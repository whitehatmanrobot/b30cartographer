     LONG           lEntries,   // number of valid array elements
    IN       ULONG          ulIndex)    // index to find within array
{
    char *szRet=NULL;

    while (lEntries)
    {
        if (pNameIndex->ulIndex == ulIndex)
        { 
            // found index, return string
            szRet = pNameIndex->szName;
            break;
        }
        pNameIndex++;
        lEntries--;
    }

    if (szRet == NULL)
    {
        // entry not found, return default string
        szRet = "unknown";
    }

    return (szRet);
}


//*************************************************************************
// vDbg_PrintDBG_NAMEINDEX
// 
// General debug print for DBG_NAMEINDEX member with ulIndex, using 
// debuglevel and leading string.
//*************************************************************************
VOID vDbg_PrintDBG_NAMEINDEX(
    LONG         DebugPrintLevel,    // debug level
    const PCHAR  pcString,           // any leading string
    char        *(szFlCaps)(ULONG),  // function pointer to stringizer function
    ULONG        ulIndex)            // index to find and to which the matching name has to be printed
{
    DISPDBG((DebugPrintLevel, "%s 0x%08x %s", pcString, ulIndex, szFlCaps(ulIndex) ));
}


//*************************************************************************
// vDbg_PrintDBG_NAMEINDEXfl
// 
// Same as vDbg_PrintDBG_NAMEINDEX but interpreting fl as bitfield and 
// calling stringizer function for every bit.
//*************************************************************************
VOID vDbg_PrintDBG_NAMEINDEXfl(
  LONG DebugPrintLevel, 
  const PCHAR pcString, 
  char *(szFlCaps)(ULONG),  // function pointer to stringizer function
  FLONG fl)
{
    ULONG ul;

    DISPDBG((DebugPrintLevel, "%s: 0x%8x ->", pcString,fl));
    for (ul=0; ul<32; ul++)
    {
        ULONG ulBit = 1<<ul;
        if (fl & ulBit)
        {
            DISPDBG(( DebugPrintLevel, "  0x%8x %s", ulBit, szFlCaps(ulBit) ));
        }
    }
}


//*************************************************************************
// DrvEscape-iEsc stuff:                        
//                                                        
// szDbg_iEscGet                                        
//   return string matching the iEsc
// aDbg_iEsc                                             
//   array defining all known escapes                            
//*************************************************************************
DBG_NAMEINDEX aDbg_iEsc[] =
{
#if _WIN32_WINNT >= 0x0500
    {3076, "MCDFUNCS"},
#else
    {3076, "RXFUNCS" },
#endif
    DBG_MAKE_NAMEINDEX(QUERYESCSUPPORT          ),
    DBG_MAKE_NAMEINDEX(OPENGL_CMD               ),
    DBG_MAKE_NAMEINDEX(OPENGL_GETINFO           ),
    DBG_MAKE_NAMEINDEX(NV_OPENGL_SET_ENABLE     ),
    DBG_MAKE_NAMEINDEX(ESC_ALLOC_CONTEXT_DMA    ),
    DBG_MAKE_NAMEINDEX(ESC_FREE_CONTEXT_DMA     ),
    DBG_MAKE_NAMEINDEX(ESC_ALLOC_CHANNEL_DMA    ),
    DBG_MAKE_NAMEINDEX(ESC_FREE_CHANNEL_DMA     ),
    DBG_MAKE_NAMEINDEX(ESC_DMA_FLOW_CONTROL     ),
    DBG_MAKE_NAMEINDEX(ESC_SET_GAMMA_RAMP       ),
    DBG_MAKE_NAMEINDEX(ESC_GET_GAMMA_RAMP       ),
    DBG_MAKE_NAMEINDEX(ESC_SET_GAMMA_RAMP_MULTI ),
    DBG_MAKE_NAMEINDEX(ESC_GET_GAMMA_RAMP_MULTI ),
    DBG_MAKE_NAMEINDEX(ESC_GET_PIXEL_FORMAT     ),

    DBG_MAKE_NAMEINDEX(NV_ESC_RM_BASE                  ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OPEN                  ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CLOSE                 ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_ROOT            ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_DEVICE          ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_CONTEXT_DMA     ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_CHANNEL_PIO     ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_CHANNEL_DMA     ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_MEMORY          ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_OBJECT          ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_FREE                  ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_DMA_PUSH_INFO         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC                 ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_VERSION        ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_GET            ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_SET            ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_UPDATE         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ARCH_HEAP             ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_DEBUG_CONTROL         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_GET_EX         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_SET_EX         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_I2C_ACCESS            ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_POWER_MANAGEMENT      ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_INTERRUPT             ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OS_CONFIG_GET         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OS_CONFIG_SET         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OS_CONFIG_GET_EX      ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OS_CONFIG_SET_EX      ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_NVWATCH               ),

    DBG_MAKE_NAMEINDEX(WNDOBJ_SETUP),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_DMA_PUSH_GO),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_ESCAPE),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY       ),
    DBG_MAKE_NAMEINDEX(ESC_NV_QUERYSET_REGISTRY_KEY              ),
    DBG_MAKE_NAMEINDEX(ESC_NV_MAP_USER	),
    DBG_MAKE_NAMEINDEX(ESC_NV_UNMAP_USER),
    DBG_MAKE_NAMEINDEX(ESC_NV_QUERY_PCI_SLOT                  ),
    DBG_MAKE_NAMEINDEX(ESC_NV_QUERY_HEAD_REFRESH_RATE         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_PRIMARY_INFO),
    DBG_MAKE_NAMEINDEX(ESC_NV_DESKMGR_ZOOMBLIT),
    DBG_MAKE_NAMEINDEX(ESC_NV_WKS_APP_SUPPORT),
};

char *szDbg_iEscGet(ULONG iEsc)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_iEsc, iEsc));
}

DBG_NAMEINDEX aDbg_NV_OPENGL_ESCAPE[] =
{
    //DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_CREATE_DRAWABLE             ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_DESTROY_DRAWABLE            ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_START_STATE_CLIENT_TRACKING ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_STOP_STATE_CLIENT_TRACKING  ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_DMA_PUSH_GO_CMD             ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY       ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SCREEN_TO_SCREEN_SRCCOPY    ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SUPPORT_ENABLED             ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_ALLOC_SHARED_MEMORY         ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_FREE_SHARED_MEMORY          ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_DISPLAY_PITCH           ),
    DBG_MAKE_NAMEINDEX(ESC_NV4_OPENGL_SWAP_BUFFERS               ),
    DBG_MAKE_NAMEINDEX(ESC_NV4_OPENGL_FLUSH                      ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_PURGE_DEVICE_BITMAP         ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_FLUSH                       ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SWAP_BUFFERS                ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_COMMAND                     ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_CPUBLIT                     ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_INIT_STATE                  ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES      ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_FREE_UNIFIED_SURFACES       ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_SURFACE_INFO            ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_DID_STATUS_CHANGE           ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_CLIP_LIST_COUNT         ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_CLIP_LIST               ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SUPPORT                     ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_REGISTER_RM_CLIENT          ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_UNREGISTER_RM_CLIENT        ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SET_DAC_BASE                ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SYNC_CHANNEL                ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SET_LAYER_PALETTE           ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_LAYER_PALETTE           ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_OVERLAY_MERGEBLIT           ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_PFD_CHECK                   ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SHARED_LIBRARY_SIZES        ),
};

char *szDbg_NV_OPENGL_ESCAPE(ULONG iEsc)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_NV_OPENGL_ESCAPE, iEsc));
}


//
// SURFOBJ stuff
//
DBG_NAMEINDEX aDbg_SURFOBJiBitmapFormat[] =
{
    DBG_MAKE_NAMEINDEX(BMF_1BPP ),
    DBG_MAKE_NAMEINDEX(BMF_4BPP ),
    DBG_MAKE_NAMEINDEX(BMF_8BPP ),
    DBG_MAKE_NAMEINDEX(BMF_16BPP),
    DBG_MAKE_NAMEINDEX(BMF_24BPP),
    DBG_MAKE_NAMEINDEX(BMF_32BPP),
    DBG_MAKE_NAMEINDEX(BMF_4RLE ),
    DBG_MAKE_NAMEINDEX(BMF_8RLE ),
#if _WIN32_WINNT >= 0x0500
    DBG_MAKE_NAMEINDEX(BMF_JPEG ),
    DBG_MAKE_NAMEINDEX(BMF_PNG  ),
#endif
};

char *szDbg_SURFOBJiBitmapFormat(ULONG iBitmapFormat)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_SURFOBJiBitmapFormat, iBitmapFormat));
}

#define STYPE_DEVBITMAP_DIB 'derf'

DBG_NAMEINDEX aDbg_SURFOBJiType[] =
{
    DBG_MAKE_NAMEINDEX(STYPE_BITMAP   ),
    DBG_MAKE_NAMEINDEX(STYPE_DEVICE   ),
    DBG_MAKE_NAMEINDEX(STYPE_DEVBITMAP),
    // the following doesn't exist!
    DBG_MAKE_NAMEINDEX(STYPE_DEVBITMAP_DIB),
};

char *szDbg_SURFOBJiType(USHORT iType)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_SURFOBJiType, (ULONG)iType));
}

char *szDbg_SURFOBJ_surf(SURFOBJ *pso)
{
    if (pso)
    {
        if(IS_DIB_DEVICEBITMAP(pso))
        {
            ASSERT(STYPE_DEVBITMAP==pso->iType);
            return(szDbg_SURFOBJiType((USHORT)STYPE_DEVBITMAP_DIB));
        }
        else
            return(szDbg_SURFOBJiType(pso->iType));
    }
    else
    {
        return "";
    }
}

//
// CLIPOBJ stuff
// 
DBG_NAMEINDEX aDbg_CLIPOBJiDComplexity[] =
{
    DBG_MAKE_NAMEINDEX(DC_TRIVIAL),
    DBG_MAKE_NAMEINDEX(DC_RECT   ),
    DBG_MAKE_NAMEINDEX(DC_COMPLEX),
};

char *szDbg_CLIPOBJiDComplexity(BYTE iDComplexity)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_CLIPOBJiDComplexity, (ULONG)iDComplexity));
}

//
// XLATEOBJ stuf
//
DBG_NAMEINDEX aDbg_XLATEOBJflXlate[] =
{
    DBG_MAKE_NAMEINDEX(XO_TRIVIAL   ),
    DBG_MAKE_NAMEINDEX(XO_TABLE     ),
    DBG_MAKE_NAMEINDEX(XO_TO_MONO   ),
#if _WIN32_WINNT >= 0x0500
    DBG_MAKE_NAMEINDEX(XO_FROM_CMYK ),
    DBG_MAKE_NAMEINDEX(XO_DEVICE_ICM),
    DBG_MAKE_NAMEINDEX(XO_HOST_ICM  ),
#endif //_WIN32_WINNT >= 0x0500
};

char *szDbg_XLATEOBJflXlate(FLONG flXlate)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_XLATEOBJflXlate, (ULONG)flXlate));
}





////////////////////////////////////////////////////////////////////////////

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\dmamacro.h ===
//******************************************************************************
//
// Module Name: DMAMACRO.H
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1998 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/
 
#define DECLARE_DMA_FIFO                                                \
    ULONG       nvDmaCount;                                             \
    ULONG       *nvDmaFifo                                              \
                         
                         
#define INIT_LOCAL_DMA_FIFO                                             \
    nvDmaCount = ppdev->nvDmaCount;                                     \
    nvDmaFifo = ppdev->nvDmaFifo;                                      \
    
#define NV_DMA_FIFO                 nvDmaFifo[nvDmaCount++]

#define UPDATE_PDEV_DMA_COUNT       ppdev->nvDmaCount  = nvDmaCount

#define UPDATE_LOCAL_DMA_COUNT      nvDmaCount = ppdev->nvDmaCount   


//******************************************************************************
// DMA Pusher Control DWORD macros
//******************************************************************************

#define NV_DMAPUSH_CONTROL_WORD(NUM_DWORD, SUBCH, METHOD_OFFSET)            \
            ( ((NUM_DWORD)<<18) | ((SUBCH)<<13) | (METHOD_OFFSET) )

#define NV_DMAPUSH_START(NUM_DWORD, SUBCH, METHOD_OFFSET)                   \
{\
            nvDmaFifo[nvDmaCount++] = NV_DMAPUSH_CONTROL_WORD(NUM_DWORD,    \
                                                              SUBCH,        \
                                                              METHOD_OFFSET); \
}                                                              

#define NV_DMAPUSH_SET_DEST_BASE(ppdev, Offset, Stride)                     \
{                                                                           \
    if ((Offset != ppdev->CurrentDestOffset) ||                             \
        (Stride != (LONG)ppdev->CurrentDestPitch))                          \
        {                                                                   \
        (ppdev->pfnSetDestBase)(ppdev, Offset, Stride);                     \
        }                                                                   \
}                                                              

#define NV_DMAPUSH_SET_SOURCE_BASE(ppdev, Offset, Stride)                   \
{                                                                           \
    if ((Offset != ppdev->CurrentSourceOffset) ||                           \
        (Stride != (LONG)ppdev->CurrentSourcePitch))                        \
        {                                                                   \
        (ppdev->pfnSetSourceBase)(ppdev, Offset, Stride);                   \
        }                                                                   \
}                                                              

//******************************************************************************
// DMAPUSH_WRITE1 macro 
//
// Writes a control dword followed by ONE method value
// 
// SUBCH            = subchannel for the methods placed into the push buffer
// METHOD_OFFSET    = offset to the first method in the subchannel to
//                    be filled in by the push buffer commands
// METHOD_VALUE     = Actual value sent to hardware
// 
//
//
// Example Usage of sending MULTIPLE method values:
//
//            NV_DMAPUSH_START(NUM_DWORDS, SUBCHANNEL, STARTING_OFFSET)
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE1
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE2
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE3
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE4
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE5
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE6
//            ... up to N methods
//
//******************************************************************************

#define NV_DMAPUSH_WRITE1(SUBCH, METHOD_OFFSET, METHOD_VALUE)               \
{\
            NV_DMAPUSH_START(1, SUBCH, METHOD_OFFSET);                      \
            nvDmaFifo[nvDmaCount++] = METHOD_VALUE;                         \
}


//******************************************************************************
// CREATE OBJECT macro
//
// SUBCHANNEL to be used
// CLASS type to create
// INSTANCE name
//******************************************************************************

//#define NV_CREATE_OBJECT(SUBCH,CLASS,INSTANCE)                              \
//{\
//            NV_DMAPUSH_WRITE1(SUBCH, NVFFF_SET_OBJECT, CLASS);              \
//            NV_DMAPUSH_WRITE1(SUBCH, NVFFF_CREATE, INSTANCE);               \
//}            

//******************************************************************************
// DESTROY OBJECT macro
//
// SUBCHANNEL to be used
// CLASS type to destroy
// INSTANCE name
//******************************************************************************

#define NV_DESTROY_OBJECT(SUBCH,CLASS,INSTANCE)                              \
{\
            NV_DMAPUSH_WRITE1(SUBCH, NVFFF_SET_OBJECT, CLASS);               \
            NV_DMAPUSH_WRITE1(SUBCH, NVFFF_DESTROY, INSTANCE);               \
}            


//******************************************************************************
// Used to reset the DMA buffer address back to the beginning
//******************************************************************************

#define NV4_JUMP(ADDR)                              (0x20000000 | (ADDR))


//******************************************************************************
//
// NV_DMAPUSH_CHECKFREE() macro
//
//
//         WRAP_FLAG = FALSE
//
//         ---------  0  
//        |         |    
//        |         |    
//        |         |    
//        |         |  
//        |         |  
//        |         |  
//        |  Push   |  
//        | Buffer  |  
//        |         |  <----- Get Ptr (Normally, the GET ptr will be 'less'
//        |         |    |             than the PUT ptr. It constantly tries
//        |         |    v             to catchup to the PUT ptr.
//        |         |
//        |         |  <----- Cached Put Ptr 
//        |         |    | 
//        |         |    v
//        |         |  <----- DMA Count (Where CPU writes data)  
//        |         |    
//         ---------    
//
//         Total Size of Push Buffer
//
//
//  ---------------------------------------------------------------------------
//
//
//         WRAP_FLAG = TRUE
//          
//         ---------  0  
//        |         |    
//        |         |    
//        |         |  <----- Cached Put Ptr (Where the last hardware PUT occurred)  
//        |         |    |                   (PUT ptr must not get ahead of the GET ptr)  
//        |         |    v
//        |         |  
//        |  Push   |  <----- DMA Count (Where CPU currently writes data)
//        | Buffer  |    |
//        |         |    |
//        |         |    v            
//        |         |                
//        |         |  <----- Get Ptr   
//        |         |    | 
//        |         |    v
//        |         |    
//        |         |    
//         ---------    
//
//         Total Size of Push Buffer
//
//
//  Current Setings:    DmaPushBufTotalSize = 512k
//    
//******************************************************************************

//******************************************************************************
// PADDING is needed because when we wraparound, 
// we sometimes insert 1 JUMP dword at the end (need an extra dword)
// (Specified in DWORDS)
//******************************************************************************


#define NV_DMAPUSH_CHECKFREE(DWORDS_NEEDED)               \
    {\
\
    /***************************************************************************/ \
    /* 2 scenarios:                                                            */ \
    /*      1) DMA Count Ptr is ahead of the Get Ptr.  (DmaCount >= Get Ptr)   */ \
    /*      2) Get Ptr is ahead of the DMA Count Ptr   (DmaCount < Get Ptr)    */ \
    /***************************************************************************/ \
\
    if (ppdev->nvDmaWrapFlag == FALSE)\
        {\
\
        /***********************************************************************/ \
        /* WRAP_FLAG = FALSE                                                   */ \
        /* Check if we need to wraparound.                                     */ \
        /* Convert PushBufTotalSize to DWORDS                                  */ \
        /***********************************************************************/ \
        if ( (nvDmaCount + DWORDS_NEEDED) > (ppdev->DmaPushBufCanUseSize) )       \
            {\
            /*******************************************************************/ \
            /* Make sure to update the PDEV copy of the DmaCount first!!       */ \
            /*******************************************************************/ \
            ppdev->nvDmaCount = nvDmaCount;\
\
            NV_DmaPush_Wrap(ppdev,(ULONG)(DWORDS_NEEDED));\
\
            /*******************************************************************/ \
            /* Make sure to update the LOCAL copy of the DmaCount!!            */ \
            /*******************************************************************/ \
            nvDmaCount=ppdev->nvDmaCount;\
            }\
\
        }\
\
    else\
\
        {\
        /***********************************************************************/ \
        /* Make sure to update the PDEV copy of the DmaCount first!!           */ \
        /***********************************************************************/ \
        ppdev->nvDmaCount = nvDmaCount;\
        /***********************************************************************/ \
        /* WRAP_FLAG = TRUE                                                    */ \
        /* We are currently 'wrapped around' (DMA Count < Get Ptr)             */ \
        /* Make sure DMA Count does NOT go past GET ptr                        */ \
        /***********************************************************************/ \
        NV_DmaPush_CheckWrapped(ppdev,(ULONG)(DWORDS_NEEDED));\
\
        /***********************************************************************/ \
        /* Make sure to update the LOCAL copy of the DmaCount!!                */ \
        /***********************************************************************/ \
        nvDmaCount=ppdev->nvDmaCount;\
        }\
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\debug.h ===
#ifndef _DEBUG_H
#define _DEBUG_H
//******************************************************************************
//
// Module Name: debug.h
//
// Commonly used debugging macros.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

extern
VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#if DBG

#ifndef _WIN32_WINNT     // If this is NT 3.5
#define OutputDebugString OutputDebugStringA
#define EngDebugBreak() DebugBreak()
#define EngDebugPrint(s1, s2, s3) \
    OutputDebugString(s1);  \
    OutputDebugString(s2);  \
    OutputDebugString(s3)
#endif                  // If this is NT 3.5

VOID DebugLog(LONG, CHAR*, ...);

#define DISPDBG(arg) DebugPrint arg
#define DISPDBGCOND(cond, arg) if (cond) DISPDBG(arg)
#define STATEDBG(level) DebugState(level)


// FNicklisch 28.09.2000: more comfortable Assert and debug functions
#ifdef i386
#define DBG_HW_INDEP_BREAK { __asm {int 3} }
#else
#define DBG_HW_INDEP_BREAK EngDebugBreak()
#endif

//old version #define RIP(x) { DebugPrint(0, x); EngDebugBreak(); }
#define RIP(text)                                                                                                            \
  {                                                                                                                          \
    ENG_TIME_FIELDS localTime;                                                                                               \
    EngQueryLocalTime(&localTime);                                                                                           \
    DebugPrint(0, "RIP %s in %s, %d at %02d:%02d on %02d.%02d.%04d",                                                         \
      text?text:"",__FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
    DBG_HW_INDEP_BREAK;                                                                                                      \
    DebugPrint(0, "RIP %s in %s, %d at %02d:%02d on %02d.%02d.%04d",                                                         \
      text?text:"",__FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
  }

//old version #define ASSERTDD(x, y) if (!(x)) RIP(y)
#define ASSERTDD(condition, text)                                                            \
  if (!(condition))                                                                          \
  {                                                                                          \
    DebugPrint(0, "ASSERTION \"%s\" failed: %s (%s,%d)",#condition, text,__FILE__,__LINE__); \
    DBGBREAK(); /* No more output (text) needed! */                                          \
    DebugPrint(0, "ASSERTION \"%s\" failed: %s (%s,%d)",#condition, text,__FILE__,__LINE__); \
  }

#define DBG_ERROR(a) DISPDBG((0, "ERROR, %s", a));

#define DBGBREAK()                                                                                              \
  {                                                                                                             \
    ENG_TIME_FIELDS localTime;                                                                                  \
    EngQueryLocalTime(&localTime);                                                                              \
    DebugPrint(0, "BREAK in %s, %d at %02d:%02d on %02d.%02d.%04d",                                             \
      __FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
    DBG_HW_INDEP_BREAK;                                                                                         \
    DebugPrint(0, "BREAK in %s, %d at %02d:%02d on %02d.%02d.%04d",                                             \
      __FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
  }

#undef ASSERT // remove if defined!
#define ASSERT(condition) ASSERTDD(condition,"")

#define NVDBG(x, y) \
    if(!(x)){\
        extern BOOL g_bNvbreak;\
        DebugPrint(0, y);\
        if(g_bNvbreak) {EngDebugBreak();}\
    }

//*************************************************************************
// DBG_NAMEINDEX stuff:
// 
// Little helper code that allows us to easily convert enums or defines to 
// strings.
//*************************************************************************

//
// Basic structure conatining a index and the corresponding string
//
typedef struct _DBG_NAMEINDEX
{
  ULONG ulIndex;
  char *szName;
} DBG_NAMEINDEX;

// This macro simplifies the presetting of nameindex arrays
// Example aDbg_DrvEscapeIEsc in debug.c 
#define DBG_MAKE_NAMEINDEX(id) {(ULONG)id, #id}

// returns the string matching to index using lEntries out of the array pNameIndex
char *szDbg_GetDBG_NAMEINDEX(IN const struct _DBG_NAMEINDEX *pNameIndex, IN LONG lEntries, IN ULONG ulIndex);

// define to simplify the call to szDbg_GetDBG_NAMEINDEX
// Use it withing the specific strinizer function: Example szDbg_GetDrvEscapeIEsc in debug.c
#define DBG_GETDBG_NAMEINDEX(array, ulIndex) szDbg_GetDBG_NAMEINDEX((array), sizeof(array)/sizeof((array)[0]), ulIndex)

// Use Instead of DISPDBG if a 
VOID vDbg_PrintDBG_NAMEINDEX(LONG DebugPrintLevel,const PCHAR pcString,char *(szFlCaps)(ULONG),ULONG ul);
#define DBG_PRINT_DBG_NAMEINDEX(lvl,str,pfn,ul)    vDbg_PrintDBG_NAMEINDEX(lvl,str,pfn,ul)

VOID vDbg_PrintDBG_NAMEINDEXfl(LONG DebugPrintLevel,const PCHAR pcString,char *(szFlCaps)(ULONG),FLONG fl);
#define DBG_PRINT_DBG_NAMEINDEX_FL(lvl,str,pfn,fl) vDbg_PrintDBG_NAMEINDEXfl(lvl,str,pfn,fl)

char *szDbg_iEscGet(ULONG iEsc);
char *szDbg_NV_OPENGL_ESCAPE(ULONG iEsc);
char *szDbg_SURFOBJiBitmapFormat(ULONG iBitmapFormat);
char *szDbg_SURFOBJiType(USHORT iType);
char *szDbg_SURFOBJ_surf(SURFOBJ *pso);
char *szDbg_CLIPOBJiDComplexity(BYTE iDComplexity);
char *szDbg_XLATEOBJflXlate(FLONG flXlate);

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

// Translate ELSA trace code:
#define DBG_TRACE_IN(a, b)  DISPDBG((a,"%s {", #b))
#define DBG_TRACE_OUT(a, b) DISPDBG((a,"}: 0x%x", (unsigned long)b))
#define DBG_LVL_SUBENTRY  5
#define DBG_LVL_RECT      15

#else

#define EngDebugBreak()
#define DISPDBG(arg)
#define DISPDBGCOND(cond, arg)
#define STATEDBG(level)
#define LOGDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)

#define DBG_ERROR(a)
#define DBGBREAK()
#define ASSERT(x)


#define NVDBG(x, y)

#define DBG_PRINT_DBG_NAMEINDEX(lvl,str,pfn,ul)
#define DBG_PRINT_DBG_NAMEINDEX_FL(lvl,str,pfn,fl)

#define DBG_TRACE_IN(a,b)
#define DBG_TRACE_OUT(a,b)
#endif

#endif // _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\cliplist.h ===
#ifndef _CLIPLIST_H
#define _CLIPLIST_H
//******************************Module*Header***********************************
// Module Name: cliplist.h
//
// management functions for struct CLIPLIST
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

LONG lClipListCopy(
  OUT       RECTL    *prclOut,
  IN        LONG      cOutMax,
  IN  const struct _CLIPLIST *pClip);

BOOL bClipListAlloc(
  IN OUT struct _CLIPLIST *pClip, // structure to fill out
  IN     LONG      cMax); // number of rects to allocate

BOOL bClipListReAlloc(
  IN OUT struct _CLIPLIST *pClip,  // structure to fill out
  IN     LONG      cNewMax);  // number of rects to allocate

BOOL bClipListFree(
  IN OUT struct _CLIPLIST *pClip);

LONG lClipListPixelCount(struct _CLIPLIST *pClip);

VOID vClipListBoundsCalculate(struct _CLIPLIST *pClip);

BOOL bClipListCheck(
  IN  const struct _CLIPLIST *pClip);
#endif // _CLIPLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\drawescape.c ===
//*****************************Module*Header******************************
//
// Module Name: drawescape.c
//
// Supports the API DrvDrawEscape entry
//
// FNicklisch 14.09.00: New: added from ELSA code
//   Added this to implement the roller tool support. I use this entry because 
//   the code and the tool were already available and it was the fastest
//   way to get it running. 
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files
#include "precomp.h"
#include "driver.h"
#include "nv32.h"

#include "dmamacro.h"
#include "nv32.h"
#include "nvsubch.h"

#ifdef IA64
    //
    // Disable the scroll interface for IA64 as we don't have the tool and
    // I don't know how dwParam in the DCICOMMAND is defined
    //
    #undef ROLLER_TOOL_SUPPORT
#else
    #include <Dciddi.h>
#endif


// export header file
#include "drawescape.h"

//*****************************************************************************
// Externs
//*****************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

//
// 
//
static BOOL ulRollerToolEscape(PPDEV ppdev, VOID* pv);


//
// Driver Entry point
//
ULONG APIENTRY DrvDrawEscape (
    SURFOBJ *pso,
    ULONG    iEsc,
    CLIPOBJ *pco,
    RECTL   *prcl,
    ULONG    cjIn,
    PVOID    pvIn)
{
    ULONG ulRet = 0; // unsuported escape
    PPDEV ppdev = (PPDEV)pso->dhpdev;

    prcl = prcl; // unreferenced formal parameter
    pco  = pco;  // unreferenced formal parameter

    switch(iEsc)
    {
        #ifdef ROLLER_TOOL_SUPPORT
        case DCICOMMAND:
        {
            DCICMD *pDciCmd = (DCICMD*)pvIn;

            if (   (cjIn < sizeof(DCICMD)) 
                || (pDciCmd->dwVersion != DCI_VERSION) )
            {
                ulRet = (ULONG)-1; // error
                break;
            }

            switch (pDciCmd->dwCommand)
            {
            case 0xEEEE0000: // EDDESCAPE==ELSA defined service escape
                ulRet = ulRollerToolEscape(ppdev, (PVOID)pDciCmd->dwParam1);
                break;
            }
            break;
        }
        #endif // ROLLER_TOOL_SUPPORT
    }

    return ulRet;
}


#ifdef ROLLER_TOOL_SUPPORT
//
// Downstripped version of the ELSA DrawEscape support function. 
// The remaining code supports the roller tool.
//

//
// ELSA specific command group
//
#define EDDESC_SCROLL               (0xEDD00000 | 0x00000012)

//
// scrolling into offscreen (debug purposes)
//
typedef struct _EDDESC_SCROLL_DATA
{
  DWORD dwSize;             // = sizeof(struct tagSCROLL_DATA)
  DWORD dwCommand;          // = EDDESC_SCROLL
  LONG  cyLines;            // # of lines vertical panning
} EDDESC_SCROLL_DATA;


//
// ulRollerToolEscape was spawned from a more complex
// escape interface, but only the EDDESC_SCROLL is supported
// in the nVidia code.
//
static BOOL ulRollerToolEscape(PPDEV ppdev, VOID* pv)
{
    BOOL                bRet    = FALSE; // unsupported escape==default error exit
    EDDESC_SCROLL_DATA *pScroll = pv;

    if (   (NULL != pScroll)
        && (NULL != ppdev)
        && (EDDESC_SCROLL==pScroll->dwCommand)
        && (pScroll->dwSize == sizeof(EDDESC_SCROLL_DATA)) )
    {
        static LONG ActualLine = 0; // remember this as last address!

        // CSchalle 12/3/98 2:43:28 PM: want to see instance memory, too
        ULONG cbTotalRAM = (ppdev->cbFrameBuf + (4 *1024*1024 - 1)) & ~(4 *1024 *1024 - 1);
        LONG  lLastLine  = cbTotalRAM / ppdev->lDelta;
        ULONG i=0;
        ULONG ulMaxDacs;

        DECLARE_DMA_FIFO;

        INIT_LOCAL_DMA_FIFO;


        ActualLine += pScroll->cyLines;

        // stop scrolling up at top
        if (ActualLine < 0)  
            ActualLine = 0;

        // stop scrolling down at bottom - screem height
        if (ActualLine + ppdev->cyScreen > lLastLine) 
            ActualLine = lLastLine - ppdev->cyScreen;

        if (ppdev->ulDesktopMode & NV_CLONE_DESKTOP)
        {
            // In clone mode only do it for first monitor by now as
            // it seems to be more convenient for debugging

            ulMaxDacs = 1;
        }
        else
        {
            // In a multimon environment scroll all dacs
            ulMaxDacs = ppdev->ulNumberDacsActive;
        }

        //doesn't work for multiple dacs...    for (i = 0; i < ulMaxDacs; i++)
        {
            ULONG ulHead;
            ulHead = ppdev->ulDeviceDisplay[i];

            // ELSA method of setting the display start address 
            // replaced by code taken from OglRestoreDacs.

            NV_DMAPUSH_CHECKFREE( ((ULONG)(10)));
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,
                NV_VIDEO_LUT_CURSOR_DAC + ulHead);

            ASSERT(0==i); // notification fails for multiple dacs, don't know why!
            while (((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)* sizeof(NvNotification)])))->status == NV_IN_PROGRESS)
            {
                ;
            }

            ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*
                                   sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_OFFSET(0), 
                ActualLine * ppdev->lDelta);
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_FORMAT(0), 
                ppdev->lDelta | NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31);
        }
        // Restore to 1st DAC
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0), NV_VIDEO_LUT_CURSOR_DAC);

        UPDATE_PDEV_DMA_COUNT;

        //******************************************************************
        // Send data on thru to the DMA push buffer
        //******************************************************************

        NV4_DmaPushSend(ppdev);

        bRet = TRUE;
    }

    return bRet;
}

// End of drawescape.c
#endif //ROLLER_TOOL_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

/**************************************************************************
 *                                                                        *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.          *
 *                                                                        *
 **************************************************************************/

#include "precomp.h"
#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);
                                                // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ddraw.c ===
//******************************************************************************
//
// Copyright (c) 1995-1996 Microsoft Corporation
//
// Module Name:
//
//     DDRAW.C
//
// Abstract:
//
//     Implements all the DirectDraw components for the driver.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"
#include "nvPriv.h"
#include "nvReg.h"

#include "ddminint.h"

#include "nvalpha.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "nvProcMan.h"
    #include "ddmini.h"
#endif

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"
#include "nvcm.h"

#include "oglutils.h"

#ifdef NVD3D

#include "dx95type.h"
#define _NO_COM
#include "ddkernel.h"
#undef _NO_COM
#define NV_DD_DMA_PUSH_BUFFER_SIZE      (2*1024*1024)
                                        // This is a temporary default til we get the registry stuff going.

#ifndef _WIN64
extern DWORD __stdcall GetDriverInfo32(LPDDHAL_GETDRIVERINFODATA lpData);
#endif // D3D is not 64 bit code clean , skip for now...

// D3D Callbacks
extern DWORD __fastcall D3DClear2( LPD3DHAL_CLEAR2DATA);
extern DWORD __fastcall D3DValidateTextureStageState( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
extern DWORD __fastcall D3DDrawPrimitives2( LPD3DHAL_DRAWPRIMITIVES2DATA);
extern DWORD __fastcall D3DSetRenderTarget32(LPD3DHAL_SETRENDERTARGETDATA);


ULONG a = (ULONG)DDERR_UNSUPPORTED;
ULONG b = (ULONG)DDERR_GENERIC;
ULONG c = (ULONG)DDERR_OUTOFCAPS;

//extern DDHAL_DDKERNELCALLBACKS KernelCallbacks;
extern DDHAL_DDCOLORCONTROLCALLBACKS ColorControlCallbacks;
DDKERNELCAPS KernelCaps =
{
    sizeof( DDKERNELCAPS ),
    DDKERNELCAPS_SKIPFIELDS|DDKERNELCAPS_SETSTATE|
        DDKERNELCAPS_LOCK|DDKERNELCAPS_FLIPVIDEOPORT|DDKERNELCAPS_FLIPOVERLAY| \
        DDKERNELCAPS_FIELDPOLARITY,
    DDIRQ_DISPLAY_VSYNC|DDIRQ_VPORT0_VSYNC
};

DWORD WINAPI DdGetDriverInfo(struct _DD_GETDRIVERINFODATA *);
VOID nvTexDeSwizzle16BPP(int, int, int);
VOID nvTexSwizzle16BPP(int, int, int);

//*******************************************************************
// These functions initialize the driver caps and callbacks. They
// can be found in the common DX driver source.
// nvBuildDDHALInfo32   - ddDrv.cpp
//*******************************************************************
//BOOL nvBuildDDHALInfo32  (GLOBALDATA *pDriverData);

//
// One time DX6 Init/Destroy code. This is the "16 bit" ddraw init code
// from the Win9x GDI driver. Found in
// $(BUILDDIR)\main\drivers\common\nvX\src\ddmini16.c.
//
ULONG ddEnable(PDEV *lpDevice);

#else   // !NVD3D
DWORD __stdcall DriverInit_NT4(GLOBALDATA * pDriverData);
DWORD WINAPI GetDriverInfo32(struct _DD_GETDRIVERINFODATA *lpData);
#endif // #ifdef NVD3D

#ifdef NVPE
extern const DDHAL_DDVIDEOPORTCALLBACKS LPBVideoPortCallbacks;
extern const DDHAL_DDKERNELCALLBACKS KernelCallbacks;
extern const DDVIDEOPORTCAPS g_ddNVideoPortCaps;
///// H.AZAR: (02/29/2000): this function is defined in nvpkrnl.c (nvpe.lib)
#ifdef __cplusplus
extern "C" {
#endif
BOOL __stdcall NVPIsVPEEnabled(GLOBALDATA *pDriverData, DWORD hDriver);
#ifdef __cplusplus
}
#endif // __cplusplus
#endif // NVPE

/*
 * IN_VBLANK should be replaced by a test to see if the hardware is currently
 * in the vertical blank
 */
#define IN_VBLANK               FALSE
#define IN_DISPLAY              TRUE

/*
 * CURRENT_VLINE should be replaced by a macro to retrieve the current
 * scanline
 */
#define CURRENT_VLINE   (ppdev->pfnGetScanline(ppdev))

// Defines we'll use in the surface's 'dwReserved1' field:

#define DD_RESERVED_DIFFERENTPIXELFORMAT    0x0001


// Worst-case possible number of FIFO entries we'll have to wait for in
// DdBlt for any operation:

#define DDBLT_FIFO_COUNT    9

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += surf->yHint;                   \
    x += surf->xHint;                   \
}

//******************************************************************************
// External declarations
//******************************************************************************

//******************************Public*Routine**********************************
//
// Function: DdMapMemory()
//
//      This is a new DDI call specific to Windows NT that is used to map
//      or unmap all the application modifiable portions of the frame buffer
//      into the specified process's address space.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD DdMapMemory(
                 PDD_MAPMEMORYDATA lpMapMemory)

    {
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
        {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        //**********************************************************************
        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:
        //**********************************************************************

        ShareMemory.RequestedVirtualAddress = 0;

        //**********************************************************************
        // We map in starting at the top of the frame buffer:
        //**********************************************************************

        ShareMemory.ViewOffset = 0;

        //**********************************************************************
        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.
        //
        // NOTE: AdapterMemorySize was adjusted in NVValidateModes
        //       to compensate for INSTANCE memory in offscreen memory.
        //       That is, Hash Table, Fifo Context, and Run Out information
        //       is stored in PRAMIN memory, which also exists in offscreen memory.
        //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
        //       To make a long story short, AdapterMemorySize was adjusted by
        //       64k in NVValidateModes (The last 64k of VRAM contains Instance memory).
        //       See NVValidateModes for more comments.
        //**********************************************************************

        ShareMemory.ViewSize
        = ROUND_UP_TO_64K(ppdev->cbFrameBuf);

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
            {
            DISPDBG((2, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
            return (DDHAL_DRIVER_HANDLED);
            }

        // Be aware of IA64 when doing ptr arithmetic !!
        // fpProcess is of type FLATPTR, VirtualAddres is PVOID
        lpMapMemory->fpProcess = (FLATPTR) ShareMemoryInformation.VirtualAddress;

#if _WIN32_WINNT < 0x0500
        // we need this to count Ddraw Clients
        NV_OglDDrawSurfaceCreated(ppdev);
#endif
        }

    else

        {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
            {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
            }

#if _WIN32_WINNT < 0x0500
        // we need this to count Ddraw Clients
        NV_OglDDrawSurfaceDestroyed(ppdev);
#endif
        }

    lpMapMemory->ddRVal = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
    }

#ifndef NVD3D
/*
 * GetScanLine32
 */
DWORD GetScanLine32(
                   PDD_GETSCANLINEDATA lpGetScanLine )
    {
    PDEV*   ppdev;

    ppdev = lpGetScanLine->lpDD->dhpdev;

    /*
     * If a vertical blank is in progress the scan line is in
     * indeterminant. If the scan line is indeterminant we return
     * the error code DDERR_VERTICALBLANKINPROGRESS.
     * Otherwise we return the scan line and a success code
     */
    if (ppdev->pfnVBlankIsActive(ppdev))
        {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
        }
    else
        {
        lpGetScanLine->dwScanLine = ppdev->pfnGetScanline(ppdev);
        lpGetScanLine->ddRVal = DD_OK;
        }
    return DDHAL_DRIVER_HANDLED;

    } /* GetScanLine32 */
#endif // #ifndef NVD3D

//******************************Public*Routine**********************************
//
// Function: DdGetFlipStatus
//
//      If the display has gone through one refresh cycle since the flip
//      occurred, we return DD_OK.  If it has not gone through one refresh
//      cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
//      is still busy "drawing" the flipped page.   We also return
//      DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
//      to know if they could flip yet.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD DdGetFlipStatus(
                     PDD_GETFLIPSTATUSDATA lpGetFlipStatus)

    {
    PDEV*   ppdev;
    BYTE*   pjMmBase;
    FNGRAPHICSENGINEBUSY*  pfnGraphicsEngineBusy;

    ppdev    = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;

    //**************************************************************************
    // Init chip specific function pointers
    //**************************************************************************

    pfnGraphicsEngineBusy = ppdev->pfnGraphicsEngineBusy;


    //**************************************************************************
    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem:
    //**************************************************************************

    lpGetFlipStatus->ddRVal = ppdev->pfnUpdateFlipStatus(ppdev, 0);

    //**************************************************************************
    // Check if the bltter is busy if someone wants to know if they can
    // flip:
    //**************************************************************************

    if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
        {
        if ( (lpGetFlipStatus->ddRVal == DD_OK) && (pfnGraphicsEngineBusy(ppdev)) )
            {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
        }

    return (DDHAL_DRIVER_HANDLED);
    }

//******************************Public*Routine**********************************
//
// Function: DdWaitForVerticalBlank
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD DdWaitForVerticalBlank(
                            PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)

    {
    PDEV*   ppdev;
    FNWAITWHILEVBLANKACTIVE*    pfnWaitWhileVBlankActive;
    FNWAITWHILEDISPLAYACTIVE*   pfnWaitWhileDisplayActive;
    FNVBLANKISACTIVE*           pfnVBlankIsActive;

    ppdev    = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;

    //**************************************************************************
    // Init chip specific function pointers
    //**************************************************************************

    pfnWaitWhileVBlankActive = ppdev->pfnWaitWhileVBlankActive;
    pfnWaitWhileDisplayActive = ppdev->pfnWaitWhileDisplayActive;
    pfnVBlankIsActive = ppdev->pfnVBlankIsActive;


    switch (lpWaitForVerticalBlank->dwFlags)
        {
        case DDWAITVB_I_TESTVB:

            //******************************************************************
            // If TESTVB, it's just a request for the current vertical blank
            // status:
            //******************************************************************

            if (pfnVBlankIsActive(ppdev))
                lpWaitForVerticalBlank->bIsInVB = TRUE;
            else
                lpWaitForVerticalBlank->bIsInVB = FALSE;

            lpWaitForVerticalBlank->ddRVal = DD_OK;

            return (DDHAL_DRIVER_HANDLED);

        case DDWAITVB_BLOCKBEGIN:

            //******************************************************************
            // If BLOCKBEGIN is requested, we wait until the vertical blank
            // is over, and then wait for the display period to end:
            //******************************************************************

            pfnWaitWhileVBlankActive(ppdev);
            pfnWaitWhileDisplayActive(ppdev);

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            return (DDHAL_DRIVER_HANDLED);

        case DDWAITVB_BLOCKEND:

            //******************************************************************
            // If BLOCKEND is requested, we wait for the vblank interval to end:
            //******************************************************************

            pfnWaitWhileDisplayActive(ppdev);
            pfnWaitWhileVBlankActive(ppdev);

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }

    return (DDHAL_DRIVER_NOTHANDLED);
    }

#ifdef IS_WINNT4
//******************************Public*Routine**********************************
//
// Function: DdCanCreateSurface
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD __stdcall DdCanCreateSurface(PDD_CANCREATESURFACEDATA lpCanCreateSurface )
    {
    DWORD               caps;
    LPDDSURFACEDESC     lpDDSurface;
    int                 i;
    PDEV *ppdev = (PDEV *) lpCanCreateSurface->lpDD->dhpdev;

    /*
     * NOTES:
     *
     * This entry point is called after parameter validation but before
     * any object creation.   You can decide here if it is possible for
     * you to create this surface.  For example, if the person is trying
     * to create an overlay, and you already have the maximum number of
     * overlays created, this is the place to fail the call.
     *
     * You also need to check if the pixel format specified can be supported.
     *
     * lpCanCreateSurface->bIsDifferentPixelFormat tells us if the pixel format of the
     * surface being created matches that of the primary surface.  It can be
     * true for Z buffer and alpha buffers, so don't just reject it out of
     * hand...
     */
    DISPDBG((2, "CanCreateSurface, lpCanCreateSurface->lpDD=%08lx", lpCanCreateSurface->lpDD ));
    DISPDBG((2, "    lpCanCreateSurface->lpDDSurfaceDesc=%08lx", lpCanCreateSurface->lpDDSurfaceDesc ));

    lpDDSurface = lpCanCreateSurface->lpDDSurfaceDesc;

    caps = lpDDSurface->ddsCaps.dwCaps;

    if (caps & (DDSCAPS_MODEX | DDSCAPS_PALETTE))
        return DDHAL_DRIVER_NOTHANDLED;

    if (ppdev->cBitsPerPel == 8)
        {
        if (caps & DDSCAPS_ALPHA)
            return DDHAL_DRIVER_NOTHANDLED;
        }

    /*
     * check pixel format.   Don't allow pixel formats that aren't
     * the same, unless we have a valid fourcc code, an overlay,
     * an alpha surface, or z buffer.
     */
    if ( lpCanCreateSurface->bIsDifferentPixelFormat )
        {
        DISPDBG((2, "    different pixel format!" ));

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_FOURCC )
            {
            if (ppdev->cBitsPerPel == 8)
                {
                /* We don't support RGB FOURCCs in 8bpp mode */
                if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                    }
                }

            DISPDBG((2, "    FourCC requested (%4.4hs, 0x%08lx)",
                     (LPSTR) &lpDDSurface->ddpfPixelFormat.dwFourCC,
                     lpDDSurface->ddpfPixelFormat.dwFourCC ));
            for ( i=0; i < NV_MAX_FOURCC; i++ )
                {
                if ( lpDDSurface->ddpfPixelFormat.dwFourCC == ppdev->fourCC[i] )
                    {
                    DISPDBG((2, "    FOURCC=%4.4hs", (LPSTR) &ppdev->fourCC[i] ));
                    if (caps & DDSCAPS_OVERLAY)
                        {
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YV12) &&
//                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_420i) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IF09) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YVU9) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV32) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV31))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        if ((ppdev->cBitsPerPel == 32) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IF09))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                            (lpDDSurface->dwBackBufferCount > 1) &&
                            ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_UYVY) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YUY2)))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        if (ppdev->dwOverlaySurfaces > 0)
                            {
                            lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        if (ppdev->bHwVidOvl == FALSE)
                            {
                            lpCanCreateSurface->ddRVal = DDERR_NOOVERLAYHW;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        // NB: Unlike win2k/Dx8, we HAVE to fail based on bandwidth in canCreateSurface.  If we do it in
                        //     createSurface we cause Windows Media player to fault.  It's probably their bug, but it's
                        //     easy enough to reject in both cases.
                        if (VppGetVideoScalerBandwidthStatus(&ppdev->pDriverData->vpp, (WORD)lpDDSurface->dwWidth) == FALSE)
                            {
                            lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        }
                    else if (caps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN))
                        {
                        /* Front end YUV support cannot reformat data so Indeo is not supported */
                        /* Currently also disallowing front end YUV420 since YUYV or UYVY
                           should do ok when not enough backend bandwidth is available */
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IF09) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YVU9) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IV32) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IV31) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YV12) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_420i))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        /* Front end YUV support not available in 8bit indexed mode */
                        if (ppdev->cBitsPerPel == 8)
                            {
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        }

                    if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0)
                        {
                        if (((ppdev->cBitsPerPel == 16) &&
                             (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_16)) ||
                            ((ppdev->cBitsPerPel == 32) &&
                             (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_32)))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        }

                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                    }
                }
            }
        else if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_RGB )
            {

            /* Don't allow 3D devices in 8bpp or 32bpp */
            if (caps & DDSCAPS_3DDEVICE)
                {
                if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 8) ||
                    (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32))
                    {
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                    }
                }

            if (caps & (DDSCAPS_TEXTURE | DDSCAPS_OFFSCREENPLAIN))
                {
                /* Don't allow textures in 8bpp or 32bpp */
                if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
                    {
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_NOTHANDLED;
                    }
#if 0
                if (lpDDSurface->ddpfPixelFormat.dwFlags & PALETTEINDEXED8)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                    }
#endif

                if (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                    {
                        // ELAU NV3 cannot handle 565 format
                        if(lpDDSurface->ddpfPixelFormat.dwGBitMask == 0x7e0)
                        {
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                        }
                        /* accept all 16 bpp texture formats */
                        lpCanCreateSurface->ddRVal = DD_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }
                }

            /* For now, support z buffers in video memory only when our primary rendering depth is 16 bpp */
            if (caps & DDSCAPS_ZBUFFER)
                {
                if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
                    return DDHAL_DRIVER_NOTHANDLED;

                if (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                    {
                    /* accept all 16 bpp z buffer formats */
                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                    }
                }

            /* We don't support any other RGB surfaces not in our native format */
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }
        else if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER )
            {
            /* For now, support z buffers in video memory only when our primary rendering depth is 16 bpp */
            if (caps & DDSCAPS_ZBUFFER)
                {
                if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
                    return DDHAL_DRIVER_NOTHANDLED;
                }

            DISPDBG((2, "Z BUFFER OK!" ));
            lpCanCreateSurface->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
            }

        /*
         * can't handle any other kinds of different fourcc or RGB overlays
         */
        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
        }

    if (caps & DDSCAPS_MODEX)
        {
        DISPDBG((2, "    Mode X requested" ));
        lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDMODE;
        return DDHAL_DRIVER_HANDLED;
        }

    /* Don't allow 3D devices in 8bpp or 32bpp (except for primary surface access, fixes Jedi Knight) */
    if ((caps & DDSCAPS_3DDEVICE) && (!(caps & DDSCAPS_PRIMARYSURFACE)))
        {
        if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (caps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE))
        {
        DISPDBG((2, "    Frontbuffer requested" ));

        if (caps & DDSCAPS_OVERLAY)
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }

        if (caps & DDSCAPS_FLIP)
            {
            if (lpDDSurface->dwHeight > (unsigned long)ppdev->cyScreen)
                {
                if (lpDDSurface->dwFlags & DDSD_HEIGHT)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                    return DDHAL_DRIVER_HANDLED;
                    }
                else
                    {
                    lpDDSurface->dwHeight = (unsigned long)ppdev->cyScreen;
                    }

                }
            if (lpDDSurface->dwWidth > (unsigned long)ppdev->cxScreen)
                {
                if (lpDDSurface->dwFlags & DDSD_WIDTH)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                    return DDHAL_DRIVER_HANDLED;
                    }
                else
                    {
                    lpDDSurface->dwWidth = (unsigned long)ppdev->cxScreen;
                    }
                }
            }
        lpCanCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

        }
    else if (caps & DDSCAPS_BACKBUFFER)
        {
        DISPDBG((2, "    Backbuffer requested" ));
        if (caps & DDSCAPS_OVERLAY)
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }

        if (caps & DDSCAPS_FLIP)
            {
            if (lpDDSurface->dwHeight > (unsigned long)ppdev->cyScreen)
                {
                if (lpDDSurface->dwFlags & DDSD_HEIGHT)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                    return DDHAL_DRIVER_HANDLED;
                    }
                else
                    {
                    lpDDSurface->dwHeight = (unsigned long)ppdev->cyScreen;
                    }

                }
            if (lpDDSurface->dwWidth > (unsigned long)ppdev->cyScreen)
                {
                if (lpDDSurface->dwFlags & DDSD_WIDTH)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                    return DDHAL_DRIVER_HANDLED;
                    }
                else
                    {
                    lpDDSurface->dwWidth = (unsigned long)ppdev->cBitsPerPel;
                    }
                }
            }
        lpCanCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

        }
    else if (caps & DDSCAPS_TEXTURE)
        {
        /* Don't allow textures in 8bpp or 32bpp */
        if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }
#ifndef NVD3D
        lpDDSurface->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
        lpDDSurface->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
#endif
        lpCanCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

        }
    else if (caps & DDSCAPS_OFFSCREENPLAIN)
        {
        DISPDBG((2, "    Can create offscreen requested" ));

        if (caps & DDSCAPS_VIDEOMEMORY)
            {
            if (caps & DDSCAPS_OVERLAY)
                {
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return DDHAL_DRIVER_HANDLED;
                }

            if (caps & DDSCAPS_FLIP)
                {
                if (lpDDSurface->dwHeight > (unsigned long)ppdev->cyScreen)
                    {
                    if (lpDDSurface->dwFlags & DDSD_HEIGHT)
                        {
                        lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    else
                        {
                        lpDDSurface->dwHeight = (unsigned long)ppdev->cyScreen;
                        }
                    }
                if (lpDDSurface->dwWidth > (unsigned long)ppdev->cxScreen)
                    {
                    if (lpDDSurface->dwFlags & DDSD_WIDTH)
                        {
                        lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    else
                        {
                        lpDDSurface->dwWidth = (unsigned long)ppdev->cxScreen;
                        }

                    }
                }
            }
        lpCanCreateSurface->ddRVal = DD_OK;
        DISPDBG((2, "    Can create offscreen granted" ));
        return DDHAL_DRIVER_HANDLED;

        }
    else if (caps & (DDSCAPS_FLIP | DDSCAPS_VIDEOMEMORY | DDSCAPS_ZBUFFER))
        {
        DISPDBG((2, "    Can create flipping surface requested" ));

        if (caps & DDSCAPS_OVERLAY)
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }
        DISPDBG((2, "    Can create flipping surface available" ));
        lpCanCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

        }
    else
        if (caps & DDSCAPS_SYSTEMMEMORY)
        {
        lpCanCreateSurface->ddRVal = DD_OK;
        DISPDBG((2, "    Can create system memory requested" ));
        return DDHAL_DRIVER_HANDLED;
        }

    return DDHAL_DRIVER_NOTHANDLED;

    } /* DdCanCreateSurface */

//******************************Public*Routine**********************************
//
// Function: DdCreateSurface
//
// Routine Description:
//
//    Creates an off-screen surface.
//
//    We use the Millennium's own off-screen heap manager instead of DirectDraw's
//    so that the OpenGL MCD and DirectDraw parts can coexist -- at the time of this
//    writing NT has no support for call-backs from the driver to allocate memory,
//    which we need to do to allocate the MCD's back buffer and Z-buffer.  So
//    we simply manage all of off-screen memory ourselves.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
DWORD DdCreateSurface(
                     PDD_CREATESURFACEDATA lpCreateSurface)

    {
    PDEV*               ppdev;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;
    DD_SURFACE_GLOBAL*  lpSurfaceGlobal;
    LPDDSURFACEDESC     lpSurfaceDesc;
    DWORD               dwByteCount;
    ULONG               lPitch;
    DWORD               dwHeight;
    NvU16               wWidth;
    LONG                wHeight;
    LONG                adjustedHeight;
    FLATPTR             fpVidMem;
    PDD_SURFACE_LOCAL   *powner;
    ULONG               dwBlockSize;
    ULONG   index;
    ULONG   memType;
    NvU32 dwStatus;
#ifdef DEBUG
    char                        fourCCStr[5];
#endif // DEBUG

    //**************************************************************************
    // Get pointer to device
    //**************************************************************************

    ppdev = (PDEV*) lpCreateSurface->lpDD->dhpdev;

    //**************************************************************************
    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:
    //**************************************************************************
    powner = lpCreateSurface->lplpSList;
    lpSurfaceLocal  = lpCreateSurface->lplpSList[0];
    lpSurfaceGlobal  = lpCreateSurface->lplpSList[0]->lpGbl;
    lpSurfaceDesc   = lpCreateSurface->lpDDSurfaceDesc;

    //**************************************************************************
    // Get width and height
    //**************************************************************************

    wWidth  = (WORD)lpSurfaceGlobal->wWidth;    // wWidth is actually an unsigned long despite name
    wHeight = lpSurfaceGlobal->wHeight;

    //**************************************************************************
    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.
    //**************************************************************************

    ASSERTDD(lpSurfaceGlobal->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
             "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    //**************************************************************************
    // Determine type and format of surface prior to allocation.
    //**************************************************************************

    if (
       //(lpSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
       (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC) )
    {
        DPF( "NVDD: FOURCC surface requested" );

        if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
             (VppGetVideoScalerBandwidthStatus(&ppdev->pDriverData->vpp, wWidth) == FALSE))
        {
            DPF( "NVDD: Insufficient video bandwidth, overlay creation refused.");
            lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
            goto CREATE_HANDLED;
        }

        //**************************************************************************
        // we know the FOURCC code is OK, because we validated it
        // during CanCreateSurface.   Compute a block size based
        // on the code, and allocate system memory for it.
        //**************************************************************************
        switch ( lpSurfaceLocal->lpGbl->ddpfSurface.dwFourCC )
            {
            case FOURCC_RGB0:
                lpSurfaceGlobal->ddpfSurface.dwRGBBitCount = ppdev->cBitsPerPel;
                if (ppdev->cBitsPerPel == 8)
                    {
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask = 0;
                    lpSurfaceGlobal->ddpfSurface.dwGBitMask = 0;
                    lpSurfaceGlobal->ddpfSurface.dwBBitMask = 0;
                    lpSurfaceGlobal->ddpfSurface.dwFlags |= DDPF_PALETTEINDEXED8;
                    }
                else if (ppdev->cBitsPerPel == 16)
                    {
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask = 0x00007C00;
                    lpSurfaceGlobal->ddpfSurface.dwGBitMask = 0x000003E0;
                    lpSurfaceGlobal->ddpfSurface.dwBBitMask = 0x0000001F;
                    }
                else if (ppdev->cBitsPerPel == 32)
                    {
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask = 0x00FF0000;
                    lpSurfaceGlobal->ddpfSurface.dwGBitMask = 0x0000FF00;
                    lpSurfaceGlobal->ddpfSurface.dwBBitMask = 0x000000FF;
                    }
                lpSurfaceGlobal->ddpfSurface.dwRGBAlphaBitMask = 0;
#ifdef DEBUG
                fourCCStr[0] = (char)lpSurfaceGlobal->ddpfSurface.dwFourCC & 0xFF;
                fourCCStr[1] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 8) & 0xFF;
                fourCCStr[2] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 16) & 0xFF;
                fourCCStr[3] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 24) & 0xFF;
                fourCCStr[4] = 0;
                DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

                lPitch = wWidth * (ppdev->cBitsPerPel >> 3);
                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

                if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    NVHEAP_ALLOC(dwStatus,fpVidMem, lPitch * wHeight, TYPE_OVERLAY);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,fpVidMem, lPitch * wHeight, TYPE_OVERLAY);
                    }
                    if (dwStatus==0)
                        {
                        //**********************************************************************
                        // Flip surfaces, detected by surface requests that are the
                        // same size as the current display, have special
                        // considerations: they must live in the first four megabytes
                        // of video memory:
                        //**********************************************************************

                        lpSurfaceGlobal->yHint        = (fpVidMem / ppdev->lDelta);
                        lpSurfaceGlobal->xHint        = ((fpVidMem - (lpSurfaceGlobal->yHint * ppdev->lDelta))/ ppdev->cjPelSize) ;
                        lpSurfaceGlobal->fpVidMem     = fpVidMem;
                        lpSurfaceGlobal->lPitch       = lPitch;

                        lpSurfaceDesc->lPitch   = lPitch;
                        lpSurfaceDesc->dwFlags |= DDSD_PITCH;


                        //**********************************************************************
                        // We handled the creation entirely ourselves, so we have to
                        // set the return code and return DDHAL_DRIVER_HANDLED:
                        //**********************************************************************

                        lpCreateSurface->ddRVal = DD_OK;
                        lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                        lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                        break;
                        }
                    }

                //**********************************************************************
                // Tell DDRAW to allocate user mem for this surface.
                //**********************************************************************
                lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
                lpSurfaceGlobal->dwUserMemSize = lPitch * wHeight;
                lpSurfaceDesc->lPitch = lPitch;
                lpSurfaceDesc->dwFlags  |= DDSD_PITCH;
                lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                return (DDHAL_DRIVER_NOTHANDLED);
                break;

            case FOURCC_IF09:
            case FOURCC_YVU9:
            case FOURCC_IV32:
            case FOURCC_IV31:

                if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (ppdev->dwOverlaySurfaces > 0))
                    {
                    if ((ppdev->dwOverlayOwner != (DWORD)powner) ||
                        (ppdev->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES))
                        {
                        lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                        goto CREATE_HANDLED;
                        }
                    }

                /* First allocate enough video memory for YUY2 overlay pixel area */
                lPitch = ((lpSurfaceGlobal->wWidth + 1) & 0xFFFFFFFE) << 1;

                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                /* pad with an extra scanline */
                dwBlockSize = (lPitch * (DWORD)lpSurfaceGlobal->wHeight);
                /* now allocate enough video memory for the Indeo part of the surface */
                lPitch = lpSurfaceGlobal->wWidth;
                /* allow extra room for block skip bits between Indeo portion of surface and YUY2 portion */
                dwBlockSize +=
                ((lPitch * ((DWORD)lpSurfaceGlobal->wHeight * 10L)) >> 3);
                /* Force block to be properly aligned */
                dwBlockSize =
                (dwBlockSize + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 9;
                lpSurfaceGlobal->ddpfSurface.dwYBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwUBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwVBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwYUVAlphaBitMask = 0;
#ifdef DEBUG
                fourCCStr[0] = (char)lpSurfaceGlobal->ddpfSurface.dwFourCC & 0xFF;
                fourCCStr[1] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 8) & 0xFF;
                fourCCStr[2] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 16) & 0xFF;
                fourCCStr[3] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 24) & 0xFF;
                fourCCStr[4] = 0;
                DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG

                lpSurfaceGlobal->lPitch = lPitch;
                lpSurfaceGlobal->fpVidMem = ppdev->ulPrimarySurfaceOffset;
                lpSurfaceGlobal->dwReserved1 = 0;
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

                if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    }

                    if (dwStatus==0)
                        {
                        ppdev->DDrawVideoSurfaceCount++;
                        lpSurfaceGlobal->fpVidMem = fpVidMem;
                        lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                        lpSurfaceLocal->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);

                        if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                            {
                            index = 0;
                            while ((ppdev->dwOverlaySurfaceLCL[index] != 0) &&
                                   (index < NV_MAX_OVERLAY_SURFACES))
                                index++;
                            ppdev->dwOverlaySurfaceLCL[index] = (DWORD) lpSurfaceLocal;
                            ppdev->dwOverlayOwner = (DWORD)powner;
                            ppdev->dwOverlaySurfaces++;
                            }

                        lpCreateSurface->ddRVal = DD_OK;
                        goto CREATE_HANDLED;
                        }
                    else
                        {
                        /* We can't support overlay surfaces in system memory */
                        if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                            {
                            return DDHAL_DRIVER_NOTHANDLED;
                            }
                        }
                    }

                //**********************************************************************
                // Tell DDRAW to allocate user mem for this surface.
                //**********************************************************************
                lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
                lpSurfaceGlobal->dwUserMemSize = dwBlockSize;
                lpSurfaceDesc->lPitch = lPitch;
                lpSurfaceLocal->ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                return DDHAL_DRIVER_NOTHANDLED;
                break;

            case FOURCC_YUY2:
            case FOURCC_UYVY:

                if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (ppdev->dwOverlaySurfaces > 0))
                    {
                    if ((ppdev->dwOverlayOwner != (DWORD)powner) ||
                        (ppdev->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES))
                        {
                        lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                        goto CREATE_HANDLED;
                        }
                    }

                /* First try video memory */
                lPitch = ((lpSurfaceGlobal->wWidth + 1) & 0xFFFFFFFE) << 1;
                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                /* pad with an extra scanline */
                dwBlockSize = (lPitch * (DWORD)lpSurfaceGlobal->wHeight);
                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 16;
                if (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUY2)
                    {
                    lpSurfaceGlobal->ddpfSurface.dwYBitMask = 0x00FF00FF;
                    lpSurfaceGlobal->ddpfSurface.dwUBitMask = 0x0000FF00;
                    lpSurfaceGlobal->ddpfSurface.dwVBitMask = 0xFF000000;
                    }
                else
                    {
                    lpSurfaceGlobal->ddpfSurface.dwYBitMask = 0xFF00FF00;
                    lpSurfaceGlobal->ddpfSurface.dwUBitMask = 0x000000FF;
                    lpSurfaceGlobal->ddpfSurface.dwVBitMask = 0x00FF0000;
                    }
                lpSurfaceGlobal->ddpfSurface.dwYUVAlphaBitMask = 0;
#ifdef DEBUG
                fourCCStr[0] = (char)lpSurfaceGlobal->ddpfSurface.dwFourCC & 0xFF;
                fourCCStr[1] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 8) & 0xFF;
                fourCCStr[2] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 16) & 0xFF;
                fourCCStr[3] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 24) & 0xFF;
                fourCCStr[4] = 0;
                DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                lpSurfaceGlobal->lPitch = lPitch;
                lpSurfaceDesc->dwFlags |= DDSD_PITCH;
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

                NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                if (dwStatus!=0)
                {
                    bMoveAllDfbsFromOffscreenToDibs(ppdev);
                    NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                }


                if (dwStatus==0)
                    {
                    ppdev->DDrawVideoSurfaceCount++;
                    lpSurfaceLocal->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                    lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                    lpSurfaceGlobal->fpVidMem = fpVidMem;
                    lpCreateSurface->ddRVal = DD_OK;
                    if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                        {
                        index = 0;
                        while ((ppdev->dwOverlaySurfaceLCL[index] != 0) &&
                               (index < NV_MAX_OVERLAY_SURFACES))
                            index++;
                        ppdev->dwOverlaySurfaceLCL[index] = (DWORD) lpSurfaceLocal;
                        ppdev->dwOverlayOwner = (DWORD)powner;
                        ppdev->dwOverlaySurfaces++;
                        }

                    }
                else
                    {
                    /* We can't support overlay surfaces in system memory */
                    if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                        {
                        lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                        goto CREATE_HANDLED;
                        }
                    //**********************************************************************
                    // Tell DDRAW to allocate user mem for this surface.
                    //**********************************************************************
                    lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
                    lpSurfaceGlobal->dwUserMemSize = dwBlockSize;
                    lpSurfaceDesc->lPitch = lPitch;
                    lpSurfaceDesc->dwFlags  |= DDSD_PITCH;
                    lpSurfaceLocal->ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                    lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                    return DDHAL_DRIVER_NOTHANDLED;
                    }
                goto CREATE_HANDLED;
                break;

            case FOURCC_YV12:
            case FOURCC_420i:

                if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (ppdev->dwOverlaySurfaces > 0))
                    {
                    if ((ppdev->dwOverlayOwner != (DWORD)powner) ||
                        (ppdev->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES))
                        {
                        lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                        goto CREATE_HANDLED;
                        }
                    }

                /*
                 * Always split allocation of YV12/420i overlay surfaces.
                 *   Allocate the YV12/420i portion in AGP memory on AGP systems, local video memory on PCI systems.
                 *   Fall back to system memory only if preferred allocation fails.
                 *   Allocate additional YUY2 surfaces in local video memory for the video scaler to use
                 */
                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 12;
                lpSurfaceGlobal->ddpfSurface.dwYBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwUBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwVBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwYUVAlphaBitMask = 0;

                lpSurfaceGlobal->fpVidMem = ppdev->ulPrimarySurfaceOffset;
                lpSurfaceGlobal->dwReserved1 = 0;
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

                lPitch = ((lpSurfaceGlobal->wWidth + 1) & 0xFFFFFFFE) << 1;
                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

                adjustedHeight = (DWORD)((lpSurfaceGlobal->wHeight + 1) & ~1);

                dwBlockSize = lPitch * adjustedHeight;

                if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    }

                    if (dwStatus==0)
                        {
                        ppdev->DDrawVideoSurfaceCount++;
                        lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                        if (ppdev->NvFloatingMem2MemFormatBaseAddress == 0)
                            ppdev->NvYUY2Surface0Mem = (DWORD)fpVidMem; /* save pointer to YUY2 overlay surface */
                        else if (ppdev->NvFloatingMem2MemFormatNextAddress == 0)
                            ppdev->NvYUY2Surface1Mem = (DWORD)fpVidMem;
                        else
                            ppdev->NvYUY2Surface2Mem = (DWORD)fpVidMem;
                        }
                    else
                        {
                        /* one or more overlay surfaces could not be allocated, clean up already allocated memory */
                        if (ppdev->NvYUY2Surface1Mem > 0)
                            {
                            NVHEAP_FREE(ppdev->NvYUY2Surface1Mem);
                            ppdev->NvYUY2Surface1Mem = 0;
                            ppdev->NvFloatingMem2MemFormatNextAddress = 0;
                            if (ppdev->DDrawVideoSurfaceCount > 0)
                                ppdev->DDrawVideoSurfaceCount--;
                            }

                        if (ppdev->NvFloatingMem2MemFormatBaseAddress != 0)
                            {
                            if (ppdev->NvYUY2Surface0Mem > 0)
                                {
                                NVHEAP_FREE(ppdev->NvYUY2Surface0Mem);
                                ppdev->NvYUY2Surface0Mem = 0;
                                if (ppdev->DDrawVideoSurfaceCount > 0)
                                    ppdev->DDrawVideoSurfaceCount--;
                                }
#ifdef SYSMEM_FALLBACK
                            if ((ppdev->NvFloatingMem2MemFormatBaseAddress < (ULONG) ppdev->pjFrameBufbase) || /* If system memory */
                                (ppdev->NvFloatingMem2MemFormatBaseAddress > (ULONG) ppdev->pjFrameBufbase + 0x1000000))
                                {
                                if (NvFree(ppdev->hDriver,
                                                     ppdev->hClient,
                                                     ppdev->hDevice,
                                                     NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY)
                                    != NVOS00_STATUS_SUCCESS)
                                /*
                                if (NvFreeContextDma(ppdev->hDriver,
                                                     NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY)
                                    != NV0003_ERROR_OK)
                                */
                                    {
                                    DISPDBG((2, "Couldn't free dma context in sys mem"));
                                    lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                                    goto CREATE_HANDLED;
                                    }
                                }
                            if ((ppdev->NvFloatingMem2MemFormatBaseAddress < (ULONG) ppdev->pjFrameBufbase) || /* If system memory */
                                (ppdev->NvFloatingMem2MemFormatBaseAddress > (ULONG) ppdev->pjFrameBufbase + 0x1000000))
                                {
                                // BUGBUG...
                                //GlobalUnlock((HGLOBAL)ppdev->NvFloatingMem2MemFormatMemoryHandle);
                                //GlobalFree((HGLOBAL)ppdev->NvFloatingMem2MemFormatMemoryHandle);
                                }
                            else
#endif // #ifdef SYSMEM_FALLBACK
                                {
                                NVHEAP_FREE(ppdev->NvFloatingMem2MemFormatBaseAddress);
                                if (ppdev->DDrawVideoSurfaceCount > 0)
                                    ppdev->DDrawVideoSurfaceCount--;
                                }

                            ppdev->NvFloatingMem2MemFormatBaseAddress = 0;
                            ppdev->NvFloatingMem2MemFormatNextAddress = 0;
                            }

                        ppdev->dwOverlayOwner = 0;
                        ppdev->dwOverlaySurfaces = 0;

                        /* We can't support overlay surfaces in system memory */
                        if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                            {
                            lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                            goto CREATE_HANDLED;
                            }
                        return(DDHAL_DRIVER_NOTHANDLED);
                        }
                    }
#ifdef DEBUG
                fourCCStr[0] = (char)lpSurfaceGlobal->ddpfSurface.dwFourCC & 0xFF;
                fourCCStr[1] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 8) & 0xFF;
                fourCCStr[2] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 16) & 0xFF;
                fourCCStr[3] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 24) & 0xFF;
                fourCCStr[4] = 0;
                DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                /* now allocate enough AGP memory or local video memory for the YV12 part of the surface */
                lPitch = lpSurfaceGlobal->wWidth;
                lpSurfaceGlobal->lPitch = lPitch;

                dwBlockSize = ((lPitch * (adjustedHeight * 12L)) >> 3);
                /* Force block to be properly aligned */
                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

                if (ppdev->NvFloatingMem2MemFormatBaseAddress == 0)
                    { /* If this is the first of a complex overlay surface */

                    /*
                     * Allocate enough AGP, video, or system memory for ALL of the surfaces in the
                     * complex surface in a single block
                     */

                    if (lpCreateSurface->dwSCnt > 2)
                        dwBlockSize *= (DWORD)lpCreateSurface->dwSCnt;
                    else /* Assume that 2 of these surfaces will be created */
                        dwBlockSize <<= 1;

                    fpVidMem = 0;

                    memType = 0;

                    NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    }

                    if (dwStatus==0)
                        {
                        memType = DDSCAPS_LOCALVIDMEM;
                        ppdev->DDrawVideoSurfaceCount++;
                        lpSurfaceGlobal->fpVidMem = fpVidMem;
                        ppdev->NvFloatingMem2MemFormatMemoryHandle = 0;
                        }

                    if (dwStatus!=0)
                        { /* Finally try system memory */
#ifdef SYSMEM_FALLBACK
                        lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
                        lpSurfaceGlobal->dwUserMemSize = dwBlockSize;
                        lpSurfaceDesc->lPitch = lPitch;
                        lpSurfaceDesc->dwFlags  |= DDSD_PITCH;
                        lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;

                        lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
#endif
                        return (DDHAL_DRIVER_NOTHANDLED);
                        }

#ifdef SYSMEM_FALLBACK
                    DPF( "    System memory FOURCC surface allocation succeeded" );
                    if ((memType == DDSCAPS_NONLOCALVIDMEM) || (memType == DDSCAPS_SYSTEMMEMORY))
                        { /* If system memory */

                        if (NvAllocContextDma(ppdev->hDriver,
                                              ppdev->hClient,
                                              NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                                              NV01_CONTEXT_DMA,
                                              NVOS03_FLAGS_ACCESS_READ_ONLY,
                                              (PVOID) lpSurfaceGlobal->fpVidMem,
                                              dwBlockSize - 1
                                              ) != NVOS03_STATUS_SUCCESS)
                        /*
                        if (NvAllocContextDma(ppdev->hDriver,
                                              NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                                              NV_CONTEXT_DMA_FROM_MEMORY,
                                              (PVOID) lpSurfaceGlobal->fpVidMem,
                                              dwBlockSize - 1,
                                              0) != NV0002_ERROR_OK)
                        */
                            {
                            DISPDBG((2, "DdCreateSurface: cannot create dma context in sys mem"));
                            /* Can't lock down system memory, forget using this technique */
                            ppdev->NvFloatingMem2MemFormatBaseAddress = 0;
                            /* Free video memory just allocated above */
                            NVHEAP_FREE(ppdev->NvYUY2Surface0Mem);
                            if (ppdev->DDrawVideoSurfaceCount > 0)
                                ppdev->DDrawVideoSurfaceCount--;

                            /* Free AGP memory just allocated above */
                            NVHEAP_FREE(lpSurfaceGlobal->fpVidMem);
                            lpSurfaceGlobal->fpVidMem = 0;
                            lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                            goto CREATE_HANDLED;
                            }
                        }
#endif // #ifdef SYSMEM_FALLBACK

                    ppdev->NvFloatingMem2MemFormatBaseAddress =
                        (DWORD)lpSurfaceGlobal->fpVidMem;
                    }
                else
                    {
                    lpSurfaceGlobal->fpVidMem = ppdev->NvFloatingMem2MemFormatNextAddress =
                        ppdev->NvFloatingMem2MemFormatBaseAddress + dwBlockSize;
                    }

                if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                    {
                    index = 0;
                    while ((ppdev->dwOverlaySurfaceLCL[index] != 0) &&
                           (index < NV_MAX_OVERLAY_SURFACES))
                        index++;
                    ppdev->dwOverlaySurfaceLCL[index] = (DWORD) lpSurfaceLocal;
                    ppdev->dwOverlayOwner = (DWORD)powner;
                    ppdev->dwOverlaySurfaces++;
                    }
            }
        }
    else
        {
        //**************************************************************************
        // Allocate a space in off-screen memory, using our own heap
        // manager:
        //**************************************************************************
        lPitch = wWidth * ppdev->cjPelSize;
        lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
        if (lpSurfaceLocal->ddsCaps.dwCaps & (DDSCAPS_BACKBUFFER | DDSCAPS_FLIP))
            {
            NVHEAP_ALLOC_TILED(dwStatus,fpVidMem, lPitch, wHeight, TYPE_IMAGE);
            }
        else
            {
            NVHEAP_ALLOC(dwStatus,fpVidMem, lPitch * wHeight, TYPE_IMAGE);
            }
        if (dwStatus!=0)
        {
            bMoveAllDfbsFromOffscreenToDibs(ppdev);
            lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            if (lpSurfaceLocal->ddsCaps.dwCaps & (DDSCAPS_BACKBUFFER | DDSCAPS_FLIP))
                {
                NVHEAP_ALLOC_TILED(dwStatus,fpVidMem, lPitch, wHeight, TYPE_IMAGE);
                }
            else
                {
                NVHEAP_ALLOC(dwStatus,fpVidMem, lPitch * wHeight, TYPE_IMAGE)
                }
        }
        if (dwStatus==0)
            {
            ppdev->DDrawVideoSurfaceCount++;

            //**********************************************************************
            // Flip surfaces, detected by surface requests that are the
            // same size as the current display, have special
            // considerations: they must live in the first four megabytes
            // of video memory:
            //**********************************************************************

            lpSurfaceGlobal->yHint        = (fpVidMem / ppdev->lDelta);
            lpSurfaceGlobal->xHint        = ((fpVidMem - (lpSurfaceGlobal->yHint * ppdev->lDelta))/ ppdev->cjPelSize) ;
            lpSurfaceGlobal->fpVidMem     = fpVidMem;
            lpSurfaceGlobal->lPitch       = lPitch;

            lpSurfaceDesc->lPitch   = lPitch;
            lpSurfaceDesc->dwFlags |= DDSD_PITCH;

            lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

            //**********************************************************************
            // We handled the creation entirely ourselves, so we have to
            // set the return code and goto CREATE_HANDLED:
            //**********************************************************************

            lpCreateSurface->ddRVal = DD_OK;
            goto CREATE_HANDLED;
            }
        else
            {
            return (DDHAL_DRIVER_NOTHANDLED);
            }
        }
    //**********************************************************************
    // We handled the creation entirely ourselves, so we have to
    // set the return code and goto CREATE_HANDLED:
    //**********************************************************************
    lpCreateSurface->ddRVal = DD_OK;

CREATE_HANDLED:
    return DDHAL_DRIVER_HANDLED;

    }
#endif // IS_WINNT4

/******************************Public*Routine**********************************\
* DWORD DdSetColorKey
*
\******************************************************************************/
DWORD __stdcall DdSetColorKey(PDD_SETCOLORKEYDATA lpSetColorKey)
    {
    PDD_DIRECTDRAW_GLOBAL pdrv;
    PDD_SURFACE_LOCAL     psurf;
    PDEV                 *ppdev;

    pdrv = lpSetColorKey->lpDD;
    psurf = lpSetColorKey->lpDDSurface;
    ppdev = (PDEV *) lpSetColorKey->lpDD->dhpdev;

    DPF( "in SetSurfaceColorKey, lpSetColorKey->lpDD=%08lx, lpSetColorKey->lpDDSurface = %08lx",
         pdrv, lpSetColorKey->lpDDSurface );

    if (lpSetColorKey->dwFlags == DDCKEY_SRCBLT)
        {
        psurf->ddckCKSrcOverlay.dwColorSpaceLowValue =
        lpSetColorKey->ckNew.dwColorSpaceLowValue & ppdev->physicalColorMask;
        /* Use no mask on this one on NV3 so that our D3D driver can get all the bits when surface is 565 */
        psurf->ddckCKSrcOverlay.dwColorSpaceHighValue =
        lpSetColorKey->ckNew.dwColorSpaceHighValue & ppdev->physicalColorMask;
        }
    else if (lpSetColorKey->dwFlags == DDCKEY_DESTOVERLAY)
        {
        psurf->ddckCKDestOverlay.dwColorSpaceLowValue =
        lpSetColorKey->ckNew.dwColorSpaceLowValue & ppdev->physicalColorMask;
        psurf->ddckCKDestOverlay.dwColorSpaceHighValue =
        lpSetColorKey->ckNew.dwColorSpaceHighValue & ppdev->physicalColorMask;
        }
    else
        {
        lpSetColorKey->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
        }


    lpSetColorKey->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    }

#if (_WIN32_WINNT >= 0x0500) && defined(NVD3D) && !defined(_WIN64)
//WINNT 5 version, use common code to build caps. If not D3D use WINNT 4 version
//note that both have to build with NV3/NV4
BOOL DrvGetDirectDrawInfo(
                         DHPDEV          dhpdev,
                         DD_HALINFO*     pHalInfo,
                         DWORD*          pdwNumHeaps,
                         VIDEOMEMORY*    pvmList,            // Will be NULL on first call
                         DWORD*          pdwNumFourCC,
                         DWORD*          pdwFourCC)          // Will be NULL on first call
    {
    PDEV*       ppdev;
    LONGLONG    li;
    DWORD       i=0;

    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // When enabling Direct Draw, DrvGetDirectDrawInfo will get called twice.
    //
    // The first call will have (pvmList = NULL) and (pdwFourCC = NULL)
    // During this time, the driver needs to returns the size of the memory
    // heap and the number of FourCC's that the driver supports.
    //
    // During the second call, the driver should initialize pdwNumHeaps,
    // pvmList, pdwNumFourCC, and pdwFourCC based on the values returned
    // in the first call.
    //
    //**************************************************************************

    //************************************************************************
    // BUGBUG - temp hack til we get overlay conversion stuff working.
    //************************************************************************

#ifdef YUNV_UYNV
    *pdwNumFourCC = 10;
#else // YUNV_UYNV
    *pdwNumFourCC = 8;
#endif// YUNV_UYNV

#if !defined(DX_AGP)
    *pdwNumHeaps = 0;
#else
    *pdwNumHeaps = 1;       // AGP memory heap
#endif // #if _WIN32_WINNT >= 0x0500

    //**************************************************************************
    // Verify that we enabled Direct Draw in bEnableDirectDraw
    //**************************************************************************

    if (!(ppdev->flStatus & STAT_DIRECTDRAW_CAPABLE))
    {
        return (FALSE);
    }

    if (pvmList == NULL && pdwFourCC == NULL)
    {
        return (TRUE);
    }

    buildDDHALInfo32(ppdev->pDriverData);
    *pHalInfo = ppdev->pDriverData->HALInfo;

    pHalInfo->dwSize = sizeof(*pHalInfo);

    //**************************************************************************
    // Current primary surface attributes.  Since HalInfo is zero-initialized
    // by GDI, we only have to fill in the fields which should be non-zero:
    // First fill out VideoMemoryInformation
    //**************************************************************************

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.fpPrimary       = ppdev->ulPrimarySurfaceOffset;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;
    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPel;

    if (ppdev->iBitmapFormat == BMF_8BPP)
        {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
        }

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

#if defined(NV4) && defined(DX_AGP)
    //**************************************************************
    // AGP support is Win2k specific.
    //**************************************************************

    {
#if (_WIN32_WINNT >= 0x0500)
        // Ask miniport if AGP should be enabled.
        // Miniport has knowledge of AGP chipsets for which we should disable AGP functionality.
        // e.g. ALi1541 chipset

        ULONG ulReturn = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED,
                               NULL, 0, NULL, 0, &ulReturn))
        {
            // non NO_ERROR returned
            ppdev->bAgp = FALSE;
        }
        else
        {
            // NO_ERROR returned
            ppdev->bAgp = TRUE;
        }
#else
        ULONG cbLimit = 0xfff;

        if (NvAllocMemory(ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDevice,
            NV_AGP_PUSHBUF_OBJECT_HANDLE,
            NV01_MEMORY_SYSTEM,
            (DRF_DEF(OS02, _FLAGS, _LOCATION, _AGP) | DRF_DEF(OS02, _FLAGS, _COHERENCY, _WRITE_COMBINE)),
            (PVOID *)&(ppdev->AgpHeapBase),
            &cbLimit))
        {
            ppdev->bAgp = FALSE;
        }
        else
        {
            ppdev->bAgp = TRUE;
            NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_AGP_PUSHBUF_OBJECT_HANDLE);
        }
#endif
    }

    if (ppdev->bAgp)
    {
        // get the AGP aperture size and store in pDriverdata->regMaxAGPLimit;
        NvWin2KGetAgpLimit(ppdev, ppdev->hClient, ppdev->hDevice);

        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
        pHalInfo->ddCaps.dwCaps2        |= DDCAPS2_NONLOCALVIDMEMCAPS | DDCAPS2_NONLOCALVIDMEM;
        pHalInfo->ddCaps.dwVidMemTotal   = ppdev->pDriverData->regMaxAGPLimit + 1;

        NvWin2KpvmConfig(ppdev, pvmList);

        ppdev->AgpHeap = pvmList;
        ppdev->AgpHeapAlignment.Linear.dwStartAlignment = 256;
        ppdev->AgpHeapAlignment.Linear.dwPitchAlignment = 256;
    }
    else
#endif
    {
        pHalInfo->ddCaps.dwCaps2 &= ~DDCAPS2_NONLOCALVIDMEM;
        pHalInfo->ddCaps.dwVidMemTotal = ppdev->cbFrameBuf - (ppdev->cyScreen * ppdev->lDelta);
    }
    //**************************************************************************
    // Since we do our own memory allocation, we have to set dwVidMemTotal
    // ourselves.  Note that this represents the amount of available off-
    // screen memory, not all of video memory:
    //**************************************************************************

    //**************************************************************************
    // Dword alignment must be guaranteed for off-screen surfaces:
    //**************************************************************************
    pHalInfo->vmiData.dwOffscreenAlign = ppdev->ulSurfaceAlign + 1;
    pHalInfo->vmiData.dwTextureAlign   = ppdev->ulSurfaceAlign + 1;
    pHalInfo->vmiData.dwAlphaAlign     = ppdev->ulSurfaceAlign + 1;
    pHalInfo->vmiData.dwZBufferAlign   = ppdev->ulSurfaceAlign + 1;
    pHalInfo->vmiData.dwOverlayAlign   = ppdev->ulSurfaceAlign + 1;

    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_UYVY;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_YUY2;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_RAW8;
#ifdef YUNV_UYNV
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_YUNV;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_UYNV;
#endif
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_YV12;

    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_YVU9;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_IV32;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_IV31;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_IF09;

    // The first call will have (pvmList = NULL) and (pdwFourCC = NULL)
    // During this time, the driver needs to returns the size of the memory
    // heap and the number of FourCC's that the driver supports.
    DISPDBG((2,"NV3:DrvEnableDirectDraw: Set D3D caps"));
#if defined(NV4)
#ifndef _WIN64
    NvWin2KD3DHALCreateDriver(pHalInfo, ppdev);
#endif // D3D is not 64 bit code clean , skip for now...

    /*
     * Force reset of D3D rendering target and z-buffer.
     */
    ppdev->pDriverData->HALInfo = *pHalInfo;

    ppdev->pDriverData->dwFullScreenDOSStatus   = 0;
    ppdev->pDriverData->dwCurrentContextHandle  = 0;
    ppdev->pDriverData->bDirtyRenderTarget      = TRUE;

    ppdev->pDriverData->vpp.dwOverlayFSOvlHeadSaved = 0xFFFFFFFF;
    ppdev->pDriverData->vpp.dwOverlayFSOvlHead = 0xFFFFFFFF;
#else
    D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA *)&pHalInfo->lpD3DGlobalDriverData,
                       (LPD3DHAL_CALLBACKS *)&pHalInfo->lpD3DHALCallbacks);
    pDriverData->HALInfo = *pHalInfo;
    /*
     * Force reset of D3D rendering target and z-buffer.
     */
    pDriverData->fFullScreenDosOccurred  = 0;
    pDriverData->lpLast3DSurfaceRendered = 0;
    pDriverData->dwCurrentContextHandle  = 0;

    pDriverData->vpp.dwOverlayFSOvlHeadSaved = 0xFFFFFFFF;
    pDriverData->vpp.dwOverlayFSOvlHead = 0xFFFFFFFF;

#endif // #ifdef NV4
    return (TRUE);
    }

#else
//
// WINNT 4 version -- no Direct3D
//
BOOL DrvGetDirectDrawInfo(
                         DHPDEV          dhpdev,
                         DD_HALINFO*     pHalInfo,
                         DWORD*          pdwNumHeaps,
                         VIDEOMEMORY*    pvmList,            // Will be NULL on first call
                         DWORD*          pdwNumFourCC,
                         DWORD*          pdwFourCC)          // Will be NULL on first call
{
    PDEV*       ppdev;
    LONGLONG    li;

    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // When enabling Direct Draw, DrvGetDirectDrawInfo will get called twice.
    //
    // The first call will have (pvmList = NULL) and (pdwFourCC = NULL)
    // During this time, the driver needs to returns the size of the memory
    // heap and the number of FourCC's that the driver supports.
    //
    // During the second call, the driver should initialize pdwNumHeaps,
    // pvmList, pdwNumFourCC, and pdwFourCC based on the values returned
    // in the first call.
    //
    //**************************************************************************
    *pdwNumFourCC = NV_MAX_FOURCC;
    *pdwNumHeaps = 0;
    if (!ppdev->bEnableIF09)
    {
        //***********************************************************************
        // Don't report support for the IF09 FOURCC. The default Indeo codec
        // shipping with NT 4 doesn't decode IF09's properly, so we need to punt them
        // to sw. NOTE: WE ASSUME IF09 IS THE LAST CODEC in the FOURCC LIST!
        //************************************************************************
        (*pdwNumFourCC)--;
    }

    //**************************************************************************
    // Verify that we enabled Direct Draw in bEnableDirectDraw
    //**************************************************************************

    if (!(ppdev->flStatus & STAT_DIRECTDRAW_CAPABLE))
        return (FALSE);

    pHalInfo->dwSize = sizeof(*pHalInfo);

    //**************************************************************************
    // Current primary surface attributes.  Since HalInfo is zero-initialized
    // by GDI, we only have to fill in the fields which should be non-zero:
    // First fill out VideoMemoryInformation
    //**************************************************************************

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.fpPrimary       = ppdev->ulPrimarySurfaceOffset;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;
    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPel;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    //**************************************************************************
    // Since we do our own memory allocation, we have to set dwVidMemTotal
    // ourselves.  Note that this represents the amount of available off-
    // screen memory, not all of video memory:
    //**************************************************************************

    pHalInfo->ddCaps.dwVidMemTotal = ppdev->cbFrameBuf - (ppdev->cyScreen * ppdev->lDelta);

    //**************************************************************************
    // Dword alignment must be guaranteed for off-screen surfaces:
    //**************************************************************************

    pHalInfo->vmiData.dwOffscreenAlign = ppdev->ulSurfaceAlign + 1;

    //**************************************************************************
    // Capabilities supported:
    //**************************************************************************

    pHalInfo->ddCaps.dwCaps = DDCAPS_BLT
                              | DDCAPS_BLTCOLORFILL
                              | DDCAPS_COLORKEY
                              | DDCAPS_READSCANLINE
                              | DDCAPS_BLTFOURCC
                              | DDCAPS_OVERLAY
                              | DDCAPS_OVERLAYSTRETCH
                              | DDCAPS_OVERLAYFOURCC
                              | DDCAPS_OVERLAYCANTCLIP
                              | DDCAPS_BLTDEPTHFILL;

    pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT;

    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                      | DDSCAPS_PRIMARYSURFACE
                                      | DDSCAPS_FLIP
                                      | DDSCAPS_OVERLAY
                                      | DDSCAPS_HWCODEC;

    // Overlays need 8-byte alignment.  Note that if 24bpp overlays are
    // ever supported, this will have to change to compensate:
    pHalInfo->vmiData.dwOverlayAlign = ppdev->ulSurfaceAlign + 1;

    pHalInfo->ddCaps.dwCaps |=
          DDCAPS_OVERLAY
        | DDCAPS_OVERLAYSTRETCH
        | DDCAPS_OVERLAYFOURCC
        | DDCAPS_OVERLAYCANTCLIP;

    pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYSTRETCHX
                              | DDFXCAPS_OVERLAYSTRETCHY;
                                                                 // H.AZAR: (03/15/1999) overlay shrink support !
                                 //| DDFXCAPS_OVERLAYSHRINKX
                                 //| DDFXCAPS_OVERLAYSHRINKY;

    // We support only destination colour keying because that's the
    // only permutation we've had a chance to test.
    pHalInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_DESTOVERLAY;

    if (pdwFourCC)
    {
        USHORT i = 0;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_UYVY;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_YUY2;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_YVU9;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_IV32;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_IV31;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_YV12;
        if (ppdev->bEnableIF09)
        {
            pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_IF09;
        }
    }
    pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;
    pHalInfo->ddCaps.dwMinOverlayStretch   = ppdev->ulMinOverlayStretch;
    pHalInfo->ddCaps.dwMinLiveVideoStretch = ppdev->ulMinOverlayStretch;
    pHalInfo->ddCaps.dwMinHwCodecStretch   = ppdev->ulMinOverlayStretch;

    pHalInfo->ddCaps.dwMaxOverlayStretch   = 9999;
    pHalInfo->ddCaps.dwMaxLiveVideoStretch = 9999;
    pHalInfo->ddCaps.dwMaxHwCodecStretch   = 9999;

    pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH;
    pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_BLTSTRETCHX
                                 | DDFXCAPS_BLTSTRETCHY;
    return (TRUE);
}
#endif

//******************************Public*Routine**********************************
//
// Function: DrvEnableDirectDraw()
//
//  This function is called by GDI to enable DirectDraw when a DirectDraw
//  program is started and DirectDraw is not already active.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


BOOL DrvEnableDirectDraw(
                        DHPDEV                  dhpdev,
                        DD_CALLBACKS*           pCallBacks,
                        DD_SURFACECALLBACKS*    pSurfaceCallBacks,
                        DD_PALETTECALLBACKS*    pPaletteCallBacks)

{
    PDEV* ppdev;
    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // Perform one time initialization steps necessary every time directdraw is
    // started.
    //**************************************************************************
    if (!bAssertModeDirectDraw(ppdev, TRUE))
        return(FALSE);
    ppdev->flStatus |= STAT_DIRECTDRAW_ENABLED;
#ifndef NVD3D
    //****************************************************************************
    // DX3 - Initialize HAL fct ptrs.
    //****************************************************************************
    NvDDEnable(ppdev);
    *pCallBacks = ppdev->ddCallBacks;
    *pSurfaceCallBacks = ppdev->ddSurfaceCallBacks;
    *pPaletteCallBacks = ppdev->ddPaletteCallBacks;

#else
    //****************************************************************************
    // DX6 - Initialize HAL fct ptrs.
    //****************************************************************************
#ifndef _WIN64
    ppdev->pDriverData->DDCallbacks.dwFlags  |= DDHAL_CB32_MAPMEMORY;
    ppdev->pDriverData->DDCallbacks.MapMemory = DdMapMemory;
    *pCallBacks = ppdev->pDriverData->DDCallbacks;
    *pSurfaceCallBacks = ppdev->pDriverData->DDSurfaceCallbacks;
    *pPaletteCallBacks = ppdev->pDriverData->DDPaletteCallbacks;
#endif // #ifndef _WIN64
#endif // #ifndef NVD3D
    return (TRUE);
}

//******************************Public*Routine**********************************
//
// Function: DrvDisableDirectDraw()
//
//      This function is called by GDI when the last active DirectDraw program
//      is quit and DirectDraw will no longer be active.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID DrvDisableDirectDraw(
                         DHPDEV      dhpdev)

    {
    PDEV* ppdev;
    ULONG  NvStatus;
    BOOL  status;
    ppdev = (PDEV*) dhpdev;
    if (!ppdev || !ppdev->bEnabled)
        {
        return;
        }

#if defined(NVD3D) && (NVARCH>= 0x04)
    vDisableDirectDraw(ppdev);
#else
    if (!bAssertModeDirectDraw(ppdev, FALSE))
        return;
#endif // NVD3D

    ppdev->flStatus &= ~STAT_DIRECTDRAW_ENABLED;

    //*****************************************************************************
    // If the 2d driver is running in DMA push mode, the channel ptr in ppdev->pjMmBase
    // must be the ddraw channel ptr, which is no longer valid.
    //*****************************************************************************
#if _WIN32_WINNT >= 0x0500
    // ifdeffed out because NT4 still references the PIO channel in many places -- slum
    if (ppdev->DmaPushEnabled2D)
        {
        ppdev->pjMmBase = NULL;
        }
#endif
    return;
    }

//******************************Public*Routine**********************************
//
// Function: bAssertModeDirectDraw
//
//      This function is called by enable.c when entering or leaving the
//      DOS full-screen character mode.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     TRUE if successful.
//     FALSE if an error occurred.
//
//******************************************************************************


BOOL bAssertModeDirectDraw(PDEV*   ppdev, BOOL    bEnable)
{
    BOOL releaseOpenglSemaphore = FALSE;

    ENTER_DMA_PUSH_SYNC();

    if (bEnable && !ppdev->DDrawEnabledFlag)
    {
        //*************************************************************************
        // Init ddraw state data.
        //*************************************************************************
        ppdev->OverlayBufferIndex = 1;

        //*************************************************************************
        // If this is NV4, create the ddraw patch. NV3 ddraw patch is integrated
        // into the 2D patch.
        //*************************************************************************
#ifndef NVD3D
        if (!ppdev->pDriverData->dwRootHandle)
        {
            if (!DriverInit_NT4(ppdev->pDriverData))
                return(FALSE);
        }
        nvAssert(ppdev->pDriverData->dwRootHandle);

        if (!bCreateNVDDPatch(ppdev))
        {
            END_DMA_PUSH_SYNC();
            return(FALSE);
        }
#else
        //**************************************************************************
        // Initialize DX7 driver state for this device.
        //**************************************************************************
#ifndef _WIN64
#if (NVARCH >= 0x04)
        if (!ppdev->pDriverData->dwRootHandle)
            if (!DriverInit((ULONG)ppdev))
                return(FALSE);
#else
        if (ppdev->pDriverData == NULL)
        {
            pDriverData = ppdev->pDriverData =
                EngAllocMem(FL_ZERO_MEMORY, sizeof(GLOBALDATA), ALLOC_TAG);
            if (ppdev->pDriverData == NULL)
                {
                END_DMA_PUSH_SYNC();
                return(FALSE);
                }
            *(ppdev->pDriverData) = DefaultGlobalData;
            ppdev->pDriverData->dwGlobalStructSize = sizeof(GLOBALDATA);
            ppdev->pDriverData->ppdev = ppdev;
            ppdev->pDriverData->dwRootHandle = ppdev->hClient;
            ppdev->pDriverData->dwDeviceHandle = ppdev->hDevice;
            ddEnable(ppdev);
            if (!DriverInit((ULONG) ppdev))
            {
                EngFreeMem(ppdev->pDriverData);
                ppdev->pDriverData = NULL;
                END_DMA_PUSH_SYNC();
                return(FALSE);
            }
        }
#endif // D3D is not 64 bit code clean , skip for now...


        //********************************************************
        // Temp hack to use RM pitch alignment.
        //********************************************************
        ppdev->pDriverData->HALInfo.vmiData.lDisplayPitch = ppdev->lDelta;
        ppdev->pDriverData->VideoHeapTotal = ppdev->VideoHeapTotal;
        ppdev->pDriverData->VideoHeapFree = ppdev->VideoHeapFree;

#endif // #ifdef NVD3D
#endif // #ifndef _WIN64
        ppdev->DDrawEnabledFlag = TRUE;
    }
    else if (!bEnable && (ppdev->DDrawEnabledFlag))
    {
        //*************************************************************************
        // If this is NV4, destroy the ddraw patch. NV3 ddraw patch is integrated
        // into the 2D patch.
        //*************************************************************************
#ifndef NVD3D
        if (!bDestroyNVDDPatch(ppdev))
        {
            END_DMA_PUSH_SYNC();
            return(FALSE);
        }
#else   // NVD3D
        if (ppdev->pDriverData)
        {
            DWORD status;
            //************************************************
            // Force DX driver to recreate its objects.
            //************************************************
#ifndef _WIN64
            status = DestroyDriver32(ppdev->pDriverData);
#endif // D3D is not 64 bit code clean , skip for now...
        }

#endif // NVD3D
        ppdev->DDrawEnabledFlag = FALSE;
    }
    else if (bEnable && ppdev->DDrawEnabledFlag)
    {
#ifndef NVD3D
        extern VOID __cdecl NvTurnOffVideoOverlay(PDEV *ppdev);

        if(ppdev->dwOverlayEnabled == TRUE)
        {
            NvTurnOffVideoOverlay(ppdev);
        }
#endif
    }

    END_DMA_PUSH_SYNC();
    return(TRUE);
}

//******************************Public*Routine**********************************
//
// Function: bEnableDirectDraw()
//
// Routine Description:
//
//      This function is called by enable.c when the mode is first initialized,
//      right after the miniport does the mode-set.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

BOOL bEnableDirectDraw(PDEV*   ppdev)
{
    //**************************************************************************
    // Now init the low level direct draw functions depending on
    // what chip we're currently using.  We need to do this here,
    // (instead of later in DrvEnableDirectDraw), because GetDisplayDuration
    // uses the hardware registers.
    //**************************************************************************
//BUGBUG
#ifdef NV3
    ppdev->pfnGraphicsEngineBusy        = NV3_GraphicsEngineBusy;
    ppdev->pfnVBlankIsActive            = NV3_VBlankIsActive;
    ppdev->pfnWaitWhileVBlankActive     = NV3_WaitWhileVBlankActive;
    ppdev->pfnWaitWhileDisplayActive    = NV3_WaitWhileDisplayActive;
#else
    ppdev->pfnGraphicsEngineBusy        = NV4_GraphicsEngineBusy;
    ppdev->pfnVBlankIsActive            = NV4_VBlankIsActive;
    ppdev->pfnWaitWhileVBlankActive     = NV4_WaitWhileVBlankActive;
    ppdev->pfnWaitWhileDisplayActive    = NV4_WaitWhileDisplayActive;
#endif
    ppdev->pfnGetScanline               = NV_GetScanLineData;
    ppdev->pfnFifoIsBusy                = NV1FifoIsBusy;

#ifndef _WIN64
    //**************************************************************************
    // DirectDraw is all set to be used on this card:
    //**************************************************************************

    ppdev->flStatus |= STAT_DIRECTDRAW_CAPABLE;

    //**************************************************************************
    // Anything else we need to do here to prep NV for Direct Draw ??
    //**************************************************************************
#if (NVARCH >= 0x04)
#if IS_WINNT4
        if (!ppdev->pDriverData->dwRootHandle)
            if (!DriverInit_NT4(ppdev->pDriverData))
                return(FALSE);
#else
        if (!ppdev->pDriverData->dwRootHandle)
            if (!DriverInit((ULONG)ppdev))
                return(FALSE);
#endif
#endif

#endif // #ifndef _WIN64
    return (TRUE);
}

//******************************Public*Routine**********************************
//
// Function: vDisableDirectDraw()
//
// Routine Description:
//
//      This function is called by enable.c when the driver is shutting down.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
VOID vDisableDirectDraw(PDEV*   ppdev)
{
#if IS_WINNT4
//@mjl@   VppDestructor(&ppdev->pDriverData->vpp);
#endif

    if (!bAssertModeDirectDraw(ppdev, FALSE))
    {
        return;
    }

    ppdev->flStatus &= ~STAT_DIRECTDRAW_ENABLED;
}

#if _WIN32_WINNT >= 0x0500
//******************************Public*Routine**********************************
/*
 *  GetAvailDriverMemory
 *
 *  DDraw 'miscellaneous' callback returning the amount of free memory in driver's
 *  'private' heap
 */
//******************************************************************************

DWORD WINAPI GetAvailDriverMemory (PDD_GETAVAILDRIVERMEMORYDATA  pDmd)
{
    LONG    Free, Total;
    memory_t* pBlk;
    PDEV  *ppdev = pDmd->lpDD->dhpdev;

    DISPDBG((2,"NV3: GetAvailDriverMemory"));

    //**************************************************************************
    // Currently the driver only manages local vidmem
    //**************************************************************************
    if (pDmd->DDSCaps.dwCaps & DDSCAPS_LOCALVIDMEM ||
        pDmd->DDSCaps.dwCaps & DDSCAPS_VIDEOMEMORY ||
        pDmd->DDSCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ||
        pDmd->DDSCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN
#ifdef NVD3D
        ||
        pDmd->DDSCaps.dwCaps & DDSCAPS_TEXTURE
#endif // #ifdef NVD3D
        )
#ifndef RM_HEAPMGR
        {
        if (pDmd->DDSCaps.dwCaps &
            (DDSCAPS_VIDEOMEMORY | DDSCAPS_TEXTURE | DDSCAPS_LOCALVIDMEM))
            {
            pBlk = (memory_t *) ppdev->heap.heap_2d_ptr;
            if (!pBlk)
                {
                pDmd->ddRVal = DDERR_GENERIC;
                return(DDHAL_DRIVER_HANDLED);
                }
            Free = Total = 0;
            do
                {
                if (IS_EMPTY(pBlk))
                    Free += pBlk->blkSize;
                Total += pBlk->blkSize;
                pBlk  = pBlk->next;
                } while (pBlk != ppdev->heap.heap_2d_ptr);
            Free *= ALIGN_SIZE;
            Total *= ALIGN_SIZE;
            pDmd->dwFree = Free;
            pDmd->dwTotal = Total - (ppdev->cyScreen * ppdev->lDelta);
            }
        if (pDriverData->GARTLinearBase &&
            pDmd->DDSCaps.dwCaps &
                (DDSCAPS_VIDEOMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
            {
            pDmd->dwTotal += MAX_AGP_HEAP;
            pDmd->dwFree += MAX_AGP_HEAP;
            if (pDriverData->NvAGPDmaPusherBufferBase)
                {
                //*************************************************
                // Account for AGP push buffer.
                //*************************************************
                pDmd->dwFree -= pDriverData->NvDmaPusherBufferSize;
                }
            }
        }
#else
        {
        //********************************************************
        // Any memory currently used by GDI device bitmaps should
        // be reported as available for DX usage.
        //********************************************************
        pDmd->dwTotal = ppdev->VideoHeapTotal;
        pDmd->dwFree  = ppdev->VideoHeapFree + ppdev->cbGdiHeap;
        }
#endif // RM_HEAPMGR
        else
        {
            pDmd->dwTotal = 0;
            pDmd->dwFree  = 0;
        }

    pDmd->ddRVal = DD_OK;

    DISPDBG((2,"NV3:            Total:0x%08xd",pDmd->dwTotal));
    DISPDBG((2,"NV3:            Free :0x%08xd",pDmd->dwFree));
    return DDHAL_DRIVER_HANDLED;
}
#if !defined(DX7) || !(NVARCH >= 0x04) // DX7 driver uses GetDriverInfo32 routine in common code
//******************************Public*Routine**********************************
/*
 * GetDriverInfo32
 *
 * Initialize Extended Functionality Classes
 */
//******************************************************************************

DWORD WINAPI GetDriverInfo32(struct _DD_GETDRIVERINFODATA *lpData)
{
        DWORD dwSize = 0;
    PDEV  *ppdev = lpData->dhpdev;

    DISPDBG((2,"NV3dd: GetDriverInfo"));
    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    if (IsEqualIID(&(lpData->guidInfo), &GUID_MiscellaneousCallbacks) ) {
        DD_MISCELLANEOUSCALLBACKS miscCB;
        dwSize = lpData->dwExpectedSize;

        DISPDBG((2,"NV3dd: GetDriverInfo - Process GUID_MiscellaneousCallbacks"));
        if ( sizeof(miscCB) < dwSize )
            dwSize = sizeof(miscCB);
        lpData->dwActualSize = sizeof(miscCB);
        memset(&miscCB, 0, dwSize);
        miscCB.dwSize = dwSize;

        miscCB.dwFlags = DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;

        miscCB.GetAvailDriverMemory = GetAvailDriverMemory;

        memcpy(lpData->lpvData, &miscCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#ifdef NVPE
    /*
     * VPE stuff
     */

    if (IsEqualIID(&lpData->guidInfo, &GUID_VideoPortCallbacks))
    {
            dwSize = sizeof(DDHAL_DDVIDEOPORTCALLBACKS);

            lpData->dwActualSize = dwSize;
            lpData->ddRVal = DD_OK;

            memcpy(lpData->lpvData, &LPBVideoPortCallbacks, dwSize);
    }

        ///// H.AZAR (02/02/99): use structure defined in nvpe.lib
    if (IsEqualIID(&lpData->guidInfo, &GUID_VideoPortCaps))
    {
            dwSize = sizeof(DDVIDEOPORTCAPS);

            lpData->dwActualSize = dwSize;
            lpData->ddRVal = DD_OK;

            memcpy(lpData->lpvData, &g_ddNVideoPortCaps, dwSize);
    }

    if (IsEqualIID(&(lpData->guidInfo), &GUID_KernelCallbacks) )
    {
                DDHAL_DDKERNELCALLBACKS KernelCallbacks;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(KernelCallbacks) < dwSize )
            dwSize = sizeof(KernelCallbacks);
        lpData->dwActualSize = sizeof(KernelCallbacks);

        KernelCallbacks.dwSize = sizeof(DDHAL_DDKERNELCALLBACKS);
        KernelCallbacks.dwFlags = 0; //DDHAL_KERNEL_SYNCSURFACEDATA | DDHAL_KERNEL_SYNCVIDEOPORTDATA;
        KernelCallbacks.SyncSurfaceData = NULL;          // we're not doing anything on EITHER of these yet
        KernelCallbacks.SyncVideoPortData = NULL;

        memcpy(lpData->lpvData, &KernelCallbacks, dwSize );
        lpData->ddRVal = DD_OK; //DDERR_CURRENTLYNOTAVAIL;
    }

    if (IsEqualIID(&(lpData->guidInfo), &GUID_KernelCaps))
    {
        DDKERNELCAPS cpKernelCaps;
        if (lpData->dwExpectedSize != sizeof(DDKERNELCAPS))
            return DDHAL_DRIVER_HANDLED;

        lpData->dwActualSize = sizeof(DDKERNELCAPS);

        cpKernelCaps.dwSize = sizeof(DDKERNELCAPS);
        cpKernelCaps.dwCaps =   DDKERNELCAPS_SKIPFIELDS         |
                                        DDKERNELCAPS_AUTOFLIP           |
                                        DDKERNELCAPS_SETSTATE           |
                                            DDKERNELCAPS_LOCK               |
                                            //DDKERNELCAPS_FLIPVIDEOPORT      |
                                            DDKERNELCAPS_FLIPOVERLAY        |
                                            DDKERNELCAPS_CAPTURE_SYSMEM |
                                            //DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM |
                                            DDKERNELCAPS_FIELDPOLARITY      ;
                                            //DDKERNELCAPS_CAPTURE_INVERTED   ;

        cpKernelCaps.dwIRQCaps = DDIRQ_VPORT0_VSYNC |
                                                           //#define DDIRQ_BUSMASTER                         0x00000002l
                               2; //DDIRQ_BUSMASTER;
                                                   //DDIRQ_DISPLAY_VSYNC |
                                                   //DDIRQ_RESERVED1     |
                                                   //DDIRQ_VPORT0_VSYNC  |    // this is the only IRQ we'll be supporting
                                                   //DDIRQ_VPORT0_LINE   |
                                                   //DDIRQ_VPORT1_VSYNC  |
                                                   //DDIRQ_VPORT1_LINE;

        memcpy(lpData->lpvData, &cpKernelCaps, sizeof(DDKERNELCAPS));
        lpData->ddRVal = DD_OK; //DDERR_CURRENTLYNOTAVAIL;
    }
#endif // NVPE

#ifdef NVD3D
    /*
     * Call D3D HAL to see if there's any GUIDs it wants to handle.
     */
    pDriverData = ppdev->pDriverData;
    D3DGetDriverInfo(lpData);
#endif // #ifdef NVD3D

    return DDHAL_DRIVER_HANDLED;

} /* GetDriverInfo32 */
#endif // !DX7
#endif // #if _WIN32_WINNT >= 0x0500

#if IS_WINNT4

/*
 * DriverInit_NT4
 *
 * this is the entry point called by DirectDraw to
 * initialize the 32-bit driver when running on NT4.
 *
 * This was converted from the version in ddraw/common/src/ddDrv.cpp and
 * the logic greatly reduced because we *know* we're on NT4 and many of the
 * optional features are not available (AGP for example).
 *
 * Note: all registry lookups have also been removed (for now)
 *
 */
DWORD __stdcall DriverInit_NT4(GLOBALDATA * pDriverData)
{
    static NvU8 bFirstTime = TRUE;

    dbgResetTraceLevel();
    dbgTracePush("DriverInit_NT4");

    nvAssert(pDriverData);
    nvAssert(pDriverData->ppdev);

    // These get erased on modesets? @mjl@
    pDriverData->dwRootHandle      = pDriverData->ppdev->hClient;
    pDriverData->NvBaseFlat        = (DWORD) pDriverData->ppdev->NvBaseAddr;

    if (bFirstTime)
    {
        pDriverData->pCommonNotifierBuffer = NULL;
        pDriverData->NvDeviceVersion   = (unsigned short) pDriverData->ppdev->dwDeviceVersion;
        pDriverData->dwDeviceHandle    = pDriverData->ppdev->hDevice;
        pDriverData->dwSurfaceAlignPad = pDriverData->ppdev->ulSurfaceAlign;
        pDriverData->BaseAddress       = 0;   // offset of frame buffer

        NvConfigGet(pDriverData->ppdev->hDriver,pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
            NV_CFG_RAM_SIZE_MB, &(pDriverData->TotalVRAM));
        pDriverData->TotalVRAM       <<= 20;    // Convert megabytes to bytes

#if (NVARCH < 0x010)
        if (pDriverData->NvDeviceVersion > NV_DEVICE_VERSION_5) {
            pDriverData->NvDeviceVersion = NV_DEVICE_VERSION_5;
        }
#endif // !NV10

        // get the number of heads (DACs) on this device
        NvConfigGet(pDriverData->ppdev->hDriver,pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
            NV_CFG_NUMBER_OF_HEADS, &pDriverData->dwHeads);

        nvDeterminePerformanceStrategy_NT4(pDriverData,&pDriverData->sysInfo);

        // Construct the VPP object (must be after nvDeterminePerformanceStrategy)
        //   There must be NO references to vpp data prior to this point
        //
        if (!VppConstructor(pDriverData->ppdev,&(pDriverData->vpp),&pDriverData->sysInfo))
        {
            VppDestructor(&(pDriverData->vpp)); // Release anything we might have allocated thus far
            dbgTracePop();
            return 0;
        }

        // TBD: move nvPusher init here? -@mjl@

//          bFirstTime = FALSE;
    }

    // Get the current registry settings from the hardware specific routine.
    // TBD: need any of these? @mjl@

    //***************************************************************
    // Shared variable for active channel id is stored in NT display
    // driver state.
    //***************************************************************

    g_adapterData[0].pDriverData = pDriverData; // add this device to the global adapter table (used by nvPriv)

    pDriverData->pCurrentChannelID       = &(pDriverData->ppdev->oglLastChannel);
    pDriverData->dwDesktopState          = 0;  // Means there is no clone or twinview mode
    pDriverData->regPBLocale             = NV_REG_SYS_PB_LOCATION_SYSTEM; // push buffer location: No AGP on NT4, force to SystemMem
//    pDriverData->dwVideoPortsAvailable   = 1;
    pDriverData->DDrawVideoSurfaceCount  = 0;
    pDriverData->dwTVTunerFlipCount      = 0;

    // Reset in case of a mode switch which unloaded the driver
    pDriverData->ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;


    pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;
    pDriverData->bltData.dwLastRop                      = 0xFFFFFFFF;
    pDriverData->bltData.dwLastColourKey                = 0xFFFFFFF0;
    pDriverData->bltData.dwLastColourFormat             = 0;
    pDriverData->bltData.dwLastCombinedPitch            = 0;
    pDriverData->bltData.dwLastSrcOffset                = 0xFFFFFFFF;
    pDriverData->bltData.dwLastDstOffset                = 0xFFFFFFFF;
    pDriverData->bltData.dwSystemBltFallback            = 0;
    pDriverData->bltData.dwLetItThrash                  = 0;


    // can't do this unless more than 4M and MMX instructions available
    if (!(pDriverData->sysInfo.dwCPUFeatureSet & FS_MMX) || (pDriverData->TotalVRAM <= 0x400000)) {
        pDriverData->vpp.regOverlayColourControlEnable = FALSE;
    }

    // Disable HQVUp on less than 16M
    if (pDriverData->TotalVRAM < 0x1000000) {
        pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
    }

    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
    {
        // Disable HQVUp and sw colour controls on NV10
        pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
        pDriverData->vpp.regOverlayColourControlEnable = FALSE;
        if (pDriverData->TotalVRAM < 0x800000) {
            // Disable temporal and deinterlace filters on NV10 if less than 8M
            pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
            pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
        }
    } else {
        pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
        if (pDriverData->TotalVRAM < 0x1000000) {
            // Disable temporal filter on NV4/5 if less than 16M
            pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
        }
    }

    // Disable fullscreen mirror on non-dual head devices
    if (pDriverData->dwHeads < 2)
    {
        pDriverData->vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSDEVICEMASK;
    }
    else
    {
        dbgError("NT4 direct draw driver is seeing more than 1 head!");

        // Disable anyway!
        pDriverData->dwHeads = 1;
        pDriverData->vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSDEVICEMASK;
    }

    dbgTracePop();
    return (DWORD)pDriverData;
} // DriverInit_NT4

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\drawescape.h ===
//*****************************Module*Header******************************
//
// Module Name: drawescape.h
//
// FNicklisch 14.09.00: New: added from ELSA code
//
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef _DRAWESCAPE_H
#define _DRAWESCAPE_H



#endif // _DRAWESCAPE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\fillpath.c ===
//******************************Module*Header***********************************
//
//  Module Name: fillpath.c
//
//  Contains the DrvFillPath routine.
//
//  Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"
/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    //**************************************************************************
    // NV: Not implemented.
    //**************************************************************************
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\enable.c ===
/************************** Module Header *************************************
//                                                                             *
//  Module Name: enable.c                                                      *
//                                                                             *
//  This module contains the functions that enable and disable the             *
//  driver, the pdev, and the surface.                                         *
//                                                                             *
//  Copyright (c) 1992-1996 Microsoft Corporation                              *
//                                                                             *
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "nvcm.h"
#include "ddminint.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "nvProcMan.h"
    #include "ddmini.h"
#endif
#include "oglDD.h"
#include "ogloverlay.h"
#include "oglutils.h"
#include "oglstereo.h"
#include "oglflip.h"
#include "nvdoublebuf.h"
#include "pixelfmt.h"
#include "linkedlist.h"
#include "savescreenbits.h"

// To get the NV11 twinview definitions
#include "nvMultiMon.h"

extern void FreeMemoryMultiMon(PDEV *ppdev);
extern BOOLEAN   TwinViewDataOK(PPDEV ppdev, NVTWINVIEWDATA *pData);
extern VOID ReadToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode);
extern VOID WriteToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode);

// 2 next functions are utils functions in nvMultiMon.c
//
extern void GetRegValueW(HANDLE hDriver, PWSTR keyName, PVOID keyData, ULONG keyDataSize);
extern void SetRegValueW(HANDLE hDriver, PWSTR keyName, PVOID keyData, ULONG keyDataSize);


extern BOOLEAN bQueryGDIModePruning(ULONG ulTwinView_State, ULONG ulPrimaryHead, ULONG ulPrimaryDeviceMask,
        ULONG ulHead, ULONG ulDeviceMask, ULONG ulACPISystem, ULONG ulGDIModePruning);

#if DBG
extern VOID GetDebugLevelRegValue(PPDEV ppdev);
#endif

#if defined(DX7) && (NVARCH >= 0x04)

#ifndef _WIN64
extern BOOL __stdcall nvDeterminePerformanceStrategy(GLOBALDATA *pDriverData, PDEV* ppdev);
#endif // D3D is not 64 bit code clean , skip for now...

#endif // DX7

// local prototypes
#ifdef NV3
BOOL bNV3CreateStdPatches(PDEV *ppdev);
VOID vNV3DestroyStdPatches(PDEV *ppdev, BOOL CreateStdPatchFailFlag);
#endif // NV3
VOID RenderRectangle(PDEV *ppdev);

VOID vCalibrate_XferSpeeds(PDEV *ppdev);    // Calibration routine to decide xfer chunk size
                                            // when doing a vram ram to sys mem xfer -steph


// save old client on list of PDEVs using this client

//******************************************************************************
//
//  GDIINFO ggdiDefault
//
//  This contains the default GDIINFO fields that are passed back to GDI
//  during DrvEnablePDEV.
//
//  NOTE: This structure defaults to values for an 8bpp palette device.
//        Some fields are overwritten for different colour depths.
//
//******************************************************************************

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};

//*********************** Public cStructure *************************************
//
//  DEVINFO gdevinfoDefault
//
//  This contains the default DEVINFO fields that are passed back to GDI
//  during DrvEnablePDEV.
//
//  NOTE: This structure defaults to values for an 8bpp palette device.
//        Some fields are overwritten for different colour depths.
//
//******************************************************************************

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
    GCAPS_MONO_DITHER       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_COLOR_DITHER     //|
     //GCAPS_ASYNCMOVE
#ifndef NVGDI
      | GCAPS_DIRECTDRAW
#endif
      ),
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

#ifdef NVD3D
//*********************************************************************
// This is the GLOBALDATA struct used to store the default settings
// for each GLOBALDATA struct created dynamically at DrvEnablePDEV
// time.
//*********************************************************************
GLOBALDATA  DefaultGlobalData;


//******************************************************************************
// This semaphore is used by the DX and GDI drivers to synchronize access to the
// DX GLOBALDATA struct.
//******************************************************************************
ENGSAFESEMAPHORE  NvSem = {(HSEMAPHORE) 0, 0L};
#endif // NVD3D

//************************* Public Structure ***********************************
//
//  FUNCTION TABLE:    DFVFN gadrvfn[]
//
//  Build the driver function table gadrvfn with function index/address
//  pairs.  This table tells GDI which DDI calls we support, and their
//  location (GDI does an indirect call through this table to call us).
//
//  Why haven't we implemented DrvSaveScreenBits?  To save code.
//
//  When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
//  the-fly by creating a temporary device-format-bitmap, and explicitly
//  calling DrvCopyBits to save/restore the bits.  Since we already hook
//  DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
//  the bits anyway (which would have been the main reason for implementing
//  DrvSaveScreenBits).  So we may as well save some working set.
//
//******************************************************************************

#ifdef NT4_MULTI_DEV
extern DRVFN gadrvfn[];
extern ULONG gcdrvfn;
#else //#ifdef NT4_MULTI_DEV

#if MULTI_BOARDS

//******************************************************************************
// Multi-board support has its own thunks...
//******************************************************************************

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) MulEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) MulCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) MulDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) MulEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) MulDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) MulAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) MulMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) MulSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) MulDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) MulSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) MulCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) MulBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) MulTextOut            },
    {   INDEX_DrvGetModes,              (PFN) MulGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) MulStrokePath         },
//  {   INDEX_DrvFillPath,              (PFN) MulFillPath           }, not supported
    {   INDEX_DrvPaint,                 (PFN) MulPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) MulRealizeBrush       },
    {   INDEX_DrvDestroyFont,           (PFN) MulDestroyFont        },
    // Note that we don't support DrvCreateDeviceBitmap for multi-boards
    // Note that we don't support DrvDeleteDeviceBitmap for multi-boards
    // Note that we don't support DrvStretchBlt for multi-boards
    // Note that we don't support DrvLineTo for multi-boards
    // Note that we don't support DrvEscape for multi-boards
    // Note that we don't support DrvDirectDraw functions for multi-boards
};

#elif DBG && !defined(QUIET)

//******************************************************************************
// On Checked builds, thunk everything through Dbg calls...
//******************************************************************************

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvLineTo,                (PFN) DbgLineTo             },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
//    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           }, // not suppported
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
//  {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         }, // not implemented or hooked
    {   INDEX_DrvDestroyFont,           (PFN) DbgDestroyFont        },
#ifndef NVGDI
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
#endif
    {   INDEX_DrvSynchronize,           (PFN) DbgSynchronize        },
    {   INDEX_DrvEscape,                (PFN) DbgEscape             },
    {   INDEX_DrvDrawEscape,            (PFN) DbgDrawEscape         },
    {   INDEX_DrvResetPDEV,             (PFN) DbgResetPDEV          },
    {   INDEX_DrvDescribePixelFormat,   (PFN) DrvDescribePixelFormat},
    {   INDEX_DrvSetPixelFormat,        (PFN) DrvSetPixelFormat     },
    {   INDEX_DrvSwapBuffers,           (PFN) DrvSwapBuffers        },

    #if _WIN32_WINNT >= 0x0500
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DbgIcmSetDeviceGammaRamp},
    {   INDEX_DrvDeriveSurface,         (PFN) DbgDeriveSurface},
    {   INDEX_DrvNotify,                (PFN) DbgDrvNotify},
    #ifndef NV3
    {   INDEX_DrvAlphaBlend,            (PFN) DbgAlphaBlend},           // not supported in nv3
    {   INDEX_DrvTransparentBlt,        (PFN) DbgTransparentBlt},       // not supported in nv3
    #endif
    #endif
#if (NVARCH >= 0x4)
    {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
#endif
};
#else

//******************************************************************************
// On Free builds, directly call the appropriate functions...
//******************************************************************************

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
//    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           }, // not supported
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
//  {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         }, // not implemented or hooked
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },
#ifndef NVGDI
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
#endif
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
    {   INDEX_DrvEscape,                (PFN) DrvEscape             },
    {   INDEX_DrvDrawEscape,            (PFN) DrvDrawEscape         },
    {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV          },
    {   INDEX_DrvDescribePixelFormat,   (PFN) DrvDescribePixelFormat},
    {   INDEX_DrvSetPixelFormat,        (PFN) DrvSetPixelFormat     },
    {   INDEX_DrvSwapBuffers,           (PFN) DrvSwapBuffers        },

    #if _WIN32_WINNT >= 0x0500
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp},
    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface},
    {   INDEX_DrvNotify,                (PFN) DrvNotify},
    #ifndef NV3
    {   INDEX_DrvAlphaBlend,            (PFN) DrvAlphaBlend},           // not supported in nv3
    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt},       // not supported in nv3
    #endif
    #endif
#if (NVARCH >= 0x4)
    {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
#endif
};
#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

#endif // NT4_MULTI_DEV


//******************************************************************************
//
//  Function:   GetDisplayUniqueness
//
//  Routine Description:
//
//      Returns the display uniqueness.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG GetDisplayUniqueness(PDEV *ppdev)
    {
    return ppdev->iUniqueness;
    }

//******************************************************************************
//
//  Function:   DrvResetPDEV
//
//  Routine Description:
//
//      Notifies the driver of a dynamic mode change.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE : okay, now GDI is allowed to continue with the mode switch
//      FALSE: Stop with the mode switch, return to the old mode. This causes
//             GDI to open a dialog that a reboot is necessary!
//
//******************************************************************************


BOOL DrvResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)

    {
    PDEV* ppdevNew = (PDEV*) dhpdevNew;
    PDEV* ppdevOld = (PDEV*) dhpdevOld;
    ULONG                       i;
    NV_OPENGL_GLOBAL_DATA*      nvGlobalData;
    long                        status;
    ULONG                       ulTemp;
    HSEMAPHORE                  csFifoTemp;
    NV_OPENGL_CLIENT_INFO      *clientInfo;
    BOOL                        bRet = FALSE; // default error exit

    // Do some test for OpenGL that might cause problems
    // in the new resolution
    if (!bOglResetPDEV(ppdevOld, ppdevNew))
        goto Exit;

    ppdevNew->iUniqueness             = ppdevOld->iUniqueness + 1;
#ifdef NVD3D
    ppdevNew->bDXGblStateInitialized = ppdevOld->bDXGblStateInitialized;
#endif // NVD3D
    ppdevOld->pfnAcquireOglMutex(ppdevOld);

    ppdevNew->dwGlobalModeSwitchCount = ppdevOld->dwGlobalModeSwitchCount;

    if (HWGFXCAPS_QUADRO_GENERIC(ppdevOld))
    {
        // The reference counter must be unique as long as the system isn't rebooted
        ppdevNew->ulSaveScreenBitsRefCounter = ppdevOld->ulSaveScreenBitsRefCounter;
        bSaveScreenBitsGarbageCollection(ppdevOld, 0); // remove all elements we've collected (GDI bug)
    }

    if (ppdevOld->oglGlobalPageMdl)
        {
        // This swap is done because we can't have global memory
        // allocated within the display driver.  PDEV is local
        // to current instantiation so we swap memory old and new
        // pointers and information.
        //
        // Swap new and old OGL pointers.  The old OGL pointer
        // is in use by clients so we can't free it but we can free
        // the new one.  So, swap them and the new one will get freed
        // when the disable PDEV call is made.
        //
        ULONG *oglGlobalPagePtr;           // OGL mutex lock variable
        ULONG oglGlobalPageSize;           // OGL mutex lock size in bytes
        PVOID oglGlobalPageMdl;            // MDL to locked down mutex page
        PVOID origOglGlobalPagePtr;        // OGL Ptr for allocated memory

        // tmp = New
        oglGlobalPagePtr  = ppdevNew->oglGlobalPagePtr;
        oglGlobalPageSize = ppdevNew->oglGlobalPageSize;
        oglGlobalPageMdl  = ppdevNew->oglGlobalPageMdl;
        origOglGlobalPagePtr = ppdevNew->origOglGlobalPagePtr;

        // New = Old
        ppdevNew->oglGlobalPagePtr  = ppdevOld->oglGlobalPagePtr;
        ppdevNew->oglGlobalPageSize = ppdevOld->oglGlobalPageSize;
        ppdevNew->oglGlobalPageMdl  = ppdevOld->oglGlobalPageMdl;
        ppdevNew->origOglGlobalPagePtr = ppdevOld->origOglGlobalPagePtr;

        // old = tmp
        ppdevOld->oglGlobalPagePtr  = oglGlobalPagePtr;
        ppdevOld->oglGlobalPageSize = oglGlobalPageSize;
        ppdevOld->oglGlobalPageMdl  = oglGlobalPageMdl;
        ppdevOld->origOglGlobalPagePtr = origOglGlobalPagePtr;

        nvGlobalData = (NV_OPENGL_GLOBAL_DATA *)ppdevNew->oglGlobalPagePtr;
        if (nvGlobalData)
            {
            ppdevNew->oglMutexPtr      = &nvGlobalData->oglMutex;
            ppdevNew->oglModeSwitchPtr = &nvGlobalData->oglModeSwitch;
            }

        nvGlobalData = (NV_OPENGL_GLOBAL_DATA *)ppdevOld->oglGlobalPagePtr;
        if (nvGlobalData)
            {
            ppdevOld->oglMutexPtr      = &nvGlobalData->oglMutex;
            ppdevOld->oglModeSwitchPtr = &nvGlobalData->oglModeSwitch;
            }
        }

    OglAcquireGlobalMutex();
    if (globalOpenGLData.oglClientListHead.clientList)
        {
        globalOpenGLData.oglClientListHead.clientList->refCount++;
        }


    // Update width and height of screen in each node.
    clientInfo = NULL; // start search at top of list
    while (bOglGetNextClient(&clientInfo))
        {
        NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

        ASSERT(bOglHasDrawableInfo(clientInfo));

#ifdef NV_MAIN_MULTIMON
        // NOTE: We want to check the old PDEV with
        // the one inside the clientInfo, so in a 
        // Multi-Monitor situation, we don't update
        // clients with the modeset PDEV.  Since we
        // keep multiple clients per-app/per-monitor,
        // we would end up having all the clients
        // point to the same monitor.  This is bad.
        if ( clientInfo->ppdev == ppdevOld ) {
            clientInfo->ppdev  = ppdevNew;
            clientDrawableInfo = clientInfo->clientDrawableInfo;
            if (clientDrawableInfo)
                {
                clientDrawableInfo->cxScreen = ppdevNew->cxScreen;
                clientDrawableInfo->cyScreen = ppdevNew->cyScreen;
                clientDrawableInfo->cxcyChanged = 1;
                }
            }
        }
#else
        clientInfo->ppdev  = ppdevNew;
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        if (clientDrawableInfo)
            {
            clientDrawableInfo->cxScreen = ppdevNew->cxScreen;
            clientDrawableInfo->cyScreen = ppdevNew->cyScreen;
            clientDrawableInfo->cxcyChanged = 1;
            }
        }
#endif


    OglReleaseGlobalMutex();

    // release mutex taken with previous ppdevOld->pfnAcquireOglMutex(ppdevOld);
    ulTemp = ppdevNew->bReleaseOglMutex;
    ppdevNew->bReleaseOglMutex = ppdevOld->bReleaseOglMutex;
    ppdevOld->bReleaseOglMutex = ulTemp;

    csFifoTemp = ppdevNew->csFifo;
    ppdevNew->csFifo = ppdevOld->csFifo;
    ppdevOld->csFifo = csFifoTemp;

    ppdevNew->bSupportOgl = ppdevOld->bSupportOgl;

    OglEnableModeSwitchUpdate(ppdevNew);

    ppdevNew->pfnReleaseOglMutex(ppdevNew);

    // we need to do this when switching back to a previously left desktopsize
    ppdevNew->oglDDrawSurfaceCount = 0;
    bClearPointerList(&ppdevNew->oglDDrawSurfaceCountList);

    // Transfer the state of the NVSVC service from the old prev to the new pdev.
    ppdevNew->ulNVSVCStatus = ppdevOld->ulNVSVCStatus;

    bRet = TRUE;
Exit:
    return(bRet);
    }


//******************************************************************************
//
//  Function:   DrvEnableDriver
//
//  Routine Description:
//
//      Enables the driver by retrieving the drivers function table and version.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)

    {
    //**************************************************************************
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.
    //**************************************************************************
    //**************************************************************************
    // Fill in as much as we can.
    //**************************************************************************
    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    //**************************************************************************
    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.
    //**************************************************************************

    if (cj >= sizeof(ULONG))

#if _WIN32_WINNT >= 0x0500  // Win2k or later OS
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;
#else // NT4 build uses NT4 DDK, so use version available in NT4 DDK WINDDI.H
        pded->iDriverVersion = DDI_DRIVER_VERSION;
#endif

    //**************************************************************************
    // Save the DDI version so we can tell the miniport which version of NT is running.
    //**************************************************************************
    //iOsVersion = iEngineVersion;

#if defined(DX7) && (NVARCH >= 0x04)

    //**************************************************************************
    // Create the semaphore used to sync access to the DX GLOBALDATA
    //**************************************************************************
    EngInitializeSafeSemaphore(&NvSem);

    //**************************************************************************
    // Initialize data which is GLOBAL to the DX7 driver. This data is not
    // associated with a particular device.
    //**************************************************************************
#ifndef _WIN64
    NvWin2KInitDXGlobals();
#endif // D3D is not 64 bit code clean , skip for now...

#endif  // DX7

    OglInitLayerPalette();

#ifdef NV_MAIN_MULTIMON
    /* Initialize the global PDEV list for OpenGL. */
    OglInitPDEVList();
#endif

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   DrvDisableDriver
//
//  Routine Description:
//
//      Tells the driver it is being disabled. Release any resources allocated in
//      DrvEnableDriver.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvDisableDriver(VOID)
    {
#if defined(DX7) && (NVARCH >= 0x04)
    //**************************************************************************
    // Create the semaphore used to sync access to the DX GLOBALDATA
    //**************************************************************************
    EngDeleteSafeSemaphore(&NvSem);
#endif  // DX7

#ifdef NV_MAIN_MULTIMON
    /* Destroy the global PDEV list for OpenGL. */
    OglDestroyPDEVList();
#endif

    return;
    }

//******************************************************************************
//
//  Function:   DrvEnablePDEV
//
//  Routine Description:
//
//    Initializes a bunch of fields for GDI, based on the mode we've been asked
//    to do.  This is the first thing called after DrvEnableDriver, when GDI
//    wants to get some information about us.
//
//    (This function mostly returns back information; DrvEnableSurface is used
//    for initializing the hardware and driver components.)
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

DHPDEV DrvEnablePDEV(
        DEVMODEW*   pdm,            // Contains data pertaining to REQUESTED MODE
        PWSTR       pwszLogAddr,    // Logical address
        ULONG       cPat,           // Count of standard patterns
        HSURF*      phsurfPatterns, // Buffer for standard patterns
        ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
        ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
        ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
        DEVINFO*    pdi,            // Device information
        HDEV        hdev,           // HDEV, used for callbacks
        PWSTR       pwszDeviceName, // Device name
        HANDLE      hDriver)        // Kernel driver handle

{
    PDEV* ppdev;
    ULONG ReturnedDataLength;
    NV_COMMON_DEVICE_INFO CommonDeviceInfo;

    //**************************************************************************
    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:
    //**************************************************************************
    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
        {
        DISPDBG((2, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
        }

    //**************************************************************************
    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:
    //**************************************************************************

    ppdev = EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
        {
        DISPDBG((2, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
        }
    memset(ppdev, 0, sizeof(PDEV));

    ppdev->hDriver = hDriver;
#if DBG
    GetDebugLevelRegValue(ppdev);
#endif

    if (ppdev && pdm)
    {
        DISPDBG((6,"DrvEnablePDev(): ppdev: 0x%x, requesting mode: (%d, %d), %d bpp, %d HZ\n",
            ppdev,pdm->dmPelsWidth,pdm->dmPelsHeight,pdm->dmBitsPerPel,pdm->dmDisplayFrequency));
    }

    //********************************************************************
    // Store our 'Unique' signature in the PPDEV
    //********************************************************************

    ppdev->NVSignature = NV_SIGNATURE;

    //********************************************************************
    // Store global settings in the PDEV. BUGBUG: GLOBAL VARS NOT ALLOWED!!!
    //********************************************************************

    ppdev->bEnableIF09 = TRUE; //bEnableIF09;

    //**************************************************************************
    //
    // OpenGL code:
    //
    // Create OGL mutex pointer and lock down the memory page
    //
    //**************************************************************************
    CreateOglGlobalMemory(ppdev);
    ppdev->bSupportOgl = (ULONG)TRUE; // Enable OpenGL support by default

#ifdef NV_MAIN_MULTIMON
    /* Add the ppdev to the global PDEV list for OpenGL.  See oglmultimon.c */
    OglAddPDEVToList(ppdev);
#endif

#ifdef NV3
        ppdev->bOglSingleBackDepthSupported = (ULONG)FALSE; // Not available on NV3
#else        
        ppdev->bOglSingleBackDepthSupported = (ULONG)TRUE; // Enable single-back-depth surfaces
#endif // NV3

    ppdev->DoubleBuffer.bEnabled = FALSE;

    

    //**************************************************************************
    // Get the current screen mode information.  Set up device caps and
    // devinfo:
    //**************************************************************************

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
        {
        DISPDBG((2, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
        }

    //**************************************************************************
    // Save position relative to desktop (0,0 on single monitor system and
    // relative to primary display on multi-monitor system)
    //**************************************************************************
#if _WIN32_WINNT >= 0x0500
    ppdev->left = pdm->dmPosition.x;
    ppdev->top = pdm->dmPosition.y;
#else
    // ASSUME NT4 builds...
    // will be set by NT4 multiboard wrapper
    ppdev->left = 0;
    ppdev->top = 0;
#endif // NVD3D

    //**************************************************************************
    // Initialize palette information.
    //**************************************************************************

    if (!bInitializePalette(ppdev, pdi))
        {
        DISPDBG((2, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
        }

    //**************************************************************************
    // We are running a version of NT which is >= 4.0. This means we can safely
    // enable P6 write combining when mapping the framebuffer. The following IOCTL
    // sets a flag in the device state which tells the miniport to do just that.
    // This needs to be done for every physical NV device enabled by this driver.
    //**************************************************************************
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_ENABLE_WRITE_COMBINING,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
        {
        DISPDBG((1, "DrvEnablePDEV - IOCTL_VIDEO_ENABLE_WRITE_COMBINING failed"));
        }

    //
    // Get common device information from miniport
    //
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_COMMON_DEVICE_INFO,
                           NULL,
                           0,
                           &CommonDeviceInfo,
                           sizeof(NV_COMMON_DEVICE_INFO),
                           &ReturnedDataLength))
    {
        DISPDBG((1, "DrvEnablePDEV - VIDEO_GET_COMMON_DEVICE_INFO failed"));
        goto ReturnFailure1;
    }
    ppdev->ulDeviceReference   = CommonDeviceInfo.ulDeviceReference;
    ppdev->ulEnableDualView    = CommonDeviceInfo.ulEnableDualView;
    ppdev->ulDualViewSecondary = CommonDeviceInfo.ulDualViewSecondary;
#if _WIN32_WINNT >= 0x0500
    ppdev->OsVersionInfo       = CommonDeviceInfo.OsVersionInfo;
    ppdev->SysMemInfo          = CommonDeviceInfo.SysMemInfo;
#endif // _WIN32_WINNT >= 0x0500

    //**************************************************************************
    // Get the OGL stencil registry switch
    //**************************************************************************

    ppdev->OglStencilSwitch = FALSE;

    if (EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH,
            NULL,
            0,
            &ppdev->OglStencilSwitch,
            sizeof(DWORD),
            &ReturnedDataLength))
    {
        DISPDBG((1, "DrvEnablePDEV - VIDEO_GET_OGL_STENCIL_SWITCH failed"));
    }


    // On NT4, there is no global DriverData struct.  Here we allocate and 
        // hang it on the PDEV.
        //
#if IS_WINNT4
    if (ppdev->pDriverData == NULL)
    {
        ppdev->pDriverData = EngAllocMem(FL_ZERO_MEMORY, sizeof(GLOBALDATA), ALLOC_TAG);
        if (ppdev->pDriverData == NULL)
        {
            goto ReturnFailure1;
        }
        ppdev->pDriverData->ppdev = ppdev;
    }
#endif

#if defined(DX7) && !defined(_WIN64) && (NVARCH >=0x04)
    if (NvWin2KAllocDriverData(ppdev))
    {
        DISPDBG((1, "DrvEnablePDEV - Allocation of DX7 GLOBALDATA failed"));
        goto ReturnFailure1;
    }

    //**************************************************************************
    // Initialize fixed 'global' data which is device specific (fixed on a
    // per device basis).
    //**************************************************************************
    nvDeterminePerformanceStrategy(ppdev->pDriverData, ppdev);
    ppdev->pDriverData->NvSemRefCnt = 0;

#endif  // DX7

    //**************************************************************************
    // Initialize nvidia class list structure
    //**************************************************************************
    ppdev->nvNumClasses = 0;
    ppdev->nvClassList = NULL;

    //**************************************************************************
    // Fill in the Eng..() procs with the default GDI routines.
    // This gets overloaded with the NV_Eng.._DBLBUF() procs in nvdoublebuf.c
    // when we are in double buffer mode
    //**************************************************************************
    ppdev->pfnEngBitBlt     = EngBitBlt;
    ppdev->pfnEngCopyBits   = EngCopyBits;
    ppdev->pfnEngTextOut    = EngTextOut;
    ppdev->pfnEngLineTo     = EngLineTo;
    ppdev->pfnEngStrokePath = EngStrokePath;
#if _WIN32_WINNT >= 0x0500
    ppdev->pfnEngAlphaBlend = EngAlphaBlend;
    ppdev->pfnEngTransparentBlt = EngTransparentBlt;
#endif

    //
    // Clear the default request for NVSVC to induce a modeset. It will be set later in HandleBiosHeads()
    // if needed. Also set the default status of NVSVC as stopped.
    //
    ppdev->ulInduceModeChangeDeviceMask = 0;
    ppdev->ulNVSVCStatus = NVSVC_STATUS_STOPPED;

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((1, "Failed DrvEnablePDEV"));

    return(0);
    }

//******************************************************************************
//
//  Function:   DrvDisablePDEV
//
//  Routine Description:
//
//     Release the resources allocated in DrvEnablePDEV.  If a surface has been
//     enabled DrvDisableSurface will have already been called.
//
//     Note that this function will be called when previewing modes in the
//     Display Applet, but not at system shutdown.  If you need to reset the
//     hardware at shutdown, you can do it in the miniport by providing a
//     'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
//
//     Note: In an error, we may call this before DrvEnablePDEV is done.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvDisablePDEV(DHPDEV dhpdev)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);

#if IS_WINNT4
    if (ppdev->pDriverData != NULL)
    {
        EngFreeMem(ppdev->pDriverData);
        ppdev->pDriverData = NULL;
    }
#endif

    //**************************************************************************
    //
    // OpenGL code:
    //
    // Destroy OGL mutex pointer and unlock down the memory page
    //
    //**************************************************************************
    DestroyOglGlobalMemory(ppdev);

#ifdef NV_MAIN_MULTIMON
    /* Remove the ppdev from the global PDEV list for OpenGL.  See oglmultimon.c */    
    OglRemovePDEVFromList(ppdev);
#endif

    // Free up any memory alloced by display driver for multimon purposes.
    FreeMemoryMultiMon(ppdev);

    EngFreeMem(ppdev);
}

//******************************************************************************
//
//  Function:   DrvCompletePDEV
//
//  Routine Description:
//
//      Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

//******************************************************************************
//
//  Function:   DrvSynchronize
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvSynchronize(DHPDEV dhpdev, RECTL  *prcl)
{
    PDEV*           ppdev;

    ppdev = (PDEV *)dhpdev;

    //**************************************************************************
    // Call the NV1/NV3/NV4 specific version of 'waiting while the engine is busy' routine
    //**************************************************************************

    ppdev->pfnWaitEngineBusy( ppdev );

    return;
}


#define CALIBRATION_ENABLED // enable calibration in DrvEnableSurface



//******************************************************************************
//
//  Function:   HSURF DrvEnableSurface
//
//      Creates the drawing surface, initializes the hardware, and initializes
//      driver components.  This function is called after DrvEnablePDEV, and
//      performs the final device initialization.
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

HSURF DrvEnableSurface(
DHPDEV dhpdev)
    {
    PDEV*   ppdev;
    HSURF   hsurf;
    DSURF*  pdsurf;
    BYTE*   TextureDataPtr;
    ULONG   i;
    PULONG  pulBmp;
    PULONG DMABufferStart;
    PULONG DMABufferEnd;
    PULONG VRAMStart;
    PULONG VRAMEnd;
    BOOL   UseDFBPrimary;
    ppdev = (PDEV*) dhpdev;

    // Turn off the DrvAssertMode flag.
    ppdev->ulDrvAssertModeTRUE = 0;

    //**************************************************************************
    // First enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...
    //**************************************************************************

    //**************************************************************************
    // EnableHardware mainly does 4 things:
    //      1) Gets access to framebuffer memory
    //      2) Gets access to miscellaneous memory mapped hardware registers
    //      3) Sets the mode, then fills in the ppdev fields (AssertModeHardware)
    //      4) Init the function table (NV1 functions vs NV3 functions)
    //**************************************************************************


    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // Call the NV1/NV3 specific version of 'waiting while the engine is busy' routine
    // ??? NEED TO INCLUDE THIS TO PREVENT INCONSISTENT LOCKUP ???
    //**************************************************************************

    ppdev->pfnWaitEngineBusy(ppdev);

    // test rect render patch (jsw)
    //RenderRectangle(ppdev);

    //**************************************************************************
    // EnableOffscreenHeap mainly does 3 things:
    //      1) Inits the heap to contain all of Video Memory, then..
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //!!! JOEHACK the next two should be done in EnableSurface to decouple  !!!
    //!!!         offscreen mgmt & bitmap caching from primary surface init !!!
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //      2) Allocates a permanent region for the visible screen
    //      3) Creates the wrapper surface objects that GDI will use,
    //         when we use GDI to draw to our offscreen DFB's.
    //**************************************************************************
    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // EnablePointer currently does nothing (just returns TRUE)
    //**************************************************************************

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // EnablePointer currently does nothing (just returns TRUE)
    // since we don't do glyph caching
    //**************************************************************************

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // EnableBrushCache currently does nothing (just returns TRUE)
    // since we don't do brush caching
    //**************************************************************************

    //**************************************************************************
    // Inits the 8bpp palette registers
    //**************************************************************************

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // EnableDirectDraw currently does measures vertical refresh rate
    // and sets the bit DIRECTDRAW_CAPABLE
    //**************************************************************************

    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // Initialize the ohScreen struct with primary screen info.  This should
    // be done before the DSURF stuct for the primary screen is initialized.
    //**************************************************************************

    ppdev->ohScreen.pdsurf         = &ppdev->dsurfScreen;
    ppdev->ohScreen.next           = NULL;
    ppdev->ohScreen.prev           = NULL;
    ppdev->ohScreen.nextEmpty      = NULL;
    ppdev->ohScreen.pHeap          = NULL;
    ppdev->ohScreen.ulSizeInBytes  = ppdev->cyScreen *
                                     ppdev->cxScreen * ppdev->cjPelSize;
    ppdev->ohScreen.ulOffset       = 0;
    ppdev->ohScreen.ulLinearStride = (ULONG)ppdev->lDelta;

    //**************************************************************************
    // Now create our private (DSURF) surface structure.
    // This DSURF structure is specifically used to denote the physical screen.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.
    //
    //JOEHACK - obsolete comment???
    // NV: For NV, this is not the case.  Since we started with a Dumb Frame
    //     Buffer driver, we used EngCreateBitmap to create a surface
    //     for the visible screen, so that we could let GDI draw directly
    //     to it.  Since then, Offscreen DFB's have now been implemented, and we
    //     can now go back to using EngCreateDeviceSurface to create the surface
    //     and have the code be more consistent.  But that would require
    //     BitBlt, TextOut and other code to be reworked (DFB testing code
    //     will need to be changed as well as wrapper surface functionality,
    //     so that we can tell if a bitmap is in system memory, or in VRAM).
    //     For now, we'll just continue using EngCreateBitmap. Basically, it
    //     doesn't seem to make that much of a difference.  If we decide
    //     to switch back to having our primary surface being Device-Managed,
    //     we'll need to add back the following code.
    //
    //     The bottom line, is that we can always default back to GDI to draw
    //     to ANY of our surface objects.
    //**************************************************************************

    pdsurf = &ppdev->dsurfScreen;

    //**********************************************************************
    // DSURF structures denote whether a DFB exists in offscreen memory (DT_SCREEN)
    // or whether it's been converted to a DIB (DT_DIB) in system memory.
    // Since this DSURF structure represents the physical screen, we init
    // the DSURF fields with the physical screen attributes.
    //**********************************************************************

    pdsurf->dt           = DT_SCREEN;           // Not to be confused with a DIB
    pdsurf->sizl.cx      = ppdev->cxScreen;     // Width of screen surface
    pdsurf->sizl.cy      = ppdev->cyScreen;     // Height of screen surface
    pdsurf->ppdev        = ppdev;               // Pointer to physical device
    pdsurf->poh          = &ppdev->ohScreen;    // The screen is a surface, too
    pdsurf->LinearPtr    = ppdev->pjScreen;
    pdsurf->LinearStride = (ULONG) ppdev->lDelta;

    //**************************************************************************
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.
    //
    // If we could map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it would be
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.  When we pass a call on to GDI
    // where it can't directly read/write to the surface bits because the
    // surface is device managed, it has to create a temporary bitmap and
    // call our DrvCopyBits routine to get/set a copy of the affected bits.
    // Fer example, the OpenGL component prefers to be able to write on the
    // framebuffer bits directly.
    //
    // NOTE: For NV, we don't have this problem.  We create the surface
    //       using EngCreateBitmap.  This allows us to pass any call we want
    //       to back to GDI. (Driver can run in Dumb Framebuffer mode if desired)
    //**************************************************************************

    // Always use a STYPE_DEVICE for our primary
    hsurf = (HSURF) EngCreateDeviceSurface( (DHSURF)pdsurf,
                                            pdsurf->sizl,
                                            ppdev->iBitmapFormat );
        
    
    if (hsurf == 0)
    {
        DISPDBG((1, "DrvEnableSurface - Failed EngCreateBitmap/DeviceSurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;     // Remember it for clean-up

    //**************************************************************************
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //**************************************************************************

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks ))
    {
        DISPDBG((1, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    //**************************************************************************
    // DrvEnableSurface Succeeded!
    //**************************************************************************

    if (HWGFXCAPS_QUADRO_GENERIC(ppdev))
    {
        // Create the linked list used to store DrvSaveScreenBits data
        if(!bLinkedListCreate(&(ppdev->pLinkedListSaveScreenBits), LL_CLASS_SAVESCREENBITS))
        {
            //  If failed, return immediately

            goto ReturnFailure;
        }
    }

    DISPDBG((5, "Passed DrvEnableSurface"));


    //**************************************************************************
    // Call the NV1/NV3 specific version of 'waiting while the engine is busy' routine
    // ??? NEED TO INCLUDE THIS TO PREVENT INCONSISTENT LOCKUP ???
    //**************************************************************************

    ppdev->pfnWaitEngineBusy(ppdev);

    // OpenGL init
    if (!bOglServicesInit(ppdev))
    {
        DISPDBG((1, "DrvEnableSurface - Failed bOglServicesInit"));
        goto ReturnFailure;
    }

    #ifdef  CALIBRATION_ENABLED
    
    vCalibrate_XferSpeeds(ppdev);   // Just before returning from this last stage
                                    // of the installation of the driver/pdev,
                                    // calibrate to setup ppdev->globalXferOverheadFactor
    #endif


#if _WIN32_WINNT >= 0x0500
    // In W2K the video card's acceleration level can be dynamically set through the Display Applet
    // Here we read the value because we need to disable e.g. page flipping on a sw cursor
    // as long as our double pumping double pumps even on to of opengl surfaces
    if (!EngQueryDeviceAttribute(ppdev->hdevEng, QDA_ACCELERATION_LEVEL, NULL, 0, &ppdev->ulDriverCompatibilityMode, sizeof(ULONG)))
#endif
    {
        // on NT4 or if we failed we assume full acceleration
        ppdev->ulDriverCompatibilityMode = 0;
    }

    return(hsurf);

    //**************************************************************************
    // DrvEnableSurface Failed!
    //**************************************************************************

ReturnFailure:

    DrvDisableSurface((DHPDEV) ppdev);
    ppdev->bEnabled = FALSE;

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
    }

//******************************************************************************
//
//  Function:   DrvDisableSurface
//
//  Routine Description:
//
//     Free resources allocated by DrvEnableSurface.  Release the surface.
//
//     Note that this function will be called when previewing modes in the
//     Display Applet, but not at system shutdown.  If you need to reset the
//     hardware at shutdown, you can do it in the miniport by providing a
//     'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
//
//     Note: In an error case, we may call this before DrvEnableSurface is
//           completely done.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************


VOID DrvDisableSurface(
DHPDEV dhpdev)

    {
    PDEV*   ppdev;
    BOOLEAN bHwDisabled;

    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.
    //**************************************************************************

    //**************************************************************************
    // DisableDirectDraw -> frees up memory taken my Direct Draw)
    // DisablePalette    -> does nothing
    // DisableBrushCache -> does nothing (we don't put brushes in offscreen memory)
    // DisableText       -> does nothing (we don't do glyph caching)
    // DisablePointer    -> does nothing
    // DisableOffscreenHeap -> frees up system memory used for offscreen heap
    //                         management, as well as the wrapper 'punt' surface objects
    //JOEHACK - move punt surfobj creation/deletion from  E/Doffscreenheap to E/Dsurface and fix the comment
    // DisableBanking    -> does nothing (we don't do banking in NV)
    // DisableHardware   -> frees up memory used to map frame buffer , as well
    //                      as memory used to map miscellaneous memory mapped
    //                      register ranges
    //**************************************************************************
    if (HWGFXCAPS_QUADRO_GENERIC(ppdev))
    {
        // Free the linked list used to store DrvSaveScreenBits data
        bSaveScreenBitsGarbageCollection(ppdev, 0); // remove all elements we've collected (GDI bug)
        bLinkedListDestroy(&(ppdev->pLinkedListSaveScreenBits));
    }

    bOglServicesDisable(ppdev);

    vDisableDirectDraw(ppdev);
    vDisablePalette(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);
    if (ppdev->hsurfScreen != NULL)
        EngDeleteSurface(ppdev->hsurfScreen);

    }

//******************************************************************************
//
//  Function:   AssertModeEnable
//
//  Routine Description:
//
//      Called by DrvAssertMode(dhpdev, TRUE);
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
BOOL AssertModeEnable(PDEV* ppdev)
{
    ULONG   ReturnedDataLength;

    //**************************************************************************
    // We are running a version of NT which is >= 4.0. This means we can safely
    // enable P6 write combining when mapping the framebuffer. The following IOCTL
    // sets a flag in the device state which tells the miniport to do just that.
    // This needs to be done for every physical NV device enabled by this driver.
    //**************************************************************************
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_ENABLE_WRITE_COMBINING,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
        {
        DISPDBG((1, "AssertModeEnable - IOCTL_VIDEO_ENABLE_WRITE_COMBINING failed"));
        }

    //**********************************************************************
    // Enable - Switch back to graphics mode
    //**********************************************************************

    //**********************************************************************
    // We have to enable every subcomponent in the reverse order
    // in which it was disabled:
    //**********************************************************************


    if (bAssertModeHardware(ppdev, TRUE))
    {
#if (_WIN32_WINNT >= 0x0500) && !defined(NV3)
        if (ppdev->bAgp) {
            ppdev->pDriverData->GARTPhysicalBase = ppdev->AgpHeap->lpHeap->fpGARTDev;
            ppdev->pDriverData->GARTLinearHeapOffset = ppdev->AgpHeap->lpHeap->fpGARTLin;
        }
#endif

        //******************************************************************
        // This really doesn't do anything, since BitBlt already
        // attempts to put DFB DIBs back into offscreen VRAM if possible
        //******************************************************************
        bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                //   return code with TRUE
        //******************************************************************
        // Init heap for direct draw if it was previously active.
        //******************************************************************
        if (ppdev->flStatus & STAT_DIRECTDRAW_ENABLED)
            if (!bAssertModeDirectDraw(ppdev, TRUE))
                return(FALSE);


        //******************************************************************
        // Re-enable the cursor
        //******************************************************************

        vAssertModePointer(ppdev, TRUE);

        if (!bOglAssertMode(ppdev, TRUE))
            return(FALSE);

        ppdev->bEnabled = TRUE;
        ppdev->dsurfScreen.LinearPtr = ppdev->pjScreen;

        return(TRUE);
    }
    return(FALSE);
}

//******************************************************************************
//
//  Function:   AssertModeDisable
//
//  Routine Description:
//
//      Called by DrvAssertMode(dhpdev, TRUE);
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
BOOL AssertModeDisable(PDEV* ppdev)
{
    BOOL  bReleaseOpenGLMutex = FALSE;
    ULONG ulRet;

    //**************************************************************************
    // If OpenGL is enabled, then wait for current push buffer to complete.
    //**************************************************************************

    //  Indicate that we are currently disabled, and should not call
    //  accelerated codes.

    ppdev->bEnabled = FALSE;

    if (!bOglAssertMode(ppdev, FALSE))
        return(FALSE);


    if (OglIsEnabled(ppdev))
    {
        ppdev->pfnAcquireOglMutex(ppdev);
        ppdev->pfnWaitForChannelSwitch(ppdev);
        ppdev->NVFreeCount = 0;
        bReleaseOpenGLMutex = TRUE;
    }

    //**********************************************************************
    // Disable - Switch to full-screen mode
    //**********************************************************************
    if(ppdev->pjScreen != NULL)
    {
        ULONG ulBytesToClear,ul;

        // clear visible screen
        ulBytesToClear = ppdev->lDelta * ppdev->cyScreen;

        for(ul = 0; ul < (ulBytesToClear / sizeof(ULONG)); ul++)
        {
            ((PULONG) ppdev->pjScreen)[ul] = 0;
        }
    }


    //**********************************************************************
    // NT4 - Disable directdraw offscreen heap if enabled.
    // NT5 - Destroy DX6 objects.
    //**********************************************************************
    if (!bAssertModeDirectDraw(ppdev, FALSE))
    {
        if (bReleaseOpenGLMutex == TRUE)
        {
            ppdev->pfnReleaseOglMutex(ppdev);
        }
        // Don't return so soon; let clean up other stuff.
        //return(FALSE);
    }

    //**********************************************************************
    // AssertModePalette doesn't do anything for NV.
    // We'll just leave it as a placeholder
    //**********************************************************************

    vAssertModePalette(ppdev, FALSE);

    //**********************************************************************
    // AssertModeBrushCache doesn't do anything for NV,
    // since we don't implement brushes in offscreen vram.
    //**********************************************************************

    //**********************************************************************
    // AssertModeBrushCache doesn't do anything for NV,
    // since we don't do glyph caching.
    // We'll just leave it as a placeholder
    //**********************************************************************

    vAssertModeText(ppdev, FALSE);

    //**********************************************************************
    // Disable/hide the cursor
    //**********************************************************************

    vAssertModePointer(ppdev, FALSE);

    //**********************************************************************
    // Make sure to move offscreen DFB's to system memory
    //**********************************************************************
    if (bAssertModeOffscreenHeap(ppdev, FALSE))
    {
    //******************************************************************
    // Now do the actual mode switch to full-screen
    //******************************************************************

        if (bAssertModeHardware(ppdev, FALSE))
        {
            if (bReleaseOpenGLMutex == TRUE)
            {
                ppdev->pfnReleaseOglMutex(ppdev);
                if (ppdev->oglMutexPtr) *(ppdev->oglMutexPtr) = 0;
            }

            if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_UNIQUENESS_VGA,
                               &ppdev->iUniqueness,
                               sizeof(ULONG),
                               NULL,
                               0,
                               &ulRet))
            {
                DISPDBG((1, "AssertModeDisable - Failed SET_UNIQUENESS_VGA IOCTL"));
            }


            return(TRUE);
        }
    }                                       //   return code with TRUE

    //**********************************************************************
    // Re-enable the cursor
    //**********************************************************************

    vAssertModePointer(ppdev, TRUE);

    if (bReleaseOpenGLMutex == TRUE)
    {
        ppdev->pfnReleaseOglMutex(ppdev);
        if (ppdev->oglMutexPtr) *(ppdev->oglMutexPtr) = 0;
    }

    return(FALSE);
}

//******************************************************************************
//
//  Function:   vDisableAcceleration
//
//  Routine Description:
//
//      
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
VOID vDisableAcceleration(PDEV* ppdev)
{
    ULONG ulReturnedDataLength;

    // Reset the chip
    if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_RESET_DEVICE,
                       NULL,
                       0,
                       NULL,
                       0,
                       &ulReturnedDataLength))
    {
        DISPDBG((1, "bAssertModeHardware - Failed reset IOCTL"));
    }

    // setup new mode by call miniport throught RmSetMode because
    // display driver has trouble to create/initialize the HW objects.
    if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_SET_CURRENT_MODE,
                       &ppdev->ulMode,  // input buffer
                       sizeof(DWORD),
                       &ppdev->bHwVidOvl,
                       sizeof(BOOLEAN),
                       &ulReturnedDataLength))
    {
        DISPDBG((1, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
    }

    // Disable all accelerations
    ppdev->bEnabled = FALSE; 
}

//******************************************************************************
//
//  Function:   DrvAssertMode
//
//  Routine Description:
//
//      This asks the device to reset itself to the mode of the pdev passed in.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;
    TOSHIBA_HOTKEY_MODE ToshibaHotKeyMode;

    ppdev = (PDEV*) dhpdev;

    if (bEnable)
    {
        // Indicate we are in DrvAssertMode(TRUE) so that we can obey the BOOT_DEVICEs for laptops.
        ppdev->ulDrvAssertModeTRUE = 1;
        // if we are already enabled, do nothing.
        if (ppdev->bEnabled)
        {
            DISPDBG((1, "DrvAssertMode(TRUE):Already enabled. Returning"));
            return(TRUE);
        }
    }
    else
    {
        // Indicate we are not in DrvAssertMode(TRUE)
        ppdev->ulDrvAssertModeTRUE = 0;
        if (!ppdev->bEnabled)
        {
            DISPDBG((1, "DrvAssertMode(FALSE): Already disabled. Returning"));
            return(TRUE);
        }
    }

#if _WIN32_WINNT >= 0x0500

    if (bEnable)
    {
        // Read in the Toshiba Hotkey mode. This is only for win2K or later.
        ToshibaHotKeyMode.ValidMode = 0;
        ReadToshibaHotKeyMode(ppdev->hDriver, &ToshibaHotKeyMode);
        if (ToshibaHotKeyMode.ValidMode == 1)
        {
            // We are here because of a hotkey switch. However, GDI is keeping the same mode so no need to
            // force GDI into the same mode.
            // Now turn off the hotkey mode.
            ToshibaHotKeyMode.ValidMode = 0;
            WriteToshibaHotKeyMode(ppdev->hDriver, &ToshibaHotKeyMode);
        }

        if(!AssertModeEnable(ppdev))
        {

            // Has trouble to assert mode
            // Let's disable them if any of them enabled


            if(!AssertModeDisable(ppdev))
            {
                //  If failed, exit immediately to avoid risk of access violation later
                //  in the code.

                // Free up any memory alloced by display driver for multimon purposes.
                FreeMemoryMultiMon(ppdev);
                return(FALSE);
            }

            // Disable acceleration
            vDisableAcceleration(ppdev);
            DISPDBG((0, "DrvAssertMode - all 2D accelerations are disable."));

        }
    }
    else
    {
        AssertModeDisable(ppdev);
        // Free up any memory alloced by display driver for multimon purposes.
        FreeMemoryMultiMon(ppdev);
    }
    // Always return TRUE to make OS kernal happy.
    return(TRUE);

#else

    if (bEnable)
    {
        if(AssertModeEnable(ppdev))
            return(TRUE);
    }
    else
    {
        if(AssertModeDisable(ppdev))
        {
            // Free up any memory alloced by display driver for multimon purposes.
            FreeMemoryMultiMon(ppdev);
            return(TRUE);
        }
    }
    DISPDBG((0, "DrvAssertMode - failed (bEnable = %d)", bEnable));
    // Free up any memory alloced by display driver for multimon purposes.
    FreeMemoryMultiMon(ppdev);
    return(FALSE);

#endif

}

//******************************************************************************
//
//  Function:   DrvGetModes
//
//  Routine Description:
//
//      Returns the list of available modes for the device.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)

    {
    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;
    DWORD cNumGDIModes;

    DISPDBG((6,"DrvGetModes() Enter\n"));

    //**************************************************************************
    // getAvailableModes mainly does 2 things
    //      1) Gets the TOTAL number of modes supported by the miniport
    //      2) Returns a pointer to the array of modes. The modes
    //         whose length is set to 0 are not valid for the display driver
    //**************************************************************************

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize, &cNumGDIModes);

    //**************************************************************************
    // If this fails, NT will go back to VGA
    //**************************************************************************

    if (cModes == 0 || cNumGDIModes == 0)
        {
        DISPDBG((1, "DrvGetModes failed to get mode information"));
        return(0);
        }


    //**************************************************************************
    // pdm points to the buffer where we'll store the valid modes
    // (DEVMODEW structures).  If pdm == NULL, we need to return
    // the number of bytes required to hold all the mode data.
    //**************************************************************************

    if (pdm == NULL)
        {
        cbOutputSize = cNumGDIModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
        }

    else

        {
        //**********************************************************************
        // Now copy the information for the supported modes back into the
        // output buffer
        //**********************************************************************

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do  {

            //******************************************************************
            // Now copy only the modes which this display driver supports
            //******************************************************************

            if (pVideoTemp->Length != 0)
                {

                //**************************************************************
                // Make sure we don't go past the end of the mode
                // buffer supplied to us
                //**************************************************************

                if (cOutputModes == 0)
                    {
                    break;
                    }

                //**************************************************************
                // Zero the entire structure to start off with.
                //**************************************************************

                memset(pdm, 0, sizeof(DEVMODEW));

                //**************************************************************
                // Set the name of the device to the name of the DLL.
                //**************************************************************

                DISPDBG((6, "exporting: (%d, %d) at %d bpp, %d HZ\n",
                    pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight,
                    pVideoTemp->BitsPerPlane,pVideoTemp->Frequency));

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //**************************************************************
                // Go to the next DEVMODE entry in the buffer.
                // cOutputModes represents the number of mode entries
                // left in the buffer supplied to us.
                //**************************************************************

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((BYTE *)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

                }

            //******************************************************************
            // Check next miniport mode
            //******************************************************************

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


            } while (--cModes);

        }

    //**************************************************************************
    // MAKE sure to free up this memory, which was allocated in
    // getAvailableModes()
    //**************************************************************************

    EngFreeMem(pVideoModeInformation);
    DISPDBG((1,"Returning number of modes: %d\n",(cbOutputSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE))));

    return(cbOutputSize);
    }

//******************************************************************************
//


//  Function:   bInitializeModeFields
//
//  Routine Description:
//
//      Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
//      devinfo based on the requested mode.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************


BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)

    {
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;
    ULONG i;
    TOSHIBA_HOTKEY_MODE     ToshibaHotKeyMode;
    DWORD cNumGDIModes;

    //**************************************************************************
    // Call the miniport to get mode information
    //**************************************************************************

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize, &cNumGDIModes);
    if (cModes == 0)
        goto bInitializeModeFields_ReturnFalse;

#if _WIN32_WINNT >= 0x0500
    // Read in the Toshiba Hotkey mode.
    ToshibaHotKeyMode.ValidMode = 0;
    ReadToshibaHotKeyMode(ppdev->hDriver, &ToshibaHotKeyMode);
    if (ToshibaHotKeyMode.ValidMode == 1)
    {
        // We are here because of a hotkey switch. So overwrite the 'pdm'. This will automatically percolate the desired mode
        // to 'pgdi'.
        pdm->dmPelsWidth = ToshibaHotKeyMode.Width;
        pdm->dmPelsHeight = ToshibaHotKeyMode.Height;
        pdm->dmBitsPerPel = ToshibaHotKeyMode.Depth;
        pdm->dmDisplayFrequency = ToshibaHotKeyMode.RefreshRate;

        // Now turn off the hotkey mode.
        ToshibaHotKeyMode.ValidMode = 0;
        WriteToshibaHotKeyMode(ppdev->hDriver, &ToshibaHotKeyMode);
    }

#endif _WIN32_WINNT >= 0x0500

    //****************************************************************************************
    // Now check if we were asked to force a mode: if we started this 
    // one-time-after-reboot-forced-mode sequence, but we haven't rebooted yet,
    // we just clear the flag that indicate the start of this sequence. This means
    // the user switched mode before rebooting.  Else, we do the mode overide if the
    // sequence is at the "end" (only the mode overide is missing)
    // This sequence goes like :  
    //                            hwinit()        -> ForceModeNextBoot := 1 (if we want to force this sequence)
    //                            reboot
    //                            hwinit()        -> ForceModeNextBoot := 0, ReBootedNowForceMode.ValidMode := 1
    //                                                 ( if ForceModeNextBoot == 1 )
    //
    //                            drvenablepdev() -> + ReBootedNowForceMode.ValidMode := 0
    //                                               | Overide mode
    //                                               |
    //                                               +--> this is only done if ForceModeNextBoot == 0, and 
    //                                                    ReBootedNowForceMode.ValidMode == 1
    //
    //                                               Else, if ForceModeNextBoot == 1, we halt the sequence here
    //                                               because we're assuming the user sets a mode and that
    //                                               overides our force sequence.
    //
    // SEE \nv_mini\nv.c: CheckForcedResolution()
    //
    // (The next comments are pulled from that:)
    //
    // In DrvEnablePdev(): ***!ASSUMING it is called ONLY on modeset!*** 
    //
    //
    //    1) read the ForceModeNextBoot flag: 
    //
    //                     if it is set ->        clear it ! (the user changed the mode but we haven't rebooted
    //                                            yet because otherwise, on reboot, in this very function,
    //                                            we would have cleared it);   ReBootedNowForceMode.ValidMode is 
    //                                            probably = 0, else the state is inconsistant.
    //                     else 
    //                         -> 
    //                     read the ReBootedNowForceMode.ValidMode flag:  
    //            
    //                         if it is set -> clear it and overide the GDI mode with
    //                                         ReBootedNowForceMode;
    //                         else 
    //                             -> nothing special;
    //
    //  was already induced, we already have a mode to set, from a previous call to this function)
    //
    //****************************************************************************************

    {
        ULONG           ForceModeNextBoot;

        
        ForceModeNextBoot = 0;

        GetRegValueW( ppdev->hDriver, L"ForceModeNextBoot", (PVOID) &ForceModeNextBoot, sizeof(ULONG));

        if( ForceModeNextBoot == 1)
        {
            // Force mode sequence started but we haven't rebooted and the user switch mode, so 
            // overide the sequence

            ForceModeNextBoot = 0;
            SetRegValueW( ppdev->hDriver, L"ForceModeNextBoot", (PVOID) &ForceModeNextBoot, sizeof(ULONG));
        }
        else
        {
            // Check to see if a force mode sequence needs to be completed
            
            MODE_ENTRY      ModeEntry;
        
            GetRegValueW( ppdev->hDriver, L"ReBootedNowForceMode", (PVOID) &ModeEntry, sizeof(MODE_ENTRY));

            if( ModeEntry.ValidMode == 1 )
            {
                // Clear the flag, and overide the mode asked by GDI

                ModeEntry.ValidMode = 0;
                
                // Overwrite the 'pdm' field (DEVMODEW).
                
                pdm->dmPelsWidth  = ModeEntry.Width;
                pdm->dmPelsHeight = ModeEntry.Height;
                pdm->dmBitsPerPel = ModeEntry.Depth;
                pdm->dmDisplayFrequency = ModeEntry.RefreshRate;

                SetRegValueW( ppdev->hDriver, L"ReBootedNowForceMode", (PVOID) &ModeEntry, sizeof(MODE_ENTRY));    
            
            } // ... if validmode (then we overide the mode asked by GDI with the mode in the key)

        }// ...else forcemodenextboot = 0;  (need to check for force mode sequence)
    }

    //*** ...check for a forced mode we wanted to set ****************************************


    //**************************************************************************
    // Now see if the requested mode has a match in that table.
    //**************************************************************************

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
        {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
        }
    else
        {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
        }

    //**************************************************************************
    // Check the requested mode against the miniport modes until we find a match
    //**************************************************************************

    while (cModes--)
        {
        if (pVideoTemp->Length != 0)
            {
            DISPDBG((8, "   Checking against miniport mode:"));
            DISPDBG((8, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((8, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((8, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((8, "      Frequency     -- %li", pVideoTemp->Frequency));

            //******************************************************************
            // If the default mode is requested, use the first mode entry
            //******************************************************************

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
                {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
                }
            }


        //**********************************************************************
        // Check next miniport mode
        //**********************************************************************

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

        }

    //**************************************************************************
    // If no mode has been found, return an error
    //**************************************************************************

    if (pVideoModeSelected == NULL)
        {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto bInitializeModeFields_ReturnFalse;
        }

    //**************************************************************************
    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.
    //**************************************************************************

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    #if DEBUG_HEAP
        VideoModeInformation.VisScreenWidth  = 640;
        VideoModeInformation.VisScreenHeight = 480;
    #endif

    //**************************************************************************
    // Set up screen information from the mini-port:
    //**************************************************************************

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;
    ppdev->cBitsPerPel      = VideoModeInformation.BitsPerPlane;
    ppdev->ulGDIRefreshRate      = VideoModeInformation.Frequency;

    // For Twinview purposes
    // GDI tells us the refresh rate for the first head. nVidia panel tells us the refresh rate for the second head.
    ppdev->ulRefreshRate[0]      = VideoModeInformation.Frequency;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    //**************************************************************************
    // We'll slowly add accelerations, starting with BITBLT
    //**************************************************************************
    ppdev->flHooks = (HOOK_SYNCHRONIZEACCESS |
                      HOOK_SYNCHRONIZE       |
                      HOOK_BITBLT            |
                      HOOK_COPYBITS          |
                      HOOK_TEXTOUT           |
                      HOOK_PAINT             |
                      HOOK_STROKEPATH        |
//                      HOOK_FILLPATH          |
                      HOOK_LINETO 
#if _WIN32_WINNT >= 0x0500 
#ifndef NV3
                      | HOOK_ALPHABLEND
                      | HOOK_TRANSPARENTBLT
#endif
#endif                      
                      );


    //**************************************************************
    // It's a device-managed surface; make sure we don't set
    // HOOK_SYNCHRONIZE, otherwise we may confuse GDI:
    //**************************************************************
    ppdev->flHooksDeviceBitmap = ppdev->flHooks & ~HOOK_SYNCHRONIZE;

    //**************************************************************
    // Setting the SYNCHRONIZEACCESS flag tells GDI that we
    // want all drawing to the bitmaps to be synchronized (GDI
    // is multi-threaded and by default does not synchronize
    // device bitmap drawing -- it would be a Bad Thing for us
    // to have multiple threads using the accelerator at the
    // same time):
    //**************************************************************

    ppdev->flHooksDeviceBitmap  |= HOOK_SYNCHRONIZEACCESS;


    //**************************************************************************
    // We currently don't implement the following functions
    //
    //          HOOK_STRETCHBLT         -> Not that important speed wise?
    //                                     Current version doesn't handle DFB's
    //          HOOK_FILLPATH           -> Not implemented
    //          HOOK_STROKEANDFILLPATH  -> Not implemented
    //
    //**************************************************************************

    //**************************************************************************
    // Make sure that Clipping rectangle gets reset by the first hardware function
    // By default, the clipping rectangle should include ALL of video memory
    // (including offscreen). Whenever we change it, we need to set this flag.
    // So, by setting it here, the first function we get to will reset
    // the clipping rectangle.
    //**************************************************************************

    ppdev->NVClipResetFlag=1;

    //**************************************************************************
    // Used to test successful return of functions without doing anything
    // The following variables are just used for debugging and profiling
    //**************************************************************************

    ppdev->NVAbsoluteLimitFlag      = FALSE;
    ppdev->NVStubTest               = FALSE;
    ppdev->NVRecordFunctionsFlag    = 0;
    for (i=0;i<70;i++)
        ppdev->NVLocation[i]=0;

    //**************************************************************************
    // Fill in the GDIINFO data structure with the default 8bpp values:
    // NOTE: This is a global variable/structure!  May need to
    //       change it if we implement multiple board functionality
    //**************************************************************************

    *pgdi = ggdiDefault;

    //**************************************************************************
    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:
    //**************************************************************************

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    //
    // The analog clock on the lower right end of the task bar needs to be circular shaped always.
    // So adjust the millimeter size of the width or height accordingly for spanning modes.
    //
    if (HORIZONTAL_MODE(VideoModeInformation.VisScreenWidth, VideoModeInformation.VisScreenHeight))
    {
        //
        // Double the horizontal size
        //
        pgdi->ulHorzSize *= 2;

    }
    else
    if (VERTICAL_MODE(VideoModeInformation.VisScreenWidth, VideoModeInformation.VisScreenHeight))
    {
        //
        // Double the vertical size.
        //
        pgdi->ulVertSize *= 2;
    }

    //**************************************************************************
    // Fill in the devinfo structure with the default 8bpp values:
    //**************************************************************************

    *pdi = gdevinfoDefault;

    //**************************************************************************
    // Initialize the ppdev field values according to the bitdepth
    //**************************************************************************

    if (VideoModeInformation.BitsPerPlane == 8)

        {
        ppdev->cjPelSize       = 1;
        ppdev->iBitmapFormat   = BMF_8BPP;
        ppdev->ulWhite         = 0xff;
        ppdev->physicalColorMask = 0xff;

        //**********************************************************************
        // Assuming palette is orthogonal - all colors are same size.
        //**********************************************************************

        ppdev->cPaletteShift   = 8 - pgdi->ulDACRed;
        pdi->flGraphicsCaps   |= (GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
        DISPDBG((3, "palette shift = %d\n", ppdev->cPaletteShift));
        }

    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
        {
        ppdev->cjPelSize       = 2;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->ulWhite         = 0xffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->physicalColorMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        #if _WIN32_WINNT >= 0x0500

        //
        //  Allow system to call DrvIcmSetDeviceGammaRamp
        //

        pdi->flGraphicsCaps2 |= GCAPS2_CHANGEGAMMARAMP;
        pdi->flGraphicsCaps2 |= GCAPS2_ALPHACURSOR;

        pdi->flGraphicsCaps2 |= GCAPS2_ICD_MULTIMON;

        #endif

        }

    else

        {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 32,
         "This driver supports only 8, 16, and 32bpp");

        ppdev->cjPelSize       = 4;
        ppdev->iBitmapFormat   = BMF_32BPP;
        ppdev->ulWhite         = 0xffffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->physicalColorMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        #if _WIN32_WINNT >= 0x0500

        //
        //  Allow system to call DrvIcmSetDeviceGammaRamp
        //

        pdi->flGraphicsCaps2 |= GCAPS2_CHANGEGAMMARAMP;
        pdi->flGraphicsCaps2 |= GCAPS2_ALPHACURSOR;

        pdi->flGraphicsCaps2 |= GCAPS2_ICD_MULTIMON;

        #endif
        }

    DISPDBG((5, "Passed bInitializeModeFields"));

    return(TRUE);

bInitializeModeFields_ReturnFalse:

    DISPDBG((1, "Failed bInitializeModeFields"));

    return(FALSE);
    }

//******************************************************************************
//
//  Function:   getAvailableModes
//
//  Routine Description:
//
//     Calls the miniport to get the master list of modes in the registry.
//     Returns the number of entries in the videomode buffer 'modeInformation'.
//     0 means no modes are supported by the miniport or that an error occured.
//     The number of modes returned is the total number of modes in the master mode list
//     read from the registry and returned via 'modeInformation'.
//     The actual number of modes supported in the current
//     desktop (standard/clone/span modes and EDID based pruning) which needs to be
//     exported to the GDI via DrvgetModes() is returned in the out parameter 'pcNumGDIModes'.
//     The validated GDI modes in the 'modeINformation' list can be identified by the 'Length'
//     field being non-zero.
//
//     NOTE: the buffer must be freed up by the caller.
//
//  Arguments:
//
//  Return Value:
//
//
//
//******************************************************************************


DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,       // Must be freed by caller
DWORD*                   cbModeSize,
DWORD*                   pcNumGDIModes)

{
    ULONG                   ulTemp, ulRet, ulRetSize;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    NVTWINVIEWDATA sData;
    ULONG   TwinView_State, TwinView_Orientation;
    ULONG   ReturnedDataLength, NumDacsOnBoard;
    GET_NUMBER_DACS   NumberDacs;
    ULONG   PrimaryHead;
    ULONG   PrimaryDeviceMask;
    ULONG   ulDeviceDisplay[NV_NO_DACS];
    ULONG TwinViewRegistryDataOK = 0;
    MODE_ENTRY RequestedMode, BestFitMode;
    ULONG MaxCommonWidth, MaxCommonHeight;
    ULONG i, j;
    ULONG PhysWidth, PhysHeight, ulHead;
    MODE_ENTRY *PhysModeList[NV_NO_DACS];
    ULONG NumPhysModes[NV_NO_DACS];
    MODE_ENTRY *SingleVirtualModeList;
    ULONG NumSingleVirtualModes;
    MODE_ENTRY *PhysModePtr;
    MODE_ENTRY *DestPtr;
    BOOLEAN bFoundPhysMode;
    ULONG MustHaveResolution;
    DWORD cNumGDIModes = 0;

    *pcNumGDIModes = 0;    
    //**************************************************************************
    // Get the number of modes supported by the mini-port
    //**************************************************************************

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((1, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //**************************************************************************
    // Allocate the buffer for the mini-port to write the modes in.
    //**************************************************************************

    *modeInformation = EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes * modes.ModeInformationLength,
                                   ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }


    //**************************************************************************
    // See if we are in clone or normal or multimon mode on a dual head system.
    // if we are on a single head system, then we always assume a normal mode.
    //**************************************************************************
    NumberDacs.ulNumberDacsOnBoard = 1;
    NumberDacs.ulNumberDacsConnected = 1;
    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_GET_NUMBER_DACS,
                           NULL,
                           0,
                           &NumberDacs,
                           sizeof(NumberDacs),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "getAvailableModes() - IOCTL_VIDEO_GET_NUMBER_DACS failed"));
    }
    else
    {
        DISPDBG((6, "Got NumDacsOnBoard: 0x%x, NumDacsConnected: 0x%x\n",NumberDacs.ulNumberDacsOnBoard,
                 NumberDacs.ulNumberDacsConnected ));
    }
    if (NumberDacs.ulNumberDacsOnBoard == 0 || NumberDacs.ulNumberDacsOnBoard > 2)
    {
        DISPDBG((0, "Oops! Invalid NumberDacs.ulNumberDacsOnBoard: 0x%x, assuming single headed board\n",NumberDacs.ulNumberDacsOnBoard));
        NumberDacs.ulNumberDacsOnBoard = 1;
    }
    if (NumberDacs.ulNumberDacsConnected == 0 || NumberDacs.ulNumberDacsConnected > 2)
    {
        DISPDBG((0, "Oops! Invalid NumberDacs.ulNumberDacsConnected: 0x%x, assuming single headed board\n",NumberDacs.ulNumberDacsConnected));
        NumberDacs.ulNumberDacsConnected = 1;
    }

    //
    // Assume a safe default state
    //
    TwinView_State = NVTWINVIEW_STATE_NORMAL;

    PrimaryHead = NumberDacs.ulDeviceDisplay[0];
    PrimaryDeviceMask = NumberDacs.ulDeviceMask[PrimaryHead];

    //
    // Initialize the modelist pointers to NULL
    //
    for (i=0; i < NV_NO_DACS; i++)
    {
        PhysModeList[i] = NULL;
        ulDeviceDisplay[i]= NumberDacs.ulDeviceDisplay[i];
    }
    SingleVirtualModeList = NULL;

    
    if ((NumberDacs.ulNumberDacsOnBoard == 2 && NumberDacs.ulNumberDacsConnected == 2) ||
        (NumberDacs.ulNumberDacsOnBoard == 2 && NumberDacs.ulNumberDacsConnected == 1) ||
        (NumberDacs.ulNumberDacsOnBoard == 1 && NumberDacs.ulNumberDacsConnected == 1))
    {
        
        if (EngDeviceIoControl(hDriver,
                               IOCTL_VIDEO_GET_TWINVIEW_STATE,
                               NULL,
                               0,
                               &sData,
                               sizeof(NVTWINVIEWDATA),
                               &ReturnedDataLength))
        {
            DISPDBG((3, "InitMultiMon() - IOCTL_VIDEO_GET_TWINVIEW_STATE failed"));
            TwinView_State = NVTWINVIEW_STATE_NORMAL;
        }
        else
        {
            DISPDBG((6,"Read the registry state as: 0x%x\n",sData.dwState));

            // sanity check to see if the TwinViewInfo data is valid.
            // 'NULL' is because we don't get a pointer to ppdev in DrvGetModes.
            if (sData.dwState == NVTWINVIEW_STATE_DUALVIEW)
                TwinView_State = sData.dwState;

            if (!TwinViewDataOK((PPDEV)NULL, &sData))
            {
                TwinViewRegistryDataOK = 0; 
            }
            else
            {
                TwinView_State = sData.dwState;
                TwinView_Orientation = sData.dwOrientation;
                PrimaryHead = sData.dwDeviceDisplay[0];
                PrimaryDeviceMask = sData.NVTWINVIEWUNION.nvtwdevdata[PrimaryHead].dwDeviceMask;

                for (i = 0; i < NV_NO_DACS; i++)
                    ulDeviceDisplay[i]= sData.dwDeviceDisplay[i];
                DISPDBG((6,"Read the Primary head as: 0x%x\n",PrimaryHead));
                TwinViewRegistryDataOK = 1;

                if (TwinView_State != NVTWINVIEW_STATE_NORMAL && TwinView_State != NVTWINVIEW_STATE_CLONE &&
                    TwinView_State != NVTWINVIEW_STATE_DUALVIEW && TwinView_State != NVTWINVIEW_STATE_SPAN)
                {
                    DISPDBG((0, "getAvailableModes - Invalid State read from registry: 0x%x,TwinView_State"));
                    return 0;
                }
                if (TwinView_State == NVTWINVIEW_STATE_SPAN)
                {
                    if (TwinView_Orientation != HORIZONTAL_ORIENTATION && TwinView_Orientation != VERTICAL_ORIENTATION)
                    {
                        DISPDBG((0, "getAvailableModes - Invalid Orientation read from registry: 0x%x for MULTIMON state\n",TwinView_Orientation));
                        return 0;
                    }
                }
            }
        }
    }



    //**************************************************************************
    // Ask the mini-port to fill in the available modes.
    //**************************************************************************

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((1, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //**************************************************************************
    // Allocate the temporary buffers to hold the physical modelist
    // for each head and the single resolution virtual mode list.
    //**************************************************************************
    for (i = 0; i < NumberDacs.ulNumberDacsOnBoard; i++)
    {
        PhysModeList[i] = (MODE_ENTRY *)EngAllocMem(FL_ZERO_MEMORY,
                                                    modes.NumModes * sizeof(MODE_ENTRY),
                                                    ALLOC_TAG);
        if (PhysModeList[i] == (MODE_ENTRY *) NULL)
        {
            DISPDBG((0, "getAvailableModes - Failed EngAllocMem for PhysModeList: %d", i));
            goto getAvailableModesFailure;
        }
    }

    SingleVirtualModeList = (MODE_ENTRY *)EngAllocMem(FL_ZERO_MEMORY,
                                                      modes.NumModes * sizeof(MODE_ENTRY),
                                                      ALLOC_TAG);
    if (SingleVirtualModeList == (MODE_ENTRY *) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem for PhysModeList1"));
        goto getAvailableModesFailure;
    }

    // Invalidate all the doubled modes from the VirtualModeList.
    NumSingleVirtualModes = 0;
    pVideoTemp = *modeInformation;
    DestPtr = SingleVirtualModeList;
    for (i=0; i<modes.NumModes; i++)
    {
        if (pVideoTemp)
        {
            if (MULTIMON_MODE(pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight))
            {
                // Do not copy.
                pVideoTemp++;
                continue;
            }
            // This is a single resolution virtual mode. So copy it.
            DestPtr->Width = (USHORT)pVideoTemp->VisScreenWidth;
            DestPtr->Height = (USHORT)pVideoTemp->VisScreenHeight;
            DestPtr->Depth = (USHORT)pVideoTemp->BitsPerPlane;
            DestPtr->RefreshRate = (USHORT)pVideoTemp->Frequency;
            DestPtr->ValidMode = TRUE;
            NumSingleVirtualModes++;
            DestPtr++;
            pVideoTemp++;
        }
    }

    //**************************************************************************
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //**************************************************************************

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    
    //**************************************************************************
    // Get the physical mode list for all the heads from miniport.
    // We already have this info in PDEV but we don't get the ppdev passed to us
    // in DrvGetModes()
    //**************************************************************************
    for (i=0; i < NumberDacs.ulNumberDacsOnBoard; i++)
    {
        HEAD_MODE_LIST_INFO VirtInfo;
        
        ulHead = ulDeviceDisplay[i];
        VirtInfo.ulHead = ulHead;

        // Use the correct default values if the registry entry is absent
        if (!TwinViewRegistryDataOK)
        {
            VirtInfo.ulDeviceMask = NumberDacs.ulDeviceMask[ulHead];
            VirtInfo.ulDeviceType = NumberDacs.ulDeviceType[ulHead];
            VirtInfo.ulTVType = NumberDacs.ulTVFormat[ulHead];
            VirtInfo.ulEnableDDC = 1;
        }
        else
        {
            VirtInfo.ulDeviceMask = sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
            VirtInfo.ulDeviceType = sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType;
            VirtInfo.ulTVType = sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat;
            VirtInfo.ulEnableDDC = sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwEnableDDC;
            VirtInfo.ulEnableDDC = 1;
        }
        
        VirtInfo.pVirtualModeList = SingleVirtualModeList;
        VirtInfo.ulNumVirtualModes = NumSingleVirtualModes;

        VirtInfo.pPhysicalModeList = PhysModeList[ulHead];

        // Call the IOCTL for the miniport to return the physical modes.
        ulRet = EngDeviceIoControl(hDriver,
                                   IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST,
                                   (HEAD_MODE_LIST_INFO *)&VirtInfo,
                                   sizeof(HEAD_MODE_LIST_INFO),
                                   NULL,
                                   0,
                                   &(ulRetSize));
        if (ulRet)
        {
            DISPDBG((0,"Oops! IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST failed!"));
            return(FALSE);
        }
        else
        {
            if (ulRetSize == 0)
            {
                DISPDBG((0,"Oops! Number of physical modes for head: %d is 0",i));
                return(FALSE);
            }

            NumPhysModes[ulHead] = ulRetSize/sizeof(MODE_ENTRY);

        }
    }
    

    //**************************************************************************
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 16, 32 bits per pel.
    //**************************************************************************

    while (ulTemp--)
    {

        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) && //24bpp
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                     pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }


        // export only single resolution modes for the normal or clone modes


        MustHaveResolution = 0;

        if(TwinView_State == NVTWINVIEW_STATE_SPAN && 
            pVideoTemp->VisScreenWidth != 480 && pVideoTemp->VisScreenHeight != 360 &&
            pVideoTemp->VisScreenWidth <= 640 && pVideoTemp->VisScreenHeight <= 480)
        {
            // Also export low resolution for spanning mode for DirectDraw
            MustHaveResolution = 1;
        }
        else  
        {
            // The exception is the 640x480 and 800x600 modes which NT4.0 and Win2K expects to be there always.
            // In win2k, GDI inserts 640x480 and 800x600 modes at 4bpp if the driver does not support it natively.
            // Also PC99 14.8 says that 1024x768 should always be supported.

            if ((pVideoTemp->VisScreenWidth == 640 && pVideoTemp->VisScreenHeight == 480) ||
                (pVideoTemp->VisScreenWidth == 800 && pVideoTemp->VisScreenHeight == 600) ||
                (pVideoTemp->VisScreenWidth == 1024 && pVideoTemp->VisScreenHeight == 768))
            {
            // do not skip these modes. Otherise you will see the ugly 4BPP vga modes show up in NT panel list of modes.
            MustHaveResolution = 1;
            }
        }


        if (TwinView_State == NVTWINVIEW_STATE_NORMAL || TwinView_State == NVTWINVIEW_STATE_CLONE || TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
        {
            if (MULTIMON_MODE(pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight))
            {
                pVideoTemp->Length = 0;
            }
        }

        // export only horizontal doubled modes if the state is MULTIMON and orinetation is HORIZONTAL
        if (TwinView_State == NVTWINVIEW_STATE_SPAN && TwinView_Orientation == HORIZONTAL_ORIENTATION)
        {
            if (!(HORIZONTAL_MODE(pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight)))
            {
                if (!MustHaveResolution)
                {
                    pVideoTemp->Length = 0;
                }

            }
        }

        // export only vertical doubled modes if the state is MULTIMON and orinetation is VERTICAL
        if (TwinView_State == NVTWINVIEW_STATE_SPAN && TwinView_Orientation == VERTICAL_ORIENTATION)
        {
            if (!(VERTICAL_MODE(pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight)))
            {
                if (!MustHaveResolution)
                {
                    pVideoTemp->Length = 0;
                }
            }
        }


        


        //
        // Peter Daifuku's specs says that for Rel 6.0, we limit the desktop to 2X the smaller of the two displays.
        // i.e., no pan-scan for either heads.
        // Also, if the INF specifies PAN_SCAN_SELECTION_DISABLE_ALL such as for Gateway, we disallow pan-scan for both heads
        // in clone mode (and standard and span modes).
        //
        if ((TwinView_State == NVTWINVIEW_STATE_SPAN) ||
            (NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_DISABLE_ALL && (TwinView_State == NVTWINVIEW_STATE_CLONE)))
        {
            // see if this mode has already been rejected.
            if (pVideoTemp->Length != 0)
            {
                if (TwinViewRegistryDataOK)
                {
                    PhysWidth =  pVideoTemp->VisScreenWidth;
                    PhysHeight = pVideoTemp->VisScreenHeight;

                    // Get the physical dimensions of this mode.
                    if (HORIZONTAL_MODE(pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight))
                    {
                        PhysWidth = pVideoTemp->VisScreenWidth / 2;
                    }
                    if (VERTICAL_MODE(pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight))
                    {
                        PhysHeight = pVideoTemp->VisScreenHeight / 2;
                    }

                    //
                    // Now see if this physical mode is supported by both heads. 
                    // If not, we do not support this spanning mode.
                    //
                    for (i = 0; i < NV_NO_DACS; i++)
                    {
                        ulHead = ulDeviceDisplay[i];
                        PhysModePtr = PhysModeList[ulHead];
                        bFoundPhysMode = FALSE;

                        for (j=0; j < NumPhysModes[ulHead]; j++)
                        {
                            // Do not test the refresh rate because we allow it to be different on
                            // both the heads.
                            if (PhysModePtr->Width == PhysWidth && PhysModePtr->Height == PhysHeight &&
                                PhysModePtr->Depth == pVideoTemp->BitsPerPlane &&
                                PhysModePtr->ValidMode)
                            {
                                // Found a match.
                                bFoundPhysMode = TRUE;
                                break;
                            }
                            PhysModePtr++;
                        }

                        // Special case.
                        // Toshiba wants 1400x1050 to be exported only if panel supports it
                        // natively.
                        if (NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_ENABLE_ALL && 
                            PhysWidth == 1400 && PhysHeight == 1050 && 
                            NumberDacs.ulDFPSupports1400x1050 == 0)
                        {
                            // Disallow the mode.
                            pVideoTemp->Length = 0;
                            break;
                        }

                        // Special case
                        // The common modeset code does not allow two low res modes for DFP
                        // These are 480x360 and 960x720. So do not export these modes.
                        // To be more symmetrical, we will disallow these modes irrespective of the 
                        // device types and platforms.
                        if ((PhysWidth == 480 && PhysHeight == 360) ||
                            (PhysWidth == 960 && PhysHeight == 720) )
                        {
                            // Disallow the mode.
                            pVideoTemp->Length = 0;
                            break;
                        }

                        
                        if (!bFoundPhysMode)
                        {
                            // This head does not support pan-scan. So ignore this mode.
                            // On Toshiba, we allow pan-scan for spanning modes also.
                            if (NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_ENABLE_ALL)
                            {
                                // Do nothing
                            }

                            else
                            {
                                // Disallow the mode.
                                pVideoTemp->Length = 0;
                            }


                            break;
                        }
                    } // for each DAC
                } // registry data is OK
            } // Mode is valid
        } // State is MULTIMON


        // In normal mode or clone mode or multimon mdoe, each and every mode exported to GDI should be supported 
        // by the primary monitor as NT/Win2K directly control the primary screen.
        if ((pVideoTemp->Length != 0) &&
            (TwinView_State == NVTWINVIEW_STATE_NORMAL ||
             TwinView_State == NVTWINVIEW_STATE_DUALVIEW ||
             TwinViewRegistryDataOK)
           ) 
        {
            PhysWidth = (unsigned short)(pVideoTemp->VisScreenWidth);
            PhysHeight = (unsigned short)(pVideoTemp->VisScreenHeight);

            //
            // Note: Peter Daifuku's requirement states as follows
            // 1. For normal mode, allow pan/scan for primary. So filter based on refresh rate only.
            //    However, it is off by default unless user explicitly turns on panning in the panel.
            // 2. For clone mode, do not allow pan/scan for primary. So we need to filter based on refresh rate,
            //    width and height.
            // 3. For multimon mode, do not allow pan/scan for primary (and secondary). 
            //    So we need to filter based on refresh rate, width and height.
            //
            if (TwinView_State == NVTWINVIEW_STATE_SPAN)
            {
                // Get the physical dimensions of this mode.
                if (HORIZONTAL_MODE(pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight))
                {
                    PhysWidth = pVideoTemp->VisScreenWidth / 2;
                }
                if (VERTICAL_MODE(pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight))
                {
                    PhysHeight = pVideoTemp->VisScreenHeight / 2;
                }
            }

            if (TwinViewRegistryDataOK)
            {
                ulHead = sData.dwDeviceDisplay[0];
            }
            else
            {
                // Determine whether to use head0 or head1.
                // If you have only one head connected on a dual head card, use the head which
                // has a valid device connected to it.
                if (NumberDacs.ulNumberDacsOnBoard == 1)
                {
                    ulHead = 0;
                }
                else if (NumberDacs.ulNumberDacsOnBoard == 2 && TwinView_State == NVTWINVIEW_STATE_NORMAL)
                {
                    if (NumberDacs.ulDeviceMask[0] == BITMASK_INVALID_DEVICE && NumberDacs.ulDeviceMask[1] != BITMASK_INVALID_DEVICE)
                    {
                        ulHead = 1;
                    }
                    if (NumberDacs.ulDeviceMask[0] != BITMASK_INVALID_DEVICE && NumberDacs.ulDeviceMask[1] == BITMASK_INVALID_DEVICE)
                    {
                        ulHead = 0;
                    }
                    if (NumberDacs.ulDeviceMask[0] == BITMASK_INVALID_DEVICE && NumberDacs.ulDeviceMask[1] == BITMASK_INVALID_DEVICE)
                    {
                        // Pathological case. Nothing is connected!
                        ulHead = 0;
                    }
                    if (NumberDacs.ulDeviceMask[0] != BITMASK_INVALID_DEVICE && NumberDacs.ulDeviceMask[1] != BITMASK_INVALID_DEVICE)
                    {
                        // A valid device is connected to both heads. Let us choose head0 as default.
                        ulHead = 0;
                    }
                }
                else if (NumberDacs.ulNumberDacsOnBoard == 2 && TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
                {
                    ulHead = sData.dwDeviceDisplay[0];
                }
            }

            PhysModePtr = PhysModeList[ulHead];
            bFoundPhysMode = FALSE;

            for (j = 0; j < NumPhysModes[ulHead]; j++)
            {
                if (PhysModePtr->Width == PhysWidth && PhysModePtr->Height == PhysHeight &&
                    PhysModePtr->Depth == pVideoTemp->BitsPerPlane &&
                    PhysModePtr->RefreshRate == pVideoTemp->Frequency &&
                    PhysModePtr->ValidMode)
                {
                    // Found a match.
                    bFoundPhysMode = TRUE;
                    break;
                }
                PhysModePtr++;
            }

            if (!bFoundPhysMode)
            {
                // This head does not support pan-scan. So ignore this mode.
                // On Toshiba laptops, we allow pan-scan on standard mode and clone mode and multimon mode also.
                if ( NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_ENABLE_ALL )
                {
                    // Do nothing.
                }
#if _WIN32_WINNT >= 0x500
                else
                if (bQueryGDIModePruning(TwinView_State, PrimaryHead, PrimaryDeviceMask, 
                        PrimaryHead,  PrimaryDeviceMask, NumberDacs.ACPISystem, NumberDacs.GDIModePruning))
                {
                    //
                    // We let GDI do the mode pruning for the EDID
                    //
                    // Do nothing
                }
#endif
                else
                {
                    // Do not allow this mode.
                    pVideoTemp->Length = 0;
                }
            }

            // Special case.
            // Toshiba wants 1400x1050 to be exported only if panel supports it
            // natively.
            if (NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_ENABLE_ALL && 
                PhysWidth == 1400 && PhysHeight == 1050 && 
                NumberDacs.ulDFPSupports1400x1050 == 0)
            {
                // Disallow the mode.
                pVideoTemp->Length = 0;
            }

            // Special case
            // The common modeset code does not allow two low res modes for DFP
            // These are 480x360 and 960x720. So do not export these modes.
            // To be more symmetrical, we will disallow these modes irrespective of the 
            // device types and platforms.
            if ((PhysWidth == 480 && PhysHeight == 360) ||
                (PhysWidth == 960 && PhysHeight == 720) )
            {
                // Disallow the mode.
                pVideoTemp->Length = 0;
            }

        } // Normal or clone mode or multimon mode.

        //
        // If this mode was found valid for GDI for current desktop settings, increment the counter.
        //
        if (pVideoTemp->Length)
        {
            cNumGDIModes++;
        }
        


        //**********************************************************************
        // Check next mode
        //**********************************************************************

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
                     (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    // Free up the temporary memory allocations.
    for (i = 0; i < NumberDacs.ulNumberDacsOnBoard; i++)
    {
        EngFreeMem(PhysModeList[i]);
    }
    EngFreeMem(SingleVirtualModeList);

    *pcNumGDIModes = cNumGDIModes;
    return(modes.NumModes);

getAvailableModesFailure:
    for (i = 0; i < NumberDacs.ulNumberDacsOnBoard; i++)
    {
        if (PhysModeList[i] != NULL)
        {
            EngFreeMem(PhysModeList[i]);
        }
    }
    if (*modeInformation != NULL) 
    {
        EngFreeMem(*modeInformation);
    }
    *pcNumGDIModes = 0;
    return 0;
}

#if (_WIN32_WINNT >= 0x0500)
//******************************************************************************
//
//  Function: DrvNotify
//
//  Routine Description: Attempts to allocate push buf from AGP memory, if
//  there is no AGP memory it falls back to allocating the push buf from
//  system memory.
//
//  Arguments:
//
//  Return Value:
//            TRUE or FALSE
//
//
//******************************************************************************
void DrvNotify(
    SURFOBJ *hsurf,
    ULONG iType,
    PVOID pvData)
    {

    if (hsurf && pvData)
        {
        PDEV* ppdev = (PDEV *)hsurf->dhpdev;

        switch(iType)
            {
            case DN_DEVICE_ORIGIN:
                {
                POINTL *devOrigin;

                devOrigin = (POINTL *)pvData;
                ppdev->left = devOrigin->x;
                ppdev->top = devOrigin->y;
                }
                break;
            default:
                break;
            }
        }

    }

#endif // #if _WIN32_WINNT >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\heap.c ===
//******************************Module*Header***********************************
//
// Module Name: heap.c
//
// Contains offscreen heap manager and create/delete device bitmap functions.
//
// Copyright (c) 1993-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
//    #include "nvProcMan.h"
    #include "ddmini.h"
#endif

// Define USE_RM_MMGR RM to use RM heap manager only
//#define USE_RM_MMGR     1

#ifndef USE_RM_MMGR // [
#define MIN_HEAP_SIZE       ( 128 * 1024)
#define FIRST_HEAP_SIZE_16  ( 512 * 1024)
#define FIRST_HEAP_SIZE_32  (1024 * 1024)

void FreeHeap(PDEV* ppdev, HEAP* pHeap);
HEAP* GetHeap(PDEV* ppdev, ULONG ulMinAlloc);

OH* heap_alloc(ULONG blksToAlloc, HEAP* pHeap);
BOOL heap_free(OH* pBlk);
BOOL heap_init(ULONG memBegin, ULONG memSize, HEAP* pHeap);
void heap_clear(HEAP* pHeap);
#endif // !USE_RM_MMGR ]

#ifdef FONT_CACHE // [
// Font cache definitions
//
// NOTE: If values are changed, must update NV4TEXT.ASM
//
#define MAX_FONTS       16
#define MAX_GLYPHS      256
#define GLYPH_PITCH     128
#define FONT_CACHE_SIZE MAX_FONTS*MAX_GLYPHS*GLYPH_PITCH
//
// End of font cache definitions
#endif // FONT_CACHE ]

// macro to clear the given poh with color
// FN: Disabled until someone needs it
#if 0//DBG
#define DBG_CLEARPOH(ppdev, poh, color)                                                                   \
{                                                                                                         \
    RECTL rclTrg = {0};                                                                                   \
    RBRUSH_COLOR rbc = {0};                                                                               \
    ppdev->pfnSetDestBase(ppdev, (ULONG)((BYTE *)(poh->LinearPtr) - ppdev->pjScreen), poh->LinearStride); \
    rbc.iSolidColor = color;                                                                              \
    rclTrg.right    = poh->cx;                                                                            \
    rclTrg.bottom   = poh->cy;                                                                            \
    ppdev->pfnFillSolid(ppdev, 1, &rclTrg, 0xF0F0, rbc, NULL);                                            \
}
#else
#define DBG_CLEARPOH(ppdev, poh, color)
#endif


//******************************Public*Routine**********************************
//
// Function: pohFree()
//
//      Frees an off-screen heap allocation.  The free space will be combined
//      with any adjacent free spaces to avoid segmentation of the heap.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     poh   - Pointer to the offscreen memory allocation to free
//
// Return Value:
//
//     None.
//
//******************************************************************************

void pohFree
(
    PDEV*   ppdev,
    OH*     poh
)
{
    if (poh == NULL)
        return;

#ifdef USE_RM_MMGR // [

    //**********************************************************************
    // We now support linear memory management
    //**********************************************************************

    //                       green
    DBG_CLEARPOH(ppdev, poh, 0xff00);
    NVHEAP_FREE(poh->ulOffset);

    //**********************************************************************
    // Remove this node from the allocation list.
    //**********************************************************************

    poh->next->prev = poh->prev;
    poh->prev->next = poh->next;

    //**************************************************************************
    // Free the struct space
    //**************************************************************************

    EngFreeMem(poh);

#else // USE_RM_MMGR ][
    {
        // poh is freed by heap_free so we need to get the heap pointer
        // before calling heap_free
        HEAP* pHeap = poh->pHeap;

        /*
        ** If there is alloc/free hysteresis here, then we have to return heap
        ** space in the following functions:
        **     bAssertModeOffscreenHeap()
        **     bMoveAllOffscreenDfbsToDibs()
        **     vDisableOffscreenHeap()
        */
        if (heap_free(poh) == 1)    // retval 1 means heap is empty
        {
            FreeHeap(ppdev, pHeap);
        }
    }
#endif // USE_RM_MMGR ]

    //**********************************************************************
    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:
    //**********************************************************************

    ppdev->iHeapUniq++;
}


//******************************Public*Routine**********************************
//
// Function:   OH* pohAllocate
//
// Routine Description:
//
//      Allocates a piece in off-screen memory.
//
// Arguments:
//
//
// Return Value:
//
//        Ptr to OH structure representing offscreen memory
//
//******************************************************************************

OH* pohAllocate
(
    PDEV*   ppdev,
    LONG    cxThis,         // Width of rectangle to be allocated
    LONG    cyThis          // Height of rectangle to be allocated
)
{
    OH*     pohThis;    // Points to found available rectangle we'll use
    OH*     pohRoot;

    ULONG   LinearStride;
    ULONG   ulSizeInBytes;
    ULONG   ulAllocated;
    NvU32   dwStatus;

    //**************************************************************************
    // Align to appropriate boundary.
    //**************************************************************************

    LinearStride  = cxThis * ppdev->cjPelSize;
    LinearStride += ppdev->ulSurfaceAlign;
    LinearStride &= ~ppdev->ulSurfaceAlign;
    ulSizeInBytes = LinearStride * cyThis;

    //**************************************************************************
    // Request offscreen memory from linear memory manager
    //**************************************************************************

#ifdef USE_RM_MMGR // [

    NVHEAP_ALLOC(dwStatus, ulAllocated, ulSizeInBytes, TYPE_IMAGE);

    if (dwStatus != 0)
        return NULL;

    if ((pohThis = EngAllocMem(0, sizeof(OH), ALLOC_TAG)) == NULL)
    {
        NVHEAP_FREE(ulAllocated);
        return NULL;
    }

    //**************************************************************************
    // Fill in the OH structure for this allocation.
    //**************************************************************************

    pohThis->pdsurf         = NULL; // The caller owns and sets this field:
//  pohThis->next           = filled in below
//  pohThis->prev           = filled in below
    pohThis->nextEmpty      = NULL; // not used if RM doing all alloc/free
    pohThis->pHeap          = &ppdev->heap; // not used if RM doing all alloc/free
    pohThis->ulSizeInBytes  = ulSizeInBytes;
    pohThis->ulOffset       = ulAllocated;
    pohThis->ulLinearStride = LinearStride;

    //**************************************************************************
    // Now insert this new node at the head of the OH list:
    //**************************************************************************

    pohRoot = &ppdev->heap.oh;

    pohThis->next = pohRoot->next;
    pohThis->prev = pohRoot;

    pohRoot->next->prev = pohThis;
    pohRoot->next = pohThis;

#else // USE_RM_MMGR ][

    {
        HEAP* pHeap = &ppdev->heap;

        /*
        ** Try to allocate space from one of the heaps.
        */
        do
        {
            pohThis = heap_alloc(ulSizeInBytes, pHeap);
        }
        while ((pohThis == NULL) && ((pHeap = pHeap->pNextHeap) != NULL));

        /*
        ** If we couldn't allocate space allocate another heap and try again.
        */
        if (pohThis == NULL)
        {
            if ((pHeap = GetHeap(ppdev, ulSizeInBytes)) == NULL)
                return NULL;

            /*
            ** This should always succeed if the GetHeap above worked.
            */
            pohThis = heap_alloc(ulSizeInBytes, pHeap);

            /*
            ** This check should not be necessary but is here to be safe in
            ** case GetHeap() is changed to not allocate at least the min
            ** heap space requested in the above GetHeap call.
            */
            if (pohThis == NULL)
            {
                FreeHeap(ppdev, pHeap);
                return NULL;
            }
        }

        /*
        ** The linear memory manager does not have LinearStride so fill it in.
        */
        pohThis->ulLinearStride = LinearStride;


        //                           yellow
        DBG_CLEARPOH(ppdev, pohThis, 0xffff00);

    }
#endif // USE_RM_MMGR ]

    DISPDBG((7, "   Allocated (%li x %li) at offset %li",
                cxThis, cyThis, pohThis->ulOffset));

    return pohThis;
}


//******************************Public*Routine**********************************
//
// Function: BOOL bMoveDibToOffscreenDfbIfRoom
//
// Routine Description:
//
//      Converts the DIB DFB to an off-screen DFB, if there's room for it in
//      off-screen memory.
//
// Arguments:
//
//      ppdev - Pointer to the physical device structure
//
// Return Value:
//
//      FALSE if there wasn't room, TRUE if successfully moved.
//
//******************************************************************************


BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)

    {
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    //**************************************************************************
    // If we're in full-screen mode, or ddraw is currently loaded,
    // we can't move anything to off-screen memory:
    //**************************************************************************

    if (!ppdev->bEnabled || (ppdev->flStatus & STAT_DIRECTDRAW_ENABLED))
        return(FALSE);

    //**************************************************************************
    // Allocate an offscreen region
    //**************************************************************************

    poh = pohAllocate(ppdev, pdsurf->sizl.cx, pdsurf->sizl.cy);
    if (poh == NULL)
        {
        //**********************************************************************
        // There wasn't any free room.
        //**********************************************************************

        return(FALSE);
        }

    //**************************************************************************
    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.
    //**************************************************************************

    rclDst.left   = 0;
    rclDst.top    = 0;
    rclDst.right  = pdsurf->sizl.cx;
    rclDst.bottom = pdsurf->sizl.cy;

    pdsurf->LinearPtr    = ppdev->pjFrameBufbase + poh->ulOffset;
    pdsurf->LinearStride = poh->ulLinearStride;

    vPutBits(ppdev,pdsurf, pdsurf->pso, &rclDst);

    //**************************************************************************
    // Update the data structures to reflect the new off-screen node:
    //**************************************************************************

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    //**************************************************************************
    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):
    //**************************************************************************

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
    }

//******************************Public*Routine**********************************
//
// Function: BOOL pohMoveOffscreenDfbToDib
//
// Routine Description:
//
//       Converts the DFB from being off-screen to being a DIB.
//
//       Note: The caller does NOT have to call 'pohFree' on 'poh' after making
//             this call.
//
// Arguments:
//
//       ppdev - Pointer to the physical device structure
//
// Return Value:
//
//       NULL if the function failed (due to a memory allocation).
//       Otherwise, it returns a pointer to the coalesced off-screen heap
//       node that has been made available for subsequent allocations
//       (useful when trying to free enough memory to make a new
//       allocation).
//
//******************************************************************************

BOOL pohMoveOffscreenDfbToDib
(
    PDEV*       ppdev,
    OH*         poh
)
{
    DSURF*      pdsurf;
    HBITMAP     hbmDib;
    SURFOBJ*    pso;
    RECTL       rclDst;

    if ((pdsurf = poh->pdsurf) == NULL)
        return TRUE;

    DISPDBG((2, "Throwing out %li x %li at offset %li!",
                 pdsurf->sizl.cx, pdsurf->sizl.cy, poh->ulOffset));

    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    //**************************************************************************
    // Create the Bitmap for NT GDI to use
    //**************************************************************************

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat, BMF_TOPDOWN, NULL);

    if (hbmDib)
        {

        //**********************************************************************
        // Specify flhooks = 0
        //**********************************************************************

        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
            {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
                {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                vGetBits(ppdev, pdsurf, pso, &rclDst);

                //**************************************************************
                // sizel field  is already set. Does not need to be modified.
                // Does ppdev field need to be set to NULL here ???
                // No, not really. This is still a DFB and as such is associated
                // with our Device.  A DFB implies that the surface is in a
                // DEVICE format. But for NV, we're just using the standard DIB
                // format.  Essentially, we can just leave the ppdev field alone.
                // Besides, this DFB may get put back in offscreen memory and
                // at that point we may need the ppdev again.
                //**************************************************************

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                //**************************************************************
                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:
                //**************************************************************

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                //**************************************************************
                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:
                //**************************************************************

                pohFree(ppdev, poh);
                return TRUE;
                }
            else
                {
                DISPDBG((0,"ERROR in pohMoveOffscreenDfbToDib: EngLockSurface failed on poh:0x%p with 0x%p!",poh,hbmDib));
                }
            }
        else
            {
            DISPDBG((0,"ERROR in pohMoveOffscreenDfbToDib: EngAssociateSurface failed on poh:0x%p with 0x%p!",poh,hbmDib));
            }

        //**********************************************************************
        // Fail case:
        //**********************************************************************

        EngDeleteSurface((HSURF) hbmDib);
        }
    else
        {
        DISPDBG((0,"ERROR in pohMoveOffscreenDfbToDib: EngCreateBitmap failed on poh:0x%p (%d x %d)!",poh,pdsurf->sizl.cx,pdsurf->sizl.cy));
        }
    return FALSE;
}


//******************************Public*Routine**********************************
//
// Function: bMoveAllDfbsFromOffscreenToDibs
//
// Routine Description:
//
//      This function is used when we're about to enter full-screen mode, which
//      would wipe all our off-screen bitmaps.  GDI can ask us to draw on
//      device bitmaps even when we're in full-screen mode, and we do NOT have
//      the option of stalling the call until we switch out of full-screen.
//      We have no choice but to move all the off-screen DFBs to DIBs.
//
// Arguments:
//
//      ppdev - Pointer to the physical device structure
//
// Return Value:
//
//      Returns TRUE if all DSURFs have been successfully moved.
//
//******************************************************************************

BOOL __fastcall bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev)
{
    DSURF*  pdsurf;
    BOOL    bRet = TRUE;    // Assume success

    pdsurf = ppdev->pdsurf;

    while (pdsurf)
    {
        if (pdsurf->dt == DT_SCREEN)
        {
            //JOEHACK - why would we keep trying if this fails???
            if (!pohMoveOffscreenDfbToDib(ppdev, pdsurf->poh))
                bRet = FALSE;
        }

        pdsurf = pdsurf->next;
    }

#if defined(USE_RM_MMGR) && defined(OLD_WAY) // [
    {
        OH*     poh;
        OH*     pohNext;

        //**************************************************************************
        // Make sure that heap was already initialized in EnableOffscreenHeap.
        //**************************************************************************

        poh = ppdev->heap.oh.next;

        if (poh == NULL)
            return TRUE;

        while (poh != &ppdev->heap.oh)
        {
            pohNext = poh->next;

            //JOEHACK - why would we keep trying if this fails???
            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;

            poh = pohNext;
        }
    }
#endif // defined(USE_RM_MMGR) && defined(OLD_WAY) ]

    return bRet;
}


//******************************Public*Routine**********************************
//
// Function:    DrvCreateDeviceBitmap
//
// Routine Description:
//
//   Function called by GDI to create a device-format-bitmap (DFB).  We will
//   always try to allocate the bitmap in off-screen; if we can't, we simply
//   fail the call and GDI will create and manage the bitmap itself.
//
//   Note: We do not have to zero the bitmap bits.  GDI will automatically
//         call us via DrvBitBlt to zero the bits (which is a security
//         consideration).
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)

    {
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;

    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.
    //**************************************************************************

    if (!ppdev->bEnabled)
        return(0);

    //**************************************************************************
    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.
    //**************************************************************************

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    //**************************************************************************
    // Do NOT support device bitmaps when OpenGL or ddraw is enabled !
    // OpenGL MCD and ddraw currently expect to manage all of offscreen memory.
    //**************************************************************************

    //**************************************************************************
    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:
    //
    // (Some of the screen savers like 'Dangerous Creatures' have very wide
    // offscreen bmaps).  CorelDream3D and RayDream use very TALL bitmaps (0x20 x 0x4400).
    // So we also need to limit the height of the offscreen bitmaps too.
    //**************************************************************************

    if ( ((sizl.cx <= 8) && (sizl.cy <= 8)) ||
         ((sizl.cx == 0x30) && (sizl.cy == 0x0E)) || // gains ~2% on 32bpp WB99BG
          (sizl.cx > ppdev->cxScreen * 2) ||
          (sizl.cy > ppdev->cyScreen * 2) ||
          (sizl.cx > ppdev->cxSurfaceMax) || // don't exceed h/w limits
          (sizl.cy > MAX_CY_MEMORY_VALUE)    // don't exceed h/w limits
       )
    {
        return 0;
    }


//******************************************************************************
//
//  Remove this code since it hurts OGL performance when running with GDI.
//
//    if (OglIsEnabled(ppdev))
//        return(0);
//
//******************************************************************************

    //**************************************************************************
    // When OpenGL is rendering in FULL screen mode,
    // don't create any offscreen bitmap so that display driver will not perform
    // any render in GDI channel in order to avoid the channel switch from OpenGL.
    //**************************************************************************
    if(globalOpenGLData.oglDrawableClientCount)
        if(ppdev->ulOpenGLinFullScreen)
            return(0);

#if defined(NVD3D)
    if (ppdev->pDriverData && ppdev->pDriverData->DDrawVideoSurfaceCount)
#else
    if (ppdev->DDrawVideoSurfaceCount)
#endif // !NVD3D
        {
        return(0);
        }

    poh = pohAllocate(ppdev, sizl.cx, sizl.cy);

    if (poh != NULL)
        {
        pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
            {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
                {

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        ppdev->flHooksDeviceBitmap))
                    {
                    pdsurf->dt           = DT_SCREEN;
                    pdsurf->sizl         = sizl;
                    pdsurf->ppdev        = ppdev;
                    poh->pdsurf          = pdsurf;
                    pdsurf->poh          = poh;
                    pdsurf->LinearPtr    = ppdev->pjFrameBufbase + poh->ulOffset;
                    pdsurf->LinearStride = poh->ulLinearStride;

                    /*
                    ** Add this pdsurf to the head of our pdsurf list.
                    */
                    pdsurf->prev = NULL;
                    pdsurf->next = ppdev->pdsurf;
                    if (ppdev->pdsurf)
                        ppdev->pdsurf->prev = pdsurf;
                    ppdev->pdsurf = pdsurf;

                    return(hbmDevice);
                    }
                else
                    {
                    DISPDBG((0, "ERROR in DrvCreateDeviceBitmap: EngAssociateSurface on hbmDevice:0x%p", hbmDevice));
                    }

                EngDeleteSurface((HSURF) hbmDevice);
                }
            else
                {
                DISPDBG((0, "ERROR in DrvCreateDeviceBitmap: EngCreateDeviceBitmap failed on pdsurf:0x%p", pdsurf));
                }
            EngFreeMem(pdsurf);
            }
        else
            {
            DISPDBG((0, "ERROR in DrvCreateDeviceBitmap: EngAllocMem failed to alloc %d bytes", sizeof(DSURF)));
            }

        pohFree(ppdev, poh);
        }

    return(0);
    }

//******************************Public*Routine**********************************
//
// Function: DrvDeleteDeviceBitmap
//
// Routine Description:
//
//      Deletes a DFB.
//
//      Since we implement DrvDeriveSurface on W2k, there are two cases to
//      handle here.  One case is the classic case where this DFB to delete
//      was created by an eariler successful call to DrvCreateDeviceBitmap.
//      The other case is where this DFB to delete was created by an eariler
//      successful call to DrvDeriveSurface.  In the latter case, there will
//      never be a non-NULL poh because the offscreen memory had already been
//      allocated by DirectDraw when DrvDeriveSurface was called.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID DrvDeleteDeviceBitmap
(
    DHSURF      dhsurf
)
{
    DSURF*      pdsurf;
    PDEV*       ppdev;
    SURFOBJ*    psoDib;
    HSURF       hsurfDib;

    pdsurf = (DSURF *)dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        // If this DFB was created by DrvDeriveSurface, poh will be NULL.
        if (pdsurf->poh)
            pohFree(ppdev, pdsurf->poh);

        // Comment from DDK500\src\video\displays\3dlabs\driver\heap.c:
        // Note: we don't need to call EngDeleteSurface(psurf->hsurf) to delete
        // the HBITMAP we created in DrvCreateDeviceBitmap() or DrvDeriveSurface()
        // because GDI will take care of this when it call DrvDeleteDeviceBitmap
        //

    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        //**********************************************************************
        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):
        //**********************************************************************

        psoDib = pdsurf->pso;
        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    /*
    ** Remove this dsurf from our ppdev->pdsurf list.  DrvDeriveSurface dsurfs
    ** will never be in the ppdev->pdsurf list but DrvDeriveSurface dsurfs
    ** always have (NULL==next==prev) so these DrvDeriveSurface dsurfs don't
    ** cause anything to happen below.
    **
    ** Note that (NULL==next==prev) cannot be used to detect a DrvDeriveSurface
    ** created dsurf because this will also be true for a DrvCreateDeviceBitmap
    ** dsurf when there is only one in a PDEV.
    **
    ** Also note that since DrvDeriveSurface dsurfs always have a NULL prev
    ** pointer we must check that the dsurf being deleted is indeed the head
    ** of the ppdev->pdsurf before unlinking the old head.
    */
    if (pdsurf->next)
        pdsurf->next->prev = pdsurf->prev;

    if (pdsurf->prev)
        pdsurf->prev->next = pdsurf->next;
    else if (ppdev->pdsurf == pdsurf)
        ppdev->pdsurf = pdsurf->next;   // new head of list

    EngFreeMem(pdsurf);
}

//******************************Public*Routine**********************************
//
// Function: bAssertModeOffscreenHeap
//
// Routine Description:
//
//   This function is called whenever we switch in or out of full-screen
//   mode.  We have to convert all the off-screen bitmaps to DIBs when
//   we switch to full-screen (because we may be asked to draw on them even
//   when in full-screen, and the mode switch would probably nuke the video
//   memory contents anyway).
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     True if successful.
//
//******************************************************************************

BOOL bAssertModeOffscreenHeap
(
    PDEV*   ppdev,
    BOOL    bEnable
)
{
    if (!bEnable)
        return bMoveAllDfbsFromOffscreenToDibs(ppdev);

    return TRUE;
}

//******************************Public*Routine**********************************
//
// Function: vDisableOffscreenHeap
//
// Routine Description:
//
//     Frees any resources allocated by the off-screen heap.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID vDisableOffscreenHeap
(
    PDEV*   ppdev
)
{
    SURFOBJ*    psoPunt;
    HSURF       hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
        {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
        }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
        {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
        }

    psoPunt = ppdev->psoPunt3;
    if (psoPunt != NULL)
        {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
        }

#ifndef USE_RM_MMGR // [
    //**************************************************************************
    // Free heap space allocated from from RM.
    //**************************************************************************
    {
        HEAP* pHeap = &ppdev->heap;

        // This should never have to free any heap space unless we are using
        // hysteresis in the alloc/free heap algorithm.  That is if we are
        // freeing heaps as they become empty instead of deferring that work,
        // this function should never be called with any offscreen currently
        // in use.

        /*
        ** Start with the last heap in list.
        */
        while (pHeap->pNextHeap)
            pHeap = pHeap->pNextHeap;

        /*
        ** Return heap space back to RM in reverse order of allocation.
        */
        do
        {
            /*
            ** This check is required because the first heap struct is part of
            ** PDEV instead of being allocated so the only way we know that it
            ** is empty (no space allocated for the heap) is to check its size.
            */
            if (pHeap->ulSizeInBytes)
                FreeHeap(ppdev, pHeap);
        }
        while ((pHeap = pHeap->pPrevHeap) != NULL);
    }
#endif // !USE_RM_MMGR ]

    //**********************************************************************
    // Destroy the offscreen heap.
    //**********************************************************************

    NVHEAP_CLEAR(NULL);
}


//******************************Public*Routine**********************************
//
// Function: bEnableOffscreenHeap
//
// Routine Description:
//
//      Initializes the off-screen heap using all available video memory,
//      accounting for the portion taken by the visible screen.
//
//      Input: ppdev->cxScreen
//             ppdev->cyScreen
//             ppdev->cxMemory
//             ppdev->cyMemory
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

BOOL bEnableOffscreenHeap
(
    PDEV*       ppdev
)
{
    SIZEL       sizl;
    HSURF       hsurf;
    ULONG       xSize;

    //**************************************************************************
    // Initialize offscreen heap manager
    //**************************************************************************
    NVHEAP_INIT(0, ppdev->cbFrameBuf - 1, NULL);

    //**************************************************************************
    // cxMemory is Width of Video Memory (in pixels, not bytes)
    // cyMemory is Height of All of Video Memory (in scanlines)
    //
    //      cx/cyMemory encompasses all of video memory, which includes
    //      any additional 'right-hand' side memory, which may be present if
    //      the Width of the screen != pitch/stride of mode.
    //
    // NOTE:  NV Instance memory exists at the end of offscreen memory.
    //        This has already been compensated for by the miniport.
    //        The Miniport reduces the available amount of offscreen memory
    //        before it returns it to the display driver.  See NVValidateModes
    //        for more information.
    //**************************************************************************

    DISPDBG((1, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ASSERTDD((ppdev->cxScreen <= ppdev->cxMemory) &&
             (ppdev->cyScreen <= ppdev->cyMemory),
             "Memory must not have smaller dimensions than visible screen!");

#ifdef USE_RM_MMGR // [
    //**************************************************************************
    // Init the heap.oh structure links.
    //**************************************************************************

    ppdev->heap.oh.pdsurf         = NULL;
    ppdev->heap.oh.next           = &ppdev->heap.oh;
    ppdev->heap.oh.prev           = &ppdev->heap.oh;
    ppdev->heap.oh.nextEmpty      = NULL;
    ppdev->heap.oh.pHeap          = &ppdev->heap;
    ppdev->heap.oh.ulSizeInBytes  = 0;
    ppdev->heap.oh.ulOffset       = 0;
    ppdev->heap.oh.ulLinearStride = 0;
#endif // USE_RM_MMGR ]

    //**************************************************************************
    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:
    //**************************************************************************

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    //**************************************************************************
    // We don't want to hook any drawing functions for the punt surfaces, since
    // they are only there to allow GDI to perform drawing operations which we
    // don't support in hardware. We do need to ask GDI to call us prior to drawing,
    // to ensure the hw graphics engine is idle, since these surfaces represent bitmaps
    // stored in graphics memory.
    //**************************************************************************

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                     ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
        {
        DISPDBG((2, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
        }

    //**************************************************************************
    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:
    //**************************************************************************

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    //**************************************************************************
    // These 'punt' services are necessary for when we use GDI to
    // draw on a 'Device' format bitmap.  Instead of passing the SURFOBJ
    // with the Device Surface in it, we use these temporary wrapper surfaces.
    //**************************************************************************

    if ((hsurf == 0)                                     ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
        {
        DISPDBG((2, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
        }


    //**************************************************************************
    // We need another punt surface for translating multi-colored brushes
    //**************************************************************************

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjFrameBufbase);

    //**************************************************************************
    // These 'punt' services are necessary for when we use GDI to
    // draw on a 'Device' format bitmap.  Instead of passing the SURFOBJ
    // with the Device Surface in it, we use these temporary wrapper surfaces.
    //**************************************************************************

    if ((hsurf == 0)                                     ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt3 = EngLockSurface(hsurf))))
        {
        DISPDBG((2, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
        }

    //**************************************************************************
    // Point the punt surface back to the ppdev
    //**************************************************************************
    ppdev->psoPunt->dhpdev = (DHPDEV) ppdev;
    ppdev->psoPunt2->dhpdev = (DHPDEV) ppdev;
    ppdev->psoPunt3->dhpdev = (DHPDEV) ppdev;


    DISPDBG((5, "Passed bEnableOffscreenHeap"));

#ifdef FONT_CACHE // [
    /*
    ** JOEHACK
    ** If we go back to glyph caching we should create and Enable, Disable and
    ** AssertMode GlyphCache() funtions and call them as appropiate from Enable
    ** and Disable Surface and AssertMode().
    */
#ifndef NV3
    //**************************************************************************
    // Check if screen rectangle allocation succeeded
    //**************************************************************************

    if (poh != NULL) {

    //**************************************************************************
    // Reserve the font cache area in offscreen memory.
    //**************************************************************************

        if (ppdev->fontCacheEnabled) {
            xSize = ppdev->cxScreen;
            poh = pohAllocate  (ppdev,
                                xSize/ppdev->cjPelSize,
                                (FONT_CACHE_SIZE+xSize-1)/xSize,
                                FLOH_MAKE_PERMANENT);
            if (poh == NULL)
                ppdev->fontCacheEnabled = FALSE;
            else {
                ppdev->fontCacheOffset = (ULONG)((BYTE *)poh->LinearPtr - ppdev->pjFrameBufbase);
            }

        }
    }
#endif // NV3
#endif // FONT_CACHE ]

    return(TRUE);

ReturnFalse:

    DISPDBG((2, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}


#if _WIN32_WINNT >= 0x0500 // [
/*****************************************************************************\
*  HBITMAP DrvDeriveSurface
*
*   This function derives and creates a GDI surface from
*   specified DirectDraw surface.
*
*   Parameters:
*   pDirectDraw     Points to a DD_DIRECTDRAW_GLOBAL structure that
*                   describes the DirectDraw obect.
*   pSurface        Points to a DD_SURFACE_LOCAL structure that
*                   describes DirectDraw surface around which to wrap
*                   a GDI surface.
*
*   Return Value:
*   DrvDeriveSurface returns a handle to the created GDI surface
*   upon succeed. It returns NULL if the call fails or
*   if if the river cannot accelerate GDI drawing to
*   the specified DirectDraw surface.
*
*   Comments:
*   DrvDeriveSurface allows the driver to create a GDI surface around a
*   DirectDraw video memory or AGP surface object in order to allow
*   acceleration of GDI drawing to the surface. If the driver does not
*   hook this call, all drawing to DirectDRaw surfaces is done in software
*   using DIB engine.
*   GDI calls DrvDeriveSurface with RGB surfaces only.
*   The driver should call DrvCreateDeviceBitmap to create a GDI surface
*   of the same size and format as that of the DirectDraw surface. Space
*   for the actual pixels need not be allocated since it already exists.
*
*   Note:
*
\*****************************************************************************/

HBITMAP DrvDeriveSurface(
    DD_DIRECTDRAW_GLOBAL    *pDirectDraw,
    DD_SURFACE_LOCAL        *pSurface
)
{
    PPDEV               ppdev   = (PPDEV)pDirectDraw->dhpdev;
    SIZEL               sizel;
    HBITMAP             hbmDevice;
    DSURF               *pdsurf;
    DD_SURFACE_GLOBAL   *pSurfaceGlobal = pSurface->lpGbl;

    //  Conditions that can't create GDI surface on DirectDraw surface.

    if(pSurface->ddsCaps.dwCaps & (DDSCAPS_NONLOCALVIDMEM | DDSCAPS_TEXTURE))
    {
        //  Currently, we don't support create GDI surface over AGP
        //  memory, or textures (swizzled).

        return(0);
    }

    pdsurf  = (DSURF *)EngAllocMem(
        FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);

    if(pdsurf != NULL)
    {
        sizel.cx    = pSurfaceGlobal->wWidth;
        sizel.cy    = pSurfaceGlobal->wHeight;

        hbmDevice   = EngCreateDeviceBitmap(
            (DHSURF)ppdev, sizel, ppdev->iBitmapFormat);

        if(hbmDevice != NULL)
        {
            //  HOOK_SYNCHRONIZE must always be hooked when we
            //  give GDI a pointer to the bitmap bits. (flHook
            //  already has this bit set.)

            if(EngModifySurface(
                (HSURF)hbmDevice, ppdev->hdevEng, ppdev->flHooks,
                MS_NOTSYSTEMMEMORY, (DHSURF)pdsurf,
                ppdev->pjFrameBufbase + pSurfaceGlobal->fpVidMem,
                pSurfaceGlobal->lPitch, NULL))
            {
                pdsurf->dt  = DT_SCREEN;
                pdsurf->sizl= sizel;
                pdsurf->ppdev= ppdev;
                pdsurf->LinearPtr   = ppdev->pjFrameBufbase + pSurfaceGlobal->fpVidMem;
                pdsurf->LinearStride= pSurfaceGlobal->lPitch;

                return(hbmDevice);
            }

            //  Delete the surface handle if failed.

            EngDeleteSurface((HSURF)hbmDevice);
        }

        //  Can't create handle to the bitmap, free allocated resources.

        EngFreeMem(pdsurf);
    }

    //  We can't allocate memory for the device surface object, we must
    //  return failure.

    return(0);
}
#endif // _WIN32_WINNT >= 0x0500 ]

#ifndef USE_RM_MMGR // [
//******************************Public*Routine**********************************
//
// Function:   void FreeHeap
//
// Routine Description:
//
//     Calls RM to free a heap.
//
// Arguments:
//
//     pointer to current PDEV
//     poniter to heap to free
//
// Return Value:
//
//******************************************************************************

void FreeHeap
(
    PDEV*   ppdev,
    HEAP*   pHeap
)
{
    /*
    ** Free structs used to manage this heap space.
    */
    heap_clear(pHeap);

    /*
    ** Call RM to return this heap space to its pool.
    */
    NVHEAP_FREE(pHeap->ulOffset);

    /*
    ** If this is not the root heap unlink it and free the heap struct.
    */
    if (pHeap != &ppdev->heap)
    {
        if (pHeap->pNextHeap)
            pHeap->pNextHeap->pPrevHeap = pHeap->pPrevHeap;

        if (pHeap->pPrevHeap)
            pHeap->pPrevHeap->pNextHeap = pHeap->pNextHeap;

        EngFreeMem(pHeap);
    }
    else // this is the root heap so just mark it as empty
    {
        pHeap->ulSizeInBytes = 0;
        pHeap->ulOffset      = 0;
    }
}

//******************************Public*Routine**********************************
//
// Function:   HEAP* GetHeap
//
// Routine Description:
//
//     Calls RM to allocates another heap.
//
// Arguments:
//
//     pointer to current PDEV
//     size in bytes of minimum allocation requested
//
// Return Value:
//
//     Ptr to HEAP structure (success) or NULL
//
//******************************************************************************

HEAP* GetHeap
(
    PDEV*   ppdev,
    ULONG   ulMinAlloc
)
{
    ULONG   ulAllocated = 0;
    ULONG   ulAllocSize;
    HEAP*   pNewHeap;
    HEAP*   pHeap;
    NvU32   dwStatus;

    /*
    ** Don't allocate heap space smaller than MIN_HEAP_SIZE
    */
    if (ulMinAlloc < MIN_HEAP_SIZE)
        ulMinAlloc = MIN_HEAP_SIZE;

    /*
    ** First heap will contain the persistent DFBS allocated right after a mode
    ** switch and some extra space so we won't usually have to allocate a big
    ** chunk.  If we do allocate a big chunk, it will be after Windows has
    ** already allocated its persistent DFBs so that allocation shouldn't last
    ** long.
    **
    ** We allocate TYPE_CURSOR from them RM because it will high-justify these
    ** allocations.  We do this so that when we free one of these chunks to
    ** make room for Dx/Ogl the freed space should be adjacent the current
    ** free memory since Dx/Ogl allocations are low-justified.  This leaves a
    ** single large free block to work with instead of 2 smaller free blocks.
    */

    if (ppdev->heap.ulSizeInBytes == 0)
    {
        if (ppdev->cjPelSize == 4)
            ulAllocSize = FIRST_HEAP_SIZE_32;
        else
            ulAllocSize = FIRST_HEAP_SIZE_16;  // same for 8bpp
    }
    else
    {
        // RoundUp(2 * screensize, 2^n)
        ulAllocSize = 4 * MIN_HEAP_SIZE;
        while (ulAllocSize < (ULONG)(2 * ppdev->cyScreen * ppdev->cxScreen * ppdev->cjPelSize))
        {
            ulAllocSize *= 2;
        }
    }

    /*
    ** Allocate a heap chunk from the RM memmgr.  Start with a base size and
    ** if that fails, try to allocate something half that size.
    */
    do
    {
        NVHEAP_ALLOC(dwStatus, ulAllocated, ulAllocSize, TYPE_CURSOR);
    }
    while ((dwStatus!=0) && (ulAllocSize /= 2) >= ulMinAlloc);

    if (dwStatus!=0)
    {
        DISPDBG((0, "GetHeap failed to initialize heap. Last try: %d byte", ulAllocSize));
        return NULL;
    }

    /*
    ** This is kind of a hack but rather than changing the USE_RM_MMGR case
    ** which handles only a single heap, here we deal with the mess associated
    ** with the first heap struct allocated within ppdev and subsequent heap
    ** structs being allocated.
    */

    if (ppdev->heap.ulSizeInBytes == 0)
    {
        memset(&ppdev->heap, 0, sizeof(ppdev->heap));

        pNewHeap = &ppdev->heap;
    }
    else
    {
        /*
        ** Running out of system memory sould be a rare event compared to running
        ** out of offscreen memory so we allocate the space for the heap structure
        ** after we know we have the offscreen space.
        */
        pNewHeap = EngAllocMem(FL_ZERO_MEMORY, sizeof(HEAP), ALLOC_TAG);
        if (pNewHeap == NULL)
        {
            NVHEAP_FREE(ulAllocated);
            return NULL;
        }

        /*
        ** Walk to last heap in list.
        */
        pHeap = &ppdev->heap;
        while (pHeap->pNextHeap)
            pHeap = pHeap->pNextHeap;

        pHeap->pNextHeap = pNewHeap;
        pNewHeap->pPrevHeap = pHeap;
    }

    /*
    ** Initialize size info for this heap.
    */
    pNewHeap->ulSizeInBytes = ulAllocSize;
    pNewHeap->ulOffset      = ulAllocated;

    /*
    ** Initialize memory manager structs for this heap.
    */
    if (heap_init(ulAllocated, pNewHeap->ulSizeInBytes, pNewHeap) == 0)
    {
        FreeHeap(ppdev, pNewHeap);
        return NULL;
    }

    return pNewHeap;
}

/*
** This linear heap manager is massaged from the one that was previously in
** this file.  It has been changed to use OH structs and the OH struct was
** changed to incorporate the memory management components in the memory_t
** structure that the original version used.
*/

// Don't use the memstruc.h versions of these macros.
#undef EMPTY
#undef IS_EMPTY
#undef SET_EMPTY
#undef SET_BUSY
#define EMPTY           0x1
#define IS_EMPTY(pBlk)  ((ULONG_PTR)(pBlk)->prev &  EMPTY)
#define SET_EMPTY(pBlk) ((pBlk)->prev = (OH *)((ULONG_PTR)(pBlk)->prev |  EMPTY))
#define SET_BUSY(pBlk)  ((pBlk)->prev = (OH *)((ULONG_PTR)(pBlk)->prev & ~EMPTY))

//----------------------------------------------------------------------------
//
//  Function:   heap_alloc
//
//  Routine Description:
//
//      Allocates a block of memory and cleans up the heap
//
//  Arguments:
//
//  Return Value:
//
//----------------------------------------------------------------------------
OH* heap_alloc
(
    ULONG   ulBytesToAlloc,
    HEAP*   pHeap
)
{
    OH*     pBlk;
    OH*     pPrevEmpty;
    OH*     pNextEmpty;
    ULONG   ulBytesAvail;

    /*
    ** Check for a valid initialized heap.
    */
    if ((pHeap == NULL) || (pHeap->ulSizeInBytes == 0))
        return NULL;

    //**************************************************************************
    // Scan through the free list for a block large enough
    //
    // pHeap->oh.next  (Initial look at heap)
    //        |                                               -------
    //        |  ------- nextEmpty --------   --- nextEmpty--| EMPTY |
    //        | |                          | |                -------
    //        v |                          v |
    //       1st Blk      2nd Blk       3rd Blk       Last Blk
    //       ----          ----          ----          ----
    //      |    |  --->  |    |  --->  |    |  --->  |    | ---
    //      |    |  <---  |    |  <---  |    |  <---  |    |    |
    //       ----          ----          ----          ----     |
    //         ^                                                |
    //         |                                                |
    //          ------------------------------------------------
    //
    //      EMPTY          BUSY          EMPTY         BUSY
    //
    //     No Space       Contains      Contains       Contains
    //     Available         no          video           no
    //                      data         memory         data
    //
    //  ------------------------------------------------------------------------
    // First time heap_alloc is called:
    //
    //                                  pBlk
    //                                     |
    //                                     v
    //       1st Blk      2nd Blk       3rd Blk       Last Blk
    //       ----          ----          ----          ----
    //      |    |  --->  |    |  --->  |    |  --->  |    | ---
    //      |    |  <---  |    |  <---  |    |  <---  |    |    |
    //       ----          ----          ----          ----     |
    //         ^                                                |
    //         |                                                |
    //          ------------------------------------------------
    //**************************************************************************

    pBlk = pHeap->oh.next;   // points to 1st block in heap

    do
    {
        pPrevEmpty = pBlk ;

        pBlk = pBlk->nextEmpty;

        if (pBlk == (void *)EMPTY)
            return 0;

        ulBytesAvail = pBlk->ulSizeInBytes;
    }
    while (ulBytesAvail < ulBytesToAlloc);

    //**************************************************************************
    // At this point, pBlk points to an entry which contains enough memory
    // to satisfy the allocation request.
    //
    // Note: We search thru the 'EMPTY' (UNUSED) entries, not the 'BUSY' (USED) entries
    //**************************************************************************

    if (ulBytesAvail == ulBytesToAlloc)
    {
        //**********************************************************************
        // We're giving the caller the whole thing
        // So all we need to do is set pNextEmpty
        //**********************************************************************
        pNextEmpty = pBlk->nextEmpty;
    }
    else
    {
        //**********************************************************************
        // Create a new 'EMPTY' entry which will hold the currently unused
        // portion of memory (EMPTY essentially means UNUSED in this
        // heap manager). pBlk will hold the currently allocated portion of memory
        //**********************************************************************

        pNextEmpty = EngAllocMem(FL_ZERO_MEMORY, sizeof(OH), ALLOC_TAG);

        //  if pNextEmpty is NULL ptr, we can't do anything but fail the call.

        if(pNextEmpty == NULL)
            return 0;

//      pNextEmpty->pdsurf        = we don't have this information
        pNextEmpty->next          = pBlk->next;
        pNextEmpty->prev          = pBlk;
        pNextEmpty->nextEmpty     = pBlk->nextEmpty;
        pNextEmpty->pHeap         = pHeap;
        pNextEmpty->ulSizeInBytes = ulBytesAvail - ulBytesToAlloc;
        pNextEmpty->ulOffset      = pBlk->ulOffset + ulBytesToAlloc;
//      pNextEmpty->ulLinearStride= we don't have this information

        SET_EMPTY(pNextEmpty);

        //**********************************************************************
        // Now patch its neighbors
        //**********************************************************************

        pBlk->next = pNextEmpty;
        pNextEmpty->next->prev = pNextEmpty;
    }

    pPrevEmpty->nextEmpty = pNextEmpty;

    //**************************************************************************
    // Mark as BUSY (BUSY essentially means USED in this heap manager)
    //**************************************************************************

    pBlk->ulSizeInBytes = ulBytesToAlloc;

    SET_BUSY(pBlk);

    //**************************************************************************
    //
    // pHeap->oh.next  (UPDATED HEAP)
    //        |                                                           -------
    //        |  ------- nextEmpty --------------------   --- nextEmpty--| EMPTY |
    //        | |                       pBlk           | |                -------
    //        v |                                      v |
    //       1st Blk      2nd Blk        NEW           NEW         Last Blk
    //       ----          ----         ----          ----          ----
    //      |    |  --->  |    |  ---> |    |  --->  |    |  --->  |    | ---
    //      |    |  <---  |    |  <--- |    |  <---  |    |  <---  |    |    |
    //       ----          ----         ----          ----          ----     |
    //         ^                                                             |
    //         |                                                             |
    //          -------------------------------------------------------------
    //
    //                                  NEW           NEW
    //      EMPTY          BUSY         BUSY         EMPTY          BUSY
    //
    //     No Space       Contains    Contains      Contains        Contains
    //     Available         no       current         all             no
    //                      data      requested     of video         data
    //                                 video         memory
    //                                 memory
    //
    //                  |<---------------------->|
    //                   This is where new nodes
    //                          get added
    //**************************************************************************

    return pBlk;
}

//----------------------------------------------------------------------------
//
//  Function:   heap_free
//
//  Routine Description:
//
//      Frees up a block of memory and cleans up the heap
//
//  Arguments:
//
//  Return Value:
//      0 - heap is not empty
//      1 - heap is empty
//
//----------------------------------------------------------------------------
BOOL heap_free
(
    OH*     pBlk
)
{
    HEAP*   pHeap = pBlk->pHeap;

    OH*     pChk;
    OH*     pNext;
    OH*     pNextEmpty;
    OH*     freeCurrent;
    OH*     freeAhead;

    //**************************************************************************
    // Check and see if we can coalesce memory blocks
    //
    //
    //              Previous Block    Block to     Next Block
    //                                be freed
    //
    //                   |              |               |
    //                   |              |               |
    //                   v              v               v
    //
    //               EMPTY/BUSY?       BUSY         EMPTY/BUSY?
    //
    //**************************************************************************

    pNext = pBlk->next;
    if (IS_EMPTY(pNext))
    {
        //**********************************************************************
        // Coalesce forward , next block is EMPTY
        //**********************************************************************

        freeAhead   = pNext;
        pNextEmpty  = pNext->nextEmpty;
        pNext       = pNext->next;

        //**********************************************************************
        // Current State of Variables:
        //
        //                            Block to     Next Block
        //                            be freed
        //
        //                            (pBlk)
        //                              |               |
        //                              |               |  ----- pNextEmpty -->
        //                              v               v |
        //                                                |
        //                             BUSY  ------>  EMPTY ---- pNext ------->
        //                                  freeAhead
        //
        //                          |<---------------------->|
        //                             These two blocks will
        //                             be merged below
        //
        //          pBlk        = current block
        //          freeAhead   = points to the block that will be deleted
        //          pNextEmpty  = points to the new NextEmpty block
        //          pNext       = points to the new Next block
        //**********************************************************************

    }
    else
    {
        //**********************************************************************
        // Coalesce forward , next block is BUSY
        //**********************************************************************

        pNextEmpty = 0 ;
        freeAhead = (OH *)0;

        //**********************************************************************
        // Current State of Variables:
        //
        //                            Block to     Next Block
        //                            be freed
        //
        //                            (pBlk)
        //                              |               |
        //                              |               |
        //                              v               v       pNextEmpty = 0
        //                                                      freeAhead  = 0
        //                             BUSY  ------>  BUSY
        //                                    pNext
        //
        //
        //                            The above two blocks
        //                            will NOT be merged
        //
        //          pBlk        = current block
        //          freeAhead   = 0 (means we will NOT delete/merge a block)
        //          pNextEmpty  = 0 (means we will need to obtain the pNextEmpty
        //                           block from the PREVIOUS Empty block)
        //          pNext       = unchanged, already points to the next block
        //**********************************************************************

    }

    //**************************************************************************
    // Now check and see if we can coalesce previous memory blocks
    //**************************************************************************

    if (IS_EMPTY(pBlk->prev))
    {
        //**********************************************************************
        // Coalesce backward, previous block is EMPTY
        //**********************************************************************

        freeCurrent     = pBlk;
        pBlk            = pBlk->prev;
        pNext->prev     = pBlk;
        if (pNextEmpty)
            pBlk->nextEmpty = pNextEmpty;

        //**********************************************************************
        // Current State of Variables:
        //
        //          Previous Block    Block to
        //                            be freed
        //
        //               |              |
        //               |              |
        //               v              v       --> pNextEmpty (already set up above)
        //                                      --> pNext (already set up above)
        //             EMPTY <------  BUSY
        //
        //               ^ |            ^
        //               | |            |
        //             pBlk|        freeCurrent
        //                 |
        //                  ------------------------> pNextEmpty
        //
        //          |<------------------------>|
        //              The above two blocks
        //                WILL be merged
        //
        //          pBlk            = updated to the new 'current' block
        //
        //          freeCurrent     = points to block that will be deleted
        //          pNext->prev     = updated to be linked to its new previous block
        //          pBlk->nextEmpty = updated to point to next empty block
        //                            (unless the pNextEmpty block is to be obtained
        //                             from the previous empty block, then
        //                             this field is left UNMODIFIED, because
        //                             it ALREADY points to the next empty block)
        //          pBlk->next      = is initialized after this if statement because
        //                            it doesn't depend on this if statement
        //**********************************************************************

    }
    else
    {
        //**********************************************************************
        // Coalesce backward, previous block is BUSY
        //**********************************************************************

        SET_EMPTY( pBlk ) ;
        freeCurrent = (OH *)0;

        //**********************************************************************
        // Search this heap for the previous empty block
        //**********************************************************************

        for (pChk = pHeap->oh.next;
                (pChk->nextEmpty != (OH *)EMPTY) && (pChk->nextEmpty->ulOffset < pBlk->ulOffset);
                pChk = pChk->nextEmpty)
        {
            ;
        }

        //**********************************************************************
        // If we already have a pNextEmpty block, then we know that we just need to
        // update the pNext->prev block to point back to this current block, because
        // it pNext->prev currently points to the block which will be deleted.
        //
        // However, if pNextEmpty == 0, then pNext->prev is already setup correctly.
        //
        // The following if statement would be easier to understand in the following
        // format:
        //
        //  if (pNextEmpty)
        //      pNext->prev = pBlk;
        //
        //  if (!pNextEmpty)
        //      pNextEmpty = pChk->nextEmpty
        //
        //**********************************************************************

        if (pNextEmpty)
            pNext->prev = pBlk;
        else
            pNextEmpty = pChk->nextEmpty ;

        //**********************************************************************
        // pNextEmpty has now been correctly determined.
        // Insert the block in the EMPTY list and fixup the pointers.
        //**********************************************************************

        pBlk->nextEmpty = pNextEmpty ;
        pChk->nextEmpty = pBlk ;

        //**********************************************************************
        // Current State of Variables:
        //
        //              Previous Block    Block to
        //                                be freed
        //
        //                   |              |
        //                   |              |
        //                   v              v     --> pNextEmpty (already set up above)
        //                                        --> pNext (already set up above)
        //                 BUSY           BUSY
        //                                ^ ^
        //      Previous                  | |
        //       Empty <------------------   -- pBlk
        //       Block
        //
        //
        //       pBlk            = current block
        //       freeCurrent     = 0 (means that we will NOT delete a block)
        //       pNext->prev     = updated to be linked to its new previous block
        //                         (if necessary)
        //       pBlk->nextEmpty = updated to point to the next empty block.
        //       pChk->nextEmpty = previous next empty block is also correctly updated
        //       pBlk->next      = is initialized after this if statement because
        //                         it doesn't depend on this if statement
        //**********************************************************************
    }


    //**************************************************************************
    // freeAhead is NONZERO if we merged 2 empty blocks into 1
    // freeCurrent is also NONZERO if we merged 2 empty blocks into 1
    //**************************************************************************

    if (freeCurrent)
        EngFreeMem(freeCurrent);

    if (freeAhead)
        EngFreeMem(freeAhead);

    //**************************************************************************
    // Update the next block link.
    // Also, update the size of the current block, due to freeing up one block.
    //**************************************************************************

    pBlk->next = pNext;
    pBlk->ulSizeInBytes = pNext->ulOffset - pBlk->ulOffset;

    return pBlk->ulSizeInBytes == pHeap->ulSizeInBytes;
}

//----------------------------------------------------------------------------
//
//  Function:   heap_init
//
//  Routine Description:
//
//      Initializes the linear heap manager for OpenGL
//
//  Arguments:
//
//  Return Value:
//      0 - failed
//      1 - success
//
//----------------------------------------------------------------------------
BOOL heap_init
(
    ULONG   memBegin,
    ULONG   memSize,
    HEAP*   pHeap
)
{
    OH*     pFirstBlk;
    OH*     pSecondBlk;
    OH*     pThirdBlk;
    OH*     pLastBlk;
    OH*     pNextBlk;
    OH*     pBlk;

    //**************************************************************************
    // We initialize the memory system, by setting up three special
    // blocks and a fourth block containing all of free memory.
    // The first block is "EMPTY", but has no "spaceAvailable".
    // The second block is "BUSY", but uses no space.
    // The last block is "BUSY" and also contains no memory.
    // Finally, the third block contains the rest of memory!
    //
    // pHeap->oh.next
    //        |                                               -----------
    //        |  ------- nextEmpty --------   --- nextEmpty--| 0 + EMPTY |
    //        | |                          | |                -----------
    //        v |                          v |
    //       1st Blk      2nd Blk       3rd Blk       Last Blk
    //       ----          ----          ----          ----
    //      |    |  --->  |    |  --->  |    |  --->  |    | ---
    //      |    |  <---  |    |  <---  |    |  <---  |    |    |
    //       ----          ----          ----          ----     |
    //         ^                                                |
    //         |                                                |
    //          ------------------------------------------------
    //
    //      EMPTY          BUSY          EMPTY         BUSY
    //
    //     No Space       Contains      Contains       Contains
    //     Available         no           all            no
    //                      data        of video        data
    //                                   memory
    //
    //**************************************************************************

    if ((pFirstBlk = EngAllocMem(FL_ZERO_MEMORY, 4*sizeof(OH), ALLOC_TAG)) == NULL)
    {
        pHeap->oh.next = NULL;
        return 0;
    }

    pHeap->oh.next = pFirstBlk;
    pSecondBlk = pFirstBlk + 1;
    pThirdBlk = pSecondBlk + 1;
    pLastBlk = pThirdBlk + 1;

    //**************************************************************************
    // FirstBlk is "EMPTY" but has no space available
    //**************************************************************************

    pFirstBlk->prev          = pLastBlk;
    pFirstBlk->next          = pSecondBlk;
    pFirstBlk->nextEmpty     = pThirdBlk;
    pFirstBlk->pHeap         = pHeap;
    pFirstBlk->ulSizeInBytes = 0;
    pFirstBlk->ulOffset      = memBegin;
    SET_EMPTY(pFirstBlk);

    //**************************************************************************
    // Second is "BUSY", but contains no data
    //**************************************************************************

    pSecondBlk->prev          = pFirstBlk;
    pSecondBlk->next          = pThirdBlk;
    pSecondBlk->nextEmpty     = NULL;
    pSecondBlk->pHeap         = pHeap;
    pSecondBlk->ulSizeInBytes = 0;
    pSecondBlk->ulOffset      = memBegin;
    SET_BUSY(pSecondBlk);

    //**************************************************************************
    // ThirdBlk is "EMPTY" and contains all of memory!
    //**************************************************************************

    pThirdBlk->prev          = pSecondBlk;
    pThirdBlk->next          = pLastBlk ;
    pThirdBlk->nextEmpty     = (OH *)EMPTY;
    pThirdBlk->pHeap         = pHeap;
    pThirdBlk->ulSizeInBytes = memSize;
    pThirdBlk->ulOffset      = memBegin;
    SET_EMPTY(pThirdBlk);

    //**************************************************************************
    // LastBlk is "BUSY", but contains no data
    // LastBlk starts 1 past end of available memory
    //**************************************************************************

    pLastBlk->prev          = pThirdBlk;
    pLastBlk->next          = pFirstBlk;
    pLastBlk->nextEmpty     = NULL;
    pLastBlk->pHeap         = pHeap;
    pLastBlk->ulSizeInBytes = 0;
    pLastBlk->ulOffset      = memBegin + memSize;
    SET_BUSY(pLastBlk);

    return 1;
}


//----------------------------------------------------------------------------
//
//  Function:   heap_clear
//
//  Routine Description:
//
//      Frees up the 4 base blocks used to manage a a heap
//
//  Arguments:
//
//  Return Value:
//
//----------------------------------------------------------------------------
void heap_clear
(
    HEAP*   pHeap
)
{
    /*
    ** Note that this is NOT an assert case.  If GetHeap successfully allocates
    ** a new heap but heap_init() fails (presumeably because the allocation of
    ** the oh struct space failed) then GetHeap will call FreeHeap which calls
    ** heap_clear() and pHeap->oh.next will definitely be NULL in that case.
    */
    if (pHeap && pHeap->oh.next)
    {
        EngFreeMem(pHeap->oh.next);
        pHeap->oh.next = NULL;
    }
}
#endif // !USE_RM_MMGR ]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\driver.h ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
#include "CompileControl.h"
#if IS_WINNT5
#include <ntddvdeo.h>
#include <dmemmgr.h>
#endif
#include "nvtypes.h"

//***************************************************************************
// Include display driver IOCTL codes (shared by all components)
//***************************************************************************
#include <dspioctl.h>

#include "nvOverlay.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#define GDI_CHANNEL_ID 0x00000000 // NOTE: assumes GDI is on channel 0

//***************************************************************************
// Special cased ROPS (In ROP3 single byte format)
//***************************************************************************

#define NV BLACKNESS 0x00
#define NV_DSTINVERT 0x55
#define NV_PATINVERT 0x5A
#define NV_SRCAND    0x88
#define NV_DSTCOPY   0xAA
#define NV_SRCCOPY   0xCC
#define NV_SRCPAINT  0xEE
#define NV_PATCOPY   0xF0
#define NV_WHITENESS 0xFF

// !!! CAUTION CAUTION !!!  See Note!!!
#define DMAPUSH_BUFFER_SIZE 0x200000    // NOTE: If you change these values, then
#define DMAPUSH_PADDING     32          //       change the EQUs in I386/STRUCS.INC
// !!! CAUTION CAUTION !!!              //


// these #defines are used by opengl api stereo 
#define OGL_STEREO_NUMBUFFERS       2
#define OGL_STEREO_BUFFER_LEFT      0
#define OGL_STEREO_BUFFER_RIGHT     1


#define MAX_INDEXED_IMAGE_NOTIFIERS 16       // Must be a power of 2
#define INDEXED_IMAGE_LUT_BUFFER_SIZE (MAX_INDEXED_IMAGE_NOTIFIERS * 256 * 4)
                                             // Allocate LUTs for each indexed image
                                             // object. These are associated so that
                                             // the LUT is not updated causing the
                                             // image to be corrupted
#define MAX_INDEXED_IMAGE_DWORDS 1792

#define MAX_CY_MEMORY_VALUE 0x7fff           // Hardware limitation

#ifndef NVD3D_DX6 // D3D driver conflicts
#define NV_IN_PROGRESS 255
#else
//
// DX6 Only:
// Redefine HAL CALLBACK function structs so they match the "NT" way.
//
//typedef DD_CALLBACKS       DDHAL_CALLBACKS;
typedef DD_SURFACECALLBACKS    DDHAL_SURFACECALLBACKS;
typedef DD_PALETTECALLBACKS    DDHAL_PALETTECALLBACKS;
#endif // #ifdef NVD3D_DX6


//***************************************************************************
// Number of cached cursors
//***************************************************************************

#define NUM_CACHED_CURSORS 4

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Multi-board support can be enabled by setting this to 1:

#define MULTI_BOARDS            0

#if _WIN32_WINNT < 0x0500
//#define NT4_MULTI_DEV
#else
#undef NT4_MULTI_DEV
#endif

// This is the maximum number of boards we'll support in a single
// virtual driver:

#if MULTI_BOARDS
    #define MAX_BOARDS          16
    #define IBOARD(ppdev)       ((ppdev)->iBoard)
#else
    #define MAX_BOARDS          1
    #define IBOARD(ppdev)       0
#endif

//*********************************************************************************
// Number of dacs
// SAME one also define in miniport head file(s).  Search in miniport to match it.
//*********************************************************************************
#define NV_NO_DACS                  2
#define NV_NO_CONNECTORS                  24

// Useful for visualizing the offscreen heap:

#define DEBUG_HEAP              0

// Sorts out memory allocation macros
#ifndef PDEV_PTR
#define PDEV_PTR() ppdev
#endif

//*********************************************************************
// For NT4 for both NV3 and NV4, the display and DX drivers use the
// same version of the mem allocation macros.
//
// For Win2K, the NV4 DX6 driver has its own version of the memory
// allocation macros in D3DINC.H. For NV3, the Win2K DX driver is
// currently the same DX driver used for NT4, so it uses the following
// mem allocation in both the DX and display drivers. This will change
// once NV3 Win2K DX6 support is implemented.
//*********************************************************************

#if (!defined(NVD3D_DX6)) // [ && defined(NV4)) || (defined(NV3) && (defined(DISPDRV) ||  _WIN32_WINNT < 0x0500))


#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define HEAP_ALLOC_TILED_PITCH_HEIGHT        6
#define HEAP_DESTROY                         7
#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define MEM_TYPE_PRIMARY                     8
#define MEM_TYPE_IMAGE_TILED                 9
#define TYPE_DEPTH_COMPR16                   10
#define TYPE_DEPTH_COMPR32                   11

#define NVHEAP_INFO()                           \
{                                               \
    NVOS11_PARAMETERS   HeapParams;             \
    PVOID pParms = (PVOID) &HeapParams;         \
    DWORD cbReturned;                           \
    HeapParams.hRoot = ppdev->hClient;          \
    HeapParams.hObjectParent = ppdev->hDevice;  \
    HeapParams.function = HEAP_INFO;            \
    HeapParams.owner    = 'NVDD';               \
    EngDeviceIoControl(                         \
        ppdev->hDriver,                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    ppdev->VideoHeapTotal = HeapParams.total;   \
    ppdev->VideoHeapFree = HeapParams.free;     \
}

#define NVHEAP_PURGE()                          \
{                                               \
    NVOS11_PARAMETERS HeapParams;               \
    PVOID pParms = (PVOID) &HeapParams;         \
    DWORD cbReturned;                           \
    HeapParams.hRoot = ppdev->hClient;          \
    HeapParams.hObjectParent = ppdev->hDevice;  \
    HeapParams.function = HEAP_PURGE;           \
    HeapParams.owner    = 'NVDD';               \
    EngDeviceIoControl(                         \
        ppdev->hDriver,                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
}

#define NVHEAP_DESTROY()                        \
{                                               \
    NVOS11_PARAMETERS HeapParams;               \
    PVOID pParms = (PVOID) &HeapParams;         \
    DWORD cbReturned;                           \
    HeapParams.hRoot = ppdev->hClient;          \
    HeapParams.hObjectParent = ppdev->hDevice;  \
    HeapParams.function = HEAP_DESTROY;         \
    HeapParams.owner    = 'NVDD';               \
    EngDeviceIoControl(                         \
        ppdev->hDriver,                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
}

#define NVHEAP_INIT(strt, end, heap) \
{                                    \
    PDEV_PTR()->cbGdiHeap = 0;          \
}

#define NVHEAP_CLEAR(heap)  \
{                           \
    PDEV_PTR()->cbGdiHeap = 0; \
}

#define NVHEAP_ALLOC(sts,pvm,sz,tp)                     \
{                                                       \
    NVOS11_PARAMETERS   HeapParams;                     \
    PVOID pParms = (PVOID) &HeapParams;                 \
    DWORD cbReturned;                                   \
                                                        \
    HeapParams.hRoot = PDEV_PTR()->hClient;                \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice;        \
    HeapParams.function = HEAP_ALLOC_SIZE;              \
    HeapParams.owner    = 'NVDD';                       \
    HeapParams.type     = (tp);                         \
    HeapParams.size     = (sz);                         \
    EngDeviceIoControl(                                 \
        PDEV_PTR()->hDriver,                               \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                    \
        (&pParms),                                      \
        sizeof(PVOID),                                  \
        pParms,                                         \
        sizeof(NVOS11_PARAMETERS),                      \
        &cbReturned                                     \
    );                                                  \
    (sts) = HeapParams.status;                          \
    (pvm) = (HeapParams.status ? 0 : HeapParams.offset);\
    if (pvm)                                            \
        {                                               \
        PDEV_PTR()->cbGdiHeap += PDEV_PTR()->VideoHeapFree -  \
            HeapParams.free;                            \
        PDEV_PTR()->VideoHeapFree = HeapParams.free;       \
        }                                               \
}

#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp)           \
{                                                       \
    NVOS11_PARAMETERS HeapParams;                       \
    PVOID pParms = (PVOID) &HeapParams;                 \
    DWORD cbReturned;                                   \
    HeapParams.hRoot = PDEV_PTR()->hClient;                \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice;        \
    HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;\
    HeapParams.owner    = 'NVDD';                       \
    HeapParams.type     = (tp);                         \
    HeapParams.pitch    = (pch);                        \
    HeapParams.height   = (ht);                         \
    EngDeviceIoControl(                                 \
        PDEV_PTR()->hDriver,                               \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                    \
        (&pParms),                                      \
        sizeof(PVOID),                                  \
        pParms,                                         \
        sizeof(NVOS11_PARAMETERS),                      \
        &cbReturned                                     \
    );                                                  \
    (sts) = HeapParams.status;                          \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;  \
    (pch) = HeapParams.pitch;                           \
    if (pvm)                                            \
        {                                               \
        PDEV_PTR()->cbGdiHeap += PDEV_PTR()->VideoHeapFree -  \
            HeapParams.free;                            \
        PDEV_PTR()->VideoHeapFree = HeapParams.free;       \
        }                                               \
}

#define NVHEAP_FREE(pvm)                        \
{                                               \
    NVOS11_PARAMETERS HeapParams;               \
    PVOID pParms = (PVOID) &HeapParams;         \
    DWORD cbReturned;                           \
    HeapParams.hRoot = PDEV_PTR()->hClient;        \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice;\
    HeapParams.function = HEAP_FREE;            \
    HeapParams.owner    = 'NVDD';               \
    HeapParams.offset   = (U032)(pvm);          \
    EngDeviceIoControl(                         \
        PDEV_PTR()->hDriver,                       \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    PDEV_PTR()->cbGdiHeap -= (HeapParams.free -    \
        PDEV_PTR()->VideoHeapFree);                \
    PDEV_PTR()->VideoHeapFree = HeapParams.free;   \
}

#endif // (!defined(NVD3D_DX6)) ]

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"NV_DISP"  // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "NV: "      // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               '  VN'      // Four byte tag used for tracking
                                            //   memory allocations (characters
                                            //   are in reverse order)

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define MEM_TO_MEM_BUFFER_SIZE    (0x80000)  // 512kb
 
                                  // Size in bytes of 'MEM_TO_MEM_Buffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

#if defined(_ALPHA_)
    #define XFER_BUFFERS    16  // Defines the maximum number of write buffers
                                //   possible on any Alpha.  Must be a power
#else                           //   of two.
    #define XFER_BUFFERS    1   // On non-alpha systems, we don't have to
                                //   worry about the chip caching our bus
#endif                          //   writes.

#define XFER_MASK           (XFER_BUFFERS - 1)

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */


// structure to handle FC_RECT4 but doesn't use so much stack space as CLIPENUM
typedef struct _ENUMRECT4 {
    LONG    c;
    RECTL   arcl[4];   // Space for enumerating FC_RECT4 clipping
} ENUMRECT4;


typedef struct _NV_VIDEO_CLUTDATA {
    UCHAR Blue;
    UCHAR Green;
    UCHAR Red;
    UCHAR Unused;
} NV_VIDEO_CLUTDATA, *PNV_VIDEO_CLUTDATA;

// BUGBUG - Hack 'o rama, these should be NvNotification structs!
typedef struct _NV_NOTIFIERS
{
    BYTE   VideoLutCursorDac[16*9];
    BYTE   Sync[16*5];
    BYTE   FlipPrimary[16*9];
    BYTE   FlipOverlay[16*5];
    BYTE   FlipVport[16*5];
    BYTE   DmaFromMem[16*5];
    BYTE   DmaToMem[16*5];
    BYTE   DmaToMemIndexedImage[16*MAX_INDEXED_IMAGE_NOTIFIERS];
    BYTE   MemToMem[16*2];
    BYTE   ScaledImage[16*5];
    BYTE   Primary2d[16*5];
    BYTE   DmaPushBufErr[16];
} NV_NOTIFIERS, *PNV_NOTIFIERS;

typedef struct _PDEV PDEV;      // Handy forward declaration

typedef struct _GLOBALDATA GLOBALDATA; // Defined in DD driver's DDMINI.H (NT5)
                                       // or Display Driver's DDMININT.H (NT4)


VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);

//////////////////////////////////////////////////////////////////////
// Text stuff

#define GLYPH_CACHE_HEIGHT  48  // Number of scans to allocate for glyph cache,
                                //   divided by pel size

#define GLYPH_CACHE_CX      64  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      64  // Maximum height of glyphs that we'll consider
                                //   caching

#define MAX_GLYPH_SIZE      ((GLYPH_CACHE_CX * GLYPH_CACHE_CY + 31) / 8)
                                // Maximum amount of off-screen memory required
                                //   to cache a glyph, in bytes

#define GLYPH_ALLOC_SIZE    8100
                                // Do all cached glyph memory allocations
                                //   in 8k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits

    // Device specific fields below here:

    LONG            cxLessOne;  // Glyph width less one
    LONG            cyLessOne;  // Glyph height less one
    LONG            cxcyLessOne;// Packed width and height, less one
    LONG            cw;         // Number of words to be transferred
    LONG            cd;         // Number of dwords to be transferred
    ULONG           ad[1];      // Start of glyph bits
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT CACHEDFONT;
typedef struct _CACHEDFONT
{
    CACHEDFONT*     pcfNext;    // Points to next entry in CACHEDFONT list
    CACHEDFONT*     pcfPrev;    // Points to previous entry in CACHEDFONT list
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                          /* xlc, pxlc */


//********************************************************************
// This cursor structure MUST also match the one defined in nv.h
// (in the miniport directory)
//********************************************************************

typedef struct _TV_CURSOR_ADJUST_INFO
    {
    ULONG   MonitorType;
    ULONG   Underscan_x;
    ULONG   Underscan_y;
    ULONG   Scale_x;
    ULONG   Scale_y;
    ULONG   FilterEnable;
    ULONG   TVCursorMin;
    ULONG   TVCursorMax;
    } TV_CURSOR_ADJUST_INFO;


BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

VOID vFastText(GLYPHPOS*, ULONG, BYTE*, ULONG, ULONG, RECTL*, RECTL*,
               FLONG, RECTL*, RECTL*);
VOID vClearMemDword(ULONG*, ULONG);

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:

#define SLOW_BRUSH_CACHE_DIM    3   // Controls the number of brushes cached
                                    //   in off-screen memory, when we don't
                                    //   have the S3 hardware pattern support.
                                    //   We allocate 3 x 3 brushes, so we can
                                    //   cache a total of 9 brushes:
#define SLOW_BRUSH_COUNT        (SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_CACHE_DIM)
#define SLOW_BRUSH_DIMENSION    64  // After alignment is taken care of,
                                    //   every off-screen brush cache entry
                                    //   will be 64 pels in both dimensions
#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    //   pattern, using the 8 extra for brush
                                    //   alignment

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    BOOL        bTransparent;   // TRUE if brush was realized for a transparent
                                //   blt (meaning colours are white and black),
                                //   FALSE if not (meaning it's already been
                                //   colour-expanded to the correct colours).
                                //   Value is undefined if the brush isn't
                                //   2 colour.
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    BRUSHENTRY* apbe[MAX_BOARDS];// Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */


//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);

VOID vDirectStretch8Narrow(STR_BLT*);
VOID vDirectStretch8(STR_BLT*);
VOID vDirectStretch16(STR_BLT*);
VOID vDirectStretch32(STR_BLT*);

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef struct _DSURF DSURF;
typedef struct _HEAP HEAP;
typedef struct _OH OH;

typedef struct _OH
{
    DSURF*  pdsurf;         // corresponding DSURF structure
    OH*     next;           // for 2-link list
    OH*     prev;           // for 2-link list
    OH*     nextEmpty;      // for 1-link list of empty fragments
    HEAP*   pHeap;          // pointer to heap containing this fragment
                            // not used if using RM_MMGR exclusively

    ULONG   ulSizeInBytes;  // size in bytes of fragment
    ULONG   ulOffset;       // FB offset to allocation
    ULONG   ulLinearStride; // stride in bytes (that was used to enforce alignment restrictions)
#ifdef _WIN64
    ULONG   pad;            // keep struct 64bit aligned for IA64 builds
#endif
}
OH;

typedef struct _HEAP
{
    OH      oh;             // Contains base OH struct for entire heap.

    HEAP*   pNextHeap;
    HEAP*   pPrevHeap;

    ULONG   ulSizeInBytes;  // size in bytes of this heap
    ULONG   ulOffset;       // physical offset to base of heap
}
HEAP;

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    ULONG     pad;          // keep pointers below 64bit aligned for IA64

    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    DSURF*    next;         // for 2-link list of DSURFs
    DSURF*    prev;         // for 2-link list of DSURFs

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

    /* the following information is from OH structure */
    VOID*    LinearPtr;
    ULONG    LinearStride;

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    4

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x0001,   // Don't kick stuff out of off-
                                        //   screen memory to make room
    FLOH_MAKE_PERMANENT     = 0x0002,   // Allocate a permanent entry
    FLOH_RESERVE            = 0x0004,   // Allocate an off-screen entry,
                                        //   but let it be used by discardable
                                        //   bitmaps until it's needed
} FLOH;

// Publicly callable heap APIs:

OH*  pohAllocate(PDEV*, LONG, LONG);
void pohFree(PDEV*, OH*);

BOOL pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
BOOL __fastcall bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);


/////////////////////////////////////////////////////////////////////////
// Pointer stuff

#define POINTER_DATA_SIZE       40      // Number of bytes to allocate for the
                                        //   miniport down-loaded pointer code
                                        //   working space
#define HW_INVISIBLE_OFFSET     2       // Offset from 'ppdev->yPointerBuffer'
                                        //   to the invisible pointer
//#define HW_POINTER_DIMENSION    64      // Maximum dimension of default
//                                        //   (built-in) hardware pointer
#define HW_POINTER_DIMENSION    32      // Maximum dimension of default
                                        //   (built-in) hardware pointer


#define HW_POINTER_HIDE         63      // Hardware pointer start pixel
                                        //   position used to hide the pointer
//#define HW_POINTER_TOTAL_SIZE   1024    // Total size in bytes required
//                                        //   to define the hardware pointer
//                                        //   (must be a power of 2 for
//                                        //   allocating space for the shape)
#define NV1_POINTER_TOTAL_SIZE   256    // Total size in bytes required



typedef VOID (FNSHOWPOINTER)(PDEV*, BOOL);
typedef VOID (FNMOVEPOINTER)(PDEV*, LONG, LONG);
typedef ULONG (FNSETPOINTERSHAPE)(SURFOBJ *,SURFOBJ*,SURFOBJ*,XLATEOBJ*,LONG,LONG,LONG,LONG,LONG,LONG,BOOL);
typedef VOID (FNENABLEPOINTER)(PDEV*, BOOL);

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);
ULONG nvSetGammaRamp(PDEV *ppdev, PUSHORT fpRampVals);
ULONG nvGetGammaRamp(PDEV *ppdev, PUSHORT fpRampVals);
BOOL nvSetHeadGammaRamp(PDEV *ppdev, ULONG ulHead, PUSHORT fpRampVals);
BOOL nvGetHeadGammaRamp(PDEV *ppdev, ULONG ulHead, PUSHORT fpRampVals);

#if 0 // _WIN32_WINNT >= 0x0500
BOOL    DrvIcmSetDeviceGammaRamp(DHPDEV, ULONG, LPVOID);
HBITMAP DrvDeriveSurface(DD_DIRECTDRAW_GLOBAL *, DD_SURFACE_LOCAL *);
#endif

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))
#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

#ifndef NVD3D
/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

// There's a 64K granularity that applies to the mapping of the frame
// buffer into the application's address space:
#endif // #ifndef NVD3D

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
BOOL bAssertModeDirectDraw(PDEV*, BOOL);

#ifdef VPE_NT
DWORD   VPE_DriverInit(PDEV*);
#endif

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

#if (_WIN32_WINNT < 0x0500)
#define BLENDOBJ   VOID
#endif


typedef VOID (FNSETDESTBASE)(PDEV*, ULONG, LONG);
typedef VOID (FNSETSOURCEBASE)(PDEV*, ULONG, LONG);

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, RBRUSH_COLOR, POINTL*);
typedef VOID (FNMEMTOSCRN)(PDEV*, SURFOBJ*, POINTL*, RECTL *);
typedef BOOL (FNSCRNTO1BPPMEM)(PDEV*, LONG, RECTL *, SURFOBJ*, SURFOBJ*, POINTL*, RECTL *, XLATEOBJ *);

typedef BOOL (FNSCRNTOMEM)(PDEV*, LONG, RECTL *, SURFOBJ*, SURFOBJ*, POINTL*, RECTL *, XLATEOBJ *);
typedef VOID (FNSCRNTOSCRNPAT)(PDEV*, LONG, RECTL*, POINTL*, RECTL*, BRUSHOBJ*, POINTL*, ROP4);

typedef VOID (FNGETSCRNBITS)(PDEV* ,DSURF* ,SURFOBJ* ,RECTL* ,POINTL* );

typedef VOID (FNMEMTOSCRNPATTERN)(PDEV*, SURFOBJ*, POINTL*, RECTL *,ULONG ,RBRUSH_COLOR * , RECTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ULONG, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*,ULONG,BLENDOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ULONG, POINTL*, RECTL*, BLENDOBJ*);
typedef VOID (FNCOLORKEYBLT)(PDEV*, LONG, RECTL*, POINTL*, RECTL*, ULONG);
typedef VOID (FNFASTPATREALIZE)(PDEV*, RBRUSH*, POINTL*, BOOL);
typedef VOID (FNIMAGETRANSFER)(PDEV*, BYTE*, LONG, LONG, LONG, ULONG);
typedef BOOL (FNTEXTOUT)(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*,
                         BRUSHOBJ*, BRUSHOBJ*);
typedef VOID (FNLINETOTRIVIAL)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX);
typedef VOID (FNLINETOCLIPPED)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX, RECTL*);
typedef VOID (FNSETPALETTE)(PDEV*, ULONG, ULONG);

typedef VOID (FNWAITENGINEBUSY)(PDEV*);
typedef VOID (FNWAITCHANNELSWITCH)(PDEV*);
typedef ULONG (FNDMAPUSHGO)(PDEV*, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
typedef BOOL (FNSTROKEPATH)(SURFOBJ *,PATHOBJ *,CLIPOBJ *,XFORMOBJ*,BRUSHOBJ *,POINTL *,LINEATTRS *, MIX);
typedef BOOL (FNLINETO)(SURFOBJ *,CLIPOBJ *,BRUSHOBJ *,LONG,LONG,LONG,LONG,RECTL *,MIX);
typedef BOOL (FNSTRETCHCOPY)(PDEV*, ULONG, int, RECTL*, RECTL*, int, RECTL*);

typedef VOID (FastXFER)(PDEV*, RECTL*, SURFOBJ*, POINTL*, XLATEOBJ*);

typedef VOID (FNACQUIREOGLMUTEX)(PDEV*);
typedef VOID (FNRELEASEOGLMUTEX)(PDEV*);

//******************************************************************************
// NV1 Function declarations
//******************************************************************************


FNWAITENGINEBUSY    NV1_WaitWhileGraphicsEngineBusy;
FNSTROKEPATH        NV1StrokePath;
FNLINETO            NV1LineTo;

//******************************************************************************
// NV3 Function declarations
// (These functions support 16bpp in 555 format)
//******************************************************************************

FNSETDESTBASE       NV3_SetDestBase;
FNSETSOURCEBASE     NV3_SetSourceBase;
FNFILL              NV3FillPatFast;
FNFILL              NV3FillSolid;
FNMEMTOSCRN         NV3MemToScreenBlt;
FNMEMTOSCRNPATTERN  NV3MemToScreenWithPatternBlt;
FNXFER              NV3Xfer1bpp;
FNXFER              NV3Xfer4bpp;
FNXFER              NV3XferNative;
FNCOPY              NV3CopyBlt;
FNTEXTOUT           NV3TextOut;
FNSETPALETTE        NV3SetPalette;

FNWAITENGINEBUSY    NV3_WaitWhileGraphicsEngineBusy;
FNWAITCHANNELSWITCH NV3_WaitForChannelSwitch;
FNDMAPUSHGO         NV3_DmaPushGo;

FNACQUIREOGLMUTEX   NV3_AcquireOglMutex;
FNRELEASEOGLMUTEX   NV3_ReleaseOglMutex;

FNSCRNTO1BPPMEM     NV4ScreenTo1bppMemBlt;

FNSCRNTOMEM         NV4ScreenToMemBlt;
FNSCRNTOMEM         NV4ScreenToMem16to4bppBlt;
FNSCRNTOMEM         NV4ScreenToMem32to4bppBlt;
FNSCRNTOMEM         NV4ScreenToMem16to8bppBlt;
FNSCRNTOMEM         NV4ScreenToMem32to8bppBlt;
FNSCRNTOSCRNPAT     NV4ScreenToScreenWithPatBlt;

FNWAITENGINEBUSY    NV4_WaitWhileGraphicsEngineBusy;
FNWAITCHANNELSWITCH NV4_WaitForChannelSwitch;

FNACQUIREOGLMUTEX   NV4_AcquireOglMutex;
FNRELEASEOGLMUTEX   NV4_ReleaseOglMutex;
VOID NV4_EnableDither(PDEV*  ppdev, BOOLEAN DitherFlag);

//******************************************************************************
// NV4 DMA Pusher Function declarations
// (These functions support 16bpp in 565 format)
//******************************************************************************

FNSETDESTBASE       NV4_DmaPushSetDestBase;
FNSETSOURCEBASE     NV4_DmaPushSetSourceBase;
FNFILL              NV4DmaPushFillPatFast;
FNFILL              NV4DmaPushFillSolid;
FNMEMTOSCRN         NV4DmaPushMemToScreenBlt;
FNMEMTOSCRNPATTERN  NV4DmaPushMemToScreenWithPatternBlt;
FNXFER              NV4DmaPushXfer1bpp;
FNXFER              NV4DmaPushXfer4bpp;
FNXFER              NV4DmaPushXferNative;
FNCOPY              NV4DmaPushCopyBlt;
FNCOLORKEYBLT       NV4DmaPushColorKeyBlt;
FNTEXTOUT           NV4DmaPushTextOut;
FNSETPALETTE        NV4DmaPushSetPalette;

FNXFER              NV4DmaPushXfer4to16bpp;
FNXFER              NV4DmaPushXfer8to16bpp;
FNXFER              NV4DmaPushXfer4to32bpp;
FNXFER              NV4DmaPushXfer8to32bpp;
FNXFER              NV4DmaPushIndexedImage;

FastXFER            NV4DmaPushFastXfer8to32;
FastXFER            NV4DmaPushFastXfer8to16;

FNGETSCRNBITS       NV4DmaPushDMAGetScreenBits;

FNWAITENGINEBUSY    NV4_DmaPushWaitWhileGraphicsEngineBusy;
FNWAITCHANNELSWITCH NV4_DmaPushWaitForChannelSwitch;
FNSTROKEPATH        NV4DmaPushStrokePath;
FNLINETO            NV4DmaPushLineTo;
FNSTRETCHCOPY       NV4DmaPushStretchCopy;

//******************************************************************************
// NV10 DMA Pusher Function declarations
// (These functions support 16bpp in 565 format)
//******************************************************************************

FNXFER              NV4DmaPushIndexedImage;     // this function call NV10DmaPush, but include
                                                // a bugfix for bug #20000720-213841
FNXFER              NV10DmaPushIndexedImage;
FNSETDESTBASE       NV10_DmaPushSetDestBase;
FNSETSOURCEBASE     NV10_DmaPushSetSourceBase;


FNFASTPATREALIZE    vMmFastPatRealize;
FNIMAGETRANSFER     vMmImageTransferMm16;
FNIMAGETRANSFER     vMmImageTransferMm32;
FNLINETOTRIVIAL     vMmLineToTrivial;
FNLINETOCLIPPED     vMmLineToClipped;


//////////////////////////////////////////////////////////////////////
// Function pointer for Direct Draw
//////////////////////////////////////////////////////////////////////

typedef ULONG (FNGRAPHICSENGINEBUSY)(PDEV*);
typedef VOID (FNFLIPBUFFER)(PDEV*,ULONG);
typedef ULONG (FNVBLANKISACTIVE)(PDEV*);
typedef VOID (FNWAITWHILEVBLANKACTIVE)(PDEV*);
typedef VOID (FNWAITWHILEDISPLAYACTIVE)(PDEV*);
typedef ULONG (FNGETSCANLINE)(PDEV*);
typedef VOID (FNDDENABLE)(PDEV*);
typedef DWORD (FNDDUPDATEFLIPSTATUS)(PDEV*, DWORD);

typedef ULONG (FNFIFOISBUSY)(PDEV *);

FNGRAPHICSENGINEBUSY    NV3_GraphicsEngineBusy;
FNGRAPHICSENGINEBUSY    NV4_GraphicsEngineBusy;
FNFLIPBUFFER            NV3_FlipBuffer;
FNVBLANKISACTIVE        NV3_VBlankIsActive;
FNVBLANKISACTIVE        NV4_VBlankIsActive;
FNWAITWHILEVBLANKACTIVE NV3_WaitWhileVBlankActive;
FNWAITWHILEVBLANKACTIVE NV4_WaitWhileVBlankActive;
FNWAITWHILEDISPLAYACTIVE NV3_WaitWhileDisplayActive;
FNWAITWHILEDISPLAYACTIVE NV4_WaitWhileDisplayActive;
FNGETSCANLINE           NV_GetScanLineData;

FNFIFOISBUSY            NV1FifoIsBusy;

VOID vPutBits(PDEV*, DSURF *,SURFOBJ*, RECTL*);
VOID vGetBits(PDEV*, DSURF *,SURFOBJ*, RECTL*);

VOID vIoSlowPatRealize(PDEV*, RBRUSH*, BOOL);

VOID NvHwSpecific(PDEV* ppdev);
//******************************************************************************
// Capabilities flags
//
// These are private flags passed to us from the NV miniport.  They
// come from the 'DriverSpecificAttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the NV miniport's 'NV.h'!
//******************************************************************************

//******************************************************************************
// Do NOT use CAPS_NVX_IS_PRESENT anywhere in the display driver.  Chip
// capabilities should be based on the classes that are allocated.  See
// ppdev->CurrentClass for which classes got allocated at init time.
//******************************************************************************


typedef enum {
/*    
    CAPS_NV1_IS_PRESENT     = 0x00000010,   // NV1 Chip is present
    CAPS_NV3_IS_PRESENT     = 0x00000020,   // NV3 Chip is present
    CAPS_NV4_IS_PRESENT     = 0x00000040,   // NV4 Chip is present
    CAPS_NV5_IS_PRESENT     = 0x00000080,   // NV5 Chip is present
    CAPS_NV5VANTA_IS_PRESENT= 0x00000100,   // NV5 VANTA Chip is present
    CAPS_NV5ULTRA_IS_PRESENT= 0x00000200,   // NV5 ULTRA Chip is present
    CAPS_NV0A_IS_PRESENT    = 0x00000400,   // NV0A Chip is present
    CAPS_NV10_IS_PRESENT    = 0x00000800,   // NV10 Chip is present
 CAPS_NV5MODEL64_IS_PRESENT = 0x00001000,   // NV5 Model 64 is present
 CAPS_NV10DDR_IS_PRESENT    = 0x00002000,   // NV10 DDR Chip is present
 CAPS_NV10GL_IS_PRESENT     = 0x00004000,   // NV10 GL Chip is present
 CAPS_NV11_IS_PRESENT       = 0x00008000,   // NV11 Chip is present
 CAPS_NV11DDR_IS_PRESENT    = 0x00010000,   // NV11 DDR Chip is present
 CAPS_NV11M_IS_PRESENT      = 0x80000000,   // NV11M Chip is present
 CAPS_NV11GL_IS_PRESENT     = 0x00020000,   // NV11 GL Chip is present
 CAPS_NV15_IS_PRESENT       = 0x00040000,   // NV15 Chip is present
 CAPS_NV15DDR_IS_PRESENT    = 0x00080000,   // NV15 DDR Chip is present
 CAPS_NV15GL_IS_PRESENT     = 0x00100000,   // NV15 GL Chip is present
 CAPS_NV15BR_IS_PRESENT     = 0x00200000,   // NV15 BR Chip is present
 CAPS_NV20_IS_PRESENT       = 0x00400000,   // NV20 Chip is present
*/    
// not used    CAPS_BT485_POINTER      = 0x00400000,   // Use Brooktree 485 pointer
// not used     CAPS_TI025_POINTER      = 0x00800000,   // Use TI TVP3020/3025 pointer
// not used     CAPS_SCALE_POINTER      = 0x01000000,   // Set if the S3 hardware pointer
// not used                                             //   x position has to be scaled by
// not used                                             //   two
// not used     CAPS_SPARSE_SPACE       = 0x02000000,   // Frame buffer is mapped in sparse
// not used                                             //   space on the Alpha
// not used     CAPS_NEW_BANK_CONTROL   = 0x04000000,   // Set if 801/805/928 style banking
// not used     CAPS_NEWER_BANK_CONTROL = 0x08000000,   // Set if 864/964 style banking
// not used     CAPS_RE_REALIZE_PATTERN = 0x10000000,   // Set if we have to work around the
// not used                                             //   864/964 hardware pattern bug
// not used     CAPS_SLOW_MONO_EXPANDS  = 0x20000000,   // Set if we have to slow down
// not used                                             //   monochrome expansions
    CAPS_SW_POINTER         = 0x40000000,   // No hardware pointer; use software simulation
// Note definition above: CAPS_NV11M_IS_PRESENT      = 0x80000000,   // NV11M Chip is present


} CAPS;

#define CAPS_DAC_POINTER        (CAPS_BT485_POINTER | CAPS_TI025_POINTER)

#define CAPS_LINEAR_FRAMEBUFFER CAPS_NEW_MMIO
                                            // For now, we're linear only
                                            //   when using with 'New MM I/O'

//******************************************************************************
// Do NOT use NVX_IS_PRESENT anywhere in the display driver.  Chip
// capabilities should be based on the classes that are allocated.  See
// ppdev->CurrentClass for which classes got allocated at init time.
//******************************************************************************

/*
// The NV4_IS_PRESENT bit is also used as a compatibility flag, so to truly detect an NV4, no other bits must be set
#define IS_NV04_PRESENT(ppdev) ((ppdev->flCaps & CAPS_NV4_IS_PRESENT) && (ppdev->flCaps & ~CAPS_NV4_IS_PRESENT)==0)

#define IS_NV05_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV5_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV5VANTA_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV5MODEL64_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV5ULTRA_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV0A_IS_PRESENT))

#define IS_NV10_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV10_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV10DDR_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV10GL_IS_PRESENT))

#define IS_NV11_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV11_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV11DDR_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV11M_IS_PRESENT)   ||\
             (ppdev->flCaps & CAPS_NV11GL_IS_PRESENT))

#define IS_NV15_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV15_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV15DDR_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV15BR_IS_PRESENT)  ||\
             (ppdev->flCaps & CAPS_NV15GL_IS_PRESENT))

#define IS_NV20_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV20_IS_PRESENT))

*/

// DENSE(ppdev) returns TRUE if the normal 'dense space' mapping of the
// frame buffer is being used.  It returns FALSE only on the Alpha when
// the frame buffer is mapped in using 'sparse space,' meaning that all
// reads and writes to and from the frame buffer must be done through the
// funky 'ioaccess.h' macros.

#if defined(_ALPHA_)
    #define DENSE(ppdev)        (!(ppdev->flCaps & CAPS_SPARSE_SPACE))
#else
    #define DENSE(ppdev)        1
#endif

////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_GLYPH_CACHE        = 0x0001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
    STAT_DIRECTDRAW_CAPABLE = 0x0004,   // Card is DirectDraw capable
    STAT_DIRECTDRAW_ENABLED = 0x0008,   // DirectDraw is currently enabled
    STAT_STREAMS_ENABLED    = 0x0010,   // Streams are enabled for this mode
    STAT_FORMATTER_ENABLED  = 0x0020,   // Pixel formatter enabled for this mode
} STATUS;

////////////////////////////////////////////////////////////////////////
// Nvidia OpenGL client information.
// globalOpenGLData.oglClientCount will not go to 0, so it is bad to use it for ogl tests!
#define OglIsEnabled(_pdev) (0 != globalOpenGLData.oglDrawableClientCount)
#define OGL_FLIPPED() (ppdev->ulPrimarySurfaceOffset != ppdev->ulFlipBase)

#define NV_OGL_CLIENT_DRAWABLE_INFO 0x0001 // if bit ON then drawable info exists...
#define NV_OGL_CLIENT_CONTEXT_INFO  0x0002 // if bit ON then context info exits...
#define NV_OGL_CLIENT_SHARED_INFO   0x0004 // if bit ON then context info exits...
#define NV_OGL_CLIENT_WOC_DELETE    0x0008 // if bit ON then WOC_DELETE occured on window...

typedef struct _NV_OPENGL_CLIENT_INFO
    {
    DWORD                      flags;               // bits indicating allocated/free resources
    HDRVOBJ                    hDrvObj;             // driver object handle for this client
    WNDOBJ                     *pwo;                // WNDOBJ pointer for drawable node
    struct _PDEV               *ppdev;              // Pointer to current ppdev;
    DWORD                      modeSwitchCount;     // mode switch counter when hDrvObj is created
    ULONG                      processHandle;       // Process handle from client associated with globalData
    PVOID                      oglGlobalPagePtr;    // Pointer to shared memory
    PVOID                      pfifoAddress;        // Address of FIFO in client address space
    PVOID                      pbusAddress;         // Address of PBUS in client address space
    ULONG                      hClient;             // Per-process shared hClient
    PIXELFORMATDESCRIPTOR      pfd;                 // pixelformat of the client window
    BOOL                       bStereoDisabled;     // if stereo pfd: TRUE: currently disabled because unused
    BOOL                       bFlipping;           // TRUE if client is allowed to flip.
    DWORD                      dwProcessID;         // ProcessID of ICD's process
    struct _NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo; // drawable information for this client
    struct _NV_OPENGL_CONTEXT_INFO     *clientContextInfo;  // context information for this client
    } NV_OPENGL_CLIENT_INFO;

struct _NV_OPENGL_CLIENT_INFO_LIST;
typedef struct _NV_OPENGL_CLIENT_INFO_LIST
    {
        ULONG refCount;
        NV_OPENGL_CLIENT_INFO              clientInfo;
        struct _NV_OPENGL_CLIENT_INFO_LIST *next;
    } NV_OPENGL_CLIENT_INFO_LIST;

typedef struct _NV_OPENGL_CLIENT_LIST_HEAD
    {
    NV_OPENGL_CLIENT_INFO_LIST *clientList;
    } NV_OPENGL_CLIENT_LIST_HEAD;

typedef struct _NV_LAYER_PALETTE
    {
    struct _NV_LAYER_PALETTE *next;

    void         *windowHandle;
    unsigned int  entries[ICD_PALETTE_ENTRIES];
    unsigned int  crTransparent;
    } NV_LAYER_PALETTE;

typedef struct _NV_LAYER_PALETTE_LIST_HEAD
    {
    NV_LAYER_PALETTE *paletteList;
    } NV_LAYER_PALETTE_LIST_HEAD;

typedef struct _GLOBAL_OPENGL_DATA {
    NV_OPENGL_CLIENT_LIST_HEAD oglClientListHead;
    ULONG                      oglClientCount; // Count of number of OGL clients connected to display driver
    ULONG                      oglDrawableClientCount; // Count of number of OGL drawable clients
    // RBierman: addons for overlay
    NV_LAYER_PALETTE_LIST_HEAD oglLayerPaletteListHead;
    ULONG                      oglLayerPaletteClientCount; 
#ifdef NV_MAIN_MULTIMON
    struct _LINKEDLISTHEAD     *oglpdevList;
#endif
} GLOBAL_OPENGL_DATA;

extern GLOBAL_OPENGL_DATA globalOpenGLData;
extern VOID OglAcquireGlobalMutex();
extern VOID OglReleaseGlobalMutex();

typedef struct _CLASSOBJ {
    ULONG ChannelDMA;
    ULONG IndexedImageFromCPU;
    ULONG VideoLutCursorDac;
    ULONG ContextSurfaces2D;
    ULONG VideoOverlay;
    ULONG ScaledImageFromMemory;
    ULONG AlphaImageFromMemory;
} CLASSOBJ;

////////////////////////////////////////////////////////////////////////
// Misc video related defs
#define NV_MAX_BUFFERS 8

typedef struct _VIDBUFFER
{
     ULONG offset;                 /* byte offset of top-left pixel       00-  03*/
     ULONG pitch;                  /* bytes between lines                 04-  07*/
     ULONG size;                   /* height_width U16_U16 in pixels      08-  0b*/
     ULONG format;                 /* ORed NV_VFM_IMAGE_FORMAT_*          0c-  0f*/
     ULONG notify;                 /* notification style, varies w/OS     10-  13*/
} VIDBUFFER, *PVIDBUFFER;

// for ICD-Overlay purposes + DDrawApp detection
#define MAX_POINTER_LIST_ELEMENTS 50 

typedef struct _POINTER_LIST
{
    ULONG  cElements;
    PULONG apulElements[MAX_POINTER_LIST_ELEMENTS];
}POINTER_LIST, *PPOINTER_LIST;

////////////////////////////////////////////////////////////////////////
// HW workaround flags
#define NV_WORKAROUND_NV11RevB_DIRTHERING       0x00000001

// this is required for pre-win2k driver builds. on win2k, the display
// driver shares a flip record in GLOBALDATA with the d3d driver
typedef struct 
{
    FLATPTR         fpFlipFrom;             // Surface we last flipped from
    FLATPTR         fpFlipTo;               // Surface we last flipped to
    LONGLONG        liFlipTime;             // Time at which last flip
                                            //   occured
    LONGLONG        liFlipDuration;         // Precise amount of time it
                                            //   takes from vblank to vblank
    BOOL            bHaveEverCrossedVBlank; // True if we noticed that we
                                            //   switched from inactive to
                                            //   vblank
    BOOL            bWasEverInDisplay;      // True if we ever noticed that
                                            //   we were inactive
    UINT            dwFlipScanLine;
    BOOL            bFlipFlag;              // True if we think a flip is
                                            //   still pending
    DWORD           fpPreviousFlipFrom;     // Previous surface we flipped from
    LONGLONG        liPreviousFlipTime;     // Time of previous surface flip
    DWORD           dwReserved1;            // pad to 64 bits
} OLD_FLIPRECORD;

//
// cliplist structure managed through cliplist.c/h
typedef struct _CLIPLIST
{
  RECTL   rclBounds;  // visible bounding <= rclClient!
  LONG    cMax;       // allocated size for prcl
  LONG    c;          // number of rects stored in prcl
  LONG    cPixel;     // Number of total pixels inside cliplist
  RECTL  *prcl;       // array of size cMac with c valid rects
} CLIPLIST;


////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    // -------------------------------------------------------------------
    // NOTE: Changes between here and NOTE1 in the PDEV structure must be
    // reflected in i386\strucs.inc (assuming you're on an x86, of course)!

    ULONG       NVSignature;
    LONG        xOffset;                // Pixel offset from (0, 0) to current
    LONG        yOffset;                //   DFB located in off-screen memory
    DWORD*      pjMmBase;               // We'll use it as a ptr to our NV Channel
    volatile DWORD* GrStatusReg;        // We'll use it as a ptr to our Gr Status Reg
    volatile DWORD* FbConfig0Reg;       // We'll use it as a ptr to our Fb Config0 Reg
    volatile DWORD* FbStartAddr;        // We'll use it as a ptr to our Fb Start Addr
    volatile DWORD* DACRegs;            // We'll use it as a ptr to our Cursor registers
    volatile UCHAR* PRMCIORegs;         // NV3 PRMCIO Regs
    volatile UCHAR* PRMVIORegs;         // NV3 PRMVIO Regs
    volatile DWORD* PRAMDACRegs;        // NV3 PRAMDAC Regs
    volatile DWORD* PRAMINRegs;         // NV3 PRAMIN Regs
    volatile DWORD* PGRAPHRegs;         // NV3 PGRAPH Regs
    volatile DWORD* PFIFORegs;          // NV3 PFIFO Regs
    ULONG       FbBufferToggle;         // 0 or 1 (denotes frame buffer)
    BYTE*       pjFrameBufbase;         // pjFrameBuf base pointing to the base of frame buffer
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Distance from one scan to the next.
    LONG        cjPelSize;              // 1 if 8bpp, 2 if 16bpp, 3 if 24bpp,
                                        //   4 if 32bpp
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                        //   (our current colour depth)
    LONG        iBoard;                 // Logical multi-board identifier
                                        //   (zero by default)
    ULONG       fontCacheOffset;        // Offset into font cache offscreen mem area
    ULONG       fontCacheEnabled;       // Flag to indicate whether driver will cache fonts

    CAPS        flCaps;                 // Capabilities flags
    STATUS      flStatus;               // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    LONG        cBitsPerPel;            // Bits per pel (8, 15, 16, 24 or 32)
    ULONG       cbFrameBuf;             // Size of frame buffer in bytes
    ULONG       AlphaEnableValue;       // Global alpha enable value

    ////////// DMA Pusher Functionality

    ULONG       DmaPushEnabled2D;
    ULONG       DmaPushBufTotalSize;
    ULONG       DmaPushBufCanUseSize;
    ULONG       DmaPushBufMinSize;
    ULONG       DmaPushHandle;
    ULONG      *nvDmaFifo;
    ULONG       nvDmaCount;
    ULONG      *nvDmaChannel;
    ULONG       nvDmaCachedGet;
    ULONG       nvDmaCachedPut;
    ULONG       nvDmaPreviousPut;
    ULONG       nvDmaWrapFlag;
    LONG        nvDmaCachedFreeCount;
    ULONG      *nvDmaFlushFixDwordPtr;
    ULONG       nvDmaFlushFixDummyValue;

    // -------------------------------------------------------------------
    // NOTE1: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    ULONG       left;                   // left edge of display (relative to desktop)
    ULONG       top;                    // rop edge of display (relative to desktop)

    volatile DWORD* NvBaseAddr;         // Base address of NV device regs
    VOID*  NvDmaIndexedImageLut;        // pointer to indexed image LUT buffer
    ULONG  NvLastIndexedImageNotifier;

    ULONG       AliFixupIoNeeded;       // Flag to enable IO fixup for ALI
    ULONG       AliFixupIoBase;         // Mapping to unused IO register

    ULONG       ulMode;                 // Mode the mini-port driver is in.

    FLONG       flHooks;                // What we're hooking from GDI
    FLONG       flHooksDeviceBitmap;    // What we're hooking from GDI
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    VOID*       pMemToMemBuffer;        // General purpose temporary buffer,
                                        //   MEM_TO_MEM_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    ULONG       MemToMemBufferSize;     // Holds size of mem to mem temporary buffer
    USHORT*     apwMmXfer[XFER_BUFFERS];// Pre-computed array of unique
    ULONG*      apdMmXfer[XFER_BUFFERS];//   addresses for doing memory-mapped
                                        //   transfers without memory barriers
                                        // Note that the 868/968 chips have a
                                        //   hardware bug and can't do byte
                                        //   transfers
    HSEMAPHORE  csCrtc;                 // Used for synchronizing access to
                                        //   the CRTC register
    HSEMAPHORE  csFifo;                 // Used for synchronizing access to
                                        //   the DMA pusher or CPU pusher shared FIFO
    ULONG       numDevices;             // Number of devices OpenGL is using...
    ULONG       bSupportOgl;            // TRUE if OpenGL ICD is supported
    ULONG       bReleaseOglMutex;       // TRUE indicates driver must release the OGL mutex
    ULONG       *oglGlobalPagePtr;      // pointer to page of locked down memory used by OGL
    PVOID       origOglGlobalPagePtr;   // Pointer remembered to free oglGlobalPagePtr
    PVOID       oglGlobalPageMdl;       // MDL to locked down OGL page
    ULONG       oglGlobalPageSize;      // size in bytes of locked down OGL page
    ULONG       *oglMutexPtr;           // OGL mutex lock pointer
    ULONG       *oglModeSwitchPtr;      // OGL mode switch pointer
    ULONG       bOglSingleBackDepthSupported; // TRUE if display driver allocates single-back-depth surface
    ULONG       bOglSingleBackDepthCreated; // TRUE if display driver allocated single-back-depth surface
    ULONG       oglSyncGdi;             // Synchronize OpenGL with GDI
    ULONG       ulOpenGLinFullScreen;   // TRUE if OpenGL is rendering in FULL screen
    ULONG       hwGfxCaps;              // Graphics caps reported by the RM. 
    DWORD       oglRegUBB;              // registry val for NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER
    DWORD       oglRegFlippingControl;  // registry val for NV4_REG_OGL_BUFFER_FLIPPING_CONTROL
    DWORD       oglRegWindowFlipping;   // registry val for NV_REG_OGL_WINDOW_FLIPPING
    DWORD       oglRegOverlaySupport;   // registry val for NV_REG_OGL_OVERLAY_SUPPORT
    DWORD       oglRegApiStereoSupport; // registry val for NV_REG_OGL_STEREO_SUPPORT
    DWORD       oglRegApiStereoMode;    // registry val for NV_REG_OGL_API_STEREO_MODE
    BOOL        bOglOverlayDesired;     // reflects that ogl overlay is switched on via registry
    BOOL        bOglStereoDesired;      // reflects that ogl stereo is switched on via registry
    BOOL        bOglStereoActive;       // TRUE if stereo is active now, and glasses are in any of oglRegApiStereoMode supported modes
    ULONG       ulOglActiveViews;       // number of addition active OGL_STEREO_NUMBUFFERS views for ogl 0 -> ogl not running, 1 -> monoscopic left only, 2 -> stereo left and right
    NvU32       singleFrontOffset[OGL_STEREO_NUMBUFFERS]; // offset in video memory to single-front buffer
    NvU32       singleFrontPitch[OGL_STEREO_NUMBUFFERS];  // offset in video memory to single-front buffer
    NvU32       singleBack1Offset[OGL_STEREO_NUMBUFFERS]; // offset in video memory to single-back buffer
    NvU32       singleBack1Pitch[OGL_STEREO_NUMBUFFERS];  // offset in video memory to single-back buffer
    NvU32       singleDepthOffset[OGL_STEREO_NUMBUFFERS]; // offset in video memory to single-depth buffer
    NvU32       singleDepthPitch[OGL_STEREO_NUMBUFFERS];  // offset in video memory to single-depth buffer
    ULONG       ulTempOffscreenBufferSize;  // size of temporary offscreen buffer ( lDelta long )
    ULONG       ulTempOffscreenBufferOffset;// offset of temporary offscreen buffer ( needed in ubb mode )
    ULONG       bOglOverlaySurfacesCreated; // TRUE if display driver allocated overlay surfaces
                                            //      for OpenGL
    NvU32       singleFrontMainOffset[OGL_STEREO_NUMBUFFERS];      // Offsets and pitches to main and overlay planes
    NvU32       singleFrontMainPitch[OGL_STEREO_NUMBUFFERS];       //    for opengl pseudo hardware implementation of
    NvU32       singleBack1MainOffset[OGL_STEREO_NUMBUFFERS];      //    overlay planes
    NvU32       singleBack1MainPitch[OGL_STEREO_NUMBUFFERS]; 
    NvU32       singleFrontOverlayOffset[OGL_STEREO_NUMBUFFERS];
    NvU32       singleFrontOverlayPitch[OGL_STEREO_NUMBUFFERS]; 
    NvU32       singleBack1OverlayOffset[OGL_STEREO_NUMBUFFERS];
    NvU32       singleBack1OverlayPitch[OGL_STEREO_NUMBUFFERS]; 
    POINTER_LIST plSavedPopupMenus; // MSchwarzer 10/04/2000 need this for overlay popuprestauration
    LONG        lSavedScreenBits;         // MSchwarzer 11/20/2000 need this for overlay popuprestauration
    FNACQUIREOGLMUTEX *pfnAcquireOglMutex; // function to acquire the OGL mutex
    FNRELEASEOGLMUTEX *pfnReleaseOglMutex; // function to release the OGL mutex
    CLIPLIST          OglNegativeClipList; // pointer to negative cliplist == desktop - all clients

    ////////// Low-level blt function pointers:

    FNSETDESTBASE*      pfnSetDestBase;
    FNSETSOURCEBASE*    pfnSetSourceBase;

    FNFILL*             pfnFillSolid;
    FNFILL*             pfnFillPat;
    FNXFER*             pfnXfer1bpp;
    FNXFER*             pfnXfer4bpp;
    FNXFER*             pfnXferNative;
    FNXFER*             pfnXfer8to16bpp;
    FNXFER*             pfnXfer4to16bpp;
    FNXFER*             pfnXfer8to32bpp;
    FNXFER*             pfnXfer4to32bpp;
    FastXFER*           pfnFastXfer8to32;
    FastXFER*           pfnFastXfer8to16;

    FNXFER*             pfnIndexedImage;
    FNCOPY*             pfnCopyBlt;
    FNMEMTOSCRN*        pfnMemToScreenBlt;
    FNSCRNTO1BPPMEM*    pfnScreenTo1BppMemBlt;
    FNGETSCRNBITS*      pfnGetScreenBits;
    FNFASTPATREALIZE*   pfnFastPatRealize;
    FNIMAGETRANSFER*    pfnImageTransfer;
    FNTEXTOUT*          pfnTextOut;
    FNSETPALETTE*       pfnSetPalette;
    FNLINETOTRIVIAL*    pfnLineToTrivial;
    FNLINETOCLIPPED*    pfnLineToClipped;

    
    FNSCRNTOMEM*        pfnScreenToMemBlt;        // 
                                                  //
    DWORD               globalXferOverheadFactor; // This is not a pfn, but is data
                                                  // needed by pfnScreenToMemBlt

    FNSCRNTOMEM*        pfnScreenToMem16to4bppBlt; 
    FNSCRNTOMEM*        pfnScreenToMem32to4bppBlt; 
    FNSCRNTOMEM*        pfnScreenToMem16to8bppBlt; 
    FNSCRNTOMEM*        pfnScreenToMem32to8bppBlt; 

    FNSCRNTOSCRNPAT*    pfnScreenToScreenWithPatBlt; 


    ////////// Other NV function pointers:

    FNWAITENGINEBUSY*   pfnWaitEngineBusy;
    FNWAITCHANNELSWITCH* pfnWaitForChannelSwitch;
    FNDMAPUSHGO*        pfnDmaPushGo;
    FNMEMTOSCRNPATTERN* pfnMemToScreenPatternBlt;
    FNSTROKEPATH*       pfnStrokePath;
    FNLINETO*           pfnLineTo;
    FNSTRETCHCOPY*      pfnStretchCopy;

    ////////// Eng fallback function pointers:
    
    BOOL (*pfnEngBitBlt)(SURFOBJ  *psoTrg,
                                  SURFOBJ  *psoSrc,
                                  SURFOBJ  *psoMask,
                                  CLIPOBJ  *pco,
                                  XLATEOBJ *pxlo,
                                  RECTL    *prclTrg,
                                  POINTL   *pptlSrc,
                                  POINTL   *pptlMask,
                                  BRUSHOBJ *pbo,
                                  POINTL   *pptlBrush,
                                  ROP4      rop4);
    BOOL (*pfnEngCopyBits)(SURFOBJ  *psoDest,
                                    SURFOBJ  *psoSrc,
                                    CLIPOBJ  *pco,
                                    XLATEOBJ *pxlo,
                                    RECTL    *prclDest,
                                    POINTL   *pptlSrc);
    BOOL (*pfnEngAlphaBlend)(SURFOBJ       *psoDest,
                                      SURFOBJ       *psoSrc,
                                      CLIPOBJ       *pco,
                                      XLATEOBJ      *pxlo,
                                      RECTL         *prclDest,
                                      RECTL         *prclSrc,
                                      BLENDOBJ      *pBlendObj);
    BOOL (*pfnEngTransparentBlt)(SURFOBJ       *psoDest,
                                      SURFOBJ       *psoSrc,
                                      CLIPOBJ       *pco,
                                      XLATEOBJ      *pxlo,
                                      RECTL         *prclDest,
                                      RECTL         *prclSrc,
                                      ULONG         iTransColor,
                                      ULONG         Reserved);
    BOOL (*pfnEngTextOut)(SURFOBJ  *pso,
                                   STROBJ   *pstro,
                                   FONTOBJ  *pfo,
                                   CLIPOBJ  *pco,
                                   RECTL    *prclExtra,
                                   RECTL    *prclOpaque,
                                   BRUSHOBJ *pboFore,
                                   BRUSHOBJ *pboOpaque,
                                   POINTL   *pptlOrg,
                                   MIX       mix);
    BOOL (*pfnEngLineTo)(SURFOBJ   *pso,
                                  CLIPOBJ   *pco,
                                  BRUSHOBJ  *pbo,
                                  LONG       x1,
                                  LONG       y1,
                                  LONG       x2,
                                  LONG       y2,
                                  RECTL     *prclBounds,
                                  MIX        mix);
    BOOL (*pfnEngStrokePath)(SURFOBJ   *pso,
                                      PATHOBJ   *ppo,
                                      CLIPOBJ   *pco,
                                      XFORMOBJ  *pxo,
                                      BRUSHOBJ  *pbo,
                                      POINTL    *pptlBrushOrg,
                                      LINEATTRS *plineattrs,
                                      MIX        mix);

    struct {
        LONG  NumBuffers; // number of valid offsets in MultiBufferOffsets (signed to allow better error checking)
        ULONG MultiBufferOffsets[NV_MAX_BUFFERS];
        BOOL  bEnabled;

        struct {
            // FNACQUIREOGLMUTEX *pfnAcquireOglMutex; // function to acquire the OGL mutex
            // FNRELEASEOGLMUTEX *pfnReleaseOglMutex; // function to release the OGL mutex

            ////////// Low-level blt function pointers:
            // FNSETDESTBASE*      pfnSetDestBase;
            // FNSETSOURCEBASE*    pfnSetSourceBase;

            FNFILL*             pfnFillSolid;
            FNFILL*             pfnFillPat;
            FNXFER*             pfnXfer1bpp;
            FNXFER*             pfnXfer4bpp;
            FNXFER*             pfnXferNative;
            FNXFER*             pfnXfer8to16bpp;
            FNXFER*             pfnXfer4to16bpp;
            FNXFER*             pfnXfer8to32bpp;
            FNXFER*             pfnXfer4to32bpp;
            FastXFER*           pfnFastXfer8to32;
            FastXFER*           pfnFastXfer8to16;

            FNXFER*             pfnIndexedImage;
            FNCOPY*             pfnCopyBlt;
            FNMEMTOSCRN*        pfnMemToScreenBlt;
            FNSCRNTO1BPPMEM*    pfnScreenTo1BppMemBlt;
            //FNGETSCRNBITS*      pfnGetScreenBits;
            FNFASTPATREALIZE*   pfnFastPatRealize;
            FNIMAGETRANSFER*    pfnImageTransfer;
            FNTEXTOUT*          pfnTextOut;
            FNSETPALETTE*       pfnSetPalette;
            FNLINETOTRIVIAL*    pfnLineToTrivial;
            FNLINETOCLIPPED*    pfnLineToClipped;

            // Screen to Mem Function Pointers
            FNSCRNTOMEM*        pfnScreenToMemBlt;

            //DWORD               globalXferOverheadFactor; // This is not a pfn, but is data
            //                                              // needed by pfnScreenToMemBlt
            
            FNSCRNTOMEM*        pfnScreenToMem16to4bppBlt; 
            FNSCRNTOMEM*        pfnScreenToMem32to4bppBlt; 
            FNSCRNTOMEM*        pfnScreenToMem16to8bppBlt; 
            FNSCRNTOMEM*        pfnScreenToMem32to8bppBlt; 

            FNSCRNTOSCRNPAT*    pfnScreenToScreenWithPatBlt; 


            ////////// Other NV function pointers:

            // FNWAITENGINEBUSY*   pfnWaitEngineBusy;            
            // FNWAITCHANNELSWITCH* pfnWaitForChannelSwitch;
            // FNDMAPUSHGO*        pfnDmaPushGo;
            FNMEMTOSCRNPATTERN* pfnMemToScreenPatternBlt;
            FNSTROKEPATH*       pfnStrokePath;
            FNLINETO*           pfnLineTo;
            FNSTRETCHCOPY*      pfnStretchCopy;

        } SavedProcs;
    } DoubleBuffer;


    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    FLONG       physicalColorMask;      //
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.

    ////////// Primary surface stuff:
    
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF       dsurfScreen;            // Our private DSURF for the screen
    OH          ohScreen;               // Off-screen heap structure for the
                                        //   visible screen

    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap

    DSURF*      pdsurf;                 // head of 2-link list of all DFBs.

    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    SURFOBJ*    psoPunt3;               // Another one needed for brush conversion

    ////////// Pointer stuff:

    ULONG       MonitorType;            // Cursor adjustment values for when
    ULONG       Underscan_x;            // the driver is running through a TV set
    ULONG       Underscan_y;            //
    ULONG       Scale_x;                //
    ULONG       Scale_y;                //
    ULONG       FilterEnable;           //
    ULONG       TVCursorMin;            //
    ULONG       TVCursorMax;            //

    LONG        xPointerHot;            // xHot of current hardware pointer
    LONG        yPointerHot;            // yHot of current hardware pointer

    LONG        xPointer;               // Start x-position for the current
                                        //   S3 pointer
    LONG        yPointer;               // Start y-position for the current

    ULONG       ulCursorMemOffset[2];   // Offset into inst mem of area for ptr bmps - Double buffer.
    ULONG       ulCursorCurBufIndex;    // Double Buffer, current cursor buffer;

    ULONG       ulCachedCursorWidth;    // Last width programmed into the HW
    ULONG       ulCachedCursorFormat;   // Last format programmed into the HW
    ULONG       ulMaxHwCursorDepth;     // Max color depth of cursor (16/32)
    ULONG       ulMaxHwCursorSize;      // Max cursor width/height supported by
                                        //   current hardware
    BOOL        bSupportAlphaCursor;    // Support Alpha blended cursor

    FNSHOWPOINTER*      pfnShowPointer;
    FNMOVEPOINTER*      pfnMovePointer;
    FNSETPOINTERSHAPE*  pfnSetPointerShape;
    FNENABLEPOINTER*    pfnEnablePointer;

    ////////// Brush stuff:
    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    POINTL      ptlReRealize;           // Work area for 864/964 pattern


    BYTE        NV_CursorImageData[32*32*2]; // Max size is 32x32  *2bytes/pixel
    BYTE        NV_TVCursorImageData[32*32*2]; // Max size is 32x32  *2bytes/pixel

    ////////// Text stuff:

    SURFOBJ*    psoText;                // 1bpp surface to which we will have
                                        //   GDI draw our glyphs for us
    /////////// DirectDraw stuff:

    ULONG       DDrawEnabledFlag;       // Flag denotes if DDRAW was enabled
    ULONG       ulMinOverlayStretch;    // Minimum stretch ratio for this mode,
    DWORD       hDdChannel;             // Channel handle
    DWORD       *ddChannelPtr;          // PIO channel ptr for ddraw
    DWORD       DummyReturn;            // Scratch area used to store return from RM fcts

#ifdef NVD3D
    /////////// Direct3D stuff:
    BOOL                        bD3DInitialized;
    DWORD                       lpLast3DSurfaceRendered;
    DWORD                       dwZBufferContextAddr;
    BOOL                        TwoDRenderingOccurred;
    BOOL                        ThreeDRenderingOccurred;
    struct _def_nv_d3d_context *FirstCtxt;
#endif // NVD3D
    BOOL                        bD3DappIsRunning;

    FNGRAPHICSENGINEBUSY*       pfnGraphicsEngineBusy;
    FNVBLANKISACTIVE*           pfnVBlankIsActive;
    FNWAITWHILEVBLANKACTIVE*    pfnWaitWhileVBlankActive;
    FNWAITWHILEDISPLAYACTIVE*   pfnWaitWhileDisplayActive;
    FNGETSCANLINE*              pfnGetScanline;
    FNFIFOISBUSY*               pfnFifoIsBusy;
    FNDDUPDATEFLIPSTATUS*       pfnUpdateFlipStatus;

    ////////// OpenGL ICD stuff:
    struct _OGLSERVER          *pOglServer;    // Pointer to structure containing OpenGL Server data.
    ULONG                      oglLastChannel; // Count of number of OGL clients connected to display driver
    ULONG                      dwGlobalModeSwitchCount;// Number of mode switches since boot
    ULONG                      OglStencilSwitch;       // Registry switch for OpenGL stencil
    ULONG                      oglColor32Depth16; // TRUE if hardware supports mixed 32/16 mode rendering
    ULONG                      oglColor16Depth32; // TRUE if hardware supports mixed 16/32 mode rendering
    ULONG                      oglMultisample;    // TRUE if hardware supports multisample rendering
    ULONG                      oglDDrawSurfaceCount;
    POINTER_LIST               oglDDrawSurfaceCountList;

    ULONG       iUniqueness;            // display uniqueness for tracking
                                        // resolution changes
    OH*         pohBackBuffer;          // Our 2-d heap allocation structure
                                        //   for the back-buffer
    ULONG       ulBackBuffer;           // Byte offset in the frame buffer
                                        //   to the start of the back-buffer
    OH*         pohRed;
    OH*         pohBlue;
    OH*         pohGreen;
    ULONG       SolidTextureOffset;     // Offset to solid texture data

    /////////// NV list of supported classes
    ULONG       nvNumClasses;
    ULONG*      nvClassList;

    CLASSOBJ    CurrentClass;          

    /////////// NV Buffer Management:

    ULONG       CurrentZOffset;
    ULONG       CurrentZPitch;
    ULONG       CurrentSourceOffset;
    ULONG       CurrentSourcePitch;
    ULONG       CurrentDestOffset;
    ULONG       CurrentDestPitch;
    ULONG       CurrentDitherState;
    ULONG       CurrentDisplayOffset;

    /////////// Ddraw Buffer Management:
    ULONG       DdCurrentSourceOffset;
    ULONG       DdCurrentSourcePitch;
    ULONG       DdCurrentDestOffset;
    ULONG       DdCurrentDestPitch;
    ULONG       DdClipResetFlag;

    // Vertex Cache Stuff

    ULONG       VRotIndex0[8];
    ULONG       VRotIndex1[8];
    ULONG       VRotIndex2[8];
    ULONG       VRotMask[8];
    ULONG       VCache[16];

    ULONG       SavedCursorCheckSums[NUM_CACHED_CURSORS];
    ULONG       SavedCursorBitmaps[NUM_CACHED_CURSORS][512];
    ULONG       NextCachedCursor;


    //Texture buffers related data
    ULONG       pListDevTex;            // A pointer to the list of device textures
                                        // being handled by the physical device

    ULONG       lastRenderedTexKey;     // Contains a reference to the texture (if any)
                                        // used in the last hw primitive rendering,
                                        // this helps us to avoid corrupting the texture
                                        // while it still may be in use by the hw

    NV_VIDEO_CLUTDATA  *ajClutData;     // Local copy of palette data
    /////////// NV Brush stuff:

    DWORD       AlignedBrush[8*8];      // Enough room for an 8x8 pattern

// NVTEST
    DWORD       NVAbsoluteLimitFlag;    // Use to calculate theoretical limit
    DWORD       NVStubTest;             // Used to return without doing anything..
    DWORD       TestChannelFlag;        // Used to return without doing anything..
    DWORD*      TestChannelPtr;
    DWORD       NVClipResetFlag;
    DWORD       NVPatternResetFlag;
    USHORT      NVFreeCount;
    DWORD       NVDebugTrace;           // Used to return without doing anything..
    DWORD       NVRecordFunctionsFlag;
    DWORD       NVLocation[70];        //Record iterations thru paths

    DWORD       dwMaxClip;              // Max. Clip value: (ppdev->cyMemory)<<16) | (0x7fff)

    //*********************************************************************************
    // Direct draw support.
    //*********************************************************************************

    // TBD: these will be replaced by vpp components in GLOBALDATA eventually. -@mjl@
    //    At present, they are used in nv4vid (among others perhaps)
#define NV_MAX_OVERLAY_SURFACES 10 // replaced by NV_VPP_MAX...
    DWORD                       dwOverlayEnabled;
    DWORD                       dwOverlayFormat;
    DWORD                       dwOverlaySurfaces;
    DWORD                       dwOverlayOwner;
    DWORD                       dwOverlaySurfaceLCL[NV_MAX_OVERLAY_SURFACES];
    DWORD                       dwOverlaySrcWidth;
    DWORD                       dwOverlaySrcHeight;
    DWORD                       dwOverlayDstWidth;
    DWORD                       dwOverlayDstHeight;
    DWORD                       dwOverlayDeltaX;
    DWORD                       dwOverlayDeltaY;
    DWORD                       dwOverlayDstX;        // overlay Dst starting point
    DWORD                       dwOverlayDstY;
    DWORD                       dwVideoColorKey;
    ULONG                       OverlaySrcX;        // overlay source starting point
    ULONG                       OverlaySrcY;
    ULONG                       OverlaySrcOffset;
    ULONG                       OverlaySrcPitch;
    ULONG                       OverlaySrcSize;
    ULONG                       OverlayBufferIndex;

    DWORD                       DDrawVideoSurfaceCount;
    ULONG                       NvFloating0UYVYSurfaceMem;
    ULONG                       NvFloating1UYVYSurfaceMem;
    ULONG                       NvFloating0YUYVSurfaceMem;
    ULONG                       NvFloating1YUYVSurfaceMem;
    ULONG                       NvFloatingMem2MemFormatBaseAddress;
    ULONG                       NvYUY2Surface0Mem;
    ULONG                       NvYUY2Surface1Mem;
    ULONG                       NvFloatingMem2MemFormatMemoryHandle;
    ULONG                       NvFloatingMem2MemFormatNextAddress;
    ULONG                       NvYUY2Surface2Mem;
    ULONG                       BaseAddress;
    PVOID                       NvDmaBufferFlat;

    //
    // Directdraw callbacks
    //
    DD_CALLBACKS            ddCallBacks;
    DD_SURFACECALLBACKS     ddSurfaceCallBacks;
    DD_PALETTECALLBACKS     ddPaletteCallBacks;

    GLOBALDATA              *pDriverData; // ->Global data used by DX6 driver.

#ifdef NVD3D
    //********************************************************************************
    // NT5 Specific data.
    //********************************************************************************
    PULONG                  dmaD3DPusherNotifier;
    BOOLEAN                 bDXGblStateInitialized;
#else
    BOOLEAN                 bDDChannelActive;
#endif // #ifdef NVD3D

    //
    // Cached surface pitch and offset for ddraw surfaces. This is for NV4 only, since
    // the NV4 ddraw patch runs in a seperate channel from the GDI driver.
    //
    ULONG   ddSrcOffset;
    ULONG   ddDstOffset;
    ULONG   ddSrcPitch;
    ULONG   ddDstPitch;

#ifdef VPE_NT
    //
    // VPE stuff
    //
    ULONG       ulCaps;
#endif

    PNV_NOTIFIERS               Notifiers;
/*#if (NVARCH < 0x4)
    // BUGBUG - Hack 'o rama, these should be NvNotification structs!
    BYTE                       NvVideoLutCursorDacNotifier[16*9];
    BYTE                       NvSyncNotifierFlat[16*5];
    BYTE                       NvFlipPrimaryNotifierFlat[16*9];
    BYTE                       NvFlipOverlayNotifierFlat[16*5];
    BYTE                       NvFlipVportNotifierFlat[16*5];
    BYTE                       NvDmaToMemNotifierFlat[16*5];
    BYTE                       NvDmaFromMemNotifierFlat[16*5];
    BYTE                        NvScaledImageNotifier[16*5];
    BYTE                        NvPrimary2dNotifier[16*5];
#endif
*/  ULONG                       fourCC[10];
    ULONG                       fNvActiveFloatingContexts;
    ULONG                       CurrentVisibleSurfaceAddress;
    DD_HALINFO                  HALInfo;
//    ULONG                       ddClipUpdate;
    BOOLEAN                     bHwVidOvl;
    ULONG                       dDrawSpareSubchannelObject;
    PVOID                       NvScanlineBufferFlat;
    ULONG                       NvDmaFromMemSurfaceMem;
    ULONG                       bEnableIF09;

    // jsw: global handles for the new architecture
    ULONG                       hClient;
    ULONG                       hDevice;
    ULONG                       hDevClass;
    ULONG                       ulDeviceReference;
#ifdef VPE_NT
    ULONG                       hVPEChannel;
    void*                       pMySurfaces;
#endif
    ULONG                       vppChannelNdx;
    ULONG                       hPioChannel;
    ULONG                       hDmaChannel;
    ULONG                       hFrameBuffer;
    ULONG                       hCursor;
    ULONG                       ulSurfaceAlign;     // hw required surface alignment
    ULONG                       ulSurfaceBitAlign;  // hw required surface alignment in term of bits
    LONG                        cxSurfaceMax;       // maximum surface width in pixels (based upon the current CONTEXT_SURFACES_2D pitch constraint)


#if (_WIN32_WINNT >= 0x0500) && !defined(NV3)
    SURFACEALIGNMENT            AgpHeapAlignment;
    LPVIDEOMEMORY               AgpHeap;
    LONG                        AgpDummyPitch;
    PVOID                       AgpPushBuffer;
    PVOID                       AgpHeapBase;
    BOOLEAN                     bAgp;               // Is AGP supported on this config?

#endif // #if _WIN32_WINNT > 0x0500

    ULONG                       ulEnableDualView;   // WINXP DualView
    ULONG                       ulDualViewSecondary;

    // used by NVHEAP_ macros
    ULONG   VideoHeapTotal;
    ULONG   VideoHeapFree;
    ULONG   cbGdiHeap;

#if _WIN32_WINNT >= 0x0500
    NV_SYSMEM_INFO  SysMemInfo;
    NV_OS_VERSION_INFO OsVersionInfo;
#endif // _WIN32_WINNT >= 0x0500

#ifndef NV3
    USHORT  dwDeviceVersion;
#endif // !NV3

    ULONG ulWorkAroundHwFlag;
    
    // VIRTUAL DESKTOP SUPPORT
        // Display driver needs 1+2*NV_NO_DACS from control panel to set the multi-view
        // 1. cxScreen, cyScreen is the big Virtual Desktop to GDI
        // 2. rclDisplayDesktop is the virtual desktop for each view fram each DAC
        // 3. width and height are calculated from rclCurrentDisplay which is the resolution 
        //    for setting mode for each DAC.  rclCurrentDisplay.top and rclCurrentDisplay.left
        //    are the intial display of each view.

    ULONG   ulDesktopMode;                      // 0x0000 -> Single Monitor
    ULONG   ulDriverNotSupportPanScan;          // Driver does not support Panning and Scanning
    ULONG   ulPuntCursorToGDI;                  // Win2K only punt the cursor back to GDI
    ULONG   ulNumberDacsOnBoard;                // Number of DACs on the board
    ULONG   ulNumberDacsConnected;              // Number of DACs which have a device (CRT/DFP/TV) connected to them
    ULONG   ulNumberDacsActive;                 // Number of DACs which are currently active. For example, in the Normal
                                                // mode, this value will be 1.
    ULONG   ulPrimaryBufferIndex;               // used by ddraw flip
    ULONG   ulDacStatus[NV_NO_DACS];            // The status of each dac (onBoard/connected/Active). Defined in nvMultiMon.h.
    ULONG   ulMoveDisplayDx;                    // Move Delta X to right or left direction
    ULONG   ulMoveDisplayDy;                    // Move Delta Y to up or down direction
    ULONG   ulGDIRefreshRate;                   // Refresh rate of the current mode as requested by GDI.
    ULONG   ulRefreshRate[NV_NO_DACS];          // Refresh rate in Hz for each head.
    RECTL   rclDisplayDesktop[NV_NO_DACS];      // Boundary of desktop;
    RECTL   rclCurrentDisplay[NV_NO_DACS];      // Current display view
    ULONG   ulHeadDisplayOffset[NV_NO_DACS];    // The offset calculated from rclDisplayDesktop (top, left and ppdev->lDelta)
    ULONG   ulFlipBase;                         // Multi buffer switching for 3D rendering
    ULONG   ulDeviceDisplay[NV_NO_DACS];        // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
    ULONG   ulEnableDDC[NV_NO_DACS];            // Enable EDID filtering by the display driver.
    ULONG   ulTimingOverRide[NV_NO_DACS];       // DMT/GTF/AUTO Timing override
    ULONG   ulEnablePanScan[NV_NO_DACS];        // Enable the virtual desktop (pan-scan).
    ULONG   ulFreezePanScan[NV_NO_DACS];        // Freeze the pan-scan.
    ULONG   ulFreezeOriginX[NV_NO_DACS];       // The user specified upper left corner for freezing the pan-scan.
    ULONG   ulFreezeOriginY[NV_NO_DACS];       // The user specified upper left corner for freezing the pan-scan.

    ULONG   ulDeviceMask[NV_NO_DACS];             // The bit mask ID of the device. Part of the new Head API of ResMan.
    ULONG   ulAllDeviceMask;                     // The bit mask for all the output device connectors in the board.
    ULONG   ulConnectedDeviceMask;               // The bit mask for all the currently connected output devices in the system.

    ULONG   ulDeviceType[NV_NO_DACS];           // The type of device connected to the head viz., CRT, TV, FlatPanel
                                                // defined in nvcm.h
    ULONG   ulHeadDeviceOptions[NV_NO_DACS];    // A matrix of possible device options for each head. Defined in nvMultiMon.h.
                                                // This info is used mainly by the NV control panel and gets scanned in after each
                                                // modeset since this matrix can be changed by the RM after a modeset.
                                                // This is a static entity as opposed to ulDeviceType[NV_NO_DACS] which specifies
                                                // the currently selected device type for this head.
    ULONG   ulTVFormat[NV_NO_DACS];             // The TV type: defined in nvcm.h
    ULONG   ulNumPhysModes[NV_NO_DACS];         // number of EDID trimmed, FB size trimmed and PixelClockFrequency trimmed modes
    ULONG   ulNumVirtualModes[NV_NO_DACS];      // number of FB size trimmed and PixelClockFrequency trimmed modes
    MODE_ENTRY *PhysModeList[NV_NO_DACS];       // EDID trimmed, FB size trimmed and PixelClockFrequency trimmed mode list.
    MODE_ENTRY *VirtualModeList[NV_NO_DACS];    // FB size trimmed and PixelClockFrequency trimmed mode list
    
    ULONG   TwinView_State;                     // normal, multi-mon or clone mode. Defined in nvMultiMon.h
    ULONG   TwinView_Orientation;               // horizontal or vertical. Only for multimon. Defined in nvMultiMon.h

    ULONG   ulPrimarySurfaceOffset;

    BOOL    bNVInitDmaCompleted;                // Make sure DMA initialization is completed.
    ULONG   Mobile;                             // Read from the registry. 0: Desktop, 1: Dell laptop, 2: Toshiba laptop.
                                                // NOTE: Display driver should not use this registry key. This will
                                                // be deleted eventually.
    ULONG   UseHWSelectedDevice;                // BIOS devices take precedence over windows devices.
    ULONG   UseHotKeySameMode;                  // On hot key switches, keeps the same desktop mode (resolution,depth).
                                                // This needs PAN_SCAN_SELECTION_ENABLE_ALL to have been turned on.
                                                // This field is obsolete now since no OEM is using this feature curently.
    ULONG   PanScanSelection;                   // absent or 0: pan-scan in only secondary monitor of clone mode: PAN_SCAN_SELECTION_CLONE_SECONDARY_ONLY
                                                // 1: Enable pan-scan in all modes: PAN_SCAN_SELECTION_ENABLE_ALL
                                                // 2: Disable pan-scan in all modes:PAN_SCAN_SELECTION_DISABLE_ALL 
    ULONG   GDIModePruning;                     // Absent or 0: Driver always provides EDID mode pruning protection.
                                                // 1:   For desktop or laptop systems, for CRT, for the
                                                //      standard mode device and the primary device in clone mode and
                                                //      both devices in XP DualView mode, lets the GDI handle EDID 
                                                //      mode pruning via "Hide Modes" monitor checkbox.
                                                // 2:   For desktop systems only, for CRT or DFP, for the
                                                //      standard mode device and the primary device in clone mode and
                                                //      both devices in XP DualView mode, lets the GDI handle EDID 
                                                //      mode pruning via "Hide Modes" monitor checkbox.
                                                //
    ULONG   EnableModesetStopImage;             // Sony specific feature to STOP_IMAGE during modesets and 
                                                // DPMS power on.
    ULONG   ulInduceModeChangeDeviceMask;       // The device mask/masks used by the NVSVC to induce mode change.
    ULONG   ulNVSVCStatus;                      // Started, stopped or paused status of the NVSVC service.
    ULONG   ACPISystem;                         // TRUE if we are on a ACPI system (such as laptops).

    ULONG   ulDFPSupports1400x1050;             // For Toshiba. Export 1400x1050 only on the 14x10 flat panel laptops.
    ULONG   ulDrvAssertModeTRUE;                // 1 if DrvAssertMode(TRUE). 0 if DrvEnableSurface().
    ULONG   ulDefaultTVFormat;                  // The latest and correct BIOS or user specified TV format.
    ULONG   ulDefaultTVDeviceType;              // PAL or NTSC device type based on the ppdev->ulDefaultTVFormat above.
    NVTWINVIEWDATA SaveSettings[NUM_ENTRIES_SAVE_SETTINGS]; // Saved settings for each device combo.
    // VIRTUAL DESKTOP SUPPORT

    ULONG   ulSaveScreenBitsRefCounter;                // is incremented per DrvSaveScreenBits call and used as unique ID.
    struct _LINKEDLISTHEAD *pLinkedListSaveScreenBits; // linked list of data collected in DrvSaveScreenBits

#if defined(_WIN64)
    PVOID fpState;                              // EngSaveFloatingPointState ptr
    ULONG fpStateSize;                          // EngSaveFloatingPointState len
#endif
#ifdef NT4_MULTI_DEV
    struct _MDEV *pmdev;                        // NT4 multiboarddescriptor for fast onedevice access        
#endif
    ULONG ulDriverCompatibilityMode;            // The video card's acceleration level (can be dynamically set through the Display Applet)
                                                // Value Description (W2K DDK):
                                                //     0 All display driver accelerations are permitted. 
                                                //     1 DrvSetPointerShape and DrvCreateDeviceBitmap are disabled. 
                                                //     2 In addition to 1, more sophisticated display driver accelerations are disallowed, including DrvStretchBlt, DrvFillPath, DrvGradientFill, DrvLineTo, DrvAlphaBlend, and DrvTransparentBlt. 
                                                //     3 In addition to 2, all DirectDraw and Direct3D accelerations are disallowed. 
                                                //     4 In addition to 3, almost all display driver accelerations are disallowed, except for solid color fills, DrvCopyBits, DrvTextOut, and DrvStrokePath. DrvEscape is disabled. 
                                                //     5 No hardware accelerations are allowed. The driver will only be called to do bit-block transfers from a system memory surface to the screen. 
    BOOL  bIsSWPointer;                         // NOTE: is true for SW emulated pointers (different to ulPuntCursorToGDI)
} PDEV, *PPDEV;


    // This is defined in the NT5 ddk, but nt4 needs it also
#if _WIN32_WINNT < 0x0500
    // Gamma support ( single head )
    typedef struct _GAMMARAMP
    {
      WORD Red[256];
      WORD Green[256];
      WORD Blue[256];
    }  GAMMARAMP, *PGAMMARAMP;

#endif

    // Gamma support ( multi head )
   typedef struct GAMMARAMP_MULTI
   {
      WORD        wHead; 
      GAMMARAMP   grGammaRamp;
   } GAMMARAMP_MULTI, *PGAMMARAMP_MULTI;


/////////////////////////////////////////////////////////////////////////
// Double Buffer Window Flipping Support

void NV_InitDoubleBufferMode(PDEV *ppdev, LONG NumBuffers, ULONG *MultiBufferOffsets);
void NV_DisableDoubleBufferMode(PDEV *ppdev);

/////////////////////////////////////////////////////////////////////////
// nv4hw.c export prototypes:

VOID NV4_DdPioSync(PDEV *ppdev);

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL __fastcall bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*, POINTL*, RECTL*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

void __cdecl NvSetDacImageOffset(PDEV* ppdev, ULONG ulDac, ULONG ulOffset);
BOOL __cdecl NvSetDac(PDEV *ppdev, ULONG ulHead, RESOLUTION_INFO * pResolution);
void __cdecl DisableHeadCursor(PDEV *ppdev, ULONG ulHead, ULONG ulDiable);
BOOL NvInitialDac(PDEV *ppdev);
VOID NvRestoreDacs(PDEV *ppdev);
VOID NvCreateObject(PDEV *, BOOL, PVOID, NvU32, NvU32 *, NvU32 *, int, NvU32 *);
BOOL NvGetSupportedClasses(PDEV *);

BOOL AllocDmaPushBuf(PDEV *ppdev);
VOID FreeDmaPushBuf(PDEV *ppdev);

BOOL AllocMemOncePerPdev(PDEV * ppdev);
VOID FreeMemOncePerPdev(PDEV * ppdev);

BOOL NvSetupContextDma(PDEV * ppdev);
VOID NvFreeContextDma(PDEV * ppdev);

BOOL NvSetupHwObjects(PDEV * ppdev);            
BOOL NvInitHwObjects(PDEV * ppdev);

ULONG OglSupportEnabled(PDEV *ppdev);
NV_OPENGL_CLIENT_INFO *OglFindClientInfoHWnd(PDEV *ppdev, HWND hWnd);
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWnd(PDEV *ppdev, HWND hWnd);

#if defined(_WIN64)
ULONG DrvEscape32(SURFOBJ *pso, ULONG iEsc,
                  ULONG cjIn, VOID *pvIn,
                  ULONG cjOut, VOID *pvOut);

VOID NvCopyStructIn (VOID *ptr32, VOID *ptr64, CHAR *fmt);
VOID NvCopyStructOut(VOID *ptr32, VOID *ptr64, CHAR *fmt);
#endif

extern BYTE gajHwMixFromMix[];
extern BYTE gaRop3FromMix[];
extern ULONG gaulHwMixFromRop2[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(_X86_)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

/////////////////////////////////////////////////////////////////////////
// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// CONVERT_TO_BYTES - Converts to byte count.

#define CONVERT_TO_BYTES(x, pdev)   ( (x) * pdev->cjPelSize)

//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// CONVERT_FROM_BYTES - Converts to byte count.

#define CONVERT_FROM_BYTES(x, pdev) ( (x) / pdev->cjPelSize)

/////////////////////////////////////////////////////////////////////////
// Macro to determine if SURFOBJ is on primary screen
#define IS_SCREEN(pso)           (STYPE_DEVICE == pso->iType)
// Macro to determine if SURFOBJ any kind of devicebitmap
#define IS_DEVICEBITMAP(pso)     (STYPE_DEVBITMAP == pso->iType)
// Macro to determine if SURFOBJ a devicebitmap in device memory
#define IS_DEV_DEVICEBITMAP(pso) (IS_DEVICEBITMAP(pso) && (((DSURF *)pso->dhsurf)->dt == DT_SCREEN))
// Macro to determine if SURFOBJ a devicebitmap in host memory
#define IS_DIB_DEVICEBITMAP(pso) (IS_DEVICEBITMAP(pso) && (((DSURF *)pso->dhsurf)->dt == DT_DIB))
/////////////////////////////////////////////////////////////////////////
// Macro to determine if SURFOBJ is in framebuffer (device memory)
// NT4 doesn't have BMF_NOTSYSMEM or DrvDeriveSurface
#if _WIN32_WINNT >= 0x0500
#define IS_DEV_SURF(pso)   \
        (  IS_SCREEN(pso)  \
        || IS_DEV_DEVICEBITMAP(pso) \
        || (pso->fjBitmap & BMF_NOTSYSMEM) )
#else
#define IS_DEV_SURF(pso)   \
        (  IS_SCREEN(pso)  \
        || IS_DEV_DEVICEBITMAP(pso) )
#endif

/////////////////////////////////////////////////////////////////////////
// Macros used to access NV PRM regs.

#define PRMVIO_Base ppdev->PRMVIORegs
#define PRMCIO_Base ((PBYTE) (ppdev->PRMCIORegs))


//////////////////////////////////////////////////////////////////////

// These Mul prototypes are thunks for multi-board support:

ULONG   MulGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  MulEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    MulCompletePDEV(DHPDEV, HDEV);
HSURF   MulEnableSurface(DHPDEV);
BOOL    MulStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    MulFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    MulBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    MulDisablePDEV(DHPDEV);
VOID    MulDisableSurface(DHPDEV);
BOOL    MulAssertMode(DHPDEV, BOOL);
VOID    MulMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   MulSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   MulDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    MulSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    MulCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    MulTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    MulDestroyFont(FONTOBJ*);
BOOL    MulPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    MulRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP MulCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    MulDeleteDeviceBitmap(DHSURF);
BOOL    MulStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);

// These Dbg prototypes are thunks for debugging:

ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);

VOID    DbgCompletePDEV(DHPDEV, HDEV);
VOID    DbgSynchronize(DHPDEV, RECTL *);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgLineTo(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, LONG, LONG, LONG, LONG,
                  RECTL*, MIX);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
BOOL    DbgAlphaBlend(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*,
                      RECTL*, BLENDOBJ*); 
BOOL    DbgTransparentBlt(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, RECTL*, ULONG, ULONG);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);

BOOL    DbgAssertMode(DHPDEV, BOOL);

VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
ULONG   DbgEscape(SURFOBJ*, ULONG, ULONG, VOID*, ULONG, VOID*);
ULONG   DbgDrawEscape (SURFOBJ*, ULONG, CLIPOBJ*, RECTL*, ULONG, VOID*);
BOOL    DbgResetPDEV(DHPDEV, DHPDEV);

VOID NV3_SetSourceBase(PDEV *,ULONG,LONG);
VOID NV3_SetDestBase(PDEV *,ULONG,LONG);

VOID NvDDEnable(PDEV *ppdev);
NvU8 bCreateNVDDPatch(PDEV *ppdev);
NvU8 bDestroyNVDDPatch(PDEV *ppdev);

BOOL    DbgGetDirectDrawInfo(DHPDEV, DD_HALINFO*, DWORD*, VIDEOMEMORY*,
                             DWORD*, DWORD*);
BOOL    DbgEnableDirectDraw(DHPDEV, DD_CALLBACKS*, DD_SURFACECALLBACKS*,
                            DD_PALETTECALLBACKS*);
VOID    DbgDisableDirectDraw(DHPDEV);

#if _WIN32_WINNT >= 0x0500
BOOL    DbgIcmSetDeviceGammaRamp(DHPDEV,ULONG,LPVOID);
HBITMAP DbgDeriveSurface(DD_DIRECTDRAW_GLOBAL *, DD_SURFACE_LOCAL *);
void    DbgDrvNotify(SURFOBJ *, ULONG, PVOID);

#endif

#if DBG
    VOID    vAcquireCrtc(PDEV*);
    VOID    vReleaseCrtc(PDEV*);

    #define ACQUIRE_CRTC_CRITICAL_SECTION(ppdev)    vAcquireCrtc(ppdev)
    #define RELEASE_CRTC_CRITICAL_SECTION(ppdev)    vReleaseCrtc(ppdev)

#else

    /////////////////////////////////////////////////////////////////////////
    // Free Build
    //
    // For a free (non-debug build), we make everything in-line.

    // Safe port access macros -- these macros automatically do memory
    // -----------------------    barriers, so you don't have to worry
    //                            about them:

    // The CRTC register critical section must be acquired before
    // touching the CRTC register (because of async pointers):


    #define ACQUIRE_CRTC_CRITICAL_SECTION(ppdev)                \
        EngAcquireSemaphore(ppdev->csCrtc);

    #define RELEASE_CRTC_CRITICAL_SECTION(ppdev)                \
    {                                                           \
        EngReleaseSemaphore(ppdev->csCrtc);                     \
    }

#endif

//
// macro to access the hwGfxCaps which is initialized with NvConfigGet(..NV_CFG_GRAPHICS_CAPS..) (look nvcm.h)
//
#define HWGFXCAPS_MAXCLIPS(ppdev)       ((ppdev->hwGfxCaps >> NV_CFG_GRAPHICS_CAPS_MAXCLIPS_SHIFT) & NV_CFG_GRAPHICS_CAPS_MAXCLIPS_MASK)
#define HWGFXCAPS_QUADRO_GENERIC(ppdev) (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)
#define HWGFXCAPS_UBB(ppdev)            (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_UBB)


/*******************************************************************************
 *
 *    Useful information for OpenGL support.  Not guaranteed to work.
 *
 *******************************************************************************/


#define     OPENGL_CMD              4352
#define     OPENGL_GETINFO          4353
#define     NV_OPENGL_SET_ENABLE    0x6988
#define     OPENGL_GETINFO_DRVNAME  0

#define     OPENGL_ICD_VER          2
#define     OPENGL_DRIVER_VER       0x10000
#define     OPENGL_KEY_NAME_NV3     L"RIVA128"
#define     OPENGL_KEY_NAME_NV4     L"RIVATNT"

#define     ESC_ALLOC_CONTEXT_DMA                   0x6989
#define     ESC_FREE_CONTEXT_DMA                    0x698A
#define     ESC_ALLOC_CHANNEL_DMA                   0x698B
#define     ESC_FREE_CHANNEL_DMA                    0x698C
#define     ESC_DMA_FLOW_CONTROL                    0x698D
#define     ESC_SET_GAMMA_RAMP                      0x698E
#define     ESC_GET_GAMMA_RAMP                      0x698F
#define     ESC_SET_GAMMA_RAMP_MULTI                0x6990
#define     ESC_GET_GAMMA_RAMP_MULTI                0x6991
#define     ESC_GET_PIXEL_FORMAT                    0x7000
#define     ESC_NV_OPENGL_DMA_PUSH_GO               0x7001

#define DDI_VER_40 0x00020000

#define NV_DMA_SCANLINE_BUF_SIZE 32768

#ifndef NVD3D_DX6 // D3D driver conflicts
//*******************************************************************************
// Macros used to access NV registers.
//*******************************************************************************
#define REG_WR32(a,d)   ppdev->NvBaseAddr[(a)/4]=(U032)(d)
#define REG_RD32(a)     ppdev->NvBaseAddr[(a)/4]
#define REG_WR08(a,d)   ((V008 *)(ppdev->NvBaseAddr))[(a)]  =(U008)(d)
#define REG_RD08(a)     ((V008 *)(ppdev->NvBaseAddr))[(a)]

#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d) - DEVICE_BASE(d) + 1
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#endif // #ifndef NVD3D_DX6

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\escape32.c ===
//***************************** Module Header **********************************
//
// Module Name: escape.c
//
// Escape handler for the 64 bit driver for 32 bit clients
//
// Copyright (c) 1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#if defined(_WIN64)

#include "driver.h"
#include "nvReg.h"
#include "oglDD.h"
#include "pixelfmt.h"

//******************************************************************************
//
//  Function:   DrvEscape32(SURFOBJ *, ULONG, ULONG, VOID *, ULONG cjOut, VOID *pvOut)
//
//  Routine Description:
//
//      Driver escape entry point.  This function should return TRUE for any
//      supported escapes in response to QUERYESCSUPPORT, and FALSE for any
//      others.  All supported escapes are called from this routine.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

static ULONG DoOpenGLEscapeCommand32(PPDEV ppdev, PVOID in, PVOID out);

ULONG DrvEscape32(SURFOBJ *pso, ULONG iEsc,
                  ULONG cjIn, VOID *pvIn,
                  ULONG cjOut, VOID *pvOut)

{
    PDEV    *ppdev = (PDEV *)pso->dhpdev;

    switch(iEsc)
    {
    case NV_ESC_PRIMARY_INFO:
        {
        NV_PRIMARY_INFO32 *primaryInfoIn = (NV_PRIMARY_INFO32 *)pvIn;
        NV_PRIMARY_INFO32 *primaryInfoOut = (NV_PRIMARY_INFO32 *)pvOut;
        LONG status;
        unsigned int numActiveDACs, dacMask, activeDACs, d;

        try
            {
            if (primaryInfoIn && primaryInfoOut && primaryInfoIn->ulNVSignature == NV_SIGNATURE)
                {
                primaryInfoOut->ulWidth         = ppdev->cxScreen;
                primaryInfoOut->ulHeight        = ppdev->cyScreen;
                primaryInfoOut->ulDepth         = ppdev->cjPelSize << 3;
                primaryInfoOut->ulPitch         = ppdev->lDelta;
                primaryInfoOut->ulPrimaryOffset = ppdev->ulPrimarySurfaceOffset;
                primaryInfoOut->ulNumDACs       = ppdev->ulNumberDacsOnBoard;
                primaryInfoOut->ulNumActiveDACs = ppdev->ulNumberDacsActive;
                primaryInfoOut->ulPanningPtr    = NULL;
                primaryInfoOut->ulReturnCode    = TRUE;

                // Compute a bitmap of active DACs by looping over all displays
                // until we've checked them all, or found ulNumberDacsActive
                // unique DACs--whichever comes first.
                for (d = activeDACs = numActiveDACs = 0; (d < NV_NO_DACS) &&
                     (numActiveDACs < ppdev->ulNumberDacsActive); d++)
                    {
                    if (ppdev->ulDeviceDisplay[d] < NV_NO_DACS)
                        {
                        dacMask = 1 << ppdev->ulDeviceDisplay[d];
                        if (!(dacMask & activeDACs))
                            {
                            numActiveDACs++;
                            activeDACs |= dacMask;
                            }
                        }
                    }
                primaryInfoOut->ulActiveDACs = activeDACs;
                }
            else
                {
                return (ULONG)FALSE;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
            status = GetExceptionCode();
            DISPDBG((1, "NV_ESC_PRIMARY_INFO: exception = 0x%lx", status));
            return (ULONG)FALSE;
            }
        }
        return (ULONG)TRUE;
        break;
    case ESC_NV_OPENGL_ESCAPE:
        {
        return((ULONG)DoOpenGLEscapeCommand32(ppdev, (PVOID)pvIn, (PVOID)pvOut));
        }
        break;
    case ESC_NV_QUERYSET_REGISTRY_KEY:
        {
            __PNVRegKeyInfo32 inParms, outParms;
            WCHAR tmpStrBuf[NV_MAX_REG_KEYNAME_LEN];
            ULONG  inpStrLen, outStrLen;
            ULONG ii, returnedDataLen;
            NV_REGISTRY_STRUCT regStruct;
            NV_REGISTRY_STRUCT regStructInput, regStructOutput;
            DWORD retStatus;
            

            inParms = (__PNVRegKeyInfo32) pvIn;


            if (!inParms->keyName)
                return (FALSE);

            inpStrLen = strlen(inParms->keyName);

            if ((inpStrLen+1) > NV_MAX_REG_KEYNAME_LEN)
                return (FALSE);
            /*
            for (ii = 0; ii < inpStrLen; ii++)
                tmpStrBuf[ii] = inParms->keyName[ii];
            tmpStrBuf[ii] = 0;
            */

            EngMultiByteToUnicodeN((LPWSTR)tmpStrBuf, NV_MAX_REG_KEYNAME_LEN*sizeof(WCHAR), &outStrLen,
                                   inParms->keyName, (inpStrLen+1)*sizeof(CHAR));



            switch(inParms->type)
            {
            case NV_QUERY_REGISTRY_BINARY_KEY:
                outParms = (__PNVRegKeyInfo32) pvOut;
                *outParms = *inParms;

                regStructInput.keyName = (PWSTR)tmpStrBuf;
                regStructInput.keyVal = outParms->keyVal;
                regStructInput.keyValSize = outParms->keyValMaxSize;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                               (LPVOID)&regStructInput,
                               sizeof(NV_REGISTRY_STRUCT),
                               (LPVOID) (&regStructOutput),
                               sizeof(NV_REGISTRY_STRUCT),
                               &(returnedDataLen));

                outParms = (__PNVRegKeyInfo32) pvOut;

                outParms->retStatus = retStatus;

                // Copy the returned registry value size into outParams
                outParms->keyValSize = regStructOutput.keyValSize;
                // The KeyVal has already been copied by the miniport

                break;

            case NV_QUERY_REGISTRY_KEY:

                outParms = (__PNVRegKeyInfo32) pvOut;
                *outParms = *inParms;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                               (LPVOID)tmpStrBuf,
                               outStrLen,
                               (LPVOID) (outParms->keyVal),
                               outParms->keyValMaxSize,
                               &(outParms->keyValSize));

                outParms->retStatus = retStatus;

                break;

            case NV_SET_REGISTRY_KEY:

                outParms = (__PNVRegKeyInfo32) pvOut;
                *outParms = *inParms;

                regStruct.keyName = (PWSTR)tmpStrBuf;
                regStruct.keyVal = inParms->keyVal;
                regStruct.keyValSize = inParms->keyValSize;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_REGISTRY_VALUE,
                               (LPVOID)(&regStruct),
                               sizeof(NV_REGISTRY_STRUCT),
                               (LPVOID) NULL,
                               0,
                               &returnedDataLen);

                outParms->retStatus = retStatus;

                break;

            default:
                break;
            }
            return (TRUE);
        }
        break;
    default:
        break;
    }

    return (ULONG)FALSE;
}

static ULONG DoOpenGLEscapeCommand32(PPDEV ppdev, PVOID pvIn, PVOID pvOut)
{
    NV_OPENGL_COMMAND32 *inCommand;
    LONG                status;
    ULONG               ulRet = FALSE;

    ASSERT(ppdev);

    inCommand = (NV_OPENGL_COMMAND32 *)pvIn;
    try
        {
        ppdev->numDevices = inCommand->numDevices;
        }
    except(EXCEPTION_EXECUTE_HANDLER)
        {
        status = GetExceptionCode();
        DISPDBG((1, "DoOpenGLEscapeCommand32: exception = 0x%lx", status));
        return(1 + (ULONG)FALSE);
        }
    switch(inCommand->command)
    {
    case ESC_NV_OPENGL_SHARED_LIBRARY_SIZES:
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_SUPPORT:
        if (OglSupportEnabled(ppdev) == (ULONG)TRUE)
        {
            if (inCommand->NVSignature == NV_SIGNATURE)
            {
                ulRet = ((ULONG)TRUE);
                break;
            }
            else
            {
                ulRet = ((ULONG)FALSE);
                break;
            }
         }
         ulRet = ((ULONG)FALSE);
         break;
    case ESC_NV_OPENGL_REGISTER_RM_CLIENT:
        OglAcquireGlobalMutex();
        OglRegisterRmClient(ppdev, (ULONG)(inCommand->other));
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_UNREGISTER_RM_CLIENT:
        OglAcquireGlobalMutex();
        OglUnRegisterRmClient(ppdev, (ULONG)(inCommand->other));
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_DESTROY_DRAWABLE:
        OglAcquireGlobalMutex();
        DestroyDrawableClientInfo(ppdev, inCommand->hWnd, inCommand->hDC, TRUE);
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_START_STATE_CLIENT_TRACKING:
        OglAcquireGlobalMutex();
        ulRet = CreateContextClientInfo(ppdev, inCommand->hWnd, inCommand->hClient);
        OglReleaseGlobalMutex();
        break;
    case ESC_NV_OPENGL_STOP_STATE_CLIENT_TRACKING:
        OglAcquireGlobalMutex();
        DestroyContextClientInfo(ppdev, inCommand->hClient, TRUE);
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_ALLOC_SHARED_MEMORY:
         {
            void *globalData, *pfifoAddress, *pbusAddress;
            void * __ptr32 * outPtr = (void * __ptr32 *)pvOut;

            OglAcquireGlobalMutex();
            CreateSharedClientInfo(ppdev, inCommand->hClient, inCommand->processHandle, &globalData, &pfifoAddress, &pbusAddress);
            outPtr[0] = (void * __ptr32)globalData;
            outPtr[1] = (void * __ptr32)pfifoAddress;
            outPtr[2] = (void * __ptr32)pbusAddress;
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
        }
        break;
    case ESC_NV_OPENGL_FREE_SHARED_MEMORY:
        OglAcquireGlobalMutex();
        DestroySharedClientInfo(ppdev, inCommand->hClient, inCommand->processHandle, inCommand->globalData, TRUE);
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_INIT_STATE:
        ppdev->oglSyncGdi       = 0;
        ulRet = ((ULONG)TRUE);
        break;
    // this is used by W2K in DrvDescribePixelFormat
    case ESC_NV_OPENGL_PFD_CHECK:
    {
        ULONG *pulPfdCheckFlags = pvOut;           
        *pulPfdCheckFlags = 0;

        ulRet = bOglPfdCheckFlags(ppdev, pulPfdCheckFlags) ? 1 : (ULONG)-1;
        break;
    }
     case ESC_NV_OPENGL_PURGE_DEVICE_BITMAP:
        ((ULONG *)pvOut)[0] = (ULONG)0; // means nothing got punted
        if (ppdev->cbGdiHeap)   // contains #bytes allocated by GDI
        {
            bMoveAllDfbsFromOffscreenToDibs(ppdev);
            ((ULONG *)pvOut)[0] = (ULONG)1; // means something got punted
        }
        ulRet = (ULONG) TRUE;
        break;
     case ESC_NV_OPENGL_FLUSH:
        {
            __GLNVflushInfo flushInfo;
            __GLNVcmdInfo cmdInfo;

            NvCopyStructIn(inCommand->other, &flushInfo, "IPPIP[IIII]IIIIi");
            NvCopyStructIn(flushInfo.cmdInfo, &cmdInfo, "PIIPPIIICIIIIIIIIIII");
            flushInfo.cmdInfo = &cmdInfo;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV_OglFlushClipped(ppdev,
                                       inCommand->hWnd,
                                       inCommand->hDC,
                                       flushInfo.hClient,
                                       &flushInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            NvCopyStructOut(inCommand->other, &flushInfo, "ippip[iiii]iiiiI");
        }
        break;
    case ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES:
        OglAllocUnifiedSurfaces(ppdev, inCommand->other);
        ulRet = (ppdev->bOglSingleBackDepthSupported &&
                 ppdev->bOglSingleBackDepthCreated);
        break;
    case ESC_NV_OPENGL_FREE_UNIFIED_SURFACES:
        OglFreeUnifiedSurfaces(ppdev);
        ulRet = (ppdev->bOglSingleBackDepthSupported &&
                 !ppdev->bOglSingleBackDepthCreated);
        break;
    case ESC_NV_OPENGL_GET_SURFACE_INFO:
        {
            NvU32 fbInfo;
            ULONG *outPtr = (ULONG *)pvOut;
                
            fbInfo = OglGetUnifiedSurfaceInfo(ppdev, inCommand->other);
            try
            {
                *outPtr = (ULONG)fbInfo;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_SURFACE_INFO: ppdev: exception = 0x%lx", status));
            }
            if (fbInfo)
            {
                ulRet = ((ULONG)TRUE);
            }
            else
            {
                ulRet = ((ULONG)FALSE);
            }
        }
        break;
    case ESC_NV_OPENGL_GET_CLIP_LIST_COUNT:
        {
            ULONG *outPtr = (ULONG *)pvOut;
            try
            {
                NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                {
                    clientInfo = &clientList->clientInfo;
                }
                if (clientInfo)
                {
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

                    clientDrawableInfo = clientInfo->clientDrawableInfo;
                    *outPtr = clientDrawableInfo->numClipRects;
                }
                else
                {
                    *outPtr = -1; // client not found
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_CLIP_LIST_COUNT: ppdev: exception = 0x%lx", status));
                }
            ulRet = ((ULONG)TRUE);
        }
        break;
    case ESC_NV_OPENGL_GET_CLIP_LIST:
        {
            ULONG *outPtr = (ULONG *)pvOut;
            try
            {
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                {
                    NV_OPENGL_CLIP_LIST_DATA32 *nvClipList;
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;
                    int       i, rgnDataSize;
                    LPRGNDATA rgnData = NULL;
                    RECTL     *rectList = NULL, *rect = NULL;
                    static RECTL nullRect = { 0,0,0,0 };

                    clientDrawableInfo = clientList->clientInfo.clientDrawableInfo;
                    nvClipList = (NV_OPENGL_CLIP_LIST_DATA32 *)inCommand->other;

                    rect        = (RECTL *)nvClipList->rect; // bounds rectangle
                    rgnDataSize = sizeof(RGNDATAHEADER) + (clientDrawableInfo->numClipRects * sizeof(RECT));
                    rgnData     = (LPRGNDATA)nvClipList->rgnData;

                    if (rgnDataSize > nvClipList->rgnDataSize)
                    {
                        *outPtr = rgnDataSize;  // Insufficient space--return space needed.
                    }
                    else
                    {
                        rgnDataSize           = nvClipList->rgnDataSize;
                        rgnData->rdh.dwSize   = sizeof(RGNDATAHEADER);
                        rgnData->rdh.iType    = RDH_RECTANGLES;
                        rgnData->rdh.nCount   = clientDrawableInfo->numClipRects;
                        rgnData->rdh.nRgnSize = rgnDataSize;

                        rgnData->rdh.rcBound = clientDrawableInfo->rect;
                        rectList = (RECTL *)&rgnData->rdh.rcBound;
                        if (rectList->left >= rectList->right ||
                            rectList->top  >= rectList->bottom)
                       {
                            // NULL clip list
                            rgnData->rdh.nCount = 0;
                            *rectList = nullRect; // rgnData->rdh.rcBound set to NULL rectangle
                       }

                        rectList = (RECTL *)&rgnData->Buffer;
                        if ((int)rgnData->rdh.nCount <= 0)
                        {
                            rectList[0] = nullRect;
                        }
                        else
                        {
                            for (i = 0; i < (int)rgnData->rdh.nCount; i++)
                            {
                                rectList[i] = clientDrawableInfo->copyWindowRect[i];
                                if (rectList[i].left >= rectList[i].right ||
                                    rectList[i].top  >= rectList[i].bottom)
                                {
                                    rectList[i] = nullRect;
                                }
                            }
                        }

                        nvClipList->clipChangedCount = clientDrawableInfo->clipChangedCount;
                        *outPtr = 1;
                    }
                }
                else
                {
                    *outPtr = -1; // client not found
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_CLIP_LIST: ppdev: exception = 0x%lx", status));
            }
            ulRet = ((ULONG)TRUE);
        }
        break;
    default:
        ulRet = ((ULONG)FALSE);
        break;
    }

    return(ulRet + 1);
    // Offset the return value by +1 so that the ESC_NV_OPENGL_ESCAPE escape
    // handler always returns >0, so a zero return from ExtEscape() will
    // indicate a "hard" GDI error.
}

VOID NvCopyStructIn(VOID *ptr32, VOID *ptr64, CHAR *fmt)
{
    char f;

    while ((f = *fmt++) != '\0') {
        switch(f) {
        case 'c':
            ((char *)ptr32)++;
            ((char *)ptr64)++;
            break;
        case 'C':
            *((char *)ptr64)++ = *((char *)ptr32)++;
            break;
        case 's':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x1) & ~0x1);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x1) & ~0x1);
            ((short *)ptr32)++;
            ((short *)ptr64)++;
            break;
        case 'S':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x1) & ~0x1);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x1) & ~0x1);
            *((short *)ptr64)++ = *((short *)ptr32)++;
            break;
        case 'i':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x3) & ~0x3);
            ((int *)ptr32)++;
            ((int *)ptr64)++;
            break;
        case 'I':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x3) & ~0x3);
            *((int *)ptr64)++ = *((int *)ptr32)++;
            break;
        case 'p':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x7) & ~0x7);
            ((void * __ptr32 *)ptr32)++;
            ((void **)ptr64)++;
            break;
        case 'P':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x7) & ~0x7);
            *((void **)ptr64)++ = *((void * __ptr32 *)ptr32)++;
            break;
        case '{':
        case '}':
            break;
        }
    }
}

VOID NvCopyStructOut(VOID *ptr32, VOID *ptr64, CHAR *fmt)
{
    char f;

    while ((f = *fmt++) != '\0') {
        switch(f) {
        case 'c':
            ((char *)ptr32)++;
            ((char *)ptr64)++;
            break;
        case 'C':
            *((char *)ptr32)++ = *((char *)ptr64)++;
            break;
        case 's':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x1) & ~0x1);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x1) & ~0x1);
            ((short *)ptr32)++;
            ((short *)ptr64)++;
            break;
        case 'S':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x1) & ~0x1);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x1) & ~0x1);
            *((short *)ptr32)++ = *((short *)ptr64)++;
            break;
        case 'i':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x3) & ~0x3);
            ((int *)ptr32)++;
            ((int *)ptr64)++;
            break;
        case 'I':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x3) & ~0x3);
            *((int *)ptr32)++ = *((int *)ptr64)++;
            break;
        case 'p':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x7) & ~0x7);
            ((void **)ptr64)++;
            ((void * __ptr32 *)ptr32)++;
            break;
        case 'P':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x7) & ~0x7);
            *((void * __ptr32 *)ptr32)++ = (void * __ptr32)*((void **)ptr64)++;
            break;
        case '{':
        case '}':
            break;
        }
    }
}
#endif // defined(_WIN64)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\lines.h ===
/******************************Module*Header***********************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1996 Microsoft Corporation
\******************************************************************************/

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

// The clipping hardware coordinates are limited to 16-bit unsigned values:

#define MIN_INTEGER_BOUND (0)
#define MAX_INTEGER_BOUND (65535)

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);
extern PFNSTRIP gapfnStrip[];

// Strip drawers:

VOID vssSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vStripStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\escape.c ===
//***************************** Module Header **********************************
//
// Module Name: escape.c
//
// Escape handler for drivers and other escapes.
//
// Copyright (c) 1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#include "nv32.h"
#include "nvos.h"
#include "nvntioctl.h"
//#include "nvntddctl.h"
//#include "nvosnt.h"
#include "nvsubch.h"
#include "nvapi.h"
#include "nvReg.h"
#if (NVARCH >= 0x4)
#if _WIN32_WINNT >= 0x0500
#include "nvPriv.h"
#endif
#endif

#include "wksappsupport.h"

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"
#include "nvapi.h"

#include "oglDD.h"
#include "oglOverlay.h"
#include "oglsync.h"
#ifdef NV_MAIN_MULTIMON
#include "oglutils.h"
#endif
#include "pixelfmt.h"

// To get the NV11 twinview definitions
#include "escape.h"
#include "nvcm.h"
extern BOOLEAN   TwinViewDataOK(PPDEV ppdev, NVTWINVIEWDATA *pData);
extern void PrintTwinViewData (char *Msg, ULONG ulDebugLevel, NVTWINVIEWDATA *pData, PPDEV ppdev);
extern BOOLEAN bGetPhysicalVirtualModeList(PPDEV ppdev, ULONG Head, ULONG DeviceMask, ULONG DeviceType, ULONG TVFormat,
        MODE_ENTRY *PhysModeList, MODE_ENTRY *VirtModeList, ULONG *NumPhysModes, ULONG *NumVirtModes);
extern void InduceAndUpdateDeviceScanning (PPDEV ppdev);

extern void   ProcessSynchronousFlags(PPDEV ppdev, NVTWINVIEWDATA *pData);
extern VOID WriteRegistryTwinViewInfo (PPDEV ppdev, NVTWINVIEWDATA *pData);

extern VOID SetInduceRegValue(PPDEV ppdev, ULONG ulVal);
extern NVTWINVIEWDATA * pFindSaveSettings(PPDEV ppdev, QUERY_SAVE_SETTINGS * pQuery, NVTWINVIEWDATA * pTwinViewData);
extern VOID vWriteSaveSettings(PPDEV ppdev);
BOOLEAN bHandleNT4HotKey(PPDEV ppdev, GET_DEVICE_MASK_DATA_TYPE *pInfo);

#if 0 // defined in common\win9x\inc\escape.h
// - Added escapes for output device set/get
#define NV_ESC_SET_DISPLAY_DEVICE_TYPE  0x6E84
#define NV_ESC_GET_DISPLAY_DEVICE_TYPE  0x6E85
// - Added to provide the path to the driver reg area (hard coded under winnt4)
#define NV_ESC_GET_LOCAL_REGISTRY_PATH      0x6E7F
// - Added to provide id of the board and type
#define NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER   0x6E80
// - Added escape to validate a mode for a device
#define NV_ESC_VALIDATE_DEVICE_MODE         0x6E83
// - From nvVer.h, the escape value for driver verification
#endif
#define NV_ESCAPE_ID                'nv'
#define NV_ESCAPE_ID_RETURN         0x3031564E  // "NV10"


#if 0
//
// Since we are including escape.h now, we don't need to define the structure here. Otherwise we get a redefinition error.
//

// - Data struct for NV_ESC_SET_DISPLAY_DEVICE_TYPE / NV_ESC_GET_DISPLAY_DEVICE_TYPE
typedef struct  tagSETGETDEVTYPE
{
    unsigned long   dwSuccessFlag;
    unsigned long   dwDeviceType;
    unsigned long   dwTvFormat;
} SETGETDEVTYPE, *PSETGETDEVTYPE;
#else
typedef SETGETDEVTYPE *PSETGETDEVTYPE;
#endif // 0



// - Data struct for NV_ESC_VALIDATE_DEVICE_MODE
typedef struct  tagVALMODEEXTR
{
    unsigned long   dwHRes;
    unsigned long   dwVRes;
    unsigned long   dwBpp;
    unsigned long   dwRefresh;
    unsigned long   dwDeviceType;
} VALMODEXTR;

// - Added function protos for support functions added
BOOL  nvSetDisplayDevice(PDEV *ppdev, PSETGETDEVTYPE pvIn);
BOOL  nvGetDisplayDevice(PDEV *ppdev, PSETGETDEVTYPE pvIn);
BOOL  __cdecl nvDoValidateDeviceModeEsc(PDEV *ppdev, VALMODEXTR *pvIn, DWORD *pvOut);
BOOL  nvGetDisplayDeviceClass(PDEV *ppdev, ULONG *deviceclass);


//
// Before calling RM IOCTL routines use csFifo mutex.  This is also
// used before kicking off push buffers.  This should remove any chance
// that a software interrupt can get into the resource manager at the
// same time as a user IOCTL on MP systems.
//
#define NVDMAPUSHMODESWITCHCOUNT 0x6986

#define CHECK_PDEV_NULL(_STR) \
    if (ppdev == NULL || pvIn == NULL || pvOut == NULL) \
        { \
        DISPDBG((0, "DrvEscape - %s NULL error!", _STR)); \
        return(FALSE); \
        }
#define CHECK_IN_OUT_SIZE(_STR, _INSIZE, _OUTSIZE) \
    if (_INSIZE != cjIn) \
        { \
        DISPDBG((0, "DrvEscape - %s input size error! needed:%d != cjIn:%d", _STR, _INSIZE, cjIn)); \
        return(FALSE); \
        } \
    if (_OUTSIZE != cjOut) \
        { \
        DISPDBG((0, "DrvEscape - %s output size error! needed:%d != cjOut:%d ", _STR, _OUTSIZE, cjOut)); \
        return(FALSE); \
        }

#define OGL_ESCAPE_FAIL_TEST(_PPDEV) ((_PPDEV)->oglMutexPtr == NULL)

static ULONG DoOpenGLEscapeCommand(PPDEV ppdev, PVOID in, PVOID out);

#ifdef NV3
// WARNING: This structure is defined in the client side.
// Don't change it without changing the OpenGL clients too.
typedef struct Nv3DmaPushInfo {
    DWORD dwChID;
    DWORD dwTlbPtBase;
    DWORD dwAddressSpace;
    DWORD get;
    DWORD put;
    DWORD localModeSwitchCount;
    DWORD hClient;
    DWORD hDevice;
} Nv3DmaPushInfo;

extern ULONG NV3_DmaPushGo(PDEV *ppdev, ULONG chID, ULONG tlbPtBase, ULONG busAddressSpace, ULONG getOffset, ULONG putOffset, ULONG hClient, ULONG hDevice);
#endif

static ULONG OglCheckForClientDll(PDEV *ppdev);

//******************************************************************************
//
//  Function:   DrvEscape(SURFOBJ *, ULONG, ULONG, VOID *, ULONG cjOut, VOID *pvOut)
//
//  Routine Description:
//
//      Driver escape entry point.  This function should return TRUE for any
//      supported escapes in response to QUERYESCSUPPORT, and FALSE for any
//      others.  All supported escapes are called from this routine.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


ULONG DrvEscape(SURFOBJ *pso, ULONG iEsc,
                ULONG cjIn, VOID *pvIn,
                ULONG cjOut, VOID *pvOut)

    {
    ULONG   retVal;
    ULONG   oglSupported;
    ULONG   returnedDataLength;
    ULONG   cbReturned;
    PDEV    *ppdev = (PDEV *)pso->dhpdev;

#ifdef _WIN32_WINNT // >= NT 4.x

    //**************************************************************************
    //
    // On 64 bit systems, the following switch statement is for escape codes
    // that are handled identically on both 32 and 64 bit clients.
    // This primarily means the RM calls where the incoming parameter
    // structure is deliberately sized the same for both models.
    //
    // When in doubt, add new escapes to the second switch statement below.
    //
    //**************************************************************************
    switch(iEsc)
    {
    case NV_ESC_RM_OPEN:
        {
        CHECK_PDEV_NULL("NV_OPEN");
        CHECK_IN_OUT_SIZE("NV_OPEN", sizeof(DWORD), sizeof(DWORD));

        ppdev->pfnAcquireOglMutex(ppdev);
        (*(HANDLE *)pvOut) = NvOpen(ppdev->hDriver);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CLOSE:
        {
        CHECK_PDEV_NULL("NV_CLOSE");
        CHECK_IN_OUT_SIZE("NV_CLOSE", sizeof(DWORD), sizeof(DWORD));

        ppdev->pfnAcquireOglMutex(ppdev);
        NvClose(ppdev->hDriver);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_ROOT:
        {
        NVOS01_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_ROOT");
        CHECK_IN_OUT_SIZE("ALLOC_ROOT", sizeof(NVOS01_PARAMETERS), sizeof(NVOS01_PARAMETERS));

        inParms  = (NVOS01_PARAMETERS *)pvIn;
        outParms = (NVOS01_PARAMETERS *)pvOut;
        inParms->hClass  = NV01_ROOT_USER;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocRoot(ppdev->hDriver, NV01_ROOT_USER, &inParms->hObjectNew);
        ppdev->pfnReleaseOglMutex(ppdev);

        outParms->hObjectNew = inParms->hObjectNew;

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_DEVICE:
        {
        NVOS06_PARAMETERS *inParms, *outParms;
        union
        {
            ULONG osName;
            char devName[NV_DEVICE_NAME_LENGTH_MAX+1];
        } nameBuffer;

        CHECK_PDEV_NULL("ALLOC_DEVICE");
        CHECK_IN_OUT_SIZE("ALLOC_DEVICE", sizeof(NVOS06_PARAMETERS), sizeof(NVOS06_PARAMETERS));

        inParms  = (NVOS06_PARAMETERS *)pvIn;
        outParms = (NVOS06_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);

        // escape the device class to the device reference
        nameBuffer.osName = ppdev->ulDeviceReference;

        outParms->status = NvAllocDevice(ppdev->hDriver,
                                         inParms->hObjectParent,
                                         inParms->hObjectNew,
                                         NV03_DEVICE_XX, // inParms->hClass,
                                         (unsigned char *)nameBuffer.devName);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_CONTEXT_DMA:
        {
        NVOS03_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_CONTEXT_DMA");
        CHECK_IN_OUT_SIZE("ALLOC_CONTEXT_DMA", sizeof(NVOS03_PARAMETERS), sizeof(NVOS03_PARAMETERS));

        inParms  = (NVOS03_PARAMETERS *)pvIn;
        outParms = (NVOS03_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocContextDma(ppdev->hDriver,
                                             inParms->hObjectParent,
                                             inParms->hObjectNew,
                                             inParms->hClass,
                                             inParms->flags,
                                             (PVOID)inParms->pBase,
                                             (ULONG)inParms->limit);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_CHANNEL_PIO:
        {
        NVOS04_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_CHANNEL_PIO");
        CHECK_IN_OUT_SIZE("ALLOC_CHANNEL_PIO", sizeof(NVOS04_PARAMETERS), sizeof(NVOS04_PARAMETERS));

        inParms  = (NVOS04_PARAMETERS *)pvIn;
        outParms = (NVOS04_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocChannelPio(ppdev->hDriver,
                                             inParms->hRoot,
                                             inParms->hObjectParent,
                                             inParms->hObjectNew,
                                             inParms->hClass,
                                             inParms->hObjectError,
                                             (PVOID)&inParms->pChannel,
                                             inParms->flags);
        ppdev->pfnReleaseOglMutex(ppdev);

        outParms->pChannel = inParms->pChannel;

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_CHANNEL_DMA:
        {
        NVOS07_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_CHANNEL_DMA");
        CHECK_IN_OUT_SIZE("ALLOC_CHANNEL_DMA", sizeof(NVOS07_PARAMETERS), sizeof(NVOS07_PARAMETERS));

        inParms  = (NVOS07_PARAMETERS *)pvIn;
        outParms = (NVOS07_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocChannelDma(ppdev->hDriver,
                                             inParms->hRoot,
                                             inParms->hObjectParent,
                                             inParms->hObjectNew,
                                             inParms->hClass,
                                             inParms->hObjectError,
                                             inParms->hObjectBuffer,
                                             inParms->offset,
                                             (PVOID)&inParms->pControl);
        ppdev->pfnReleaseOglMutex(ppdev);

        outParms->pControl = inParms->pControl;

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_MEMORY:
        {
        NVOS02_PARAMETERS *inParms, *outParms;
        PVOID memory;
        ULONG limit;

        CHECK_PDEV_NULL("ALLOC_MEMORY");
        CHECK_IN_OUT_SIZE("ALLOC_MEMORY", sizeof(NVOS02_PARAMETERS), sizeof(NVOS02_PARAMETERS));

        inParms  = (NVOS02_PARAMETERS *)pvIn;
        outParms = (NVOS02_PARAMETERS *)pvOut;

        memory = (PVOID)inParms->pMemory; 
        limit = (ULONG)inParms->pLimit; 

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocMemory(ppdev->hDriver,
                                         inParms->hRoot,
                                         inParms->hObjectParent,
                                         inParms->hObjectNew,
                                         inParms->hClass,
                                         inParms->flags,
                                         &memory,
                                         &limit);
        ppdev->pfnReleaseOglMutex(ppdev);

        outParms->pMemory = (NvP64)memory;
        outParms->pLimit  = (NvU64)limit;

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC:
        {
        NVOS21_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC");
        CHECK_IN_OUT_SIZE("ALLOC", sizeof(NVOS21_PARAMETERS), sizeof(NVOS21_PARAMETERS));

        inParms  = (NVOS21_PARAMETERS *)pvIn;
        outParms = (NVOS21_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAlloc(ppdev->hDriver,
                                   inParms->hRoot,
                                   inParms->hObjectParent,
                                   inParms->hObjectNew,
                                   inParms->hClass,
                                   (PVOID)inParms->pAllocParms);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_OBJECT:
        {
        NVOS05_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_OBJECT");
        CHECK_IN_OUT_SIZE("ALLOC_OBJECT", sizeof(NVOS05_PARAMETERS), sizeof(NVOS05_PARAMETERS));

        inParms  = (NVOS05_PARAMETERS *)pvIn;
        outParms = (NVOS05_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocObject(ppdev->hDriver,
                                             inParms->hRoot,
                                             inParms->hObjectParent,
                                             inParms->hObjectNew,
                                             inParms->hClass);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_EVENT:
        {
        NVOS10_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_EVENT");
        CHECK_IN_OUT_SIZE("ALLOC_EVENT", sizeof(NVOS10_PARAMETERS), sizeof(NVOS10_PARAMETERS));

        inParms  = (NVOS10_PARAMETERS *)pvIn;
        outParms = (NVOS10_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocEvent(ppdev->hDriver,
                                            inParms->hRoot,
                                            inParms->hObjectParent,
                                            inParms->hObjectNew,
                                            inParms->hClass,
                                            inParms->index,
#ifdef _WIN64
                                            (PVOID) inParms->hEvent);
#else
                                            (ULONG) inParms->hEvent);
#endif
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_FREE:
        {
        NVOS00_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("NV_FREE");
        CHECK_IN_OUT_SIZE("NV_FREE", sizeof(NVOS00_PARAMETERS), sizeof(NVOS00_PARAMETERS));

        inParms  = (NVOS00_PARAMETERS *)pvIn;
        outParms = (NVOS00_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvFree(ppdev->hDriver,
                                  inParms->hRoot,
                                  inParms->hObjectParent,
                                  inParms->hObjectOld);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ARCH_HEAP:
        {
        NVOS11_PARAMETERS *inParms, *outParms;
        ULONG             lPitch;
        FLATPTR           fpVidMem;

        CHECK_PDEV_NULL("RM_ARCH_HEAP");
        CHECK_IN_OUT_SIZE("RM_ARCH_HEAP", sizeof(NVOS11_PARAMETERS), sizeof(NVOS11_PARAMETERS));

        inParms  = (NVOS11_PARAMETERS *)pvIn;
        outParms = (NVOS11_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);

        // copy input data to set it up
        *outParms = *inParms;

#ifdef RM_HEAPMGR
        outParms->status = NvArchHeap(ppdev->hDriver, inParms);
        outParms->offset = inParms->offset;
        outParms->pitch  = inParms->pitch;
#else
        // TODO: track heap allocations and cleanup on process
        // termination in DestroyContextClientInfo.
        if (inParms->function == NVOS11_HEAP_ALLOC_SIZE)
            {
            lPitch = (ULONG)inParms->pitch;
            lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            NVHEAP_ALLOC(fpVidMem, lPitch * inParms->height, TYPE_IMAGE);
            inParms->offset = (ULONG)fpVidMem;
            if (inParms->offset)
                {
                outParms->offset = inParms->offset;
                outParms->pitch  = inParms->pitch;
                outParms->status = NVOS11_STATUS_SUCCESS;
                }
            else
                {
                outParms->offset = inParms->offset;
                outParms->pitch  = inParms->pitch;
                outParms->status = NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                }
            }
        else
            {
            NVHEAP_FREE(inParms->offset);
            outParms->status = NVOS11_STATUS_SUCCESS;
            }
#endif

        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_VERSION:
        {
        NVOS12_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_VERSION");
        CHECK_IN_OUT_SIZE("CONFIG_VERSION", sizeof(NVOS12_PARAMETERS), sizeof(NVOS12_PARAMETERS));

        inParms  = (NVOS12_PARAMETERS *)pvIn;
        outParms = (NVOS12_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigVersion (ppdev->hDriver,
                                            inParms->hClient,
                                            inParms->hDevice,
                                            &outParms->version);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_GET:
        {
        NVOS13_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_GET");
        CHECK_IN_OUT_SIZE("CONFIG_GET", sizeof(NVOS13_PARAMETERS), sizeof(NVOS13_PARAMETERS));

        inParms  = (NVOS13_PARAMETERS *)pvIn;
        outParms = (NVOS13_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigGet (ppdev->hDriver,
                                        inParms->hClient,
                                        inParms->hDevice,
                                        inParms->index,
                                        &outParms->value);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_SET:
        {
        NVOS14_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_SET");
        CHECK_IN_OUT_SIZE("CONFIG_SET", sizeof(NVOS14_PARAMETERS), sizeof(NVOS14_PARAMETERS));

        inParms  = (NVOS14_PARAMETERS *)pvIn;
        outParms = (NVOS14_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigSet (ppdev->hDriver,
                                        inParms->hClient,
                                        inParms->hDevice,
                                        inParms->index,
                                        inParms->newValue,
                                        &outParms->oldValue);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_GET_EX:
        {
        NVOS_CONFIG_GET_EX_PARAMS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_GET_EX");
        CHECK_IN_OUT_SIZE("CONFIG_GET_EX", sizeof(NVOS_CONFIG_GET_EX_PARAMS), sizeof(NVOS_CONFIG_GET_EX_PARAMS));

        inParms  = (NVOS_CONFIG_GET_EX_PARAMS *)pvIn;
        outParms = (NVOS_CONFIG_GET_EX_PARAMS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigGetEx (ppdev->hDriver,
                                          inParms->hClient,
                                          inParms->hDevice,
                                          inParms->index,
                                          (ULONG *)inParms->paramStructPtr,
                                          inParms->paramSize);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_SET_EX:
        {
        NVOS_CONFIG_SET_EX_PARAMS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_SET_EX");
        CHECK_IN_OUT_SIZE("CONFIG_SET_EX", sizeof(NVOS_CONFIG_SET_EX_PARAMS), sizeof(NVOS_CONFIG_SET_EX_PARAMS));

        inParms  = (NVOS_CONFIG_SET_EX_PARAMS *)pvIn;
        outParms = (NVOS_CONFIG_SET_EX_PARAMS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigSetEx (ppdev->hDriver,
                                          inParms->hClient,
                                          inParms->hDevice,
                                          inParms->index,
                                          (ULONG *)inParms->paramStructPtr,
                                          inParms->paramSize);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_UPDATE:
        {
        NVOS15_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_UPDATE");
        CHECK_IN_OUT_SIZE("CONFIG_UPDATE", sizeof(NVOS15_PARAMETERS), sizeof(NVOS15_PARAMETERS));

        inParms  = (NVOS15_PARAMETERS *)pvIn;
        outParms = (NVOS15_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigUpdate (ppdev->hDriver,
                                           inParms->hClient,
                                           inParms->hDevice,
                                           inParms->flags);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_DEBUG_CONTROL:
        {
        NVOS20_PARAMETERS *parms;
        NVOS20_PARAMETERS *outParms;
        parms = (NVOS20_PARAMETERS *) pvIn;
        outParms = (NVOS20_PARAMETERS *)pvOut;

        outParms->status = NvRmDebugControl(ppdev->hDriver,
                                            parms->hRoot,
                                            parms->command,
                                            (PVOID)(parms->pArgs));
        return (ULONG)TRUE;
        }
        break;
    case ESC_NV_CONVERT_RING3_TO_RING0:
        {
        DWORD status, cbReturned;
        HANDLE* input[] = {pvIn, pvOut};

        CHECK_PDEV_NULL("NV_OPEN");
        CHECK_IN_OUT_SIZE("NV_CONVERT_RING3_TO_RING0", sizeof(HANDLE), sizeof(HANDLE));        

        if (*(HANDLE*)pvIn == NULL)
        {
            *(HANDLE*)pvOut = NULL;
            return(TRUE);
        }

        // the miniport will convert the handle
        status = EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_CONVERT_RING3_HANDLE,
            input,
            2 * sizeof(HANDLE*),
            input,
            2 * sizeof(HANDLE*),
            &cbReturned
        );

        if (status)
        {
            *(HANDLE*)pvOut = NULL;            
        }

        return(TRUE);
        }
        break;
    case QUERYESCSUPPORT:
        {
        // QUERYESCSUPPORT is sent to the driver to ask do you support
        // this pvIn points to the function code to query
        switch(*(ULONG *)pvIn)
            {
            case OPENGL_GETINFO:
                if (OGL_ESCAPE_FAIL_TEST(ppdev))
                    {
                    return((ULONG)FALSE);
                    }
#ifdef NV3
                oglSupported = (ppdev->cBitsPerPel == 16);
#else
                oglSupported = ((ppdev->cBitsPerPel == 16) ||
                                (ppdev->cBitsPerPel == 32));
#endif // NV3

#ifdef _WIN64
                oglSupported = oglSupported && (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC);
#endif
                if (oglSupported)
                    return((ULONG)TRUE); // return non-zero if supported
                return((ULONG)FALSE);
            break;
            case OPENGL_CMD:
                return((ULONG)TRUE); // supported
            break;
            default:
            break;
            }
        break;
        }
    case OPENGL_GETINFO:
        {
        if (OGL_ESCAPE_FAIL_TEST(ppdev))
            {
            return((ULONG)FALSE);
            }

        if (OglSupportEnabled(ppdev) == (ULONG)FALSE)
            {
            return((ULONG)FALSE);
            }
#ifdef NV3
        oglSupported = (ppdev->cBitsPerPel == 16);
#else
        oglSupported = ((ppdev->cBitsPerPel == 16) ||
                        (ppdev->cBitsPerPel == 32));
#endif // NV3

#ifdef _WIN64
        oglSupported = oglSupported && (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC); 
#endif
        if (oglSupported) {
            if (*((ULONG *)pvIn) == OPENGL_GETINFO_DRVNAME) {
#ifdef NV3
                if (wcslen(OPENGL_KEY_NAME_NV3) <= MAX_PATH) {
                    (void)wcscpy((wchar_t *)((LP_OPENGL_INFO) pvOut)->awch, OPENGL_KEY_NAME_NV3);
                    ((LP_OPENGL_INFO) pvOut)->ulVersion       = OPENGL_ICD_VER;
                    ((LP_OPENGL_INFO) pvOut)->ulDriverVersion = OPENGL_DRIVER_VER;

                    return((ULONG)TRUE);
                }
#else                
                if (wcslen(OPENGL_KEY_NAME_NV4) <= MAX_PATH) {
                    (void)wcscpy((wchar_t *)((LP_OPENGL_INFO) pvOut)->awch, OPENGL_KEY_NAME_NV4);
                    ((LP_OPENGL_INFO) pvOut)->ulVersion       = OPENGL_ICD_VER;
                    ((LP_OPENGL_INFO) pvOut)->ulDriverVersion = OPENGL_DRIVER_VER;

                    return((ULONG)TRUE);
                }
#endif            
            }
        }
        return((ULONG)FALSE);
        }
        break;
    case OPENGL_CMD:
      { 
            NV_OPENGL_COMMAND *pNvOpenGLCmd = (NV_OPENGL_COMMAND *)pvIn;
            PPDEV              ppdevTemp    = ppdev;

            if (   (NULL == pNvOpenGLCmd)
                || (cjIn < sizeof(NV_OPENGL_COMMAND)) )
            {
                DISPDBG((0, "DrvEscape - OPENGL_CMD input param error! needed:%d != cjIn:%d, pvIn:0x%p", sizeof(NV_OPENGL_COMMAND), cjIn, pNvOpenGLCmd));
                return(FALSE);
            }

#if defined(_WIN64)
            ASSERTDD(pNvOpenGLCmd->NVClientModel == NV_ESC_IS_64BIT_CLIENT || pNvOpenGLCmd->NVClientModel == NV_ESC_IS_32BIT_CLIENT, "NVClientModel not preset !!!");
#else
            ASSERTDD(pNvOpenGLCmd->NVClientModel == NV_ESC_IS_32BIT_CLIENT, "ICD Client is not matching 64 bit client on 32 bit server or NVClientModel not preset !!!");
#endif
            // this call has to be send to the right device in multimon configuration
            // we use the device origin for that purpose
#ifdef NV_MAIN_MULTIMON
            if( bOglRetrieveValidPDEVForOrigin( &ppdevTemp, pNvOpenGLCmd->devOriginLeft, pNvOpenGLCmd->devOriginTop ) )
#else
            if( NULL != ppdevTemp )
#endif
            {
                //************************************************************************** 
                // Need to do smart sync between OpenGL and GDI depending on 
                // clip intersection.
                //**************************************************************************
                bOglSyncOglIfGdiRenderedToWindow(ppdevTemp);

                return ((ULONG)DoOpenGLEscapeCommand(ppdevTemp, (PVOID)pvIn, (PVOID)pvOut));
            }
            else
            {
                ASSERT(FALSE);
                return((ULONG)FALSE);
            }
            
        }
        break;
    case WNDOBJ_SETUP:
        {
        NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;
        NV_WNDOBJ_SETUP *pNvWndObj;
        LONG status;
#if defined(_WIN64)
        NV_WNDOBJ_SETUP    nvWndObj;
        NV_WNDOBJ_SETUP32 *pNvWndObj32;

        if (cjIn == sizeof(NV_WNDOBJ_SETUP32)) {
            pNvWndObj32 = (NV_WNDOBJ_SETUP32 *)pvIn;
            pNvWndObj = &nvWndObj;
            try
                {
                    NvCopyStructIn(pNvWndObj32, pNvWndObj, "IPPII");
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "WNDOBJ_SETUP: exception = 0x%lx", status));
                return((ULONG)FALSE);
                }
 
        } else
#endif
        pNvWndObj = (NV_WNDOBJ_SETUP *)pvIn;

        if((pNvWndObj != NULL ) && (pNvWndObj->NVSignature == NV_SIGNATURE))
            {
            try
                {
                ppdev->numDevices = pNvWndObj->numDevices;
                OglAcquireGlobalMutex();
                clientDrawableInfo = CreateDrawableClientInfo(pso,
                    pNvWndObj->hWnd,
                    pNvWndObj->hDC,
                    &pNvWndObj->pfd);
               ((PVOID *)pvOut)[0] = clientDrawableInfo;
                OglReleaseGlobalMutex();
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "WNDOBJ_SETUP: exception = 0x%lx", status));
                return((ULONG)FALSE);
                }
            return((ULONG)TRUE);
            }
        else
            {
            return((ULONG)FALSE);
            }
        }
        break;
   // - Added to provide the path to the driver reg area (hard coded under winnt4)
   case NV_ESC_GET_LOCAL_REGISTRY_PATH:
      {
         // - The first four spaces in the string are required to remain comp with w9x behavior
#if (_WIN32_WINNT >= 0x0500)
        UCHAR drv_path[128];
#else
        UCHAR drv_path[] = "    SYSTEM\\CurrentControlSet\\Services\\nv4\\Device0";
#endif
         if(ppdev == NULL ||
            pvOut == NULL || cjOut < sizeof(drv_path) ) { // - Remember to change this to X 2 when unicode

            DISPDBG((2, "DrvEscape - can't NV_ESC_GET_LOCAL_REGISTRY_PATH"));
            return(FALSE);
            }

#if (_WIN32_WINNT >= 0x0500)
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_GET_REGISTRY_PATH,
                               NULL,
                               0,
                               (LPVOID) (drv_path),
                               sizeof(drv_path),
                               &returnedDataLength))
        {
            return(FALSE);
        }
        if (returnedDataLength == 0)
        {
            return(FALSE);
        }
#endif

        // - Do a simple memcpy for now, till unicode later
        {
            int i;
            for(i=0;drv_path[i]!=0 && i<127;i++)
               ((UCHAR*)pvOut)[i] = drv_path[i];
            ((UCHAR*)pvOut)[i] = 0;
        }

        return(TRUE);
      }
      break;


    default:
        break;
    }

    //**************************************************************************
    //
    // DISABLED UNTIL IMPLEMENTATION IS COMPLETE
    //
    // On 64 bit systems, call DrvEscape32() for escape codes that need
    // special handling (pointer conversion) for 32 bit clients.
    //
    //
    //**************************************************************************
    if (iEsc & NV_ESC_64_BASE)
        iEsc &= ~NV_ESC_64_BASE;
#if 0
    else
        return(DrvEscape32(pso, iEsc, cjIn, pvIn, cjOut, pvOut));
#endif

    //**************************************************************************
    //
    // The following switch statement handles the bulk of the cases where the
    // incoming parameter data differs in size from 32 and 64 bit clients.
    //
    //**************************************************************************

    switch(iEsc)
    {
    case NV_ESC_PRIMARY_INFO:
        {
        NV_PRIMARY_INFO *primaryInfoIn = (NV_PRIMARY_INFO *)pvIn;
        NV_PRIMARY_INFO *primaryInfoOut = (NV_PRIMARY_INFO *)pvOut;
        LONG status;
        unsigned int numActiveDACs, dacMask, activeDACs, d;

        try
            {
            if (primaryInfoIn && primaryInfoOut && primaryInfoIn->ulNVSignature == NV_SIGNATURE)
                {
                primaryInfoOut->ulWidth         = ppdev->cxScreen;
                primaryInfoOut->ulHeight        = ppdev->cyScreen;
                primaryInfoOut->ulDepth         = ppdev->cjPelSize << 3;
                primaryInfoOut->ulPitch         = ppdev->lDelta;
                primaryInfoOut->ulPrimaryOffset = ppdev->ulPrimarySurfaceOffset;
                primaryInfoOut->ulNumDACs       = ppdev->ulNumberDacsOnBoard;
                primaryInfoOut->ulNumActiveDACs = ppdev->ulNumberDacsActive;
                primaryInfoOut->ulPanningPtr    = NULL;
                primaryInfoOut->ulReturnCode    = TRUE;

                // Compute a bitmap of active DACs by looping over all displays
                // until we've checked them all, or found ulNumberDacsActive
                // unique DACs--whichever comes first.
                for (d = activeDACs = numActiveDACs = 0; (d < NV_NO_DACS) &&
                     (numActiveDACs < ppdev->ulNumberDacsActive); d++)
                    {
                    if (ppdev->ulDeviceDisplay[d] < NV_NO_DACS)
                        {
                        dacMask = 1 << ppdev->ulDeviceDisplay[d];
                        if (!(dacMask & activeDACs))
                            {
                            numActiveDACs++;
                            activeDACs |= dacMask;
                            }
                        }
                    }
                primaryInfoOut->ulActiveDACs = activeDACs;
                }
            else
                {
                return (ULONG)FALSE;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
            status = GetExceptionCode();
            DISPDBG((1, "NV_ESC_PRIMARY_INFO: exception = 0x%lx", status));
            return (ULONG)FALSE;
            }
        }
        return (ULONG)TRUE;
    case NVDMAPUSHMODESWITCHCOUNT:
        {
        if (OGL_ESCAPE_FAIL_TEST(ppdev))
            {
            return((ULONG)FALSE);
            }

        if (pvOut != NULL)
            {
            ((ULONG *)pvOut)[0] = 0; // ppdev->dwGlobalModeSwitchCount;
            return((ULONG)TRUE);
            }
        return((ULONG)FALSE);
        }
        break;
    case ESC_NV_OPENGL_ESCAPE:
        {
        return((ULONG)DoOpenGLEscapeCommand(ppdev, (PVOID)pvIn, (PVOID)pvOut));
        }
        break;
    case NV_OPENGL_SET_ENABLE:
        {
        // return the current mode switch counter to the caller and
        // the shared mutex lock pointer.
        ((ULONG *)pvOut)[0] = ppdev->dwGlobalModeSwitchCount;
        return((ULONG)TRUE); // return non-zero if supported
        }
        break;
    case ESC_NV_OPENGL_DMA_PUSH_GO:
        {

            if (ppdev == NULL || pvOut == NULL || pvIn == NULL) {
                return((ULONG)FALSE);
            } else {
#ifdef NV3
                Nv3DmaPushInfo *dmaPushInfo;
                dmaPushInfo = (Nv3DmaPushInfo *)((Nv3DmaPushInfo *)pvIn);

                if ((long)dmaPushInfo->put - (long)dmaPushInfo->get <= 0) {
                    ((ULONG *)pvOut)[1] = ppdev->dwGlobalModeSwitchCount;

                    return((ULONG)FALSE);
                }

                if (ppdev->cBitsPerPel == 16 &&
                    dmaPushInfo->localModeSwitchCount == ppdev->dwGlobalModeSwitchCount)
                    {
                    // on NV3 this is a DMA push kickoff escape function
                    ((ULONG *)pvOut)[0] = (ULONG)NV3_DmaPushGo(ppdev,
                                                               dmaPushInfo->dwChID,
                                                               dmaPushInfo->dwTlbPtBase,
                                                               dmaPushInfo->dwAddressSpace,
                                                               dmaPushInfo->get,
                                                               dmaPushInfo->put,
                                                               dmaPushInfo->hClient,
                                                               dmaPushInfo->hDevice);
                }
#else                
                // on NV4 this is an engine sync escape function
                // force a channel sync when GDI gets called again for rendering
                ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
                ppdev->NVFreeCount = 0;
                ppdev->pfnWaitForChannelSwitch(ppdev);
#endif // NV3
            
                ((ULONG *)pvOut)[1] = ppdev->dwGlobalModeSwitchCount;

                DISPDBG((2, "DrvEscape - SUCCESS!"));
                return((ULONG)TRUE);
            }
        }
        break;
    case ESC_SET_GAMMA_RAMP:
        {
        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(GAMMARAMP) )
            {
            DISPDBG((2, "DrvEscape - can't set gamma ramp"));
            return(FALSE);
            }
        nvSetGammaRamp(ppdev, (PUSHORT) pvIn);
        return(TRUE);
        }
        break;
    case ESC_GET_GAMMA_RAMP:
        {
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(GAMMARAMP) ) 
            {
            DISPDBG((2, "DrvEscape - can't get gamma ramp"));
            return(FALSE);
            }
        nvGetGammaRamp(ppdev, (PUSHORT) pvOut);
        return(TRUE);
        }
        break;
    case ESC_SET_GAMMA_RAMP_MULTI:
        {
        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(GAMMARAMP_MULTI) )
            {
            DISPDBG((2, "DrvEscape - can't set gamma ramp multi"));
            return(FALSE);
            }
        nvSetHeadGammaRamp(ppdev, ((PGAMMARAMP_MULTI)pvIn)->wHead, (PUSHORT)&(((PGAMMARAMP_MULTI)pvIn)->grGammaRamp));
        return(TRUE);
        }
        break;
    case ESC_GET_GAMMA_RAMP_MULTI:
        {
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(GAMMARAMP_MULTI) ||
                             pvIn == NULL  || cjIn != sizeof(GAMMARAMP_MULTI) )
            {
            DISPDBG((2, "DrvEscape - can't get gamma ramp multi"));
            return(FALSE);
            }
        nvGetHeadGammaRamp(ppdev, ((PGAMMARAMP_MULTI)pvIn)->wHead, (PUSHORT)&(((PGAMMARAMP_MULTI)pvOut)->grGammaRamp));
        return(TRUE);
        }
        break;
    case NV_ESC_RM_DMA_PUSH_INFO:
        {
        // TODO: define a structure for this call...
        ULONG *inParms, *outParms;

        CHECK_PDEV_NULL("RM_DMA_PUSH_INFO");
        CHECK_IN_OUT_SIZE("RM_DMA_PUSH_INFO", sizeof(NVOS08_PARAMETERS), sizeof(NVOS08_PARAMETERS));

        inParms  = (ULONG *)pvIn;
        outParms = (ULONG *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms[4] = NvGetDmaPushInfo (ppdev->hDriver,
                                        inParms[0],  // hClient
                                        inParms[1],  // hDevice
                                        inParms[2],  // hChannel
                                        inParms[3],  // a pointer to a DWORD array
                                        inParms[4]); // hDmaContext
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;

    case ESC_NV_QUERY_PCI_SLOT:
    {
        ULONG * pulPciSlot;

        pulPciSlot = (ULONG *) pvOut;

        if(EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_QUERY_PCI_SLOT,
                       NULL,
                       0,
                       (LPVOID) (pulPciSlot),
                       sizeof(ULONG),
                       &returnedDataLength))
        {
            DISPDBG((2, "DrvEscape - can't get PCI number"));
            return(FALSE);
        }
        
        return(TRUE);
    }    
    break;

    case ESC_NV_QUERY_HEAD_REFRESH_RATE:
    {
        ULONG * pulHead;
        ULONG * pulRefreshRate;

        pulHead = (ULONG *) pvIn;
        pulRefreshRate = (ULONG *) pvOut;

        if( (pulHead == NULL) || (*pulHead > 1) )
        {
            DISPDBG((2, "DrvEscape - Invaild Head number"));
            return(FALSE);
        }

        if( ppdev == NULL || pulRefreshRate == NULL)
        {
            DISPDBG((2, "DrvEscape - NULL pointer for refresh rate"));
            return(FALSE);
        }

        *pulRefreshRate = ppdev->ulRefreshRate[*pulHead];

        return(TRUE);
    }    
    break;


    case ESC_NV_QUERYSET_REGISTRY_KEY:
        {
            __PNVRegKeyInfo inParms, outParms;
            WCHAR tmpStrBuf[NV_MAX_REG_KEYNAME_LEN];
            ULONG  inpStrLen, outStrLen;
            ULONG ii, returnedDataLen;
            NV_REGISTRY_STRUCT regStruct;
            NV_REGISTRY_STRUCT regStructInput, regStructOutput;
            DWORD retStatus;
            
            CHECK_PDEV_NULL("QUERYSET_REGISTRY_KEY");
            CHECK_IN_OUT_SIZE("QUERYSET_REGISTRY_KEY", sizeof(__NVRegKeyInfo), sizeof(__NVRegKeyInfo));

            inParms = (__PNVRegKeyInfo) pvIn;


            if (!inParms->keyName)
                return (FALSE);

            inpStrLen = strlen(inParms->keyName);

            if ((inpStrLen+1) > NV_MAX_REG_KEYNAME_LEN)
                return (FALSE);
            /*
            for (ii = 0; ii < inpStrLen; ii++)
                tmpStrBuf[ii] = inParms->keyName[ii];
            tmpStrBuf[ii] = 0;
            */

            EngMultiByteToUnicodeN((LPWSTR)tmpStrBuf, NV_MAX_REG_KEYNAME_LEN*sizeof(WCHAR), &outStrLen,
                                   inParms->keyName, (inpStrLen+1)*sizeof(CHAR));



            switch(inParms->type)
            {
            case NV_QUERY_REGISTRY_BINARY_KEY:
                outParms = (__PNVRegKeyInfo) pvOut;
                *outParms = *inParms;

                regStructInput.keyName = (PWSTR)tmpStrBuf;
                regStructInput.keyVal = outParms->keyVal;
                regStructInput.keyValSize = outParms->keyValMaxSize;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                               (LPVOID)&regStructInput,
                               sizeof(NV_REGISTRY_STRUCT),
                               (LPVOID) (outParms->keyVal),
                               outParms->keyValMaxSize,
                               &(returnedDataLen));

                outParms->retStatus = retStatus;

                // Copy the returned registry value size into outParams
                outParms->keyValSize = returnedDataLen;
                // The KeyVal has already been copied by the miniport

                break;

            case NV_QUERY_REGISTRY_KEY:

                outParms = (__PNVRegKeyInfo) pvOut;
                *outParms = *inParms;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                               (LPVOID)tmpStrBuf,
                               outStrLen,
                               (LPVOID) (outParms->keyVal),
                               outParms->keyValMaxSize,
                               &(outParms->keyValSize));

                outParms->retStatus = retStatus;

                break;

            case NV_SET_REGISTRY_KEY:

                outParms = (__PNVRegKeyInfo) pvOut;
                *outParms = *inParms;

                regStruct.keyName = (PWSTR)tmpStrBuf;
                regStruct.keyVal = inParms->keyVal;
                regStruct.keyValSize = inParms->keyValSize;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_REGISTRY_VALUE,
                               (LPVOID)(&regStruct),
                               sizeof(NV_REGISTRY_STRUCT),
                               (LPVOID) NULL,
                               0,
                               &returnedDataLen);

                outParms->retStatus = retStatus;

                break;

            default:
                break;
            }
            return (TRUE);
        }
        break;

    case ESC_NV_DESKMGR_ZOOMBLIT:
#ifdef _WIN32_WINNT
        {
            __NVDMEscapeParams* pParams = (__NVDMEscapeParams*) pvIn;

            // Validate parameters.
            if (!(pParams && (cjIn >= (sizeof(__NVDMEscapeParams) +
                                      (pParams->clips - 1) * sizeof(RECTL)))))
                return (ULONG) FALSE;
            // If we don't have appropriate scaled-image HW support, fail.
            if (!(ppdev->CurrentClass.ScaledImageFromMemory &&
                  ppdev->pfnStretchCopy))
                return (ULONG) FALSE;

            // If performing a blit out of system memory...
            if (pParams->flags & NVDM_ESC_BLIT_SYSMEM) {
                // Not supported at the moment.
                return (ULONG) TRUE;
            }
            // Otherwise do a vidmem-to-vidmem blit.
            return (ULONG)
                ppdev->pfnStretchCopy(ppdev,
                                      pParams->flags & NVDM_ESC_BLIT_SMOOTH,
                                      pParams->scale,
                                      &pParams->srcRect, &pParams->dstRect,
                                      pParams->clips, pParams->clipRects);
        }
#endif  //#ifdef _WIN32_WINNT
        return (ULONG) TRUE;

#if (NVARCH >= 0x4) && (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
    case NV_ESC_DDPRIV_DMABLIT:
       {
           ULONG i;
           if (cjOut >= sizeof(NVS2VERROR)) {
               ((LPNVS2VDATATYPE)pvIn)->dwDevice = ppdev->ulDeviceReference;
               *((NVS2VERROR *)pvOut) = nvMoComp(pvIn);
               return (TRUE);
           }
       }
       break;

   case NV_ESC_DDPRIV_OVERLAYCONTROL:
       {
           ULONG i;
           if (cjOut >= sizeof(NVOCERROR)) {
               ((LPNVOCDATATYPE)pvIn)->dwDevice = ppdev->ulDeviceReference;
               *((NVOCERROR *)pvOut) = nvOverlayControl(pvIn);
               return (TRUE);
           }
       }
       break;
#endif

    case NV_ESC_SETGET_TWINVIEW_DATA:
        {

            NVTWINVIEWDATA  * nvDataIn;
            NVTWINVIEWDATA  * nvDataOut;
            ULONG GetFlag;  // 1 means a "Get" kind of action and 0 means a "Set" kind of action
            ULONG i, j;

            DISPDBG((1, "Enter NV_ESC_SETGET_TWINVIEW_DATA"));

            if (ppdev == NULL || pvIn == NULL || pvOut == NULL) {
                DISPDBG((0, "DrvEscape - cant NV_ESC_SETGET_TWINVIEW_DATA: ppdev: 0x%x, pvIn: 0x%x, pvOut: 0x%x", ppdev, pvIn, pvOut));
                return(FALSE);
            }
            //
            // Need to add some defensive code in case the Control Panel doesn't match the driver. If this
            // happens, the structure size can be different and cause lots of problems, especially when doing
            // the memcpy below. Note that I'm not checking for cjIn/cjOut to be equal the NVTWINVIEWDATA
            // because there is a case during initialization where this isn't true - they are about 4 times
            // larger. Need to check with Control Panel guys, and so this is at least a first pass to make
            // sure the memcpy below won't get a page fault.
            //
            if ((cjIn < sizeof(NVTWINVIEWDATA)) || (cjOut < sizeof(NVTWINVIEWDATA)))
            {
                DISPDBG((1, "DrvEscape - NV_ESC_SETGET_TWINVIEW_DATA error: cjIn: 0x%x, cjOut: 0x%x", cjIn, cjOut));
                return(FALSE);
            }
            nvDataIn = (NVTWINVIEWDATA *)pvIn;
            nvDataOut = (NVTWINVIEWDATA *)pvOut;

            switch (nvDataIn->dwFlag) {
                case NVTWINVIEW_FLAG_GET: 
                     GetFlag = 1;
                     // Do a copy of the pvIn to pvOut.
                     // This is to handle the case where the OS zeroes out the pvOut before calling the display driver.
                     memcpy(nvDataOut, nvDataIn, sizeof(NVTWINVIEWDATA));
                     break;
                case NVTWINVIEW_FLAG_SET: 
                     GetFlag = 0;
                     break;
                default:
                     DISPDBG((0," oops! dwFlag is unknown: 0x%x\n",nvDataIn->dwFlag));
                     nvDataOut->dwSuccess = FALSE;
                     return(TRUE);
                     break;
            }
            nvDataOut->dwSuccess = TRUE;

            switch (nvDataIn->dwAction) {
                case NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODE:
                    if (GetFlag)
                    {
                        SET_RECT(&nvDataOut->DeskTopRectl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
                        nvDataOut->dwState = ppdev->TwinView_State;
                        nvDataOut->dwOrientation = ppdev->TwinView_Orientation;
                        nvDataOut->dwAllDeviceMask = ppdev->ulAllDeviceMask;
                        nvDataOut->dwConnectedDeviceMask = ppdev->ulConnectedDeviceMask;
                        for (i=0; i < ppdev->ulNumberDacsOnBoard; i++) {
                            nvDataOut->dwDeviceDisplay[i] = ppdev->ulDeviceDisplay[i];
                        }
                    }
                    else
                    {
                       BOOLEAN DataOK;
                        DataOK = TwinViewDataOK(ppdev, nvDataIn);
                        if (!DataOK) 
                        {
                            DISPDBG((0,"Oops! The panel did not pass us sensible data. So return Failure\n"));
                            nvDataOut->dwSuccess = FALSE;
                            return(TRUE);
                        }
                        //
                        // Now write the TwinViewInfo structure to the registry.
                        //
                        PrintTwinViewData ("SET_PHYSICAL_VIRTUAL_MODE:Info sent by nvPanel", 1, nvDataIn, ppdev);
                        WriteRegistryTwinViewInfo(ppdev, nvDataIn);

                        // Some of the flags are synchronous. They take effect immediately.
                        // Handle the synchronous EnablePanScan flag.
                        ProcessSynchronousFlags(ppdev, nvDataIn);


                        return(TRUE);
                    }

                    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++) {
                        if (GetFlag) {
                            SET_RECT(&nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl,ppdev->rclDisplayDesktop[i].left,
                                ppdev->rclDisplayDesktop[i].top, ppdev->rclDisplayDesktop[i].right,ppdev->rclDisplayDesktop[i].bottom);
                            SET_RECT(&nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl,ppdev->rclCurrentDisplay[i].left,
                                ppdev->rclCurrentDisplay[i].top,ppdev->rclCurrentDisplay[i].right,ppdev->rclCurrentDisplay[i].bottom);

                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwDeviceMask = ppdev->ulDeviceMask[i];

                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwDeviceType = ppdev->ulDeviceType[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwTVFormat = ppdev->ulTVFormat[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwBpp = ppdev->cBitsPerPel; // same for both devices
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwRefresh = ppdev->ulRefreshRate[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwNumPhysModes = ppdev->ulNumPhysModes[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwNumVirtualModes = ppdev->ulNumVirtualModes[i];

                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwTimingOverRide = ppdev->ulTimingOverRide[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwEnableDDC = ppdev->ulEnableDDC[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwEnablePanScan = ppdev->ulEnablePanScan[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwFreezePanScan = ppdev->ulFreezePanScan[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwFreezeOriginX = ppdev->ulFreezeOriginX[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwFreezeOriginY = ppdev->ulFreezeOriginY[i];

                        } else {
                            DISPDBG((0,"OOps! Logic error in display driver. Should not be here. file: %s, line: %d\n",__FILE__,__LINE__));
                        }
                    } // for
                    if (GetFlag) {
                        //
                        // Print the info we are sending back to the panel
                        //
                        PrintTwinViewData ("GET_PHYSICAL_VIRTUAL_MODE:Info returned to nvPanel", 2, nvDataOut, ppdev);
                    }
                    break;

                case NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODELIST:
                    if (GetFlag) {
                        for (i=0; i < ppdev->ulNumberDacsOnBoard; i++) {
                            if (!bGetPhysicalVirtualModeList(ppdev, i, 

                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwDeviceMask,

                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwDeviceType,
                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwTVFormat,
                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].PhysModeEntries,
                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].VirtualModeEntries,
                                    &nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwNumPhysModeEntries,
                                    &nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwNumVirtualModeEntries))
                            {
                                nvDataOut->dwSuccess = FALSE;
                                return(TRUE);
                            }
                        }
                    } 
                    else 
                    {
                        // There is no necessity for this path. The panel should never need to tell
                        // the driver to set the physmodeList for a head.
                    }
                    break;

                default: DISPDBG((0,"Invalid unsupported dwAction: 0x%x\n",nvDataIn->dwAction));
                     nvDataOut->dwSuccess = FALSE;
                     return(TRUE);
                    break;
            }
            return(TRUE);
        }


    case NV_ESC_SET_DISPLAY_DEVICE_TYPE:
        {
        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(SETGETDEVTYPE))
            {
            DISPDBG((2, "DrvEscape - cant NV_ESC_SET_DISPLAY_DEVICE_TYPE"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESC_SET_DISPLAY_DEVICE_TYPE"));
        if(!nvSetDisplayDevice(ppdev, (PSETGETDEVTYPE) pvIn)) {
           return(FALSE);
        }
        return(TRUE);
        }
        break;


    case NV_ESC_GET_DISPLAY_DEVICE_TYPE:
        {
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(SETGETDEVTYPE))
            {
            DISPDBG((2, "DrvEscape - cant NV_ESC_GET_DISPLAY_DEVICE_TYPE"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESC_GET_DISPLAY_DEVICE_TYPE"));
        if(!nvGetDisplayDevice(ppdev, (PSETGETDEVTYPE) pvOut)) {
            return(FALSE);
        }
        return(TRUE);
        }
        break;

    case NV_ESC_GET_DEVICE_SCAN_DATA:
        {
        GET_DEVICE_SCAN_DATA_TYPE * pInfo;
        ULONG i;
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(GET_DEVICE_SCAN_DATA_TYPE))
            {
            DISPDBG((0, "DrvEscape - cant NV_ESC_GET_DEVICE_SCAN_DATA"));
            return(FALSE);
            }
        DISPDBG((1, "DrvEscape - NV_ESC_GET_DEVICE_SCAN_DATA"));
        pInfo = (GET_DEVICE_SCAN_DATA_TYPE *)pvOut;
        pInfo->ulNumberDacsOnBoard = ppdev->ulNumberDacsOnBoard;
        pInfo->ulNumberDacsConnected = ppdev->ulNumberDacsConnected;
        pInfo->ulNumberDacsActive = ppdev->ulNumberDacsActive;
        for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
        {
            pInfo->ulHeadDeviceOptions[i] = ppdev->ulHeadDeviceOptions[i];
        }
        
        return(TRUE);
        }
        break;

    case NV_ESC_GET_DEVICE_MASK:
        {
        GET_DEVICE_MASK_DATA_TYPE * pInfo;
        ULONG ulPrimaryHead;
        ULONG ReturnedDataLength;
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(GET_DEVICE_MASK_DATA_TYPE))
            {
            DISPDBG((0, "DrvEscape - cant NV_ESC_GET_DEVICE_MASK"));
            return(FALSE);
            }
        DISPDBG((1, "DrvEscape - NV_ESC_GET_DEVICE_MASK, ppdev->ulInduceModeChangeDeviceMask: 0x%x",
                 ppdev->ulInduceModeChangeDeviceMask));
        pInfo = (GET_DEVICE_MASK_DATA_TYPE *)pvOut;
        //
        // Initialize the return data.
        //
        pInfo->ulDeviceMask = 0;

        //
        // A sanity check. We enable this modeswitch only if the NVSVC has started.
        // We should not run into this situation since we would never be here unless NVSVC had responded to
        // the signal on the named event. A sanity check however should not hurt.
        //
        if (ppdev->ulNVSVCStatus != NVSVC_STATUS_STARTED)
        {
            DISPDBG((1,"Something wrong. NVSVC is not running."));
            return(TRUE);
        }


#if _WIN32_WINNT < 0x500
        //
        // See if we got here as a result of a NT4.0 hotkey switch, such as on gateway laptops.
        // I can put a further check here for ACPI system. Do this later.
        //
        if (bHandleNT4HotKey(ppdev, pInfo))
        {
            //
            // There was a hotkey pending. We processed it and now we can return.
            //
            return(TRUE);
        }
#endif

        //
        // We are not here because of a hotkey switch.
        // Ergo, this is a device switch initiated by the display driver.
        // So return the device mask to be used by the control panel.
        //
        pInfo->ulDeviceMask = ppdev->ulInduceModeChangeDeviceMask;
        DISPDBG((1, "Info being returned: ulDeviceMask: 0x%x",pInfo->ulDeviceMask));

        //
        // The ulInduceModeChangeDeviceMask has been consumed by the panel. So clear it now so that subsequent
        // modesets will not cause StopImage method to show up. Also, let miniport know too.
        // Note: it is better to do it here rather than on entry into InitMultiMon(). Reason is the hibernation
        // case where GDI callsDrvAssertMode(TRUE) twice and by the time control panel makes the GET_DEVICE_MASK
        // escape call, the second DrvAssertMode(TRUE) would have sneaked in and cleared the 
        // ulInduceModeChangeDeviceMask before the control panel had a chance to consume it.
        //
        ppdev->ulInduceModeChangeDeviceMask = 0;
        if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK,
                        &ppdev->ulInduceModeChangeDeviceMask,
                        sizeof(ULONG),
                        NULL,
                        0,
                        &ReturnedDataLength))
        {
            DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_DEVMASK failed"));
        }   
        return(TRUE);
        }
        break;

    case NV_ESC_INDUCE_DEVICE_SCAN:
        {
            if (ppdev == NULL)
               {
               DISPDBG((0, "DrvEscape - cant NV_ESC_INDUCE_DEVICE_SCAN"));
               return(FALSE);
               }
            DISPDBG((1, "DrvEscape - NV_ESC_INDUCE_DEVICE_SCAN"));
            InduceAndUpdateDeviceScanning(ppdev);

            return(TRUE);
        }
        break;

    case NV_ESC_SET_NVSVC_STATUS:
        {
        ULONG ulNVSVCStatus;
        ULONG returnedDataLength;

        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(ULONG))
            {
            DISPDBG((0, "DrvEscape - cant NV_ESC_SET_NVSVC_STATUS"));
            return(FALSE);
            }
        DISPDBG((1, "DrvEscape - NV_ESC_SET_NVSVC_STATUS"));
        ulNVSVCStatus = *(ULONG *)pvIn;
        if (ulNVSVCStatus != NVSVC_STATUS_STARTED && ulNVSVCStatus != NVSVC_STATUS_STOPPED &&
            ulNVSVCStatus != NVSVC_STATUS_PAUSED)
        {
            //
            // Invalid data passed to us by NVSVC
            //
            DISPDBG((0, "DrvEscape - Invalid NVSVC_STATUS data passed in by NVSVC: 0x%x",ulNVSVCStatus));
            return(FALSE);
        }
        DISPDBG((1, "NVSVCStatus being set: 0x%x\n",ulNVSVCStatus));
        //
        // Store it in the pdev.
        //
        ppdev->ulNVSVCStatus = ulNVSVCStatus;
        //
        // Let the miniport know of this latest status also.
        //
        if(EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_SET_NVSVC_STATUS,
                       &ulNVSVCStatus,
                       sizeof(ULONG),
                       NULL,
                       0,
                       &returnedDataLength))
        {
            DISPDBG((0, "DrvEscape - can't do SET_NVSVC_STATUS"));
            return(FALSE);
        }

        return(TRUE);
        }
        break;

    case NV_ESC_QUERY_SAVE_SETTINGS:
        {

            QUERY_SAVE_SETTINGS  * nvDataIn;
            NVTWINVIEWDATA  * nvDataOut;
            NVTWINVIEWDATA  * pFind;

            DISPDBG((1, "Enter NV_ESC_QUERY_SAVE_SETTINGS"));

            if (ppdev == NULL || pvIn == NULL || pvOut == NULL) {
                DISPDBG((0, "DrvEscape - cant NV_ESC_QUERY_SAVE_SETTINGS: ppdev: 0x%x, pvIn: 0x%x, pvOut: 0x%x", ppdev, pvIn, pvOut));
                return(FALSE);
            }
            //
            // Need to add some defensive code in case the Control Panel doesn't match the driver. 
            //
            if ((cjIn < sizeof(QUERY_SAVE_SETTINGS)) || (cjOut < sizeof(NVTWINVIEWDATA)))
            {
                DISPDBG((1, "DrvEscape - NV_ESC_QUERY_SAVE_SETTINGS error: cjIn: 0x%x, cjOut: 0x%x", cjIn, cjOut));
                return(FALSE);
            }
            nvDataIn = (QUERY_SAVE_SETTINGS *)pvIn;
            nvDataOut = (NVTWINVIEWDATA *)pvOut;
            
            DISPDBG((1, "Query: State: 0x%x, Orientation: 0x%x, mapping array:(%d, %d), deviceMask: (0x%x, 0x%x)",
                nvDataIn->ulState,nvDataIn->ulOrientation, nvDataIn->ulDeviceDisplay[0], nvDataIn->ulDeviceDisplay[1],
                nvDataIn->ulDeviceMask[0],nvDataIn->ulDeviceMask[1]));

            //
            // Find the saved settings slot for the requested device combo
            //
            pFind = pFindSaveSettings(ppdev, nvDataIn, NULL);
            if (pFind == NULL)
            {
                DISPDBG((1,"Something wrong. pFindSaveSettings() returned failure"));
                nvDataOut->dwSuccess = FALSE;
                return(TRUE);
            }
        
            //
            // We found the saved settings. Now return the data to the panel
            //
            memcpy(nvDataOut, pFind, sizeof(NVTWINVIEWDATA));
            nvDataOut->dwSuccess = TRUE;
            //
            // Print the info we are sending back to the panel
            //
            PrintTwinViewData ("QUERY_SAVE_SETTINGS:Info returned to nvPanel", 1, nvDataOut, ppdev);
            return(TRUE);
        }
        break;

    case NV_ESC_FORCE_SAVE_SETTINGS:
        {
            NVTWINVIEWDATA  * nvDataIn;
            NVTWINVIEWDATA  * pFind;

            DISPDBG((1, "Enter NV_ESC_QUERY_SAVE_SETTINGS"));

            if (ppdev == NULL || pvIn == NULL) {
                DISPDBG((0, "DrvEscape - cant NV_ESC_FORCE_SAVE_SETTINGS: ppdev: 0x%x, pvIn: 0x%x", ppdev, pvIn));
                return(FALSE);
            }
            //
            // Need to add some defensive code in case the Control Panel doesn't match the driver. 
            //
            if (cjIn < sizeof(NVTWINVIEWDATA))
            {
                DISPDBG((1, "DrvEscape - NV_ESC_FORCE_SAVE_SETTINGS error: cjIn: 0x%x", cjIn));
                return(FALSE);
            }
            nvDataIn = (NVTWINVIEWDATA *)pvIn;
            PrintTwinViewData("DataInput", 1, nvDataIn, ppdev);

            //
            // Find the saved settings slot for the requested device combo
            //
            pFind = pFindSaveSettings(ppdev, NULL, nvDataIn);
            if (pFind == NULL)
            {
                DISPDBG((1,"Something wrong. pFindSaveSettings() returned failure"));
                // How do I pass an error value back to control panel here?
                return(TRUE);
            }
        
            //
            // We found the saved settings. Now Copy the passed in data into the slot.
            //
            *pFind = *nvDataIn;

            //
            // Write the table back to the registry.
            //
            vWriteSaveSettings(ppdev);
            return(TRUE);
        }
        break;

    case NV_ESC_DISPLAY_ICON:
        {
        DISPLAY_ICON_DATA_TYPE * pInfo;
        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(DISPLAY_ICON_DATA_TYPE))
            {
            DISPDBG((0, "DrvEscape - cant NV_ESC_DISPLAY_ICON"));
            return(FALSE);
            }
        DISPDBG((1, "DrvEscape - NV_ESC_DISPLAY_ICON"));
        pInfo = (DISPLAY_ICON_DATA_TYPE *)pvIn;
        return(TRUE);
        }
        break;

    case NV_ESC_HIDE_ICON:
        {
            if (ppdev == NULL)
            {
                DISPDBG((0, "DrvEscape - cant NV_ESC_HIDE_ICON:"));
                return(FALSE);
            }
            DISPDBG((1, "DrvEscape - NV_ESC_HIDE_ICON"));
            return(TRUE);
        }
        break;

    case NV_ESC_DISABLE_HW_CURSOR:
        {
            if (ppdev == NULL || pvIn == NULL)
            {
                DISPDBG((0, "DrvEscape - Incorrect param to disable HW cursor"));
                return(FALSE);
            }
            if(*(ULONG *)pvIn == FALSE)
            {
                ppdev->flCaps &= ~CAPS_SW_POINTER;
                DISPDBG((1, "DrvEscape - enable HW cursor"));
            }
            else
            {
                ppdev->flCaps |= CAPS_SW_POINTER;
                DISPDBG((1, "DrvEscape - disable HW cursor"));
            }
            return(TRUE);
        }
        break;

   case NV_ESC_VALIDATE_DEVICE_MODE:
      {
        if (ppdev == NULL ||
            pvIn  == NULL || cjIn  != sizeof(VALMODEXTR) ||
            pvOut == NULL || cjOut != sizeof(DWORD))
            {
            DISPDBG((2, "DrvEscape - cant NV_ESC_VALIDATE_DEVICE_MODE"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESC_VALIDATE_DEVICE_MODE"));

        if(!nvDoValidateDeviceModeEsc(ppdev, (VALMODEXTR *)pvIn, (DWORD *) pvOut)) {
           return(FALSE);
        }
        return(TRUE);
      }
      break;


   // - Added to provide id of the board and type
   case NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER:
      {
        if (ppdev == NULL ||
            pvOut == NULL || cjOut != 2 * sizeof(DWORD)) // Two DWORDs
            {
            DISPDBG((2, "DrvEscape - cant NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER"));

        // - Store the ESC value back in the 1st DWORD
        ((DWORD *)pvOut)[0] = NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER;

        // - Store the nvidia device class in the second DWORD
        if(!nvGetDisplayDeviceClass(ppdev, &((DWORD *)pvOut)[1])) {
           return(FALSE);
        }

        return(TRUE);
      }
      break;


#ifdef   NV_ESCAPE_ID
   // - Added to positive id of nvidia drivers
   case NV_ESCAPE_ID:
      {
        if (ppdev == NULL ||
            pvOut == NULL || cjOut != 1 * sizeof(DWORD))
            {
            DISPDBG((2, "DrvEscape - cant NV_ESCAPE_ID"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESCAPE_ID"));

        // - Store the NV_ESCAPE_ID_RETURN value in the 1st DWORD
        ((DWORD *)pvOut)[0] = NV_ESCAPE_ID_RETURN;
        return(TRUE);
      }
      break;
#endif

   case NV_ESC_RM_I2C_ACCESS:
      {

         NVOS_I2C_ACCESS_PARAMS *inParms, *outParms;
         ULONG ReturnedDataLength;

         CHECK_PDEV_NULL("I2C_ACCESS");
         CHECK_IN_OUT_SIZE("I2C_ACCESS", sizeof(NVOS_I2C_ACCESS_PARAMS), sizeof(NVOS_I2C_ACCESS_PARAMS));

         inParms  = (NVOS_I2C_ACCESS_PARAMS *)pvIn;
         outParms = (NVOS_I2C_ACCESS_PARAMS *)pvOut;

         if( EngDeviceIoControl( ppdev->hDriver,
                                IOCTL_NV04_I2C_ACCESS,
                                pvIn,
                                sizeof(NVOS_I2C_ACCESS_PARAMS),
                                pvOut,
                                sizeof(NVOS_I2C_ACCESS_PARAMS),
                                &ReturnedDataLength) ) {

            // The IOCTL failed, so return fail
            return(FALSE);
         }

         // Make sure we got what we wanted, at least size wise
         if(ReturnedDataLength != sizeof(NVOS_I2C_ACCESS_PARAMS))
            return(FALSE);

         return(TRUE);
      }
      break;

      case ESC_NV_MAP_USER:
        {
        // Setup the parms
        NV_SYSMEM_SHARE_MEMORY *sysmemIn;

        CHECK_PDEV_NULL("MAP_USER");

        sysmemIn = (NV_SYSMEM_SHARE_MEMORY *)pvIn;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_TO_USER,
                               sysmemIn,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               (NV_SYSMEM_SHARE_MEMORY *)pvOut,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               &returnedDataLength))
            {
            DISPDBG((2, "DrvEscape - can't map address"));
            return(FALSE);
            }
            // Add some clean-up registering code.

        return(TRUE);
        }
        break;

    case ESC_NV_UNMAP_USER:
        {
        NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;

        CHECK_PDEV_NULL("UNMAP_PFIFO_USER");

        sysmemShareMemoryIn = *(NV_SYSMEM_SHARE_MEMORY *)pvIn;
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_FROM_USER,
                               &sysmemShareMemoryIn,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               (PULONG) &sysmemShareMemoryOut,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               &returnedDataLength))
            {
            DISPDBG((2, "DrvEscape - can't unmap NV PFIFO"));
            return(FALSE);
            }
        return(TRUE);
        }
        break;

#ifdef USE_WKS_ELSA_TOOLS
    case ESC_ELSA_TOOLS:
    {
        // Only support the interface on a QUADRO piece
        if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)
        {
            return ((ULONG)lEscapeTools(pso, cjIn, pvIn, cjOut, pvOut));
        }
        // not supported on this device -> defaults to FALSE
        break;
    }
#endif //USE_WKS_ELSA_TOOLS

    case ESC_NV_WKS_APP_SUPPORT:
    {
        return ((ULONG)lWksAppSupport(pso, cjIn, pvIn, cjOut, pvOut));
        break;
    }

    default:
        break;
    }

#endif  // >= NT 4.x
    return (ULONG)FALSE;
    }

static ULONG DoOpenGLEscapeCommand(PPDEV ppdev, PVOID pvIn, PVOID pvOut)
{
    NV_OPENGL_COMMAND *inCommand;
    ULONG             *outPtr = NULL;
    LONG              status;
    ULONG             ulRet = FALSE;

    ASSERT(ppdev);

    inCommand = (NV_OPENGL_COMMAND *)pvIn;
    try
        {
        ppdev->numDevices = inCommand->numDevices;
        }
    except(EXCEPTION_EXECUTE_HANDLER)
        {
        status = GetExceptionCode();
        DISPDBG((1, "DoOpenGLEscapeCommand: exception = 0x%lx", status));
        return(1 + (ULONG)FALSE);
        }

#if defined(_WIN64)
    if (!EngSaveFloatingPointState(ppdev->fpState, ppdev->fpStateSize))
        {
        DISPDBG((1, "EngSaveFloatingPointState failed"));
        return(1 + (ULONG)FALSE);
        }
#endif

    switch(inCommand->command)
    {
#if (NVARCH >= 0x4)
        case ESC_NV_OPENGL_COMMAND:
            // Call back to shared library to execute a command
            if (NV_OglOperation(ppdev,
                                inCommand->hWnd,
                                inCommand->hDC,
                                (__GLNVoperation*)inCommand->other)) {
                ulRet = ((ULONG)TRUE);
            } else {
                ulRet = ((ULONG)FALSE);
            }
            break;
        case ESC_NV_OPENGL_SYNC_CHANNEL:
            // force a channel sync when GDI gets called again for rendering
            ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
            ppdev->NVFreeCount = 0;
            ppdev->pfnWaitForChannelSwitch(ppdev);
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_SHARED_LIBRARY_SIZES:
            {
            extern int sizeOfState;
            extern int sizeOfDrawablePrivate;
            int *sizes = (int *)inCommand->other;

                if (sizes[0] == sizeOfState && // __GLNVstate
                    sizes[1] == sizeOfDrawablePrivate)  // __GLdrawablePrivate
                    {
                    ulRet = ((ULONG)TRUE);
                    break;
                    }
                else
                    {
                    ulRet = ((ULONG)FALSE);
                    break;
                    }
                ulRet = ((ULONG)FALSE);
            }
            break;
        case ESC_NV_OPENGL_SUPPORT:
            if (OglSupportEnabled(ppdev) == (ULONG)TRUE)
                {
                if (inCommand->NVSignature == NV_SIGNATURE)
                    {
                    ulRet = ((ULONG)TRUE);
                    break;
                    }
                else
                    {
                    ulRet = ((ULONG)FALSE);
                    break;
                    }
                }
            ulRet = ((ULONG)FALSE);
            break;
        case ESC_NV_OPENGL_REGISTER_RM_CLIENT:
            OglAcquireGlobalMutex();
            OglRegisterRmClient(ppdev, PtrToUlong(inCommand->other));
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_UNREGISTER_RM_CLIENT:
            OglAcquireGlobalMutex();
            OglUnRegisterRmClient(ppdev, PtrToUlong(inCommand->other));
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_DESTROY_DRAWABLE:
            OglAcquireGlobalMutex();
            DestroyDrawableClientInfo(ppdev, inCommand->hWnd, inCommand->hDC, TRUE);
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_START_STATE_CLIENT_TRACKING:
            {
            OglAcquireGlobalMutex();
            ulRet = CreateContextClientInfo(ppdev, inCommand->hWnd, inCommand->hClient);
            OglReleaseGlobalMutex();
            }
            break;
        case ESC_NV_OPENGL_STOP_STATE_CLIENT_TRACKING:
            OglAcquireGlobalMutex();
            DestroyContextClientInfo(ppdev, inCommand->hClient, TRUE);
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_ALLOC_SHARED_MEMORY:
            {
            void *globalData, *pfifoAddress, *pbusAddress;

            OglAcquireGlobalMutex();
            CreateSharedClientInfo(ppdev, inCommand->hClient, inCommand->processHandle, &globalData, &pfifoAddress, &pbusAddress);
            ((PVOID *)pvOut)[0] = globalData;
            ((PVOID *)pvOut)[1] = pfifoAddress;
            ((PVOID *)pvOut)[2] = pbusAddress;
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            }
            break;
        case ESC_NV_OPENGL_FREE_SHARED_MEMORY:
            OglAcquireGlobalMutex();
            DestroySharedClientInfo(ppdev, inCommand->hClient, inCommand->processHandle, inCommand->globalData, TRUE);
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_GET_DISPLAY_PITCH:
            ((ULONG *)pvOut)[0] = (ULONG)ppdev->lDelta;
            break;
        case ESC_NV4_OPENGL_SWAP_BUFFERS:
            {
            __GLNVswapInfo *swapInfo = (__GLNVswapInfo *)inCommand->other;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV4_OglSwapBuffers(ppdev,
                                       inCommand->hWnd,
                                       inCommand->hDC,
                                       swapInfo->hClient,
                                       swapInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            break;
            }
        case ESC_NV_OPENGL_SWAP_BUFFERS:
            {
            __GLNVswapInfo *swapInfo = (__GLNVswapInfo *)inCommand->other;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV_OglSwapBuffers(ppdev,
                                      inCommand->hWnd,
                                      inCommand->hDC,
                                      swapInfo->hClient,
                                      swapInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            break;
            }
        case ESC_NV_OPENGL_INIT_STATE:
            {
            NV_OglInitState(ppdev, inCommand->other);
            ulRet = ((ULONG)TRUE);
            break;
            }

        case ESC_NV_OPENGL_OVERLAY_MERGEBLIT:
        {
            __GLNVoverlayMergeBlitInfo *mergeInfo = (__GLNVoverlayMergeBlitInfo *)inCommand->other;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV_OglOverlayMergeBlit(ppdev,
                                           inCommand->hWnd,
                                           inCommand->hDC,
                                           mergeInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            break;
        }

        // this is used by W2K in DrvDescribePixelFormat
        case ESC_NV_OPENGL_PFD_CHECK:
        {
            ULONG *pulPfdCheckFlags = pvOut;           
            *pulPfdCheckFlags = 0;

            ulRet = bOglPfdCheckFlags(ppdev, pulPfdCheckFlags) ? 1 : (ULONG)-1;
            break;
        }
#endif // (NVARCH >= 0x4)
        case ESC_NV_OPENGL_PURGE_DEVICE_BITMAP:
            {
            ((ULONG *)pvOut)[0] = (ULONG)0; // means nothing got punted
            if (ppdev->cbGdiHeap)   // contains #bytes allocated by GDI
                {
                bMoveAllDfbsFromOffscreenToDibs(ppdev);
                ((ULONG *)pvOut)[0] = (ULONG)1; // means something got punted
                }
            ulRet = (ULONG) TRUE;
            break;
            }
        case ESC_NV4_OPENGL_FLUSH:
            {
            __GLNVflushInfo *flushInfo = (__GLNVflushInfo *)inCommand->other;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV4_OglFlushClipped(ppdev,
                                        inCommand->hWnd,
                                        inCommand->hDC,
                                        flushInfo->hClient,
                                        flushInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            break;
            }
        case ESC_NV_OPENGL_FLUSH:
            {
#if (NVARCH >= 0x4)
            __GLNVflushInfo *flushInfo = (__GLNVflushInfo *)inCommand->other;
#endif // (NVARCH >= 0x4)

            ulRet = (ULONG) FALSE;

#if (NVARCH >= 0x4)
            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV_OglFlushClipped(ppdev,
                                       inCommand->hWnd,
                                       inCommand->hDC,
                                       flushInfo->hClient,
                                       flushInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
#endif // (NVARCH >= 0x4)
            break;
            }
        case ESC_NV_OPENGL_DMA_PUSH_GO_CMD:
            {
                if (ppdev == NULL || pvOut == NULL || pvIn == NULL) {
                    ulRet = ((ULONG)FALSE);
                    break;
                } else {
#ifdef NV3
                    Nv3DmaPushInfo *dmaPushInfo;
                    dmaPushInfo = (Nv3DmaPushInfo *)((Nv3DmaPushInfo *)pvIn);

                    if ((long)dmaPushInfo->put - (long)dmaPushInfo->get <= 0) {
                        ((ULONG *)pvOut)[1] = ppdev->dwGlobalModeSwitchCount;

                        ulRet = ((ULONG)FALSE);
                        break;
                    }

                    if (ppdev->cBitsPerPel == 16 &&
                        dmaPushInfo->localModeSwitchCount == ppdev->dwGlobalModeSwitchCount)
                        {
                        // on NV3 this is a DMA push kickoff escape function
                        ((ULONG *)pvOut)[0] = (ULONG)NV3_DmaPushGo(ppdev,
                            dmaPushInfo->dwChID,
                            dmaPushInfo->dwTlbPtBase,
                            dmaPushInfo->dwAddressSpace,
                            dmaPushInfo->get,
                            dmaPushInfo->put,
                            dmaPushInfo->hClient,
                            dmaPushInfo->hDevice);
                    }
#else                    
                    // on NV4 this is an engine sync escape function
                    // force a channel sync when GDI gets called again for rendering
                    ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
                    ppdev->NVFreeCount = 0;
                    ppdev->pfnWaitForChannelSwitch(ppdev);
#endif // NV3
                }
                ((ULONG *)pvOut)[1] = ppdev->dwGlobalModeSwitchCount;

                DISPDBG((2, "DrvEscape - SUCCESS!"));
            }
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_SCREEN_TO_SCREEN_SRCCOPY:
            {
            ulRet = ((ULONG)FALSE);
            }
            break;
        case ESC_NV_OPENGL_SUPPORT_ENABLED:
            {
            // This is a toggle...
            if (ppdev->bSupportOgl == (ULONG)TRUE)
                ppdev->bSupportOgl = (ULONG)FALSE;
            else
                ppdev->bSupportOgl = (ULONG)TRUE;
            ((ULONG *)pvOut)[0] = ppdev->bSupportOgl; // return current value
            ulRet = ((ULONG)TRUE);
            }
            break;
        case ESC_NV_OPENGL_SET_DAC_BASE:
            ppdev->pfnAcquireOglMutex(ppdev);

            NvRestoreDacs(ppdev);

            ppdev->pfnReleaseOglMutex(ppdev);

            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_CPUBLIT:
            {
                __GLNvCpuBltData * oglNvCpuBlitData;

                oglNvCpuBlitData = (__GLNvCpuBltData *)inCommand->other;

                ppdev->pfnAcquireOglMutex(ppdev);
                ulRet = OglCpuBlit(ppdev, oglNvCpuBlitData);

                ppdev->pfnReleaseOglMutex(ppdev);
            }
            break;
        case ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES:
            if (!OglAllocUnifiedSurfaces(ppdev, inCommand->other))
            {
                DISPDBG((0, "ERROR in DrvEscape: ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES-OglAllocUnifiedSurfaces failed!"));
            }
            ulRet = (ppdev->bOglSingleBackDepthSupported &&
                     ppdev->bOglSingleBackDepthCreated);
            break;
        case ESC_NV_OPENGL_FREE_UNIFIED_SURFACES:
            OglFreeUnifiedSurfaces(ppdev);
            ulRet = (ppdev->bOglSingleBackDepthSupported &&
                     !ppdev->bOglSingleBackDepthCreated);
            break;
        case ESC_NV_OPENGL_GET_SURFACE_INFO:
            {
                NvU32 fbInfo;
                outPtr = (ULONG *)pvOut;
                
                fbInfo = OglGetUnifiedSurfaceInfo(ppdev, inCommand->other);
                try
                {
                    *outPtr = (ULONG)fbInfo;
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    status = GetExceptionCode();
                    DISPDBG((1, "ESC_NV_OPENGL_GET_SURFACE_INFO: ppdev: exception = 0x%lx", status));
                }
                if (fbInfo) {
                    ulRet = ((ULONG)TRUE);
                } else {
                    ulRet = ((ULONG)FALSE);
                }
                break;
            }
        case ESC_NV_OPENGL_DID_STATUS_CHANGE:
            outPtr = (ULONG *)pvOut;
            try
                {
                NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                    {
                    clientInfo = &clientList->clientInfo;
                    }
                if (clientInfo)
                    {
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

                        clientDrawableInfo = clientInfo->clientDrawableInfo;
                        if (clientDrawableInfo->clipChangedCount != PtrToUlong(inCommand->other))

                        {
                        *outPtr = 1;
                        }
                    else
                        {
                        *outPtr = 0;
                        }
                    }
                else
                    {
                    *outPtr = -1; // client not found
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_DID_STATUS_CHANGE: ppdev: exception = 0x%lx", status));
                }
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_GET_CLIP_LIST_COUNT:
            outPtr = (ULONG *)pvOut;
            try
                {
                NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                    {
                    clientInfo = &clientList->clientInfo;
                    }
                if (clientInfo)
                    {
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

                    clientDrawableInfo = clientInfo->clientDrawableInfo;
                    *outPtr = clientDrawableInfo->numClipRects;
                    }
                else
                    {
                    *outPtr = -1; // client not found
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_CLIP_LIST_COUNT: ppdev: exception = 0x%lx", status));
                }
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_GET_CLIP_LIST:
            outPtr = (ULONG *)pvOut;
            try
                {
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                    {
                    NV_OPENGL_CLIP_LIST_DATA *nvClipList;
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;
                    int       i, rgnDataSize;
                    LPRGNDATA rgnData = NULL;
                    RECTL     *rectList = NULL, *rect = NULL;
                    static RECTL nullRect = { 0,0,0,0 };

                    clientDrawableInfo = clientList->clientInfo.clientDrawableInfo;
                    nvClipList = (NV_OPENGL_CLIP_LIST_DATA *)inCommand->other;

                    rect        = (RECTL *)nvClipList->rect; // bounds rectangle
                    rgnDataSize = sizeof(RGNDATAHEADER) + (clientDrawableInfo->numClipRects * sizeof(RECT));
                    rgnData     = (LPRGNDATA)nvClipList->rgnData;

                    if (rgnDataSize > nvClipList->rgnDataSize)
                        {
                        *outPtr = rgnDataSize;  // Insufficient space--return space needed.
                        }
                    else
                        {
                        rgnDataSize           = nvClipList->rgnDataSize;
                        rgnData->rdh.dwSize   = sizeof(RGNDATAHEADER);
                        rgnData->rdh.iType    = RDH_RECTANGLES;
                        rgnData->rdh.nCount   = clientDrawableInfo->numClipRects;
                        rgnData->rdh.nRgnSize = rgnDataSize;

                        rgnData->rdh.rcBound = clientDrawableInfo->rect;
                        rectList = (RECTL *)&rgnData->rdh.rcBound;
                        if (rectList->left >= rectList->right || rectList->top >= rectList->bottom)
                            {
                            // NULL clip list
                            rgnData->rdh.nCount = 0;
                            *rectList = nullRect; // rgnData->rdh.rcBound set to NULL rectangle
                            }

                        rectList = (RECTL *)&rgnData->Buffer;
                        if ((int)rgnData->rdh.nCount <= 0)
                            {
                            rectList[0] = nullRect;
                            }
                        else
                            {
                            for (i = 0; i < (int)rgnData->rdh.nCount; i++)
                                {
                                rectList[i] = clientDrawableInfo->copyWindowRect[i];
                                if (rectList[i].left >= rectList[i].right ||
                                    rectList[i].top >= rectList[i].bottom)
                                    {
                                    rectList[i] = nullRect;
                                    }
                                }
                            }

                        nvClipList->clipChangedCount = clientDrawableInfo->clipChangedCount;
                        *outPtr = 1;
                        }
                    }
                else
                    {
                    *outPtr = -1; // client not found
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_CLIP_LIST: ppdev: exception = 0x%lx", status));
                }
            ulRet = ((ULONG)TRUE);
            break;

        case ESC_NV_OPENGL_SET_LAYER_PALETTE:
            ulRet = OglSetLayerPalette(inCommand->other);
            break;

        case ESC_NV_OPENGL_GET_LAYER_PALETTE:
            ulRet = OglGetLayerPalette(inCommand->other);
            break;

        default:
            ulRet = ((ULONG)FALSE);
            break;
    }

#if defined(_WIN64)
    EngRestoreFloatingPointState(ppdev->fpState);
#endif

    // Offset the return value by +1 so that the ESC_NV_OPENGL_ESCAPE escape handler
    // always returns >0, so a zero return from ExtEscape() will indicate a "hard"
    // GDI error.
    return(ulRet + 1);
}


//*************************************************************************
// OglSupportEnabled
// 
// returns TRUE if hw accelerated OpenGL is supported and allowed.
//*************************************************************************
ULONG OglSupportEnabled(PDEV *ppdev)
{
    if (   (ppdev->bSupportOgl == (ULONG)TRUE)         // sw enable/disable
        && (NULL != ppdev->pOglServer)                 // need ogl server data
        && OglCheckForClientDll(ppdev) == (ULONG)TRUE) // need ICD dll
        {
        return((ULONG)TRUE);
        }
    return((ULONG)FALSE);
}

/*
 * This function checks to see if the OpenGL driver is on
 * the system.  If it is then we can return TRUE.  If is
 * isn't then we return FALSE.  This code was added for NT5
 * because Microsoft reported a bug that we claimed to run
 * OpenGL but the client side DLL didn't exist.  But
 * Microsoft wouldn't let us ship the DLL.  This code became
 * old when Microsoft decided to let NVidia ship the OpenGL
 * client side DLL.
 */
static ULONG OglCheckForClientDll(PDEV *ppdev)
{
#if 0
    return((ULONG)TRUE);
#else
    unsigned char oglDllName[MAX_PATH + 1];
    HANDLE        oglDllHandle;

#ifdef NV3
    (void)wcscpy((wchar_t *)oglDllName, OGL_CLIENT_DLL_NAME_NV3);
#else    
    (void)wcscpy((wchar_t *)oglDllName, OGL_CLIENT_DLL_NAME_NV4);
#endif // NV3
    
    oglDllHandle = EngLoadModule((unsigned short *)&oglDllName[0]);
    if (oglDllHandle)
        {
        EngFreeModule(oglDllHandle);
        DISPDBG((2, "OglCheckForClientDll - SUCCESS!"));
        return((ULONG)TRUE);
        }
    DISPDBG((0, "OglCheckForClientDll - FAILED!"));
    return((ULONG)FALSE);
#endif
}

/******************************************************************************
 * This function does a generic CPU blit.
 * It is currently used in buffer region extension.
 * It can be optimized later by figuring out whether the blit was
 * from Mem To Screen OR Screen To Mem OR Mem To Mem.
 ******************************************************************************/
ULONG
OglCpuBlit(PDEV *ppdev, __GLNvCpuBltData *oglNVCpuBltData)
{
    BYTE *src, *dst;
    ULONG  srcStep, dstStep;
    ULONG  height, width;

    if (oglNVCpuBltData->useClipList == 0L)
    {
        src = (BYTE *)(oglNVCpuBltData->pSrcBase)
            + (oglNVCpuBltData->dwSrcTop * oglNVCpuBltData->dwSrcByteWidth)
            + (oglNVCpuBltData->dwSrcLeft * oglNVCpuBltData->dwSrcElementSize);
        dst = (BYTE *)(oglNVCpuBltData->pDstBase)
            + (oglNVCpuBltData->dwDstTop * oglNVCpuBltData->dwDstByteWidth)
            + (oglNVCpuBltData->dwDstLeft * oglNVCpuBltData->dwDstElementSize);

        srcStep = oglNVCpuBltData->dwSrcByteWidth;
        dstStep = oglNVCpuBltData->dwDstByteWidth;

        height = oglNVCpuBltData->dwHeight;
        width = oglNVCpuBltData->dwWidth * oglNVCpuBltData->dwDstElementSize;

        while (height--) {
            memcpy(dst, src, width);
            src += srcStep;
            dst += dstStep;
        }
    }
    else
    {
        /* Intersect rectangle
           (oglNVCpuBltData->dwSrcTop,
            oglNVCpuBltData->dwDstLeft,
            oglNVCpuBltData->dwSrcTop+oglNVCpuBltData->dwHeight,
            oglNVCpuBltData->dwSrcLeft+oglNVCpuBltData->dwWidth)
            with clip list using CombineRectList
            and blit each rectangle separately.
         */
    }
    oglNVCpuBltData->retStatus = TRUE;
    return ((ULONG)TRUE);
}



BOOL  nvSetDisplayDevice(PDEV *ppdev, PSETGETDEVTYPE pvIn)
{

   ULONG ReturnedDataLength;

   // - Attempt to perform the IOCTL to SET the display device
   if (
       EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VIDEO_SET_DISPLAY_DEVICE,
            pvIn,
            sizeof(SETGETDEVTYPE),
            NULL,
            0,
            &ReturnedDataLength
      )
   ) {

      // - That call burned, so return fail
      return(FALSE);
   }

   return(TRUE);

}

BOOL  nvGetDisplayDevice(PDEV *ppdev, PSETGETDEVTYPE pvIn)
{

   ULONG ReturnedDataLength;

   // - Attempt to perform the IOCTL to GET the display device
   if (
       EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VIDEO_GET_DISPLAY_DEVICE,
            NULL,
            0,
            pvIn,
            sizeof(SETGETDEVTYPE),
            &ReturnedDataLength
      )
   ) {

      // - That call burned, so return fail
      return(FALSE);
   }

   // - Make sure we got what we wanted, at least size wise
   if(ReturnedDataLength != sizeof(SETGETDEVTYPE))
      return(FALSE);

   return(TRUE);

}


BOOL __cdecl nvDoValidateDeviceModeEsc(PDEV *ppdev, VALMODEXTR *pvIn, DWORD *pvOut)
{

   ULONG ReturnedDataLength;

   // Assume that the mode is not valid just to be safe
   *(DWORD *)pvOut = FALSE;

   // - Attempt to perform the IOCTL to validate the device display mode
   if (
       EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VALIDATE_DEVICE_MODE,
            pvIn,
            sizeof(VALMODEXTR),
            pvOut,
            sizeof(DWORD),
            &ReturnedDataLength
      )
   ) {

      DISPDBG((1, "DrvEscape - nvDoValidateDeviceModeEsc FAILED"));
      // - That call burned, so return fail
      return(FALSE);
   }

   // - Make sure we got what we wanted, at least size wise
   if(ReturnedDataLength != sizeof(DWORD))
      return(FALSE);

   DISPDBG((1, "DrvEscape - nvDoValidateDeviceModeEsc PASSED"));

   return(TRUE);

}


BOOL  nvGetDisplayDeviceClass(PDEV *ppdev, ULONG *deviceclass)
{

   ULONG ReturnedDataLength;

   // - Attempt to perform the IOCTL to GET the display device
   if (
       EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER,
            NULL,
            0,
            deviceclass,
            sizeof(ULONG),
            &ReturnedDataLength
      )
   ) {

      // - That call burned, so return fail
      return(FALSE);
   }

   // - Make sure we got what we wanted, at least size wise
   if(ReturnedDataLength != sizeof(ULONG))
      return(FALSE);

   return(TRUE);

}

//
// Handles the hotkeys under NT4.0 for laptops.
// Return Value: FALSE if there was no hotkey pending. TRUE if a hotkey was pending.
// Modifies the 'ulDeviceMask' field with the hotkey device mask if a hotkey was pending. 
// 
//
BOOLEAN bHandleNT4HotKey(PPDEV ppdev, GET_DEVICE_MASK_DATA_TYPE *pInfo)
{
        NV_CFGEX_GET_HOTKEY_EVENT_PARAMS nvHotKeyEvent, nvTmp;
        ULONG ulDeviceMask;
        ULONG i, status;
        UCHAR statusByte;

        //
        // See if a NT4.0 style hotkey request is pending.
        //
        nvHotKeyEvent.status = 0;
        nvHotKeyEvent.event =  0;
        if (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                 NV_CFGEX_GET_HOTKEY_EVENT, &nvHotKeyEvent, sizeof(NV_CFGEX_GET_HOTKEY_EVENT_PARAMS))) 
        {
            DISPDBG((1, "bHandleNT4HotKey() - Cannot get HOTKEY_EVENT from RM. What to do??"));
            return(FALSE);
        }
        
        //
        // check to see if a hotkey event is really pending
        //
        if (nvHotKeyEvent.event == NV_HOTKEY_EVENT_DISPLAY_ENABLE)
        {
            //
            // Atleast one HK event is there. Extract the device mask.
            //
            ulDeviceMask = 0;
            status = nvHotKeyEvent.status;
            DISPDBG((1,"special device word from RM to be parsed: 0x%x",nvHotKeyEvent.status));
            for (i=0; i < 2; i++)
            {   
                statusByte = (UCHAR)((status >> (i * 8)) & 0xff);
                switch (statusByte)
                {
                case NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD:
                    ulDeviceMask |= BITMASK_DFP0;
                    break;
                case NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT:
                    ulDeviceMask |= BITMASK_CRT0;
                    break;
                case NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV:
                    ulDeviceMask |= BITMASK_TV0;
                    break;
                }
            }
            DISPDBG((1, "ulDeviceMask constructed: 0x%x",ulDeviceMask));
            pInfo->ulDeviceMask = ulDeviceMask;
            
            //
            // We now need to drain the event queue of the RM of any other 
            // HKs. This can happen if the user presses Fn+F5 faster than the driver can process.
            // Just as a safety measure, do it only say 50 times before bailing out.
            //
            nvTmp.event = NV_HOTKEY_EVENT_DISPLAY_ENABLE;
            i = 0;
            while (nvTmp.event != NV_HOTKEY_EVENT_NONE_PENDING && i < 50)
            {
                if (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                 NV_CFGEX_GET_HOTKEY_EVENT, &nvTmp, sizeof(NV_CFGEX_GET_HOTKEY_EVENT_PARAMS))) 
                {
                    DISPDBG((1, "bHandleNT4HotKey() - Cannot get tmp HOTKEY_EVENT from RM. What to do??"));
                    break;
                }
                i++;
            }
            DISPDBG((1,"bHandleNT4HotKey(): Successful hotkey event processed")); 
            return(TRUE);
        }
        else
        {
            //
            // Either hotkey is not supported or is not pending.
            //
            DISPDBG((1,"bHandleNT4HotKey(): no hotkey event pending: 0x%x", nvHotKeyEvent.event)); 
            return(FALSE);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\lines.c ===
//******************************************************************************
//
// Module Name: Lines.c
//
// Contains most of the required GDI line support.  Supports drawing
// lines in short 'strips' when clipping is complex or coordinates
// are too large to be drawn by the line hardware.
//
// Copyright (c) 1990-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"

//*****************************************************************************
//
//  Function:   DrvStrokePath
//
//  Routine Description:
//
//              Strokes the path.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)


    {
    PDEV*   ppdev;
    DSURF*  pdsurfDst;
    ULONG   DstOffset;
    ULONG   DstStride;
    BOOL    result;
    SURFOBJ*    PuntPtr;
    ULONG       *DstBits;
    ULONG       *ScreenBitmap;


    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Set linear offset and stride for destination buffers
    //**************************************************************************

    pdsurfDst = (DSURF*) pso->dhsurf;    // May be NULL since we created the


    //**************************************************************************
    //  Fixes case where driver is called in full screen DOS during STRESS tests.
    //  In this case, GDI is allowed to call us to update DFBs that are stored in
    //  system memory. 
    //**************************************************************************

    if(!ppdev->bEnabled)
        {
        goto ENG_STROKE_PATH_IT;        
        }


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowPath(ppdev,pso,ppo,pco);
    }

    
    if (  (pdsurfDst != 0) && (pdsurfDst->dt == DT_SCREEN)  )
        {
        DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
        DstStride = pdsurfDst->LinearStride;
        }

    else
        {
        DstOffset = ppdev->ulPrimarySurfaceOffset;
        DstStride = ppdev->lDelta;
        }

    //**************************************************************************
    // Check if this is a device managed surface
    //**************************************************************************

    if (pdsurfDst !=0)
    {

        //**********************************************************************
        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:
        //**********************************************************************

        if (pdsurfDst->dt == DT_DIB)
        {
            //******************************************************************
            // NOTE: We use pdsurf->pso, NOT just pso, because this is
            //       a DFB that exists in system memory.
            //******************************************************************
            ppdev->pfnWaitEngineBusy(ppdev);
            return(ppdev->pfnEngStrokePath(pdsurfDst->pso, ppo, pco, pxo, pbo, pptlBrush,
                                           pla, mix));
        }
    }

    //**************************************************************************
    // Only handle line drawing to VRAM.  Send lines to system memory back to GDI.
    //**************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);
    if ((pdsurfDst == 0) && (DstBits != ScreenBitmap)) 
    {
        goto ENG_STROKE_PATH_IT;
    }

    (ppdev->pfnSetDestBase)(ppdev,DstOffset , DstStride);

    //*************************************************************************
    // Call the chip specific version of DrvStrokePath
    //*************************************************************************

    result =  (ppdev->pfnStrokePath)(pso,ppo,pco,pxo,pbo,pptlBrush,pla,mix)  ;

    return(result);

ENG_STROKE_PATH_IT:

//**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = pso;

    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************
    
    if (pdsurfDst !=0 )
        {
        PuntPtr         = ppdev->psoPunt;
        PuntPtr->dhsurf = 0;                    // Behave like a standard DIB
        
        if (pdsurfDst->dt == DT_SCREEN)
            {
            //*************************************************************
            // Set linear offset and stride for source and destination buffers
            //*************************************************************
            PuntPtr->sizlBitmap  = pdsurfDst->sizl;
            PuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            PuntPtr->pvBits  = pdsurfDst->LinearPtr;
            PuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            PuntPtr->lDelta  = pdsurfDst->LinearStride;
            PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //*************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //*************************************************************
            PuntPtr->sizlBitmap  = pdsurfDst->pso->sizlBitmap;
            PuntPtr->cjBits      = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            PuntPtr->pvBits  = pdsurfDst->pso->pvBits;
            PuntPtr->pvScan0 = pdsurfDst->pso->pvScan0;
            PuntPtr->lDelta  = pdsurfDst->pso->lDelta;
            PuntPtr->iBitmapFormat = pdsurfDst->pso->iBitmapFormat;
            }
        }
    ppdev->pfnWaitEngineBusy(ppdev);
    return(ppdev->pfnEngStrokePath(PuntPtr, ppo, pco, pxo, pbo, pptlBrush, pla, mix));

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\machdep.h ===
//******************************************************************************
//
// Module Name: machdep.h
//
// Macros to hide Win32/Win64 machine dependent code.
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1998 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/


#ifdef _WIN64

#define	NV_BREAKPOINT()                                                     \
{                                                                           \
    __break(0x80016);                                                       \
}

#define NV_EXCHANGE(lock, key)                                              \
{                                                                           \
    key = _InterlockedExchange(lock, key);                                  \
}

#else // _WIN32

#define	NV_BREAKPOINT()                                                     \
{                                                                           \
    __asm int 3                                                             \
}

#define NV_EXCHANGE(lock, key)                                              \
{                                                                           \
    __asm mov  ebx, key                                                     \
    __asm mov  eax, (lock)                                                  \
    __asm xchg [eax], ebx                                                   \
    __asm mov  key, ebx                                                     \
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\linkedlist.c ===
//******************************Module*Header***********************************
// Module Name: linkedlist.c
//
// Manage a linked list containing any data
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
// Usage:
// 
// 1. Define new class type in LL_CLASS_ID enum (or use LL_CLASS_ANY_CLASS).
// 2. Call bLinkedListCreate to initialize the linked list
// 3. Add items to linked list using bLinkedListAddElement
// 4. Work with the items
// 5. Remove items from linked list using bLinkedListRemoveElement
// 6. Destroy linked list with a bLinkedListDestroy call
//
// You need unique identifier (which of course can be a pointer) and optional
// data you want to store. The identifier is used to reference the data.
//
// Example:
//
// VOID vLinkedListTest(VOID)
// {
//     // NOTE: we don't need the definition of the structure for a pointer!
//     struct _LINKEDLISTHEAD *pHead;
// 
//     // create linked list head
//     pHead = NULL;
//     if (bLinkedListCreate(&pHead, LL_CLASS_MYCLASS))
//     {
//         ULONG ul;
//         PVOID pData=&ul;
// 
//         // Add elements to linked list
//         for (ul=0; ul<10; ul++)
//         {
//             if (!bLinkedListAddElement(pHead, LL_CLASS_MYCLASS, ul, pData, 0))
//                 errorhandling();
//         }
// 
//         // Work with data (e.g. get element with id 5)
//         if (bLinkedListGetElement(pHead,LL_CLASS_MYCLASS, 5, &pData))
//         {
//             ASSERT(NULL==pHead);
//             //work with pData
//         }
//         else 
//             errorhandling();
// 
//         // Remove elements from linked list
//         for (ul=0; ul<10; ul++)
//         {
//             if (!bLinkedListRemoveElement(pHead,LL_CLASS_MYCLASS,ul))
//                 errorhandling();
//         }
// 
//         // destroy linked list head linked list should be empty!
//         bLinkedListDestroy(&pHead);
//         ASSERT(NULL==pHead);
//     }
// }
//
//
//
//******************************************************************************

// import
#include "precomp.h"
#include "driver.h"

// export
#include "linkedlist.h"

//*************************************************************************
// LINKEDLIST
// 
// structure defines one double linked node containing data of type ClassID
// with unique identifier ulIdent.
//*************************************************************************
typedef struct _LINKEDLIST
{
    LL_CLASS_ID         ClassID;            // Type of data 
    ULONG_PTR           ulIdent;            // unique identifier for data (can be pointer)
    PVOID               pData;              // poiter to any kind of data
    struct _LINKEDLIST *pPrev;              // previous element in linked list or NULL if there is none
    struct _LINKEDLIST *pNext;              // next element in linked list or NULL if there is none
    ULONG               ulAllocatedSize;    // 0 if pData is allocated outside, != 0 if allocated in this module
    ULONG               ulReferenceCount;   // number of references to this node
} LINKEDLIST;


//*************************************************************************
// LINKEDLISTHEAD
// 
// head to double linked list of any data. If ClassID is set to 
// LL_CLASS_ANY_CLASS the linked list can store any class. If it is set to
// something else out of the enum LL_CLASS_ID it can only store this type.
//*************************************************************************
typedef struct _LINKEDLISTHEAD
{
    ULONG        ulMagic;         // must be set to LL_MAGIC to identify a valid head
    LL_CLASS_ID  ClassID;         // specifies type of data
    LINKEDLIST  *pFirst;          // points to first element in list
    LINKEDLIST  *pLast;           // points to last element in list
    LINKEDLIST  *pCurrent;        // used internaly to handle first/get
    ULONG        ulNumberOfNodes; // total number of nodes in linked list
} LINKEDLISTHEAD;

#define LL_MAGIC    'derf'        // magic value to check validity of linked list header


//******************************************************************************
//
// Internal functions
//

//*************************************************************************
// bLLValidList
// 
// returns TRUE if the linked list to which pAnchor is pointing is a valid 
// linked list. Returns FALSE if it is invalid or corrupted.
//
// NOTE: As we access the pointers, we will crash if they are invalid!
//*************************************************************************
BOOL bLLValidList(
    IN LINKEDLISTHEAD *pAnchor)
{
    LINKEDLIST *pNode         = NULL;
    LINKEDLIST *pNodeLast     = NULL;
    ULONG       ulCount       = 0;
    BOOL        bFoundCurrent = FALSE;
    BOOL        bRet          = FALSE;

    //
    // Check pAnchor and base members
    //

    if (NULL==pAnchor)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor==NULL"));
        goto Exit;
    }

    if (LL_MAGIC != pAnchor->ulMagic)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor invalid ulMagic"));
        goto Exit;
    }

    if (LL_CLASS_INVALID == pAnchor->ClassID)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor invalid ClassID"));
        goto Exit;
    }


    //
    // Test simple conditions with pFirst and pLast depending on number of stored nodes
    //

    if (   (0 == pAnchor->ulNumberOfNodes)
        && ( (NULL != pAnchor->pFirst) || (NULL != pAnchor->pLast) || (NULL != pAnchor->pCurrent)  ) )
    {
        DISPDBG((0, "ERROR in linked list: 0 nodes but pointers!= NULL (pLast:0x%p, pFirst:0x%p, pCurrent:0x%p)", pAnchor->pFirst, pAnchor->pLast, pAnchor->pCurrent));
        goto Exit;
    }

    if (   (1 == pAnchor->ulNumberOfNodes)
        && (pAnchor->pFirst != pAnchor->pLast) )
    {
        DISPDBG((0, "ERROR in linked list: 1 node but first!=last (pLast:0x%p, pFirst:0x%p)", pAnchor->pFirst, pAnchor->pLast));
        goto Exit;
    }

    if (   (0 != pAnchor->ulNumberOfNodes)
        && (   (pAnchor->pFirst == NULL) 
            || (pAnchor->pLast  == NULL) 
           ) )
    {
        DISPDBG((0, "ERROR in linked list: %d nodes and first and last invalid (pLast:0x%p, pFirst:0x%p)", pAnchor->ulNumberOfNodes, pAnchor->pFirst, pAnchor->pLast));
        goto Exit;
    }

    if (   (pAnchor->ulNumberOfNodes > 1)
        && (pAnchor->pFirst == pAnchor->pLast) )
    {
        DISPDBG((0, "ERROR in linked list: %d nodes but first and last invalid (pLast:0x%p, pFirst:0x%p)", pAnchor->ulNumberOfNodes, pAnchor->pFirst, pAnchor->pLast));
        goto Exit;
    }

    if (   (NULL != pAnchor->pFirst)
        && (NULL != pAnchor->pFirst->pPrev) )
    {
        DISPDBG((0, "ERROR in linked list: first element not pointing to NULL"));
        goto Exit;
    }

    if (   (NULL != pAnchor->pLast)
        && (NULL != pAnchor->pLast->pNext) )
    {
        DISPDBG((0, "ERROR in linked list: last element not pointing to NULL"));
        goto Exit;
    }

    //
    // Walk through list and check linkage
    //

    if (NULL==pAnchor->pCurrent)
        bFoundCurrent = TRUE;
    else
        bFoundCurrent = FALSE;

    for (pNode = pAnchor->pFirst, ulCount = 0, pNodeLast = NULL; 
         (NULL != pNode) && (ulCount < pAnchor->ulNumberOfNodes+5); 
         pNodeLast = pNode, pNode = pNode->pNext)
    {
        if (pNode->pPrev != pNodeLast)
        {
            DISPDBG((0, "ERROR in linked list: wrong prev linkage node %d: 0x%p==pNode->pPrev != pNodeLast==0x%p", ulCount,pNode->pPrev,pNodeLast));
            goto Exit;
        }

        if (   (pAnchor->ClassID != LL_CLASS_ANY_CLASS)
            && (pAnchor->ClassID != pNode->ClassID) )
        {
            DISPDBG((0, "ERROR in linked list: node 0x%p has wrong ClassID: 0x%x (0x%x expected)", pNode, pNode->ClassID,pAnchor->ClassID));
            goto Exit;
        }

        if (   (pNode->ulAllocatedSize != 0)
            && (NULL==pNode->pData) )
        {
            DISPDBG((0, "ERROR in linked list: node 0x%p pData NULL although %d bytes allocated", pNode, pNode->ulAllocatedSize));
            goto Exit;
        }

        if (pAnchor->pCurrent==pNode)
            bFoundCurrent=TRUE;
        ulCount++;
    }

    if (NULL != pNode)
    {
        DISPDBG((0, "ERROR in linked list: didn't find end of list after %d nodes with expected pAnchor->ulNumberOfNodes=%d", ulCount,pAnchor->ulNumberOfNodes));
        goto Exit;
    }

    if (ulCount != pAnchor->ulNumberOfNodes)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor->ulNumberOfNodes=%d not valid (found %d nodes)",pAnchor->ulNumberOfNodes, ulCount));
        goto Exit;
    }

    if (pNodeLast!=pAnchor->pLast)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor->pLast==0x%p instead of 0x%p", pAnchor->pLast,pNodeLast));
        goto Exit;
    }

    if (!bFoundCurrent)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor->pCurrent:0x%p not found",pAnchor->pCurrent));
        goto Exit;
    }

    // couldn't find an error
    bRet = TRUE;
Exit:
    return (bRet);
}


//*************************************************************************
// bLLFindNode
// 
// find node with class ClassID and identifier ulIdent and return node. 
// returns TRUE if node was found; *ppNode is valid; 
// returns FALSE if node wasn't found, *ppNode invalid (not touched)
//*************************************************************************
BOOL bLLFindNode(
    IN  LINKEDLISTHEAD *pAnchor, // root of linked list 
    IN  LL_CLASS_ID     ClassID, // class if data to look for
    IN  ULONG_PTR       ulIdent, // unique identifier of node to finde
    OUT LINKEDLIST    **ppNode)  // contains found node if return is TRUE
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID != ClassID);

    if (   (NULL != pAnchor)
        && (   (pAnchor->ClassID == ClassID)                // either specified ClassID
            || (pAnchor->ClassID == LL_CLASS_ANY_CLASS) ) ) // or list can store any class
    {
        // run through linked list
        pNode = pAnchor->pFirst;
        while (pNode)
        {
            if (   (pNode->ulIdent == ulIdent)
                && (pNode->ClassID == ClassID) )
            {                
                // found node
                *ppNode = pNode;
                bRet    = TRUE;
                break;
            }
            pNode = pNode->pNext;
        }
    }

    return (bRet);
}


//******************************************************************************
//
// Exported functions
//

//*************************************************************************
// bLinkedListCreate
// 
// must be called to create and initialize a linked list. A linked list
// can either store any data types (classes) if LL_CLASS_ANY_CLASS is 
// given or only one type.
// returns TRUE if a linked list was created and *ppAnchor contains a 
// valid head.
// returns FALSE if it failed.
//*************************************************************************
BOOL bLinkedListCreate(
    OUT LINKEDLISTHEAD **ppAnchor, // root of linked list 
    IN  LL_CLASS_ID      ClassID)  // class of linked list to create (or 
{
    LINKEDLISTHEAD *pAnchor = NULL;
    BOOL            bRet    = FALSE;

    ASSERT(NULL != ppAnchor);
    ASSERT(NULL == *ppAnchor);
    ASSERT(LL_CLASS_INVALID!=ClassID);

    pAnchor = EngAllocMem(FL_ZERO_MEMORY, sizeof(LINKEDLISTHEAD), ALLOC_TAG);

    if (NULL != pAnchor)
    {
        // initialize head
        pAnchor->ulMagic = LL_MAGIC;
        pAnchor->ClassID = ClassID;

        *ppAnchor = pAnchor;
        ASSERT(bLLValidList(*ppAnchor));
        bRet = TRUE;
    }

    return bRet;
}


//*************************************************************************
// bLinkedListDestroy
// 
// free and destroy a linked list given by ppAnchor. 
// NOTE this function doesn't free nodes!
// returns TRUE if a linked list was destroyed and *ppAnchor is invalidated
// returns FALSE if it failed.
//*************************************************************************
BOOL bLinkedListDestroy(
    IN OUT LINKEDLISTHEAD **ppAnchor)
{
    LINKEDLISTHEAD *pAnchor = NULL;
    BOOL            bRet    = FALSE;

    ASSERT(bLLValidList(*ppAnchor));

    if (NULL != ppAnchor)
    {
        ASSERT(0 == (*ppAnchor)->ulNumberOfNodes);

        (*ppAnchor)->ulMagic = 0;

        EngFreeMem(*ppAnchor);
        *ppAnchor = NULL;
        bRet = TRUE;
    }

    return bRet;
}


//*************************************************************************
// bLinkedListAddElement
// 
// adds an element with the unique identifier ulIdent and the data pData 
// to the linked list. 
//
// NOTE: ulAllocSize is reserved for a future extension, where this would
//       specify additonal memory to allocate and internaly set pData.
//       Currently there is no mehtod to return the allocated pointer.
//
// Returns TRUE if succeeded, use ulIdent and ClassID to access later.
// Returns FALSE if failed.
//*************************************************************************
BOOL bLinkedListAddElement(
    IN LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    IN ULONG_PTR       ulIdent,     // unique identifier of data (can be a pointer)
    IN PVOID           pData,       // pointer to data to store in the node, can be NULL!
    IN ULONG           ulAllocSize) // unused for now! must be 0!
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID != ClassID);
    ASSERT(0==ulAllocSize);

    if (   (NULL != pAnchor)
        && (   (pAnchor->ClassID == ClassID)
            || (pAnchor->ClassID == LL_CLASS_ANY_CLASS) ) )
    {
        //
        // Create new node at top of linked list
        //

        pNode = EngAllocMem(FL_ZERO_MEMORY, sizeof(LINKEDLIST)+ulAllocSize, ALLOC_TAG);

        if (NULL != pNode)
        {
            // Add at top of linked list
            pNode->pNext   = pAnchor->pFirst;
            pNode->pPrev   = NULL;

            // let next element point back to us
            if (NULL != pNode->pNext)
                pNode->pNext->pPrev = pNode;

            // replace anchor entries.
            pAnchor->pFirst = pNode;

            if (NULL == pAnchor->pLast)
                pAnchor->pLast = pNode;

            pAnchor->ulNumberOfNodes++;

            // Insert Data to node

            pNode->ClassID = ClassID;
            pNode->ulIdent = ulIdent;
            if (ulAllocSize)
            {
                // cannot allocate if pData already is assigned
                ASSERT(NULL == pData);

                pNode->ulAllocatedSize = ulAllocSize;
                pNode->pData           = (PVOID)(pNode+1); // data starts behind node struct
            }
            else
            {
                // remember data
                pNode->pData   = pData;
            }
            pNode->ulReferenceCount = 0;
            bRet = TRUE;
        }
    }

    ASSERT(bLLValidList(pAnchor));
    ASSERT(bRet);

    return bRet;
}


//*************************************************************************
// bLinkedListRemoveElement
// 
// remove element with unique identifier ulIdent of type ClassID from 
// linked list.
//
// Returns TRUE if succeeded.
// Returns FALSE if failed.
//*************************************************************************
BOOL bLinkedListRemoveElement(
    IN LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    IN ULONG_PTR       ulIdent)     // unique identifier of data (can be a pointer)
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);
    
    if (bLLFindNode(pAnchor, ClassID, ulIdent, &pNode))
    {
        ASSERT(NULL!=pNode);

        // Unlink from linked list
        if (NULL != pNode->pNext)
            pNode->pNext->pPrev = pNode->pPrev;

        if (NULL != pNode->pPrev)
            pNode->pPrev->pNext = pNode->pNext;

        // Unlink from anchor
        if (pAnchor->pFirst == pNode)
        {
            ASSERT(NULL==pNode->pPrev);
            pAnchor->pFirst = pNode->pNext;
        }

        if (pAnchor->pLast == pNode)
        {
            ASSERT(NULL==pNode->pNext);
            pAnchor->pLast = pNode->pPrev;
        }

        if (pAnchor->pCurrent == pNode)
        {
            pAnchor->pCurrent = pNode->pPrev;
        }

        //
        // Nothing should point to pNode anymore
        // 

        EngFreeMem(pNode);

        ASSERT(pAnchor->ulNumberOfNodes!=0);
        pAnchor->ulNumberOfNodes--;

        bRet = TRUE;
    }

    ASSERT(bLLValidList(pAnchor));
    ASSERT(bRet);

    return bRet;
}


//*************************************************************************
// bLinkedListGetElement
// 
// find and return data element of node with unique identifier ulIdent of 
// type ClassID. 
//
// Returns TRUE if element was found (and returns data if ppData != NULL). 
// Returns FALSE if element wasn't found. ppData isn't touched.
//*************************************************************************
BOOL bLinkedListGetElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    IN  ULONG_PTR       ulIdent,     // unique identifier of data (can be a pointer)
    OUT PVOID          *ppData)      // pointer to data returned if bRet==TRUE, ppData can be NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);
    
    if (bLLFindNode(pAnchor, ClassID, ulIdent, &pNode))
    {
        // node found
        if (NULL != ppData)
        {
            // if data returned increase reference counter
            pNode->ulReferenceCount++;
            *ppData = pNode->pData;
        }
        bRet = TRUE;
    }

    return bRet;
}

//*************************************************************************
// bLinkedListGetFirstElement
// bLinkedListGetNextElement
// 
// used to enumerate a linked list from top to bottom. It returns the 
// unique identifier and data of first element with type ClassID 
// within linked list. This is the initializer for a get first/next
// enumeration loop
//
// NOTE: a single or both out params can be NULL if the data isn't needed.
// NOTE 2: Use bLinkedListGetNextElement to enumerate the list after it has
//         been resetted with this bLinkedListGetFirstElement.
//
// Returns TRUE and OUT data if succeed. 
// Returns FALSE if failed or list empty, OUT data not touched
//*************************************************************************
BOOL bLinkedListGetFirstElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);

    // Initialize pCurrent with top of linked list
    pAnchor->pCurrent = pAnchor->pFirst;

    bRet = bLinkedListGetNextElement(pAnchor,ClassID, pulIdent, ppData); 

    return bRet;
}

// see above
BOOL bLinkedListGetNextElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);
    
    // start at last positon
    pNode = pAnchor->pCurrent;

    // find next element matching the type
    while (   (NULL != pNode)
           && (ClassID != pNode->ClassID)
           && (ClassID != LL_CLASS_ANY_CLASS) )
    {
        pNode = pNode->pNext;
    }

    if (NULL != pNode)
    {
        // found node
        if (pulIdent)
            *pulIdent = pNode->ulIdent;
        if (ppData)
            *ppData = pNode->pData;

        // if data returned increase reference counter
        if (pulIdent || ppData)
            pNode->ulReferenceCount++;

        // initialize current with next element (as this one already is returned)
        pAnchor->pCurrent = pNode->pNext;
        bRet = TRUE;
    }
    else
    {
        // cannot continue
        pAnchor->pCurrent = NULL;
    }

    return bRet;
}


//*************************************************************************
// bLinkedListGetLastElement
// bLinkedListGetPrevElement
// 
// same as bLinkedListGetFirstElement and bLinkedListGetNextElement runing
// from bottom to top.
//
// Returns TRUE and OUT data if succeed. 
// Returns FALSE if failed or list empty, OUT data not touched
//*************************************************************************
BOOL bLinkedListGetLastElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);

    // Initialize pCurrent with top of linked list
    pAnchor->pCurrent = pAnchor->pLast;

    bRet = bLinkedListGetPrevElement(pAnchor,ClassID, pulIdent, ppData); 

    return bRet;
}

// see above
BOOL bLinkedListGetPrevElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);

    // start at bottom of linked list
    pNode = pAnchor->pCurrent;

    // find previous element matching the type
    while (   (NULL != pNode)
           && (   (ClassID != pNode->ClassID)
               && (ClassID != LL_CLASS_ANY_CLASS) ) )
    {
        pNode = pNode->pPrev;
    }

    if (NULL != pNode)
    {
        // found node
        if (pulIdent)
            *pulIdent = pNode->ulIdent;
        if (ppData)
            *ppData = pNode->pData;

        // if data returned increase reference counter
        if (pulIdent || ppData)
            pNode->ulReferenceCount++;
        pAnchor->pCurrent = pNode->pPrev;
        bRet = TRUE;
    }
    else
    {
        pAnchor->pCurrent = NULL;
    }

    return bRet;
}


//*************************************************************************
// bLinkedListGetNewestElement
// 
// returns the data of the newset element in the linked list of given type.
//
// Returns TRUE and OUT data if succeed. 
// Returns FALSE if failed or list empty, OUT data not touched
//*************************************************************************
BOOL bLinkedListGetNewestElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    ASSERT(bLLValidList(pAnchor));
    return(bLinkedListGetFirstElement(pAnchor, ClassID, pulIdent, ppData)); 
}


//*************************************************************************
// bLinkedListGetOldestElement
// 
// returns the data of the oldest element in the linked list of given type.
//
// Returns TRUE and OUT data if succeed. 
// Returns FALSE if failed or list empty, OUT data not touched
//*************************************************************************
BOOL bLinkedListGetOldestElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    ASSERT(bLLValidList(pAnchor));
    return(bLinkedListGetLastElement(pAnchor, ClassID, pulIdent, ppData)); 
}


//*************************************************************************
// ulLinkedListGetCountOfElements
// 
// returns number of node stored in linked list that have type ClassID.
//*************************************************************************
ULONG ulLinkedListGetCountOfElements(
    LINKEDLISTHEAD *pAnchor,  // root of linked list 
    LL_CLASS_ID     ClassID)  // type of this date (must be valid for this linked list)
{
    BOOL  bFound;
    ULONG ulRet  = 0;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);

    if (   (ClassID == pAnchor->ClassID)
        && (ClassID != LL_CLASS_ANY_CLASS) )
    {
        // Only one class is stored, return all linked nodes
        ulRet = pAnchor->ulNumberOfNodes;
    }
    else if (ClassID == LL_CLASS_ANY_CLASS)
    {
        // type doesn't matter, return all nodes
        ulRet = pAnchor->ulNumberOfNodes;
    }
    else
    {
        // Only count members of class ClassID
        // need to enumerate and find nodes.
        if (bLinkedListGetFirstElement(pAnchor, ClassID, NULL, NULL))
        {
            ulRet++;

            while (bLinkedListGetNextElement(pAnchor, ClassID, NULL, NULL))
            {
                ulRet++;
            }
        }
    }

    ASSERT(ulRet <= pAnchor->ulNumberOfNodes);
    
    return ulRet;
}

// End of linkedlist.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\linkedlist.h ===
#ifndef _LINKEDLIST_H
#define _LINKEDLIST_H
//******************************Module*Header***********************************
// Module Name: linkedlist.h
//
// Manage a linked list containing any data
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

typedef enum _LL_CLASS_ID
{
    LL_CLASS_INVALID = 0,   // invalid type, do not use!
    LL_CLASS_ANY_CLASS,     // only allowed in call to bLinkedListCreate
    LL_CLASS_SAVESCREENBITS,
#ifdef NV_MAIN_MULTIMON
    LL_CLASS_OGLPDEV,
#endif
    // add more classes here
} LL_CLASS_ID;

BOOL bLinkedListCreate          (IN OUT struct _LINKEDLISTHEAD **ppAnchor, IN LL_CLASS_ID ClassID);
BOOL bLinkedListDestroy         (IN OUT struct _LINKEDLISTHEAD **ppAnchor);
BOOL bLinkedListAddElement      (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, IN  ULONG_PTR   ulIdent, PVOID pData, ULONG ulAllocSize);
BOOL bLinkedListRemoveElement   (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, IN  ULONG_PTR   ulIdent);
BOOL bLinkedListGetElement      (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, IN  ULONG_PTR   ulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetFirstElement (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetNextElement  (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetLastElement  (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetPrevElement  (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetNewestElement(IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetOldestElement(IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
ULONG ulLinkedListGetCountOfElements(IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID);

#endif // _LINKEDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\misc.c ===
//******************************Module*Header******************************\
//
// Module Name: misc.c
//
// Miscellaneous common routines.
//
// Copyright (c) 1992-1995 Microsoft Corporation
//
//*************************************************************************/

/**************************************************************************
 *                                                                        *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.          *
 *                                                                        *
 **************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL __fastcall bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\lineto.c ===
//*****************************Module*Header************************************
// 
// Module Name: Lineto.c
// 
// DrvLineTo for NV driver
// 
// Copyright (c) 1995-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"

//*****************************************************************************
//  
//  Function:   DrvLineTo
//  
//  Routine Description:
//  
//          Draws a single solid integer-only cosmetic line.
//
//  Arguments:
//  
//  Return Value:
//  
//      None.
//  
//*****************************************************************************


BOOL DrvLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)

    {
    PDEV*   ppdev;
    DSURF*  pdsurfDst;
    ULONG   DstOffset;
    ULONG   DstStride;
    BOOL    result;
    SURFOBJ*    PuntPtr;

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Set linear offset and stride for source and destination buffers
    //**************************************************************************

    pdsurfDst = (DSURF*) pso->dhsurf;    // May be NULL since we created the

#if _WIN32_WINNT >= 0x0500

    //**************************************************************************
    //  Fixes case where driver is called in full screen DOS during STRESS tests.
    //  In this case, GDI is allowed to call us to update DFBs that are stored in
    //  system memory. 
    //**************************************************************************

        if(!ppdev->bEnabled)
            goto DRV_LINE_TO_IT;
#endif

    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowRect(ppdev,pso,prclBounds,pco);
    }

    
    if (  (pdsurfDst != 0) && (pdsurfDst->dt == DT_SCREEN)  )
        {
        DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
        DstStride = pdsurfDst->LinearStride;
        }
    else
        { 
        DstOffset = ppdev->ulPrimarySurfaceOffset;
        DstStride = ppdev->lDelta;
        }
    
    (ppdev->pfnSetDestBase)(ppdev,DstOffset , DstStride);


    //*************************************************************************
    // Call the chip specific version of DrvLineTo
    //*************************************************************************

    result =  (ppdev->pfnLineTo)(pso,pco,pbo,x1,y1,x2,y2,prclBounds,mix)  ;

    return(result);

#if _WIN32_WINNT >= 0x0500

DRV_LINE_TO_IT:

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = pso;

    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************
    
    if (pdsurfDst !=0 )
        {
        PuntPtr         = ppdev->psoPunt;
        PuntPtr->dhsurf = 0;                    // Behave like a standard DIB
        
        if (pdsurfDst->dt == DT_SCREEN)
            {
            //*************************************************************
            // Set linear offset and stride for source and destination buffers
            //*************************************************************
            PuntPtr->sizlBitmap  = pdsurfDst->sizl;
            PuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            PuntPtr->pvBits  = pdsurfDst->LinearPtr;
            PuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            PuntPtr->lDelta  = pdsurfDst->LinearStride;
            PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //*************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //*************************************************************
            PuntPtr->sizlBitmap     = pdsurfDst->pso->sizlBitmap;
            PuntPtr->cjBits         = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            PuntPtr->pvBits         = pdsurfDst->pso->pvBits;
            PuntPtr->pvScan0        = pdsurfDst->pso->pvScan0;
            PuntPtr->lDelta         = pdsurfDst->pso->lDelta;
            PuntPtr->iBitmapFormat  = pdsurfDst->pso->iBitmapFormat;
            }
        }
    ppdev->pfnWaitEngineBusy(ppdev);    
    return(ppdev->pfnEngLineTo(PuntPtr, pco, pbo, x1, y1, x2, y2, prclBounds, mix));
#endif

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4muldrawfunc.c ===
//************************** Module Header *************************************
//                                                                             *
//  Module Name: nt4MulDrawFunc.c                                                   *
//                                                                             *
//  This module contains the functions that belong to the multi device wrapper *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//******************************************************************************


#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"

#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV

//******************************************************************************
//
//  MulRealizeBrush
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulRealizeBrush(BRUSHOBJ* pbo, SURFOBJ*  psoTarget,
                    SURFOBJ*  psoPattern,   SURFOBJ*  psoMask,
                    XLATEOBJ* pxlo, ULONG     iHatch)
{
    PPDEV ppdev = (PPDEV)psoTarget->dhpdev; 
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulRealizeBrush >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvRealizeBrush(pbo, psoTarget, psoPattern, psoMask, pxlo, iHatch);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ASSERT(pmdev->abdDevices[ulDev].pso);
            bRet = DrvRealizeBrush(pbo, pmdev->abdDevices[ulDev].pso, psoPattern,   psoMask, pxlo,  iHatch);
        }
    }

    DISPDBG((100, "<<< MulRealizeBrush"));
    return bRet;
}


//******************************************************************************
//
//  MulSaveScreenBits
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//  For now we don't have implemented SaveScreenBits for Multimon case
//  We may need to do it if quadbuffered stereo and opengl overlay are
//  needed in multimon case.
//  That means to return an array of all collected ulRets and to take ths array
//  as input parameter for the restore cases
//
//******************************************************************************
ULONG_PTR APIENTRY MulSaveScreenBits(
    SURFOBJ   *pso,
    ULONG      iMode,
    ULONG_PTR  ident,
    RECTL     *prcl )
{
    PPDEV      ppdev = (PPDEV)pso->dhpdev; 
    ULONG_PTR  ulRet = FALSE;

    DISPDBG((100, "MulSaveScreenBits >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        ulRet = DrvSaveScreenBits(pso, iMode, ident, prcl);
    }
#if 0 // not implemented yet
    else
    {
        switch(iMode) 
        {
        case SS_SAVE:
            // create array to contain all ulRets, call all DrvSaveScreenBits and return array
            break;
        case SS_RESTORE:
            // free array ( which is given by ident )
            break;
        case SS_FREE:
            // free array ( which is given by ident )
            break;
        default:
            ASSERT(FALSE);
            break;
        }
    }
#endif// #if 0

    DISPDBG((100, "<<< MulSaveScreenBits"));
    return ulRet;
}


//******************************************************************************
//
//  MulPaint
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulPaint(  SURFOBJ*  pso,
                CLIPOBJ*  pco,
                BRUSHOBJ* pbo,
                POINTL*   pptlBrushOrg,
                MIX       mix)
{
    PPDEV ppdev = (PPDEV)pso->dhpdev; 
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulPaint >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvPaint(pso, pco, pbo, pptlBrushOrg, mix);
    }
    else
    {
        PMDEV       pmdev = ppdev->pmdev;  
        ULONG       ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            BOARDDESC *pBoardDesc;
            ASSERT(pmdev->abdDevices[ulDev].pso);
            ASSERT(pco);

            // adjust clipobject for each single board and pass it to the coresponding board
            pBoardDesc = &pmdev->abdDevices[ulDev];

            if (DC_COMPLEX == pco->iDComplexity)
            {
                BOOL        bMoreClip;
                CLIPENUM    ce;
                LONG        l;

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                do  
                {
                    bMoreClip = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);
                    for (l = 0; l < ce.c; l++)
                    {
                        if (bRclIntersect(&pBoardDesc->pco->rclBounds, &ce.arcl[l], &pBoardDesc->rclBoard))
                        {
                            vRclSubOffset(&pBoardDesc->pco->rclBounds,
                                          &pBoardDesc->pco->rclBounds,
                                          pBoardDesc->rclBoard.left, 
                                          pBoardDesc->rclBoard.top);
                            pBoardDesc->pco->iDComplexity = DC_RECT;
                            bRet = DrvPaint( pBoardDesc->pso, pBoardDesc->pco, pbo, pptlBrushOrg, mix);
                            ASSERT(bRet);
                        }
                    }
                }
                while (bMoreClip);
            }
            else
            {
                if (bRclIntersect(&pBoardDesc->pco->rclBounds, &pco->rclBounds, &pBoardDesc->rclBoard))
                {
                    vRclSubOffset(&pBoardDesc->pco->rclBounds,
                                  &pBoardDesc->pco->rclBounds,
                                  pBoardDesc->rclBoard.left, 
                                  pBoardDesc->rclBoard.top);
                    pBoardDesc->pco->iDComplexity = DC_RECT;
                    bRet = DrvPaint( pBoardDesc->pso, pBoardDesc->pco, pbo, pptlBrushOrg, mix);
                    ASSERT(bRet);
                }
            }
        }//for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
    }

    DISPDBG((100, "<<< MulPaint"));
    return bRet;
}


//******************************************************************************
//
//  bTranslateBitBltParams
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL _inline bTranslateBitBltParams(IN  RECTL           *prclDstBoard,
                                    IN  RECTL           *prclSrcBoard,
                                    IN  ROP4            rop4,
                                    IN  RECTL           *prclClip,
                                    IN  RECTL           *prclDst,
                                    IN  POINTL          *pptlSrc,
                                    IN  POINTL          *pptlMask,
                                    IN  POINTL          *pptlBrush,
                                    OUT BLT_PARAM       *pBltParam)
{
    BOOL bRet = FALSE;
    SIZEL   sizSrcMinusDst;
    SIZEL   sizMaskMinusDst;
    RECTL   rclSrc;
    RECTL   rclMask;

    ASSERT(pBltParam);
    ASSERT(prclClip);
    ASSERT(prclDst);

    pBltParam->rclClip  = *prclClip;
    pBltParam->prclClip = &pBltParam->rclClip;

    pBltParam->rclDst   = *prclDst;
    pBltParam->prclDst  = &pBltParam->rclDst;

    pBltParam->pptlSrc  = pptlSrc;
    if (pptlSrc)
    {
        pBltParam->ptlSrc = *pptlSrc;
        pBltParam->pptlSrc = &pBltParam->ptlSrc;
    }

    pBltParam->pptlMask = pptlMask;
    if (pptlMask)
    {
        pBltParam->ptlMask = *pptlMask;
        pBltParam->pptlMask = &pBltParam->ptlMask;
    }

    pBltParam->pptlBrush= pptlBrush;
    if (pptlBrush)
    {
        pBltParam->ptlBrush = *pptlBrush;
        pBltParam->pptlBrush = &pBltParam->ptlBrush;
    }

    if (pptlMask)
    {
        sizMaskMinusDst.cx = pptlMask->x  - prclDst->left;
        sizMaskMinusDst.cy = pptlMask->y  - prclDst->top;
    }

    if (pptlSrc)
    {
        ASSERT(prclSrcBoard);

        sizSrcMinusDst.cx = pptlSrc->x  - prclDst->left;
        sizSrcMinusDst.cy = pptlSrc->y  - prclDst->top;

        if (bRclIntersect(&pBltParam->rclClip, prclClip, prclDstBoard))
        {
            if (bRclIntersect(&pBltParam->rclDst, prclDst, &pBltParam->rclClip))
            {
                pBltParam->ptlSrc.x = pBltParam->rclDst.left + sizSrcMinusDst.cx;
                pBltParam->ptlSrc.y = pBltParam->rclDst.top  + sizSrcMinusDst.cy;
                rclSrc.left         = pBltParam->ptlSrc.x;
                rclSrc.top          = pBltParam->ptlSrc.y;
                rclSrc.right        = pBltParam->ptlSrc.x + pBltParam->rclDst.right - pBltParam->rclDst.left;
                rclSrc.bottom       = pBltParam->ptlSrc.y + pBltParam->rclDst.bottom - pBltParam->rclDst.top;

                if (bRclIntersect(&rclSrc, &rclSrc, prclSrcBoard))
                {
                    vRclSubOffset(&pBltParam->rclDst, &rclSrc, sizSrcMinusDst.cx, sizSrcMinusDst.cy); 

                    vRclSubOffset(&pBltParam->rclClip, &pBltParam->rclClip, prclDstBoard->left, prclDstBoard->top); 
                    vRclSubOffset(&pBltParam->rclDst, &pBltParam->rclDst, prclDstBoard->left, prclDstBoard->top); 
                    vRclSubOffset(&rclSrc, &rclSrc, prclSrcBoard->left, prclSrcBoard->top); 
                    pBltParam->ptlSrc.x = rclSrc.left;
                    pBltParam->ptlSrc.y = rclSrc.top;

                    if (pptlMask)
                    {
                        pBltParam->ptlMask.x = pBltParam->rclDst.left + prclDstBoard->left + sizMaskMinusDst.cx;
                        pBltParam->ptlMask.y = pBltParam->rclDst.top + prclDstBoard->top + sizMaskMinusDst.cy;
                    }
                    if (pptlBrush)
                    {
                        pBltParam->ptlBrush.x = pptlBrush->x - prclDstBoard->left;
                        pBltParam->ptlBrush.y = pptlBrush->y - prclDstBoard->top;
                    }
                    bRet = TRUE;
                }
            }
        }

    }
    else
    {
        if (bRclIntersect(&pBltParam->rclClip, prclClip, prclDstBoard))
        {
            if (bRclIntersect(&pBltParam->rclDst, prclDst, &pBltParam->rclClip))
            {
                vRclSubOffset(&pBltParam->rclClip, &pBltParam->rclClip, prclDstBoard->left, prclDstBoard->top); 
                vRclSubOffset(&pBltParam->rclDst, &pBltParam->rclDst, prclDstBoard->left, prclDstBoard->top); 

                if (pptlMask)
                {
                    pBltParam->ptlMask.x = pBltParam->rclDst.left + prclDstBoard->left + sizMaskMinusDst.cx;
                    pBltParam->ptlMask.y = pBltParam->rclDst.top + prclDstBoard->top + sizMaskMinusDst.cy;
                }

                if (pptlBrush)
                {
                    pBltParam->ptlBrush.x = pptlBrush->x - prclDstBoard->left;
                    pBltParam->ptlBrush.y = pptlBrush->y - prclDstBoard->top;
                }
                bRet = TRUE;
            }
        }


    }



    return bRet;
}

//******************************************************************************
//
//  vPatchGlyphs
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
void vPatchGlyphs(GLYPHPOS*  pgp, ULONG cGlyphs, LONG xOffset, LONG yOffset)
{
    ULONG ul;
    ASSERT(pgp);

    if (xOffset != 0 || yOffset != 0)
    {
        for (ul = 0; ul < cGlyphs; ul++)
        {
            pgp[ul].ptl.x += xOffset;
            pgp[ul].ptl.y += yOffset;
        }
    }
}


//******************************************************************************
//
//  MulTextOut
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulTextOut(SURFOBJ*  pso, STROBJ*   pstro, FONTOBJ*  pfo,
                CLIPOBJ*  pco, RECTL*    prclExtra, RECTL*    prclOpaque,
                BRUSHOBJ* pboFore, BRUSHOBJ* pboOpaque, POINTL*   pptlOrg, MIX mix)
{
    PPDEV ppdev = (PPDEV)pso->dhpdev; 
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulTextOut >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore, pboOpaque, pptlOrg, mix);
    }
    else
    {
        ULONG       cDevices;
        BOOL        bMore;
        BOOL        bMoreClip;
        ENUMDEV16   enumDev16;    
        ULONG       ulDevID;
        DEVOBJ      DevObj;
        BOARDDESC  *pBoardDesc;
        RECTL       rclClip;
        CLIPENUM    ce;
        LONG        l;
        POINTL     *pptlBoardOrg;
        POINTL      ptlOrg;
        RECTL       rclBoard;
        SURFOBJ    *psoBoard;
        RECTL       rclOpaque;
        RECTL      *prclBoardOpaque;
        STROBJ      SaveStrO;
        GLYPHPOS   *pgpOriginal;
        ULONG       cGlyphOriginal;
        BOOL        bMoreGlyphs;
        ULONG       ulGlyph;
        ULONG       iDComplexity;
        BOOL        bIntersectString;
        BOOL        bIntersectOpaque;

#if DBG
        DWORD dwLvl = 100;
        DISPDBG((dwLvl, "pco    :0x%x", pco));
        DISPDBG((dwLvl, "rclBkGd: (%d, %d) - (%d, %d)", pstro->rclBkGround.left, pstro->rclBkGround.top, pstro->rclBkGround.right, pstro->rclBkGround.bottom));
        if (prclOpaque)
            DISPDBG((dwLvl, "rclOpaque: (%d, %d) - (%d, %d)", prclOpaque->left, prclOpaque->top, prclOpaque->right, prclOpaque->bottom));
        if (prclExtra)
            DISPDBG((dwLvl, "rclExtra: (%d, %d) - (%d, %d)", prclExtra->left, prclExtra->top, prclExtra->right, prclExtra->bottom));
        if (pboFore)
            DISPDBG((dwLvl, "Fore Color: 0x%x", pboFore->iSolidColor));
        if (pboOpaque)
            DISPDBG((dwLvl, "Opaque Color: 0x%x", pboOpaque->iSolidColor));
#endif

        cDevices = DEVOBJ_cEnumStart(&DevObj, pso, NULL, TRUE, CD_ANY);
        if (cDevices)
        {
            do 
            {
                bMore = DEVOBJ_bEnum(&DevObj, &enumDev16);
                for (ulDevID = 0; ulDevID < enumDev16.c; ulDevID++)
                {
                    pBoardDesc = enumDev16.apbdDevices[ulDevID];
                    psoBoard = psoGetBoardRectAndSync( IN pso, IN pBoardDesc, IN NULL, OUT &rclBoard);

                    prclBoardOpaque = prclOpaque;
                    if (prclOpaque)
                    {
                        if (bRclIntersect(&rclOpaque, prclOpaque, &rclBoard))
                        {
                            vRclSubOffset(&rclOpaque, &rclOpaque, rclBoard.left, rclBoard.top);                            
                            prclBoardOpaque = &rclOpaque;
                        }

                    }

                    pptlBoardOrg = pptlOrg;
                    if (pptlBoardOrg)
                    {
                        ptlOrg.x = pptlOrg->x - rclBoard.left;
                        ptlOrg.y = pptlOrg->y - rclBoard.top;
                        pptlBoardOrg = &ptlOrg;
                    }


                    iDComplexity = NULL == pco ? DC_TRIVIAL : pco->iDComplexity;

                    if (DC_TRIVIAL == iDComplexity || DC_RECT == iDComplexity)
                    {
                        if (DC_RECT == iDComplexity)
                        {
                            if (!bRclIntersect(&pBoardDesc->pco->rclBounds, &pco->rclBounds, &rclBoard))
                                continue;
                        }
                        else
                        {
                            pBoardDesc->pco->rclBounds        = rclBoard;    
                        }

                        // string is completely outside of clip or board rect, so go haead next board
                        bIntersectOpaque = prclOpaque ? bRclIntersect(NULL, &pBoardDesc->pco->rclBounds, prclOpaque) : FALSE;
                        bIntersectString = bRclIntersect(NULL, &pBoardDesc->pco->rclBounds, &pstro->rclBkGround);

                        if (!bIntersectString && !bIntersectOpaque)
                            continue;

                        vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, rclBoard.left, rclBoard.top);

                        if (!pstro->pgp)
                            STROBJ_vEnumStart(pstro);

                        do {
                            SaveStrO   = *pstro;

                            if (pstro->pgp)
                            {
                                bMoreGlyphs     = FALSE;
                                pgpOriginal     = pstro->pgp;
                                cGlyphOriginal  = pstro->cGlyphs;
                            }
                            else
                            {
                                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
                            }

                            vPatchGlyphs(pgpOriginal, cGlyphOriginal, -rclBoard.left, -rclBoard.top);

                            pstro->pgp      = pgpOriginal;
                            pstro->cGlyphs  = cGlyphOriginal;

                            vRclSubOffset(&pstro->rclBkGround, &pstro->rclBkGround, rclBoard.left, rclBoard.top);

                            bRet = DrvTextOut(psoBoard, pstro, pfo, pBoardDesc->pco, prclExtra, prclBoardOpaque, pboFore, pboOpaque, pptlBoardOrg, mix);

                            vPatchGlyphs(pgpOriginal, cGlyphOriginal, rclBoard.left, rclBoard.top);

                            *pstro = SaveStrO;
                        }
                        while (bMoreGlyphs);
                    }
                    else
                    {
                        if (!bRclIntersect(&pBoardDesc->pco->rclBounds, &pco->rclBounds, &pBoardDesc->rclBoard))
                            continue;

                        // string is completely outside of clip or board rect, so go haead next board
                        bIntersectOpaque = prclOpaque ? bRclIntersect(NULL, &pBoardDesc->pco->rclBounds, prclOpaque) : FALSE;
                        bIntersectString = bRclIntersect(NULL, &pBoardDesc->pco->rclBounds, &pstro->rclBkGround);

                        if (!bIntersectString && !bIntersectOpaque)
                            continue;

                        if (!pstro->pgp)
                            STROBJ_vEnumStart(pstro);

                        do {
                            SaveStrO   = *pstro;
                            if (pstro->pgp)
                            {
                                bMoreGlyphs     = FALSE;
                                pgpOriginal     = pstro->pgp;
                                cGlyphOriginal  = pstro->cGlyphs;
                            }
                            else
                            {
                                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
                            }

                            vRclSubOffset(&pstro->rclBkGround, &pstro->rclBkGround, rclBoard.left, rclBoard.top);

                            vPatchGlyphs(pgpOriginal, cGlyphOriginal, -rclBoard.left, -rclBoard.top);

                            pstro->pgp      = pgpOriginal;
                            pstro->cGlyphs  = cGlyphOriginal;

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                            do  
                            {
                                bMoreClip = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);
                                for (l = 0; l < ce.c; l++)
                                {
                                    if (bRclIntersect(&pBoardDesc->pco->rclBounds, &ce.arcl[l], &pBoardDesc->rclBoard))
                                    {
                                        vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, pBoardDesc->rclBoard.left, pBoardDesc->rclBoard.top);

                                        bRet = DrvTextOut(psoBoard, pstro, pfo, pBoardDesc->pco, prclExtra, prclBoardOpaque, pboFore, pboOpaque, pptlBoardOrg, mix);
                                    }
                                }
                            }
                            while (bMoreClip);

                            vPatchGlyphs(pgpOriginal, cGlyphOriginal, rclBoard.left, rclBoard.top);

                            *pstro = SaveStrO;
                        }
                        while (bMoreGlyphs);
                    }
                }
            }
            while (bMore && bRet);
        }
    }
    
    DISPDBG((100,"<<< MulTextOut %d", bRet));
    return bRet;
}


//******************************************************************************
//
//  ulGetBlitDirection
//
//  NT4 multiboard helper function which calculates the direction of a blit
//  to get the right clip enumeration
//
//******************************************************************************
ULONG ulGetBlitDirection( POINTL* pptlSrc, RECTL* prclDst)
{
    ULONG ulDir = CD_ANY;

    ASSERT(prclDst);

    if (pptlSrc)
    {
        if (prclDst->left < pptlSrc->x)
        {
            if (prclDst->top < pptlSrc->y)
            {
                ulDir = CD_RIGHTDOWN;
            }
            else if (prclDst->top == pptlSrc->y)
            {
                ulDir = CD_RIGHTDOWN;
            }
            else
            {
                ulDir = CD_RIGHTUP;
            }
        }
        else if (prclDst->left == pptlSrc->x)
        {
            if (prclDst->top < pptlSrc->y)
            {
                ulDir = CD_RIGHTDOWN;
            }
            else if (prclDst->top == pptlSrc->y)
            {
                ulDir = CD_ANY;
            }
            else
            {
                ulDir = CD_RIGHTUP;
            }
        }
        else
        {
            if (prclDst->top < pptlSrc->y)
            {
                ulDir = CD_LEFTDOWN;
            }
            else if (prclDst->top == pptlSrc->y)
            {
                ulDir = CD_LEFTDOWN;
            }
            else
            {
                ulDir = CD_LEFTUP;
            }
        }
    }

    return ulDir;
}


//******************************************************************************
//
//  MulBitBlt
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulBitBlt(SURFOBJ*  psoDst, SURFOBJ*  psoSrc, SURFOBJ*  psoMask,
                CLIPOBJ*  pco, XLATEOBJ* pxlo, RECTL*    prclDst,
                POINTL*   pptlSrc, POINTL*   pptlMask, BRUSHOBJ* pbo,
                POINTL*   pptlBrush, ROP4      rop4)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulBitBlt >>>"));

    if(psoDst)
        ppdev = (PPDEV)psoDst->dhpdev; 
    if(!ppdev)
    {
        ASSERT(psoSrc);
        ppdev = (PPDEV)psoSrc->dhpdev; 
    }

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
         bRet = DrvBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc, pptlMask, pbo, pptlBrush, rop4);
    }
    else
    {
        ULONG   ulDev;
        BOOL    bNeedToEnumTrg;
        BOOL    bNeedToEnumSrc;
        ULONG   cDstDevices;
        ULONG   cSrcDevices;
        BOOL    bDstMore;
        BOOL    bSrcMore;
        ENUMDEV16 enumDstDev16; 
        ENUMDEV16 enumSrcDev16; 
        ULONG   ulDstDevID;
        ULONG   ulSrcDevID;
        DEVOBJ  DstDevObj;
        DEVOBJ  SrcDevObj;
        BOARDDESC *pDstBoardDesc;
        BOARDDESC *pSrcBoardDesc;
        RECTL   rclDst;
        POINTL  ptlSrc;
        POINTL  ptlMask;
        POINTL  ptlBrush;
        BOOL    bMoreClip;
        LONG    l;
        CLIPENUM    ce;
        RECTL       rclDstBoard;
        RECTL       rclSrcBoard;
        BLT_PARAM   BltParam;
        ULONG       ulDir;

#if DBG
        DWORD dwLvl = 10;

        DISPDBG((dwLvl, "MulBitBlt >>>"));
        DISPDBG((dwLvl, "prclDst:0x%x", prclDst));
        DISPDBG((dwLvl, "pco    :0x%x", pco));
        DISPDBG((dwLvl, "rclDst: (%d, %d) - (%d, %d)", prclDst->left, prclDst->top, prclDst->right, prclDst->bottom));
        if (pbo)
            DISPDBG((dwLvl, "Color: 0x%x", pbo->iSolidColor));
#endif

        bNeedToEnumTrg = bNeedToEnumerate(psoDst);
        bNeedToEnumSrc = bNeedToEnumerate(psoSrc);

        if (bNeedToEnumTrg || bNeedToEnumSrc)
        {
            ulDir = ulGetBlitDirection(pptlSrc,prclDst);

            rclDst  = *prclDst;
            prclDst = &rclDst;

            if (pptlSrc)
            {
                ptlSrc  = *pptlSrc;
                pptlSrc = &ptlSrc;
            }

            if (pptlMask)
            {
                ptlMask  = *pptlMask;
                pptlMask = &ptlMask;
            }
            if (pptlBrush)
            {
                ptlBrush  = *pptlBrush;
                pptlBrush = &ptlBrush;
            }

            cDstDevices = DEVOBJ_cEnumStart(&DstDevObj, psoDst, NULL, TRUE, ulDir);
            if (cDstDevices)
            {
                bDstMore = TRUE;
                bRet  = TRUE;
                while (bDstMore && bRet)
                {
                    bDstMore = DEVOBJ_bEnum(&DstDevObj, &enumDstDev16);
                    for (ulDstDevID = 0; ulDstDevID < enumDstDev16.c; ulDstDevID++)
                    {
                        pDstBoardDesc = enumDstDev16.apbdDevices[ulDstDevID]; // maybe NULL on Memory bitmaps
                        BltParam.psoDst = psoGetBoardRectAndSync( IN psoDst, IN pDstBoardDesc, IN NULL, OUT &rclDstBoard);

                        cSrcDevices = DEVOBJ_cEnumStart(&SrcDevObj, psoSrc, NULL, TRUE, ulDir);
                        do
                        {
                            bSrcMore    = DEVOBJ_bEnum(&SrcDevObj, &enumSrcDev16);

                            for (ulSrcDevID = 0; ulSrcDevID < enumSrcDev16.c; ulSrcDevID++)
                            {
                                pSrcBoardDesc = enumSrcDev16.apbdDevices[ulSrcDevID];       // maybe NULL on Memory bitmaps

                                BltParam.psoSrc = psoGetBoardRectAndSync( IN psoSrc, IN pSrcBoardDesc, IN pDstBoardDesc, OUT &rclSrcBoard);
                                if (!BltParam.psoSrc)
                                    rclSrcBoard = rclDstBoard;

                                bRet = TRUE;
                                if (NULL == pco || DC_TRIVIAL == pco->iDComplexity)
                                {
                                    if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                IN &rclSrcBoard,
                                                                rop4,
                                                                &rclDstBoard,  // as rclClip
                                                                prclDst, pptlSrc, pptlMask, pptlBrush, &BltParam))
                                        bRet = DrvBitBlt(BltParam.psoDst, BltParam.psoSrc, psoMask, NULL, pxlo, 
                                                        BltParam.prclDst, BltParam.pptlSrc, BltParam.pptlMask, pbo, BltParam.pptlBrush, rop4);
                                }
                                else if (DC_RECT == pco->iDComplexity)
                                {
                                    pDstBoardDesc->pco->rclBounds = pco->rclBounds;

                                    if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                IN &rclSrcBoard,
                                                                rop4,
                                                                &pDstBoardDesc->pco->rclBounds,  // as rclClip
                                                                prclDst, pptlSrc, pptlMask, pptlBrush, &BltParam))
                                        bRet = DrvBitBlt(BltParam.psoDst, BltParam.psoSrc, psoMask, NULL, pxlo, 
                                                        BltParam.prclDst, BltParam.pptlSrc, BltParam.pptlMask, pbo, BltParam.pptlBrush, rop4);

                                }
                                else
                                {
                                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDir, 0);
                                    do  
                                    {
                                        bMoreClip = CLIPOBJ_bEnum(pco, sizeof(CLIPENUM), (ULONG*) &ce);
                                        for (l = 0; l < ce.c; l++)
                                        {
                                            if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                        IN &rclSrcBoard,
                                                                        rop4,
                                                                        &ce.arcl[l],  // as rclClip
                                                                        prclDst, pptlSrc, pptlMask, pptlBrush, &BltParam))
                                            bRet = DrvBitBlt(BltParam.psoDst, BltParam.psoSrc, psoMask, NULL, pxlo, 
                                                            BltParam.prclDst, BltParam.pptlSrc, BltParam.pptlMask, pbo, BltParam.pptlBrush, rop4);
                                        }
                                    }
                                    while (bMoreClip);
                                }
                            }
                        }
                        while (bSrcMore);
                    }
                }

            }
        }
        else
        {
            ASSERT(FALSE);
            bRet = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
    }

    ASSERT(bRet);

    DISPDBG((100, "<<< MulBitBlt - %d", bRet));

    return bRet;
}


//******************************************************************************
//
//  MulCopyBits
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulCopyBits(SURFOBJ*  psoDst, SURFOBJ*  psoSrc, CLIPOBJ*  pco,
                XLATEOBJ* pxlo, RECTL*    prclDst, POINTL*   pptlSrc)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulCopyBits >>>"));

    if(psoDst)
        ppdev = (PPDEV)psoDst->dhpdev; 
    if(!ppdev)
    {
        ASSERT(psoSrc);
        ppdev = (PPDEV)psoSrc->dhpdev; 
    }

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);
    }
    else
    {

        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        BOOL    bNeedToEnumTrg;
        BOOL    bNeedToEnumSrc;
        ULONG   cDstDevices;
        ULONG   cSrcDevices;
        BOOL    bDstMore;
        BOOL    bSrcMore;
        ENUMDEV16 enumDstDev16; 
        ENUMDEV16 enumSrcDev16; 
        ULONG   ulDstDevID;
        ULONG   ulSrcDevID;
        DEVOBJ  DstDevObj;
        DEVOBJ  SrcDevObj;
        BOARDDESC *pDstBoardDesc;
        BOARDDESC *pSrcBoardDesc;
        RECTL   rclDst;
        POINTL  ptlSrc;
        BOOL    bMoreClip;
        LONG    l;
        CLIPENUM    ce;
        RECTL       rclDstBoard;
        RECTL       rclSrcBoard;
        BLT_PARAM   BltParam;
        ULONG       ulDir;

#if DBG
        DWORD dwLvl = 10;
        DISPDBG((dwLvl, "MulCopyBits >>>"));
        DISPDBG((dwLvl, "prclDst:0x%x", prclDst));
        DISPDBG((dwLvl, "pco    :0x%x", pco));
        DISPDBG((dwLvl, "rclDst: (%d, %d) - (%d, %d)", prclDst->left, prclDst->top, prclDst->right, prclDst->bottom));
#endif

        bNeedToEnumTrg = bNeedToEnumerate(psoDst);
        bNeedToEnumSrc = bNeedToEnumerate(psoSrc);

        if (bNeedToEnumTrg || bNeedToEnumSrc)
        {
            ulDir = ulGetBlitDirection(pptlSrc,prclDst);

            rclDst  = *prclDst;
            prclDst = &rclDst;

            if (pptlSrc)
            {
                ptlSrc  = *pptlSrc;
                pptlSrc = &ptlSrc;
            }

            cDstDevices = DEVOBJ_cEnumStart(&DstDevObj, psoDst, NULL, TRUE, ulDir);
            if (cDstDevices)
            {
                bDstMore = TRUE;
                bRet  = TRUE;
                while (bDstMore && bRet)
                {
                    bDstMore = DEVOBJ_bEnum(&DstDevObj, &enumDstDev16);
                    for (ulDstDevID = 0; ulDstDevID < enumDstDev16.c; ulDstDevID++)
                    {
                        pDstBoardDesc = enumDstDev16.apbdDevices[ulDstDevID]; // maybe NULL on Memory bitmaps
                        BltParam.psoDst = psoGetBoardRectAndSync( IN psoDst, IN pDstBoardDesc, IN NULL, OUT &rclDstBoard);

                        cSrcDevices = DEVOBJ_cEnumStart(&SrcDevObj, psoSrc, NULL, TRUE, ulDir);
                        do
                        {
                            bSrcMore    = DEVOBJ_bEnum(&SrcDevObj, &enumSrcDev16);

                            for (ulSrcDevID = 0; ulSrcDevID < enumSrcDev16.c; ulSrcDevID++)
                            {
                                pSrcBoardDesc = enumSrcDev16.apbdDevices[ulSrcDevID];       // maybe NULL on Memory bitmaps

                                BltParam.psoSrc = psoGetBoardRectAndSync( IN psoSrc, IN pSrcBoardDesc, IN pDstBoardDesc, OUT &rclSrcBoard);
                                if (!BltParam.psoSrc)
                                    rclSrcBoard = rclDstBoard;

                                bRet = TRUE;
                                if (NULL == pco || DC_TRIVIAL == pco->iDComplexity)
                                {
                                    if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                IN &rclSrcBoard,
                                                                0xcccc,
                                                                &rclDstBoard,  // as rclClip
                                                                prclDst, pptlSrc, NULL, NULL, &BltParam))

                                        bRet = DrvCopyBits(BltParam.psoDst, BltParam.psoSrc, NULL, pxlo, BltParam.prclDst, BltParam.pptlSrc);
                                }
                                else if (DC_RECT == pco->iDComplexity)
                                {
                                    pDstBoardDesc->pco->rclBounds = pco->rclBounds;

                                    if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                IN &rclSrcBoard,
                                                                0xcccc,
                                                                &pDstBoardDesc->pco->rclBounds,  // as rclClip
                                                                prclDst, pptlSrc, NULL, NULL, &BltParam))
                                        bRet = DrvCopyBits(BltParam.psoDst, BltParam.psoSrc, NULL, pxlo, BltParam.prclDst, BltParam.pptlSrc);

                                }
                                else
                                {
                                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDir, 0);
                                    do  
                                    {
                                        bMoreClip = CLIPOBJ_bEnum(pco, sizeof(CLIPENUM), (ULONG*) &ce);
                                        for (l = 0; l < ce.c; l++)
                                        {
                                            if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                        IN &rclSrcBoard,
                                                                        0xcccc,
                                                                        &ce.arcl[l],  // as rclClip
                                                                        prclDst, pptlSrc, NULL, NULL, &BltParam))
                                                bRet = DrvCopyBits(BltParam.psoDst, BltParam.psoSrc, NULL, pxlo, BltParam.prclDst, BltParam.pptlSrc);
                                        }
                                    }
                                    while (bMoreClip);
                                }
                            }
                        }
                        while (bSrcMore);
                    }
                }

            }
        }
        else
        {
            ASSERT(FALSE);
            bRet = DrvCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);
        }
    }

    ASSERT(bRet);

    DISPDBG((100, "<<< MulCopyBits - %d", bRet));
    return bRet;
}


//******************************************************************************
//
//  MulStretchBlt
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulStretchBlt( SURFOBJ*            psoDst,
                    SURFOBJ*            psoSrc,
                    SURFOBJ*            psoMask,
                    CLIPOBJ*            pco,
                    XLATEOBJ*           pxlo,
                    COLORADJUSTMENT*    pca,
                    POINTL*             pptlHTOrg,
                    RECTL*              prclDst,
                    RECTL*              prclSrc,
                    POINTL*             pptlMask,
                    ULONG               iMode)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulStretchBlt >>>"));

    if(psoDst)
        ppdev = (PPDEV)psoDst->dhpdev; 
    if(!ppdev)
    {
        ASSERT(psoSrc);
        ppdev = (PPDEV)psoSrc->dhpdev; 
    }

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg, prclDst, prclSrc, pptlMask, iMode);
    }
    else
    {

        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        // have to implement this if needed
        ASSERT( FALSE );
    }
    DISPDBG((100, "<<< MulStretchBlt"));
    return TRUE;
}


#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4muldirectdraw.c ===
//************************** Module Header *************************************
//                                                                             *
//  Module Name: nt4MulDirectDraw.c                                                   *
//                                                                             *
//  This module contains the functions that belong to the multi device wrapper *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//******************************************************************************

#include "precomp.h"
#include "driver.h"

#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV

//******************************************************************************
//
//  MulEnableDirectDraw
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulEnableDirectDraw(DHPDEV dhpdev, DD_CALLBACKS*  pCallBacks,
							DD_SURFACECALLBACKS*    pSurfaceCallBacks, DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PPDEV  ppdev = (PPDEV)dhpdev;
    BOOL   bRet  = FALSE;

    DISPDBG((100, "MulEnableDirectDraw >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvEnableDirectDraw(dhpdev, pCallBacks, pSurfaceCallBacks, pPaletteCallBacks);
    }
    else
    {
        DISPDBG((1,"MulEnableDirectDraw: multiboards directDraw not implemented !"));
    }

    DISPDBG((100, "<<< MulEnableDirectDraw"));
	return bRet;
}


//******************************************************************************
//
//  MulGetDirectDrawInfo
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulGetDirectDrawInfo(DHPDEV dhpdev, DD_HALINFO* pHalInfo, DWORD* lpdwNumHeaps,
						  VIDEOMEMORY* pvmList, DWORD* lpdwNumFourCC, DWORD* lpdwFourCC)
{
    PPDEV  ppdev = (PPDEV)dhpdev;
    BOOL   bRet  = FALSE;

    DISPDBG((100, "MulGetDirectDrawInfo >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvGetDirectDrawInfo(dhpdev, pHalInfo, lpdwNumHeaps, pvmList, lpdwNumFourCC, lpdwFourCC);
    }
    else
    {
        DISPDBG((1,"MulGetDirectDrawInfo: multiboards directDraw not implemented !"));
    }

    DISPDBG((100, "<<< MulGetDirectDrawInfo - %d", bRet));
	return bRet;
}


//******************************************************************************
//
//  MulGetDirectDrawInfo
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulDisableDirectDraw(DHPDEV dhpdev)
{
    PPDEV  ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulDisableDirectDraw >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvDisableDirectDraw(dhpdev);
    }
    else
    {
        DISPDBG((1,"MulDisableDirectDraw: multiboards directDraw not implemented !"));
    }

    DISPDBG((100, "<<< MulDisableDirectDraw"));
	return ;
}

#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\multi.c ===
/******************************Module*Header*******************************\
* Module Name: multi.c
*
* Supports multiple display boards as a single virtual desktop.
*
* This is implemented by presenting to GDI a single large virtual
* display and adding a layer between GDI and the driver's Drv functions.
* For the most part, the rest of the driver outside of multi.c doesn't
* have to change much, subject to the requirements below.
*
* This implementation requires that each board have the same virtual
* resolution and colour depth (e.g., all be running 1024x768x256), and
* that the boards be arranged in a rectangular configuration.
*
* Each board has its own PDEV, and completely manages its surface
* independently, down to glyph and bitmap caching.  The Mul
* routine intercepts the DDI call, and for each board dispatches
* a Drv call with the appropriate PDEV and clip object modifications.
*
* The following support in the main driver is required:
*
* 1) The driver should be able to handle a per-surface offset.  For
*    example, if two 1024x768 displays are pasted side-by-side, the
*    right board will get drawing operations in the range (1024, 768) -
*    (2048, 768).  The driver has a (-1024, 0) surface offset to convert
*    the actual drawing on the right board to the expected (0, 0) -
*    (1024, 768).
*
*    The current driver already uses this notion to support device-format
*    bitmaps drawn in off-screen memory.
*
*    Another option would be to handle the surface offsets in this layer,
*    but then all parameters including clip objects, paths and glyph
*    enumerations would have to be adjusted here as well.
*
* 2) The main driver must be able to share realized pattern information
*    between board instances.  That is, with the current DDI specification
*    GDI entirely handles brush memory allocation via pvAllocRBrush,
*    and the driver doesn't get notified when the brush is destroyed, so
*    the driver has to keep all information about the brush for all the
*    boards in the one brush realization.  This isn't too onerous.
*
* Problems:
*
* 1) DrvSetPointerShape requires that support be consistent between all
*    board instances -- for example, one board instance cannot accept
*    a h/w cursor and the other fail it, because GDI doesn't know it would
*    have to simulate on one area of the screen and not the other.
*
* 2) CompatibleBitmaps would have to be shared between board instances.
*    This becomes a problem when the bitmaps are kept by the driver in off-
*    screen memory.
*
* Status:
*
*    This code is officially untested.  However, I know of no outstanding
*    bugs -- everything seems to just work.
*
*    Note that I haven't addressed any initialization issues; to adapt this
*    code, you will need to solve some of those problems (such as proper
*    miniport support, and a nice method for the user to control the board
*    configurations and geometry).
*
* Disclaimer:
*
*    This code is provided as sample code only.  It is not intended to
*    represent Microsoft's endorsed solution for multiple screen support.
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/

/***************************************************************************
 *                                                                         *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.           *
 *                                                                         *
 ***************************************************************************/

#include "precomp.h"

#if MULTI_BOARDS

// We change the active board to the home board after every drawing
// operation.  We do this only because the Metheus BIOS does not reset
// the active board on a soft-reset, and so the initial POST text
// would come up on whatever happened to be the last board drawn to.

#define GO_HOME(pmdev)       vSelectBoard(pmdev, pmdev->pmbHome)
#define GO_BOARD(pmdev, pmb) vSelectBoard(pmdev, pmb)

struct _MULTI_BOARD;

typedef struct _MULTI_BOARD MULTI_BOARD;    /* mb */

struct _MULTI_BOARD
{
    LONG            iHwBoard;       // Hardware board number
    LONG            iBoard;         // Sequentially allocated board number
    RECTL           rcl;            // Board's coordinates
    MULTI_BOARD*    pmbNext;        // For traversing the entire list of boards
    MULTI_BOARD*    pmbLeft;        // For traversing by direction
    MULTI_BOARD*    pmbUp;
    MULTI_BOARD*    pmbRight;
    MULTI_BOARD*    pmbDown;

    PDEV*           ppdev;          // Pointer to the board's PDEV
    SURFOBJ*        pso;            // Surface representing the board
    HSURF           hsurf;          // Handle to surface
};                                          /* mb, pmb */

typedef struct _MDEV
{
    MULTI_BOARD*    pmb;            // Where to start enumerating
    MULTI_BOARD*    pmbHome;        // Board used for full-screen
    MULTI_BOARD*    pmbUpperLeft;   // Board in upper-left corner
    MULTI_BOARD*    pmbUpperRight;
    MULTI_BOARD*    pmbLowerLeft;
    MULTI_BOARD*    pmbLowerRight;
    LONG            cxBoards;       // Number of boards per row
    LONG            cyBoards;       // Number of boards per column
    LONG            cBoards;        // Total number of boards

    MULTI_BOARD*    pmbPointer;     // Board where cursor is currently visible
    MULTI_BOARD*    pmbCurrent;     // Currently selected board (needed for
                                    //   DrvRealizeBrush)
    HDEV            hdev;           // Handle that GDI knows us by
    HSURF           hsurf;          // Handle to our virtual surface
    CLIPOBJ*        pco;            // A temporary CLIPOBJ that we can modify
    ULONG           iBitmapFormat;  // Current colour depth
    FLONG           flHooks;        // Those functions that the main driver
                                    //   is hooking

} MDEV;                                     /* mdev, pmdev */

typedef struct _PVCONSUMER
{
    PVOID       pvConsumer;
} PVCONSUMER;

typedef struct _FONT_CONSUMER
{
    LONG        cConsumers;         // Total number of boards
    PVCONSUMER  apvc[MAX_BOARDS];   // Array of structures cConsumers in length
} FONT_CONSUMER;                            /* fc, pfc */

typedef struct _BITBLTDATA
{
    RECTL       rclBounds;
    MDEV*       pmdev;

    SURFOBJ*    psoDst;
    SURFOBJ*    psoSrc;
    SURFOBJ*    psoMask;
    CLIPOBJ*    pco;
    XLATEOBJ*   pxlo;
    RECTL*      prclDst;
    POINTL*     pptlSrc;
    POINTL*     pptlMask;
    BRUSHOBJ*   pbo;
    POINTL*     pptlBrush;
    ROP4        rop4;
} BITBLTDATA;                               /* bb, pbb */

/******************************Public*Routine******************************\
* bFindBoard
*
* Returns in ppmb a pointer to the board containing the upper-left
* corner of prcl.
*
* Returns TRUE if prcl is entirely containing on one board; FALSE if
* prcl spans multiple boards.
*
\**************************************************************************/

BOOL bFindBoard(MDEV* pmdev, RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = pmdev->pmbUpperLeft;

    // It should never happen that GDI will give us a call whose bounds
    // don't intersect the virtual screen.  But so that we don't crash
    // should it ever happen, we'll return an intersection with the first
    // board -- we can assume GDI at least said the clipping was non-
    // trivial, in which case that board's display routine will realize
    // nothing had to be done:

    *ppmb = pmb;

    // First find the row:

    while (prcl->top >= pmb->rcl.bottom)
    {
        pmb = pmb->pmbDown;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // Now find the column:

    while (prcl->left >= pmb->rcl.right)
    {
        pmb = pmb->pmbRight;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // So we found the first board:

    *ppmb = pmb;

    return(prcl->right  <= pmb->rcl.right &&
           prcl->bottom <= pmb->rcl.bottom);
}

/******************************Public*Routine******************************\
* bNextBoard
*
* Returns in ppmb a pointer to the next board after intersecting prcl, going
* left-to-right then top-to-bottom.
*
* Returns TRUE if all boards intersecting prcl have been enumerated; FALSE
* if there are more boards.
*
\**************************************************************************/

BOOL bNextBoard(RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = *ppmb;

    // We'll do all the boards in a row first, remembering that the
    // bounds rectangle can extend past the end of our virtual screen:

    if ((prcl->right > pmb->rcl.right) && (pmb->pmbRight != NULL))
    {
        *ppmb = pmb->pmbRight;
        return(TRUE);
    }

    // Go to next row if need be, starting at the rcl.left:

    if ((prcl->bottom > pmb->rcl.bottom) && (pmb->pmbDown != NULL))
    {
        pmb = pmb->pmbDown;
        while ((prcl->left < pmb->rcl.left) && (pmb->pmbLeft != NULL))
        {
            pmb = pmb->pmbLeft;
        }
        *ppmb = pmb;
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* vIntersect
*
* Returns in prclOut the intersection of rectangles prcl1 and prcl2.
*
\**************************************************************************/

VOID vIntersect(RECTL* prcl1, RECTL* prcl2, RECTL* prclOut)
{
    prclOut->left   = max(prcl1->left,   prcl2->left);
    prclOut->top    = max(prcl1->top,    prcl2->top);
    prclOut->right  = min(prcl1->right,  prcl2->right);
    prclOut->bottom = min(prcl1->bottom, prcl2->bottom);
}

/******************************Public*Routine******************************\
* bVeryTemporaryInitializationCode
*
\**************************************************************************/

BOOL bVeryTemporaryInitializationCode(MDEV* pmdev)
{
    MULTI_BOARD* pmb1 = NULL;
    MULTI_BOARD* pmb2 = NULL;

    pmb1 = EngAllocMem(FL_ZERO_MEMORY, sizeof(MULTI_BOARD), ALLOC_TAG);
    pmb2 = EngAllocMem(FL_ZERO_MEMORY, sizeof(MULTI_BOARD), ALLOC_TAG);

    if ((pmb1 == NULL) || (pmb2 == NULL))
    {
        EngFreeMem(pmb1);
        EngFreeMem(pmb2);
        return(FALSE);
    }

    // Only this initialization part is hard-coded to have two monitors,
    // side-by-side.

    // Board one:

    pmb1->iHwBoard         = 0;
    pmb1->iBoard           = 0;
    pmb1->pmbNext          = pmb2;
    pmb1->pmbRight         = pmb2;

    pmdev->pmb             = pmb1;
    pmdev->pmbUpperLeft    = pmb1;
    pmdev->pmbLowerLeft    = pmb1;
    pmdev->pmbHome         = pmb1;

    // Board two:

    pmb2->iHwBoard         = 1;
    pmb2->iBoard           = 1;
    pmb2->pmbLeft          = pmb1;

    pmdev->pmbUpperRight   = pmb2;
    pmdev->pmbLowerRight   = pmb2;

    pmdev->cxBoards        = 2;
    pmdev->cyBoards        = 1;
    pmdev->cBoards         = 2;

    // Assume that the currently active board is the 'home' board:

    pmdev->pmbCurrent      = pmdev->pmbHome;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vSelectBoard
*
* Selects board pmb for drawing.  We can have only one Metheus board active
* at any time, so we have to disable the old board before enabling the new.
*
* Obviously, your hardware implementation may not require this entire
* function.  For example, you probably won't have to do this if you can
* have each board's accelerator registers mapped into separate address
* spaces.  NOTE: You'll still have to set pmdev->pmbCurrent, however,
* for DrvRealizeBrush to work!
*
\**************************************************************************/

VOID vSelectBoard(MDEV* pmdev, MULTI_BOARD* pmb)
{
    LONG iOldHwBoard;

    ASSERTDD(pmdev->pmbCurrent != NULL, "Can't have NULL pmbCurrent");
    pmdev->pmbCurrent = pmb;                             // Remember new board
}

/******************************Public*Routine******************************\
* bBoardCopy
*
* Given the BitBlt parameters in pbb, bitblt's the part of the rectangle
* on the pmbSrc board that must bitblt'ed to the pmbDst board.  Bails
* out quickly if nothing actually has to be copied.
*
* Will do a screen-to-screen blt if pmbSrc and pmbDst are the same board;
* otherwise it uses the psoTmp bitmap as temporary storage for transferring
* between the two boards.
*
* NOTE: If your hardware allows you to have all the frame buffers mapped
*       into memory simultaneously, you can avoid the 'psoTmp' bitmap
*       allocation and extra copy!
*
\**************************************************************************/

BOOL bBoardCopy(
BITBLTDATA*  pbb,
SURFOBJ*     psoTmp,
MULTI_BOARD* pmbDst,
MULTI_BOARD* pmbSrc)
{
    BOOL     b;
    RECTL    rclDst;
    LONG     dx;
    LONG     dy;
    RECTL    rclTmp;
    POINTL   ptlSrc;

    // If there's really no source board, we're guaranteed not to
    // have to copy anything from it:

    if (pmbSrc == NULL)
        return(TRUE);

    dx = pbb->prclDst->left - pbb->pptlSrc->x;
    dy = pbb->prclDst->top  - pbb->pptlSrc->y;

    // Pretend we're going to copy the entire source board's screen.
    // rclDst would be the destination rectangle:

    rclDst.left   = pmbSrc->rcl.left   + dx;
    rclDst.right  = pmbSrc->rcl.right  + dx;
    rclDst.top    = pmbSrc->rcl.top    + dy;
    rclDst.bottom = pmbSrc->rcl.bottom + dy;

    // We really want to copy only the part that overlaps the
    // destination board's screen:

    vIntersect(&pmbDst->rcl, &rclDst, &rclDst);

    // Plus we really only want to copy anything to what is contained
    // in the original destination rectangle:

    vIntersect(&pbb->rclBounds, &rclDst, &rclDst);

    // rclDst is now the destination rectangle for our call.  We'll
    // need a temporary bitmap for copying, so compute its extents:

    rclTmp.left   = 0;
    rclTmp.top    = 0;
    rclTmp.right  = rclDst.right  - rclDst.left;
    rclTmp.bottom = rclDst.bottom - rclDst.top;

    // If it's empty, we're outta here:

    if ((rclTmp.right <= 0) || (rclTmp.bottom <= 0))
        return(TRUE);

    if (pmbDst == pmbSrc)
    {
        // If the source and destination are the same board, we don't
        // need a temporary bitmap:

        psoTmp = pmbSrc->pso;
        ptlSrc = *pbb->pptlSrc;
    }
    else
    {
        ASSERTDD(psoTmp != NULL, "Need non-null bitmap");
        ASSERTDD(psoTmp->sizlBitmap.cx >= rclTmp.right, "Bitmap too small in x");
        ASSERTDD(psoTmp->sizlBitmap.cy >= rclTmp.bottom, "Bitmap too small in y");

        // Figure out the upper-left source corner corresponding to our
        // upper-left destination corner:

        ptlSrc.x = rclDst.left - dx;
        ptlSrc.y = rclDst.top  - dy;

        // Copy the rectangle from the source to the temporary bitmap:

        GO_BOARD(pbb->pmdev, pmbSrc);
        b = DrvCopyBits(psoTmp, pmbSrc->pso, NULL, NULL, &rclTmp, &ptlSrc);

        // Then get ready to do the copy from the temporary bitmap to
        // the destination:

        ptlSrc.x = pbb->prclDst->left - rclDst.left;
        ptlSrc.y = pbb->prclDst->top  - rclDst.top;
    }

    pbb->pco->rclBounds = rclDst;
    GO_BOARD(pbb->pmdev, pmbDst);
    b &= DrvBitBlt(pmbDst->pso, psoTmp, pbb->psoMask, pbb->pco, pbb->pxlo,
                   pbb->prclDst, &ptlSrc, pbb->pptlMask, pbb->pbo,
                   pbb->pptlBrush, pbb->rop4);

    return(b);
}

/******************************Public*Routine******************************\
* bBitBltBetweenBoards
*
* Handles screen-to-screen blts across multiple boards.
*
\**************************************************************************/

BOOL bBitBltBetweenBoards(
SURFOBJ*     psoDst,
SURFOBJ*     psoSrc,
SURFOBJ*     psoMask,
CLIPOBJ*     pco,
XLATEOBJ*    pxlo,
RECTL*       prclDst,
POINTL*      pptlSrc,
POINTL*      pptlMask,
BRUSHOBJ*    pbo,
POINTL*      pptlBrush,
ROP4         rop4,
RECTL*       prclUnion,     // Rectangular union of source and destination
MULTI_BOARD* pmbUnion)      // Board containing upper-left corner of prclUnion
{
    BOOL         b = TRUE;
    BITBLTDATA   bb;
    RECTL        rclOriginalBounds;
    SIZEL        sizlBoard;
    SIZEL        sizlDst;
    SIZEL        sizl;
    MULTI_BOARD* pmbSrc;
    MULTI_BOARD* pmbDst;
    LONG         dx;
    LONG         dy;
    RECTL        rclStart;

    SURFOBJ*     pso0 = NULL;   // Initialize these first off in case we
    SURFOBJ*     pso1 = NULL;   //   early-out
    SURFOBJ*     pso2 = NULL;
    SURFOBJ*     pso3 = NULL;
    HSURF        hsurf0 = 0;
    HSURF        hsurf1 = 0;

    bb.pmdev     = (MDEV*) psoDst->dhpdev;
    bb.psoDst    = psoDst;
    bb.psoSrc    = psoSrc;
    bb.psoMask   = psoMask;
    bb.pxlo      = pxlo;
    bb.prclDst   = prclDst;
    bb.pptlSrc   = pptlSrc;
    bb.pptlMask  = pptlMask;
    bb.pbo       = pbo;
    bb.pptlBrush = pptlBrush;
    bb.rop4      = rop4;
    bb.pco       = pco;
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        bb.pco = bb.pmdev->pco;

    vIntersect(&bb.pco->rclBounds, prclDst, &bb.rclBounds);
    rclOriginalBounds = bb.pco->rclBounds;

    sizlDst.cx = bb.rclBounds.right - bb.rclBounds.left;
    sizlDst.cy = bb.rclBounds.bottom - bb.rclBounds.top;

    // This really should never happen, but we'll be paranoid:

    if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
        return(TRUE);

    // Compute delta from source to destination:

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    // Figure out the size of a board:

    sizlBoard.cx = bb.pmdev->pmbUpperLeft->rcl.right;
    sizlBoard.cy = bb.pmdev->pmbUpperLeft->rcl.bottom;

    // We use temporary bitmaps as intermediaries for copying from one
    // board to another.  Note that it is much more efficient to allocate
    // on the fly, rather than keeping a dedicated bitmap around that
    // would have to be swapped in and out.

    // When the destination is close to the source, we can accomplish
    // most of the blt using screen-to-screen copies, and will need
    // only two small temporary bitmaps to temporarily hold the bits
    // that must be transferred from one board to another:

    if ((abs(dx) < (sizlBoard.cx >> 1)) && (abs(dy) < (sizlBoard.cy >> 1)))
    {
        // Create a temporary bitmap for the horizontal delta only if
        // the blt actually spans boards in the x-direction:

        if ((dx != 0) && (prclUnion->right > pmbUnion->rcl.right))
        {
            sizl.cx = min(sizlDst.cx, abs(dx));
            sizl.cy = min(sizlDst.cy, sizlBoard.cy - abs(dy));

            hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso1 = EngLockSurface(hsurf0);
            if (pso1 == NULL)
                return(FALSE);

            // Can use same temporary bitmap for section '3':

            pso3 = pso1;
        }

        // Similarly for the vertical delta:

        if ((dy != 0) && (prclUnion->bottom > pmbUnion->rcl.bottom))
        {
            sizl.cx = min(sizlDst.cx, sizlBoard.cx - abs(dx));
            sizl.cy = min(sizlDst.cy, abs(dy));

            hsurf1 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso2 = EngLockSurface(hsurf1);
            if (pso2 == NULL)
            {
                b = FALSE;
                goto OuttaHere;
            }
        }
    }
    else
    {
        // Make the bitmap the size of a board, or the size of the
        // destination rectangle, which ever is smaller:

        sizl.cx = min(sizlDst.cx, sizlBoard.cx);
        sizl.cy = min(sizlDst.cy, sizlBoard.cy);

        hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                         0, NULL);
        pso0 = EngLockSurface(hsurf0);
        if (pso0 == NULL)
            return(FALSE);

        pso1 = pso0;
        pso2 = pso0;
        pso3 = pso0;
    }

    if ((dx <= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the left:

        // Find the board containing the upper-left corner of the destination:

        pmbDst = bb.pmdev->pmbUpperLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left = pmbDst->rcl.left - dx;
        rclStart.top  = pmbDst->rcl.top  - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to left side of next lower row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else if ((dx >= 0) && (dy >= 0))
    {
        // Move the rectangle down and to the right:

        // Find the board containing the lower-right corner of the destination:

        pmbDst = bb.pmdev->pmbLowerRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to go up to right side of next upper row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }
    else if ((dx >= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the right:

        // Find the board containing the upper-right corner of the destination:

        pmbDst = bb.pmdev->pmbUpperRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.top   = pmbDst->rcl.top   - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to right side of next lower row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else
    {
        // Move the rectangle down and to the left:

        // Find the board containing the lower-left corner of the destination:

        pmbDst = bb.pmdev->pmbLowerLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left   = pmbDst->rcl.left   - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to up down to left side of next upper row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }

    GO_HOME(bb.pmdev);
    bb.pco->rclBounds = rclOriginalBounds;

OuttaHere:

    // In one case, pso0 == pso1 == pso2 == pso3, and we don't want to
    // unlock the same surface twice:

    if (pso1 != pso2)
        EngUnlockSurface(pso1);

    EngUnlockSurface(pso2);
    EngDeleteSurface(hsurf0);
    EngDeleteSurface(hsurf1);

    return(b);
}

/******************************Public*Routine******************************\
* MulGetModes
*
\**************************************************************************/

ULONG MulGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG ulRet;

    DISPDBG((5, ">> MulGetModes"));
    ulRet = DrvGetModes(hDriver, cjSize, pdm);
    DISPDBG((6, "<< MulGetModes"));

    return(ulRet);
}

/******************************Public*Routine******************************\
* MulEnablePDEV
*
\**************************************************************************/

DHPDEV MulEnablePDEV(
DEVMODEW* pDevmode,
PWSTR     pwszLogAddress,
ULONG     cPatterns,
HSURF*    ahsurfPatterns,
ULONG     cjGdiInfo,
ULONG*    pGdiInfo,
ULONG     cjDevInfo,
DEVINFO*  pDevInfo,
HDEV      hdev,
PWSTR     pwszDeviceName,
HANDLE    hDriver)
{
    MDEV*        pmdev;                // Multi-board PDEV
    PDEV*        ppdev;                // Per-board PDEV
    MULTI_BOARD* pmb;
    LONG         cx;
    LONG         cy;

    // Note that we depend on the zero initialization:

    DISPDBG((5, ">> MulEnablePDEV"));

    pmdev = EngAllocMem(FL_ZERO_MEMORY, sizeof(MDEV), ALLOC_TAG);
    if (pmdev == NULL)
        goto ReturnFailure0;

    if (!bVeryTemporaryInitializationCode(pmdev))
        goto ReturnFailure1;

    // For every board, we'll create our own PDEV and surface:

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // Initialize each board and create a surface to go with it:

        ppdev = (PDEV*) DrvEnablePDEV(pDevmode,     pwszLogAddress,
                                      cPatterns,    ahsurfPatterns,
                                      cjGdiInfo,    pGdiInfo,
                                      cjDevInfo,    pDevInfo,
                                      hdev,         pwszDeviceName,
                                      hDriver);
        if (ppdev == NULL)
            goto ReturnFailure1;

        pmb->ppdev = ppdev;
    }

    // Choose a board, any board:

    pmb = pmdev->pmbLowerLeft;

    // Get a copy of what functions we're supposed to hook, sans
    // HOOK_STRETCHBLT because I can't be bothered to write its
    // MulStretchBlt function:

    pmdev->flHooks       = pmb->ppdev->flHooks & ~HOOK_STRETCHBLT;
    pmdev->iBitmapFormat = pmb->ppdev->iBitmapFormat;

    // As part of our hard-coded initialization hack, we will simply
    // take whatever resolution was requested via the Control Panel
    // and create a two board virtual desktop, where the screens are
    // side-by-side.
    //
    // The DrvEnablePDEV function for any board has already figured
    // out what the requested mode was:

    cx = ((GDIINFO*) pGdiInfo)->ulHorzRes;
    cy = ((GDIINFO*) pGdiInfo)->ulVertRes;

    // Set up bounds for left board:

    pmb->rcl.left       = 0;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = cx;
    pmb->rcl.bottom     = cy;

    // Set up bounds for right board:

    pmb = pmb->pmbRight;

    pmb->rcl.left       = cx;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = 2 * cx;
    pmb->rcl.bottom     = cy;

    // Adjust the stuff we return back to GDI to reflect the fact that
    // we now have a double-wide display:

    ((GDIINFO*) pGdiInfo)->ulPanningHorzRes  *= 2;
    ((GDIINFO*) pGdiInfo)->ulHorzSize        *= 2;

    // With the Metheus board, since only one board can be mapped in
    // at one time, we cannot allow asynchronous pointers:

    pDevInfo->flGraphicsCaps &= ~(GCAPS_ASYNCMOVE | GCAPS_ASYNCCHANGE);
    DISPDBG((6, "<< MulEnablePDEV: Line: %d", __LINE__));

    return((DHPDEV) pmdev);

ReturnFailure1:
    MulDisablePDEV((DHPDEV) pmdev);

ReturnFailure0:
    DISPDBG((2, "Failed MulEnablePDEV"));
    DISPDBG((6, "<< MulEnablePDEV: Line: %d", __LINE__));

    return(0);
}

/******************************Public*Routine******************************\
* MulCompletePDEV
*
\**************************************************************************/

VOID MulCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    DISPDBG((5, ">> MulCompletePDEV"));
    pmdev = (MDEV*) dhpdev;
    pmdev->hdev = hdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        DrvCompletePDEV((DHPDEV) pmb->ppdev, hdev);
    }
    DISPDBG((6, "<< MulCompletePDEV"));
}

/******************************Public*Routine******************************\
* MulEnableSurface
*
\**************************************************************************/

HSURF MulEnableSurface(DHPDEV dhpdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;
    SIZEL         sizlVirtual;
    HSURF         hsurfBoard;               // Gnarly, dude!
    SURFOBJ*      psoBoard;
    DSURF*        pdsurfBoard;
    HSURF         hsurfVirtual;
    CLIPOBJ*      pco;

    DISPDBG((5, ">> MulEnableSurface"));
    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        hsurfBoard = DrvEnableSurface((DHPDEV) pmb->ppdev);
        if (hsurfBoard == 0)
            goto ReturnFailure;

        pmb->hsurf = hsurfBoard;

        // Every time we draw on a particular board, we'll refer to it
        // using this surface:

        psoBoard = EngLockSurface(hsurfBoard);
        if (psoBoard == NULL)
            goto ReturnFailure;

        pmb->pso = psoBoard;

        // There are a few things in the board's data instances that we
        // have to modify:

        pdsurfBoard = (DSURF*) psoBoard->dhsurf;

        pmb->ppdev->iBoard  =  pmb->iBoard;

        // This is sort of a hack.  Whenever we pass a call on to a board's
        // Drv function using 'pmb->pso', it has to be able to retrieve
        // it's own PDEV pointer from 'dhpdev':

        pmb->pso->dhpdev = (DHPDEV) pmb->ppdev;
    }

    // Now create the surface which the engine will use to refer to our
    // entire multi-board virtual screen:

    sizlVirtual.cx = pmdev->pmbLowerRight->rcl.right;
    sizlVirtual.cy = pmdev->pmbLowerRight->rcl.bottom;

    hsurfVirtual = EngCreateDeviceSurface((DHSURF) pmdev, sizlVirtual,
                                          pmdev->iBitmapFormat);
    if (hsurfVirtual == 0)
        goto ReturnFailure;

    pmdev->hsurf = hsurfVirtual;

    if (!EngAssociateSurface(hsurfVirtual, pmdev->hdev, pmdev->flHooks))
        goto ReturnFailure;

    // Create a temporary clip object that we can use when a drawing
    // operation spans multiple boards:

    pco = EngCreateClip();
    if (pco == NULL)
        goto ReturnFailure;

    pmdev->pco = pco;

    pmdev->pco->iDComplexity      = DC_RECT;
    pmdev->pco->iMode             = TC_RECTANGLES;
    pmdev->pco->rclBounds.left    = 0;
    pmdev->pco->rclBounds.top     = 0;
    pmdev->pco->rclBounds.right   = pmdev->pmbLowerRight->rcl.right;
    pmdev->pco->rclBounds.bottom  = pmdev->pmbLowerRight->rcl.bottom;

    DISPDBG((6, "<< MulDisableSurface: Line: %d", __LINE__));
    return(hsurfVirtual);

ReturnFailure:
    MulDisableSurface((DHPDEV) pmdev);

    DISPDBG((2, "Failed MulEnableSurface"));
    DISPDBG((6, "<< MulDisableSurface: Line: %d", __LINE__));
    return(0);
}

/******************************Public*Routine******************************\
* MulStrokePath
*
\**************************************************************************/

BOOL MulStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;
    FLOAT_LONG   elStyleState;
    DISPDBG((5, ">> MulStrokePath"));

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;
        elStyleState = pla->elStyleState;

        b = TRUE;
        do {
            // For each board, make sure the style state gets reset and
            // the path enumeration gets restarted:

            pla->elStyleState = elStyleState;
            PATHOBJ_vEnumStart(ppo);

            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla,
                                   mix);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulStrokePath: Line: %d", __LINE__));
    return(b);
}

/******************************Public*Routine******************************\
* MulFillPath
*
\**************************************************************************/

BOOL MulFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix,
FLONG     flOptions)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;
    DISPDBG((5, ">> MulFillPath"));

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            // Make sure we restart the path enumeration if need be:

            PATHOBJ_vEnumStart(ppo);
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix,
                                 flOptions);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulFillPath: Line: %d, ret: 0x%x", __LINE__, b));
    return(b);
}

/******************************Public*Routine******************************\
* MulBitBlt
*
\**************************************************************************/

BOOL MulBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    LONG         xOffset;
    LONG         yOffset;
    RECTL        rclDstBounds;
    RECTL        rclDst;

    DISPDBG((5, ">> MulBitBlt"));

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            DISPDBG((6, "<< MulBitBlt: Line: %d", __LINE__));
            return(bBitBltBetweenBoards(psoDst, psoSrc, psoMask, pco, pxlo,
                                        &rclDst, pptlSrc, pptlMask, pbo,
                                        pptlBrush, rop4, &rclBounds, pmb));

        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoSrc->dhpdev;

        // rclBounds is the source rectangle:

        rclBounds.left   = pptlSrc->x;
        rclBounds.top    = pptlSrc->y;
        rclBounds.right  = pptlSrc->x + (rclDst.right - rclDst.left);
        rclBounds.bottom = pptlSrc->y + (rclDst.bottom - rclDst.top);

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            // Offset to transform from source rectangle to destination
            // rectangle:

            xOffset = rclDst.left - pptlSrc->x;
            yOffset = rclDst.top  - pptlSrc->y;

            b = TRUE;
            do {
                // Since the screen is the source, but the clip bounds applies
                // to the destination, we have to convert our board clipping
                // information to destination coordinates:

                rclDstBounds.left   = pmb->rcl.left   + xOffset;
                rclDstBounds.right  = pmb->rcl.right  + xOffset;
                rclDstBounds.top    = pmb->rcl.top    + yOffset;
                rclDstBounds.bottom = pmb->rcl.bottom + yOffset;

                if (bIntersect(&rclOriginalBounds, &rclDstBounds, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclBounds, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulBitBlt: Line: %d, ret: 0x%x", __LINE__, b));
    return(b);
}

/******************************Public*Routine******************************\
* MulDisablePDEV
*
* Note: May be called before MulEnablePDEV successfully completed!
*
\**************************************************************************/

VOID MulDisablePDEV(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    DISPDBG((5, ">> MulDisablePDEV"));
    pmdev = (MDEV*) dhpdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        if (pmb->ppdev != NULL)
        {
            GO_BOARD(pmdev, pmb);
            DrvDisablePDEV((DHPDEV) pmb->ppdev);
        }
    }

    GO_HOME(pmdev);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        EngFreeMem(pmb);         // Undo 'bVeryTemporaryInitializationCode'
    }                           //   allocation

    EngFreeMem(pmdev);
    DISPDBG((6, "<< MulDisablePDEV: Line: %d", __LINE__));

}

/******************************Public*Routine******************************\
* MulDisableSurface
*
* Note: May be called before MulEnableSurface successfully completed!
*
\**************************************************************************/

VOID MulDisableSurface(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    DISPDBG((5, ">> MulDisableSurface"));
    pmdev = (MDEV*) dhpdev;

    if (pmdev->pco != NULL)
        EngDeleteClip(pmdev->pco);

    EngDeleteSurface(pmdev->hsurf);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        EngUnlockSurface(pmb->pso);

        DrvDisableSurface((DHPDEV) pmb->ppdev);
    }

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulDisableSurface: Line: %d", __LINE__));
}

/******************************Public*Routine******************************\
* MulAssertMode
*
\**************************************************************************/

BOOL MulAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    DISPDBG((5, ">> MulAssertMode"));
    pmdev = (MDEV*) dhpdev;

    if (!bEnable)
    {
        // When switching to full-screen mode, PatBlt blackness over
        // all the inactive screens (otherwise it looks goofy when
        // the desktop is frozen on the inactive screens and the user
        // can't do anything with it):

        for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
        {
            if (pmb != pmdev->pmbHome)
            {
                GO_BOARD(pmdev, pmb);
                DrvBitBlt(pmb->pso, NULL, NULL, NULL, NULL, &pmb->rcl, NULL,
                          NULL, NULL, NULL, 0);
            }
        }
    }

    // We use the 'home' board for full-screen switching:

    GO_BOARD(pmdev, pmdev->pmbHome);
    DrvAssertMode((DHPDEV) pmdev->pmbHome->ppdev, bEnable);

    DISPDBG((6, "<< MulAssertMode: Line: %d", __LINE__));
    return TRUE;
}

/******************************Public*Routine******************************\
* MulMovePointer
*
\**************************************************************************/

VOID MulMovePointer(
SURFOBJ* pso,
LONG     x,
LONG     y,
RECTL*   prcl)
{
    MDEV*        pmdev;
    MULTI_BOARD* pmbPointer;
    RECTL        rclPointer;

    DISPDBG((5, ">> MulMovePointer"));
    pmdev     = (MDEV*) pso->dhpdev;
    pmbPointer = pmdev->pmbPointer;

    if (pmbPointer != NULL)
    {
        // The most common case is when the pointer is moved to a spot
        // on the same board:

        if ((x >= pmbPointer->rcl.left)  &&
            (x <  pmbPointer->rcl.right) &&
            (y >= pmbPointer->rcl.top)   &&
            (y <  pmbPointer->rcl.bottom))
        {
            GO_BOARD(pmdev, pmbPointer);
            DrvMovePointer(pmbPointer->pso, x, y, prcl);
            GO_HOME(pmdev);

            DISPDBG((6, "<< MulMovePointer: Line: %d", __LINE__));
            return;
        }

        // Tell the old board to erase its cursor:

        GO_BOARD(pmdev, pmbPointer);
        DrvMovePointer(pmbPointer->pso, -1, -1, NULL);
    }

    if (x == -1)
    {
        pmdev->pmbPointer = NULL;
        GO_HOME(pmdev);
        DISPDBG((6, "<< MulMovePointer: Line: %d", __LINE__));
        return;
    }

    // Find the new board and tell it to draw its new cursor:

    rclPointer.left   = x;
    rclPointer.right  = x;
    rclPointer.top    = y;
    rclPointer.bottom = y;

    bFindBoard(pmdev, &rclPointer, &pmbPointer);

    GO_BOARD(pmdev, pmbPointer);
    DrvMovePointer(pmbPointer->pso, x, y, prcl);

    pmdev->pmbPointer = pmbPointer;

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulMovePointer: Line: %d", __LINE__));
}

/******************************Public*Routine******************************\
* MulSetPointerShape
*
\**************************************************************************/

ULONG MulSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    ULONG        ulRetPrevious = (ULONG) -1;
    ULONG        ulRet;
    RECTL        rclPointer;
    MULTI_BOARD* pmbPointer;             // Board on which cursor is visible

    DISPDBG((5, ">> MulSetPointerShape"));
    DISPDBG((0, "BUGBUG Software Cursor only for MULTI_BOARDS for now"));
    DISPDBG((6, "<< MulSetPointerShape: Line: %d", __LINE__));
	return(SPS_DECLINE);

    pmdev = (MDEV*) pso->dhpdev;

    // Find out which board that the cursor is visible on, if any:

    pmbPointer = NULL;
    if (x != -1)
    {
        rclPointer.left   = x;
        rclPointer.right  = x;
        rclPointer.top    = y;
        rclPointer.bottom = y;

        bFindBoard(pmdev, &rclPointer, &pmbPointer);
    }
    pmdev->pmbPointer = pmbPointer;

    // LATER: Fix the case for when some boards may fail the call, and others
    //        won't.

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // We notify all boards of the new cursor shape, but only the board
        // on which the cursor is visible is told to draw it:

        GO_BOARD(pmdev, pmb);

        if (pmb == pmbPointer)
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, x, y, prcl, fl);
        }
        else
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, -1, y, NULL, fl);
        }

        if ((ulRetPrevious != (ULONG) -1) && (ulRetPrevious != ulRet))
        {
            RIP("MulSetPointerShape not all DrvSetPointerShapes same\n");
        }

        ulRetPrevious = ulRet;
    }

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulSetPointerShape: Line: %d, ret: 0x%x", __LINE__, ulRetPrevious));
    return(ulRetPrevious);
}

/******************************Public*Routine******************************\
* MulDitherColor
*
\**************************************************************************/

ULONG MulDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    PDEV* ppdev;
    ULONG ulRet;

    DISPDBG((5, ">> MulDitherColor"));
    // Let the first board's driver do the dithering:

    ppdev = ((MDEV*) dhpdev)->pmb->ppdev;
    ulRet = DrvDitherColor((DHPDEV) ppdev, iMode, rgb, pul);

    DISPDBG((6, "<< MulDitherColor: Line: %d, ret: 0x%x", __LINE__, ulRet));
    return(ulRet);
}

/******************************Public*Routine******************************\
* MulSetPalette
*
\**************************************************************************/

BOOL MulSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    BOOL         bRet = TRUE;

    DISPDBG((5, ">> MulSetPalette"));
    // Notify all boards of the palette change:

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        bRet &= DrvSetPalette((DHPDEV) pmb->ppdev, ppalo, fl, iStart, cColors);
    }

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulSetPalette: Line: %d, ret: 0x%x", __LINE__, bRet));
    return(bRet);
}

/******************************Public*Routine******************************\
* MulCopyBits
*
\**************************************************************************/

BOOL MulCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    RECTL        rclDst;

    DISPDBG((5, ">> MulCopyBits"));
    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, pmb->pso, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            DISPDBG((6, "<< MulCopyBits: Line: %d", __LINE__));
            return(bBitBltBetweenBoards(psoDst, psoSrc, NULL, pco, pxlo,
                                        &rclDst, pptlSrc, NULL, NULL,
                                        NULL, 0x0000cccc, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst,
                                     pptlSrc);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        // This rarely happens, so save some code space:

        return(MulBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst,
                              pptlSrc, NULL, NULL, NULL, 0x0000cccc));
    }

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulCopyBits: Line: %d, ret: 0x%x", __LINE__, b));
    return(b);
}

/******************************Public*Routine******************************\
* MulTextOut
*
\**************************************************************************/

BOOL MulTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    MDEV*          pmdev;
    MULTI_BOARD*   pmb;
    RECTL          rclOriginalBounds;
    BYTE           fjOriginalOptions;
    BOOL           b;
    RECTL*         prclBounds;
    FONT_CONSUMER* pfcArray;

    DISPDBG((5, ">> MulTextOut"));
    pmdev = (MDEV*) pso->dhpdev;

    // In keeping with our philosophy for multiple board support, we handle
    // multiple consumers of the same font at this level.  We do this by
    // monitoring pfo->pvConsumer, and the first time a board sets the
    // field, we take control of pfo->pvConsumer.  We use it to allocate
    // a pvConsumer array where we can keep track of every board's
    // individual pvConsumer.

    pfcArray = pfo->pvConsumer;

    prclBounds = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    bFindBoard(pmdev, prclBounds, &pmb);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // If the CLIPOBJ doesn't have at least DC_RECT complexity,
        // substitute one that does:

        pco = pmdev->pco;
    }

    rclOriginalBounds = pco->rclBounds;
    fjOriginalOptions = pco->fjOptions;

    // OR in the OC_BANK_CLIP flag to let GDI know that we may be calling
    // EngTextOut multiple times with the same parameters (EngTextOut
    // is destructive in that it modifies that parameters passed to it,
    // unless this bit is set):

    pco->fjOptions |= OC_BANK_CLIP;

    b = TRUE;
    do {
        if (pfcArray != NULL)
            pfo->pvConsumer = pfcArray->apvc[pmb->iBoard].pvConsumer;

        // Make sure we restart the glyph enumeration if need be:

        STROBJ_vEnumStart(pstro);
        if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
        {
            GO_BOARD(pmdev, pmb);
            b &= DrvTextOut(pmb->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                            pboFore, pboOpaque, pptlOrg, mix);
        }

        if (pfcArray != NULL)
        {
            // Copy the pvConsumer, in case the last DrvTextOut changed
            // it:

            pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;
        }
        else
        {
            if (pfo->pvConsumer != NULL)
            {
                // The board allocated a new consumer, so create our array
                // to keep track of consumers for every board:

                pfcArray = EngAllocMem(FL_ZERO_MEMORY, sizeof(FONT_CONSUMER),
                                       ALLOC_TAG);
                if (pfcArray == NULL)
                    DrvDestroyFont(pfo);
                else
                {
                    pfcArray->cConsumers = pmdev->cBoards;
                    pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;

                }
            }
        }
    } while (bNextBoard(prclBounds, &pmb));

    // Restore the original clip bounds:

    pco->rclBounds = rclOriginalBounds;
    pco->fjOptions = fjOriginalOptions;

    // Make sure we restore/set the font's pvConsumer:

    pfo->pvConsumer = pfcArray;

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulTextOut: Line: %d, b", __LINE__, b));
    return(b);
}

/******************************Public*Routine******************************\
* MulDestroyFont
*
\**************************************************************************/

VOID MulDestroyFont(FONTOBJ *pfo)
{
    FONT_CONSUMER* pfcArray;
    LONG           i;
    PVOID          pvConsumer;

    DISPDBG((5, ">> MulDestroyFont"));
    if (pfo->pvConsumer != NULL)
    {
        pfcArray = pfo->pvConsumer;
        for (i = 0; i < pfcArray->cConsumers; i++)
        {
            pvConsumer = pfcArray->apvc[i].pvConsumer;
            if (pvConsumer != NULL)
            {
                pfo->pvConsumer = pvConsumer;
                DrvDestroyFont(pfo);
            }
        }

        EngFreeMem(pfcArray);
        pfo->pvConsumer = NULL;
    }
    DISPDBG((6, "<< MulDestroyFont: Line: %d", __LINE__));
}

/******************************Public*Routine******************************\
* MulPaint
*
\**************************************************************************/

BOOL MulPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    DISPDBG((5, ">> MulPaint"));
    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &pco->rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
    }
    else
    {
        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
            }

        } while (bNextBoard(&rclOriginalBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulPaint: Line: %d", __LINE__));
    return(b);
}

/******************************Public*Routine******************************\
* MulRealizeBrush
*
\**************************************************************************/

BOOL MulRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    MDEV*        pmdev;
    BOOL         b;

    DISPDBG((5, ">> MulRealizeBrush"));
    pmdev = (MDEV*) psoTarget->dhpdev;

    // DrvRealizeBrush is only ever calling from within a Drv function.
    // 'psoTarget' points to our multi-board surface, but we have to point
    // it to the surface of the board for which the DrvBitBlt call was made.

    b = DrvRealizeBrush(pbo, pmdev->pmbCurrent->pso, psoPattern, psoMask,
                        pxlo, iHatch);

    DISPDBG((6, "<< MulRealizeBrush: Line: %d", __LINE__));
    return(b);
}

#endif // MULTI_BOARDS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv1ddrw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV1.C
//
// Abstract:
//
//     Implements all NV1 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"
#include "nv32.h"

    #include "ddminint.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif
#include "nv1c_ref.h"

#include "nvsubch.h"
#include "nvalpha.h"
// Temporary fix for Compile error...ask!
#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free


//******************************Public*Routine**********************************
//
// Function: NV1FifoIsBusy
//
// Routine Description:
//
//             This function has been pulled out of DDBLT so that
//             we can single step thru DDBLT.  The problem is that
//             WinDbg tries to display the values of local variables
//             when tracing through functions.  However, READING from
//             the NV User Channel (*nv) will cause the system to lock
//             and is not allowed.  So to make debugging easier, this
//             code has been separated.  We can put it back in later for
//             better performance.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

ULONG NV1FifoIsBusy(PDEV *ppdev)

    {
    Nv3ChannelPio           *nv;
    USHORT              FreeCount;

    nv  = (Nv3ChannelPio*) ppdev->pjMmBase;

    //**************************************************************************
    // Get current Free Count.  If the FIFO is absolutely full, and we
    // can't send another command, then return TRUE.
    //**************************************************************************

    FreeCount = NvGetFreeCount(nv, BLIT_SUBCHANNEL);

    if (FreeCount >= NV_GUARANTEED_FIFO_SIZE)
        return(TRUE);
    else
        return(FALSE);

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4multidev.h ===
#ifndef _INCLUDE_NT4MULTIDEV
#define _INCLUDE_NT4MULTIDEV

#ifdef NT4_MULTI_DEV

#define MAX_MULTIDEV 16

#define PMDEV_UNIQ 'MDEV'
 
typedef struct _MUL_PIXELFORMAT
{
    PIXELFORMATDESCRIPTOR  pfd;
    LONG                   iPixelFormat[MAX_MULTIDEV] ;
}MUL_PIXELFORMAT,*PMUL_PIXELFORMAT;

typedef struct _MUL_PIXELFORMAT_LIST
{
    PMUL_PIXELFORMAT pPixelFormats;
    LONG             iNumberOfPixelFormats;
}MUL_PIXELFORMAT_LIST,*PMUL_PIXELFORMAT_LIST;

typedef struct _BOARDDESC
{
    BOOL            bIsActive;
    HANDLE          hDriver;
    RECTL           rclBoard;
    DEVMODEW        DevMode;
    union
    {
    DHPDEV          dhpdev;
    struct _PDEV   *ppdev;
    };
    union
    {
    DHSURF          dhsurf;
    struct _DSURF  *pdsurf;
    };
    CLIPOBJ        *pcoBoard;
    CLIPOBJ        *pco;
    RECTL           rclSavedBounds;
    ULONG           cjCaps;
    union
    {
    ULONG          *pdevcaps;
    GDIINFO        *pGdiInfo;
    };
    ULONG           cjDevInfo;
    DEVINFO        *pdi;
    HSURF           hsurf;
    SURFOBJ        *pso;
    HSURF           hsurfBitmap;
    SURFOBJ        *psoBitmap;
    // openGl stuff
    ULONG           ulRoot;
}
BOARDDESC, *PBOARDDESC;


typedef struct _MDEV
{
    DWORD                   dwUniq;
    HDEV                    hdev;
    HANDLE                  hDriver;
    RECTL                   rclDesktop;
    DEVMODEW                DevMode;
    HSURF                   hsurf;
    SURFOBJ                *pso;
    CLIPOBJ                *pco;
    FLONG                   flHooks;
    ULONG                   ulNumDevicesActive;
    ULONG                   ulNumDevicesInSystem;
    BOARDDESC               abdDevices[MAX_MULTIDEV];
    MUL_PIXELFORMAT_LIST    PixelFormatList;
}
MDEV, *PMDEV;


typedef struct _ENUMDEV 
{
  ULONG c;
  PBOARDDESC apbdDevices[1];
} ENUMDEV;

typedef struct _ENUMDEV16 
{
  ULONG c;
  PBOARDDESC apbdDevices[16];
} ENUMDEV16;

typedef struct _DEVOBJ
{
    PMDEV       pmdev;
    SURFOBJ     *pso;
    PBOARDDESC  apbdDevices[MAX_MULTIDEV];
    ULONG       enumStart;
    ULONG       cDevices;
}
DEVOBJ, *PDEVOBJ;



BOOL _inline bMatchingDevModes(DEVMODEW*   pdm1, DEVMODEW*   pdm2)
{
    BOOL bRet = FALSE;

    ASSERT(pdm1);
    ASSERT(pdm2);

    if (pdm1->dmBitsPerPel == pdm2->dmBitsPerPel
    &&  pdm1->dmPelsWidth == pdm2->dmPelsWidth
    &&  pdm1->dmPelsHeight == pdm2->dmPelsHeight
    &&  pdm1->dmDisplayFrequency == pdm2->dmDisplayFrequency
    &&  pdm1->dmPanningWidth == pdm2->dmPanningWidth
    &&  pdm1->dmPanningHeight == pdm2->dmPanningHeight
    )
        bRet = TRUE;
    return bRet;
}

BOOL _inline bFindMatchingDevMode(IN DEVMODEW*   pdmReference,
                                  IN DEVMODEW*   pdmArray,
                                  IN ULONG       ulSize)
{
    BOOL bRet = FALSE;
    DEVMODEW    *pdm;
    ASSERT(pdmReference);
    ASSERT(pdmArray);

#if 1
    if (pdmReference->dmPelsWidth < 1024 ||
        pdmReference->dmPelsHeight < 768 ||
        pdmReference->dmBitsPerPel != 32 ||
        pdmReference->dmDisplayFrequency != 75)
    return FALSE;
#endif  

    for (pdm = pdmArray; (BYTE *)pdm < ((BYTE *)pdmArray + ulSize); pdm++)
    {
        if (bMatchingDevModes(pdmReference, pdm))
        {
            bRet = TRUE;
            break;
        }

    }
    return bRet;
}


//*********************************************************
//
//  pmdevGetFromPso
//
//  gives back a pmdev if contained in pso
//  pso can be NULL or any type of SURFOBJ
//
//********************************************************
PMDEV _inline pmdevGetFromPso(SURFOBJ *pso)
{
    if(   (NULL != pso)
        &&(NULL != pso->dhpdev)
        &&(NULL != ((PPDEV)pso->dhpdev)->pmdev)
       )
    {
        ASSERT(((PPDEV)pso->dhpdev)->pmdev->dwUniq == PMDEV_UNIQ);
        return ((PPDEV)pso->dhpdev)->pmdev;
    }
    else
    {
        return NULL;
    }
}


//*********************************************************
//
//  bNeedToEnumerate
//
//  checks if pso is the multidev- primary surface
//
//********************************************************
BOOL _inline bNeedToEnumerate(SURFOBJ *pso)
{
    BOOL    bRet = FALSE;

    if(  (NULL != pmdevGetFromPso(pso))
       &&(STYPE_DEVICE == pso->iType)
      )
        bRet = TRUE;

    return bRet;
}

//*********************************************************
//
//  psoGetDevicePSO
//
//  get singleboard primary of ulDevID
//
//********************************************************
SURFOBJ _inline *psoGetDevicePSO(SURFOBJ *pso, ULONG ulDevID)
{

    if (bNeedToEnumerate(pso))
    {
        PMDEV pmdev = pmdevGetFromPso(pso);  

        ASSERT(NULL != pmdev );
        ASSERT(ulDevID < MAX_MULTIDEV);

        pso = pmdev->abdDevices[ulDevID].pso;
    }

    return pso;
}

SURFOBJ _inline *psoGetBoardRectAndSync( IN SURFOBJ      *pso,
                                         IN BOARDDESC    *pBoardDesc,
                                         IN BOARDDESC    *pOtherBoardDesc,  // needed to decide if we export the bitmap surface
                                         OUT RECTL       *prclBoard)
{
    ASSERT(prclBoard);


    if (pso)
    {
        if (bNeedToEnumerate(pso))
        {
            ASSERT(pBoardDesc);

            if (pOtherBoardDesc)
            {
                pso = pBoardDesc->psoBitmap;
                DrvSynchronize(pBoardDesc->dhpdev, NULL);   // this indicates that we'll use this surface as the source for dev to dev blits -> sync
            }
            else
            {
                pso = pBoardDesc->pso;
            }
            *prclBoard = pBoardDesc->rclBoard;

        }
        else
        {
            prclBoard->left   = 0;
            prclBoard->top    = 0;
            prclBoard->right  = pso->sizlBitmap.cx;
            prclBoard->bottom = pso->sizlBitmap.cy;
        }
    }
    return pso;
}

ULONG DEVOBJ_cEnumStart(IN PDEVOBJ  pdo,
                        IN SURFOBJ  *pso,
                        IN RECTL    *prclBounds, // dont care if bAll = TRUE
                        IN BOOL     bAll,       // TRUE: enumerates all, FALSE enumerates only dev clipped against prclbounds
                        IN ULONG    iDir);  // CD_ANY...

BOOL DEVOBJ_bEnum(IN PDEVOBJ    pdo,
                  IN ENUMDEV16  *pEnumDev16);



typedef struct _BLT_PARAM
{
    SURFOBJ *psoDst;
    SURFOBJ *psoSrc;
    RECTL   rclClip;
    RECTL   *prclClip;
    RECTL   rclDst;
    RECTL   *prclDst;
    POINTL  ptlSrc;
    POINTL  *pptlSrc;
    POINTL  ptlMask;
    POINTL  *pptlMask;
    POINTL  ptlBrush;
    POINTL  *pptlBrush;
}
BLT_PARAM;


BOOL APIENTRY MulResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew);

DHPDEV APIENTRY MulEnablePDEV(DEVMODEW* pdm, PWSTR pwszLogAddr, ULONG  cPat, HSURF* phsurfPatterns, 
                    ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi,            
                    HDEV  hdev, PWSTR pwszDeviceName, HANDLE hDriver);

VOID APIENTRY MulDisablePDEV(DHPDEV  dhpdev);

VOID APIENTRY MulCompletePDEV(DHPDEV dhpdev,HDEV   hdev);

VOID APIENTRY MulSynchronize(DHPDEV dhpdev, RECTL  *prcl);

HSURF APIENTRY MulEnableSurface(DHPDEV dhpdev);

VOID APIENTRY MulDisableSurface(DHPDEV dhpdev);

BOOL APIENTRY MulAssertMode(DHPDEV  dhpdev,BOOL    bEnable);

ULONG APIENTRY MulGetModes(HANDLE hDriver, ULONG cjSize, DEVMODEW*   pdm);

BOOL APIENTRY MulEnableDirectDraw(DHPDEV dhpdev, DD_CALLBACKS*  pCallBacks,
                            DD_SURFACECALLBACKS*    pSurfaceCallBacks, DD_PALETTECALLBACKS*    pPaletteCallBacks);

BOOL APIENTRY MulGetDirectDrawInfo(DHPDEV dhpdev, DD_HALINFO* pHalInfo, DWORD* lpdwNumHeaps,
                          VIDEOMEMORY* pvmList, DWORD* lpdwNumFourCC, DWORD* lpdwFourCC);

VOID APIENTRY MulDisableDirectDraw(DHPDEV      dhpdev);

ULONG APIENTRY MulEscape(SURFOBJ*    pso, ULONG       iEsc, ULONG       cjIn,
                VOID*       pvIn, ULONG       cjOut, VOID*       pvOut);

ULONG APIENTRY MulDrawEscape(SURFOBJ *pso, ULONG    iEsc, CLIPOBJ *pco,
                    RECTL   *prcl, ULONG    cjIn, PVOID    pvIn);

VOID APIENTRY MulDestroyFont(FONTOBJ *pfo);

BOOL APIENTRY MulStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode);

HBITMAP APIENTRY MulCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat);

VOID APIENTRY MulDeleteDeviceBitmap(DHSURF dhsurf);

BOOL APIENTRY MulRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch);

BOOL APIENTRY MulPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix);

BOOL APIENTRY MulFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions);

BOOL APIENTRY MulStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix);

BOOL APIENTRY MulLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix);

BOOL APIENTRY MulTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix);

BOOL APIENTRY MulBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4);

BOOL APIENTRY MulCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc);

BOOL APIENTRY MulSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors);

ULONG APIENTRY MulDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul);

ULONG APIENTRY MulSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl);

VOID APIENTRY MulMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl);

BOOL APIENTRY MulSwapBuffers(SURFOBJ *psoDst, WNDOBJ *pwo);

BOOL APIENTRY MulSetPixelFormat(
    SURFOBJ *pso,
    LONG    iPixelFormat,
    HWND    hWnd);


LONG APIENTRY MulDescribePixelFormat(
    DHPDEV                  dhpdev,
    LONG                    iPixelFormat,
    ULONG                   cjpfd,
    PIXELFORMATDESCRIPTOR   *ppfd);

ULONG_PTR APIENTRY MulSaveScreenBits(
    SURFOBJ   *pso,
    ULONG      iMode,
    ULONG_PTR  ident,
    RECTL     *prcl );


#endif // NT4_MULTI_DEV

#endif //_INCLUDE_NT4MULTIDEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4mulstrokepath.c ===
//************************** Module Header *************************************
//                                                                             *
//  Module Name: MulStrokePath.c                                                   *
//                                                                             *
//  This module contains the functions that belong to the multi device wrapper *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//******************************************************************************


#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"

#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV


typedef VOID (*PFUNCSTRIP)(SURFOBJ*, BRUSHOBJ*, MIX, STRIP*, LINESTATE*);

/******************************Public*Routine******************************\
* VOID vrlSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID SolidHorizontal(SURFOBJ     *pso,
                        BRUSHOBJ    *pbo,
                        MIX         mix,
                        STRIP*      pStrip,
                        LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    yInc;
    LONG    x, y, x2;
    BOOL    bRet;
    RECTL   rclBounds;


    cStrips = pStrip->cStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    // Setup the drawing direction and the skip direction.

    yInc = pStrip->flFlips & FL_FLIP_V ? -1 : 1;

    // Output the short stroke commands.

    pStrips = pStrip->alStrips;

    for (i = 0; i < cStrips; i++)
    {
        x2 = x + *pStrips;

        rclBounds.left = min(x, x2);
        rclBounds.top = y;
        rclBounds.right = max(x, x2);
        rclBounds.bottom = y + 1;
        bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y, &rclBounds, mix);
        ASSERT(bRet);

        x += *pStrips++;
        y += yInc;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vrlSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID SolidVertical(SURFOBJ     *pso,
                        BRUSHOBJ    *pbo,
                        MIX         mix,
                        STRIP*      pStrip,
                        LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y, y2;
    PLONG   pStrips;
    BOOL    bRet;
    RECTL   rclBounds;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        for (i = 0; i < cStrips; i++)
        {
            y2 = y + *pStrips; 
            rclBounds.left = x;
            rclBounds.top = min(y, y2);
            rclBounds.right = x + 1;
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x, y2, &rclBounds, mix);
            ASSERT(bRet);

            y += *pStrips++;
            x++;
        }

    }
    else
    {
        for (i = 0; i < cStrips; i++)
        {
            y2 = y - *pStrips; 
            rclBounds.left = x;
            rclBounds.top = min(y, y2);
            rclBounds.right = x + 1;
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x, y2, &rclBounds, mix);
            ASSERT(bRet);

            y -= *pStrips++;
            x++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID SolidDiagonalHorizontal(SURFOBJ     *pso,
                                BRUSHOBJ    *pbo,
                                MIX         mix,
                                STRIP*      pStrip,
                                LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y, x2, y2;
    PLONG   pStrips;
    BOOL    bRet;
    RECTL   rclBounds;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {

        for (i = 0; i < cStrips; i++)
        {
            x2 = x + *pStrips;
            y2 = y + *pStrips;
            rclBounds.left = min(x, x2);
            rclBounds.top = min(y, y2);
            rclBounds.right = max(x, x2);
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y2, &rclBounds, mix);
            ASSERT(bRet);

            y += *pStrips - 1;
            x += *pStrips++;
        }

    }
    else
    {
        for (i = 0; i < cStrips; i++)
        {
            x2 = x + *pStrips;
            y2 = y - *pStrips;
            rclBounds.left = min(x, x2);
            rclBounds.top = min(y, y2);
            rclBounds.right = max(x, x2);
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y2, &rclBounds, mix);
            ASSERT(bRet);

            y -= *pStrips - 1;
            x += *pStrips++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID SolidDiagonalVertical(SURFOBJ     *pso,
                                BRUSHOBJ    *pbo,
                                MIX         mix,
                                STRIP*      pStrip,
                                LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y, x2, y2;
    PLONG   pStrips;
    BOOL    bRet;
    RECTL   rclBounds;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        for (i = 0; i < cStrips; i++)
        {
            x2 = x + *pStrips;
            y2 = y + *pStrips;
            rclBounds.left = min(x, x2);
            rclBounds.top = min(y, y2);
            rclBounds.right = max(x, x2);
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y2, &rclBounds, mix);
            ASSERT(bRet);

            y += *pStrips;
            x += *pStrips++ - 1;
        }

    }
    else
    {
        for (i = 0; i < cStrips; i++)
        {
            x2 = x + *pStrips;
            y2 = y - *pStrips;
            rclBounds.left = min(x, x2);
            rclBounds.top = min(y, y2);
            rclBounds.right = max(x, x2);
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y2, &rclBounds, mix);
            ASSERT(bRet);

            y -= *pStrips;
            x += *pStrips++ - 1;
        }
    }


    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID StripStyledHorizontal(SURFOBJ     *pso,
                            BRUSHOBJ    *pbo,
                            MIX         mix,
                            STRIP*      pstrip,
                            LINESTATE*  pls)
{
    LONG    x, x1, x2;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    BOOL    bRet;
    RECTL   rclBounds;


    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy      = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy      = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    // Warm up the hardware so that it will know we'll be outputing
    // short-stroke vectors, and so that it will have the current position
    // correctly set if we're starting in the middle of a 'dash':

    x1 = x;
//    y1 = y; 

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // We're gonna need the current position to be correct when we
    // start outputing short-stroke vectors:

    x1 = x;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'y'
        // to be the current scan:

//        y1 = y;
        goto OutputADash;
    }

    // Set 'y' to be the scan we're about to move to, because we've
    // finished with the current strip:

//    y1 = y + dy;

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        x2 = x;

        rclBounds.left = min(x1, x2);
        rclBounds.top = y;
        rclBounds.right = max(x1, x2);
        rclBounds.bottom = y + 1;
        bRet = MulLineTo(pso, NULL, pbo, x1, y, x2, y, &rclBounds, mix);
        ASSERT(bRet);

        x1 = x2;  // set current x1

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID StripStyledVertical(SURFOBJ     *pso,
                            BRUSHOBJ    *pbo,
                            MIX         mix,
                            STRIP*      pstrip,
                            LINESTATE*  pls)
{
    LONG    x, x1;
    LONG    y, y1, y2;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    BOOL    bRet;
    RECTL   rclBounds;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):
        dy        = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):
        dy        = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    // Warm up the hardware so that it will know we'll be outputing
    // short-stroke vectors, and so that it will have the current position
    // correctly set if we're starting in the middle of a 'dash':

    x1 = x;
    y1 = y;


    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // We're gonna need the current position to be correct when we
    // start outputing short-stroke vectors:

    y1 = y;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'x'
        // to be the current column:

        x1 = x;
        goto OutputADash;
    }

    // Set 'x' to be the column we're about to move to, because we've
    // finished with the current strip:

    x1 = x + 1;

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        y2 = y;

        rclBounds.left = x;
        rclBounds.top = min(y1, y2);
        rclBounds.right = x + 1;
        rclBounds.bottom = max(y1, y2);
        bRet = MulLineTo(pso, NULL, pbo, x, y1, x, y2, &rclBounds, mix);
        ASSERT(bRet);

        y1 = y2;   // set current y1

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}


/*******************************Public*Table*******************************\
* gapfnStrip
*
* Look-up table for DrvStrokePath to find which strip routines to call.
*
\**************************************************************************/

VOID (*gapfuncStrip[])(SURFOBJ*, BRUSHOBJ*, MIX, STRIP*, LINESTATE*) = {
    SolidHorizontal,
    SolidVertical,
    SolidDiagonalHorizontal,
    SolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    SolidHorizontal,
    SolidVertical,
    SolidDiagonalHorizontal,
    SolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    StripStyledHorizontal,
    StripStyledVertical,
    StripStyledVertical,       // Diagonal goes here
    StripStyledVertical,       // Diagonal goes here

    StripStyledHorizontal,
    StripStyledVertical,
    StripStyledVertical,       // Diagonal goes here
    StripStyledVertical,       // Diagonal goes here
};




///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

BOOL bHardwareLine(SURFOBJ*, BRUSHOBJ*, MIX, POINTFIX*, POINTFIX*);

/******************************Public*Routine******************************\
* BOOL bMulLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bMulLines( SURFOBJ     *pso,
                BRUSHOBJ    *pbo,
                MIX         mix,
                POINTFIX*  pptfxFirst,  // Start of first line
                POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
                RUN*       prun,        // Pointer to runs if doing complex clipping
                ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                                        // in prun
                LINESTATE* pls,         // Colour and style info
                RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
                PFUNCSTRIP apfn[],      // Array of strip functions
                FLONG      flStart)     // Flags for each line, which is a combination of:
                            //      FL_SIMPLE_CLIP
                            //      FL_COMPLEX_CLIP
                            //      FL_STYLED
                            //      FL_LAST_PEL_INCLUSIVE
                            //        - Should be set only for all integer lines,
                            //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFUNCSTRIP pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;
    BOOL        bRet;
    RECTL   rclBounds;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

    // Check for non-clipped, non-styled integer endpoint lines:

        if ((fl & (FL_CLIP | FL_STYLED)) == 0)
        {
            // Special-case integer end-point lines:

            if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
            {
                // -1 for 'iSolidColor' denotes that the currently set
                // colour and mix should be kept:

                rclBounds.left = min((M0 >> 4), (dM >> 4));
                rclBounds.top = min((N0 >> 4), (dN >> 4));
                rclBounds.right = max((M0 >> 4), (dM >> 4));
                rclBounds.bottom = max((N0 >> 4), (dN >> 4));
                bRet = MulLineTo(pso, NULL, pbo, 
                                 (M0 >> 4) + 0, //ppdev->xOffset,
                                 (N0 >> 4) + 0, //ppdev->yOffset,
                                 (dM >> 4) + 0, //ppdev->xOffset,
                                 (dN >> 4) + 0, //ppdev->yOffset,
                                 &rclBounds, mix);
                ASSERT(bRet);

                goto Next_Line;
            }

            // Check for fractional endpoint lines that are small enough
            // to use the hardware DDA:

            ASSERT(FALSE);
            if (bHardwareLine(pso, pbo, mix, pptfxFirst, pptfxBuf))
                goto Next_Line;
        }
    
        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
        ULONG M1 = FXFRAC(M0 + dM);

        x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

    strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = plStrip - &strip.alStrips[0];
                    (*pfn)(pso, pbo, mix, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = plStrip - &strip.alStrips[0];
            (*pfn)(pso, pbo, mix, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}

//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};


/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(SURFOBJ     *pso,
                    BRUSHOBJ    *pbo,
                    MIX         mix,                              
                    POINTFIX* pptfxStart,       // Start of line
                    POINTFIX* pptfxEnd)         // End of line
{
    return FALSE;
}


// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };


/******************************Public*Routine******************************\
* BOOL MulStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/
BOOL MulStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulStrokePath >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush,pla,mix);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDevID;
        STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
        STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
        LINESTATE ls;
        PFUNCSTRIP* apfn;
        FLONG     fl;
        RECTL     arclClip[4];                  // For rectangular clipping
        RECTL*    prclClip;

#if DBG
        DWORD dwLvl = 10;
        DISPDBG((dwLvl, "pco    :0x%x", pco));
        if (pco)
            DISPDBG((dwLvl, "rclBounds: (%d, %d) - (%d, %d)", pco->rclBounds.left, pco->rclBounds.top, pco->rclBounds.right, pco->rclBounds.bottom));
        if (pbo)
            DISPDBG((dwLvl, "Color: 0x%x", pbo->iSolidColor));
#endif
        ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
                 "GDI gave us an improper mix");

        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:

        if (!bNeedToEnumerate(pso))
        {
            // fast path for single board or bitmaps
            bRet = EngStrokePath( pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
            goto Exit;
        }

        prclClip = NULL;
        fl       = 0;

        // Look after styling initialization:

        if (pla->fl & LA_ALTERNATE)
        {
            ls.cStyle      = 1;
            ls.spTotal     = 1;
            ls.spTotal2    = 2;
            ls.spRemaining = 1;
            ls.aspRtoL     = &gaspAlternateStyle[0];
            ls.aspLtoR     = &gaspAlternateStyle[0];
            ls.spNext      = HIWORD(pla->elStyleState.l);
            ls.xyDensity   = 1;
            fl            |= FL_STYLED;
            ls.ulStartMask = 0L;
        }
        else if (pla->pstyle != (FLOAT_LONG*) NULL)
        {
            PFLOAT_LONG pstyle;
            STYLEPOS*   pspDown;
            STYLEPOS*   pspUp;

            pstyle = &pla->pstyle[pla->cstyle];

            ls.xyDensity = STYLE_DENSITY;
            ls.spTotal   = 0;
            while (pstyle-- > pla->pstyle)
            {
                ls.spTotal += pstyle->l;
            }
            ls.spTotal *= STYLE_DENSITY;
            ls.spTotal2 = 2 * ls.spTotal;

            // Compute starting style position (this is guaranteed not to overflow):

            ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                        LOWORD(pla->elStyleState.l);

            fl        |= FL_STYLED;
            ls.cStyle  = pla->cstyle;
            ls.aspRtoL = aspRtoL;
            ls.aspLtoR = aspLtoR;

            if (pla->fl & LA_STARTGAP)
                ls.ulStartMask = 0xffffffffL;
            else
                ls.ulStartMask = 0L;

            pstyle  = pla->pstyle;
            pspDown = &ls.aspRtoL[ls.cStyle - 1];
            pspUp   = &ls.aspLtoR[0];

            while (pspDown >= &ls.aspRtoL[0])
            {
                *pspDown = pstyle->l * STYLE_DENSITY;
                *pspUp   = *pspDown;

                pspUp++;
                pspDown--;
                pstyle++;
            }
        }

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

            // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

            // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

            // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        apfn = &gapfuncStrip[NUM_STRIP_DRAW_STYLES *
                                ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

        // Set up to enumerate the path:

        if (pco->iDComplexity != DC_COMPLEX)
        {
            PATHDATA  pd;
            BOOL      bMore;
            ULONG     cptfx;
            POINTFIX  ptfxStartFigure;
            POINTFIX  ptfxLast;
            POINTFIX* pptfxFirst;
            POINTFIX* pptfxBuf;


            pd.flags = 0;

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                cptfx = pd.count;
                if (cptfx == 0)
                    break;

                if (pd.flags & PD_BEGINSUBPATH)
                {
                    ptfxStartFigure  = *pd.pptfx;
                    pptfxFirst       = pd.pptfx;
                    pptfxBuf         = pd.pptfx + 1;
                    cptfx--;
                }
                else
                {
                    pptfxFirst       = &ptfxLast;
                    pptfxBuf         = pd.pptfx;
                }

                if (pd.flags & PD_RESETSTYLE)
                    ls.spNext = 0;

                if (cptfx > 0)
                {
                    if (!bMulLines(pso, pbo, mix,
                                pptfxFirst,
                                pptfxBuf,
                                (RUN*) NULL,
                                cptfx,
                                &ls,
                                prclClip,
                                apfn,
                                fl))
                    {
                        bRet = FALSE;
                        goto Exit;
                    }
                }

                ptfxLast = pd.pptfx[pd.count - 1];

                if (pd.flags & PD_CLOSEFIGURE)
                {
                    if (!bMulLines(pso, pbo, mix,
                                &ptfxLast,
                                &ptfxStartFigure,
                                (RUN*) NULL,
                                1,
                                &ls,
                                prclClip,
                                apfn,
                                fl))
                    {
                        bRet = FALSE;
                        goto Exit;
                    }
                }
            } while (bMore);

            if (fl & FL_STYLED)
            {
            // Save the style state:

                ULONG ulHigh;
                ULONG ulLow;

            // Masked styles don't normalize the style state.  It's a good
            // thing to do, so let's do it now:

                if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                    ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

                ulHigh = ls.spNext / ls.xyDensity;
                ulLow  = ls.spNext % ls.xyDensity;

                pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
            }
        }
        else
        {
        // Local state for path enumeration:

            BOOL bMore;
            union {
                BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
                CLIPLINE cl;
            } cl;

            fl |= FL_COMPLEX_CLIP;

        // We use the clip object when non-simple clipping is involved:

            PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

            do {
                bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
                if (cl.cl.c != 0)
                {
                    if (fl & FL_STYLED)
                    {
                        ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                     + LOWORD(cl.cl.lStyleState);
                    }
                    if (!bMulLines(pso, pbo, mix,
                                &cl.cl.ptfxA,
                                &cl.cl.ptfxB,
                                &cl.cl.arun[0],
                                cl.cl.c,
                                &ls,
                                (RECTL*) NULL,
                                apfn,
                                fl))
                    {
                        bRet = FALSE;
                        goto Exit;
                    }
                }
            } while (bMore);
        }

        bRet = TRUE;
    }

Exit:
    DISPDBG((100, "<<< MulStrokePath"));

    return(bRet);
}


//******************************************************************************
//
//  MulLineTo
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulLineTo(SURFOBJ*    pso,
                CLIPOBJ*    pco,
                BRUSHOBJ*   pbo,
                LONG        x1,
                LONG        y1,
                LONG        x2,
                LONG        y2,
                RECTL*      prclBounds,
                MIX         mix)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulLineTo >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDevID;
        LONG    lTransX1, lTransY1;
        LONG    lTransX2, lTransY2;
        ENUMDEV16 enumDev16;    
        BOARDDESC *pBoardDesc;
        ULONG   cDevices;
        DEVOBJ  DevObj;
        SURFOBJ *psoBoard;
        RECTL   rclBoard;
        RECTL   rclBounds;
        RECTL   *prclScratchBounds;
        CLIPENUM ce;
        LONG    l;
        BOOL    bMore;
        BOOL    bMoreClip;

#if DBG
        DWORD dwLvl = 10;
#endif

        DISPDBG((dwLvl, "MulLineTo >>>"));

        if (!bNeedToEnumerate(pso))
        {
            // fast path for bitmaps
            bRet = EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
        }
        else
        {
    
            prclScratchBounds = prclBounds;
            if (prclBounds)
            {
                rclBounds           = *prclBounds;
                prclScratchBounds   = &rclBounds;
            }

            if (pmdev)
            {
                cDevices = DEVOBJ_cEnumStart(&DevObj, pso, NULL, TRUE, CD_ANY);
                if (cDevices)
                {
                    do 
                    {
                        bMore = DEVOBJ_bEnum(&DevObj, &enumDev16);
                        for (ulDevID = 0; ulDevID < enumDev16.c; ulDevID++)
                        {
                            pBoardDesc = enumDev16.apbdDevices[ulDevID];
                            psoBoard = psoGetBoardRectAndSync( IN pso, IN pBoardDesc, IN NULL, OUT &rclBoard);
                
                            lTransX1 = x1 - rclBoard.left;
                            lTransX2 = x2 - rclBoard.left;

                            lTransY1 = y1 - rclBoard.top;
                            lTransY2 = y2 - rclBoard.top;

                            if (prclBounds)
                            {
                                vRclSubOffset(&rclBounds, prclBounds, rclBoard.left, rclBoard.top);
                            }

                            if (NULL == pco || DC_TRIVIAL == pco->iDComplexity)
                            {
                                pBoardDesc->pco->rclBounds = rclBoard;    
                                vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, rclBoard.left, rclBoard.top);

                                if (lTransX1 >= pBoardDesc->pco->rclBounds.left && lTransX1 < pBoardDesc->pco->rclBounds.right &&
                                    lTransY1 >= pBoardDesc->pco->rclBounds.top  && lTransY1 < pBoardDesc->pco->rclBounds.bottom &&
                                    lTransX2 >= pBoardDesc->pco->rclBounds.left && lTransX2 < pBoardDesc->pco->rclBounds.right &&
                                    lTransY2 >= pBoardDesc->pco->rclBounds.top  && lTransY2 < pBoardDesc->pco->rclBounds.bottom)
                                {
                                    pBoardDesc->pco->iDComplexity = DC_TRIVIAL;
                                }
                                bRet = DrvLineTo(psoBoard, pBoardDesc->pco, pbo, lTransX1, lTransY1, lTransX2, lTransY2, prclScratchBounds, mix);
                                pBoardDesc->pco->iDComplexity = DC_RECT;
                            }
                            else if (DC_RECT == pco->iDComplexity)
                            {
                                if (!bRclIntersect(&pBoardDesc->pco->rclBounds, &pco->rclBounds, &rclBoard))
                                    continue;
                                vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, rclBoard.left, rclBoard.top);

                                if (lTransX1 >= pBoardDesc->pco->rclBounds.left && lTransX1 < pBoardDesc->pco->rclBounds.right &&
                                    lTransY1 >= pBoardDesc->pco->rclBounds.top  && lTransY1 < pBoardDesc->pco->rclBounds.bottom &&
                                    lTransX2 >= pBoardDesc->pco->rclBounds.left && lTransX2 < pBoardDesc->pco->rclBounds.right &&
                                    lTransY2 >= pBoardDesc->pco->rclBounds.top  && lTransY2 < pBoardDesc->pco->rclBounds.bottom)
                                {
                                    pBoardDesc->pco->iDComplexity = DC_TRIVIAL;
                                }
                                bRet = DrvLineTo(psoBoard, pBoardDesc->pco, pbo, lTransX1, lTransY1, lTransX2, lTransY2, prclScratchBounds, mix);
                                pBoardDesc->pco->iDComplexity = DC_RECT;
                            }
                            else
                            {

                                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                                do  
                                {
                                    bMoreClip = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);
                                    for (l = 0; l < ce.c; l++)
                                    {
                                        if (bRclIntersect(&pBoardDesc->pco->rclBounds, &ce.arcl[l], &rclBoard))
                                        {
                                            vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, rclBoard.left, rclBoard.top);

                                            bRet = DrvLineTo(psoBoard, pBoardDesc->pco, pbo, lTransX1, lTransY1, lTransX2, lTransY2, prclScratchBounds, mix);
                                        }
                                    }
                                }
                                while (bMoreClip);
                            }
                        }
                    }
                    while (bMore && bRet);
                }
            }
        }
    }

    DISPDBG((100, "<<< MulLineTo"));
    return bRet;
}


//******************************************************************************
//
//  MulFillPath
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulFillPath( SURFOBJ*  pso,
                  PATHOBJ*  ppo,
                  CLIPOBJ*  pco,
                  BRUSHOBJ* pbo,
                  POINTL*   pptlBrushOrg,
                  MIX       mix,
                  FLONG     flOptions)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulFillPath >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvFillPath(pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);
    }
    else
    {
        // not implemented so far
        ASSERT(FALSE);
    }

    DISPDBG((100, "<<< MulFillPath"));
    return bRet;
}


#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv1lines.c ===
//******************************************************************************
//
// Module Name: NV1LINES.C
//
// Contains most of the required GDI line support.  Supports drawing
// lines in short 'strips' when clipping is complex or coordinates
// are too large to be drawn by the line hardware.
//
// Copyright (c) 1990-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/


#include "precomp.h"
#include "nv1_32.h"
#include "driver.h"
#include "nv1c_ref.h"
#include "nvsubch.h"
#include "nvalpha.h"


//*****************************************************************************
//
//  Function:   NV1StrokePath
//
//  Routine Description:
//
//              Strokes the path.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************

BOOL NV1StrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)

    {
    PDEV*       ppdev;
    DSURF*      pdsurf;
    RECTL       arclClip[4];                  // For rectangular clipping

    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    PuntPtr;

    NvChannel   *nv;
    USHORT      FreeCount;
    BOOL        bMore;
    ULONG       VertexCount;
    POINTFIX    *CurrentVertexPtr;
    POINTFIX    *FirstVertexPtr;
    POINTFIX    *NextVertexPtr;
    POINTFIX    LastVertex;
    LONG        x0,y0;
    LONG        x1,y1;
    ULONG       width,height;
    ULONG       AlphaEnableValue;
    PATHDATA    pd;
    ULONG       temp;
    ULONG       LineVisibleFlag;
    ULONG       *DstBits;
    ULONG       *ScreenBitmap;
    ULONG       Rop3;
    ULONG       i;
    LONG        curX, curY;
    BYTE        jClip;


    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Get the FreeCount
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Default to the original surface object passed in to us
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = ppdev->psoPunt;

    //**************************************************************************
    // Check if this is a device managed surface
    //**************************************************************************

    pdsurf = (DSURF*) pso->dhsurf;
   
    if (pdsurf !=0)
        {

        //**********************************************************************
        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:
        //**********************************************************************

        if (pdsurf->dt == DT_DIB)
            {
            //******************************************************************
            // NOTE: We use pdsurf->pso, NOT just pso, because this is
            //       a DFB that exists in system memory.
            //******************************************************************

            ppdev->pfnWaitEngineBusy(ppdev);
            return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
            }
        }

    //**************************************************************************
    // Only handle line drawing to VRAM.  Send lines to system memory back to GDI.
    //**************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

    if ((pdsurf == 0) && (DstBits != ScreenBitmap))
        goto GDI_StrokePathIt;

    //**************************************************************************
    // Only SIMPLE, STRAIGHT lines implemented, the rest go thru GDI
    //
    // If we get to this point, the line is to be drawn onscreen
    // We'll currently use NV hardware to ONLY draw straight integer lines.
    // (Because #1) The line object is not yet implemented, just the solid
    //              rectangle object, so we'll use that to draw only straight lines
    //          #2) Currently don't have time to verify the lines are drawn
    //              exactly correct.  We'll just handle the extremely simple
    //              lines, and let GDI worry about the rest.
    //**************************************************************************

    //**************************************************************************
    // Init the pointer to NV hardware
    //**************************************************************************

    nv = (NvChannel *)ppdev->pjMmBase;

    //**************************************************************************
    // ONLY handle solid single pixel wide lines
    // Line Style is solid if pstyle array ptr is NULL
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;
    else
        jClip = pco->iDComplexity;

    if ((pla->pstyle == (FLOAT_LONG*) NULL) && !(pla->fl & (LA_GEOMETRIC | LA_ALTERNATE)))
        {

        //**********************************************************************
        // ONLY handle non-clipped lines or single rectangle clipped lines
        //**********************************************************************

        if ((jClip == DC_TRIVIAL) || (jClip == DC_RECT))
            {
            //******************************************************************
            // If this is a mix which uses the destination, then we cannot punt to GDI
            // in the middle of a path enumeration since GDI will draw the same lines
            // which we have already drawn. So we MUST prescan the list of lines in the
            // path to ensure that none of the vertices in the path have a fractional
            // component, and that ALL of the lines are either horiz or vert. For now
            // we'll just check for a SRCCOPY mix.
            //******************************************************************
            if ((mix & 0xf) != R2_COPYPEN)
                {
                PATHOBJ_vEnumStart(ppo);
                do
                    {
                    pd.flags = 0;
                    bMore = PATHOBJ_bEnum(ppo, &pd);
                    curX = pd.pptfx[0].x >> 4;
                    curY = pd.pptfx[0].y >> 4;

                    for (i = 0; i < pd.count; i++)
                        {
                        if ((((pd.pptfx[i].x | pd.pptfx[i].y) & 0xf) != 0) ||
                            !((pd.pptfx[i].x >> 4) == curX || (pd.pptfx[i].y >> 4) == curY))
                            goto GDI_StrokePathIt;
                        else
                            {
                            curX = pd.pptfx[i].x >> 4;
                            curY = pd.pptfx[i].y >> 4;
                            }

                        }
                    } while (bMore);
                }

            //******************************************************************
            // First, copy the clipping rectangle if it's present
            //******************************************************************

            if (jClip == DC_RECT)
                {
                arclClip[0] = pco->rclBounds;
                }

            //******************************************************************
            // Check free count and prepare rectangle engine
            //******************************************************************

            while (FreeCount < 2*4)
                FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
            FreeCount -=2*4;

            //******************************************************************
            // Convert mix to a Rop3 value.
            //******************************************************************
            Rop3 = (mix & 0x0f) - 1;
            Rop3 |= (Rop3 << 4);

            nv->subchannel[ROP_SOLID_SUBCHANNEL].ropSolid.SetRop = Rop3;
            nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = pbo->iSolidColor;

            //**************************************************************************
            // Reset clipping rectangle to full screen extents if necessary
            // Resetting the clipping rectangle causes delays so we want to do it
            // as little as possible!
            //**************************************************************************
            if (ppdev->NVClipResetFlag)
                {
                while (FreeCount < 2*4)
                    FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.free;
                FreeCount -= 2*4;

                nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.y_x = ((0 << 16) | 0 );
                nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.height_width = (((ppdev->cyMemory)<<16) | (ppdev->cxMemory));

                ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
                }

            PATHOBJ_vEnumStart(ppo);
            do  {

                pd.flags = 0;

                //**************************************************************
                // Get the current group of lines
                //**************************************************************

                bMore = PATHOBJ_bEnum(ppo, &pd);

                //**************************************************************
                // Get number of vertices in this record.
                //**************************************************************

                VertexCount = pd.count;

                //**************************************************************
                // Check to see if we need to 'reset' the starting vertex
                //**************************************************************

                if (pd.flags & PD_BEGINSUBPATH)
                    {
                    //**********************************************************
                    // Get ptr to coordinates of the first vertex
                    //**********************************************************

                    CurrentVertexPtr    = pd.pptfx;
                    NextVertexPtr       = pd.pptfx+1;
                    FirstVertexPtr      = pd.pptfx;
                    }

                else

                    {
                    //**********************************************************
                    // Get coordinates of first vertex.
                    // Since we didn't get a BEGIN_SUBPATH notification,
                    // use the last vertex from the last line record
                    // as the first vertex.
                    //**********************************************************

                    CurrentVertexPtr    = &LastVertex;
                    NextVertexPtr       = pd.pptfx;
                    FirstVertexPtr      = &LastVertex;
                    }

                //**************************************************************
                // If we DIDN'T get a BEGIN_SUBPATH notification,
                // do we need to increment VertexCount???
                // We'll be using LastVertex, which isn't part of the
                // current list of lines???
                //**************************************************************

//           VertexCount++;

                //**************************************************************
                // Exit if there aren't at least 2 vertices
                //**************************************************************

                if (VertexCount < 2)
                    goto NV_LinesAreDone;

                //**************************************************************
                // Copy the last vertex in this record
                //**************************************************************

                LastVertex = pd.pptfx[pd.count - 1];

                //**************************************************************
                // Need a minimum of 2 vertices per line
                //**************************************************************

                do  {
                    //**********************************************************
                    // Check each line and see if it's an integer and straight
                    // Get the first PATHDATA record
                    //**********************************************************

                    x0 = CurrentVertexPtr->x;
                    y0 = CurrentVertexPtr->y;

                    x1 = NextVertexPtr->x;
                    y1 = NextVertexPtr->y;

                    //**********************************************************
                    // Send to GDI if we get a non-integer line
                    //**********************************************************

                    if (((x0 | y0 | x1 | y1) & 0xf) != 0)
                        goto GDI_StrokePathIt;

                    //**********************************************************
                    // Get rid of fixed fractional component
                    //**********************************************************

                    x0 >>=4;
                    y0 >>=4;
                    x1 >>=4;
                    y1 >>=4;

                    //**********************************************************
                    // Default to always drawing the line
                    //**********************************************************

                    LineVisibleFlag = TRUE;

                    //**********************************************************
                    // Only draw line if it's horizontal or vertical
                    //**********************************************************

                    if (x0==x1)

                        {
                        //******************************************************
                        // We're dealing with a VERTICAL line
                        // Make sure to calculate a positive height and
                        // swap the coordinates if necessary
                        //******************************************************

                        width=1;
                        if (y0 > y1)
                            {
                            temp=y0;
                            y0=y1+1;
                            y1=temp+1;
                            }

                        //******************************************************
                        // Vertical Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((x0 < arclClip[0].left) || (x0 >= arclClip[0].right) ||
                                (y1 <= arclClip[0].top) || (y0 >= arclClip[0].bottom))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the height.
                                //**********************************************

                                if (y1 > arclClip[0].bottom)
                                    y1 = arclClip[0].bottom;

                                if (y0 < arclClip[0].top)
                                    y0 = arclClip[0].top;
                                }
                            }
                        height = y1 - y0;
                        }

                   else if (y0==y1)

                        {
                        //******************************************************
                        // We're dealing with a HORIZONTAL line
                        // Make sure to calculate a positive width and
                        // swap the coordinates if necessary
                        //******************************************************

                        height=1;
                        if (x0 > x1)
                            {
                            temp=x0;
                            x0=x1+1;
                            x1=temp+1;
                            }

                        //******************************************************
                        // Horizontal Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((y0 < arclClip[0].top) || (y0 >= arclClip[0].bottom) ||
                                (x1 <= arclClip[0].left) || (x0 >= arclClip[0].right))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the width.
                                //**********************************************

                                if (x1 > arclClip[0].right)
                                    x1 = arclClip[0].right;

                                if (x0 < arclClip[0].left)
                                    x0 = arclClip[0].left;

                                }
                            }
                        width = x1 - x0;
                        }

                    else

                        {
                        //******************************************************
                        // This group of lines contains a NON straight line.
                        // Just punt it back to GDI
                        //******************************************************
                        goto GDI_StrokePathIt;

                        }

                    //**********************************************************
                    // Time to output a straight line if visible
                    //**********************************************************

                    if (LineVisibleFlag == TRUE)
                        {
                        DISPDBG((6,"x,y: %lx %lx h,w: %lx %lx", x0, y0, height, width));
                        while (FreeCount < 2*4)
                            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
                        FreeCount -=2*4;

                        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ( (y0<<16) | (x0 & 0xffff) );
                        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ( (height << 16) | (width & 0xffff) );

                        //******************************************************
                        // Advance to next line (must have at least 2 vertices)
                        //******************************************************
                        }


                    VertexCount--;

                    CurrentVertexPtr = NextVertexPtr;
                    NextVertexPtr++;

                    } while (VertexCount >= 2);

                //**************************************************************
                // Draw closing line if specified and if it's straight
                //**************************************************************

                if (pd.flags & PD_CLOSEFIGURE)
                    {

                    x0 = LastVertex.x;
                    y0 = LastVertex.y;

                    x1 = FirstVertexPtr->x;
                    y1 = FirstVertexPtr->y;

                    //**********************************************************
                    // Send to GDI if we get a non-integer line
                    //**********************************************************

                    if (((x0 | y0 | x1 | y1) & 0xf) != 0)
                        goto GDI_StrokePathIt;

                    //**********************************************************
                    // Get rid of fixed fractional component
                    //**********************************************************

                    x0 >>=4;
                    y0 >>=4;
                    x1 >>=4;
                    y1 >>=4;

                    //**********************************************************
                    // Default to always drawing the closing line
                    //**********************************************************

                    LineVisibleFlag = TRUE;

                    //**********************************************************
                    // Make sure line is straight!
                    //**********************************************************

                    if (x0==x1)

                        {
                        //******************************************************
                        // We're dealing with a VERTICAL line
                        // Make sure to calculate a positive height and
                        // swap the coordinates if necessary
                        //******************************************************

                        width=1;
                        if (y0 > y1)
                            {
                            temp=y0;
                            y0=y1+1;
                            y1=temp+1;
                            }

                        //******************************************************
                        // Vertical Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((x0 < arclClip[0].left) || (x0 >= arclClip[0].right) ||
                                (y1 <= arclClip[0].top) || (y0 >= arclClip[0].bottom))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the height.
                                //**********************************************

                                if (y0 < arclClip[0].top)
                                    y0 = arclClip[0].top;

                                if (y1 > arclClip[0].bottom)
                                    y1 = arclClip[0].bottom;
                                }
                            }
                        height = y1 - y0;
                        }

                   else if (y0==y1)

                        {
                        //******************************************************
                        // We're dealing with a HORIZONTAL line
                        // Make sure to calculate a positive width and
                        // swap the coordinates if necessary
                        //******************************************************

                        height=1;
                        if (x0 > x1)
                            {
                            temp=x0;
                            x0=x1+1;
                            x1=temp+1;
                            }

                        //******************************************************
                        // Horizontal Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((y0 < arclClip[0].top) || (y0 >= arclClip[0].bottom) ||
                                (x1 <= arclClip[0].left) || (x0 >= arclClip[0].right))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the width.
                                //**********************************************

                                if (x0 < arclClip[0].left)
                                    x0 = arclClip[0].left;

                                if (x1 > arclClip[0].right)
                                    x1 = arclClip[0].right;
                                }
                            }
                        width = x1 - x0;
                        }


                    else

                        {
                        //******************************************************
                        // This group of lines contains a NON straight line.
                        // Just punt it back to GDI
                        //******************************************************
                        goto GDI_StrokePathIt;

                        }


                    //**********************************************************
                    // Time to output a straight line if visible
                    //**********************************************************

                    if (LineVisibleFlag == TRUE)
                        {
                        DISPDBG((6,"x,y: %lx %lx h,w: %lx %lx", x0, y0, height, width));
                        while (FreeCount < 2*4)
                            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
                        FreeCount -=2*4;
                        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ( (y0<<16) | (x0 & 0xffff) );
                        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ( (height << 16) | (width & 0xffff) );
                        }

                    }

                } while (bMore) ;

NV_LinesAreDone:
            //******************************************************************
            // Update global free count
            //******************************************************************

            ppdev->NVFreeCount = FreeCount;

            return(TRUE);

            } // Only handle non-clipped lines or lines clipped to a single rectangle


        } // Only handle solid-lines


    //**************************************************************************
    // Send all other lines thru GDI
    //**************************************************************************

GDI_StrokePathIt:

    if (pdsurf !=0)

        {

        //******************************************************************
        // This is an offscreen DFB (DT_SCREEN).  Let GDI draw the line
        // using the wrapper 'punt' surface object
        //******************************************************************

        PuntPtr->dhsurf = 0;               // Behave like a standard DIB
        PuntPtr->sizlBitmap = pdsurf->sizl;

        //******************************************************************
        // Set linear offset and stride for source and destination buffers
        //******************************************************************

        PuntPtr->cjBits  = pdsurf->LinearStride * pdsurf->sizl.cy;
        PuntPtr->pvBits  = pdsurf->LinearPtr;
        PuntPtr->pvScan0 = pdsurf->LinearPtr;
        PuntPtr->lDelta  = pdsurf->LinearStride;

        PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;

        TempDstSurfObjPtr = PuntPtr;

        }

    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    ppdev->pfnWaitEngineBusy(ppdev);
    return(EngStrokePath(TempDstSurfObjPtr, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));


    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4mulescape.c ===
//************************** Module Header *************************************
//                                                                             *
//  Module Name: nt4MulEscape.c                                                   *
//                                                                             *
//  This module contains the functions that belong to the multi device wrapper *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//******************************************************************************


#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"
#include "nv32.h"       // needed for NV01_DEVICE_0 #define
#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV

BOOL bFindDeviceRMRoot( PBOARDDESC pbdDevices, ULONG ulRoot )
{
    BOOL  bRet = FALSE;
    ULONG ul   = 0;

    ASSERT( NULL != pbdDevices );
    ASSERT( 0 != ulRoot ); // 0 means not initialized !

    for( ul = 0; ul < MAX_MULTIDEV; ul ++ )
    {
        if( pbdDevices[ul].ulRoot == ulRoot )
        {
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}


//******************************************************************************
//
//  MulEscape
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulEscape(SURFOBJ*    pso, ULONG       iEsc, ULONG       cjIn,
                VOID*       pvIn, ULONG       cjOut, VOID*       pvOut)
{
    PPDEV ppdev = NULL;
    ULONG ulRet = 0;

    DISPDBG((100, "MulEscape >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        ulRet = DrvEscape(pso, iEsc, cjIn, pvIn, cjOut, pvOut);
    }
    else
    {

        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        // check for all ESCAPES related to the multimon stuff first
        switch(iEsc)
        {
            case ESC_NV_OPENGL_ESCAPE:
            {
                NV_OPENGL_COMMAND *inCommand;

                inCommand = (NV_OPENGL_COMMAND *)pvIn;

                switch(inCommand->command)
                {
                    case ESC_NV_OPENGL_NT4_GET_NUMBER_OF_MONITORS:
                        ((ULONG *)pvOut)[0] = pmdev->ulNumDevicesActive;
                        ulRet = (ULONG)TRUE + 1;
                        break;
                    case ESC_NV_OPENGL_NT4_GET_DEVICE_HANDLE:
                        ASSERT(inCommand->devID < MAX_MULTIDEV);
                        ((ULONG *)pvOut)[0] = (ULONG)pmdev->abdDevices[inCommand->devID].hDriver;
                        ulRet = (ULONG)TRUE + 1;
                        break;
                    case ESC_NV_OPENGL_NT4_GET_DEVICE_RECT:
                    {
                        RECTL *prcl;
                        prcl = (RECTL *)pvOut;
                        ASSERT(inCommand->devID < MAX_MULTIDEV);
                        *prcl = pmdev->abdDevices[inCommand->devID].rclBoard;
                        ulRet = (ULONG)TRUE + 1;
                        break;
                    }
                    case ESC_NV_OPENGL_NT4_GDI_LOCK:
                    {
                        // this call is used from ICD softwarefunctions to check if their drawable
                        // is accessible => check against modeswitches etc.
                        if(  ( ((PDEV*)(pmdev->abdDevices[inCommand->devID].pso->dhpdev))->bEnabled )
                           &&( !(((PDEV*)(pmdev->abdDevices[inCommand->devID].pso->dhpdev))->dwGlobalModeSwitchCount & 0x1) )
                          )
                        {
                            ulRet = (ULONG)TRUE + 1;
                        }
                        else
                        {
                            // here we tell ICD that Escape reached server side, but did not succeed;
                            ulRet = (ULONG)TRUE;
                        }
                        break;
                    }
                    default:
                        // all other ESCAPES ( only ESC_NV_OPENGL_ESCAPE so far ) should
                        // have DevID filled out to reach the desired device
                        // otherwise they go to device 0
                        ASSERT(inCommand->devID < MAX_MULTIDEV);
                        ASSERT(pmdev->abdDevices[inCommand->devID].pso);
                        ulRet = DrvEscape(pmdev->abdDevices[inCommand->devID].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
                        break;
                }
                break;
            }

            // this is one of the few calls we have to redirect to the right device
            // devicenumber is  given as inCommand->hClass - NV01_DEVICE_0
            case NV_ESC_RM_ALLOC_DEVICE:
            {
                NVOS06_PARAMETERS *inParms;

                ASSERT( cjIn == sizeof(NVOS06_PARAMETERS) );
                inParms  = (NVOS06_PARAMETERS *)pvIn;

                ulDev = inParms->hClass - NV01_DEVICE_0;
                ASSERT(ulDev < MAX_MULTIDEV);

                // remember ParentObject ( created by alloc_root ) to redirect rm-calls
                // only take 1st one, others are not used elsawhere
                if( 0 == pmdev->abdDevices[ulDev].ulRoot )
                {
                    pmdev->abdDevices[ulDev].ulRoot = inParms->hObjectParent;
                }

                DISPDBG((95, "Redirecting NV_ESC_RM_ALLOC_DEVICE to device No: %d ( hRoot: 0x%x )",ulDev,inParms->hObjectParent));

                ASSERT(pmdev->abdDevices[ulDev].pso);
                ulRet = DrvEscape(pmdev->abdDevices[ulDev].pso, iEsc, cjIn, pvIn, cjOut, pvOut);

                break;
            }
            case ESC_NV_QUERYSET_REGISTRY_KEY: 
            {
                __PNVRegKeyInfo inParms, outParms;

                inParms = (__PNVRegKeyInfo) pvIn;

                ulDev = inParms->devID;

                // this is a hot fox for tools which do not 
                if( ulDev >= pmdev->ulNumDevicesActive )
                {
                    //ASSERT(ulDev < MAX_MULTIDEV);
                    ulDev = 0;
                }

                DISPDBG((0, "Redirecting ESC_NV_QUERYSET_REGISTRY_KEY to device No: %d ",ulDev));

                ASSERT(pmdev->abdDevices[ulDev].pso);
                ulRet = DrvEscape(pmdev->abdDevices[ulDev].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
                break;
            }

            case WNDOBJ_SETUP:
            {
                NV_WNDOBJ_SETUP *pNvWndObj;
                ULONG            ulDev;

                pNvWndObj  = (NV_WNDOBJ_SETUP *)pvIn;

                ulDev = pNvWndObj->devID;
                DISPDBG((0, "WNDOBJ_SETUP called with ulDev: 0x%x )",pNvWndObj->devID));

                ASSERT(pmdev->abdDevices[ulDev].pso);
                ulRet = DrvEscape(pmdev->abdDevices[ulDev].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
                break;
            }


            case NV_ESC_RM_ARCH_HEAP:
            {
                NVOS11_PARAMETERS *inParms;
                ULONG              ulDev;

                inParms  = (NVOS11_PARAMETERS *)pvIn;
                DISPDBG((0, "NV_ESC_RM_ARCH_HEAP called with hRoot: 0x%x )",inParms->hRoot));

                if( bFindDeviceRMRoot( pmdev->abdDevices, inParms->hRoot ) )
                {
                    // found matching device !
                    DISPDBG((0, "Redirecting NV_ESC_RM_ARCH_HEAP to device No: %d  ( hClass: 0x%x )",ulDev,inParms->hRoot));
//                    ulRet = DrvEscape(pmdev->abdDevices[0].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
//                    break;
                }
                // check for client to redirect it to the right client
    
//                break;
            }

            default:
                ulRet = DrvEscape(pmdev->abdDevices[0].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
                break;
        }
    }

    DISPDBG((100, "<<< MulEscape"));
    return ulRet;
}


//******************************************************************************
//
//  MulDrawEscape
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulDrawEscape(SURFOBJ *pso, ULONG    iEsc, CLIPOBJ *pco,
                    RECTL   *prcl, ULONG    cjIn, PVOID    pvIn)
{
    PPDEV ppdev = NULL;
    ULONG ulRet = 0;

    DISPDBG((100, "MulDrawEscape >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        ulRet = DrvDrawEscape(pso, iEsc, pco, prcl, cjIn, pvIn);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for( ulDev=0; ulDev < pmdev->ulNumDevicesActive; ulDev++ )
        {
            ASSERT(pmdev->abdDevices[ulDev].pso);
            ulRet = DrvDrawEscape(pmdev->abdDevices[ulDev].pso, iEsc, pco, prcl, cjIn, pvIn);
            if( -1 == (LONG)ulRet )
                break;
        }
    }

    DISPDBG((100, "<<< MulDrawEscape"));
    return ulRet;
}


//******************************************************************************
//
//  MulSwapBuffers
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL APIENTRY MulSwapBuffers(SURFOBJ *psoDst, WNDOBJ *pwo)
{
    PPDEV ppdev = NULL;
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulSwapBuffers >>>"));

    ppdev = (PPDEV)psoDst->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvSwapBuffers(psoDst, pwo);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        // this is a special case !! because of the PWO
        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ASSERT(pmdev->abdDevices[ulDev].pso);
            bRet = DrvSwapBuffers(pmdev->abdDevices[ulDev].pso, pwo);
        }
    }

    DISPDBG((100, "<<< MulSwapBuffers - %d", bRet));
    return bRet;
}


//******************************************************************************
//
//  bPixelFormatMatch
//
//  NT4 multiboard helper function which checks if 2 given pixelformats
//  do exactly match
//
//  return value FALSE: pixelformats do not match
//               TRUE:  pixelformats do exactly match
//
//******************************************************************************
BOOL bPixelFormatMatch( PIXELFORMATDESCRIPTOR* ppfd1,  PIXELFORMATDESCRIPTOR* ppfd2 )
{
    BOOL bRet = FALSE;
    
    if(   (ppfd1->nSize           == ppfd2->nSize) 
        &&(ppfd1->nVersion        == ppfd2->nVersion)
        &&(ppfd1->dwFlags         == ppfd2->dwFlags)
        &&(ppfd1->iPixelType      == ppfd2->iPixelType)
        &&(ppfd1->cColorBits      == ppfd2->cColorBits)
        &&(ppfd1->cRedBits        == ppfd2->cRedBits)
        &&(ppfd1->cRedShift       == ppfd2->cRedShift)
        &&(ppfd1->cGreenBits      == ppfd2->cGreenBits)
        &&(ppfd1->cGreenShift     == ppfd2->cGreenShift)
        &&(ppfd1->cBlueBits       == ppfd2->cBlueBits)
        &&(ppfd1->cBlueShift      == ppfd2->cBlueShift)
        &&(ppfd1->cAlphaBits      == ppfd2->cAlphaBits)
        &&(ppfd1->cAlphaShift     == ppfd2->cAlphaShift)
        &&(ppfd1->cAccumBits      == ppfd2->cAccumBits)
        &&(ppfd1->cAccumRedBits   == ppfd2->cAccumRedBits)
        &&(ppfd1->cAccumGreenBits == ppfd2->cAccumGreenBits)
        &&(ppfd1->cAccumBlueBits  == ppfd2->cAccumBlueBits)
        &&(ppfd1->cAccumAlphaBits == ppfd2->cAccumAlphaBits)
        &&(ppfd1->cDepthBits      == ppfd2->cDepthBits)
        &&(ppfd1->cStencilBits    == ppfd2->cStencilBits)
        &&(ppfd1->cAuxBuffers     == ppfd2->cAuxBuffers)
        &&(ppfd1->iLayerType      == ppfd2->iLayerType)
        &&(ppfd1->bReserved       == ppfd2->bReserved)
        &&(ppfd1->dwLayerMask     == ppfd2->dwLayerMask)
        &&(ppfd1->dwVisibleMask   == ppfd2->dwVisibleMask)
        &&(ppfd1->dwDamageMask    == ppfd2->dwDamageMask)
       )
       bRet = TRUE;

    return bRet;
}


//******************************************************************************
//
//  lReallocateMulPixelFormats
//
//  NT4 multiboard wrapper function which calculates a pixelformat list which 
//  contains only matching pixelformats of ALL enabled devices. This list is
//  stored in pmdev
//
//  return value is the number of matching pixelformats
//
//******************************************************************************
LONG lReallocateMulPixelFormats( PMDEV pmdev )
{
    PMUL_PIXELFORMAT         pmpfdFirstDevice;
    LONG                     lNumPixelFormatsFirstDevice;
    PIXELFORMATDESCRIPTOR    pfdTemp;
    LONG                     lNumPixelFormatsTemp;
    LONG                     lRet = 0;
    LONG                     l;
    lRet = 0;

    ASSERT(pmdev);
    ASSERT(pmdev->ulNumDevicesActive > 1);  // function is only designed for more than 1 device

    // we have to reallocate and fill a pixelformatlist 
    if( 0 != pmdev->PixelFormatList.iNumberOfPixelFormats )
    {
        ASSERT(pmdev->PixelFormatList.pPixelFormats);
        EngFreeMem(pmdev->PixelFormatList.pPixelFormats);
        pmdev->PixelFormatList.iNumberOfPixelFormats = 0;
    }

    lNumPixelFormatsFirstDevice = DrvDescribePixelFormat(pmdev->abdDevices[0].dhpdev, 1, 0, NULL);

    if( lNumPixelFormatsFirstDevice > 0 )
    {
        pmpfdFirstDevice = (PMUL_PIXELFORMAT)EngAllocMem(FL_ZERO_MEMORY, 
            (lNumPixelFormatsFirstDevice + 1)* sizeof(MUL_PIXELFORMAT), ALLOC_TAG); 
        if(pmpfdFirstDevice)
        {
            ULONG ulDev;

            lRet = lNumPixelFormatsFirstDevice;

            // get all pixelformats from 1st device
            for(l=1; l<=lNumPixelFormatsFirstDevice; l++)
            {
                LONG ll;
                ll = DrvDescribePixelFormat(pmdev->abdDevices[0].dhpdev, l
                        , sizeof(PIXELFORMATDESCRIPTOR), &(pmpfdFirstDevice[l].pfd));
                // remember number of pixelformat for device 0
                pmpfdFirstDevice[l].iPixelFormat[0]=l;
            }

            // now loop over all other devices and reset pixelformats in 1st device's list which does not match
            for(ulDev=1;ulDev<pmdev->ulNumDevicesActive;ulDev++)
            {
                LONG ll;
                lNumPixelFormatsTemp = DrvDescribePixelFormat(pmdev->abdDevices[ulDev].dhpdev, 1, 0, NULL);
                
                for(l=1; l <= lNumPixelFormatsFirstDevice; l++)
                {
                    if( 0 != pmpfdFirstDevice[l].pfd.nSize )
                    {
                        ll = DrvDescribePixelFormat(pmdev->abdDevices[ulDev].dhpdev, l, sizeof(PIXELFORMATDESCRIPTOR), &pfdTemp);
                        if( !bPixelFormatMatch(&(pmpfdFirstDevice[l].pfd),&pfdTemp ) )
                        {
                            // mark pixelformat as not valid
                            pmpfdFirstDevice[l].pfd.nSize = 0;
                            lRet--;
                            ASSERT(lRet>=0);
                        }
                        else
                        {
                            // found a matching pixelformat => remember number for device ulDev
                            pmpfdFirstDevice[l].iPixelFormat[ulDev]=l;
                        }
                    }
                }
            }
        
            // here we have a list of valid pixelformats ( lRet is the number of it ) 
            // and indices for each device which points to it 
            // now copy valid pixelformats into pmdev
            pmdev->PixelFormatList.iNumberOfPixelFormats = 0;
            pmdev->PixelFormatList.pPixelFormats 
                = (PMUL_PIXELFORMAT)EngAllocMem(FL_ZERO_MEMORY, lRet * sizeof(MUL_PIXELFORMAT), ALLOC_TAG);
            ASSERT(pmdev->PixelFormatList.pPixelFormats);
            for( l=1;l <= lNumPixelFormatsFirstDevice;l++)
            {
                if( 0 != pmpfdFirstDevice[l].pfd.nSize )
                {
                    // copy pixelformat and indices into pmdev
                    pmdev->PixelFormatList.pPixelFormats[pmdev->PixelFormatList.iNumberOfPixelFormats] = pmpfdFirstDevice[l];
                    // remember copied number
                    pmdev->PixelFormatList.iNumberOfPixelFormats++;  
                    ASSERT(lRet>=pmdev->PixelFormatList.iNumberOfPixelFormats);
                }
            }

            EngFreeMem(pmpfdFirstDevice);
        }
    }

    return lRet;
}


//******************************************************************************
//
//  MulSetPixelFormat
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL APIENTRY MulSetPixelFormat(
    SURFOBJ *pso,
    LONG    iPixelFormat,
    HWND    hWnd)
{
    PPDEV ppdev = NULL;
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulSetPixelFormat >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvSetPixelFormat(pso, iPixelFormat, hWnd);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        LONG    lPixelFormatDevice;

        ASSERT(NULL!=pmdev->PixelFormatList.pPixelFormats);

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            // get matching pixelformat of device
            lPixelFormatDevice = pmdev->PixelFormatList.pPixelFormats[iPixelFormat].iPixelFormat[ulDev];

            bRet =  DrvSetPixelFormat(pmdev->abdDevices[ulDev].pso, lPixelFormatDevice, hWnd);
            if( !bRet )
            {
                ASSERT(FALSE);
                break;
            }
        }
    }

    DISPDBG((100, "<<< MulSetPixelFormat"));
    return bRet;
}


//******************************************************************************
//
//  MulDescribePixelFormat
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
LONG APIENTRY MulDescribePixelFormat(
    DHPDEV                  dhpdev,
    LONG                    iPixelFormat,
    ULONG                   cjpfd,
    PIXELFORMATDESCRIPTOR   *ppfd)
{
    LONG  lRet  = 0;
    PPDEV ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulDescribePixelFormat >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        lRet = DrvDescribePixelFormat(dhpdev, iPixelFormat, cjpfd, ppfd);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  

        //we do a match here to export only pixelformats which exist on ALL devices !
        // app does query us for a pixelformatlist
        if( NULL == ppfd )
        {
            lRet = lReallocateMulPixelFormats(pmdev);
        }
        else
        {
            ASSERT(NULL!=pmdev->PixelFormatList.pPixelFormats);

            lRet = pmdev->PixelFormatList.iNumberOfPixelFormats;
            if( cjpfd >= sizeof(PIXELFORMATDESCRIPTOR) )
                // our multimon pixelformatlist is zero based !!
                (*ppfd) = pmdev->PixelFormatList.pPixelFormats[iPixelFormat-1].pfd;
        }
    }

    DISPDBG((100, "<<< MulDescribePixelFormat"));
    return lRet;
}

#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4multidev.c ===
//************************** Module Header *************************************
//                                                                             
//  Module Name: nt4multidev.c                                                 
//                                                                             
//  This module contains the functions that belong to the multi device wrapper 
//
//
//  NT4 MultiBoard functionality description:
//
// Supports multiple display boards as a single virtual desktop.
//
// This is implemented by presenting to GDI a single large virtual
// display and adding a layer between GDI and the driver's Drv functions.
// For  most part, the rest of the driver outside of multidev wrapper 
// doesn't have to change much, subject to the requirements below.
//
// This implementation requires that each board have the same colour depth,
// the resolution may vary but all of the the boards have to be arranged 
// in a rectangular configuration.
//
// Each board has its own PDEV, and completely manages its surface
// independently.
//
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               
//                                                                             
//*****************************************************************************
#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"

#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV


// this is the functiontable we export in NT4-case to be able to support NT4 multimon
DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) MulEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) MulCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) MulDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) MulEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) MulDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) MulAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) MulMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) MulSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },  // can be redirected to 1st board
    {   INDEX_DrvSetPalette,            (PFN) MulSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) MulCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) MulBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) MulTextOut            },
    {   INDEX_DrvGetModes,              (PFN) MulGetModes           },
    {   INDEX_DrvLineTo,                (PFN) MulLineTo             },
    {   INDEX_DrvStrokePath,            (PFN) MulStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) MulFillPath           },  // not supported
    {   INDEX_DrvPaint,                 (PFN) MulPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) MulRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) MulCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) MulDeleteDeviceBitmap },
//  {   INDEX_DrvStretchBlt,            (PFN) MulStretchBlt         },  // not implemented or hooked
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },  // if we need to implement, we 
#ifndef NVGDI                                                           //need to change FONTOBJ->pvconsumer
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) MulGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) MulEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) MulDisableDirectDraw  },
#endif
    {   INDEX_DrvSynchronize,           (PFN) MulSynchronize        },
    {   INDEX_DrvEscape,                (PFN) MulEscape             },
    {   INDEX_DrvDrawEscape,            (PFN) MulDrawEscape         },
    {   INDEX_DrvResetPDEV,             (PFN) MulResetPDEV          },
    {   INDEX_DrvDescribePixelFormat,   (PFN) MulDescribePixelFormat},
    {   INDEX_DrvSetPixelFormat,        (PFN) MulSetPixelFormat     },
    {   INDEX_DrvSwapBuffers,           (PFN) MulSwapBuffers        },
#if (NVARCH >= 0x4)
    {   INDEX_DrvSaveScreenBits,        (PFN) MulSaveScreenBits     },
#endif
};
ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);





BOOL bSwapCompareCallback(RECTL *prcl1, RECTL *prcl2, ULONG	iDir)
{
    BOOL bSwap = FALSE;

    ASSERT(prcl1);
    ASSERT(prcl2);

    switch (iDir)
    {
    case CD_RIGHTDOWN:
        if (prcl1->top > prcl2->top)
        {
            bSwap = TRUE;
        }
        else if (prcl1->top == prcl2->top)
        {
            if (prcl1->left > prcl2->left)
            {
                bSwap = TRUE;
            }
        }
        break;
    case CD_LEFTDOWN:
        if (prcl1->top > prcl2->top)
        {
            bSwap = TRUE;
        }
        else if (prcl1->top == prcl2->top)
        {
            if (prcl1->left < prcl2->left)
            {
                bSwap = TRUE;
            }
        }
        break;
    case CD_RIGHTUP:
        if (prcl1->top < prcl2->top)
        {
            bSwap = TRUE;
        }
        else if (prcl1->top == prcl2->top)
        {
            if (prcl1->left > prcl2->left)
            {
                bSwap = TRUE;
            }
        }
        break;
    case CD_LEFTUP:
        if (prcl1->top < prcl2->top)
        {
            bSwap = TRUE;
        }
        else if (prcl1->top == prcl2->top)
        {
            if (prcl1->left < prcl2->left)
            {
                bSwap = TRUE;
            }
        }
        break;
    case CD_ANY:
    default:
        bSwap = FALSE;
    }
    return bSwap;
}


// some helper funtions
ULONG DEVOBJ_cEnumStart(IN PDEVOBJ  pdo,
                        IN SURFOBJ  *pso,
                        IN RECTL    *prclBounds, // dont care if bAll = TRUE
                        IN BOOL     bAll,       // TRUE: enumerates all, FALSE enumerates only dev clipped against prclbounds
                        IN ULONG    iDir)  // CD_ANY...
{
    PMDEV   pmdev;
    ULONG   ul;
    ULONG   ulRet;
    ULONG   ulOuter;
    ULONG   ulInner;

    pdo->pso = pso;

    if (bNeedToEnumerate(pso))
    {
        pmdev               = ((PPDEV)pso->dhpdev)->pmdev;

        pdo->pmdev          = pmdev;
        pdo->enumStart      = 0;

        // copy to pointer array
        for (ul = 0; ul < pmdev->ulNumDevicesActive; ul++)
        {
            pdo->apbdDevices[ul] = &pdo->pmdev->abdDevices[ul];
            pdo->enumStart++;
        }

        if (pmdev->ulNumDevicesActive > 1)
        {
            for (ulOuter = 0; ulOuter < (pmdev->ulNumDevicesActive - 1); ulOuter++)
            {
                for (ulInner = ulOuter + 1; ulInner < pmdev->ulNumDevicesActive; ulInner++)
                {
                    if (bSwapCompareCallback(&pdo->apbdDevices[ulOuter]->rclBoard, &pdo->apbdDevices[ulInner]->rclBoard, iDir))
                    {
                        PBOARDDESC pScratch;
                        pScratch = pdo->apbdDevices[ulOuter];
                        pdo->apbdDevices[ulOuter] = pdo->apbdDevices[ulInner];
                        pdo->apbdDevices[ulInner] = pScratch;
                    }
                }
            }
        }

        pdo->cDevices = pmdev->ulNumDevicesActive;
        ulRet = pmdev->ulNumDevicesActive;
    }
    else
    {
        pdo->pmdev      = NULL;
        pdo->cDevices   = 1; 
        ulRet           = 1;
    }

    return (ulRet);
}

BOOL DEVOBJ_bEnum(IN PDEVOBJ    pdo,
                  IN ENUMDEV16  *pEnumDev16)
{
    ULONG ul;
    BOOL    bRet;

    ASSERT(pdo);
    ASSERT(pEnumDev16);

    pEnumDev16->c = pdo->cDevices;

    if (pdo->pmdev)
    {
        for (ul = 0; ul < pEnumDev16->c; ul++)
        {
            pEnumDev16->apbdDevices[ul] = pdo->apbdDevices[ul];
            pdo->enumStart++;
        }
        bRet = pdo->enumStart < pdo->pmdev->ulNumDevicesActive ? TRUE : FALSE;
    }
    else
    {
        ASSERT(pEnumDev16->c == 1);
        pEnumDev16->apbdDevices[0] = NULL;
        pdo->enumStart++;
        bRet = FALSE;
    }
    return bRet;
}
                        



// the wrapper functions


//******************************************************************************
//
//  bGetNumberOfDevices
//
//  NT4 multiboard helper function to get number of initialized (nVidia graphics )
//  devices from miniport
//
//  returns TRUE  if call to miniport succeded
//          FALSE if call to miniport did fail
//
//******************************************************************************
BOOL bGetNumberOfDevices( HANDLE hDriver, ULONG_PTR* pulNumberOfDevices )
{
    BOOL                        bRet = FALSE;
    QUERY_NUM_OF_DEVICE_OBJECTS NumOfDevObj;
    ULONG                       ulReturnedDataLength;

    ASSERT(pulNumberOfDevices);
    ASSERT(hDriver);

    NumOfDevObj.hDriver     = hDriver;

    // call minipoirt to get adresses of all initialized device handles
    if(  ( EngDeviceIoControl(hDriver,
                              IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS,
                              &NumOfDevObj,
                              sizeof(QUERY_NUM_OF_DEVICE_OBJECTS),
                              &NumOfDevObj,
                              sizeof(QUERY_NUM_OF_DEVICE_OBJECTS),
                              &ulReturnedDataLength ) )
       ||( ulReturnedDataLength != sizeof(QUERY_NUM_OF_DEVICE_OBJECTS) )
      ) 
    {
        DISPDBG((0, "bGetNumberOfDevices - IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS failed"));
        pulNumberOfDevices = 0;
    }
    else
    {
        DISPDBG((95, "bGetNumberOfDevices - IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS found %d device objects", NumOfDevObj.ulNumDevObj));
        *pulNumberOfDevices  = NumOfDevObj.ulNumDevObj;
        bRet                 = TRUE;
    }

    return bRet;
}


//******************************************************************************
//
//  bGetDeviceObjects
//
//  NT4 multiboard helper function to get handles to initialized (nVidia graphics )
//  devices from miniport
//
//  returns TRUE  if call to miniport succeded
//          FALSE if call to miniport did fail
//
//******************************************************************************
BOOL bGetDeviceObjects( HANDLE hDriver, HANDLE ahDriver[MAX_MULTIDEV])
{
    BOOL  bRet     = FALSE;
    ULONG ulDevNum = 0;

    ASSERT(ahDriver);
    ASSERT(hDriver);

    // preset hDriverarray to zero
    RtlZeroMemory(ahDriver,sizeof(HANDLE)*MAX_MULTIDEV);

    // does miniport support multibple devices and do we have one or more ?
    if(   (bGetNumberOfDevices(hDriver,&ulDevNum))
        &&(ulDevNum > 0 )
       )
    {
        GET_DEVICE_OBJECTS  *pGetDevObj;
        ULONG                ulSizeOfGetDeviceObjects; 
        ULONG                ulReturnedDataLength;
        
        // allocate right size for miniport access
        ulSizeOfGetDeviceObjects = sizeof(GET_DEVICE_OBJECTS) + (ulDevNum - 1) * sizeof (HANDLE);
        pGetDevObj = (GET_DEVICE_OBJECTS *)EngAllocMem(FL_ZERO_MEMORY, ulSizeOfGetDeviceObjects, ALLOC_TAG); ;
        if (pGetDevObj)
        {
            pGetDevObj->hDriver     = hDriver;
            pGetDevObj->ulNumDevObj = ulDevNum;

            // ask miniport for hDriver of all nvidia graphic devices in system
            if (EngDeviceIoControl(hDriver,
                                   IOCTL_VIDEO_GET_DEVICE_OBJECTS,
                                   pGetDevObj,
                                   ulSizeOfGetDeviceObjects,
                                   pGetDevObj,
                                   ulSizeOfGetDeviceObjects,
                                   &ulReturnedDataLength) || ulReturnedDataLength != ulSizeOfGetDeviceObjects)
            {
                DISPDBG((0, "bGetDeviceObjects - IOCTL_VIDEO_GET_DEVICE_OBJECTS failed"));
            }
            else
            {
                ULONG ulDev;
                DISPDBG((95, "bGetDeviceObjects - hDriver 0x%x found %d devices", hDriver,ulDevNum));
                for (ulDev = 0; ulDev < ulDevNum; ulDev++)
                {
                    ahDriver[ulDev] = pGetDevObj->ahDriver[ulDev];
                    DISPDBG((95, "bGetDeviceObjects - no %d: hDriver: 0x%x",ulDev,ahDriver[ulDev]));
                }
                bRet = TRUE;
            }

            EngFreeMem(pGetDevObj);
        }
    }

    return bRet;
}


//******************************************************************************
//
//  bIsMultiMonMode
//
//  NT4 multiboard helper function check whether given mode is a multimon mode
//  or not
//
//  returns TRUE  if given mode is a multi device
//          FALSE if given mode is no multi device mode
//
//******************************************************************************
BOOL bIsMultiMonMode( HANDLE hDriver, DEVMODEW* pdm)
{
    BOOL    bRet = FALSE;
    ULONG   ulSingleDevWidth;  // width  of each single device    
    ULONG   ulSingleDevHeight; // height of each single device    
    ULONG   ulModeDescription; // width << 16 | height to be able to do a switch

    ASSERT(pdm);
    ASSERT(hDriver);
    // we may have to find another mechanism to check wether we need a
    // multimon resolution or not

    // try to calculate an aspect ration for desired mode and check
    // wheter it is an multimon mode or not
    ulSingleDevWidth  = pdm->dmPelsWidth;
    ulSingleDevHeight = pdm->dmPelsHeight;

    if (ulSingleDevWidth && ulSingleDevHeight)
    {
        ulModeDescription = (ulSingleDevWidth << 16) | ulSingleDevHeight;
        
        switch( ulModeDescription )
        {
        case 0x08000300: // 2048 *  768
        case 0x04000600: // 1024 * 1536
        case 0x08000400: // 2048 * 1536
            bRet = TRUE;
            break;
        default:
            break;
        }
    }
    else
    {
        ASSERT(FALSE);
    }

    return bRet;
}


//******************************************************************************
//
//  bGetSingleDeviceRect
//
//  NT4 multiboard helper function calcualtes the rect of the given device
//
//  returns TRUE  if rect could be calculated
//          FALSE if rect not could be calculated
//
//******************************************************************************
BOOL bGetSingleDeviceRect( HANDLE hDriver, DEVMODEW* pdm, ULONG ulDev, RECTL* prclDevice )
{
    BOOL bRet = FALSE;

    ASSERT(pdm);
    ASSERT(hDriver);
    ASSERT(prclDevice);
    ASSERT(ulDev < MAX_MULTIDEV);

    if(bIsMultiMonMode(hDriver,pdm))
    {
        // for now just track 1 mode: 800 * 300
        switch( (pdm->dmPelsWidth << 16) | pdm->dmPelsHeight)
        {
        case 0x08000300:
        case 0x0B000300:
        case 0x10000300:
            prclDevice->left   =  ulDev     * 0x400;
            prclDevice->right  = (ulDev + 1)* 0x400;
            prclDevice->top    = 0;
            prclDevice->bottom = 0x300;
            bRet = TRUE;
            break;
        case 0x04000600:
            prclDevice->left   = 0;
            prclDevice->right  = 0x400;
            prclDevice->top    =  ulDev     * 0x300;
            prclDevice->bottom = (ulDev + 1)* 0x300;
            bRet = TRUE;
            break;
        default:
            break;
        }
    }

    return bRet;
}

//******************************************************************************
//
//  MulEnablePDEV
//
//  NT4 multiboard wrapper function which tries to initialize the desired
//  number of single devices and sets up the multiboard environment
// otherwise it only calls the singleboard DrvEnablePDEV
//
//******************************************************************************
DHPDEV MulEnablePDEV(DEVMODEW* pdm, PWSTR pwszLogAddr, ULONG  cPat, HSURF* phsurfPatterns, 
                     ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi,            
                     HDEV  hdev, PWSTR pwszDeviceName, HANDLE hDriver)        
{
    PMDEV   pmdev = NULL;                   // ppdev for multidevice case
    HANDLE  ahDriver[MAX_MULTIDEV];         // device handles from MulEnableDriver
    ULONG   ulNumDev = 0;
    DHPDEV  dhpdevRet = NULL;

    DISPDBG((100, "MulEnablePDEV >>>"));

    ASSERT(pdm);
    ASSERT(hDriver);

    // do we should run in multimon-mode ?
    if(   (bIsMultiMonMode(hDriver,pdm))
        &&(bGetNumberOfDevices( hDriver, &ulNumDev ))
        &&(ulNumDev > 1) // caution: don't remove this check here !
        &&(bGetDeviceObjects(hDriver,ahDriver)) // get hDriver of devices
       )
    {
        // here we know there are ulDev (more than 1) nvidia graphic devices activated and
        // we have objecthandles for them
        pmdev = (PMDEV)EngAllocMem(FL_ZERO_MEMORY, sizeof(MDEV), ALLOC_TAG); 
        if (pmdev)
        {
            ULONG   ulDev = 0;

            // do some multiboard initialisation
            pmdev->dwUniq               = PMDEV_UNIQ;
            pmdev->hdev                 = hdev;
            pmdev->hDriver              = hDriver;
            pmdev->rclDesktop.left      = 0;
            pmdev->rclDesktop.top       = 0;
    //      pmdev->rclDesktop.right     = max (pdm->dmPanningWidth, pdm->dmPelsWidth);
    //      pmdev->rclDesktop.bottom    = max (pdm->dmPanningHeight, pdm->dmPelsHeight);
            pmdev->rclDesktop.right     = pdm->dmPelsWidth;
            pmdev->rclDesktop.bottom    = pdm->dmPelsHeight;
            pmdev->DevMode              = *pdm;
            pmdev->ulNumDevicesActive   = ulNumDev;

            for(ulDev = 0; ulDev < ulNumDev; ulDev++)
            {
                // try to get device rectangle for current mode and device
                if( bGetSingleDeviceRect(hDriver, pdm, ulDev, &pmdev->abdDevices[ulDev].rclBoard) )
                {
                    ASSERT(ahDriver[ulDev]);
                    // fill up necessary board related information
                    pmdev->abdDevices[ulDev].bIsActive              = TRUE;
                    pmdev->abdDevices[ulDev].hDriver                = ahDriver[ulDev];
                    pmdev->abdDevices[ulDev].DevMode                = pmdev->DevMode;
                    pmdev->abdDevices[ulDev].DevMode.dmPelsWidth    = lRclWidth(&pmdev->abdDevices[ulDev].rclBoard);
                    pmdev->abdDevices[ulDev].DevMode.dmPelsHeight   = lRclHeight(&pmdev->abdDevices[ulDev].rclBoard);
                    pmdev->abdDevices[ulDev].pcoBoard               = EngCreateClip();
                    pmdev->abdDevices[ulDev].pcoBoard->iDComplexity = DC_RECT;
                    pmdev->abdDevices[ulDev].pcoBoard->rclBounds    = pmdev->abdDevices[ulDev].rclBoard;
                    pmdev->abdDevices[ulDev].pco                    = EngCreateClip();
                    pmdev->abdDevices[ulDev].pco->iDComplexity      = DC_RECT;
                    pmdev->abdDevices[ulDev].pco->rclBounds         = pmdev->abdDevices[ulDev].rclBoard;
                    pmdev->abdDevices[ulDev].rclSavedBounds         = rclEmpty;
                    pmdev->abdDevices[ulDev].pso                    = NULL;
                    pmdev->abdDevices[ulDev].psoBitmap              = NULL;
                    pmdev->abdDevices[ulDev].cjCaps                 = cjCaps;
                    pmdev->abdDevices[ulDev].cjDevInfo              = cjDevInfo;

                    pmdev->abdDevices[ulDev].pdevcaps = (ULONG *)EngAllocMem(FL_ZERO_MEMORY, pmdev->abdDevices[ulDev].cjCaps, ALLOC_TAG); 
                    if( !pmdev->abdDevices[ulDev].pdevcaps )
                    {
                        ASSERT(pmdev->abdDevices[ulDev].pdevcaps);
                        DISPDBG((0,"MulEnablePDEV: Could not allocate memory for pmdev->abdDevices[%d].pdevcaps",ulDev));
                        break;
                    }
                    pmdev->abdDevices[ulDev].pdi = (DEVINFO *)EngAllocMem(FL_ZERO_MEMORY, pmdev->abdDevices[ulDev].cjDevInfo, ALLOC_TAG); 
                    if( !pmdev->abdDevices[ulDev].pdi )
                    {
                        ASSERT(pmdev->abdDevices[ulDev].pdi);
                        DISPDBG((0,"MulEnablePDEV: Could not allocate memory for pmdev->abdDevices[%d].pdi",ulDev));
                        break;
                    }
                    // here we call the single board driver to allocate a normal singleboard ppdev
                    pmdev->abdDevices[ulDev].dhpdev = DrvEnablePDEV(&pmdev->abdDevices[ulDev].DevMode,
                                                                    NULL, 
                                                                    0, 
                                                                    NULL, 
                                                                    pmdev->abdDevices[ulDev].cjCaps, 
                                                                    pmdev->abdDevices[ulDev].pdevcaps, 
                                                                    pmdev->abdDevices[ulDev].cjDevInfo, 
                                                                    pmdev->abdDevices[ulDev].pdi,
                                                                    pmdev->hdev, 
                                                                    pwszDeviceName, 
                                                                    pmdev->abdDevices[ulDev].hDriver);
                    if( !pmdev->abdDevices[ulDev].dhpdev )
                    {
                        ASSERT(pmdev->abdDevices[ulDev].dhpdev);
                        DISPDBG((0,"MulEnablePDEV: DrvEnablePDEV for device %d failed !",ulDev));
                        break;
                    }
                        // let board know it's boundaries for ICD clip purposes
                    ((PDEV*)(pmdev->abdDevices[ulDev].dhpdev))->left  = pmdev->abdDevices[ulDev].rclBoard.left;
                    ((PDEV*)(pmdev->abdDevices[ulDev].dhpdev))->top   = pmdev->abdDevices[ulDev].rclBoard.top;
                    ((PDEV*)(pmdev->abdDevices[ulDev].dhpdev))->pmdev = pmdev; // remember pmdev in each ppdev
                }
                else
                {
                    DISPDBG((0,"MulEnablePDEV: Could not get rect for device %d !",ulDev));
                    break;
                }
            }
            // here we have to check if something went wrong 
            // on error case release all previously allocated pdevs
            // this is the error case because previous loop runs util ulDev == ulNumDev if no error case
            if(ulDev < ulNumDev )
            {
                for(;ulDev>MAX_MULTIDEV;ulDev-- )
                {
                    if( !pmdev->abdDevices[ulDev].pdevcaps )
                        EngFreeMem(pmdev->abdDevices[ulDev].pdevcaps);
                    if( !pmdev->abdDevices[ulDev].pdi )
                        EngFreeMem(pmdev->abdDevices[ulDev].pdi);
                    if( !pmdev->abdDevices[ulDev].dhpdev )
                        EngFreeMem(pmdev->abdDevices[ulDev].dhpdev);
                }
                EngFreeMem(pmdev);

                DISPDBG((0,"MulEnablePDEV failed !"));
            }
            else
            {
                // everything succeded, now adapt devcaps and return
                RtlCopyMemory(pdi, pmdev->abdDevices[0].pdi, cjDevInfo);
                RtlCopyMemory(pdevcaps, pmdev->abdDevices[0].pdevcaps, cjCaps);
                ((GDIINFO *)pdevcaps)->ulHorzRes        = pmdev->rclDesktop.right - pmdev->rclDesktop.left;
                ((GDIINFO *)pdevcaps)->ulVertRes        = pmdev->rclDesktop.bottom - pmdev->rclDesktop.top;
                ((GDIINFO *)pdevcaps)->ulPanningHorzRes = pmdev->rclDesktop.right - pmdev->rclDesktop.left;
                ((GDIINFO *)pdevcaps)->ulPanningVertRes = pmdev->rclDesktop.bottom - pmdev->rclDesktop.top;
                ((GDIINFO *)pdevcaps)->ulHorzSize       = pmdev->rclDesktop.right - pmdev->rclDesktop.left;
                ((GDIINFO *)pdevcaps)->ulVertSize       = pmdev->rclDesktop.bottom - pmdev->rclDesktop.top;

                // returning the ppdev ot 1st device => we can catch our pmdev out of this !
                dhpdevRet = pmdev->abdDevices[0].dhpdev;
            }
        }
        else
            DISPDBG((0,"MulEnablePDEV: could not allocated Memory for multiple ppdev !!"));

        DISPDBG((95, "MulEnablePDEV: enabled multi device handling"));
    }
    else
    {
        // single board resolution is desired / available => just call singleboard driver with
        // incoming values
        dhpdevRet = DrvEnablePDEV(pdm,pwszLogAddr,cPat,phsurfPatterns, 
                                  cjCaps,pdevcaps,cjDevInfo,pdi,            
                                  hdev,pwszDeviceName,hDriver);
    }

    DISPDBG((100, "<<< MulEnablePDEV"));
    return dhpdevRet;
}


//******************************************************************************
//
//  MulDisablePDEV
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulDisablePDEV(DHPDEV  dhpdev)
{
    PPDEV   ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulDisablePDEV >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvDisablePDEV(dhpdev);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        // call DrvDisablePDEV for each single device
        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ASSERT(pmdev->abdDevices[ulDev].dhpdev);
            DrvDisablePDEV(pmdev->abdDevices[ulDev].dhpdev);
            pmdev->abdDevices[ulDev].dhpdev     = NULL;

            EngFreeMem(pmdev->abdDevices[ulDev].pdi);
            pmdev->abdDevices[ulDev].pdi        = NULL;
            pmdev->abdDevices[ulDev].cjDevInfo  = 0;

            EngFreeMem(pmdev->abdDevices[ulDev].pdevcaps);
            pmdev->abdDevices[ulDev].pdevcaps   = NULL;
            pmdev->abdDevices[ulDev].cjCaps     = 0;

            EngDeleteClip(pmdev->abdDevices[ulDev].pco);
            pmdev->abdDevices[ulDev].pco        = NULL;

            EngDeleteClip(pmdev->abdDevices[ulDev].pcoBoard);
            pmdev->abdDevices[ulDev].pcoBoard   = NULL;
        }

        EngFreeMem(pmdev);
        pmdev = NULL;
    }

    DISPDBG((100, "<<< MulDisablePDEV"));
    return;
}

//******************************************************************************
//
//  MulCompletePDEV
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulCompletePDEV(DHPDEV dhpdev, HDEV hdev)
{
    PPDEV   ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulCompletePDEV >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvCompletePDEV(dhpdev,hdev);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ASSERT(pmdev->abdDevices[ulDev].dhpdev);
            DrvCompletePDEV(pmdev->abdDevices[ulDev].dhpdev, hdev);
        }
    }

    DISPDBG((100, "<<< MulCompletePDEV"));
    return;
}


//******************************************************************************
//
//  MulResetPDEV
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew)
{
    PPDEV   ppdevOld = (PPDEV)dhpdevOld;
    PPDEV   ppdevNew = (PPDEV)dhpdevNew;
    BOOL    bRet     = FALSE;

    DISPDBG((100, "MulResetPDEV >>>"));

    ASSERT(ppdevOld);
    ASSERT(ppdevNew);

    
    if( !ppdevNew->pmdev && !ppdevOld->pmdev )
    {
        // both modes are singleboard ones ?
        bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);
    }
    // switch from multiboard to singleboard resolution
    else if( !ppdevNew->pmdev && ppdevOld->pmdev ) 
    {
        // we only allow mode switches when no icd app is running
        if(0==globalOpenGLData.oglDrawableClientCount)
        {
            bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);
        }
    }
    // switch from singleboard to multiboard resolution
    else if(  ppdevNew->pmdev && !ppdevOld->pmdev ) 
    {
        // we only allow mode switches when no icd app is running
        if(0==globalOpenGLData.oglDrawableClientCount)
        {
            PMDEV   pmdevNew = ppdevNew->pmdev;
            ULONG   ulDev;

            for (ulDev = 0; ulDev < pmdevNew->ulNumDevicesActive; ulDev++)
            {
                bRet = DrvResetPDEV(dhpdevOld, pmdevNew->abdDevices[ulDev].dhpdev);
                if(!bRet)
                    goto Exit;
            }
        }
    }
    // switch from one singleboard to another multiboard resolution
    else
    {
        // we only allow mode switches when no icd app is running
        if(0==globalOpenGLData.oglDrawableClientCount)
        {
            PMDEV   pmdevNew = ppdevNew->pmdev;
            ULONG   ulDev;

            ASSERT(ppdevNew->pmdev);
            ASSERT(ppdevOld->pmdev);
            for (ulDev = 0; ulDev < pmdevNew->ulNumDevicesActive; ulDev++)
            {
                bRet = DrvResetPDEV(dhpdevOld, pmdevNew->abdDevices[ulDev].dhpdev);
                if(!bRet)
                    goto Exit;
            }
        }
    }

Exit:
    DISPDBG((100, "<<< MulResetPDEV"));

    return bRet;
}


//******************************************************************************
//
//  MulSynchronize
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulSynchronize(DHPDEV dhpdev, RECTL  *prcl)
{
    PPDEV   ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulSynchronize >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvSynchronize(dhpdev, prcl);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            DrvSynchronize(pmdev->abdDevices[ulDev].dhpdev, prcl);
        }
    }

    DISPDBG((100, "<<< MulSynchronize"));
    return;
}


//******************************************************************************
//
//  MulEnableSurface
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
HSURF MulEnableSurface(DHPDEV dhpdev)
{
    PPDEV   ppdev       = (PPDEV)dhpdev;
    HSURF   hSurfRet    = NULL;

    DISPDBG((100, "MulEnableSurface >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        hSurfRet = DrvEnableSurface(dhpdev);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        SIZEL   sizl;
        LONG    lWidth;
        ULONG   iFormat;
        PVOID   pvBits;
        SURFOBJ *pso;
        BOOL    bEAS;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ppdev                          = (PPDEV)pmdev->abdDevices[ulDev].dhpdev;
            pmdev->abdDevices[ulDev].hsurf = DrvEnableSurface(pmdev->abdDevices[ulDev].dhpdev);

            if( 0 == pmdev->abdDevices[ulDev].hsurf )
            {
                ASSERT(FALSE);
                goto MulExit;
            }

            //  Note: EngAssociateSurface is also responsible for giving the dhpdev to the pso of hsurf
            bEAS                                    = EngAssociateSurface(pmdev->abdDevices[ulDev].hsurf, pmdev->hdev, 0);
            pmdev->abdDevices[ulDev].pso            = EngLockSurface(pmdev->abdDevices[ulDev].hsurf);
            // NOTE: this must be after EngAssociateSurface
            pmdev->abdDevices[ulDev].pso->dhpdev    = pmdev->abdDevices[ulDev].dhpdev;
            pmdev->abdDevices[ulDev].dhsurf         = pmdev->abdDevices[ulDev].pso->dhsurf;

            if (pmdev->abdDevices[ulDev].pso->dhsurf != (DHSURF)&ppdev->dsurfScreen)
            {
                pmdev->abdDevices[ulDev].pso->dhsurf = (DHSURF)&ppdev->dsurfScreen;
            }

            sizl.cx                                 = ppdev->cxScreen;
            sizl.cy                                 = ppdev->cyScreen;
            lWidth                                  = ppdev->lDelta;
            iFormat                                 = ppdev->iBitmapFormat;
            pvBits                                  = ppdev->pjScreen;
            pmdev->abdDevices[ulDev].hsurfBitmap    = EngCreateBitmap(sizl, lWidth, iFormat, BMF_TOPDOWN, pvBits);
            pmdev->abdDevices[ulDev].psoBitmap      = EngLockSurface(pmdev->abdDevices[ulDev].hsurfBitmap);

        }

        pmdev->flHooks = pmdev->abdDevices[0].ppdev->flHooks;

        sizl.cx        = pmdev->rclDesktop.right - pmdev->rclDesktop.left;
        sizl.cy        = pmdev->rclDesktop.bottom - pmdev->rclDesktop.top;
        iFormat;       // still is initialized from the loop
        lWidth         = ((sizl.cx  * (iFormat - BMF_4BPP)) + 3) & 0xFFFFFFFC;
        pvBits;        // still has a non NULL value, dont care which for now

        // create a hsurf for pmdev, but associate with ppdev[0] to be able to do
        // single board shortcut
        pmdev->hsurf   = EngCreateDeviceSurface(pmdev->abdDevices[ulDev].dhpdev, sizl, iFormat);

        if (!EngAssociateSurface(pmdev->hsurf, pmdev->hdev, pmdev->flHooks))
        {
            EngDeleteSurface(pmdev->hsurf);
            pmdev->hsurf = NULL;

            // cleanup has to be done here !
            ASSERT( FALSE);
            goto MulExit;
        }

        pmdev->pco                  = EngCreateClip();
        pmdev->pco->iMode           = TC_RECTANGLES;
        pmdev->pco->iDComplexity    = DC_RECT;
        pmdev->pco->rclBounds       = pmdev->rclDesktop;

        hSurfRet = pmdev->hsurf;

MulExit:
        if( !hSurfRet )
        {
            // cleanup necessary !
            for(; ulDev >= 0; ulDev-- )
            {
                EngUnlockSurface(pmdev->abdDevices[ulDev].psoBitmap);
                pmdev->abdDevices[ulDev].psoBitmap      = NULL;

                EngDeleteSurface(pmdev->abdDevices[ulDev].hsurfBitmap);
                pmdev->abdDevices[ulDev].hsurfBitmap = NULL;

                EngUnlockSurface(pmdev->abdDevices[ulDev].pso);
                pmdev->abdDevices[ulDev].pso = NULL;
                DrvDisableSurface(pmdev->abdDevices[ulDev].dhpdev);
            }
        }
    }

    DISPDBG((100, "<<< MulEnableSurface"));
    return hSurfRet;
}


//******************************************************************************
//
//  MulDisableSurface
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulDisableSurface(DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulDisableSurface >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvDisableSurface(dhpdev);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            EngUnlockSurface(pmdev->abdDevices[ulDev].psoBitmap);
            pmdev->abdDevices[ulDev].psoBitmap      = NULL;

            EngDeleteSurface(pmdev->abdDevices[ulDev].hsurfBitmap);
            pmdev->abdDevices[ulDev].hsurfBitmap = NULL;

            EngUnlockSurface(pmdev->abdDevices[ulDev].pso);
            pmdev->abdDevices[ulDev].pso = NULL;
            DrvDisableSurface(pmdev->abdDevices[ulDev].dhpdev);
        }

        EngDeleteClip(pmdev->pco);
        pmdev->pco  = NULL;

        EngUnlockSurface(pmdev->pso);
        pmdev->pso = NULL;
        EngDeleteSurface(pmdev->hsurf);
        pmdev->hsurf = NULL;
    }

    DISPDBG((100, "<<< MulDisableSurface"));
    return;
}


//******************************************************************************
//
//  MulAssertMode
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulAssertMode(DHPDEV  dhpdev,BOOL    bEnable)
{
    PPDEV ppdev = (PPDEV)dhpdev;
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulAssertMode >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvAssertMode(dhpdev,bEnable);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            // we should not fail here !!!
            bRet = DrvAssertMode(pmdev->abdDevices[ulDev].dhpdev, bEnable);
            ASSERT(bRet);
            if( !bRet  && (0 == ulDev) )
                goto Exit;
        }
    }

Exit:

    DISPDBG((100, "<<< MulAssertMode"));
    return bRet;
}


//******************************************************************************
//
//  MulGetModes
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulGetModes(HANDLE hDriver, ULONG cjSize, DEVMODEW*   pdm)
{
    ULONG   ulDev;
    ULONG   ulRet = 0;
    ULONG   ulNumDev = 0;
    HANDLE  ahDriver[MAX_MULTIDEV];

    ASSERT(hDriver);

    DISPDBG((100, "MulGetModes >>>"));

    // should we run in multimon-mode ?
    if( (bGetNumberOfDevices( hDriver, &ulNumDev ))
        &&(ulNumDev > 1) // caution: don't remove this check here !
        &&(bGetDeviceObjects(hDriver,ahDriver)) // get hDriver of devices
       )
    {
        DEVMODEW *apdm[MAX_MULTIDEV];
        DEVMODEW *pdmDriver;
        DEVMODEW *pdmAppend;
        ULONG     aulSize[MAX_MULTIDEV];
        BOOL      bMatch;
        BOOL      bAllocated = FALSE;

        DISPDBG((95, "MulGetModes - found %d device objects", ulNumDev));

        RtlZeroMemory(apdm, sizeof(apdm));
        RtlZeroMemory(aulSize, sizeof(aulSize));

        // get modes from all devices
        for (ulDev = 0; ulDev < ulNumDev; ulDev++)
        {
            // check needed size for modelist
            aulSize[ulDev] = DrvGetModes(ahDriver[ulDev], 0, NULL);
            if (0 != aulSize[ulDev])
            {
                // alloc memory for modelist
                apdm[ulDev] = EngAllocMem(0, aulSize[ulDev], ALLOC_TAG);
                if (NULL != apdm[ulDev])
                {
                    // copy drivers modelist into allocated space
                    aulSize[ulDev] = DrvGetModes(ahDriver[ulDev], aulSize[ulDev], apdm[ulDev]);
                    if (0 != aulSize[ulDev])
                    {   
                        bAllocated = TRUE;
                    }
                }
            }
            if(!bAllocated)
            {
                DISPDBG((0,"MulGetModes: could not allocate modelist correctly"));
                break;
            }
        }

        // everything worked fine => try to calculate modes to export
        if( bAllocated )
        {
            // system only wants to know how much space is needed for modelist
            if (NULL == pdm)
            {
                ulRet = DrvGetModes(hDriver, cjSize, pdm);

                for (pdmDriver = apdm[0]; (BYTE *)pdmDriver < ((BYTE *)apdm[0] + aulSize[0]); pdmDriver++)
                {
                    bMatch = TRUE;
                    for (ulDev = 0; ulDev < ulNumDev; ulDev++)
                    {
                        bMatch = bMatch && bFindMatchingDevMode(pdmDriver, apdm[ulDev], aulSize[ulDev]);
                    }
                    if (bMatch)
                    {
                        ulRet += sizeof(DEVMODEW);
                    }
                }
            }
            else
            {
                // fill out given list with possible modes
                ulRet = DrvGetModes(hDriver, cjSize, pdm);

                if (ulRet <= (cjSize - sizeof(DEVMODEW)))
                {
                    for (pdmDriver = apdm[0]; (BYTE *)pdmDriver < ((BYTE *)apdm[0] + aulSize[0]); pdmDriver++)
                    {
                        bMatch = TRUE;
                        for (ulDev = 0; ulDev < ulNumDev; ulDev++)
                        {
                            bMatch = bMatch && bFindMatchingDevMode(pdmDriver, apdm[ulDev], aulSize[ulDev]);
                        }
                        if (bMatch)
                        {
                            pdmAppend = (DEVMODEW *)((BYTE *)pdm + ulRet);
                            RtlCopyMemory(pdmAppend, pdmDriver, sizeof(DEVMODEW));
                            pdmAppend->dmPelsWidth *= ulNumDev;

                            ulRet += sizeof(DEVMODEW);
                            break;
                        }
                        if ((ulRet + sizeof(DEVMODEW)) > cjSize)
                            break;
                    }
                }
            }
        }

        // clean up allocated space
        for (ulDev = 0; ulDev < ulNumDev; ulDev++)
        {
            if (apdm[ulDev])
            {
                EngFreeMem(apdm[ulDev]);
                apdm[ulDev] = NULL;
            }
        }
    }
    else
    {
        // normal single board case:
        ulRet = DrvGetModes(hDriver,cjSize,pdm);
    }

    DISPDBG((100, "<<< MulGetModes"));
    return ulRet;
}


//******************************************************************************
//
//  MulSetPalette
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulSetPalette(DHPDEV  dhpdev,PALOBJ* ppalo,FLONG   fl, ULONG   iStart, ULONG   cColors)
{
    PPDEV ppdev = (PPDEV)dhpdev;
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulSetPalette >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvSetPalette(dhpdev,ppalo, fl, iStart, cColors);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            bRet = DrvSetPalette( pmdev->abdDevices[ulDev].dhpdev, ppalo, fl, iStart, cColors);                 
        }
    }

    DISPDBG((100, "<<< MulSetPalette"));
    return bRet;
}


//******************************************************************************
//
//  MulDitherColor
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulDitherColor(DHPDEV dhpdev,ULONG  iMode,ULONG  rgb,ULONG* pul)
{
    ULONG ulRet = 0;

    DISPDBG((100, "MulDitherColor >>>"));

    // nothing to do here, because we only need to call 1 driver to do 
    // calculate us a color => don't hang in MulDitherColor 
    ulRet = DrvDitherColor(dhpdev,iMode, rgb, pul);

    DISPDBG((100, "<<< MulDitherColor"));
    return ulRet;
}


//******************************************************************************
//
//  MulSetPointerShape
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulSetPointerShape(SURFOBJ*  pso, SURFOBJ*  psoMask, SURFOBJ*  psoColor,
                         XLATEOBJ* pxlo, LONG xHot, LONG yHot, LONG x, LONG y,
                         RECTL* prcl, FLONG fl)
{
    PPDEV ppdev = (PPDEV)pso->dhpdev; 
    ULONG ulRet = FALSE;

    DISPDBG((100, "MulSetPointerShape >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        ulRet = DrvSetPointerShape(pso, psoMask, psoColor, pxlo, xHot, yHot, x, y, prcl, fl);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        LONG    lx, ly;
        RECTL   rcl;
        RECTL   *prclPointerBounds;

        ASSERT(pmdev->dwUniq == PMDEV_UNIQ);

        prclPointerBounds = prcl;
        if (prcl)
        {
            prclPointerBounds = &rcl;
        }

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            lx = x - pmdev->abdDevices[ulDev].rclBoard.left;
            ly = y - pmdev->abdDevices[ulDev].rclBoard.top;

            if ( x < (pmdev->abdDevices[ulDev].rclBoard.left - 32)
             ||  x > (pmdev->abdDevices[ulDev].rclBoard.right + 32)
             ||  y < (pmdev->abdDevices[ulDev].rclBoard.top - 32)
             ||  y > (pmdev->abdDevices[ulDev].rclBoard.bottom + 32))
            {
                lx = -1;  // turns off this cursor
            }

            if (prcl)
            {
                vRclSubOffset(&rcl, prcl, pmdev->abdDevices[ulDev].rclBoard.left, pmdev->abdDevices[ulDev].rclBoard.top);
                prclPointerBounds = &rcl;
            }

            ASSERT(pmdev->abdDevices[ulDev].pso);
            ulRet = DrvSetPointerShape(pmdev->abdDevices[ulDev].pso, psoMask, psoColor, pxlo, xHot, yHot, lx, ly, prclPointerBounds, fl);
        }
    }

    DISPDBG((100, "<<< MulSetPointerShape"));
    return ulRet;
}


//******************************************************************************
//
//  MulMovePointer
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    PPDEV ppdev = (PPDEV)pso->dhpdev; 
    ULONG ulRet = FALSE;

    DISPDBG((100, "MulMovePointer >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvMovePointer(pso, x, y, prcl);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        LONG    lx, ly;
        RECTL   rcl;
        RECTL   *prclPointerBounds;

        ASSERT(pmdev->dwUniq == PMDEV_UNIQ);

        prclPointerBounds = prcl;
        if (prcl)
        {
            prclPointerBounds = &rcl;
        }

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            lx = x - pmdev->abdDevices[ulDev].rclBoard.left;
            ly = y - pmdev->abdDevices[ulDev].rclBoard.top;

            if ( x < (pmdev->abdDevices[ulDev].rclBoard.left - 32)
             ||  x > (pmdev->abdDevices[ulDev].rclBoard.right + 32)
             ||  y < (pmdev->abdDevices[ulDev].rclBoard.top - 32)
             ||  y > (pmdev->abdDevices[ulDev].rclBoard.bottom + 32))
            {
                lx = -1;  // turns off this cursor
            }

            if (prcl)
            {
                vRclSubOffset(&rcl, prcl, pmdev->abdDevices[ulDev].rclBoard.left, pmdev->abdDevices[ulDev].rclBoard.top);
                prclPointerBounds = &rcl;
            }

            ASSERT(pmdev->abdDevices[ulDev].pso);
            DrvMovePointer( pmdev->abdDevices[ulDev].pso, lx, ly, prclPointerBounds);
        }
    }

    DISPDBG((100, "<<< MulMovePointer"));
    return ;
}


//******************************************************************************
//
//  MulCreateDeviceBitmap
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
HBITMAP MulCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    PPDEV   ppdev = (PPDEV)dhpdev;
    HBITMAP hRet  = (HBITMAP) 0;

    DISPDBG((100, "MulCreateDeviceBitmap >>>"));

    ASSERT(ppdev);

    // we do not support CreateDeviceBitMap in MultiBoard case !
    if( !ppdev->pmdev )
    {
        hRet = DrvCreateDeviceBitmap(dhpdev,sizl,iFormat);
    }

    DISPDBG((100, "<<< MulCreateDeviceBitmap"));

    return hRet;
}


//******************************************************************************
//
//  MulDeleteDeviceBitmap
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulDeleteDeviceBitmap(DHSURF dhsurf)
{
    PPDEV   ppdev;
   
    ASSERT(dhsurf);

    DISPDBG((100, "MulDeleteDeviceBitmap >>>"));

    ppdev  = ((DSURF *)dhsurf)->ppdev;

    ASSERT(ppdev);

    
    if( !ppdev->pmdev )
    {
        DrvDeleteDeviceBitmap(dhsurf);
    }
    else
    {
        // we do not support DeleteDeviceBitmap in MultiBoard case !
        // => we should never be called for DrvDeleteDeviceBitmap
        ASSERT(FALSE);
    }


    DISPDBG((100, "<<< MulDeleteDeviceBitmap"));

    return;
}


#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv1linto.c ===
//*****************************Module*Header************************************
//
// Module Name: NV1LINTO.C
//
// DrvLineTo for S3 driver
//
// Copyright (c) 1995-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "nv1_32.h"
#include "nv1c_ref.h"
#include "nvsubch.h"
#include "nvalpha.h"


//*****************************************************************************
//
//  Function:   NV1LineTo
//
//  Routine Description:
//
//          Draws a single solid integer-only cosmetic line.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************


BOOL NV1LineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)

    {
    PDEV*   ppdev;
    DSURF*  pdsurf;
    LONG    xOffset;
    LONG    yOffset;
    BOOL    bRet;

    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    PuntPtr;

    NvChannel   *nv;
    USHORT      FreeCount;
    BOOL        bMore;
    ULONG       VertexCount;
    POINTFIX    *CurrentVertexPtr;
    POINTFIX    *FirstVertexPtr;
    POINTFIX    *NextVertexPtr;
    POINTFIX    LastVertex;
    ULONG       width,height;
    ULONG       AlphaEnableValue;
    ULONG       PixelDepth;
    PATHDATA    pd;
    ULONG       temp;
    ULONG       LineVisibleFlag;
    ULONG       *DstBits;
    ULONG       *ScreenBitmap;
    ULONG       Rop3;
    ULONG SrcOffset;
    ULONG DstOffset;
    ULONG SrcStride;
    ULONG DstStride;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Init FreeCount and prepare rectangle engine
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;
    
    //**************************************************************************
    // Default to the original surface object passed in to us
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = ppdev->psoPunt;

    //**************************************************************************
    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:
    //**************************************************************************

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf !=0)
        {

        //**********************************************************************
        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:
        //**********************************************************************

        if (pdsurf->dt == DT_DIB)
            {
            //******************************************************************
            // NOTE: We use pdsurf->pso, NOT just pso, because this is
            //       a DFB that exists in system memory.
            //******************************************************************
            ppdev->pfnWaitEngineBusy(ppdev);
            return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix));

            }

        else
            {

            //******************************************************************
            //  Offset values must be zero now, for linear memory management !!!
            //******************************************************************

            ppdev->xOffset = 0;
            ppdev->yOffset = 0;

            }

        }
    else
        {
        //**************************************************************************
        // Reset the 'offscreen' offsets to zero just to be safe
        //**************************************************************************
        ppdev->xOffset = 0;
        ppdev->yOffset = 0;
        }


    //*************************************************************************
    // Only handle line drawing to VRAM.  Send lines drawn
    // to system memory back to GDI.
    //*************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

    if ((pdsurf == 0) && (DstBits != ScreenBitmap))
        goto GDI_EngLineToIt;


    //**************************************************************************
    // Only SIMPLE, STRAIGHT lines implemented, the rest go thru GDI
    //
    // If we get to this point, the line is to be drawn onscreen
    // We'll currently use NV hardware to ONLY draw straight integer lines.
    // (Because #1) The line object is not yet implemented, just the solid
    //              rectangle object, so we'll use that to draw only straight lines
    //          #2) Currently don't have time to verify the lines are drawn
    //              exactly correct.  We'll just handle the extremely simple
    //              lines, and let GDI worry about the rest.
    //**************************************************************************

    //**************************************************************************
    // Init the pointer to NV hardware
    //**************************************************************************

    nv = (NvChannel *)ppdev->pjMmBase;

    //**************************************************************************
    // Restore clip rect
    //**************************************************************************
    if (ppdev->NVClipResetFlag)
        {
        while(FreeCount < 2*4)
            FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.y_x = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.height_width = (((ppdev->cyMemory)<<16) | (ppdev->cxMemory));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }


    //**************************************************************************
    // ONLY handle non-clipped lines or single rectangle clipped lines
    //**************************************************************************

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL) )
        {

        //**********************************************************************
        // Get pixel depth for the current mode.
        // Then determine the ALPHA_CHANNEL enable value
        //**********************************************************************

        PixelDepth = ppdev->cBitsPerPel;

        AlphaEnableValue = ppdev->AlphaEnableValue;

        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
        FreeCount -=2*4;

        //******************************************************************
        // Convert mix to a Rop3 value.
        //******************************************************************
        Rop3 = (mix & 0xf) - 1;
        Rop3 |= (Rop3 << 4);

        nv->subchannel[ROP_SOLID_SUBCHANNEL].ropSolid.SetRop = Rop3 ;
        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = pbo->iSolidColor | AlphaEnableValue;


        //**********************************************************************
        // Only draw line if it's horizontal or vertical
        // Init default values for width and height
        //**********************************************************************

        width=1;
        height=1;

        if (x1==x2)

            {
            //******************************************************************
            // We're dealing with a VERTICAL line
            // Make sure to calculate a positive height and
            // swap the coordinates if necessary
            //******************************************************************

            if (y1 < y2)
                height=y2-y1;
            else if (y1 > y2)
                {
                height=y1-y2;
                y1=y2+1;
                }
            }

        else if (y1==y2)

            {
            //******************************************************************
            // We're dealing with a HORIZONTAL line
            // Make sure to calculate a positive width and
            // swap the coordinates if necessary
            //******************************************************************

            if (x1 < x2)
                width=x2-x1;
            else if (x1 > x2)
                {
                width=x1-x2;
                x1=x2+1;
                }
            }
        else

            {
            //******************************************************************
            // This group of lines contains a NON straight line.
            // Just punt it back to GDI
            //******************************************************************

            //******************************************************************
            // Update global free count
            //******************************************************************

            ppdev->NVFreeCount = FreeCount;

            goto GDI_EngLineToIt;

            }

        //**********************************************************************
        // Use hardware to draw the line
        //**********************************************************************

        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
        FreeCount -=2*4;

        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ( ((y1 + ppdev->yOffset)<<16) | ((x1 + ppdev->xOffset) & 0xffff) );
        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ( (height << 16) | width );

        //**********************************************************************
        // Update global free count
        //**********************************************************************

        ppdev->NVFreeCount = FreeCount;

        return(TRUE);
        }


    else if (pco->iDComplexity == DC_RECT)

        {
        //**********************************************************************
        // This code is fairly re-dundant, but to squeeze as much performance
        // as possible, we separate it into 2 cases (non-clipped and single-clipped)
        //**********************************************************************
        //**********************************************************************
        // Get pixel depth for the current mode.
        // Then determine the ALPHA_CHANNEL enable value
        //**********************************************************************

        PixelDepth = ppdev->cBitsPerPel;

        AlphaEnableValue = ppdev->AlphaEnableValue;

        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
        FreeCount -=2*4;

        //******************************************************************
        // Convert mix to a Rop3 value.
        //******************************************************************
        Rop3 = (mix & 0xf) - 1;
        Rop3 |= (Rop3 << 4);

        nv->subchannel[ROP_SOLID_SUBCHANNEL].ropSolid.SetRop = Rop3 ;
        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = pbo->iSolidColor | AlphaEnableValue;

        //**********************************************************************
        // Default drawing the line
        //**********************************************************************

        LineVisibleFlag = TRUE;

        //**********************************************************************
        // Only draw line if it's horizontal or vertical
        // Init default values for width and height
        //**********************************************************************

        width=1;
        height=1;

        if (x1==x2)

            {
            //******************************************************************
            // We're dealing with a VERTICAL line
            // Make sure to calculate a positive height and
            // swap the coordinates if necessary
            //******************************************************************

            if (y1 < y2)
                height=y2-y1;
            else if (y1 > y2)
                {
                height=y1-y2;
                temp=y1;
                y1=y2+1;
                y2=temp;
                }


            //******************************************************************
            // Check if is line is visible or completely clipped
            //******************************************************************

            if ((x1 < pco->rclBounds.left) || (x1 > pco->rclBounds.right))
                LineVisibleFlag = FALSE;
            else if ((y2 < pco->rclBounds.top) || (y1 > pco->rclBounds.bottom))
                LineVisibleFlag = FALSE;
            else
                {
                //**************************************************************
                // If line is visible, check if it needs to be clipped
                // If it is clipped , then update the height.
                //**************************************************************

                if (y2 > pco->rclBounds.bottom)
                    y2 = pco->rclBounds.bottom;

                if (y1 < pco->rclBounds.top)
                    y1 = pco->rclBounds.top;

                height = y2 - y1;


                }
            }

        else if (y1==y2)

            {
            //******************************************************************
            // We're dealing with a HORIZONTAL line
            // Make sure to calculate a positive width and
            // swap the coordinates if necessary
            //******************************************************************

            if (x1 < x2)
                width=x2-x1;
            else if (x1 > x2)
                {
                width=x1-x2;
                temp=x1;
                x1=x2+1;
                x2=temp;
                }


            //******************************************************************
            // Check if is line is visible or completely clipped
            //******************************************************************

            if ((y1 < pco->rclBounds.top) || (y1 > pco->rclBounds.bottom))
                LineVisibleFlag = FALSE;
            else if ((x2 < pco->rclBounds.left) || (x1 > pco->rclBounds.right))
                LineVisibleFlag = FALSE;
            else
                {
                //**************************************************************
                // If line is visible, check if it needs to be clipped
                // If it is clipped , then update the width.
                //**************************************************************

                if (x2 > pco->rclBounds.right)
                    x2 = pco->rclBounds.right;

                if (x1 < pco->rclBounds.left)
                    x1 = pco->rclBounds.left;

                width = x2 - x1;

                }
            }

        else

            {
            //******************************************************************
            // This group of lines contains a NON straight line.
            // Just punt it back to GDI
            //******************************************************************

            //******************************************************************
            // Update global free count
            //******************************************************************

            ppdev->NVFreeCount = FreeCount;

            goto GDI_EngLineToIt;

            }

        //**********************************************************************
        // Use hardware to draw the line
        //**********************************************************************

        if (LineVisibleFlag == TRUE)
            {
            while (FreeCount < 2*4)
                FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
            FreeCount -=2*4;

            nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ( ((y1+ppdev->yOffset)<<16) | ((x1 + ppdev->xOffset) & 0xffff) );
            nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ( (height << 16) | width );
            }

        //**********************************************************************
        // Update global free count
        //**********************************************************************

        ppdev->NVFreeCount = FreeCount;

        return(TRUE);
        }


    //**************************************************************************
    // Send all other lines thru GDI
    //**************************************************************************

GDI_EngLineToIt:

    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************
    if (pdsurf !=0 )
        {
             PuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
             if (pdsurf->dt == DT_SCREEN)
                 {
                 PuntPtr->sizlBitmap  = pdsurf->sizl;

                 //*************************************************************
                 // Set linear offset and stride for source and destination buffers
                 //*************************************************************

                 PuntPtr->cjBits  = pdsurf->LinearStride * pdsurf->sizl.cy;
                 PuntPtr->pvBits  = pdsurf->LinearPtr;
                 PuntPtr->pvScan0 = pdsurf->LinearPtr;
                 PuntPtr->lDelta  = pdsurf->LinearStride;

                 PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;

                 }
             else
                 {
                 //*************************************************************
                 // This is a DFB which is stored in main memory as a DIB
                 //*************************************************************
                 PuntPtr->sizlBitmap  = pdsurf->pso->sizlBitmap;
                 PuntPtr->cjBits      = pdsurf->pso->lDelta * pdsurf->pso->sizlBitmap.cy;
                 PuntPtr->pvBits  = pdsurf->pso->pvBits;
                 PuntPtr->pvScan0 = pdsurf->pso->pvScan0;
                 PuntPtr->lDelta  = pdsurf->pso->lDelta;
                 PuntPtr->iBitmapFormat = pdsurf->pso->iBitmapFormat;
                 }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempDstSurfObjPtr       = PuntPtr;
        }


    ppdev->pfnWaitEngineBusy(ppdev);
    return(EngLineTo(TempDstSurfObjPtr, pco, pbo, x1, y1, x2, y2, prclBounds, mix));

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv1ptr.c ===
//******************************Module*Header***********************************
//
// Module Name: pointer.c
//
// This module contains the hardware pointer support for the display
// driver.  This supports both the built-in S3 hardware pointer and
// some common DAC hardware pointers.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#include "sgs_dac.h"


#define OFFSET_SGS_DAC_UPORT_WRITE_PAL_ADDR    0
#define OFFSET_SGS_DAC_UPORT_COLOR             1
#define OFFSET_SGS_DAC_UPORT_PIXEL_MASK        2
#define OFFSET_SGS_DAC_UPORT_READ_PAL_ADDR     3
#define OFFSET_SGS_DAC_UPORT_INDEX_LO          4
#define OFFSET_SGS_DAC_UPORT_INDEX_HI          5
#define OFFSET_SGS_DAC_UPORT_INDEX_DATA        6
#define OFFSET_SGS_DAC_UPORT_GAMEPORT          7


//******************************************************************************
//
//  Function:   NV1EnablePointer
//
//  Routine Description:
//
//      Get the hardware ready to use the Brooktree 485 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1EnablePointer(
PDEV*               ppdev,
BOOL    bEnable
)
    {
    // Nothing to do, already initialized in miniport
    }


//******************************************************************************
//
//  Function:   NV1MovePointer
//
//  Routine Description:
//
//      Move the NV1 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1MovePointer(
PDEV*   ppdev,
LONG    x,
LONG    y)

    {
    LONG    dx;
    LONG    dy;

    volatile ULONG *DACRegs;
    volatile ULONG *SGS_DAC_Index_Lo;
    volatile ULONG *SGS_DAC_Index_Hi;
    volatile ULONG *SGS_DAC_Index_Data;
    ULONG OutData;

    //**************************************************************************
    // Adjustment for cursor Hot spot
    //**************************************************************************

    x -= ppdev->xPointerHot;
    y -= ppdev->yPointerHot;

    //**************************************************************************
    // Get pointer to important SGS Dac cursor registers
    //**************************************************************************

    DACRegs = ppdev->DACRegs;

    SGS_DAC_Index_Lo = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_LO);
    SGS_DAC_Index_Hi = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_HI);
    SGS_DAC_Index_Data = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_DATA);

    //**************************************************************************
    // Set cursor position X coordinate
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_POS_X_LO & 0xff);
    *SGS_DAC_Index_Lo = OutData;

    OutData=((SGS_DAC_CURSOR_POS_X_LO>>8) & 0xff);
    *SGS_DAC_Index_Hi = OutData;

    OutData=x;
    *SGS_DAC_Index_Data= OutData;
    *SGS_DAC_Index_Data= OutData>>8;

    //**************************************************************************
    // Set cursor position Y coordinate
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_POS_Y_LO & 0xff);
    *SGS_DAC_Index_Lo = OutData;

    OutData=((SGS_DAC_CURSOR_POS_Y_LO>>8) & 0xff);
    *SGS_DAC_Index_Hi = OutData;

    OutData=y;
    *SGS_DAC_Index_Data= OutData;
    *SGS_DAC_Index_Data= OutData>>8;

    return;

    }

//******************************************************************************
//
//  Function:   NV1ShowPointer
//
//  Routine Description:
//
//      Show or hide the NV1 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1ShowPointer(
PDEV*   ppdev,
BOOL    bShow)      // If TRUE, show the pointer.  If FALSE, hide the pointer.

    {
    LONG    x;
    LONG    y;


    if (bShow)
        {
        //**********************************************************************
        // Make the hardware pointer visible:
        //**********************************************************************

        x  = ppdev->xPointer;
        y  = ppdev->yPointer;
        }

    else

        {
        //**********************************************************************
        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:
        //**********************************************************************

        x  = ppdev->cxScreen + 64;
        y  = ppdev->cyScreen + 64;
        }

    //*************************************************************************
    // Enable/Disable cursor by moving to new position
    //*************************************************************************

    NV1MovePointer(ppdev,x,y);
    }


//******************************************************************************
//
//  Function:   NV1SetPointerShape
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1SetPointerShape(
SURFOBJ*    pso,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
BYTE*       pjShape)

    {
    PDEV*   ppdev;
    ULONG*  pulSrc;
    ULONG*  pulDst;
    LONG    i;

    volatile ULONG *DACRegs;
    volatile ULONG *SGS_DAC_Index_Lo;
    volatile ULONG *SGS_DAC_Index_Hi;
    volatile ULONG *SGS_DAC_Index_Data;
    ULONG OutData;
    BYTE*   pbImage;

    ppdev    = (PDEV*) pso->dhpdev;

    DACRegs = ppdev->DACRegs;

    SGS_DAC_Index_Lo = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_LO);
    SGS_DAC_Index_Hi = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_HI);
    SGS_DAC_Index_Data = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_DATA);

    //**************************************************************************
    // Set SGS cursor image plane 1 (AND MASK plane)
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_PLANE_1_WRITE_0 & 0xff);
    *SGS_DAC_Index_Lo = OutData;

    OutData=((SGS_DAC_CURSOR_PLANE_1_WRITE_0>>8) & 0xff);
    *SGS_DAC_Index_Hi = OutData;

    pbImage = pjShape;
    for (i=0;i<128;i++)
        *SGS_DAC_Index_Data= *pbImage++;

    //**************************************************************************
    // Set SGS cursor image plane 0 (XOR MASK plane)
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_PLANE_0_WRITE_0 & 0xff);
    *SGS_DAC_Index_Lo = OutData;

    OutData=((SGS_DAC_CURSOR_PLANE_0_WRITE_0>>8) & 0xff);
    *SGS_DAC_Index_Hi = OutData;

    for (i=0;i<128;i++)
        *SGS_DAC_Index_Data= *pbImage++;

    //**************************************************************************
    // 1. Hide the current pointer.
    //**************************************************************************

    //**************************************************************************
    // 2. Wait until the vertical retrace is done.
    // --
    //
    // If we don't wait for vertical retrace here, the S3 sometimes ignores
    // the setting of the new pointer position:
    //**************************************************************************

    //**************************************************************************
    // 3. Set the new pointer position.
    // --
    //**************************************************************************

    //**************************************************************************
    // 4. Download the new pointer shape.
    //**************************************************************************

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    NV1MovePointer(ppdev, x, y);


    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3bltc.c ===
//******************************Module*Header***********************************
//
// Module Name: NV3BLTC.C
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#ifdef NV3
#include "oldnv332.h"

#include "nvsubch.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"

#ifdef _WIN32_WINNT     // If is >= NT 4.x

//******************************************************************************
// Externs
//******************************************************************************

ULONG nvBrushToSrcRopTable[64] = {
0x00000000, 0x00000011, 0x00000022, 0x00000033,
0x00000000, 0x00000011, 0x00000022, 0x00000033,
0x00000000, 0x00000011, 0x00000022, 0x00000033,
0x00000000, 0x00000011, 0x00000022, 0x00000033,
0x00000044, 0x00000055, 0x00000066, 0x00000077,
0x00000044, 0x00000055, 0x00000066, 0x00000077,
0x00000044, 0x00000055, 0x00000066, 0x00000077,
0x00000044, 0x00000055, 0x00000066, 0x00000077,
0x00000088, 0x00000099, 0x000000AA, 0x000000BB,
0x00000088, 0x00000099, 0x000000AA, 0x000000BB,
0x00000088, 0x00000099, 0x000000AA, 0x000000BB,
0x00000088, 0x00000099, 0x000000AA, 0x000000BB,
0x000000CC, 0x000000DD, 0x000000EE, 0x000000FF,
0x000000CC, 0x000000DD, 0x000000EE, 0x000000FF,
0x000000CC, 0x000000DD, 0x000000EE, 0x000000FF,
0x000000CC, 0x000000DD, 0x000000EE, 0x000000FF
};

#ifdef _X86_

//******************************************************************************
// X86 Assembly routine to xfer host bitmap->screen
//******************************************************************************

void NV1_Transfer_MemToScreen_Data(ULONG, USHORT *, ULONG, ULONG *,LONG, Nv3ChannelPio *);

#endif

//******************************************************************************
// Macros used by FillPatFast (optimization)
//******************************************************************************


#define BUILD_PIXEL_GROUP(GROUP_WIDTH,BLIT_SIZE,NUM_BLITS) \
{\
if (RemainingPixels>=(GROUP_WIDTH))\
    {\
    for (i=0; i<(NUM_BLITS) ;i++)\
        {\
        while (FreeCount < 3*4)\
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;\
        FreeCount -= 3*4;\
\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (CurrentYdst << 16) | (xdst & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (1 << 16) | (BLIT_SIZE) );\
\
        RemainingPixels -= (BLIT_SIZE);\
        CurrentXdst     += (BLIT_SIZE);\
        }\
    }\
}


#define COPY_PIXEL_GROUP(GROUP_WIDTH,NUM_BLITS) \
{\
if (RemainingPixels>= (GROUP_WIDTH) )\
    {\
    NumberOfBlits = (NUM_BLITS);\
\
    for (i=0; i< (NumberOfBlits) ;i++)\
        {\
        while (FreeCount < 3*4)\
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;\
        FreeCount -= 3*4;\
\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (CurrentYdst << 16) | (xdst & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (1 << 16) | (GROUP_WIDTH) );\
\
        RemainingPixels -= (GROUP_WIDTH);\
        CurrentXdst     += (GROUP_WIDTH);\
        }\
    }\
}


#define BUILD_PIXEL_BLOCK(GROUP_HEIGHT,GROUP_WIDTH,BLIT_HEIGHT,NUM_BLITS) \
{\
if (RemainingScanlines>=(GROUP_HEIGHT))\
    {\
    for (i=0; i<(NUM_BLITS) ;i++)\
        {\
        while (FreeCount < 3*4)\
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;\
        FreeCount -= 3*4;\
\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (ydst << 16) | ((CurrentXdst) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( ((BLIT_HEIGHT) << 16) | (GROUP_WIDTH) );\
\
        RemainingScanlines -= (BLIT_HEIGHT);\
        CurrentYdst        += (BLIT_HEIGHT);\
        }\
    }\
}


#define COPY_PIXEL_BLOCK(GROUP_HEIGHT,GROUP_WIDTH,NUM_BLITS) \
{\
if (RemainingScanlines>= (GROUP_HEIGHT) )\
    {\
    NumberOfBlits = (NUM_BLITS);\
\
    for (i=0; i< (NumberOfBlits) ;i++)\
        {\
        while (FreeCount < 3*4)\
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;\
        FreeCount -= 3*4;\
\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (ydst << 16) | ((CurrentXdst) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( ((GROUP_HEIGHT) << 16) | (GROUP_WIDTH) );\
\
        RemainingScanlines -= (GROUP_HEIGHT);\
        CurrentYdst        += (GROUP_HEIGHT);\
        }\
    }\
}


//******************************************************************************
//
//  Function:   NV3FillSolid
//
//  Routine Description:
//
//      Fills a list of rectangles with a solid colour.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3FillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used

    {
    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;

    ULONG   ulHwForeMix;
    ULONG  width,height;
    USHORT FreeCount;
    ULONG Rop3;
    ULONG temp;
    ULONG AlphaEnableValue;
    ULONG PixelDepth;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

// ???
///    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    //**************************************************************************
    // Equation to convert to Rop4 to Rop3 (We don't get patterns here)
    //
    // Rop4:
    //                 Truth table for a Rop 3.
    //                 ------------------------
    //                                    R
    //                                    O
    //                        (SD)        P
    //                  11  10  01  00    3
    //                  --------------
    //          (P) 1  |         x   x    High nibble    Example Value = 0xf0
    //              0  | x   x            Low nibble
    //
    //
    // After rop4 >> 2:
    //
    //                 Truth table for a Rop 3.
    //                 ------------------------
    //                                    R
    //                                    O
    //                        (SD)        P
    //                  11  10  01  00    3
    //                  --------------
    //          (P) 1  |                  High nibble    Value = 0x3c
    //              0  | x   x   x   x    Low nibble
    //
    //
    // After (rop4 >> 2 ) & 0xf:
    //
    //                                                   Value = 0x0c
    //
    // Final Rop3 equivalent value of a Rop2 value = 0xcc
    //
    //         This value does not depend on the Pattern
    //**************************************************************************

    temp = ((rop4 >> 2) & 0xf);         // Get bottom nibble
    Rop3 = temp | (temp << 4);        // Duplicate in top nibble

    //**************************************************************************
    // Init cached free count
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    while (FreeCount < 1*4)
        FreeCount = nv->subchannel[ROP_SOLID_SUBCHANNEL].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = Rop3 ;

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        while (FreeCount < 2*4)
           FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (( (ppdev->cyMemory)<<16) | (0x7fff));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    while(TRUE)
        {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of pixels drawn.
        // So, adjusting by 1 pixel is NOT necessary when calculating width and height.
        //**********************************************************************

        width = prcl->right - prcl->left;
        height = prcl->bottom - prcl->top;

        //**********************************************************************
        // Wait for FIFO to be ready, then draw
        // We know that this is a straight SOLID FILL with no pattern
        //***********************************************************************

        while (FreeCount < 3*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free ;
        FreeCount -=3*4;

        nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Color = (AlphaEnableValue | rbc.iSolidColor);
        nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].point = (( (prcl->top) << 16) | ( (prcl->left) & 0xffff));
        nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].size = ( (height << 16) | width );

        if (--c == 0)
            {
            //******************************************************************
            // Update global free count
            //******************************************************************
            ppdev->NVFreeCount = FreeCount;

            return;
            }

        prcl++;
        }

    }


//******************************************************************************
//
//  Function:   NV3FillPatFast
//
//  Routine Description:
//
//      This routine uses the NV Image_Mono_From_CPU and Image_From_CPU
//      object clases to draw a patterned list of rectangles.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3FillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment

    {
    BOOL        bTransparent;
    ULONG       ulHwForeMix;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG Color0;
    ULONG Color1;
    ULONG AlphaEnableValue;
    ULONG PixelDepth;
    ULONG width;
    ULONG height;
    USHORT FreeCount;
    ULONG rop3;
    LONG  xShift;
    LONG  yShift;
    ULONG BytesPerDstScan;
    ULONG DwordsPerDstScan;
    ULONG SizeInWidth;
    LONG BytesPerSrcScan;
    BYTE*  SrcBits;
    BYTE*  DstBits;
    ULONG *ScanPtr;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    RBRUSH* prb;
    ULONG PatternYCount;
    ULONG *NextScan;
    ULONG *EndOfScanPtr;
    LONG ScanInc;
    ULONG DwordCount;
    ULONG yscan;
    ULONG xdst,ydst;
    LONG  cjLeft;
    LONG  cjRight;
    ULONG   i;

    ULONG CurrentXdst;
    ULONG CurrentYdst;
    ULONG RemainingPixels;
    ULONG SrcOffset;
    ULONG SrcStride;
    ULONG NumberOfBlits;
    ULONG RemainingScanlines;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //**************************************************************************
    // TODO: Do I need to do anything special for transparent cases?
    //**************************************************************************
    rop3 = (ULONG)((BYTE) (rop4 & 0xff));
    bTransparent = (((rop4 >> 8) & 0xff) != rop3);

    //**************************************************************************
    // Get pointer to brush entry
    //**************************************************************************

    prb = rbc.prb;
    pbe = rbc.prb->apbe[IBOARD(ppdev)];

    //**************************************************************************
    // Need to add if statement if brush pattern hasn't changed
    // For now, just always re-calculate brush pattern
    // Performance boost of how much?
    //**************************************************************************

    //**************************************************************************
    // Init FreeCount variable
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    PixelDepth = ppdev->cBitsPerPel;

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // Restore clip rect
    //**************************************************************************
    if (ppdev->NVClipResetFlag)
        {
        while(FreeCount < 2*4)
            FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }


    //**************************************************************************
    // I considered doing the colour expansion for 1bpp brushes in
    // software, but by letting the hardware do it, we don't have
    // to do as many OUTs to transfer the pattern.
    //**************************************************************************

    if (prb->fl & RBRUSH_2COLOR)
        {

        //**********************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // The brush is aligned in absolute coordinates, so we have to add
        // in the surface offset:
        //
        // NV: We DON'T need to manually account for the position of the pattern
        //     on the screen, like we do for the Memory to Screen blits for
        //     multi-color patterns (below).
        //**********************************************************************

        //**********************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //**********************************************************************

        xShift = pptlBrush->x & 7;
        yShift = pptlBrush->y & 7;

        //**********************************************************************
        // Shift Mono pattern bits appropriately (vertically)
        // First we'll align it properly by copying it to a temporary buffer:
        //**********************************************************************

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift;                              // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //**********************************************************************
        // Now copy the pattern , row by row (byte by byte) and
        // align it vertically and horizontally at the same time
        //**********************************************************************

        do  {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;

            } while (--i != 0);

        //**********************************************************************
        // Now copy the 'top' part
        //**********************************************************************

        DstBits -=8;                    // Move back to beginning of destination

        for (; yShift != 0; yShift--)
            {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;
            }

        //**********************************************************************
        // Init foreground and background color
        //**********************************************************************

        Color1 = rbc.prb->ulForeColor | (AlphaEnableValue); // Background color
        Color0 = rbc.prb->ulBackColor | (AlphaEnableValue); // Foreground color

        while (FreeCount < 6*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free;
        FreeCount -= 6*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = rop3 ;

        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeShape = NV018_SET_MONOCHROME_SHAPE_8X_8Y;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor0 = Color0;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor1 = Color1;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern0 = ppdev->AlignedBrush[0];
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern1 = ppdev->AlignedBrush[1];


        do {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = prcl->right - prcl->left;
            height= prcl->bottom - prcl->top;

            //******************************************************************
            // Wait for FIFO to be ready, then draw
            //******************************************************************

            while (FreeCount < 3*4)
                FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free;
            FreeCount -= 3*4;

            nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Color = rbc.prb->ulForeColor | AlphaEnableValue;
            nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].point = ((prcl->top << 16) | ((prcl->left) & 0xffff));
            nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].size = ( (height << 16) | width );


            prcl++;

            } while (--c != 0);

        //**********************************************************************
        // Notify the rest of the driver that we changed the pattern
        //**********************************************************************

        ppdev->NVPatternResetFlag=1;

        }


    else

        {

        //**********************************************************************
        // Loop thru all the clipping rectangles
        //**********************************************************************

        do  {

            //******************************************************************
            // Handle multi-color patterns.  For now, we just use the
            // ImageFromCpu class (memory to screen blit).
            //******************************************************************

            //******************************************************************
            // Because we handle only 8x8 brushes, it is easy to compute the
            // number of pels by which we have to rotate the brush pattern
            // right and down.  Note that if we were to handle arbitrary sized
            // patterns, this calculation would require a modulus operation.
            //
            // The brush is aligned in absolute coordinates, so we have to add
            // in the surface offset:
            //
            // NV: Since we are using Memory to Screen blits, we need to manually
            //     account for the position of the pattern on screen. So, not only
            //     do we need to factor in pptrlBrush.x/y, but also prcl->left/top;
            //     We don't care what the alignment is offscreen, because offscreen
            //     position is NOT the final destination/position.
            //******************************************************************

            xShift = pptlBrush->x - prcl->left;
            yShift = pptlBrush->y - prcl->top;

            //******************************************************************
            // Rotate pattern 'xShift' pels right
            // Rotate pattern 'yShift' pels down
            //******************************************************************

            xShift &= 7;
            yShift &= 7;

            //******************************************************************
            // We're going to do a straight of the Xbpp 8x8 pattern to the screen.
            // First we'll align it properly by copying it to a temporary buffer:
            //******************************************************************

            cjLeft  = CONVERT_TO_BYTES(xShift, ppdev);      // Number of bytes pattern
                                                            //   is shifted to the right
            cjRight = CONVERT_TO_BYTES(8, ppdev) - cjLeft;  // Number of bytes pattern
                                                            // is shifted to the left

            SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
            DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

            DstBits += yShift * CONVERT_TO_BYTES(8, ppdev); // Starting yShift rows
            i = 8 - yShift;                                 //  down for 8 - yShift rows

            //******************************************************************
            // Now copy the pattern and align it, in 2 steps.
            // The 'left' part, and 'right' part (as well as the 'bottom' and 'top')
            // We'll start copying the 'bottom' part first.
            //******************************************************************

            do  {
                RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
                RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

                DstBits += cjLeft + cjRight;
                SrcBits += cjLeft + cjRight;

                } while (--i != 0);

            //******************************************************************
            // Now copy the 'top' part
            //******************************************************************

            DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

            for (; yShift != 0; yShift--)
                {
                RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
                RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

                DstBits += cjLeft + cjRight;
                SrcBits += cjLeft + cjRight;
                }

            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = prcl->right - prcl->left;
            height= prcl->bottom - prcl->top;

            //******************************************************************
            // Top left coordinate of destination on destination surface
            //******************************************************************

            xdst = prcl->left;
            ydst = prcl->top;

            //******************************************************************
            // Prepare to do an IMAGE_FROM_CPU blit
            //******************************************************************

            while (FreeCount < 4*4)
               FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=4*4;

            //******************************************************************
            // rop3 is a pat rop. Since we don't have color patterns in hw, we
            // treat pattern as source and thus convert to the corresponding source
            // rop. e.g. - convert PATCOPY->SRCCOPY, PATINVERT->SRCINVERT.
            //******************************************************************
            nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 =
                nvBrushToSrcRopTable[rop3 >> 2];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ((ydst) <<16) | ((xdst) & 0xffff) );
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (height <<16) | width );

            //******************************************************************
            // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
            // ignore/clip the extra pixel that we send it, so that it won't
            // get included as part of the next scanline. Since we always
            // send DWords at a time, we may actually send more data to the NV
            // engine than is necessary.  So clip it by specifying a larger SizeIn
            // That is, we always send DWORDS at a time for each scanline.
            // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
            //******************************************************************

            if (PixelDepth == 8)
                SizeInWidth = ((width + 3) & 0xfffc);
            else if (PixelDepth == 16)
                SizeInWidth = ((width + 1) & 0xfffe);
            else
                SizeInWidth = width;

            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (height <<16) | (SizeInWidth) );

            //******************************************************************
            // Calculate number of dwords to output for scanline
            // This is the actual amount of data that the NV engine expects per scanline.
            // SizeInWidth is guaranteed to be a multiple of 2 (for 16bpp) and
            // a multiple of 4 (for 32bpp).  So we'll always be outputting DWORDS.
            // (No leftover words or bytes, they get clipped)
            //******************************************************************

            BytesPerDstScan = SizeInWidth * PixelDepth/8;
            DwordsPerDstScan = BytesPerDstScan / 4 ;

            //******************************************************************
            // Ptr to pattern data
            //******************************************************************

            SrcBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

            //******************************************************************
            // Get ptr to start of SRC
            //******************************************************************

            NextScan = (ULONG *)(SrcBits);

            //******************************************************************
            // We only ever support 8x8 patterns
            //******************************************************************

            BytesPerSrcScan = 8 * ppdev->cjPelSize;

            //******************************************************************
            // Amount to increment for each scanline (in dwords)
            //******************************************************************

            ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment


            //******************************************************************
            // Output one scan at a time
            //******************************************************************

            PatternYCount = 0;

            //******************************************************************
            // 8bpp
            //******************************************************************

            if (ppdev->cjPelSize == 1)  // 8bpp

                {
                for (yscan=0;yscan < height; yscan++)
                    {
                    DwordCount  = DwordsPerDstScan;
                    ScanPtr     = NextScan;
                    EndOfScanPtr= NextScan + (2 * ppdev->cjPelSize);

                    //**********************************************************
                    // 4 Dwords at a time
                    //**********************************************************

                    while (DwordCount >= 4 )
                        {
                        while (FreeCount < 4*4)
                            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                        FreeCount -= 4*4;

                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[0];
                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[1];

                        DwordCount-=4;
                        }

                    //**********************************************************
                    // 1 Dword at a time
                    //**********************************************************

                    while (DwordCount > 0 )
                        {
                        while (FreeCount < 1*4)
                            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                        FreeCount -= 1*4;

                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];

                        ScanPtr ++;                  // Advance 1 dwords

                        DwordCount--;

                        //******************************************************
                        // See if we've gone past 8 pixels worth (in dwords)
                        // We only handle 8x8 patterns
                        //******************************************************

                        if (ScanPtr >= EndOfScanPtr)
                            ScanPtr = NextScan;     // Reset back to beginning
                        }


                    //**********************************************************
                    // Advance to next pattern scanline
                    //**********************************************************

                    NextScan+=ScanInc;

                    //**********************************************************
                    // Check if we need to wraparound back to beginning of pattern
                    // If so, reset pattern pointer back to the beginning
                    //**********************************************************

                    PatternYCount++;
                    if (PatternYCount>=8)
                        {
                        NextScan = (ULONG *)SrcBits;
                        PatternYCount=0;
                        }

                    }

                }

            else

                {

                //**************************************************************
                // 16bpp or 32bpp -> Use Fast optimized blit version
                //**************************************************************

                //**************************************************************
                // Use Screen to Screen blits to speed up pattern copy
                // 2 main cases:
                //    Wide blits (greater than/equal 32 pixels wide)
                //    Narrow blits (less than 32 pixels wide),
                //**************************************************************

                if ( (rop3==0xf0) || (rop3==0xcc) )

                    {
                    //**********************************************************
                    // We'll be using image blit, so we need to
                    // set linear stride and offset for the source!
                    // Make sure to set it the same as the destination
                    // (Offscreen bitmap or Onscreen)
                    //**********************************************************

                    SrcOffset = ppdev->CurrentDestOffset;
                    SrcStride = ppdev->CurrentDestPitch;
                    (ppdev->pfnSetSourceBase)(ppdev,SrcOffset,SrcStride);


                    //**********************************************************
                    // Copy the pattern on screen, then use imageblit
                    // to copy the rest of it (faster than imagefromcpu)
                    //**********************************************************

                    yscan=0;
                    RemainingScanlines=height;

                    //**********************************************************
                    // rop3 is a pat rop. Since we don't have color patterns in hw, we
                    // treat pattern as source and thus convert to the corresponding source
                    // rop. e.g. - convert PATCOPY->SRCCOPY, PATINVERT->SRCINVERT.
                    //**********************************************************

                    while (FreeCount < 1*4)
                       FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                    FreeCount -=1*4;

                    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 =
                        nvBrushToSrcRopTable[rop3 >> 2];

                    //**********************************************************
                    // Do the first 8 scanlines of this pattern blit
                    //**********************************************************

                    while ( (yscan < 8) && (yscan < height))
                        {

                        //******************************************************
                        // Get remaining number of pixels to do on this scanline
                        // Also get start of current pattern scanline
                        //******************************************************

                        RemainingPixels = width;
                        ScanPtr         = NextScan;

                        //******************************************************
                        // Get blit destination coordinate
                        //******************************************************

                        CurrentXdst = xdst;
                        CurrentYdst = ydst+yscan;

                        //******************************************************
                        // Speed up WIDE blits
                        //******************************************************

                        if ( width >=32 )
                            {
                            //**************************************************
                            // Prepare to do an IMAGE_FROM_CPU blit
                            // We'll be using it to copy the first 8 pixels
                            //**************************************************

                            while (FreeCount < 3*4)
                               FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                            FreeCount -=3*4;

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point   = ( ((CurrentYdst) <<16) | ((xdst) & 0xffff) );
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (1 <<16) | 8 );
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn  = ( (1 <<16) | 8 );

                            //**************************************************
                            // Copy first 8 pixels using ImageFromCpu (we only handle 8x8 brushes)
                            //**************************************************


                            if (ppdev->cjPelSize == 2)  // 16bpp
                                {
                                while (FreeCount < 4*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= 4*4;

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[2];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[3];

                                CurrentXdst         += 8;
                                RemainingPixels     -= 8;
                                }
                            else
                                {                       // 32bpp
                                while (FreeCount < 8*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= 8*4;

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[2];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[3];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] = ScanPtr[4];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] = ScanPtr[5];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] = ScanPtr[6];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] = ScanPtr[7];

                                CurrentXdst         += 8;
                                RemainingPixels     -= 8;
                                }


                            //**************************************************
                            // Set Rop to srccopy
                            //**************************************************

                            while (FreeCount < 1*4)
                                FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
                            FreeCount -= 1*4;

                            nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = 0xcccc ;

                            //**************************************************
                            // We've already blitted the first 8 pixels
                            // We only need to blit 24 more pixels to create
                            // the 32 pixel group.  ( 8 pixels * 3 times = 24)
                            //**************************************************

                            BUILD_PIXEL_GROUP(24,8,3);

                            //**************************************************
                            // 32pixel group is now available
                            // See if we can create the 128 pixel group
                            //**************************************************

                            BUILD_PIXEL_GROUP(128,32,4);

                            //**************************************************
                            // More than 128 pixels remaining? (7 -> Divide by 128)
                            // If so, we can blit it all at once
                            //**************************************************

                            COPY_PIXEL_GROUP(128, RemainingPixels>>7);

                            //**************************************************
                            // More than 32 pixels remaining? (5 -> Divide by 32)
                            // If so, we can blit it all at once
                            //**************************************************

                            COPY_PIXEL_GROUP(32, RemainingPixels>>5);

                            //**************************************************
                            // More than 8 pixels remaining? (3 -> Divide by 8)
                            // If so, we can blit it all at once
                            //**************************************************

                            COPY_PIXEL_GROUP(8, RemainingPixels>>3);

                            //**************************************************
                            // Check for remaining pixels
                            //**************************************************

                            if (RemainingPixels)
                                {
                                //**********************************************
                                // Copy  remaining pixels
                                //**********************************************

                                while (FreeCount < 3*4)
                                    FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
                                FreeCount -= 3*4;

                                nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (CurrentYdst << 16) | (xdst & 0xffff) );
                                nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );
                                nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (1 << 16) | (RemainingPixels) );
                                }
                            }


                        else

                            {

                            //**************************************************
                            // Speed up TALL blits (less than 32 pixels wide)
                            //**************************************************

                            while (FreeCount < 3*4)
                               FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                            FreeCount -=3*4;


                            //**************************************************
                            // Make sure to adjust the SizeInWidth appropriately
                            //**************************************************

                            if (PixelDepth == 16)
                                SizeInWidth = ((width + 1) & 0xfffe);
                            else  // Pixel Depth == 32
                                SizeInWidth = width;

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point   = ( ((CurrentYdst) <<16) | ((xdst) & 0xffff) );
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (1 <<16) | (width) );
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn  = ( (1 <<16) | (SizeInWidth) );

                            //**************************************************
                            // Copy pixels using ImageFromCpu
                            // CAREFUL: !! FreeCount can NOT go past 128-4 bytes !!
                            //             (Maximum width here is 31)
                            //**************************************************


                            if (ppdev->cjPelSize == 2)  // 16bpp
                                {
                                while (FreeCount < (USHORT)(SizeInWidth>>1)*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= (USHORT)(SizeInWidth>>1)*4;

                                for (i=0;i<(SizeInWidth>>1);i++)
                                    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[i] = ScanPtr[(i & 0x3)];
                                }
                            else
                                {                       // 32bpp
                                while (FreeCount < (USHORT)width*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= (USHORT)width*4;

                                for (i=0;i<width;i++)
                                    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[i] = ScanPtr[(i & 0x7)];
                                }

                            }


                        //******************************************************
                        // Advance to next pattern scanline
                        //******************************************************

                        NextScan+=ScanInc;

                        //******************************************************
                        // Check if we need to wraparound back to beginning of pattern
                        // If so, reset pattern pointer back to the beginning
                        //******************************************************

                        PatternYCount++;
                        if (PatternYCount>=8)
                            {
                            NextScan = (ULONG *)SrcBits;
                            PatternYCount=0;
                            }

                        //******************************************************
                        // Advance to next scanline
                        //******************************************************

                        yscan++;
                        RemainingScanlines--;
                        }


                    //**********************************************************
                    // Only need to reset the ROP if this is the tall case
                    //**********************************************************

                    if ( width < 32 )
                        {
                        //******************************************************
                        // Set Rop to srccopy
                        //******************************************************

                        while (FreeCount < 1*4)
                            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
                        FreeCount -= 1*4;

                        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = 0xcccc ;
                        }

                    //**********************************************************
                    // If there are more then 8 scanlines, use imageblit to
                    // blit the rest
                    //**********************************************************

                    if (RemainingScanlines)

                        {
                        //******************************************************
                        // Update CurrentX and CurrentY
                        //******************************************************

                        CurrentXdst = xdst;
                        CurrentYdst = ydst+yscan;

                        //******************************************************
                        // We've already blitted the first 8 scanlines.
                        // We only need to blit 24 more scanlines to create
                        // the 32 pixel block.  ( 8 pixels * 3 times = 24)
                        //******************************************************

                        BUILD_PIXEL_BLOCK(24,width,8,3);

                        //******************************************************
                        // 32pixel group is now available
                        // See if we can create the 128 pixel block
                        //******************************************************

                        BUILD_PIXEL_BLOCK(128,width,32,4);

                        //******************************************************
                        // More than 128 scanlines remaining? (7 -> Divide by 128)
                        // If so, we can blit it all at once
                        //******************************************************

                        COPY_PIXEL_BLOCK(128, width, RemainingScanlines>>7);

                        //******************************************************
                        // More than 32 scanlines remaining? (5 -> Divide by 32)
                        // If so, we can blit it all at once
                        //******************************************************

                        COPY_PIXEL_BLOCK(32, width, RemainingScanlines>>5);

                        //******************************************************
                        // More than 8 scanlines remaining? (3 -> Divide by 8)
                        // If so, we can blit it all at once
                        //******************************************************

                        COPY_PIXEL_BLOCK(8, width, RemainingScanlines>>3);

                        //******************************************************
                        // Check for remaining scanlines
                        //******************************************************

                        if (RemainingScanlines)
                            {
                            //**************************************************
                            // Copy remaining Scanlines
                            //**************************************************

                            while (FreeCount < 3*4)
                                FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
                            FreeCount -= 3*4;

                            nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (ydst << 16) | ((CurrentXdst) & 0xffff) );
                            nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );
                            nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( ((RemainingScanlines) << 16) | (width) );
                            }


                        }


                    }


                else


                    {

                    //**********************************************************
                    // 16bpp or 32bpp -> Use slower ImageFromCpu version
                    //**********************************************************

                    for (yscan=0;yscan < height; yscan++)
                        {

                        //******************************************************
                        // Init values per each pattern scanline
                        // 8bpp  -> 8 pixels * 1 dword/4 pixels = 2 dwords per pattern scanline
                        // 16bpp -> 8 pixels * 1 dword/2 pixels = 4 dwords per pattern scanline
                        // 32bpp -> 8 pixels * 1 dword/1 pixel  = 8 dwords per pattern scanline
                        //    or just multiply 2 * Bytes Per Pixel for the same result
                        //******************************************************

                        DwordCount  = DwordsPerDstScan;
                        ScanPtr     = NextScan;
                        EndOfScanPtr= NextScan + (2 * ppdev->cjPelSize);

                        //******************************************************
                        // 8x8 color pattern
                        // We can only send 4 dwords at a time for 16bpp
                        // But we can blast out 8 dwords at a time for 32bpp
                        // (16bpp-> 2 pixels per dword, 32bpp -> 1 pixel per dword)
                        //******************************************************

                        if (ppdev->cjPelSize == 4)
                            {
                            //**************************************************
                            // 8 Dwords at a time (Valid for 32bpp mode ONLY!!)
                            //**************************************************

                            while (DwordCount >= 8 )
                                {
                                while (FreeCount < 8*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= 8*4;

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[2];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[3];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] = ScanPtr[4];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] = ScanPtr[5];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] = ScanPtr[6];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] = ScanPtr[7];

                                DwordCount-=8;
                                }
                            }


                        //******************************************************
                        // 4 Dwords at a time
                        //******************************************************

                        while (DwordCount >= 4 )
                            {
                            while (FreeCount < 4*4)
                                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                            FreeCount -= 4*4;

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[2];
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[3];

                            DwordCount-=4;
                            }

                        //******************************************************
                        // Output any remaining dwords...
                        // Need to unroll and make more efficient !!!
                        //******************************************************

                        while (DwordCount > 0 )
                            {

                            while (FreeCount < 1*4)
                                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                            FreeCount -= 1*4;

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];

                            ScanPtr ++;                  // Advance 1 dwords

                            DwordCount--;

                            //**************************************************
                            // See if we've gone past 8 pixels worth (in dwords)
                            // We only handle 8x8 patterns
                            //**************************************************

                            if (ScanPtr >= EndOfScanPtr)
                                ScanPtr = NextScan;     // Reset back to beginning
                            }

                        //******************************************************
                        // Advance to next pattern scanline
                        //******************************************************

                        NextScan+=ScanInc;

                        //******************************************************
                        // Check if we need to wraparound back to beginning of pattern
                        // If so, reset pattern pointer back to the beginning
                        //******************************************************

                        PatternYCount++;
                        if (PatternYCount>=8)
                            {
                            NextScan = (ULONG *)SrcBits;
                            PatternYCount=0;
                            }

                        } // for yscan...


                    }  // slow image from cpu ...


                }  // 32bpp


            //******************************************************************
            // Onto the next clipping rectangle
            //******************************************************************

            prcl++;

            } while (--c != 0);

        } // Multi-color pattern

    //**************************************************************************
    // Update the global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    } // End of FillPattern routine



//******************************************************************************
//
//  Function:   NV3MonoScanlineImageTransfer
//
//  Routine Description:
//
//       Low-level routine for transferring a bitmap image via RENDER_GDI0_RECT_AND_TEXT
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3MonoScanlineImageTransfer(
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
ULONG   NumDwordsPerScan,
USHORT* FreeCountPtr)


    {
    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;
    USHORT FreeCount;
    ULONG MonoPixelData1;
    ULONG MonoPixelData2;
    ULONG *SrcDataPtr;

    //**************************************************************************
    // Init FreeCount variable
    //**************************************************************************

    FreeCount=(*FreeCountPtr);

    //**************************************************************************
    // Get Dword Ptr to Src Data
    //**************************************************************************

    SrcDataPtr = (DWORD *)pjSrc;

    //**************************************************************************
    // Handle groups of 16 dwords at a time
    //**************************************************************************

    while (NumDwordsPerScan>= 16)
        {

        while (FreeCount < 16*4)
           FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 16*4;

        MonoPixelData1 = SrcDataPtr[0];
        MonoPixelData2 = SrcDataPtr[1];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[0] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[1] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[2];
        MonoPixelData2 = SrcDataPtr[3];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[2] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[3] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[4];
        MonoPixelData2 = SrcDataPtr[5];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[4] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[5] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[6];
        MonoPixelData2 = SrcDataPtr[7];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[6] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[7] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[8];
        MonoPixelData2 = SrcDataPtr[9];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[8] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[9] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[10];
        MonoPixelData2 = SrcDataPtr[11];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[10] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[11] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[12];
        MonoPixelData2 = SrcDataPtr[13];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[12] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[13] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[14];
        MonoPixelData2 = SrcDataPtr[15];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[14] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[15] = MonoPixelData2;

        NumDwordsPerScan-=16;
        SrcDataPtr += 16;

        }

    //**************************************************************************
    // Handle groups of 8 dwords at a time
    //**************************************************************************

    while (NumDwordsPerScan>= 8)
        {

        while (FreeCount < 8*4)
           FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 8*4;

        MonoPixelData1 = SrcDataPtr[0];
        MonoPixelData2 = SrcDataPtr[1];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[0] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[1] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[2];
        MonoPixelData2 = SrcDataPtr[3];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[2] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[3] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[4];
        MonoPixelData2 = SrcDataPtr[5];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[4] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[5] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[6];
        MonoPixelData2 = SrcDataPtr[7];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[6] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[7] = MonoPixelData2;

        NumDwordsPerScan -=8;
        SrcDataPtr += 8;

        }

    //**************************************************************************
    // Handle groups of 4 dwords at a time
    //**************************************************************************

    while (NumDwordsPerScan>= 4)
        {

        while (FreeCount < 4*4)
           FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 4*4;

        MonoPixelData1 = SrcDataPtr[0];
        MonoPixelData2 = SrcDataPtr[1];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[0] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[1] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[2];
        MonoPixelData2 = SrcDataPtr[3];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[2] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[3] = MonoPixelData2;

        NumDwordsPerScan-=4;
        SrcDataPtr += 4;

        }

    //**************************************************************************
    // Handle any remaining dwords
    //**************************************************************************

    while (NumDwordsPerScan > 0)
        {
        while (FreeCount < 4)
            FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 4;

        MonoPixelData1 = SrcDataPtr[0];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[0] = MonoPixelData1;

        NumDwordsPerScan--;

        SrcDataPtr ++;
        }

    //**************************************************************************
    // Update cached FreeCount variable
    //**************************************************************************

    *FreeCountPtr = FreeCount;
    }





//******************************************************************************
//
//  Function:   NV3Xfer1bpp
//
//  Routine Description:
//
//     This routine colour expands a monochrome bitmap, possibly with different
//     Rop2's for the foreground and background.  It will be called in the
//     following cases:
//
//     1) To colour-expand the monochrome text buffer for the vFastText routine.
//     2) To blt a 1bpp source with a simple Rop2 between the source and
//        destination.
//  x  3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
//        white and black, and the pattern is a solid colour.
//     4) To handle a true Rop4 that works out to be two Rop2's between the
//        pattern and destination.
//
//     Needless to say, making this routine fast can leverage a lot of
//     performance.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3Xfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,     // Solid Color of pattern
BLENDOBJ*   pBlendObj)

    {
    ULONG   ulHwForeMix;
    ULONG   ulHwBackMix;
    LONG    dxSrc;
    LONG    dySrc;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;
    LONG    xLeft;
    LONG    yTop;
    LONG    xBias;

    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG Color0;
    ULONG Color1;
    ULONG AlphaEnableValue;
    ULONG NumBytesPerScan;
    ULONG NumDwordsPerScan;
    ULONG OffsetOfLastDword;
    ULONG LastDword;
    ULONG PixelDepth;
    ULONG width;
    ULONG height;
    USHORT FreeCount;
    ULONG SizeInWidth;
    ULONG rop3;
    ULONG ClipLeft;
    ULONG ClipTop;
    ULONG ClipWidth;
    ULONG ClipHeight;
    RECTL DstRect;

    //**************************************************************************
    // Make sure following conditions are true before continuing on
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");
    ASSERTDD(((((rop4 & 0xff00) >> 8) == (rop4 & 0xff)) || (rop4 == 0xaacc)),
             "Expect weird rops only when opaquing");

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // Init foreground and background color
    //**************************************************************************

    Color0 = pxlo->pulXlate[0] | (AlphaEnableValue); // Background color
    Color1 = pxlo->pulXlate[1] | (AlphaEnableValue); // Foreground color

    //**************************************************************************
    // Find the pitch and starting location of the source mono (pattern) bitmap
    //
    // NOTE:  Normally, we'd need to check if this source SURFOBJ was a
    //        standard DIB or a DFB that was moved to system memory.
    //        However, since we don't store 1bpp SURFOBJs in offscreen memory
    //        (see drvCreateDeviceBitmap), we know that the this source SURFOBJ
    //        is just a plain standard DIB. (i.e.  we don't need to get the
    //        'lDelta' and 'pvScan0' values from psoSrc->dhsurf->pso->lDelta
    //        and psoSrc->dhsurf->pso->pvScan0.
    //
    //**************************************************************************

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    //**************************************************************************
    // Safety check  ...check and see if source bitmap is dword aligned
    // This is a requirement....bitmap should never start on non-dword alignment..
    // Otherwise, that will invalidate some assumptions made...we currently
    // always read dword multiples...at dword alignments...if source bitmap
    // doesn't start on a dword boundary, then we might not be able to get
    // the first dword of data on a dword boundary ...Send back to DIBengine?
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3), "Unaligned source bitmap");

    //**********************************************************************
    // Init FreeCount variable
    //**********************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**********************************************************************
    // Adjust dest rect in case it is in offscreen memory
    //**********************************************************************

    DstRect.top = prclDst->top;
    DstRect.left = prclDst->left;
    DstRect.right = prclDst->right;
    DstRect.bottom = prclDst->bottom;

    do  {
        //**********************************************************************
        //
        //  First, we need to determine the XBIAS required (where the starting bit
        //  of the monochrome source bitmap is located).  XBIAS is affected
        //  by 3 values as follows:
        //
        //          1) pptlSrc->x    ( value x1 shown below )
        //
        //                  This is simply the bit at which we want to
        //                  start in the monochrome pattern bitmap
        //
        //          2) prclDst->x    ( value x2 shown below )
        //
        //                  Location of the original unclipped destination rectangle
        //
        //          3) prcl->x       ( value x3 shown below)
        //
        //                  Current clip rectangle with coordinates relative
        //                  to prclDst
        //
        //  Screen Origin
        //  +--------------------------------------------------------------->
        //  |
        //  |
        //  |           x2 = prclDst->left
        //  |           +-----------------------------------------------
        //  |           |                             ^                 |-Original
        //  |           |                             | dySrc           |  Unclipped
        //  |           |                             |                 |   Destination
        //  |           |         x3 = prcl->left     v                 |    Rectangle
        //  |           |         +------------       -                 |
        //  |           |         |            |                        |
        //  |           |<-dxSrc->|            |                        |
        //  |           |         |            |                        |
        //  |           |         |            |-Current                |
        //  |           |         |            |  Clip                  |
        //  |           |          ------------    Rectangle            |
        //  |           |                                               |
        //  |           |                                               |
        //  |           |                                               |
        //  |            -----------------------------------------------
        //  |
        //  v
        //
        //            Source MonoChrome Bitmap
        //          +--------+--------+--------+------->
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |           ^
        //          v           |
        //                      |
        //                      |
        //          |-- x1 ---->|
        //
        //**********************************************************************

        //**********************************************************************
        //
        // Once we determine the starting bit in the monochrome bitmap,
        // we can calculate the XBIAS value.  The left portion of the 1st source
        // dword that we will read will end up getting clipped by hardware.
        // This will allow us to NOT have to align subsequent source data.
        //
        //    xbias =  ( x1 + (x3 - x2) ) & 0x1f
        //
        //    xbias =  ( x1 + (dxSrc)   ) & 0x1f  ( starting bit position in dword)
        //                                                 from 0 - 31
        //
        //           --------------------------
        //          |00011001|00010010|00010011|  1st dword of source data
        //           --------------------------
        //          |               |          |
        //          |<--- xbias --->|          |
        //          |               |   This   |
        //          | This region is| region is|
        //          |   clipped     |  drawn   |
        //          v               v          v
        //
        //**********************************************************************

        //**********************************************************************
        // Set initial destination coordinates of blit
        //**********************************************************************

        yTop  = prcl->top;
        xLeft = prcl->left;

        //**********************************************************************
        // Init dimensions of clip rectangle.
        //**********************************************************************

        ClipTop = prcl->top;
        ClipLeft = prcl->left;

        ClipHeight = prcl->bottom - prcl->top;
        ClipWidth = prcl->right - prcl->left;

        //**********************************************************************
        // Find starting bit location of pattern.  We really only care about
        // the dword alignment (bottom 5 bits) of this value.
        //**********************************************************************

        dxSrc = prcl->left - DstRect.left;
        dySrc = prcl->top  - DstRect.top;

        //**********************************************************************
        // Determine the bias of the bitmap
        //**********************************************************************

        xBias = ( (pptlSrc->x + dxSrc) & 0x1f);     // Value from 0 thru 31
        if (xBias != 0)
            {
            //******************************************************************
            // NV: Set the hardware clip rectangle so we don't have to
            //     manually align the pattern bitmap.  Then make sure
            //     to adjust the starting point of the blit to account
            //     for this xbias.
            //
            // We should probably remove the  if (xBias !=0) statement
            // since it's not necessary.
            //******************************************************************

            xLeft -= xBias;
            }

        //**********************************************************************
        // Get width and height of the destination rectangle
        // Then calculate the DWORDS we'll send to the NV engine
        // (we always output DWORDS at a time), and the number of bytes per scan
        // SizeInWidth will always be a multiple of 32 pixels (1 dword's worth)
        //
        // Remember, xLeft has now been adjusted to account for the XBias value
        //**********************************************************************

        width = prcl->right - xLeft;
        height= prcl->bottom - yTop;

        //**********************************************************************
        // Get values required by NV hardware engine
        //**********************************************************************

        SizeInWidth = (width + 31) & 0xffe0;    // Always a multiple of 32 pixels
        NumBytesPerScan = SizeInWidth >> 3;     // Divide mono pixels by 8 to get bytes


        //**********************************************************************
        // MUST set the pattern appropriately!
        //**********************************************************************

        while (FreeCount < 5*4)
           FreeCount = nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].control.Free;
        FreeCount -= 5*4;

        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeShape = NV018_SET_MONOCHROME_SHAPE_64X_1Y;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor0 = ( PatternColor | AlphaEnableValue );
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor1 = ( PatternColor | AlphaEnableValue );
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern0 = 0xffffffff;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern1 = 0xffffffff;


        //**********************************************************************
        // Get Rop3 value from Rop4
        //**********************************************************************

        rop3 = (ULONG)((BYTE)rop4);

        while (FreeCount < 1*4)
            FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 1*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = rop3;

        //**********************************************************************
        // Prep the monster class text object (rendergdi0RectAndText)
        //**********************************************************************

        while (FreeCount < 7*4)
            FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 7*4;

        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint0E = ((ClipTop << 16) | (ClipLeft & 0xffff) );
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint1E = (((ClipTop+ClipHeight)<<16) | (ClipLeft+ClipWidth));

        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color0E = Color0;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color1E = Color1;

        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeInE = ( (height <<16) | SizeInWidth );
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeOutE = ( (height <<16) | width );
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.PointE =  ( (yTop <<16) | (xLeft & 0xffff) );

        //**********************************************************************
        // Get starting byte address of source pattern bitmap
        // Once we have the starting byte address, we can get the starting dword address
        //
        // ?: Is it possible that pptlSrc->y + dySrc will go past
        //    end of Source Bitmap??
        //**********************************************************************

        pjSrc = pjSrcScan0 + (pptlSrc->y + dySrc) * lSrcDelta
                           + ((pptlSrc->x + dxSrc) >> 3);

        (ULONG_PTR)pjSrc &= ~0x3;

        //**********************************************************************
        // Get values pertinent for each scanline
        //**********************************************************************

        NumDwordsPerScan = SizeInWidth / 32;
        OffsetOfLastDword = NumDwordsPerScan << 2;

        //**********************************************************************
        //
        // For performance, we have 2 main objectives as follows:
        //
        //   a) When reading src data, we'd like it to be dword aligned
        //   b) When outputting data, we'd like to output dwords as much as possible
        //
        // With that in mind, we accomplish objective (a) by calculating an
        // xbias value and reading the dword that the first byte of source data
        // is contained in.  That is, we'll grab the first dword of source data
        // and clip the left part of it using the hardware clip rectangle.
        // As a result, any subsequent reads of src data will not require
        // alignment.
        //
        // Example:
        //          Src data begins here --+
        //          at this bit            |
        //                                 v
        //           -----------------------------------
        //          |        |        |        |        |   1st dword of src data
        //           -----------------------------------
        //            byte 0    byte1    byte2    byte3
        //
        //          |<------ xbias ------->|
        //                                 |
        //                                 |<-- used -->|
        //                                 |    data
        //          |<- hardware clipped ->|
        //
        //
        // Objective (b) is accomplished by examining how many dwords we
        // need to output.  The key here is to make sure we don't read past
        // the end of the source bitmap. If the number of bytes we need to
        // output is a dword multiple, then we don't need to worry about it.
        // However, if it's not, we need to check the last couple of bytes
        // and not read past the end of the src data. Otherwise, we'll
        // generate a protection fault. This is done simply by using
        // a switch statement that handles 0,1,2, or 3 remaining bytes of src data.
        //
        //          Switch (Number Of src bytes left)
        //              0:  We are dword aligned already
        //              1:  Just read 1 more byte
        //              2:  Just read 2 more bytes
        //              3:  just read 3 more bytes
        //
        //**********************************************************************


        //**********************************************************************
        // Get src data, depending on how many bytes we will output
        // TO DO:  Since we now read the starting dword of the source bitmap
        //         (instead of the starting byte), isn't it true that
        //         we don't need to worry about straggling bytes going past
        //         end of bitmap...i.e. bitmaps are always allocated as
        //         multiples of dwords?  VERIFY!
        //
        //**********************************************************************


        switch (NumBytesPerScan & 3)
            {

            //******************************************************************
            // Output dwords at a time, then output last 3 bytes of data (in last dword)
            //******************************************************************

            case 3:
                do  {
                    if (NumDwordsPerScan > 0)
                        NV3MonoScanlineImageTransfer(ppdev, pjSrc, NumDwordsPerScan,&FreeCount);

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword))  |
                            (*(pjSrc + OffsetOfLastDword + 1) << 8) |
                            (*(pjSrc + OffsetOfLastDword + 2) << 16);

                    NV3MonoScanlineImageTransfer(ppdev, (BYTE *)&LastDword, 1,&FreeCount);
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // Output dwords at a time, then output last 2 bytes of data (in last dword)
            //******************************************************************

            case 2:
                do  {
                    if (NumDwordsPerScan > 0)
                        NV3MonoScanlineImageTransfer(ppdev, pjSrc, NumDwordsPerScan,&FreeCount);

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword))  |
                            (*(pjSrc + OffsetOfLastDword + 1) << 8);

                    NV3MonoScanlineImageTransfer(ppdev, (BYTE *)&LastDword, 1,&FreeCount);
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // Output dwords at a time, then output last byte of data (in last dword)
            //******************************************************************

            case 1:
                do  {
                    if (NumDwordsPerScan > 0)
                        NV3MonoScanlineImageTransfer(ppdev, pjSrc, NumDwordsPerScan,&FreeCount);

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword));

                    NV3MonoScanlineImageTransfer(ppdev, (BYTE *)&LastDword, 1,&FreeCount);
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // The amount of data we will send is already a multiple of 4.
            // We will blast out all data in dwords
            //******************************************************************

            case 0:
                do  {
                    NV3MonoScanlineImageTransfer(ppdev, pjSrc,NumDwordsPerScan,&FreeCount);
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            } // Switch (NumBytesPerScan)

        prcl++;
        } while (--c != 0); // Next Clipping rectangle


    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    }


//******************************************************************************
//
//  Function:   NV3_Send_Data
//
//  Routine Description:
//
//       Low-level routine for transferring a bitmap image via IMAGE_MONO_FROM_CPU
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3_Send_Data(
PDEV*   ppdev,
ULONG*  SrcDataPtr,              // Source pointer
ULONG   PixelCount,
USHORT* FreeCountPtr)


    {
    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;
    USHORT FreeCount;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    ULONG DwordCount;

    DwordCount = (PixelCount+3)/4;

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = *FreeCountPtr;

    //**************************************************************************
    // Output next group of 16 dwords
    //**************************************************************************

    while (DwordCount >= 16)
        {
        DwordCount -=16;

        while (FreeCount < 16*4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -=16*4;

        TempPixelData1 = SrcDataPtr[0];
        TempPixelData2 = SrcDataPtr[1];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[2];
        TempPixelData2 = SrcDataPtr[3];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[4];
        TempPixelData2 = SrcDataPtr[5];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[6];
        TempPixelData2 = SrcDataPtr[7];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[8];
        TempPixelData2 = SrcDataPtr[9];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[8] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[9] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[10];
        TempPixelData2 = SrcDataPtr[11];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[10] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[11] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[12];
        TempPixelData2 = SrcDataPtr[13];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[12] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[13] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[14];
        TempPixelData2 = SrcDataPtr[15];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[14] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[15] =  TempPixelData2;

        SrcDataPtr +=16;           // Advance 16 dwords
        }

    //**************************************************************************
    // Output next group of 4 dwords
    //**************************************************************************

    while (DwordCount >= 4)
        {
        DwordCount -=4;

        while (FreeCount < 4*4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -=4*4;

        TempPixelData1 = SrcDataPtr[0];
        TempPixelData2 = SrcDataPtr[1];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[2];
        TempPixelData2 = SrcDataPtr[3];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;

        SrcDataPtr +=4;            // Advance 4 dwords

        }


    //**************************************************************************
    // Output any remaining dwords
    //**************************************************************************

    while (DwordCount >0 )
        {
        DwordCount--;

        while (FreeCount < 4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -= 4;

        TempPixelData1 = SrcDataPtr[0];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;

        SrcDataPtr ++;             // Advance 1 dword

        }
    *FreeCountPtr = FreeCount;
    }


//******************************************************************************
//
//  Function:   NV3Xfer4bpp
//
//  Routine Description:
//
//      Does a 4bpp transfer from a bitmap to the screen.
//
//      NOTE: The screen must be 8bpp for this function to be called!
//
//      The reason we implement this is that a lot of resources are kept as 4bpp,
//      and used to initialize DFBs, some of which we of course keep off-screen.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


//******************************************************************************
// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.
//
// NV_HALF_BUFFER_SIZE -> NV fifo can hold up to 32 DWORDS (128 bytes)
//                        Here, we output the data when we've reach half of that
//******************************************************************************

#define XLATE_BUFFER_SIZE 256
#define NV_HALF_FIFO_SIZE 16*4

VOID NV3Xfer4bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG PatternColor,       // Not used
BLENDOBJ*   pBlendObj)

    {
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG Rop3;
    ULONG temp;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    BYTE *NextScan;
    ULONG yscan;
    ULONG WordCount;
    BYTE *ScanPtr;
    LONG ScanInc;
    USHORT FreeCount;
    ULONG OnePixel;
    BYTE *DstBits;
    ULONG SizeInWidth;
    ULONG WordsPerDstScan;
    ULONG clip_x,clip_y;
    ULONG clip_width,clip_height;
    BYTE TempPixelData[XLATE_BUFFER_SIZE];
    DSURF*          pdsurfSrc;
    ULONG*  pulXlate;
    BYTE  PixelDataByte;
    ULONG PixelDataDword;
    ULONG   LoopCount;
    ULONG PixelCount;
    ULONG i;
    ULONG DwordCheck;

    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**********************************************************************
    // Get ready to translate the 4bpp colors
    //**********************************************************************

    ASSERTDD(pxlo != NULL, "Xfer4BPP, NULL XLATEOBJ");
    pulXlate  =  pxlo->pulXlate;

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    if (pdsurfSrc != NULL)
        pjSrcScan0 = pdsurfSrc->pso->pvScan0;
    else
        pjSrcScan0 = psoSrc->pvScan0;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************
    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3),
        "Unaligned source bitmap");// ACK!....src bitmap is not dword aligned !!!

    //**************************************************************************
    // Get Rop3 value
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
    else
        BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************
    ASSERTDD(!((ULONG) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = BytesPerSrcScan ;      // Number of bytes to increment

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

   if (ppdev->NVClipResetFlag)
       {
       while (FreeCount < 2*4)
          FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
       FreeCount -= 2*4;

       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
       }

    //**************************************************************************
    // Blit for each clipping rectangle
    //**************************************************************************

    while(TRUE)
        {

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + prcl->left - prclDst->left;
        ysrc = pptlSrc->y + prcl->top  - prclDst->top;

        //**********************************************************************
        // Get ptr to start of SRC (Remember, there are 2 pixels per byte!)
        //**********************************************************************

        NextScan = (&(pjSrcScan0[(xsrc>>1) + ysrc*BytesPerSrcScan]));

        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - prcl->left;
        clip_height = prcl->bottom - prcl->top;

        while (FreeCount < 4*4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -=4*4;

        //**********************************************************************
        // Setup NV Blit parameters for CPU to SCREEN blit
        //**********************************************************************

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = Rop3 ;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ( (clip_y) <<16) | ((clip_x) & 0xffff) );
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (clip_height <<16) | clip_width );

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        if (depth == 8)
            SizeInWidth = ((clip_width + 3) & 0xfffc);
        else if (depth == 16)
            SizeInWidth = ((clip_width + 1) & 0xfffe);
        else
            SizeInWidth = clip_width;

        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (clip_height <<16) | (SizeInWidth) );

        //******************************************************************
        //
        // 4bpp Source Bitmap:
        //
        // nibble| hi lo | hi  lo| hi lo | hi lo | hi  lo|
        //        -----------------------------------------------
        //       | Byte0 | Byte1 | Byte2 | Byte3 | Byte4 | etc..
        //        -----------------------------------------------
        // Pixels  0  1    2  3     4  5    6  7    8  9
        //
        // Pixels are displayed on screen as UPPER NYBBLE, then LOWER NYBBLE
        //
        // We must be careful not to read past end of 4bpp bitmap
        // We do this by breaking up the operation into 2 cases:
        //
        // If the starting pixel is ODD, then we need to read
        // the LOWER nybble of the source byte first, and proceed from there.
        // If the starting pixel is EVEN, then we need to read
        // the UPPER nybble of the source byte first, and proceed from there.
        //
        //******************************************************************

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        if ( xsrc & 1)
            {
            for (yscan=0;yscan < clip_height; yscan++)
                {
                ScanPtr = NextScan;
                PixelCount=0;
                //**************************************************************
                // For each byte, we read 2 pixels.  We will count by bytes.
                // Since we started on an ODD pixel, we read the LOWER
                // nibble of the current source byte FIRST, then we
                // read the UPPER nibble
                //**************************************************************

                LoopCount= clip_width>>1 ;      // Odd pel handled separately

                //**************************************************************
                // Get the current 2 pixels of data
                //**************************************************************

                PixelDataByte = *ScanPtr;

                while (LoopCount-- > 0)
                    {
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte & 0xf];
                    ScanPtr++;

                    PixelDataByte =*ScanPtr ;
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte >> 4];

                    //**********************************************************
                    // Check if we need to flush the data and
                    // send it to NV hardware
                    //**********************************************************

                    if (PixelCount >= NV_HALF_FIFO_SIZE)
                        {
                        NV3_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount,&FreeCount);
                        PixelCount=0;
                        }
                    }

                //**************************************************************
                // Check for any straggling pixel leftover
                //**************************************************************

                if (clip_width & 1)
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte & 0xf];

                //**************************************************************
                // Flush any remaining pixel data
                //**************************************************************

                if (PixelCount!=0)
                    NV3_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount,&FreeCount);

                NextScan+=ScanInc;
                }
            }
        else
            {
            for (yscan=0;yscan < clip_height; yscan++)
                {
                ScanPtr = NextScan;
                PixelCount=0;
                //**************************************************************
                // Pixels are displayed on screen as UPPER NYBBLE, then LOWER NYBBLE
                //**************************************************************

                LoopCount = (clip_width + 1) >> 1;  // Each loop handles 2 pels

                do  {
                    //**********************************************************
                    // See if we can speed things up a bit by reading DWORDS
                    //**********************************************************

                    if (LoopCount>=4)               // 8 pels or more to go?
                        {
                        PixelDataDword = *((DWORD *)ScanPtr);
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >> 4) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword     ) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>12) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >> 8) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>20) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>16) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>28) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>24) & 0xf];

                        ScanPtr+=4;                 // Advance by 8 source pels

                        LoopCount-=4;               // 4 groups of 2 pels = 8 pels
                        }

                    else
                        {
                        PixelDataByte = *ScanPtr;

                        TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte >> 4];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte & 0xf];

                        ScanPtr++;                  // Advance by 2 source pels

                        LoopCount--;                // 1 group of 2 pels = 2 pels
                        }

                    //**********************************************************
                    // Check if we need to flush the data and
                    // send it to NV hardware
                    //**********************************************************

                    if (PixelCount >= NV_HALF_FIFO_SIZE)
                        {
                        NV3_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount,&FreeCount);
                        PixelCount=0;
                        }

                    } while (LoopCount != 0);

                //**************************************************************
                // Flush any remaining pixel data
                //**************************************************************

                if (PixelCount!=0)
                    NV3_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount,&FreeCount);


                NextScan+=ScanInc;
                }
            }

        if (--c == 0)
            {
            //******************************************************************
            // Update global free count
            //******************************************************************
            ppdev->NVFreeCount = FreeCount;

            return;
            }

        prcl++;

        } // while (TRUE)...

    }



//******************************************************************************
//
//  Function:   NV3XferNative
//
//      Transfers a bitmap that is the same colour depth as the display to
//      the screen via the data transfer register, with no translation.
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3XferNative(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG PatternColor,       // Not used
BLENDOBJ*   pBlendObj)
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   SrcBits;
    BYTE*   pjSrc;
    LONG    cjSrc;

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG Rop3;
    ULONG temp;
    ULONG xsrc,ysrc;
    ULONG *NextScan;
    ULONG BytesPerDstScan;
    ULONG DwordsPerDstScan;
    ULONG yscan;
    ULONG WordCount;
    ULONG *ScanPtr;
    LONG ScanInc;
    USHORT FreeCount;
    ULONG OnePixel;
    BYTE *DstBits;
    ULONG SizeInWidth;
    ULONG WordsPerDstScan;
    ULONG clip_x,clip_y;
    ULONG clip_width,clip_height;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    DSURF*          pdsurfSrc;
    ULONG   ByteCount;
    ULONG   i;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) ||
             ((pxlo->flXlate == 0x10) && (OglIsEnabled(ppdev))),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        if (prclDst->right - prclDst->left < prcl->right - prcl->left)
        {
            clip_width = prclDst->right - prclDst->left;
        }
        else
        {
            clip_width = prcl->right - prcl->left;
        }
        if (prclDst->bottom - prclDst->top < prcl->bottom - prcl->top)
        {
            clip_height = prclDst->bottom - prclDst->top;
        }
        else
        {
            clip_height = prcl->bottom - prcl->top;
        }

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + prcl->left - prclDst->left;
        ysrc = pptlSrc->y + prcl->top - prclDst->top;

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        while (FreeCount < 4*4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -=4*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = Rop3 ;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ( (clip_y) <<16) | ((clip_x) & 0xffff) );
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (clip_height <<16) | clip_width );

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        if (depth == 8)
            SizeInWidth = ((clip_width + 3) & 0xfffc);
        else if (depth == 16)
            SizeInWidth = ((clip_width + 1) & 0xfffe);
        else
            SizeInWidth = clip_width;

        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (clip_height <<16) | SizeInWidth );

        //**********************************************************************
        // Calculate number of dwords to output for scanline
        // This is the actual amount of data that the NV engine expects per scanline.
        // SizeInWidth is guaranteed to be a multiple of 2 (for 16bpp) and
        // a multiple of 4 (for 32bpp).  So we'll always be outputting DWORDS.
        // (No leftover words or bytes, they get clipped)
        //**********************************************************************

        BytesPerDstScan = clip_width * depth/8;
        DwordsPerDstScan = BytesPerDstScan / 4 + ((BytesPerDstScan % 4) ? 1 : 0);
        //**********************************************************************
        // Get ptr to start of SRC
        //**********************************************************************

        NextScan = (ULONG *)(&(SrcBits[(xsrc*depth/8) + ysrc*BytesPerSrcScan]));

        //**********************************************************************
        // Amount to increment for each scanline
        //**********************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

#ifdef _X86_
        //**********************************************************************
        // Use assembly to output as fast as possible
        // We can still use the NV1 assembly routine, since we're still
        // using the NV1 version of the imagefromcpu class.
        //**********************************************************************

        NV1_Transfer_MemToScreen_Data(BytesPerDstScan,&FreeCount,clip_height,NextScan,ScanInc,nv);

#else

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0;yscan < clip_height; yscan++)
            {
            ByteCount=BytesPerDstScan;
            ScanPtr = NextScan;

            //******************************************************************
            // Output next group of 16 dwords
            //******************************************************************

            while (ByteCount >= 16 * sizeof(ULONG))
                {
                ByteCount -= (16 * sizeof(ULONG));

                while (FreeCount < 16*4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -=16*4;

                TempPixelData1 = ScanPtr[0];
                TempPixelData2 = ScanPtr[1];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
                TempPixelData1 = ScanPtr[2];
                TempPixelData2 = ScanPtr[3];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;
                TempPixelData1 = ScanPtr[4];
                TempPixelData2 = ScanPtr[5];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] =  TempPixelData2;
                TempPixelData1 = ScanPtr[6];
                TempPixelData2 = ScanPtr[7];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] =  TempPixelData2;
                TempPixelData1 = ScanPtr[8];
                TempPixelData2 = ScanPtr[9];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[8] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[9] =  TempPixelData2;
                TempPixelData1 = ScanPtr[10];
                TempPixelData2 = ScanPtr[11];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[10] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[11] =  TempPixelData2;
                TempPixelData1 = ScanPtr[12];
                TempPixelData2 = ScanPtr[13];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[12] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[13] =  TempPixelData2;
                TempPixelData1 = ScanPtr[14];
                TempPixelData2 = ScanPtr[15];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[14] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[15] =  TempPixelData2;

                ScanPtr +=16;           // Advance 16 dwords
                }

            //******************************************************************
            // Output next group of 4 dwords
            //******************************************************************

            while (ByteCount >= 4 * sizeof(ULONG))
                {
                ByteCount -= (4 * sizeof(ULONG));

                while (FreeCount < 4*4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -=4*4;

                TempPixelData1 = ScanPtr[0];
                TempPixelData2 = ScanPtr[1];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
                TempPixelData1 = ScanPtr[2];
                TempPixelData2 = ScanPtr[3];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;

                ScanPtr +=4;            // Advance 4 dwords

                }


            //******************************************************************
            // Output any remaining dwords
            //******************************************************************

            while (ByteCount >= sizeof(ULONG) )
                {
                ByteCount -= sizeof(ULONG);

                while (FreeCount < 4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -= 4;

                TempPixelData1 = ScanPtr[0];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;

                ScanPtr ++;             // Advance 1 dword

                }



            //
            // Pad src scanline.
            //
            if (ByteCount)
            {
                TempPixelData1 = 0;
                for (i = 0; i < ByteCount; i++)
                {
                    TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

                while (FreeCount < 4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -= 4;

                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            }

            NextScan+=ScanInc;
            }


#endif


        if (--c == 0)
            {
            //******************************************************************
            // Update global free count
            //******************************************************************
            ppdev->NVFreeCount = FreeCount;

            return;
            }

        prcl++;

        } // while (TRUE)...

    }


//******************************************************************************
//
//  Function:   NV3MemToScreenBlit
//
//  Routine Description:
//
//      Does a memory-to-screen blt
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3MemToScreenBlt(
PDEV*   ppdev,
SURFOBJ* psoSrc,
POINTL* pptlSrc,
RECTL*  prclDst)

    {
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source
    LONG    cx;
    LONG    cy;     // Size of current rectangle - 1

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;

    ULONG width,height;
    ULONG xscan,yscan;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG ByteCount;
    ULONG SizeInWidth;
    ULONG BytesPerDstScan;
    ULONG DwordsPerDstScan;
    ULONG WordsPerDstScan;
    ULONG WordCount;
    WORD OnePixel;
    ULONG PixelData;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    ULONG *ScanPtr;
    ULONG *NextScan;
    LONG ScanInc;
    USHORT FreeCount;
    BYTE* SrcBits;
    DSURF* pdsurfSrc;

    //**************************************************************************
    // This function is exactly the same as XferNative, except
    // that 1) Rop = SRCCOPY always
    //      2) No clipping is done here
    //      3) No color translation
    //**************************************************************************

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**************************************************************************

    width = prclDst->right - prclDst->left;
    height = prclDst->bottom - prclDst->top;

    //**************************************************************************
    // Top left coordinate of destination on destination surface
    //**************************************************************************

    xdst = prclDst->left;
    ydst = prclDst->top;

    //**************************************************************************
    // Top left coordinate of source bitmap on source surface
    //**************************************************************************

    xsrc = pptlSrc->x;
    ysrc = pptlSrc->y;

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

   if (ppdev->NVClipResetFlag)
       {
       while (FreeCount < 2*4)
          FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
       FreeCount -= 2*4;

       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
       }

   //***************************************************************************
   // Initialize the ImageFromCpu object
   //***************************************************************************

    while (FreeCount < 4*4)
       FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
    FreeCount -=4*4;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = NV_SRCCOPY ;
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ((ydst) <<16) | ((xdst) & 0xffff) );
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (height <<16) | width );

    //**************************************************************************
    // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    //**************************************************************************

    if (depth == 8)
        SizeInWidth = ((width + 3) & 0xfffc);
    else if (depth == 16)
        SizeInWidth = ((width + 1) & 0xfffe);
    else
        SizeInWidth = width;

    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (height <<16) | (SizeInWidth) );

    //**************************************************************************
    // Calculate number of dwords to output for scanline.
    //**************************************************************************
    BytesPerDstScan = width * depth/8;
    DwordsPerDstScan = BytesPerDstScan / 4 + ((BytesPerDstScan % 4) ? 1 : 0);

    //**************************************************************************
    // Get ptr to start of SRC
    //**************************************************************************

    NextScan = (ULONG *)(&(SrcBits[(xsrc*depth/8) + (ysrc*BytesPerSrcScan)]));

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;
        
#ifdef _X86_
    //**************************************************************************
    // Use assembly to output as fast as possible
    // We can still use the NV3 assembly routine, since we're still
    // using the NV3 version of the imagefromcpu class
    //**************************************************************************

    NV1_Transfer_MemToScreen_Data(BytesPerDstScan,&FreeCount,height,NextScan,ScanInc,nv);

#else
    //**************************************************************************
    // The following C code is the exact equivalent of
    // NV1_Transfer_MemToScreen_Data in assembly.
    //**************************************************************************

   //************************************************************************
   // Output one scan at a time
   //************************************************************************

   for (yscan=0;yscan < height; yscan++)
        {
        ByteCount = BytesPerDstScan;

        ScanPtr = NextScan;

        //********************************************************************
        // Output next group of 16 dwords
        //********************************************************************

        while (ByteCount >= (16 * sizeof(ULONG)))
            {
            ByteCount -= (16 * sizeof(ULONG));

            while (FreeCount < 16*4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=16*4;

            TempPixelData1 = ScanPtr[0];
            TempPixelData2 = ScanPtr[1];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
            TempPixelData1 = ScanPtr[2];
            TempPixelData2 = ScanPtr[3];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;
            TempPixelData1 = ScanPtr[4];
            TempPixelData2 = ScanPtr[5];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] =  TempPixelData2;
            TempPixelData1 = ScanPtr[6];
            TempPixelData2 = ScanPtr[7];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] =  TempPixelData2;
            TempPixelData1 = ScanPtr[8];
            TempPixelData2 = ScanPtr[9];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[8] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[9] =  TempPixelData2;
            TempPixelData1 = ScanPtr[10];
            TempPixelData2 = ScanPtr[11];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[10] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[11] =  TempPixelData2;
            TempPixelData1 = ScanPtr[12];
            TempPixelData2 = ScanPtr[13];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[12] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[13] =  TempPixelData2;
            TempPixelData1 = ScanPtr[14];
            TempPixelData2 = ScanPtr[15];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[14] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[15] =  TempPixelData2;

            ScanPtr +=16;           // Advance 16 dwords
            }

        //********************************************************************
        // Output next group of 4 dwords
        //********************************************************************

        while (ByteCount >= (4 * sizeof(ULONG)))
            {
            ByteCount -= (4 * sizeof(ULONG));

            while (FreeCount < 4*4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=4*4;

            TempPixelData1 = ScanPtr[0];
            TempPixelData2 = ScanPtr[1];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
            TempPixelData1 = ScanPtr[2];
            TempPixelData2 = ScanPtr[3];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;

            ScanPtr +=4;            // Advance 4 dwords

            }

        //********************************************************************
        // Output any remaining dwords
        //********************************************************************

        while (ByteCount >= sizeof(ULONG))
            {
            ByteCount -= sizeof(ULONG);

            while (FreeCount < 4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -= 4;

            TempPixelData1 = ScanPtr[0];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;

            ScanPtr ++;             // Advance 1 dword

            }

        //********************************************************************
        // Pad src scanline.
        //********************************************************************
        if (ByteCount)
            {
            ULONG   i;
            TempPixelData1 = 0;
            for (i = 0; i < ByteCount; i++)
                {
                TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

            while (FreeCount < 4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -= 4;

            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            }


        NextScan+=ScanInc;

        }
#endif  // _X86_

    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;



    }

//******************************************************************************
//
//  Function:   NV3MemToScreenWithPatternBlt()
//
//  Routine Description:
//
//              Does a memory-to-screen with pattern blt
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3MemToScreenWithPatternBlt(
PDEV*   ppdev,
SURFOBJ* psoSrc,
POINTL* pptlSrc,
RECTL*  prclDst,
ULONG rop3,
RBRUSH_COLOR   *rbc,
RECTL*  prclClip
)


    {
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source
    LONG    cx;
    LONG    cy;     // Size of current rectangle - 1

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;

    ULONG width,height;
    ULONG xscan,yscan;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG ByteCount;
    ULONG SizeInWidth;
    ULONG BytesPerDstScan;
    ULONG DwordsPerDstScan;
    ULONG WordsPerDstScan;
    ULONG WordCount;
    WORD OnePixel;
    ULONG PixelData;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    ULONG *ScanPtr;
    ULONG *NextScan;
    LONG ScanInc;
    USHORT FreeCount;
    BYTE* SrcBits;
    DSURF* pdsurfSrc;
    ULONG   i;
    ULONG PixelDepth;
    ULONG AlphaEnableValue;

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**************************************************************************

    width = prclDst->right - prclDst->left;
    height = prclDst->bottom - prclDst->top;

    //**************************************************************************
    // Top left coordinate of source bitmap on source surface
    //**************************************************************************

    xsrc = pptlSrc->x;
    ysrc = pptlSrc->y;

    //**************************************************************************
    // Top left coordinate of destination on destination surface
    //**************************************************************************

    xdst = prclDst->left;
    ydst = prclDst->top;

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

    if((prclClip == NULL) && (ppdev->NVClipResetFlag))
    {
       while (FreeCount < 2*4)
          FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
       FreeCount -= 2*4;

       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
    }
    else if(prclClip != NULL)
    {

       while (FreeCount < 2*4)
          FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
       FreeCount -= 2*4;

       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((prclClip->top << 16) | prclClip->left );
       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((prclClip->bottom - prclClip->top) << 16) 
                    | (prclClip->right - prclClip->left) ); 

       ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
    }

    //**************************************************************************
    // Wait for FIFO, then set pattern registers
    //**************************************************************************

    while (FreeCount < 5*4)
       FreeCount = nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].control.Free;
    FreeCount -=5*4;

    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeShape = NV018_SET_MONOCHROME_SHAPE_64X_1Y ;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor0 = (ULONG)(rbc->iSolidColor | AlphaEnableValue);
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor1 = (ULONG)(rbc->iSolidColor | AlphaEnableValue);
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern0 = 0xffffffff;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern1 = 0xffffffff;

    //**************************************************************************
    // Wait for FIFO, then set IMAGE_FROM_CPU registers
    //**************************************************************************

    while (FreeCount < 4*4)
       FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
    FreeCount -=4*4;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = rop3 ;
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ((ydst) <<16) | ((xdst) & 0xffff) );
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (height <<16) | width );

    //**************************************************************************
    // Specifying 1 more pixel (example: in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    // SizeIn is specified in pixels.
    //**************************************************************************

    if (depth == 8)
        SizeInWidth = ((width + 3) & 0xfffc);       // We always send 4 pixels at a time
    else if (depth == 16)
        SizeInWidth = ((width + 1) & 0xfffe);       // We always send 2 pixels at a time
    else
        SizeInWidth = width;                        // We always send 1 pixel at a time

    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (height <<16) | (SizeInWidth) );

    //**************************************************************************
    // Calculate number of dwords to output per scanline
    // This is the actual amount of data that the NV engine expects per scanline.
    // SizeInWidth is guaranteed to be a multiple of 2 (for 16bpp) and
    // a multiple of 4 (for 8bpp).  So we'll always be outputting DWORDS.
    // (No leftover words or bytes, they get clipped)
    //**************************************************************************

    BytesPerDstScan = width * depth/8;
    DwordsPerDstScan = BytesPerDstScan / 4 + ((BytesPerDstScan % 4) ? 1 : 0);

    //**************************************************************************
    // Get ptr to start of SRC
    //**************************************************************************

    NextScan = (ULONG *)(&(SrcBits[(xsrc*depth/8) + (ysrc*BytesPerSrcScan)]));

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

    //**************************************************************************
    // Output one scan at a time
    //**************************************************************************

    for (yscan=0;yscan < height; yscan++)
        {
        ByteCount=BytesPerDstScan;

        ScanPtr = NextScan;

        //**********************************************************************
        // Output next group of 16 dwords
        //**********************************************************************

        while (ByteCount >= 16 * sizeof(ULONG))
            {
            ByteCount -= (16 * sizeof(ULONG));

            while (FreeCount < 16*4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=16*4;

            TempPixelData1 = ScanPtr[0];
            TempPixelData2 = ScanPtr[1];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
            TempPixelData1 = ScanPtr[2];
            TempPixelData2 = ScanPtr[3];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;
            TempPixelData1 = ScanPtr[4];
            TempPixelData2 = ScanPtr[5];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] =  TempPixelData2;
            TempPixelData1 = ScanPtr[6];
            TempPixelData2 = ScanPtr[7];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] =  TempPixelData2;
            TempPixelData1 = ScanPtr[8];
            TempPixelData2 = ScanPtr[9];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[8] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[9] =  TempPixelData2;
            TempPixelData1 = ScanPtr[10];
            TempPixelData2 = ScanPtr[11];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[10] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[11] =  TempPixelData2;
            TempPixelData1 = ScanPtr[12];
            TempPixelData2 = ScanPtr[13];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[12] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[13] =  TempPixelData2;
            TempPixelData1 = ScanPtr[14];
            TempPixelData2 = ScanPtr[15];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[14] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[15] =  TempPixelData2;

            ScanPtr +=16;           // Advance 16 dwords
            }

        //**********************************************************************
        // Output next group of 4 dwords
        //**********************************************************************

        while (ByteCount >= 4 * sizeof(ULONG))
            {
            ByteCount -= (4 * sizeof(ULONG));
            while (FreeCount < 4*4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=4*4;

            TempPixelData1 = ScanPtr[0];
            TempPixelData2 = ScanPtr[1];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
            TempPixelData1 = ScanPtr[2];
            TempPixelData2 = ScanPtr[3];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;

            ScanPtr +=4;            // Advance 4 dwords

            }

        //**********************************************************************
        // Output any remaining dwords
        //**********************************************************************

        while (ByteCount >= sizeof(ULONG) )
            {
            ByteCount -= sizeof(ULONG);

            while (FreeCount < 4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -= 4;

            TempPixelData1 = ScanPtr[0];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;

            ScanPtr ++;             // Advance 1 dword

            }
            //
            // Pad src scanline.
            //
            if (ByteCount)
            {
                TempPixelData1 = 0;
                for (i = 0; i < ByteCount; i++)
                {
                    TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

                while (FreeCount < 4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -= 4;

                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            }


        NextScan+=ScanInc;

        }

    //**************************************************************************
    // Notify the rest of the driver that we changed the pattern
    //**************************************************************************

    ppdev->NVPatternResetFlag=1;

    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;


    }



//******************************************************************************
//
//  Function:   NV3CopyBlit
//
//  Routine Description:
//
//      Does a screen-to-screen blt of a list of rectangles.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3CopyBlt(    // Type FNCOPY
    PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst,    // Original unclipped destination rectangle
BLENDOBJ*   pBlendObj)
    {
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source
    LONG    cx;
    LONG    cy;     // Size of current rectangle - 1

    Nv3ChannelPio  *nv  = (Nv3ChannelPio*) ppdev->pjMmBase;

    ULONG width,height;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    USHORT FreeCount;
    ULONG Rop3;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Initialize the cached free count
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    Rop3 = (rop4 & 0xff);

    //**************************************************************************
    // Do a copy blit for each clip rectangle
    //**************************************************************************

    do  {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        width = prcl->right - prcl->left;
        height = prcl->bottom - prcl->top;

        dx = prcl->left - prclDst->left;    // prcl is always within prcldst???
        dy = prcl->top  - prclDst->top;     // prcl is always within prcldst???

        xsrc = pptlSrc->x + dx;
        ysrc = pptlSrc->y + dy;

        xdst = prcl->left;
        ydst = prcl->top;

        //**********************************************************************
        // Wait for FIFO to be ready, then draw
        //**********************************************************************

        while (FreeCount < 4*4)
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
        FreeCount -= 4*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = Rop3 ;

        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (ysrc << 16) | (xsrc & 0xffff) );
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (ydst) << 16) | ((xdst) & 0xffff) );
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (height << 16) | width );

        prcl++;

        } while (--c != 0);

    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    }

#endif _WIN32_WINNT     // If is >= NT 4.x
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3lines.c ===
//******************************************************************************
//
// Module Name: NV3LINES.C
// 
// Contains most of the required GDI line support.  Supports drawing
// lines in short 'strips' when clipping is complex or coordinates
// are too large to be drawn by the line hardware.
// 
// Copyright (c) 1990-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#include "oldnv332.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// NV:   Currently, we'll be using the NV1 line functions for NV3 since
//       they're compatible.  We can add the NV3 specific versions later...
//******************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3hw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV3HW.C
//
// Abstract:
//
//     Implements NV3 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"

#ifdef NV3
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"

#include "nv3a_ref.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// Useful defines (taken from NV.H).  Need to cleanup NV.H so we can include
// it without compiler failing, but don't have time right now....
//******************************************************************************

#define DEVICE_BASE(d)          (0?d)


#define OFFSET_PGRAPH_BOFFSET0_REG      (NV_PGRAPH_BOFFSET0 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BOFFSET1_REG      (NV_PGRAPH_BOFFSET1 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BOFFSET3_REG      (NV_PGRAPH_BOFFSET3 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BPITCH0_REG       (NV_PGRAPH_BPITCH0 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BPITCH1_REG       (NV_PGRAPH_BPITCH1 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BPITCH3_REG       (NV_PGRAPH_BPITCH3 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_FIFO_REG          (NV_PGRAPH_FIFO - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_DEBUG_3_REG       (NV_PGRAPH_DEBUG_3 - DEVICE_BASE(NV_PGRAPH))


#define OFFSET_PRMCIO_INP0_COLOR_REG                0x3da

#define OFFSET_PRMCIO_CRX__COLOR_REG                0x3d4
#define OFFSET_PRMCIO_CR__COLOR_REG                 0x3d5

#define OFFSET_PRMVIO_SRX_REG                       0x3c4
#define OFFSET_PRMVIO_SR_LOCK_REG                   0x3c5
#define OFFSET_PRMVIO_MISC_READ_REG                 0x3cc
#define OFFSET_PRAMDAC_CU_START_POS_REG             0x0

#define NV_SR_UNLOCK_VALUE                          0x00000057
#define NV_SR_LOCK_VALUE                            0x00000099

//******************************************************************************
// Forward Declarations
//******************************************************************************

VOID NV3_ClearZ(PDEV *ppdev ,ULONG x,ULONG y,ULONG Width, ULONG Height, ULONG zvalue);
VOID NV3_ClearSurface(PDEV *ppdev ,ULONG x,ULONG y,ULONG Width, ULONG Height, ULONG color);
VOID NV3_BlitSurface(PDEV *ppdev ,RECTL *Src, RECTL *Dst);

VOID NV3_SetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_SetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_OGLSetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_OGLSetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_SetZBufferBase(PDEV*   ppdev, ULONG MemoryOffset, LONG Stride);

VOID NV3_SetDisplayBase(PDEV*   ppdev, ULONG MemoryOffset);

VOID NV3_SetClipRect(PDEV *ppdev, RECTL *pClip);
VOID NV3_SetDitherMode(PDEV *ppdev, BOOL enableDither);
VOID NV3_SynchronizeHW(PDEV*   ppdev);
VOID NV3_SwapDisplaySurface(PDEV *ppdev, ULONG displaybase, ULONG renderbase, BOOL waitforVSync);

VOID NV3_VerifyFunctions(PDEV*   ppdev);
VOID NV3_RestoreState(PDEV*   ppdev, ULONG ZBufferOffset);
VOID NV3_VerifyTriangleWithZBuffer(PDEV *ppdev,ULONG,ULONG);


//******************************Public*Routine**********************************
//
// Function: NV3_ClearZ
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_ClearZ(PDEV *ppdev ,ULONG x,ULONG y,ULONG Width, ULONG Height, ULONG zvalue)

    {
    ULONG SavedDestOffset;
    ULONG SavedDestPitch;
    Nv3ChannelPio *nv  = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Fill Z buffer with specified value
    //**************************************************************************

    while (FreeCount < 3*4)
       FreeCount = NvGetFreeCount(nv, CLEARZ_SUBCHANNEL);
    FreeCount -= 3*4;

    nv->subchannel[CLEARZ_SUBCHANNEL].nv1RenderSolidRectangle.Color = zvalue;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].point = ((y << 16) | (x & 0xffff));
    nv->subchannel[CLEARZ_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].size = ((Height << 16) | (Width & 0xffff) );

    ppdev->NVFreeCount = FreeCount;

    }




//******************************Public*Routine**********************************
//
// Function: NV3_ClearSurface
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_ClearSurface(PDEV *ppdev ,ULONG x,ULONG y,ULONG Width, ULONG Height, ULONG color)

    {
    ULONG Pitch;
    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Fill Z buffer with specified value
    //**************************************************************************

    while (FreeCount < 5*4)
       FreeCount = NvGetFreeCount(nv, RECTANGLE_SUBCHANNEL);
    FreeCount -= 5*4;

    //**************************************************************************
    // We'll need to temporarily replace the ROP solid object,
    // because OpenGL currently uses this subchannel to contain
    // the D3DTriangle object with textures in System Memory.
    //**************************************************************************

    nv->subchannel[ROP_SOLID_SUBCHANNEL].SetObject             = DD_ROP5_SOLID; //MY_ROP_SOLID;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = 0xcc ;
    nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Color = color;
    nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].point = ((y << 16) | (x & 0xffff));
    nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].size = ((Height << 16) | (Width & 0xffff) );

    //**************************************************************************
    // We need to restore the D3D Triangle (SYSMEM) object
    // because OpenGL expects this subchannel to contain
    // the D3DTriangle object with textures in System Memory.
    //**************************************************************************

    // nv->subchannel[D3DTRIANGLE_SYSMEM_SUBCHANNEL].SetObject     = MY_RENDER_D3D_TRIANGLE_SYSMEM;

    ppdev->NVFreeCount = FreeCount;

    }



//******************************Public*Routine**********************************
//
// Function: NV3_BlitSurface
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_BlitSurface(PDEV *ppdev ,RECTL *Src, RECTL *Dst)

    {
    ULONG   srcX,srcY;
    ULONG   dstX,dstY;
    ULONG   dstWidth,dstHeight;

    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Get source coordinates
    //**************************************************************************

    srcX = Src->left;
    srcY = Src->top;

    //**************************************************************************
    // Get destination coordinates
    //**************************************************************************

    dstX = Dst->left;
    dstY = Dst->top;

    //**************************************************************************
    // Get width and height
    //**************************************************************************

    dstWidth = Src->right - Src->left;
    dstHeight = Src->bottom - Src->top;

    //**************************************************************************
    // Wait for FIFO to be ready, then draw
    // We know that this is a straight SOLID FILL with no
    // pattern or source.  So just set ROP to SRCCOPY.
    //**************************************************************************

    while (FreeCount < 5*4)
       FreeCount = NvGetFreeCount(nv, BLIT_SUBCHANNEL);
    FreeCount -= 5*4;

    //**************************************************************************
    // We'll need to temporarily replace the ROP solid object,
    // because OpenGL currently uses this subchannel to contain
    // the D3DTriangle object with textures in System Memory.
    //**************************************************************************

    nv->subchannel[ROP_SOLID_SUBCHANNEL].SetObject             = DD_ROP5_SOLID; //MY_ROP_SOLID;


    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = NV_SRCCOPY ;

    nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (srcY << 16) | ((srcX) & 0xffff) );
    nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( (dstY << 16) | ((dstX) & 0xffff) );
    nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (dstHeight << 16) | ((dstWidth) & 0xffff) );

    //**************************************************************************
    // We need to restore the D3D Triangle (SYSMEM) object
    // because OpenGL expects this subchannel to contain
    // the D3DTriangle object with textures in System Memory.
    //**************************************************************************

    // nv->subchannel[D3DTRIANGLE_SYSMEM_SUBCHANNEL].SetObject     = MY_RENDER_D3D_TRIANGLE_SYSMEM;

    ppdev->NVFreeCount = FreeCount;
    }



//******************************************************************************
//
// Function: NV3_SetSourceBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_SetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    USHORT  FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Performance optimization, check if offset and pitch
    // are already up to date
    //**************************************************************************

    if ( (Offset == ppdev->CurrentSourceOffset)  &&  (Stride == (LONG)ppdev->CurrentSourcePitch))
        return;

    //**************************************************************************
    // Setup SRCIMAGE_IN_MEMORY object.
    //**************************************************************************
    while (FreeCount < 4*4)
        FreeCount = NvGetFreeCount(nv, SRCIMAGE_IN_MEMORY_SUBCHANNEL);
    FreeCount -= 4*4;


    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].SetObject =
         DD_SRC_IMAGE_IN_MEMORY;
    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].nv3ContextSurface1.SetImageOffset =
        Offset;
    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].nv3ContextSurface1.SetImagePitch =
        Stride;

    //**************************************************************************
    // Restore the original object in the subchannel
    //**************************************************************************
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].SetObject = DD_IMAGE_PATTERN;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentSourceOffset = Offset;
    ppdev->CurrentSourcePitch  = Stride;

    //**************************************************************************
    // NOTE: This function is currently used by the 2d display driver ONLY.
    //       So update the global free count for the DISPLAY driver
    //**************************************************************************
    ppdev->NVFreeCount = FreeCount;


    }


//******************************************************************************
//
// Function: NV3_SetDestBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_SetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Performance optimization, check if offset and pitch
    // are already up to date
    //**************************************************************************

    if ( (Offset == ppdev->CurrentDestOffset)  &&  (Stride == (LONG)ppdev->CurrentDestPitch))
        return;

    //**************************************************************************
    // Setup DSTIMAGE_IN_MEMORY object.
    //**************************************************************************
    while (FreeCount < 4*4)
        FreeCount = NvGetFreeCount(nv, DD_SPARE);
    FreeCount -= 4*4;

    if (ppdev->dDrawSpareSubchannelObject != DD_PRIMARY_IMAGE_IN_MEMORY)
        {
        nv->subchannel[DD_SPARE].SetObject = DD_PRIMARY_IMAGE_IN_MEMORY;
        ppdev->dDrawSpareSubchannelObject     = DD_PRIMARY_IMAGE_IN_MEMORY;
        }

    nv->subchannel[DD_SPARE].nv3ContextSurface0.SetImageOffset =
        Offset;
    nv->subchannel[DD_SPARE].nv3ContextSurface0.SetImagePitch =
        Stride;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentDestOffset = Offset;
    ppdev->CurrentDestPitch  = Stride;

    //**************************************************************************
    // NOTE: This function is currently used by the 2d display driver ONLY.
    //       So update the global free count for the DISPLAY driver
    //**************************************************************************
    ppdev->NVFreeCount = FreeCount;


    }



//******************************************************************************
//
// Function: NV3_OGLSetSourceBase()
//
// Routine Description:
//
//          This version of SetSourceBase requires the IMAGE_IN_MEMORY objects
//          to be present in the NV user channel.  This occurs whenever
//          OpenGL is initialized, which means that this function is NOT AVAILABLE
//          for the 2D Display driver to use (because all 8 subchannels stay
//          constant when the 2D Display driver is running)
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_OGLSetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    Nv3ChannelPio           *nv = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Set offset and stride
    //**************************************************************************

    while (FreeCount < 2*4)
       FreeCount = NvGetFreeCount(nv, SRCIMAGE_IN_MEMORY_SUBCHANNEL);
    FreeCount -= 2*4;

    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].nv3ContextSurface1.SetImagePitch = Stride;
    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].nv3ContextSurface1.SetImageOffset = Offset;

    ppdev->NVFreeCount = FreeCount;
    }


//******************************************************************************
//
// Function: NV3_OGLSetDestBase()
//
// Routine Description:
//
//          This version of SetDestBase requires the IMAGE_IN_MEMORY objects
//          to be present in the NV user channel.  This occurs whenever
//          OpenGL is initialized, which means that this function is NOT AVAILABLE
//          for the 2D Display driver to use (because all 8 subchannels stay
//          constant when the 2D Display driver is running)
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_OGLSetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio   *nv = (Nv3ChannelPio*) ppdev->pjMmBase;

    //**************************************************************************
    //Set offset and stride
    //**************************************************************************

    while (FreeCount < 2*4)
       FreeCount = NvGetFreeCount(nv, DD_SPARE);
    FreeCount -= 2*4;

    nv->subchannel[DD_SPARE].nv3ContextSurface0.SetImagePitch = Stride;
    nv->subchannel[DD_SPARE].nv3ContextSurface0.SetImageOffset = Offset;

    ppdev->NVFreeCount = FreeCount;
    }


//******************************************************************************
//
// Function: NV3_SetDisplayBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_SetDisplayBase(PDEV*   ppdev, ULONG Offset)

    {
    NV3_FlipBuffer(ppdev,Offset);

    //**************************************************************************
    // Save the updated offset
    //**************************************************************************

    ppdev->CurrentDisplayOffset = Offset;

    }


//******************************************************************************
//
// Function: NV3_SetZBufferBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_SetZBufferBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Setup ZETA_BUFFER_IN_MEMORY object.
    //**************************************************************************
    while (FreeCount < 7*4)
        FreeCount = NvGetFreeCount(nv, CLEARZ_SUBCHANNEL);
    FreeCount -= 7*4;

    nv->subchannel[CLEARZ_SUBCHANNEL].SetObject = DD_ZETA_BUFFER;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv3ContextSurface3.SetImagePitch = Stride;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv3ContextSurface3.SetImageOffset = Offset;

    nv->subchannel[CLEARZ_SUBCHANNEL].SetObject = DD_ZBUFFER_IMAGE_IN_MEMORY;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv3ContextSurface3.SetImagePitch = Stride;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv3ContextSurface3.SetImageOffset = Offset;
    nv->subchannel[CLEARZ_SUBCHANNEL].SetObject = MY_CLEARZ_RECTANGLE;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentZOffset = Offset;
    ppdev->CurrentZPitch  = Stride;
    ppdev->NVFreeCount = FreeCount;
    }




//******************************************************************************
//
//  Function:   NV3_SetClipRect
//
//  Routine Description:
//
//      Hardware-specific utility functions:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3_SetClipRect(PDEV *ppdev, RECTL *pClip)

    {
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;

    while (FreeCount < 2*4)
       FreeCount = NvGetFreeCount(nv, CLIP_SUBCHANNEL);
    FreeCount -= 2*4;

    nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = (( (pClip->top) << 16) | pClip->left );
    nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (( (pClip->bottom - pClip->top)<<16) | (pClip->right - pClip->left));

    ppdev->NVClipResetFlag=1;       // Notify rest of driver that next guy needs
                                    // to restore it
    ppdev->NVFreeCount = FreeCount;
    }


//******************************************************************************
//
//  Function:   NV3_SetDitherMode
//
//  Routine Description:
//
//      Hardware-specific utility functions:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3_SetDitherMode(PDEV *ppdev, BOOL enableDither)

    {
    volatile DWORD *PGRAPH_DEBUG_3_Reg;
    volatile DWORD *PGRAPH_STATUS_Reg;
    volatile DWORD *PGRAPH_FIFO_Reg;
    ULONG value;

    //**************************************************************************
    // 1st make sure the engine is not busy
    //**************************************************************************

    NV3_SynchronizeHW(ppdev);

//    //**************************************************************************
//    // 2nd make sure the FIFO is disabled
//    // NV_PGRAPH_FIFO_ACCESS_DISABLED --> Clear bit 0
//    //**************************************************************************
//
//    PGRAPH_FIFO_Reg = (volatile DWORD *)ppdev->PGRAPHRegs;
//    PGRAPH_FIFO_Reg += OFFSET_PGRAPH_FIFO_REG/4;
//    *PGRAPH_FIFO_Reg &= 0xfffffffe;

    //**************************************************************************
    // Set the dither state
    //**************************************************************************

    PGRAPH_DEBUG_3_Reg = (volatile DWORD *)ppdev->PGRAPHRegs;
    PGRAPH_DEBUG_3_Reg += OFFSET_PGRAPH_DEBUG_3_REG/4;

    //**************************************************************************
    // WARNING: Do NOT 'or' values directly with HARDWARE registers because
    //          the compiler will optimize and do 'Byte' or's, which will
    //          cause the hardware to hang !!  Instead, read the hardware register
    //          first (read a dword), then modify the value, then output
    //          as a dword.
    //**************************************************************************

    value = *PGRAPH_DEBUG_3_Reg;                // Get current DWORD value

    if (enableDither)
        value |= (DWORD)0x00008000;             // Set Bit 15 to enable dithering
    else
        value &= (DWORD)0xffff7fff;             // Clear bit 15 to disable dithering

    *PGRAPH_DEBUG_3_Reg = value;                // Output new value


    //**************************************************************************
    // Save the updated dither state
    //**************************************************************************

    ppdev->CurrentDitherState = enableDither;

//    //**************************************************************************
//    // Re-enable the FIFO
//    //**************************************************************************
//
//    *PGRAPH_FIFO_Reg |= 0x00000001;


    }


//******************************************************************************
//
//  Function:   NV3_SynchronizeHW
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


void NV3_SynchronizeHW(PDEV*   ppdev)

    {

    //**************************************************************************
    // Loop until the engine is not busy
    //**************************************************************************

    while (NV3_GraphicsEngineBusy(ppdev))
        ;
    }



//******************************************************************************
//
//  Function:   NV3_SwapDisplaySurface
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3_SwapDisplaySurface(PDEV *ppdev, ULONG NewDisplayOffset, ULONG NewRenderOffset, BOOL waitforVSync)

    {
    if (waitforVSync)
        NV3_WaitWhileDisplayActive(ppdev);

    //**************************************************************************
    // Swap render(destination) and display base
    //**************************************************************************

    NV3_SetDisplayBase(ppdev,NewDisplayOffset);
    NV3_SetDestBase(ppdev,NewRenderOffset,ppdev->lDelta);


    }


//******************************************************************************
//
//  Function:   NV3_VerifyFunctions
//
//  Routine Description:
//
//      This functions tests the functionality of the above functions
//      It assumes the display driver is currently running at 640x480 16bpp
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3_VerifyFunctions(PDEV*   ppdev)

    {
    RECTL SrcRect,DstRect,ClipRect;

    //**************************************************************************
    // !! SET DISPLAY MODE to 640x480 at 16bpp to view this test properly !!!
    //**************************************************************************

    //**************************************************************************
    // Source = 0
    // Destination = at 3Mb
    // pitch = 640 at 16bpp
    //**************************************************************************

    NV3_SetDisplayBase(ppdev,0x300000);
    NV3_SetSourceBase(ppdev,0,640*2 );
    NV3_SetDestBase(ppdev,0x300000,640*2);

    ClipRect.left=0;                            // Restore clip rect to full screen
    ClipRect.top=0;
    ClipRect.right=ppdev->cxMemory;
    ClipRect.bottom=ppdev->cyMemory;
    NV3_SetClipRect(ppdev,&ClipRect);

    //**************************************************************************
    // Verify clear surface works (Currently only 15 bit, 16th bit is don't care)
    //**************************************************************************

    NV3_ClearSurface(ppdev,0,0,640,480,0xffff);
    NV3_ClearSurface(ppdev,0,0,320,240,0x7c00);     // red
    NV3_ClearSurface(ppdev,0,240,320,480,0x03e0);   // green
    NV3_ClearSurface(ppdev,320,0,640,240,0x001f);   // blue
    NV3_ClearSurface(ppdev,320,240,640,480,0x0000); // black

    //**************************************************************************
    // Specify blit from buffer 0 (top left quadrant) to buffer 1 (bottom right)
    //**************************************************************************

    SrcRect.left=0;
    SrcRect.top=0;
    SrcRect.right=320;
    SrcRect.bottom=240;

    DstRect.left=320;
    DstRect.top=240;
    DstRect.right=640;
    DstRect.bottom=480;

    //**************************************************************************
    // Verify source and destination offsets were set correctly
    // Blit top left quadrant of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Verifies a different source offset for blit (same pitch)
    // Blit bottom left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,640*2*240,640*2);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

//    //**************************************************************************
//    // Verify FIFO versions of SetSourceBase and SetDestBase
//    // These are ONLY available if OpenGL is running
//    //**************************************************************************
//
//    NV3_OGLSetSourceBase(ppdev,0, 640*2);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetSourceBase(ppdev,20, 640*2);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetSourceBase(ppdev,20, 640);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetSourceBase(ppdev,0, 640*2);
//    NV3_OGLSetDestBase(ppdev,0x300000, 640*2);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetDestBase(ppdev,0x300010, 640*2);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetDestBase(ppdev,0x300000, 640);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetDestBase(ppdev,0x300000, 640*2);

    //**************************************************************************
    // Restore Source Offset to point to windows desktop
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that we can change the source pitch (Specify it twice as long
    // so that the destination blit should be 'scrunched')
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2 * 2);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that we can change the source pitch (Specify it half as long
    // so that the destination blit should show an 'interleaved' image)
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that we can change the destination pitch (Specify it half as long
    // so that the destination blit should be 'scrunched')
    // Blit top left of windows desktop to bottom right of buffer 1
    // NOTE: Since we decreased the pitch by half, the blit will occur higher
    //       up in the visible screen, instead of where it would appear
    //       if the pitch had not changed.
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that we can blit from a source to a destination pitch and back
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640);

    DstRect.left=0;
    DstRect.top=0;
    DstRect.right=320;
    DstRect.bottom=240;

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);

    NV3_SetSourceBase(ppdev,0x300000, 640);
    NV3_SetDestBase(ppdev,0x300000, 640*2);

    DstRect.left=320;
    DstRect.top=240;
    DstRect.right=640;
    DstRect.bottom=480;

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);

    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check an unusual pitch value . (Specify default_pitch + 16 bytes)
    // The destination blit should be 'skewed'
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640*2 + 16);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that clipping rectangle is working
    // Blit clipped portion of desktop to buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640*2);

    ClipRect.left=100;
    ClipRect.top=50;
    ClipRect.right=640-100;
    ClipRect.bottom=480-50;
    NV3_SetClipRect(ppdev,&ClipRect);

    SrcRect.left=0;
    SrcRect.top=0;
    SrcRect.right=640;
    SrcRect.bottom=480;

    DstRect.left=0;
    DstRect.top=0;
    DstRect.right=640;
    DstRect.bottom=480;

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that clipping rectangle is affected by the destination offset and pitch
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640*2);

    ClipRect.left=320;                          // Blit entire quadrant
    ClipRect.top=240;
    ClipRect.right=640;
    ClipRect.bottom=480;
    NV3_SetClipRect(ppdev,&ClipRect);

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    ClipRect.left=320;                          // Only top left of quadrant should appear
    ClipRect.top=240;
    ClipRect.right=320 + 160;
    ClipRect.bottom=240 + 120;
    NV3_SetClipRect(ppdev,&ClipRect);

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    NV3_SetDestBase(ppdev,0x300000, 640);       // Change the destination pitch

    ClipRect.left=320;
    ClipRect.top=240;
    ClipRect.right=320+160;
    ClipRect.bottom=240+120;
    NV3_SetClipRect(ppdev,&ClipRect);


    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);


//    //**************************************************************************
//    // Verify Z Buffer functions (using the D3D Triangle)
//    // (Z buffer should appear halfway down the screen (y=240)
//    //**************************************************************************
//
//    NV3_SetSourceBase(ppdev,0, 640*2);
//    NV3_SetDestBase(ppdev,0x300000, 640*2);
//    NV3_SetZBufferBase(ppdev,0x300000 + 640*2 *240, 640*2);
//
//    ClipRect.left=50;                           // Test specific clipping rectangle
//    ClipRect.top=50;
//    ClipRect.right=200;
//    ClipRect.bottom=200;
//    NV3_SetClipRect(ppdev,&ClipRect);
//
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    ClipRect.left=0;                            // Restore clip rect to full screen
//    ClipRect.top=0;
//    ClipRect.right=640;
//    ClipRect.bottom=480;
//    NV3_SetClipRect(ppdev,&ClipRect);
//
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify dithering
//    //**************************************************************************
//
//    NV3_SetDitherMode(ppdev,FALSE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,TRUE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,FALSE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,TRUE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify Clear Z function
//    //**************************************************************************
//
//    NV3_ClearZ(ppdev,0,0,320,10, 0);            // Just clear a portion of Z buffer
//    NV3_ClearZ(ppdev,0,0,320,10,0xffff );       // Just clear a portion of Z buffer
//    NV3_ClearZ(ppdev,320,0,320,10,0x0000 );     // Just clear a portion of Z buffer
//    NV3_ClearZ(ppdev,320,0,320,10,0xffff );     // Just clear a portion of Z buffer
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify dithering
//    //**************************************************************************
//
//    NV3_SetDitherMode(ppdev,FALSE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,TRUE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify Swap buffer function
//    // 1st setup display to be front buffer at offset = 0, and
//    // destination to be 'back' buffer at offset = 0x100000
//    //**************************************************************************
//
//    NV3_SwapDisplaySurface(ppdev,0x00000000,0x00300000, FALSE);
//    NV3_SwapDisplaySurface(ppdev,0x00300000,0x00000000, TRUE);
//
//    //**************************************************************************
//    // Verify Synchronize function
//    //**************************************************************************
//
//    NV3_SynchronizeHW(ppdev);
//
//    //**************************************************************************
//    // Verify dithering
//    //**************************************************************************
//
//    NV3_SetDestBase(ppdev,0x300000, 640*2);
//
//    NV3_SetDitherMode(ppdev,FALSE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,TRUE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify D3D triangle Zeta values are stored according to the specified destination
//    //**************************************************************************
//
//    ClipRect.left=0;                            // Restore clip rect to full screen
//    ClipRect.top=0;
//    ClipRect.right=ppdev->cxMemory;
//    ClipRect.bottom=ppdev->cyMemory;
//    NV3_SetClipRect(ppdev,&ClipRect);
//
//    NV3_SetDisplayBase(ppdev,0x300000);
//    NV3_SetSourceBase(ppdev,0,640*2 );
//    NV3_SetDestBase(ppdev,0x300000,640*2);
//    NV3_SetZBufferBase(ppdev,0x300000 + 640*2 *240, 640*2);
//
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_SetZBufferBase(ppdev,0x300000 + 640*2 *240, 640);
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
    //**************************************************************************
    // Restore 640x480 16bpp display screen
    //**************************************************************************

    NV3_SetDisplayBase(ppdev,0x0);
    NV3_SetSourceBase(ppdev,0,640*2);
    NV3_SetDestBase(ppdev,0,640*2);

    ClipRect.left=0;                            // Restore clip rect to full screen
    ClipRect.top=0;
    ClipRect.right=ppdev->cxMemory;
    ClipRect.bottom=ppdev->cyMemory;
    NV3_SetClipRect(ppdev,&ClipRect);


    }





//******************************************************************************
//
//  Function:   NV3_RestoreState
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3_RestoreState(PDEV*   ppdev, ULONG ZBufferOffset)

    {
    RECTL ClipRect;

    //**************************************************************************
    // Restore display , source, destination, and Z Buffer bases
    //**************************************************************************

    NV3_SetDisplayBase(ppdev,0);
    NV3_SetSourceBase(ppdev,0,640*2);
    NV3_SetDestBase(ppdev,0,640*2);
    NV3_SetZBufferBase(ppdev, ZBufferOffset, 640*2);

    ClipRect.left=0;                            // Restore clip rect to full screen
    ClipRect.top=0;
    ClipRect.right=ppdev->cxMemory;
    ClipRect.bottom=ppdev->cyMemory;
    NV3_SetClipRect(ppdev,&ClipRect);

    }




//******************************************************************************
//
//  Function:   NV3_VerifyTriangleWithZBuffer
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3_VerifyTriangleWithZBuffer(PDEV *ppdev, ULONG TextureOffset, ULONG D3DSubChannel)

    {
    ULONG TextureFormat;
    ULONG ControlOut;
    ULONG red,green,blue,alpha;
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio *nv = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Specify texture offset
    //**************************************************************************

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;


    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.TextureOffset = TextureOffset;

    //**************************************************************************
    // Texture format
    //      Color Mask                              Specify 0 for now
    //      Color Key Enable/Disable                Specify DISABLED for now
    //      Actual color format                     Specify X1R5G5B5 for now
    //      Min size of mip map levels (bits   .    Select 4x4 for now
    //      Max size of mip map levels (bits   .    Select 4x4 for now
    //**************************************************************************

    TextureFormat = NV_D3D0_TEXTURE_FORMAT_COLOR_KEY_DISABLED    |
                    NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5 |
                    NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_4X4          |
                    NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_4X4          ;

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.TextureFormat = TextureFormat;

    //**************************************************************************
    // Specify FILTER consists of several components OR'ed together:
    //
    //      Filter_Spread_X
    //      Filter_Spread_Y
    //      Filter_MipMap
    //      Filter_Turbo
    //
    //**************************************************************************

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.TextureFilter = 0x00000000;

    //**************************************************************************
    // Specify FOG COLOR, in X8R8G8B8 format
    //**************************************************************************

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.FogColor = 0x00000000;

    //**************************************************************************
    // Specify CONTROL OUT OPTIONS
    //
    // See NV3 reference for description of this register.
    //
    //  INTERPOLATOR    (filter from discrete image to continuous image)
    //  WRAP_U          (cylindrical, wrap, mirror, clamp)
    //  WRAP_V          (cylindrical, wrap, mirror, clamp)
    //  COLOR_FORMAT    (X8R8G8B8 or A8R8G8B8)
    //  CULLING         (None, Clockwise, Counterclockwise);
    //  ZBUFFER         (SCREEN using controlpoint[].z values, or LINEAR using 1/m
    //  ZETA_COMPARE    (conditional types = LT,EQ,LE,GT,NE,GE,TRUE)
    //  ZETA_WRITE      (NEVER,ALPHA,ZETA,ALPHA_ZETA, ALWAYS)
    //  COLOR_WRITE     (NEVER,ALPHA,ALPHA_ZETA)
    //  ROP             (BLEND_AND or ADD_WITH_SATURATION)
    //
    //**************************************************************************

    //**************************************************************************
    // Send the ControlOut value to hardware
    //**************************************************************************

    ControlOut                  = NV_D3D0_CONTROL0_INTERPOLATOR_ZOH         ;
    ControlOut                 |= NV_D3D0_CONTROL0_WRAP_U_WRAP              ;
    ControlOut                 |= NV_D3D0_CONTROL0_WRAP_V_WRAP              ;
    ControlOut                 |= NV_D3D0_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8 ;
    ControlOut                 |= NV_D3D0_CONTROL0_CULLING_NONE             ;
    ControlOut                 |= NV_D3D0_CONTROL0_ZETA_BUFFER_SCREEN       ;
    ControlOut                 |= NV_D3D0_CONTROL0_ZETA_COMPARE_TRUE        ;
    ControlOut                 |= NV_D3D0_CONTROL0_ZETA_WRITE_ALPHA_ZETA    ;
    ControlOut                 |= NV_D3D0_CONTROL0_COLOR_WRITE_ALPHA_ZETA   ;
    ControlOut                 |= NV_D3D0_CONTROL0_ROP_BLEND_AND            ;

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Control0 = ControlOut;

    //**************************************************************************
    // Vertex 1
    //**************************************************************************

    red     = 0xff;
    green   = 0x00;
    blue    = 0x00;
    alpha   = 0xff;

    alpha   <<=24;
    red     <<=16;
    green   <<=8 ;
    blue    <<=0 ;

    while (FreeCount < 8*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 8*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].specular = 0x00000000;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].color    = (alpha | red | green | blue);
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].sx       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].sy       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].sz       = (float)0.9999;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].rhw      = (float)0.1127;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].tu       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].tv       = (float)0.0;


    //**************************************************************************
    // Vertex 2
    //**************************************************************************

    red     = 0x00;
    green   = 0xff;
    blue    = 0x00;
    alpha   = 0xff;

    alpha   <<=24;
    red     <<=16;
    green   <<=8 ;
    blue    <<=0 ;

    while (FreeCount < 8*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 8*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].specular = 0x00000001;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].color    = (alpha | red | green | blue);
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].sx       = (float)320.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].sy       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].sz       = (float)0.9999;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].rhw      = (float)0.1127;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].tu       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].tv       = (float)0.0;


    //**************************************************************************
    // Vertex 3
    //**************************************************************************

    red     = 0x00;
    green   = 0x00;
    blue    = 0xff;
    alpha   = 0xff;

    alpha   <<=24;
    red     <<=16;
    green   <<=8 ;
    blue    <<=0 ;

    while (FreeCount < 8*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 8*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].specular = 0x00000102;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].color    = (alpha | red | green | blue);
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].sx       = (float)320.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].sy       = (float)240.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].sz       = (float)0.9999;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].rhw      = (float)0.1127;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].tu       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].tv       = (float)0.0;

    ppdev->NVFreeCount = FreeCount;

    }
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3ddrw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV3DDRW.C
//
// Abstract:
//
//     Implements all NV3 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#ifdef NV3

#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"
#include "nv3a_ref.h"

#include "nvsubch.h"
#include "nvalpha.h"
#include "nvapi.h"

#undef DEBUG_MSG_CHANNEL_WAIT

//******************************************************************************
// Forward Declarations
//******************************************************************************
VOID NV3_FlipBuffer(PDEV *, ULONG);

#define OFFSET_NV_PFIFO_BASE                        (0x2000)
#define OFFSET_NV_PFIFO_CACHE1_PUSH0_REG            (0x3200-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA0_REG             (0x3220-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_INTR_0                      (0x2100-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHES                      (0x2500-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PULL0                (0x3240-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PUSH1                (0x3204-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_STATUS               (0x3214-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CONFIG_0                    (0x2200-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PT_BASE      (0x3238-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_TAG          (0x3230-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PTE          (0x3234-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA3                 (0x322C-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_STATUS           (0x3218-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA1                 (0x3224-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA2                 (0x3228-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA0                 (0x3220-OFFSET_NV_PFIFO_BASE)

#define OFFSET_PRMCIO_INP0_COLOR_REG                0x3da

#define OFFSET_PRMCIO_CRX__COLOR_REG                0x3d4
#define OFFSET_PRMCIO_CR__COLOR_REG                 0x3d5

#define OFFSET_PRMVIO_SRX_REG                       0x3c4
#define OFFSET_PRMVIO_SR_LOCK_REG                   0x3c5
#define OFFSET_PRMVIO_MISC_READ_REG                 0x3cc
#define OFFSET_PRAMDAC_CU_START_POS_REG             0x0

#define NV_SR_UNLOCK_VALUE                          0x00000057
#define NV_SR_LOCK_VALUE                            0x00000099

//******************************************************************************
// Forward Declarations
//******************************************************************************

ULONG NV3_VBlankIsActive(PDEV *);
ULONG NV3_DisplayIsActive(PDEV *);
ULONG NV3_GraphicsEngineBusy(PDEV *);
VOID NV3_WaitWhileVBlankActive(PDEV * );
VOID NV3_WaitWhileDisplayActive(PDEV * );
VOID NV3_SetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_WaitForFifoAndEngineIdle(PDEV* ppdev);


//******************************************************************************
//
// Function: NV3_VBlankIsActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV3_VBlankIsActive(PDEV*   ppdev)

    {
    return (!(ppdev->pfnGetScanline(ppdev)));
    }


//******************************************************************************
//
// Function: NV3_DisplayIsActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV3_DisplayIsActive(PDEV*   ppdev)

    {
    return (ppdev->pfnGetScanline(ppdev));
    }


//******************************************************************************
//
// Function: NV3_WaitForFifoAndEngineIdle()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitForFifoAndEngineIdle(PDEV* ppdev)

    {
    volatile ULONG *Intr0Reg;
    volatile ULONG *CachesReg;
    volatile ULONG *Cache1Pull0Reg;
    ULONG cache1Pull0Value, cachesValue, intr;
    volatile ULONG *GrStatusReg;
    volatile ULONG *Cache1Dma0Reg;
    volatile ULONG *Cache1StatusReg;

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "NV3_WaitForFifoAndEngineIdle: Entry"));
#endif
    //**************************************************************************
    // Wait for pending interrupts to be completed...
    //**************************************************************************
    Intr0Reg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_INTR_0);
    intr = READ_REGISTER_ULONG(Intr0Reg) & 0x10111;
    while (intr)
    {
        // just look at cache_error, runout_pending, overflow_pending, and DMA PTE pending
        intr = READ_REGISTER_ULONG(Intr0Reg) & 0x10111;
    }

    //**************************************************************************
    // Wait for the FIFO to be enabled by potential RM operations...
    //**************************************************************************
    CachesReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHES);
    cachesValue = READ_REGISTER_ULONG(CachesReg);
    while ((cachesValue & 0x1) == 0)
        {
        cachesValue = READ_REGISTER_ULONG(CachesReg);
        }

    Cache1Pull0Reg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PULL0);
    cache1Pull0Value = READ_REGISTER_ULONG(Cache1Pull0Reg);
    while ((cache1Pull0Value & 0x1) == 0)
        {
        cache1Pull0Value = READ_REGISTER_ULONG(Cache1Pull0Reg);
        }

    //**************************************************************************
    // Wait for DMA pusher to be complete...
    //**************************************************************************
    Cache1Dma0Reg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA0_REG);
    while (READ_REGISTER_ULONG(Cache1Dma0Reg) > 0); // wait for idle status

    //**************************************************************************
    // Make sure that the FIFO is really empty.
    //**************************************************************************
    Cache1StatusReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_STATUS);
    while ((READ_REGISTER_ULONG(Cache1StatusReg) & 0x10) != 0x10);

    //**************************************************************************
    // Wait for the graphics engine to complete the last command
    //**************************************************************************
    GrStatusReg = ppdev->GrStatusReg;
    while (READ_REGISTER_ULONG(GrStatusReg) & (NV_PGRAPH_STATUS_STATE_BUSY | 0x80000000));

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "NV3_WaitForFifoAndEngineIdle: Exit"));
#endif
    }

//******************************************************************************
//
// Function: NV3_WaitForChannelSwitch()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitForChannelSwitch(PDEV*   ppdev)

    {
    Nv3ChannelPio  *nv  = (Nv3ChannelPio*) ppdev->pjMmBase;
    USHORT         FreeCount;
    NvNotification *pSyncNotifier = (NvNotification *)ppdev->Notifiers->Sync;

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "WaitForChannelSwitch: Entry"));
#endif

    if (!nv) return;

    NV3_WaitForFifoAndEngineIdle(ppdev);

    //**************************************************************************
    // Here, we make sure the Resource Manager has completed the switch from
    // Channel 1 (DMA Pusher/OpenGL) to Channel 0 (PIO)
    //**************************************************************************

    //**************************************************************************
    // Send dummy methods down the FIFO
    // If Channel 1 was previously active (OpenGL/ICD), writing this
    // method will generate a channel exception in the resource manager,
    // causing it to switch to channel 0.
    //**************************************************************************

    if (nv)
        {
#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "WaitForChannelSwitch: Punch PIO channel"));
#endif

        FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free ;
        while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free ;

        //***********************************************************************
        // Ensure graphics engine has completed all processing by waiting for
        // method notification.
        //***********************************************************************
        pSyncNotifier->status = NV_IN_PROGRESS;
        nv->subchannel[DD_ROP_RECT_AND_TEXT].nvRenderGdi0RectangleAndText.SetNotify = 0;
        nv->subchannel[DD_ROP_RECT_AND_TEXT].nvRenderGdi0RectangleAndText.Color1A = 0;
        while ((volatile)pSyncNotifier->status == NV_IN_PROGRESS); // wait for notification
        ppdev->NVFreeCount = NvGetFreeCount(nv, DD_ROP_RECT_AND_TEXT);

#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "WaitForChannelSwitch: Punch PIO channel complete"));
#endif

        }

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "WaitForChannelSwitch: Exit"));
#endif
    }



//******************************************************************************
//
// Function: NV3_GraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV3_GraphicsEngineBusy(PDEV*   ppdev)

    {
    Nv3ChannelPio *nv  = (Nv3ChannelPio*) ppdev->pjMmBase;
    USHORT FreeCount;
    BOOL   bReleaseOpenGLSemaphore = FALSE;

    if (!nv) return(FALSE);

    //**************************************************************************
    // If OpenGL is enabled, then wait for access to PIO FIFO and Semaphore lock
    // out any other processes.
    //**************************************************************************

    if (OglIsEnabled(ppdev))
        {
        ppdev->pfnAcquireOglMutex(ppdev);
        bReleaseOpenGLSemaphore = TRUE;

        ppdev->NVFreeCount = 0;

        //**********************************************************************
        // We need to make absolutely sure that the Channel switch
        // from the DMA pusher to the PIO channel has been completed
        //**********************************************************************

        ppdev->pfnWaitForChannelSwitch(ppdev);
        }

    //**************************************************************************
    // Init the cached free count
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Here, we use a notifier to make sure the engine is no longer busy.
    // We'll just send a NO-OP (using the RECT_AND_TEXT object) and
    // wait for the notifier to complete.
    //**************************************************************************

    while (FreeCount < 2*4)
         FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
    FreeCount -= 2*4;

    ((NvNotification *) (ppdev->Notifiers->Sync))->status = NV_STATUS_IN_PROGRESS;

    //**************************************************************************
    // Send the NO-OP on thru
    //**************************************************************************

    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetNotify = 0;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.Color1A = 0;

    //**************************************************************************
    // Wait for completion...
    //**************************************************************************
    while ((volatile)((NvNotification *) ppdev->Notifiers->Sync)->status == NV_IN_PROGRESS); // wait for notification

    //**************************************************************************
    // Make sure to update the free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    if (bReleaseOpenGLSemaphore == TRUE)
        {
        ppdev->pfnReleaseOglMutex(ppdev);

        bReleaseOpenGLSemaphore = FALSE;
        }

    return(FALSE);
    }


//******************************************************************************
//
// Function: NV3_WaitWhileVBlankActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitWhileVBlankActive(PDEV*   ppdev)

    {
    while (NV3_VBlankIsActive(ppdev))
        ;
    }

//******************************************************************************
//
// Function: NV3_WaitWhileDisplayActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitWhileDisplayActive(PDEV*   ppdev)

    {
    while (NV3_DisplayIsActive(ppdev))
        ;
    }


//******************************************************************************
//
// Function: NV3_WaitWhileGraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitWhileGraphicsEngineBusy(PDEV*   ppdev)

    {
    while (NV3_GraphicsEngineBusy(ppdev))
        ;
    }

//******************************************************************************
//
// Function: NV3_FlipBuffer()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_FlipBuffer(PDEV*   ppdev, ULONG MemoryOffset)

    {
    volatile UCHAR *PRMCIO_CRX_COLOR_Reg;
    volatile UCHAR *PRMCIO_CR_COLOR_Reg;
    volatile UCHAR *PRMVIO_SRX_Reg;
    volatile UCHAR *PRMVIO_SR_LOCK_Reg;
    volatile UCHAR *PRMVIO_MISC_READ_Reg;
    UCHAR i;
    UCHAR lock;

    //**************************************************************************
    // Get pointers to CRTC registers
    //
    //  ???? Should be BYTE writes or DWORDS writes ????
    //  ???? Should be BYTE? but CRTC_WR macro outputs in DWORDS???
    //
    //  #define CRTC_WR(i,d)    {PRMCIO_REG_WR32(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
    //                        PRMCIO_REG_WR32(PRMCIO_Base,NV_PRMCIO_CR__COLOR, (d));}
    //  #define CRTC_RD(i,d)    {PRMCIO_REG_WR32(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
    //                        (d) = PRMCIO_REG_RD32(PRMCIO_Base,NV_PRMCIO_CR__COLOR);}
    //**************************************************************************

    PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
    PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

    PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
    PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

    //**************************************************************************
    // Init access to extended registers
    //**************************************************************************

    PRMVIO_SRX_Reg = (volatile UCHAR *)ppdev->PRMVIORegs;
    PRMVIO_SRX_Reg += OFFSET_PRMVIO_SRX_REG;

    PRMVIO_SR_LOCK_Reg = (volatile UCHAR *)ppdev->PRMVIORegs;
    PRMVIO_SR_LOCK_Reg += OFFSET_PRMVIO_SR_LOCK_REG;

    PRMVIO_MISC_READ_Reg = (volatile UCHAR *)ppdev->PRMVIORegs;
    PRMVIO_MISC_READ_Reg += OFFSET_PRMVIO_MISC_READ_REG;

    //**************************************************************************
    // Set new frame buffer address (21-bit address)
    //
    //      NV_CIO_CR_SA_HI_INDEX
    //
    //          Bits [7:0]  -> Bits [15:8] of 21-bit display buffer address
    //
    //      NV_CIO_CR_SA_LO_INDEX
    //
    //          Bits [7:0]  -> Bits [7:0] of 21-bit display buffer address
    //
    //      NV_CIO_CRE_RPC0_INDEX
    //
    //          Bits[4:0]   -> Bits [20:16] of 21-bit display buffer address
    //          Bits[7:5]   -> Bits [10:8] of the CRTC offset register
    //
    // ?? Why bother with 0x3f ??
    //**************************************************************************

    //**************************************************************************
    // Need to shift down memory offset by 2 to account for granularity
    //**************************************************************************

    MemoryOffset>>=2;

    *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CR_SA_LO_INDEX & 0x3f);
    *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)(MemoryOffset & 0xff);

    *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CR_SA_HI_INDEX & 0x3f);
    *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)((MemoryOffset >> 8) & 0xff);

    //**************************************************************************
    // Unlock CRTC extended regs
    //
    // NV_PRMVIO_SRX            = Sequencer Index Register (3c4)
    // NV_PRMVIO_SR_LOCK        = Data is written/ readm from register (3c5)
    // NV_PRMVIO_SR_LOCK_INDEX  = This indexed register (5) locks/unlocks
    //                            all extended registers.  When written with
    //                            value of 57, all extended registers are UNLOCKED.
    //                            Otherwise, all extended registers are LOCKED.
    //
    //                            When value = 0, extended register are in a locked state
    //                            When value = 1, extended registers are in an unlocked state
    //
    //**************************************************************************

    *PRMVIO_SRX_Reg = NV_PRMVIO_SR_LOCK_INDEX;
    lock = *PRMVIO_SR_LOCK_Reg;
    *PRMVIO_SR_LOCK_Reg = NV_SR_UNLOCK_VALUE;

    //**************************************************************************
    // Fix high address bit in extended CRTC reg
    //
    //      NV_CIO_CRE_RPC0_INDEX
    //
    //          Bits[4:0]   -> Bits [20:16] of 21-bit display buffer address
    //
    //          We preserve bits [7:5]   (i & 0xe0) and
    //          just modify the botom 5 bits (0x1f)
    //
    //**************************************************************************

    *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_RPC0_INDEX & 0x3f);
    i = *PRMCIO_CR_COLOR_Reg;       // Get current value

    *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_RPC0_INDEX & 0x3f);
    *PRMCIO_CR_COLOR_Reg = (i & 0xe0) | (volatile UCHAR)((MemoryOffset >> 16) & 0x1f) ;

    //**************************************************************************
    // Lockup CRTC extended regs
    //**************************************************************************

    *PRMVIO_SRX_Reg = NV_PRMVIO_SR_LOCK_INDEX;
    if (lock == 0)
        *PRMVIO_SR_LOCK_Reg = NV_SR_LOCK_VALUE;

    }

//******************************************************************************
//
// Function: NV3_DmaPushGo()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     chID - Pointer to channel ID for resource manager
//     tlbPtBase - Base of context DMA
//     busAddressSpace - PCI, AGP or other memory base for context DMA
//     getOffset - Offset from start of context DMA where push data starts
//     putOffset - Offset from start of context DMA where push data ends
//
// Return Value:
//
//     TRUE means it kicked off FALSE means it did not.
//
//******************************************************************************

#if 0
#undef WRITE_REGISTER_ULONG
#define WRITE_REGISTER_ULONG NV3_WRITE_REGISTER_ULONG
NV3_WRITE_REGISTER_ULONG(ULONG *addr, ULONG val)
{
ULONG tmp;
tmp = *addr;
*addr = val;
tmp = *addr;
_asm lock or tmp,0x5f5f5f5f
}
#endif


ULONG NV3_DmaPushGo(PDEV* ppdev, ULONG chID, ULONG tlbPtBase, ULONG busAddressSpace, ULONG getOffset, ULONG putOffset, ULONG hClient, ULONG hDevice)

    {
    volatile ULONG *CachesReg;
    volatile ULONG *Cache1Pull0Reg;
    volatile ULONG *Cache1Dma0Reg;
    volatile ULONG *Cache1Push0Reg;
    volatile ULONG *Cache1Push1Reg;
    volatile ULONG *Config0Reg;
    volatile ULONG *cache1DmaTlbPtBaseReg;
    volatile ULONG *cache1DmaTlbTagReg;
    volatile ULONG *cache1DmaTlbPteReg;
    volatile ULONG *cache1Dma3Reg;
    volatile ULONG *cache1Dma2Reg;
    volatile ULONG *cache1Dma1Reg;
    volatile ULONG *cache1Dma0Reg;
    volatile ULONG *cache1DmaStatusReg;
    ULONG status, numDmaBytes;
    extern  ULONG RmFifoFlushContext(PDEV *ppdev, ULONG chID, ULONG hDevice, ULONG hClient);

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "DmaPushGo: Entry"));
#endif

    if (!ppdev)
    {
#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "DmaPushGo: NULL pdev Exit"));
#endif
        return (ULONG)FALSE;
    }

    if (!(ppdev->pjMmBase))
    {
#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "DmaPushGo: NULL pdev->pjMmBase Exit"));
#endif
        return (ULONG)FALSE;
    }

    if (ppdev->bEnabled == FALSE)
    {
#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "DmaPushGo: pdev NOT ENABLED Exit"));
#endif
        return (ULONG)FALSE;
    }

    numDmaBytes = (long)putOffset - (long)getOffset;
    if (numDmaBytes > 0)
        {
        ppdev->pfnAcquireOglMutex(ppdev);

        NV3_WaitForFifoAndEngineIdle(ppdev);

        CachesReg           = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHES);
        Cache1Pull0Reg      = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PULL0);
        Cache1Dma0Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA0_REG);
        Cache1Push0Reg      = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PUSH0_REG);
        Config0Reg          = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CONFIG_0);
        Cache1Push1Reg      = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PUSH1);
        cache1DmaTlbTagReg  = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_TLB_TAG);
        cache1DmaTlbPteReg  = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PTE);
        cache1DmaStatusReg  = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_STATUS);
        cache1Dma3Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA3);
        cache1Dma2Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA2);
        cache1Dma1Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA1);
        cache1Dma0Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA0);

        WRITE_REGISTER_ULONG(CachesReg, 0);
        WRITE_REGISTER_ULONG(Cache1Pull0Reg, 0);
        WRITE_REGISTER_ULONG(Cache1Push0Reg, 0);
        WRITE_REGISTER_ULONG(Cache1Dma0Reg, 0);

        if (READ_REGISTER_ULONG(Cache1Push1Reg) != chID)
            {
            status = RmFifoFlushContext(ppdev, chID, hClient, hDevice);
            if (status)
                {
                WRITE_REGISTER_ULONG(Cache1Pull0Reg, 1);
                WRITE_REGISTER_ULONG(Cache1Push0Reg, 1);
                WRITE_REGISTER_ULONG(CachesReg, 1);

                ppdev->pfnReleaseOglMutex(ppdev);

#ifdef DEBUG_MSG_CHANNEL_WAIT
                DISPDBG((2, "DmaPushGo: RmFifoFlushContext ERROR: Exit"));
#endif
                return (ULONG)FALSE;
                }
            }

        WRITE_REGISTER_ULONG(Cache1Push1Reg, chID);

        WRITE_REGISTER_ULONG(Config0Reg, (3 << 8) | (0x1F << 18));

        cache1DmaTlbPtBaseReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PT_BASE);
        WRITE_REGISTER_ULONG(cache1DmaTlbPtBaseReg, tlbPtBase);

        WRITE_REGISTER_ULONG(cache1DmaTlbTagReg, 0xFFFFFFFF);

        WRITE_REGISTER_ULONG(cache1DmaTlbPteReg, 1);

        WRITE_REGISTER_ULONG(cache1Dma3Reg, busAddressSpace);

        WRITE_REGISTER_ULONG(cache1DmaStatusReg, 0);

        WRITE_REGISTER_ULONG(cache1Dma2Reg, getOffset);

        WRITE_REGISTER_ULONG(cache1Dma1Reg, numDmaBytes);

        WRITE_REGISTER_ULONG(Cache1Pull0Reg, 1);
        WRITE_REGISTER_ULONG(Cache1Push0Reg, 1);
        WRITE_REGISTER_ULONG(CachesReg, 1);

        WRITE_REGISTER_ULONG(Cache1Dma0Reg, 1);

        ppdev->pfnReleaseOglMutex(ppdev);
        }

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "DmaPushGo: Exit"));
#endif

    return (ULONG)TRUE;
}

//******************************************************************************
//
// Function: NV3_RmFifoFlushContext
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     chID - Pointer to channel ID for resource manager
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG RmFifoFlushContext(PDEV *ppdev, ULONG chID, ULONG hClient, ULONG hDevice)
{
    DWORD   rmInfo[3];
    DWORD   *rmInfoPtr;

    rmInfo[0] = chID;
    rmInfo[1] = hClient;
    rmInfo[2] = hDevice;
    rmInfoPtr = &rmInfo[0];

// IA64 - NvDmaFlowControl needs to be modified so that the put/get can be
//        64 bit pointers (if we really want NV3 to work under IA64)

#ifndef _WIN64
    if (NvDmaFlowControl(ppdev->hDriver, (ULONG)0xFFFFFFFF, (ULONG)0, (ULONG)&rmInfoPtr, (ULONG)&rmInfoPtr))
        {
        DISPDBG((2, "RmFifoFlushContext FAILED!"));
        return(TRUE);
        }
#endif

    return(FALSE);
}

//******************************************************************************
//
// Function: NV3_AcquireOglMutex
//
// Routine Description:
//
//     Acquire the mutex that keeps OpenGL off the hardware.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_AcquireOglMutex(PDEV *ppdev)
{
    if (0 == ppdev->bReleaseOglMutex)
        {
        EngAcquireSemaphore(ppdev->csFifo);
        }
    ppdev->bReleaseOglMutex++;
}

//******************************************************************************
//
// Function: NV3_ReleaseOglMutex
//
// Routine Description:
//
//     Release the mutex that keeps OpenGL off the hardware.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_ReleaseOglMutex(PDEV *ppdev)
{
    if (1 == ppdev->bReleaseOglMutex)
        {
        EngReleaseSemaphore(ppdev->csFifo);
        }
    ppdev->bReleaseOglMutex--;
}
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3enabl.c ===
/************************** Module Header *************************************
//                                                                             *
//  Module Name: nv3enabl.c                                                    *
//                                                                             *
//  This module contains the functions that enable and disable the             *
//  driver, the pdev, and the surface.                                         *
//                                                                             *
//  Copyright (c) 1992-1996 Microsoft Corporation                              *
//                                                                             *
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#ifdef NV3
#include "excpt.h"
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "ddminint.h"
#include "dmamacro.h"
#include "nvcm.h"

//******************************************************************************
// Local prototypes
//******************************************************************************

BOOL bNV3CreateStdPatches(PDEV *ppdev);
VOID vNV3DestroyStdPatches(PDEV *ppdev, BOOL CreateStdPatchFailFlag);


//******************************************************************************
//
//  Function: bNV3CreateStdPatches
//
//  Routine Description:
//      Program the following patch:
//
//
//              ROP 5 SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
//                  |           |           |                   |
//                  \--|  |-----/           |                   |
//                     |  |                 |                   |
//                     V  V                 V                   V
//                   -----------       -------------       ----------
//      IMAGE       |           |     |             |     |          |
//      FROM   ---->|   IMAGE   |---->|    IMAGE    |---->|  IMAGE   |----\       (patch for subchannel 0)
//      CPU         |  ROP AND  |     |   STENCIL   |     | COLORKEY |    |
//                  |           |     |             |     |          |    |
//                   -----------       -------------       ----------     |
//                     |  |  ^              |                   |         |
//                     V  V  |              V                   V         |
//                   -----------       -------------       ----------     |
//                  |           |     |             |     |          |    |
//      IMAGE  ---->|   IMAGE   |---->|    IMAGE    |---->|  IMAGE   |--\ |       (patch for subchannel 1)
//      BLIT        |  ROP AND  |     |   STENCIL   |     | COLORKEY |  | |
//       ^          |           |     |             |     |          |  | |
//       |           -----------       -------------       ----------   | \-->
//   /---/             |  |  ^              |                   |       \---->IMAGE TO----> VIDEO
//   |                 V  V  |              V                   V       /----> VIDEO        SINK
//   |               -----------       -------------       ----------   | /--> |
//   |              |           |     |             |     |          |  | |    |
//   |  IMAGE  ---->|   IMAGE   |---->|    IMAGE    |---->|  IMAGE   |--/ |    |  (patch for subchannel 2)
//   |  MONO        |  ROP AND  |     |   STENCIL   |     | COLORKEY |    |    |
//   |              |           |     |             |     |          |    |    |
//   |               -----------       -------------       ----------     |    |
//   |                 |  |  ^              |                   |         |    |
//   |                 V  V  |              V                   V         |    |
//   |               -----------       -------------       ----------     |    |
//   |  RENDER      |           |     |             |     |          |    |    |
//   |  SOLID  ---->|   IMAGE   |---->|    IMAGE    |---->|  IMAGE   |----/    |  (patch for subchannel 3)
//   |  RECTANGLE   |  ROP AND  |     |   STENCIL   |     | COLORKEY |         |
//   |              |           |     |             |     |          |         |
//   |               -----------       -------------       ----------          |
//   |                       ^                                                 |
//   |                       |                                                 |
//   |                       |                                                 |
//   \-------------------------------------------------------------------------/
//
//
//  Arguments:
//      A pointer to the physical device
//
//  Return Value:
//      TRUE if successful
//      FALSE if unseccessful
//
//
//******************************************************************************

BOOL bNV3CreateStdPatches(
    PDEV *ppdev
)
{
    V032 colorFmtUnpack, colorFmtAlpha, colorFmtPack, videoFmt;
    ULONG color0, color1;
    Nv3ChannelPio *nv;
    U032 class;
    NV_CREATE_OBJECT_SETUP();

    if(!NvGetSupportedClasses(ppdev)){
        return FALSE;
    }


    //**************************************************************************
    // Get a channel from the NV device
    //**************************************************************************

    ppdev->hPioChannel = DD_PIO_CHANNEL_OBJECT_HANDLE;
    if (NvAllocChannelPio(  ppdev->hDriver,
                            ppdev->hClient,
                            ppdev->hDevice,
                            ppdev->hPioChannel,
                            NV03_CHANNEL_PIO,
                            0,
                            (PVOID)&nv,
                            0
                            ) != NVOS04_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot get NV PIO channel"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //**************************************************************************
    // Save channel ptr in state struct.
    //**************************************************************************
    ppdev->pjMmBase = (ULONG *)nv;

    //**************************************************************************
    // For NV3, ddraw and 2d driver use the same channel.
    //**************************************************************************
    (Nv3ChannelPio*) ppdev->ddChannelPtr = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Invalidate cached freecount in case this routine exits with an error
    //**************************************************************************
    ppdev->NVFreeCount = 0;

    DISPDBG((1, "DD setting up standard patches..."));

    // determine default packed and unpacked color formats from frame buffer depth
    switch (ppdev->iBitmapFormat)
    {
        case BMF_32BPP:
            colorFmtUnpack = NV_COLOR_FORMAT_LE_X8R8G8B8;
            colorFmtAlpha = NV_COLOR_FORMAT_LE_A8R8G8B8;
            colorFmtPack = colorFmtUnpack;
            videoFmt = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
            color0 =    NV_ALPHA_1_32 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_32 | 0x00ffffff;         // WHITE
            break;
        case BMF_16BPP:
            colorFmtUnpack = NV_COLOR_FORMAT_LE_X17R5G5B5;
            colorFmtAlpha = NV_COLOR_FORMAT_LE_X16A1R5G5B5;
            colorFmtPack = NV_COLOR_FORMAT_LE_X1R5G5B5_P2;
            videoFmt = NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2;
            color0 =    NV_ALPHA_1_16 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_16 | 0x00007fff;         // WHITE
            break;
        case BMF_8BPP:
            colorFmtUnpack = NV_COLOR_FORMAT_LE_X24Y8;
            colorFmtAlpha = NV_COLOR_FORMAT_LE_X16A8Y8;
            colorFmtPack = NV_COLOR_FORMAT_LE_Y8_P4;
            videoFmt = NV_VFM_FORMAT_COLOR_LE_Y8_P4;
            color0 =    NV_ALPHA_1_08 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_08 | 0x000000ff;         // WHITE
            break;

        default:
            return(FALSE);
    }

    //**************************************************************************
    // Allocate a DMA context which points to all of video memory. The limit
    // must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
    // closest page boundary) - 1.
    //**************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_WRITE,
                            (PVOID)(ppdev->pjFrameBufbase),
                            ppdev->cbFrameBuf
                            ) != NVOS03_STATUS_SUCCESS )
        {
        DISPDBG((1, "NVDD: Cannot allocate dma in memory context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //**************************************************************************
    // Allocate a DMA context to "sync" the fifo on ddraw lock calls.
    //**************************************************************************
    ((NvNotification *) ppdev->Notifiers->Sync)->status = 0;
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            DD_FIFO_SYNC_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->Sync),
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate fifo sync notifer"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }
    //*************************************************************************
    // allocate the dma notifier context for flip surface
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->FlipPrimary),
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate context dma notifier for flip surface"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    ((NvNotification *) (ppdev->Notifiers->FlipPrimary))->status = 0;

    //*************************************************************************
    // allocate the dma notifier context for video overlay flip
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->FlipOverlay),
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate notifier context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    ((NvNotification *) (ppdev->Notifiers->FlipOverlay))->status = 0;
    //*************************************************************************
    // Setup palette for indexed color mode.
    // allocate the colormap context (from system memory)
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_WIN_COLORMAP_CONTEXT,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_ONLY,
                            (PVOID)(ppdev->ajClutData),
                            (256 * sizeof(VIDEO_CLUTDATA)) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate buffer context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //*************************************************************************
    // allocate the dma notifier context (from system memory)
    //*************************************************************************
    ((NvNotification *) (ppdev->Notifiers->DmaFromMem))->status = 0;

    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID) ppdev->Notifiers->DmaFromMem,
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate notifier context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //***********************************************************************************
    // Allocate a buffer for scanlines.
    //***********************************************************************************
    if ((ppdev->NvDmaBufferFlat = EngAllocMem(0, 0x8000, ALLOC_TAG)) != NULL)
        {
        ppdev->NvScanlineBufferFlat = ppdev->NvDmaBufferFlat;
        if (NvAllocContextDma(  ppdev->hDriver,
                                ppdev->hClient,
                                NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                                NV01_CONTEXT_DMA,
                                NVOS03_FLAGS_ACCESS_READ_WRITE,
                                (PVOID) ppdev->NvDmaBufferFlat,
                                0x8000 - 1
                                ) != NVOS03_STATUS_SUCCESS)

        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //************************************************************************
    // Allocate Notifier contexts.
    //************************************************************************
    ((NvNotification *) ppdev->Notifiers->DmaToMem)->status = 0;

    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->DmaToMem),
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate notifier context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    NV_CREATE_OBJECT_INIT();

    NV_CREATE_OBJECT_PIO1(NV_VIDEO_COLORMAP, DD_COLORMAP);

    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, DD_PATCHCORD_COLORMAP);

    // create ROP ANDs
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND0);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND1);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND2);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND3);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND4);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND5);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND6);

    // create Image Stencils
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL0);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL1);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL2);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL3);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL4);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL5);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL6);

    // create Image Color Keys
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY0);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY1);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY2);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY3);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY4);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY5);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY6);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;


    NV_CREATE_OBJECT_INIT();
    // create Video Color Keys
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_COLOR_KEY, NV_DD_VIDEO_COLOR_KEY);

    // create Image In Memory
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_IN_MEMORY, DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_IN_MEMORY, DD_SRC_IMAGE_IN_MEMORY);

    // create Video from Memory
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_FROM_MEMORY, DD_PRIMARY_VIDEO_FROM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_FROM_MEMORY, NV_DD_YUV422_VIDEO_FROM_MEMORY);

    // create Video Sink
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_SINK, DD_VIDEO_SINK);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    NV_CREATE_OBJECT_INIT();
    // create Image Patchcords
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_BLIT);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_RECT_AND_TEXT);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_SOLID_RECT);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_PATTERN);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_BLACK_RECT);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_SOLID);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND0);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND1);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND2);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND3);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND4);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND5);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND6);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL0);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL1);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL2);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL3);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL4);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL5);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL6);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE0);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE1);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE2);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE3);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE4);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE5);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE6);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_FEEDBACK);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_SRC_FEEDBACK);

    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);

    NV_CREATE_OBJECT_PIO1(NV_SCALED_YUV420_FROM_MEMORY, NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_SCALED_YUV420_FROM_MEMORY, NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);


    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, DD_PATCHCORD_VIDEO);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, NV_DD_P_V_VIDEO_COLOR_KEY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, NV_DD_P_V_VIDEO_SCALER);

    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_ROP, DD_PATCHCORD_ROP5_SOLID);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    NV_CREATE_OBJECT_INIT();
    // create video scaler
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_SCALER, NV_DD_VIDEO_SCALER);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_FROM_CPU, DD_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_BLIT, DD_IMAGE_BLIT);
    NV_CREATE_OBJECT_PIO1(NV_RENDER_GDI0_RECTANGLE_AND_TEXT, DD_RENDER_RECT_AND_TEXT);
    NV_CREATE_OBJECT_PIO1(NV_RENDER_SOLID_RECTANGLE, DD_RENDER_SOLID_RECTANGLE);
    NV_CREATE_OBJECT_PIO1(NV_ROP5_SOLID, DD_ROP5_SOLID);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_PATTERN, DD_IMAGE_PATTERN);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_BLACK_RECTANGLE, DD_IMAGE_BLACK_RECTANGLE);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_SOLID, DD_IMAGE_SOLID);
    NV_CREATE_OBJECT_PIO1(NV_MEMORY_TO_MEMORY_FORMAT, NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT);
    NV_CREATE_OBJECT_PIO1(NV_MEMORY_TO_MEMORY_FORMAT, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    NV_CREATE_OBJECT_PIO1(NV_STRETCHED_IMAGE_FROM_CPU, NV_DD_STRETCHED_UV_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV_STRETCHED_IMAGE_FROM_CPU, NV_DD_STRETCHED_IMAGE_FROM_CPU);
    if (ppdev->cBitsPerPel > 8)
        {
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        }
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    // setup patch 0
    while (NvGetFreeCount(nv, 0) < 14*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput = DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput
        = DD_PATCHCORD_IMAGE_ROP_AND0;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL0;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_COLOR_KEY0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE0;

    // setup patch 1
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_ROP_AND1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLIT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput =
        DD_PATCHCORD_IMAGE_ROP_AND1;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_STENCIL1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL1;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_COLOR_KEY1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE1;

    // setup patch 2
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_ROP_AND2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
            DD_PATCHCORD_IMAGE_RECT_AND_TEXT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput =
        DD_PATCHCORD_IMAGE_ROP_AND2;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL2;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_COLOR_KEY2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE2;

    // setup patch 3
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_SOLID_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput =
        DD_PATCHCORD_IMAGE_ROP_AND3;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL3;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_COLOR_KEY3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE3;

    // setup patch 4
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput =
        DD_PATCHCORD_IMAGE_ROP_AND4;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL4;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_COLOR_KEY4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE4;

    // setup patch 5
    while (NvGetFreeCount(nv, 0) < 14*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput = DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput
        = DD_PATCHCORD_IMAGE_ROP_AND5;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL5;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_COLOR_KEY5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE5;

    // setup patch 6
    while (NvGetFreeCount(nv, 0) < 14*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND6;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput = DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput
        = DD_PATCHCORD_IMAGE_ROP_AND6;

    // setup patch back end
    while (NvGetFreeCount(nv, 0) < 25*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_PRIMARY_IMAGE_IN_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[0] =
        DD_PATCHCORD_IMAGE0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[1] =
        DD_PATCHCORD_IMAGE1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[2] =
        DD_PATCHCORD_IMAGE2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[3] =
        DD_PATCHCORD_IMAGE3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[4] =
        DD_PATCHCORD_IMAGE4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[5] =
        DD_PATCHCORD_IMAGE5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[6] =
        DD_PATCHCORD_IMAGE6;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[7] =
        NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[8] =
        NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[9] =
        NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[10] =
        NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[11] =
        NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[12] =
        NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[13] =
        NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[14] =
        NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[15] =
        NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[16] =
        NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[17] =
        NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[18] =
        DD_PATCHCORD_IMAGE_ROP_AND6;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageOutput =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetColorFormat =
            colorFmtPack;

    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImagePitch = ppdev->lDelta;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageOffset = ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageCtxDma =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    //***************************************************************************
    // Setup src image in memory for device bitmaps.
    //***************************************************************************
    while (NvGetFreeCount(nv, 0) < 6*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_SRC_IMAGE_IN_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageOutput =
        DD_PATCHCORD_SRC_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetColorFormat =
            colorFmtPack;

    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImagePitch = ppdev->lDelta;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageOffset = ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageCtxDma =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    // setup Video from memory object
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_PRIMARY_VIDEO_FROM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetVideoOutput =
        DD_PATCHCORD_VIDEO;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].offset = ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].pitch =
        ppdev->lDelta;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].size =
        (ppdev->cyScreen << 16) | (ppdev->cxScreen & 0xffff);
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].format =
        videoFmt;

    //**************************************************************************
    //
    // POSSIBLE PROBLEM ??  Or just a typo that was missed?
    //
    //        -> The following line used to be  ....nv4VideoFromMemory.ImageScan[0].notify.
    //           Now that this code has been separated out from ENABLE.C,
    //           this line has been changed to  ....nvVideoFromMemory.ImageScan[0].notify.
    //           in order for it to compile.   Essentially, the old obsolete
    //           nv3 classes are still being used in this file.
    //
    //           I don't know why .nv4VideoFromMemory was being used here,
    //           instead of nvVideoFromMemory.  First of all, nv4VideoFromMemory
    //           doesn't exist in the OLDNV332.H file.  And second, the structure
    //           OFFSETS for 'nvVideoFromMemory' vs nv4VideoFromMemory are DIFFERENT!
    //
    //           Bottom line: This looks like a typo that's been here forever.
    //                        It's now been changed, and should now be 'correct'.
    //                        However, since there's never been a problem with this before,
    //                        it's good to be aware of this change.   
    //
    //**************************************************************************

// REMOVED...causes lockup..ask!
//    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].notify = 0;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].offset = ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].pitch =
        ppdev->lDelta;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].size =
        (ppdev->cyScreen << 16) | (ppdev->cxScreen & 0xffff);
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].format =
        videoFmt;

    //**************************************************************************
    //
    // POSSIBLE PROBLEM ??  Or just a typo that was missed?
    //
    //        -> The following line used to be  ....nv4VideoFromMemory.ImageScan[0].notify.
    //           Now that this code has been separated out from ENABLE.C,
    //           this line has been changed to  ....nvVideoFromMemory.ImageScan[0].notify.
    //           in order for it to compile.   Essentially, the old obsolete
    //           nv3 classes are still being used in this file.
    //
    //           I don't know why .nv4VideoFromMemory was being used here,
    //           instead of nvVideoFromMemory.  First of all, nv4VideoFromMemory
    //           doesn't exist in the OLDNV332.H file.  And second, the structure
    //           OFFSETS for 'nvVideoFromMemory' vs nv4VideoFromMemory were DIFFERENT!
    //
    //           Bottom line: This looks like a typo that's been here forever.
    //                        It's now been changed, and should now be 'correct'.
    //                        However, since there's never been a problem with this before,
    //                        it's good to be aware of this change.   
    //
    //**************************************************************************


// REMOVED...causes lockup..ask!
//    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].notify = 0;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageNotifyCtxDma[0] =
        NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageNotifyCtxDma[1] =
        NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    // setup Image From CPU in subchannel 0
    while (NvGetFreeCount(nv, 0) < 3*4);

    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].SetObject = DD_IMAGE_FROM_CPU;
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nvImageFromCpu.SetImageOutput =
        DD_PATCHCORD_IMAGE_FROM_CPU;
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nvImageFromCpu.SetColorFormat =
        colorFmtPack;

    // setup Image BLIT in subchannel 1
    while (NvGetFreeCount(nv, 0) < 3*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_BLIT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageBlit.SetImageOutput =
        DD_PATCHCORD_IMAGE_BLIT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageBlit.SetImageInput =
        DD_PATCHCORD_SRC_FEEDBACK;

    // setup RECT and TEXT in subchannel 2
    while (NvGetFreeCount(nv, 0) < 6*4);

    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].SetObject =
        DD_RENDER_RECT_AND_TEXT;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetImageOutput =
        DD_PATCHCORD_IMAGE_RECT_AND_TEXT;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetColorFormat =
        colorFmtAlpha;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetMonochromeFormat =
        NV_MONO_CGA6_M1_P32;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetNotifyCtxDma =
        DD_FIFO_SYNC_NOTIFIER;



    // setup Render Solid Rectangle in subchannel 3
    while (NvGetFreeCount(nv, 0) < 3*4);

    nv->subchannel[RECTANGLE_SUBCHANNEL].SetObject = DD_RENDER_SOLID_RECTANGLE;
    nv->subchannel[RECTANGLE_SUBCHANNEL].nvRenderSolidRectangle.SetImageOutput = DD_PATCHCORD_IMAGE_SOLID_RECT;
    nv->subchannel[RECTANGLE_SUBCHANNEL].nvRenderSolidRectangle.SetColorFormat = colorFmtUnpack;

    // setup ROP5 Solid in subchannel 4
    while (NvGetFreeCount(nv, 0) < 3*4);

    nv->subchannel[ROP_SOLID_SUBCHANNEL].SetObject = DD_ROP5_SOLID;
    nv->subchannel[ROP_SOLID_SUBCHANNEL].nvRop5Solid.SetRopOutput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[ROP_SOLID_SUBCHANNEL].nvRop5Solid.SetRop5 = 0xcc;

    // setup Image Pattern in subchannel 5
    while (NvGetFreeCount(nv, 0) < 9*4);

    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].SetObject = DD_IMAGE_PATTERN;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetImageOutput =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetColorFormat =
        colorFmtAlpha;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetMonochromeFormat =
        NV_MONO_CGA6_M1_P32;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetPatternShape =
        NV_PATTERN_SHAPE_64X1;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetColor0 =
        color0;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetColor1 =
        color1;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetPattern.monochrome[0] =
        0xffffffff;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetPattern.monochrome[1] =
        0x50505050;

    // setup Image Rectangle Black in subchannel 6
    while (NvGetFreeCount(nv, 0) < 4*4);

    nv->subchannel[CLIP_SUBCHANNEL].SetObject = DD_IMAGE_BLACK_RECTANGLE;
    nv->subchannel[CLIP_SUBCHANNEL].nvImageBlackRectangle.SetImageOutput =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[CLIP_SUBCHANNEL].nvImageBlackRectangle.SetRectangle.y_x = 0;
    nv->subchannel[CLIP_SUBCHANNEL].nvImageBlackRectangle.SetRectangle.height_width =
        ((0x7fff<<16) | 0x7fff);

    // setup Image Solid in subchannel 7
    while (NvGetFreeCount(nv, 0) < 4*4);

    nv->subchannel[DD_SPARE].SetObject = DD_IMAGE_SOLID;
    nv->subchannel[DD_SPARE].nvImageSolid.SetColorFormat = colorFmtAlpha;
    nv->subchannel[DD_SPARE].nvImageSolid.SetImageOutput =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[DD_SPARE].nvImageSolid.SetColor = 0L;  //Disable color keying
    ppdev->dDrawSpareSubchannelObject = DD_IMAGE_SOLID;

    while (NvGetFreeCount(nv, 0) < 9*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_COLORMAP;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetVideoInput =
        DD_PATCHCORD_VIDEO;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetVideoOutput =
        DD_PATCHCORD_COLORMAP;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetNotifyCtxDma =
        NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetColormapCtxDma =
        NV_WIN_COLORMAP_CONTEXT;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetColormapFormat =
        NV_COLORMAP_X8R8G8B8;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetColormapStart = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetNotify = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetColormapLength =
        256 * sizeof(VIDEO_CLUTDATA);
    while (((NvNotification *) (ppdev->Notifiers->DmaToMem))->status == NV_STATUS_IN_PROGRESS);

    while (NvGetFreeCount(nv, 0) < 2*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_VIDEO_SINK;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoSink.SetVideoInput[0] =
        NV_DD_P_V_VIDEO_COLOR_KEY;

    //************************************************************************
    // Create the video memory to system memory format object.
    //************************************************************************
    while (NvGetFreeCount(nv, 0) < 5*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetNotifyCtxDma =
        NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferInCtxDma =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferOutCtxDma =
        NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferNotifyCtxDma =
        NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    //**************************************************************************
    // create memory to memory format object used to reformat overlay surfaces
    //**************************************************************************
    while (NvGetFreeCount(nv, 0) < 5*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
       NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetNotifyCtxDma =
       NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferInCtxDma =
       DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferOutCtxDma =
       DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferNotifyCtxDma =
       NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    //*******************************************************************************
    // Create objects needed for video overlay.
    //*******************************************************************************
    while (NvGetFreeCount(nv, BLIT_SUBCHANNEL) < 15*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_VIDEO_COLOR_KEY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoOutput =
        NV_DD_P_V_VIDEO_COLOR_KEY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoInput[0] =
        DD_PATCHCORD_VIDEO;

    if (ppdev->cBitsPerPel == 8)
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoInput[1] =
            DD_PATCHCORD_COLORMAP;
    else
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoInput[1] =
            DD_PATCHCORD_VIDEO;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoInput[2] =
        NV_DD_P_V_VIDEO_SCALER;

    if (ppdev->cBitsPerPel == 8)
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetColorFormat =
            NV_COLOR_FORMAT_LE_X16A8Y8;
    else if (ppdev->cBitsPerPel == 16)
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetColorFormat =
            NV_COLOR_FORMAT_LE_X16A1R5G5B5;
    else
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetColorFormat =
            NV_COLOR_FORMAT_LE_A8R8G8B8;


    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetColorKey = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetPoint = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetSize = 0;

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_VIDEO_SCALER;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetVideoOutput =
       NV_DD_P_V_VIDEO_SCALER;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetVideoInput =
       NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetDeltaDuDx = 0x100000;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetDeltaDvDy = 0x100000;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetPoint = 0;


    while (NvGetFreeCount(nv, BLIT_SUBCHANNEL) < 17*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetVideoOutput =
        NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageCtxDma[0] =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageCtxDma[1] =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageNotifyCtxDma[0] =
        NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageNotifyCtxDma[1] =
        NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].offset = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].pitch = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].size = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].format =
        NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].notify = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].offset = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].pitch = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].size = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].format =
        NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].notify = 0;

    if (ppdev->cBitsPerPel > 8)
        {
        //*****************************************************************************
        // Hook up scaled image from mem objects.
        //*****************************************************************************
        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
        if (ppdev->cBitsPerPel == 16)
            nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
                NV_COLOR_FORMAT_LE_X1R5G5B5_P2;
        else
            nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
                NV_COLOR_FORMAT_LE_X8R8G8B8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
        if (ppdev->cBitsPerPel == 16)
            nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
                NV_COLOR_FORMAT_LE_X1R5G5B5_P2;
        else
            nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
                NV_COLOR_FORMAT_LE_X8R8G8B8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_Y8V8Y8U8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_Y8V8Y8U8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_V8Y8U8Y8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_V8Y8U8Y8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_Y8V8Y8U8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_Y8V8Y8U8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_V8Y8U8Y8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_V8Y8U8Y8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 4*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 4*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
        }

    while (NvGetFreeCount(nv, 0) < 3*4);
    nv->subchannel[DD_STRETCH].SetObject =
        NV_DD_STRETCHED_IMAGE_FROM_CPU;
    nv->subchannel[DD_STRETCH].nvStretchedImageFromCpu.SetImageOutput =
        NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU;
    nv->subchannel[DD_STRETCH].nvStretchedImageFromCpu.SetColorFormat =
        colorFmtPack;
    ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

    while (NvGetFreeCount(nv, 0) < 3*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvStretchedImageFromCpu.SetImageOutput =
        NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvStretchedImageFromCpu.SetColorFormat =
        NV_COLOR_FORMAT_LE_Y8_P4;

    while (NvGetFreeCount(nv, 0) < 4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_BLIT;

    //******************************************************************************
    // Cache the freecount
    //******************************************************************************
    ppdev->NVFreeCount = NvGetFreeCount(nv, 0);

    return TRUE;




bNV3CreateStdPatches_ReturnFalse:

    //**************************************************************************
    // Remove ALL DMA contexts that we previously allocated!
    //**************************************************************************

    vNV3DestroyStdPatches(ppdev,TRUE);
    return(FALSE);


}

VOID vNV3DestroyStdPatches(
    PDEV *ppdev,
    BOOL  CreateStdPatchFailedFlag
)
{
    // get the FIFO pointer from the physical device descriptor
    Nv3ChannelPio *nv = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG                   status;

    DISPDBG((1, "DD destroying standard patches..."));

    //******************************************************************************
    // Ensure all hw processing has completed prior to destroying objects.
    // WaitEngineBusy function is NOT yet initialized if we just came from
    // a bNV3CreateStdPatches call, which failed.   So skip it.
    //******************************************************************************

    if (CreateStdPatchFailedFlag != TRUE)
        ppdev->pfnWaitEngineBusy(ppdev);

    //******************************************************************************
    // Invalidate cached freecount
    //******************************************************************************
    ppdev->NVFreeCount = 0;

    //**************************************************************************
    // Relinquish -> user channel
    //**************************************************************************
    if (ppdev->pjMmBase != NULL)
        {

        status = NvFree(ppdev->hDriver,
                        ppdev->hClient,
                        ppdev->hDevice,
                        ppdev->hPioChannel);

        if (status != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "Failed bAssertModeHardware"));
            return;
            }

        ASSERTDD(status == NVOS00_STATUS_SUCCESS,
                 "bAssertModeHardware: Failed to free NV user channel.");

        ppdev->pjMmBase = NULL;
        ppdev->ddChannelPtr = NULL;
        }


    //**********************************************************************
    // Destroy the notifier context (from system memory)
    //**********************************************************************

    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot free notifier context"));
        }

    //**********************************************************************
    // Destroy the colormap context (from system memory)
    //**********************************************************************

    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_WIN_COLORMAP_CONTEXT) != NVOS00_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot free buffer context"));
        }

    //*************************************************************************
    // Destroy video flip notifier.
    //*************************************************************************
        if (NvFree(ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDevice,
            NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "NVDD: Cannot free buffer context"));
            }

    //*************************************************************************
    // Destroy overlay flip notifier.
    //*************************************************************************
        if (NvFree(ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDevice,
            NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "NVDD: Cannot overlay notifier"));
            }

    //*************************************************************************
    // Destroy CONTEXT_DMA_IN_MEMORY object used to reference video memory.
    //*************************************************************************
    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "NVDD: Cannot video mem context"));
            }

    //*************************************************************************
    // Destroy FIFO sync notifier.
    //*************************************************************************
    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, DD_FIFO_SYNC_NOTIFIER) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "NVDD: Cannot free fifo sync notifier"));
            }

    //**********************************************************************************
    // Destroy DMA context for 2D/DDraw DMA Buffer.
    //**********************************************************************************
    if (NvFree(ppdev->hDriver,
                ppdev->hClient,
                ppdev->hDevice,
                NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
        {
        DISPDBG((1, "DisableOGLPatch: Cannot free 2D DMA buffer context"));
        }

    //**********************************************************************************
    // Destroy DMA notifier context for 2D/DDraw DMA Buffer.
    //**********************************************************************************
    if (ppdev->NvDmaBufferFlat)
        {
        if (NvFree(ppdev->hDriver,
                    ppdev->hClient,
                    ppdev->hDevice,
                    NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "DisableOGLPatch: Cannot free 2D DMA buffer context"));
            }
        EngFreeMem((PVOID) ppdev->NvDmaBufferFlat);
        }

    ppdev->NvDmaBufferFlat = ppdev->NvScanlineBufferFlat = 0;

    return;
}
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3linto.c ===
//*****************************Module*Header************************************
// 
// Module Name: NV3LINTO.C
// 
// DrvLineTo for S3 driver
// 
// Copyright (c) 1995-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#include "oldnv332.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// NV:   Currently, we'll be using the NV1 lineto functions for NV3 since
//       they're compatible.  We can add the NV3 specific versions later...
//******************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3pal.c ===
//******************************Module*Header***********************************
// 
// Module Name: NV3PAL.C
// 
// Copyright (c) 1992-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#ifdef NV3
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// Extern declarations
//******************************************************************************

//******************************************************************************
//
//  Function:   NV3SetPalette
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3SetPalette(
PDEV *ppdev,
ULONG start, 
ULONG length)

    {
    Nv3ChannelPio *nv = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Setup the palette via PIO
    //**************************************************************************

    while (FreeCount < 4*4)
        FreeCount = NvGetFreeCount(nv, 0);
    FreeCount -= 4*4;

    nv->subchannel[0].SetObject = DD_COLORMAP;
    nv->subchannel[0].nvVideoColorMap.ColormapDirtyStart = start;
    nv->subchannel[0].nvVideoColorMap.ColormapDirtyLength = length;
    nv->subchannel[0].SetObject = DD_IMAGE_FROM_CPU;

    //**************************************************************************
    // Update the cached free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;
    }

#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3ptr.c ===
//******************************Module*Header***********************************
//
// Module Name: NV3PTR.C
//
// This module contains the hardware pointer support for the display
// driver.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *  Copyright (C) 1997 - 2000 NVidia Corporation. All Rights Reserved.         *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#include "nvsubch.h"
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"
#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#ifdef NV3

#define OFFSET_PRMCIO_CRX__COLOR_REG                        0x3d4
#define OFFSET_PRMCIO_CR__COLOR_REG                         0x3d5
#define OFFSET_PRMVIO_SRX_REG                               0x3c4
#define OFFSET_PRMVIO_SR_LOCK_REG                           0x3c5
#define OFFSET_PRMVIO_MISC_READ_REG                         0x3cc
#define OFFSET_PRAMDAC_CU_START_POS_REG                     0x0
#define NV_PRMVIO_SR_LOCK_INDEX                             6

#define NV_SR_UNLOCK_VALUE                                  0x00000057
#define NV_SR_LOCK_VALUE                                    0x00000099

#define NV_CIO_CRE_HCUR_ADDR0_INDEX                 0x00000030
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                 0x00000031

extern ULONG NV3CursorChecksum(BYTE *);
extern VOID  NV3LoadCursorData(BYTE *,BYTE *);
extern VOID  NV3Load16x16CursorData(BYTE *,BYTE *);

//******************************************************************************
//
//  Function:   NV3_SetHwCursor
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
VOID NV3_SetHwCursor(
PDEV*   ppdev,
LONG    x,
LONG    y,
LONG    xHot,
LONG    yHot,
BYTE *  pjShape
)
{
    ULONG RowCount, ColumnCount;
    volatile ULONG *PRAMDACRegs;
    volatile ULONG*  CursorImageDataPtr;
    ULONG * pImage;
    
    //**************************************************************************
    // Get HotSpot
    //**************************************************************************

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    //**************************************************************************
    // Init access to cursor registers
    //**************************************************************************
    PRAMDACRegs = ppdev->PRAMDACRegs;

    //**************************************************************************
    // Load a test pattern into cursor image area (2k worth of data) (32x32 16bpp)
    //**************************************************************************

    CursorImageDataPtr = ppdev->PRAMINRegs;

    //**************************************************************************
    // Each cursor color bitmap takes up 2k.  However, to fix up noise which
    // occurs when we load cursor shapes, we also allocate the subsequent 2k
    // in cursor memory, and clear it.  So essentially, each cursor
    // image takes up 4k. The 1st 2k is the cursor image, and the
    // following 2k is zero'd out (made transparent)
    //**************************************************************************

    ((PUCHAR)(CursorImageDataPtr)) += NUM_CACHED_CURSORS * 2048 * 2;

    pImage =(ULONG *)pjShape;

    for (RowCount=0;RowCount < 32;RowCount++)
        for (ColumnCount=0; ColumnCount < 16 ; ColumnCount ++)
            {
            //******************************************************************
            // ColumnCount goes from 0 thru 16 because we'll be outputting
            // DWORDS at a time (instead of words)
            // Remember, RowCount and DwordCount are multiplied by 4 after
            // C Compilation, because CursorImageDataPtr is a pointer to Dwords
            // Disable Transparency (0x80008000) and specify GREEN as
            // a test pattern for the color cursor
            //******************************************************************

            *(CursorImageDataPtr + RowCount*16 + ColumnCount) =  *pImage;
            pImage++;
            }

    //**************************************************************************
    // Update cursor position
    //**************************************************************************
    ppdev->pfnMovePointer(ppdev, x, y);

}

//******************************************************************************
//
//  Function:   NV3_TVCopyCursorData
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3_TVCopyCursorData(
BYTE    *srcptr,
BYTE    *dstptr)

    {
    LONG   LineCount;
    LONG   RowCount;

    //**************************************************************************
    // Just copy the cursor bitmap as is (it's already been prepped for hardware)
    //**************************************************************************

    for (LineCount=0; LineCount <32 ;LineCount++)
        {
        for (RowCount=0;RowCount<64;RowCount+=4)
            {
            *(ULONG *)(dstptr + LineCount*64 + RowCount) =
                        *(ULONG *)(srcptr + LineCount*64 + RowCount);
            }
        }

    }

//******************************************************************************
//
//  Function:   NV3_TVClipCursorData
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************



VOID NV3_TVClipCursorData(
BYTE *dstptr,
LONG ypos,
LONG height
)

    {
    LONG   LineCount;
    LONG   RowCount;
    LONG   dy;

    //**************************************************************************
    // Get bottom of cursor and figure out # of pixels past the end
    //**************************************************************************

    dy = ypos + 32;                         // Bottom of cursor
//    dy -= 476;                              // # of pixels past end
      dy -= (height);                         // # of pixels past end

    //**************************************************************************
    // Only clip cursor if it's going past the end of the screen
    //**************************************************************************

    if (dy>0)
        {
        //**********************************************************************
        // Clear out portion of cursor AFTER tv scanline 478
        //**********************************************************************

        for (LineCount=31;(LineCount > (31-dy)) && (LineCount>=0) ;LineCount--)
            {
            for (RowCount=0;RowCount<64;RowCount+=4)
                {
                *(ULONG *)(dstptr + LineCount*64 + RowCount) =  0x00000000;
                }
            }
        }

    }



//******************************************************************************
//
//  Function:   NV3EnablePointer
//
//  Routine Description:
//
//      Get the hardware ready to use the Brooktree 485 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3EnablePointer(
PDEV*               ppdev,
BOOL    bEnable
)
{
    ULONG status;

    if (bEnable)
    {
        //**********************************************************************
        // Init access to cursor registers
        //**********************************************************************
        UCHAR lock;
        volatile UCHAR *PRMVIO_SRX_Reg;
        volatile UCHAR *PRMVIO_SR_LOCK_Reg;
        volatile UCHAR *PRMVIORegs = ppdev->PRMVIORegs;
        volatile ULONG*  CursorImageDataPtr;
        ULONG i;

        //**********************************************************************
        // Each cursor color bitmap takes up 2k.  However, to fix up noise which
        // occurs when we load cursor shapes, we also allocate the subsequent 2k
        // in cursor memory, and clear it.  So essentially, each cursor
        // image takes up 4k. The 1st 2k is the cursor image, and the
        // following 2k is zero'd out (made transparent)
        //
        // Here, we allocate memory for the cached monochrome cursors,
        // and the color cursor.
        //**********************************************************************

        ppdev->ulCursorMemOffset = (NUM_CACHED_CURSORS*2 + 2) * 2048;

        ppdev->hCursor = DD_CURSOR_OBJECT_HANDLE;
        status = NvAllocMemory( ppdev->hDriver,
                                ppdev->hClient,
                                ppdev->hDevice,
                                ppdev->hCursor,
                                NV01_MEMORY_LOCAL_PRIVILEGED,
                                0,
                                (PVOID)&ppdev->PRAMINRegs,
                                &ppdev->ulCursorMemOffset);

        if (status != NVOS02_STATUS_SUCCESS)
        /* jsw...
        status = NvAllocMemory( ppdev->hDriver,
                                "cursor",
                                (PVOID)&ppdev->PRAMINRegs,
                                &ppdev->ulCursorMemOffset);

        if (status != NV000E_ERROR_OK)
        ...jsw */
            {
            DISPDBG((2, "NV3EnablePointer: Cannot allocate cursor memory"));
            ppdev->flCaps |= CAPS_SW_POINTER;
            return;
            }

        PRMVIO_SRX_Reg = (volatile UCHAR *)(PRMVIORegs+OFFSET_PRMVIO_SRX_REG);
        PRMVIO_SR_LOCK_Reg = (volatile UCHAR *)(PRMVIORegs+OFFSET_PRMVIO_SR_LOCK_REG);

        PRMVIO_SRX_Reg = (volatile UCHAR *)(PRMVIORegs+OFFSET_PRMVIO_SRX_REG);

        *PRMVIO_SRX_Reg = NV_PRMVIO_SR_LOCK_INDEX;
        *PRMVIO_SR_LOCK_Reg = NV_SR_UNLOCK_VALUE;

        //**********************************************************************
        // Unlock CRTC extended regs
        //
        // NV_PRMVIO_SRX            = Sequencer Index Register (3c4)
        // NV_PRMVIO_SR_LOCK        = Data is written/ readm from register (3c5)
        // NV_PRMVIO_SR_LOCK_INDEX  = This indexed register (5) locks/unlocks
        //                            all extended registers.  When written with
        //                            value of 57, all extended registers are UNLOCKED.
        //                            Otherwise, all extended registers are LOCKED.
        //
        //                            When value = 0, extended register are in a locked state
        //                            When value = 1, extended registers are in an unlocked state
        //
        //**********************************************************************

        //**********************************************************************
        // Make sure to clear out cursor memory first. Otherwise,
        // we may see some noise when switching cursor shapes.
        //**********************************************************************

        CursorImageDataPtr = ppdev->PRAMINRegs;

        //**********************************************************************
        // Clear out cursor memory for all of the cached cursors and 1 color cursor.
        // Divide by 4 because we output dwords (4 bytes at a time)
        //**********************************************************************

        for (i=0;i < (((NUM_CACHED_CURSORS+1)*4096)>>2) ;i++)
            *(CursorImageDataPtr + i ) = 0x00000000;

        //**********************************************************************
        // Hide the pointer, since no cursor shape has been defined yet
        //**********************************************************************

        ppdev->pfnShowPointer(ppdev,FALSE);

    }
    else
    {
        //**********************************************************************
        // Hide the pointer.
        //**********************************************************************
        if (!(ppdev->flCaps & CAPS_SW_POINTER))
        {
            
            if(ppdev->ulCursorMemOffset)
            {
                ppdev->pfnShowPointer(ppdev, bEnable);
                status = NvFree( ppdev->hDriver,
                             ppdev->hClient,
                             ppdev->hDevice,
                             ppdev->hCursor);
                ASSERTDD(status == NVOS00_STATUS_SUCCESS,
                /*
                status = NvFreeMemory( ppdev->hDriver,
                                   (PVOID)ppdev->PRAMINRegs);
                ASSERTDD(status == NV000E_ERROR_OK,
                */
                    "Nv3EnablePointer: Cannot free cursor memory");
                ppdev->ulCursorMemOffset = 0;
            }
        }
    }
}


//******************************************************************************
//
//  Function:   NV3MovePointer
//
//  Routine Description:
//
//      Move the NV3 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3MovePointer(
PDEV*   ppdev,
LONG    x,
LONG    y)

    {
    LONG    dx;
    LONG    dy;
    volatile ULONG *PRAMDACRegs;
    volatile ULONG *PRAMDAC_CU_START_POS_Reg;
    BYTE *CursorImageDataPtr;
    BYTE *pjDstScan;
    BYTE *pjSrcScan;

    if (x != -1)
    {
    //**************************************************************************
    // Get pointer to RAMDAC register
    //**************************************************************************

    PRAMDACRegs = ppdev->PRAMDACRegs;
    PRAMDAC_CU_START_POS_Reg = (volatile ULONG *)(PRAMDACRegs+OFFSET_PRAMDAC_CU_START_POS_REG);

    //**************************************************************************
    // Adjustment for cursor Hot spot
    //**************************************************************************

    x -= ppdev->xPointerHot;
    y -= ppdev->yPointerHot;


    //**********************************************************************
    // On modes below 400 lines, scanline doubling is used.
    // We need to multiply cursor y position by 2
    //**********************************************************************

    if (ppdev->cyScreen < 400)
        y <<=1;

    //**************************************************************************
    // If TV is enabled, adjust the cursor position (monitor type is nonzero)
    //**************************************************************************

    if (ppdev->MonitorType)
        {
        x += ppdev->TVCursorMin;

        //**********************************************************************
        // If TV is enabled AND filtering is NOT enabled (i.e. 8bpp), we need to 'clip'
        // the cursor in cursor memory. Otherwise, smearing will occur at the bottom.
        // In order to do this, we won't implement cursor caching for this case.
        //**********************************************************************

        if (!(ppdev->FilterEnable))
            {
            //******************************************************************
            // First take the current cursor bitmap (which is already
            // formatted for our hardware) and store it in a temporary buffer.
            //******************************************************************

            pjSrcScan = &ppdev->NV_CursorImageData[0];
            pjDstScan = &ppdev->NV_TVCursorImageData[0];

            NV3_TVCopyCursorData(pjSrcScan,pjDstScan);

            //******************************************************************
            // Clip the cursor manually so that smearing doesn't occur with TV
            //******************************************************************

            NV3_TVClipCursorData(pjDstScan , y, ppdev->cyScreen );

            //******************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //******************************************************************

            CursorImageDataPtr = (BYTE *)ppdev->PRAMINRegs;
            CursorImageDataPtr += NUM_CACHED_CURSORS * 2048 * 2;

            //******************************************************************
            // Update PRAMIN with the updated/clipped cursor image
            //******************************************************************

            NV3_TVCopyCursorData(pjDstScan,CursorImageDataPtr);

            }

        //**********************************************************************
        // If filtering is enabled, we also need to scale the position as well!!
        //**********************************************************************

        if (ppdev->FilterEnable)
            {
            x <<=20;
            x /= ppdev->Scale_x;
            y <<=20;
            y /= ppdev->Scale_y;
            }


        }

    //**************************************************************************
    // Set hardware cursor position
    //**************************************************************************

    *PRAMDAC_CU_START_POS_Reg = ((x & 0xffff) | (y << 16) );

    return;
    }

    }

//******************************************************************************
//
//  Function:   NV3SetPointerShape
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG NV3SetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
LONG        cx,
LONG        cy,
BOOL        AlphaBlendedCursor
)

    {
    PDEV*   ppdev;
    
    BYTE    CurrentValue;
    BYTE    mono;
    BYTE    ajBuf[NV1_POINTER_TOTAL_SIZE];
    
    BYTE*   pjSrcScan;
    BYTE*   pjDstScan;
    BYTE*   pbSrc;
    BYTE*   pbDst;

    LONG    i,j,k;    
    LONG    lSrcDelta;
    LONG    lDstDelta;
    LONG    CachedCursorIndex;
    
    ULONG   Checksum;
    ULONG   CursorAddress;
    ULONG   test, mask;
    ULONG   color;
    
    volatile UCHAR *PRMCIO_CRX_COLOR_Reg;
    volatile UCHAR *PRMCIO_CR_COLOR_Reg;
    volatile UCHAR *PRMVIO_SRX_Reg;
    volatile UCHAR *PRMVIO_SR_LOCK_Reg;

    //**************************************************************************
    // Get pointer to pdev
    //**************************************************************************

    ppdev    = (PDEV*) pso->dhpdev;


    //**************************************************************************
    // Handle Win2k Alpha blended cursors (ONLY if OpenGL is enabled)
    // Normally, we wouldn't attempt to handle alpha blended cursors because
    // our hardware doesn't support alpha blended cursors.
    // Unfortunately, when OpenGL is enabled, the alpha blended software cursor
    // is not visible on top of an OpenGL app.  So we're forced to 'handle' 
    // this case with our opaque hardware cursor, so that we can see the cursor.
    //
    // 2 side effects:
    //      1) Hardware only supports 32x32 cursors (up to NV5)
    //         So Alpha Blended cursors which width > 32 and height > 32
    //         may get clipped abruptly.
    //
    //      2) We ignore the alpha blended component of the bitmap
    //          and just make it transparent.
    //**************************************************************************

    if ( AlphaBlendedCursor ) 
        {

        if (globalOpenGLData.oglDrawableClientCount
#if (_WIN32_WINNT >= 0x0500) && !defined(NV3) && !defined(_WIN64)
            || ppdev->pDriverData->dwOverlaySurfaces
#endif      
        )
            {
            //******************************************************************
            // For alpha blended cursors when OpenGL is enabled,
            // we convert it to a hardware mono cursor.  NV4/NV5 only support
            // 32x32 hardware cursors, so if alpha blended cursors come thru
            // with cx>32 or cy>32, they'll get clipped
            //******************************************************************

            if (cx > 32 )
                cx = 32;
                
            if (cy > 32 )
                cy = 32;            
            }
            
        else
                    
            {
            //******************************************************************
            // Punt all Alpha blended cursors, except when OpenGL is enabled
            //******************************************************************

            return(SPS_DECLINE);
            
            }
                                
        }
        
    //**************************************************************************
    // Only handle 32x32 and 16x16 mono cursors. Send the rest thru DrvCopyBits
    //**************************************************************************

    else if ( !(((cx == 16) && (cy == 16) && (psoColor==NULL))  ||   
           ((cx == 32) && (cy == 32))) )
        {
        //
        // Can't handle this ptr in hw.
        //
        return(SPS_DECLINE);
        }


    
    //**************************************************************************
    // Check whether we'll be drawing a MONOCHROME or COLOR cursor
    //**************************************************************************
    if (psoColor == NULL)

        {

        //**********************************************************************
        // Translate to black and white format for DAC
        // Expand 32 x 32 x 1  (monochrome source ) to 32 x 32 x 16 CursorColorImage
        //
        // We're going to take the requested pointer AND masks and XOR
        // masks and combine them into our work buffer,
        //
        // We currently ONLY allow 32x32 cursors !!!
        //
        //              Monochrome Source
        //              -----------------
        //
        //         Byte0   Byte1   Byte2   Byte3
        //  0    |       |       |       |       |
        //  1    |       |       |       |       |         (monochrome source)
        //  2    |       |       |       |       |     Total of 128 bytes per plane
        //  3    |       |       |       |       |
        //                      etc..
        //
        //  31   |       |       |       |       |
        //
        //
        //
        //              Color Destination
        //              -----------------
        //
        //         Word0   Word1   ....    Word31
        //  0    |       |       |       |       |
        //  1    |       |       |       |       |         (color destination)
        //  2    |       |       |       |       |      Total 32*32*2 bytes
        //  3    |       |       |       |       |
        //                      etc..
        //
        //  31   |       |       |       |       |
        //
        //
        //**********************************************************************

        pjSrcScan    = psoMsk->pvScan0;
        lSrcDelta    = psoMsk->lDelta;

        if(lSrcDelta != 4)
        {

            // The cursor bitmap is neither TOP-DOWN nor Contiguous.

            pbDst = ajBuf;

            // XOR MASK, AND MASK
            for (i = 2*cy; i != 0; i--)
            {
                pbSrc = pjSrcScan;

                for (j = 4; j != 0; j--)
                {
                    *pbDst = *pbSrc;
                    pbDst++;
                    pbSrc++;
                }

                pjSrcScan += lSrcDelta;
            }
            pjSrcScan = ajBuf;

        }

        pjDstScan    = &ppdev->NV_CursorImageData[0]; // Start with first AND plane
        lDstDelta    = 4;                             // Each scan is 4 bytes (see above)


        //**********************************************************************
        // If TV is enabled AND filtering is NOT enabled (i.e 8bpp), we need to 'clip'
        // the cursor in cursor memory. Otherwise, smearing will occur.
        // In order to do this, we won't implement cursor caching for this case.
        //
        // Also special case 16x16 monochrome cursors!  
        // (Occurs when running SoftImage with OGL).
        // If it's a 16x16 cursor, then don't bother doing cached cursor.
        //**********************************************************************

        if (   ( (ppdev->MonitorType) && (!(ppdev->FilterEnable)))   ||
                 (cx == 16)     )
            {              
            //******************************************************************
            // First take the cursor from GDI and format it for our hardware
            // We'll store it in a temporary buffer first
            //******************************************************************

            pjDstScan = &ppdev->NV_CursorImageData[0];

            //******************************************************************
            // Cursor load is same for NV3 and NV4
            //******************************************************************

            if (cx == 16)
                NV3Load16x16CursorData(pjSrcScan, pjDstScan);
            else
                NV3LoadCursorData(pjSrcScan, pjDstScan);

            //******************************************************************
            // Don't forget to tell hardware where the cursor resides in PRAMIN memory
            //******************************************************************

            PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

            PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

            //******************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //******************************************************************

            CursorAddress = ppdev->ulCursorMemOffset + NUM_CACHED_CURSORS * 2048 * 2;

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR0_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)(CursorAddress >> 16);

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR1_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)( (((CursorAddress >> 11) & 0x1f) << 3) | 1);

            //******************************************************************
            // Blast the cursor image data into hardware
            //******************************************************************

            NV3_SetHwCursor(ppdev, x,y, xHot, yHot, pjDstScan);

            return(SPS_ACCEPT_NOEXCLUDE);

            }


#ifdef _X86_
        //**********************************************************************
        // Use assembly to load cursor data as quickly as possible
        // To improve performance, we'll store the data DIRECTLY
        // to PRAMIN memory, update the position, and return as quickly
        // as possible. (We store cursor data at PRAMIN + 14k
        //**********************************************************************

        pjDstScan = (BYTE *) ((ULONG)(ppdev->PRAMINRegs));

        //**********************************************************************
        // Quickly scan the image and get a unique checksum
        // Cursor checksum is same for NV3 and NV4
        //**********************************************************************

        Checksum = NV3CursorChecksum(pjSrcScan);

        //**********************************************************************
        // Check and see if we've already loaded the image in a buffer
        //**********************************************************************

        CachedCursorIndex = -1;

        //**********************************************************************
        // But first check and see if we couldn't distinguish the image
        // If we encounter the flag value, then reload the image.
        // Otherwise, look for the checksum in the cache.
        //**********************************************************************

        if (Checksum != 0x12345678)
            {
            for (i=0;i<NUM_CACHED_CURSORS;i++)
                if (ppdev->SavedCursorCheckSums[i] == Checksum)
                    CachedCursorIndex=i;
            }


        if (CachedCursorIndex !=-1)

            {
            //******************************************************************
            // Load the cached image directly
            //******************************************************************

            //******************************************************************
            // The 2k bitmap of the cursor (32x32 16bpp) must be located in
            // INSTANCE memory on a 2k boundary.  That is, it must lie on a 2k
            // boundary, so only 12 bits are programmable
            //
            // NV3: ------------------------------------------------------------
            //
            //      NV_CIO_CRE_HCUR_ADDR0_INDEX
            //
            //          Bits [6:0]  -> Bits [22:16] of cursor address in instance memory
            //
            //      NV_CIO_CRE_HCUR_ADDR1_INDEX
            //
            //          Bits [7:3]  -> Bits [15:11] of cursor image address in instance memory
            //          Bit  [2]    -> Undefined?
            //          Bit  [1]    -> Turns on scan doubling
            //          Bit  [0]    -> Enable/Disables cursor
            //
            //      Cursor address [10:0] is zero, due to the 2k alignment requirement
            //
            //******************************************************************

            PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

            PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

            //******************************************************************
            // Bit definitions for cursor address are different for NV3 vs NV4
            //******************************************************************
            
            //**************************************************************
            // Need to ALWAYS unlock the CRTC registers here, because
            // on NEC systems, when Power Saving is enabled and the
            // system goes into power down mode, the CRTC registers
            // are locked when power comes back on.  Need to do this 
            // otherwise the cursor caching functionality won't work 
            // (hardware addressing won't work)
            //**************************************************************

            PRMVIO_SRX_Reg = (volatile CHAR *)ppdev->PRMVIORegs;
            PRMVIO_SRX_Reg += OFFSET_PRMVIO_SRX_REG;

            PRMVIO_SR_LOCK_Reg = (volatile CHAR *)ppdev->PRMVIORegs;
            PRMVIO_SR_LOCK_Reg += OFFSET_PRMVIO_SR_LOCK_REG;

            *PRMVIO_SRX_Reg = 6;    // Unlock register
            *PRMVIO_SR_LOCK_Reg = NV_SR_UNLOCK_VALUE;

            //**************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which 
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //**************************************************************

            CursorAddress =  ppdev->ulCursorMemOffset + CachedCursorIndex * 2048 * 2;

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR0_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)(CursorAddress >> 16);

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR1_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)( (((CursorAddress >> 11) & 0x1f) << 3) | 1);
                
            }

        else

            {
            //******************************************************************
            // Save the calculated checksum value for the cursor bitmap
            //******************************************************************

            ppdev->SavedCursorCheckSums[ppdev->NextCachedCursor] = Checksum;

            //******************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which 
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //******************************************************************

            CursorAddress = ppdev->NextCachedCursor * 2048 * 2;

            pjDstScan = (BYTE *) ((ULONG)(ppdev->PRAMINRegs));

            NV3LoadCursorData(pjSrcScan,(BYTE *)((ULONG)pjDstScan+(ULONG)(CursorAddress)));
            NV3LoadCursorData(pjSrcScan,(BYTE *) (&(ppdev->SavedCursorBitmaps[ppdev->NextCachedCursor][0])));

            //******************************************************************
            // Tell hardware where the cursor resides in PRAMIN memory
            //******************************************************************

            PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

            PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

            //******************************************************************
            // Bit definitions (for cursor address)
            //******************************************************************

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR0_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)((CursorAddress + ppdev->ulCursorMemOffset) >> 16);

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR1_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)( ((((CursorAddress + ppdev->ulCursorMemOffset) >> 11) & 0x1f) << 3) | 1);
            
            //******************************************************************
            // Reset the next cached cursor entry (round robin)
            //******************************************************************

            ppdev->NextCachedCursor++;
            if (ppdev->NextCachedCursor >= NUM_CACHED_CURSORS)
                ppdev->NextCachedCursor=0;
            }


        //**********************************************************************
        // Get HotSpot
        //**********************************************************************
        ppdev->xPointerHot = xHot;
        ppdev->yPointerHot = yHot;

        ppdev->pfnMovePointer(ppdev, x, y);
        return(SPS_ACCEPT_NOEXCLUDE);

#else

        for (i = 0; i < 32; i++)                      // 32 pixels vertically
            for (j = 0; j < 4; j++)                   // 4 bytes accross (32 pixels)
                {
                //**************************************************************
                // Read 1 byte (8 pixels) and write 8 words
                // XOR mask is 128 bytes from the beginning of source buffer
                //**************************************************************
#define COLOR_OFFSET    (32*4)

                mask = pjSrcScan[i*4 + j];                  // Get a Mask byte (8 pixels)
                mono = pjSrcScan[COLOR_OFFSET+ i*4 + j];    // Get a Mono byte (8 pixels)

                //**************************************************************
                // Now combine the masks according to the AND-XOR Microsoft convention
                //
                //  ('mask' value)      ('mono' value)
                //  AND mask value      XOR mask value      Result on screen
                //  --------------      --------------      ----------------
                //          0               0               Black
                //          0               1               White
                //          1               0               Transparent, pixel unchanged
                //          1               1               Inverts the pixel color
                //
                // We'll parse the pixels from right to left in source
                // (Bit 0 is leftmost in mono image).  This will cause
                // us to bit flip the cursor image and draw it correctly
                //**************************************************************

                test = 0x80;
                for (k = 0; k < 8; k++, test >>= 1)
                    {
                    if (test & mono)        // Test this bit
                        color = 0x7fff;     // White
                    else
                        color = 0;          // Black

                    if (!(test & mask))
                        color |= 0x8000;    // Not transparent

                    //**********************************************************
                    // Store 16 bits for NV cursor image data
                    //**********************************************************

                    *((WORD *)(pjDstScan+ i*32*2 + j*8*2 + k*2)) = (USHORT) color;
                    }
                }


#endif


        }   // Draw monochrome cursor (psoColor == NULL)

    else

        {

        WORD    red;
        WORD    green;
        WORD    blue;
        WORD    alpha;
        ULONG   iSrcBitDepth;
        LONG    lPitch;
        BYTE*   pjSrcColor;
        BYTE*   pjSrcColorMask;
        PALETTEENTRY pXlatePal[256];
        PPALETTEENTRY pPal;
    
        
        //**********************************************************************
        // Color cursor ( or alpha blended cursor)
        // Calc width of each scan in the color cursor bitmap. Assume the
        // bitmap has the same color format as the display device.
        //
        // The first 32*4 bytes is the AND mask.
        // The next 32 * 32 * bytes/pixel is the cursor image.
        // Translate the image into 1-5-5-5 format for the DAC
        // The AND mask value goes into the upper bit
        // The pixel image gets reduced to 5 bits each color and goes in the lower 15 bits
        // 8 bpp  - 8 bit index into palette.           pixel = 1 byte
        // 16 bpp - 1 bit X, 5 bit R, 5 bit G, 5 bit B. pixel = 2 bytes
        // 32 bit - 8 bit R, 8 bit G, 8 bit B           pixel = 3 bytes unpacked (+unused byte).
        //**********************************************************************

        //**********************************************************************
        // Determine if this is a device bitmap or GDI managed bitmap.
        // Note that the cursor bitmap may be any legal bit depth: it
        // does not necessarily match the current video mode. That's ok
        // since we have to convert it to 16BPP for our color cursor
        // hw.
        //**********************************************************************

        if (psoColor->dhsurf != NULL)
            {
            //******************************************************************
            // Device managed bitmap
            //******************************************************************
            if (((DSURF *) psoColor->dhsurf)->dt == DT_SCREEN)
                {
                //**************************************************************
                // Ptr surface is in offscreen device memory, need to wait for
                // fifo empty and graphics engine idle prior to copying the
                // pointer bitmap.
                //**************************************************************
                pjSrcColor      = (PBYTE) (((DSURF *) psoColor->dhsurf)->LinearPtr);
                lPitch          = (((DSURF *) psoColor->dhsurf))->LinearStride;
                iSrcBitDepth =  (((DSURF *) psoColor->dhsurf)->ppdev)->iBitmapFormat;
                ppdev->pfnWaitEngineBusy(ppdev);
                }
            else // (pdsurfSrc->dt == DT_DIB)
                {
                //**************************************************************
                // Device managed DFB in host memory, stored as DIB.
                // Don't bother moving DIB to offscreen memory since whe don't
                // use the graphics engine to draw or translate it.
                //**************************************************************
                psoColor = ((DSURF *) psoColor->dhsurf)->pso;
                lPitch =  psoColor->lDelta;
                iSrcBitDepth = psoColor->iBitmapFormat;
                pjSrcColor = (PBYTE) psoColor->pvScan0;
                }

            }
        else if (psoColor->pvScan0 != NULL)
            {
            //******************************************************************
            // GDI managed host memory bitmap
            //******************************************************************
            pjSrcColor      = (PBYTE) psoColor->pvScan0;
            lPitch          = psoColor->lDelta;
            iSrcBitDepth =  psoColor->iBitmapFormat;
            }
        else
            {
            //******************************************************************
            // If ptr bmp is neither DFB nor DIB, it's likely an error occurred.
            //******************************************************************
            return(SPS_DECLINE);
            }

        //**********************************************************************
        // Can't use ptr without address of the bitmap
        //**********************************************************************

        if (pjSrcColor == NULL)
            {
            return(SPS_DECLINE);
            }

        //**********************************************************************
        // psoMsk is NULL when using an Alpha Blended cursor
        //**********************************************************************

        if (!(AlphaBlendedCursor)) 
            {
            pjSrcColorMask  = psoMsk->pvScan0;
            lSrcDelta       = psoMsk->lDelta;
            }
            
        pjDstScan       = &ppdev->NV_CursorImageData[0];

        switch (iSrcBitDepth)
            {
            //******************************************************************
            // We gotta look up the color from the palette to convert to RGB
            //******************************************************************

            case BMF_8BPP:
                //**************************************************************
                // We gotta look up the color from the palette to
                // convert to RGB. Try to get info from the XLATEOBJ
                // first.
                //**************************************************************
                pPal = ppdev->pPal;     // Default to using pal from PDEV
                if (pxlo != NULL)
                    {
                        if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, NULL) == 256)
                        {
                        //******************************************************
                        // Get the RGB palette.
                        //******************************************************
                        if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, (PULONG) pXlatePal) != 256)
                            pPal = pXlatePal;
                        }
                    }
                for (i = 0; i < 32; i++)
                    {
                    mask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
                    test = 0x00000080;
                    for (k = 0; k < 32; k++, test >>=1)
                        {
                        if (!(k & 7))
                            test = 0x00000080 << k;
                        color = *((PBYTE) (pjSrcColor + i*lPitch + k)); // Get 15 bits of color
                        blue =  pPal[color].peBlue;
                        green = pPal[color].peGreen;
                        red =  pPal[color].peRed;
                        color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);
                        if (!(test & mask))
                            color |= 0x8000;              // Not transparent

                        //******************************************************
                        // Store 16 bits for NV cursor image data
                        //******************************************************
                        *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                        }
                    }
                break;

            //******************************************************************
            // Screen is currently in 16bpp mode
            //******************************************************************

            case BMF_16BPP:
                for (i = 0; i < 32; i++)
                   {
                   mask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
                   test = 0x00000080;
                   for (k = 0; k < 32; k++, test >>=1)
                       {
                       if (!(k & 7))
                           test = 0x00000080 << k;

                       if (ppdev->flGreen == 0x03e0)
                            {
                            //**************************************************
                            // For 555: We can use the source color as is
                            //          since the color cursor is always 555
                            //**************************************************
                            color = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 15 bits of color
                            }
                       else
                            {
                            //**************************************************
                            // For 565: Convert from 565 bitmap format to 555
                            //          since the color cursor is always 555
                            //**************************************************
                            color = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 16 bits of color
                            red   = (WORD)(color & 0xf800); // 5 bits
                            green = (WORD)(color & 0x07c0); // Just take top 5 of 6 bits !
                            blue  = (WORD)(color & 0x001f); // 5 bits
                            color = (  (red >> 1 ) | (green >> 1 ) | (blue) );
                                                            
                            }

                       if (!(test & mask))
                             color |= 0x8000;                // Not transparent

                       //******************************************************
                       // Store 16 bits for NV cursor image data
                       //******************************************************
                       *((WORD *)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                       }
                   }

                break;

            //******************************************************************
            // Screen is currently in 32bpp mode
            //******************************************************************

            case BMF_32BPP:
                if (AlphaBlendedCursor)
                    {
                    // 32bpp color cursor                     
                    for (i = 0; i < cy; i++)
                        {
                        for (k = 0; k < (LONG)cx; k++)
                            {
                            blue =  *(pjSrcColor + i*lPitch + k*4 + 0);
                            green = *(pjSrcColor + i*lPitch + k*4 + 1);
                            red =   *(pjSrcColor + i*lPitch + k*4 + 2);
                            alpha = *(pjSrcColor + i*lPitch + k*4 + 3);
                            color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);

                            if (alpha == 0xff)
                                color |= 0x8000;                // Not transparent

                            //**************************************************
                            // Store 16 bits for NV cursor image data
                            //**************************************************
                            *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                            }


                        //******************************************************
                        // If alpha blended cursor width < 32, then fill out
                        // rest of pixels with transparent color
                        //******************************************************

                        for (;k < 32; k++)
                            {
                            blue =  0x0;
                            green = 0x0;
                            red =   0x0;
                            alpha = 0x0;
                            color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);

                            if (alpha == 0xff)
                                color |= 0x8000;                // Not transparent

                            //**************************************************
                            // Store 16 bits for NV cursor image data
                            //**************************************************
                            *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                            }


                        }


                    //**********************************************************
                    // If alpha blended cursor height < 32, then fill out
                    // remaining scanlines with transparent color
                    //**********************************************************

                    for (; i < 32; i++)
                        {
                        for (k = 0; k < 32; k++)
                            {
                            blue =  0x0;
                            green = 0x0;
                            red =   0x0;
                            alpha = 0x0;
                            color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);

                            if (alpha == 0xff)
                                color |= 0x8000;                // Not transparent

                            //******************************************************
                            // Store 16 bits for NV cursor image data
                            //******************************************************
                            *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                            }

                        }

                    }
                    
                else
                
                    {
                    // 32bpp color cursor                     
                    for (i = 0; i < 32; i++)
                        {
                        mask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bitsif (!(k & 7))
                        test = 0x00000080;
                        for (k = 0; k < 32; k++, test >>=1)
                            {
                            if (!(k & 7))
                                test = 0x00000080 << k;
    
                            blue =  *(pjSrcColor + i*lPitch + k*4 + 0);
                            green = *(pjSrcColor + i*lPitch + k*4 + 1);
                            red =   *(pjSrcColor + i*lPitch + k*4 + 2);
                            color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);
                            if (!(test & mask))
                                color |= 0x8000;                // Not transparent
    
                            //******************************************************
                            // Store 16 bits for NV cursor image data
                            //******************************************************
                            *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                            }
                        }
                    }
                    

                break;

             default:
                //**************************************************************
                // Can't handle any other bit depths
                //**************************************************************
                return(SPS_DECLINE);

            }   // Switch
            //******************************************************************
            // Tell hardware where the cursor resides in PRAMIN memory
            //******************************************************************

            PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

            PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

            //******************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //******************************************************************

            CursorAddress = ppdev->ulCursorMemOffset + NUM_CACHED_CURSORS * 2048 * 2;

            //******************************************************************
            // Bit definitions (for cursor address)
            //******************************************************************
            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR0_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)(CursorAddress >> 16);

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR1_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)( (((CursorAddress >> 11) & 0x1f) << 3) | 1);

        } // psoColor != NULL

    //**************************************************************************
    // Set the buffer for NV1 monochrome hardware or NV3 hardware color cursor
    //**************************************************************************

    pjDstScan = &ppdev->NV_CursorImageData[0];

    //**************************************************************************
    // Blast the cursor image data into hardware
    //**************************************************************************
    NV3_SetHwCursor(ppdev, x,y, xHot, yHot, pjDstScan);

    //**************************************************************************
    // Since it's a hardware pointer, GDI doesn't have to worry about
    // overwriting the pointer on drawing operations (meaning that it
    // doesn't have to exclude the pointer), so we return 'NOEXCLUDE'.
    // Since we're returning 'NOEXCLUDE', we also don't have to update
    // the 'prcl' that GDI passed us.
    //**************************************************************************

    return(SPS_ACCEPT_NOEXCLUDE);

    }

#ifdef _WIN64
//*****************************************************************************
//
// Function: NV3LoadCursorData()
//
// Routine Description:
//
//   C version for IA64 only.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//*****************************************************************************

DWORD MonoTable[4] = { 0x00000000, 0x7fff0000, 0x00007fff, 0x7fff7fff };
DWORD AndTable[4]  = { 0x80008000, 0x00008000, 0x80000000, 0x00000000 };

VOID NV3LoadCursorData(
BYTE*   pjSrcScan,
BYTE*   pjDstScan
)
    {
    UCHAR*    AndMaskPtr;
    UCHAR*     MonoMaskPtr;
    ULONG*     DstPtr;
    UCHAR      AndMask;
    UCHAR      MonoMask;
    LONG       i, j, k;

    AndMaskPtr = (UCHAR *)pjSrcScan;
    MonoMaskPtr = (UCHAR *)(pjSrcScan + 128);
    DstPtr = (ULONG *)pjDstScan;

   //***************************************************************************
   // Iterate through 32 rows of data
   //***************************************************************************
    for (i = 0; i < 32; i++)
        {
        //**********************************************************************
        // Load 16bpp pels - uses tables to convert ones to 0x7fff and zeros to
        // 0x0000.  Also uses table to add transparency bit from AND mask.
        // Zero in AND mask converts to 0x8000, ones to 0x0000.
        //
        // Create two pels at a time with 4 entry tables, above.  If pjDstScan
        // will also be quad word aligned, a future optimization might be
        // creating 4 pels at a time with 16 entry tables.
        //**********************************************************************
        

        for (j = 0; j < 4; j++)
            {
            AndMask = *AndMaskPtr++;
            MonoMask = *MonoMaskPtr++;
            for (k = 0; k < 4; k++)
                {
                *DstPtr++ = AndTable[(AndMask >> 6) & 0x3] |
                            MonoTable[(MonoMask >> 6) & 0x3];
                AndMask <<= 2;
                MonoMask <<= 2;
                }
            }
        }
    }

//*****************************************************************************
//
// Function: NV3Load16x16CursorData()
//
// Routine Description:
//
//   C version for IA64 only.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//*****************************************************************************

VOID NV3Load16x16CursorData(
BYTE*   pjSrcScan,
BYTE*   pjDstScan
)
    {
    UCHAR*    AndMaskPtr;
    UCHAR*     MonoMaskPtr;
    ULONG*     DstPtr;
    UCHAR      AndMask;
    UCHAR      MonoMask;
    LONG       i, j, k;

    AndMaskPtr = (UCHAR *)pjSrcScan;
    MonoMaskPtr = (UCHAR *)(pjSrcScan + 64);
    DstPtr = (ULONG *)pjDstScan;

   //***************************************************************************
   // Iterate through 16 rows of data
   //***************************************************************************
    for (i = 0; i < 16; i++)
        {
        //**********************************************************************
        // Load 16bpp pels - uses tables to convert ones to 0x7fff and zeros to
        // 0x0000.  Also uses table to add transparency bit from AND mask.
        // Zero in AND mask converts to 0x8000, ones to 0x0000.
        //**********************************************************************
        

        for (j = 0; j < 2; j++)
            {
            AndMask = *AndMaskPtr++;
            MonoMask = *MonoMaskPtr++;
            for (k = 0; k < 4; k++)
                {
                *DstPtr++ = AndTable[(AndMask >> 6) & 0x3] |
                            MonoTable[(MonoMask >> 6) & 0x3];
                AndMask <<= 2;
                MonoMask <<= 2;
                }
            }
            AndMaskPtr += 2;
            MonoMaskPtr += 2;

        //**********************************************************************
        // Blank out remaining 'width' portion of 32x32 cursor (clear 16 pels)
        //**********************************************************************
        for (j = 0; j < 8; j++)
            *DstPtr++ = 0x0;
            }

    //**************************************************************************
    // Blank out remaining 'height' portion of 32x32 cursor
    // (clear out 16 lines * 32 pels = 512 pels = 256 dwords)
    //**************************************************************************
    for (i = 0; i < 256; i++)
        *DstPtr++ = 0x0;
    }
#endif // _WIN64
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3textc.c ===
//******************************Module*Header***********************************
//
// Module Name: NV3TEXTC.C
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#ifdef NV3
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// Extern declarations
//******************************************************************************

// IA64 Assembly is NOT feasible under IA64
#ifndef _WIN64
extern void NV3_Transfer_Text_Data(ULONG, USHORT *, ULONG *, Nv3ChannelPio *);
#endif

extern VOID vClipSolid(PDEV* ,LONG ,RECTL *,ULONG ,CLIPOBJ*);
extern RECTL grclMax;

//******************************************************************************
//
//  Function:   NV3GeneralText
//
//  Routine Description:
//
//      Handles any strings that need to be clipped, using the 'glyph
//      expansion' method.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3GeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco,
BRUSHOBJ* pboFore)

    {
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    DWORD*      myGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        cx;
    LONG        cy;
    BYTE        iDComplexity;

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG       width,height;
    ULONG       SizeInWidth;
    ULONG       NumDwords;
    ULONG       NumBytesPerScan;
    ULONG       Color1;
    USHORT      FreeCount;
    ULONG       NumDwordsPerGlyph;
    ULONG       AlphaEnableValue;
    ULONG       LocalClipResetFlag;

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // Get first freecount
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Since we are using Class D of the monster text class, we don't
    // have to specify color 0 (It's always transparent)
    // We only need to get and specify the color for the '1' bits.
    //**************************************************************************

    Color1 = pboFore->iSolidColor   | ( AlphaEnableValue); // Visible

    //**************************************************************************
    // Must make sure that ROP is set correctly
    //**************************************************************************

    while (FreeCount < 1*4)
         FreeCount = nv->subchannel[ROP_SOLID_SUBCHANNEL].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = NV_SRCCOPY ;

    //**************************************************************************
    // Performance Optimization: Only specify the clipping rectangle
    // if necessary.  A nonzero value means that we need to resend it to hardware.
    //**************************************************************************

    LocalClipResetFlag = 1;

    do  {

        //**********************************************************************
        // pstro->pgp points to the GLYPHPOS array for the whole string.
        // If it is NONZERO, then enumeration is not needed.  There's
        // just one batch of glyphs
        //**********************************************************************

        if (pstro->pgp != NULL)

            {
            //******************************************************************
            // There's only the one batch of glyphs, so save ourselves
            // a call:
            //
            // pgpOriginal   --> GLYPHPOS (contains glyph definition and src origin
            // cGlyphOriginal -> Number of glyphs in the string object
            // bMoreGlyphs    -> Since there's only one batch, don't enumerate
            //******************************************************************

            pgpOriginal    = pstro->pgp;
            cGlyphOriginal = pstro->cGlyphs;
            bMoreGlyphs    = FALSE;
            }

        else

            {
            //******************************************************************
            // Get next batch of GLYPHPOS structures
            //******************************************************************
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
            }

        //**********************************************************************
        // Check if we have any glyphs to output
        //**********************************************************************

        if (cGlyphOriginal > 0)
            {
            //******************************************************************
            // If ulCharInc is NONZERO, then we have a fixed-pitch
            // (monospace) font.  Just add this value to get position of next char
            //******************************************************************

            ulCharInc = pstro->ulCharInc;

            //******************************************************************
            // Check whether we need to do clipping or not
            //******************************************************************

            iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

            if (iDComplexity != DC_COMPLEX)
                {
                //**************************************************************
                // We could call 'cEnumStart' and 'bEnum' when the clipping is
                // DC_RECT, but the last time I checked, those two calls took
                // more than 150 instructions to go through GDI.  Since
                // 'rclBounds' already contains the DC_RECT clip rectangle,
                // and since it's such a common case, we'll special case it:
                //**************************************************************

                //**************************************************************
                // ce => Clip enumeration structure, consists of c (count)
                //       and an array of rectangle structures
                // Specify bmore = FALSE because we have one clipping structure
                //**************************************************************

                bMore = FALSE;
                ce.c  = 1;

                //**************************************************************
                // grclMax essentially means to ignore clipping
                // Otherwise, use the bounds specified in the CLIP Object
                //**************************************************************

                if (iDComplexity == DC_TRIVIAL)
                    prclClip = &grclMax;
                else
                    prclClip = &pco->rclBounds;

                //**************************************************************
                // Skip ahead and handle one clipping rectangle
                //**************************************************************
                goto SingleRectangle;
                }

            //******************************************************************
            // pco           -> Clip Object
            // FALSE         -> only parts relevant to the current drawing
            //                  operation should be enumerated.  Otherwise,
            //                  the whole region should be enumerated (TRUE)
            // CT_RECTANGLES -> Region is to be enumerated as a list of
            //                  rectangles
            //******************************************************************

            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

            //******************************************************************
            // Get the next clip rectangle to be enumerated from clip region.
            // (ce holds the clip rectangle)
            //******************************************************************

            do  {
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                //**************************************************************
                // Draw glyphs for each clipping rectangle
                //**************************************************************

                for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)

                    {
SingleRectangle:
                    pgp    = pgpOriginal;           // GLYPHPOS structure
                    cGlyph = cGlyphOriginal;        // Number of glyphs
                    pgb    = pgp->pgdf->pgb;        // Ptr to GLYPHBITS structure

                    //**********************************************************
                    // Origin = Origin of char in bitmap + position on screen
                    //**********************************************************

                    ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
                    ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

                    //**********************************************************
                    // Loop through all the glyphs for this rectangle:
                    //**********************************************************

                    while (TRUE)
                        {
                        //******************************************************
                        // Get the size (in pixels) of the monochrome bitmap
                        //******************************************************

                        cxGlyph = pgb->sizlBitmap.cx;
                        cyGlyph = pgb->sizlBitmap.cy;

                        //******************************************************
                        // Get pointer to BYTE aligned glyph bitmap
                        //******************************************************

                        pjGlyph = pgb->aj;

                        //******************************************************
                        // Check if this glyph lies completely within
                        // the clipping rectangle.
                        //******************************************************

                        if ((prclClip->left   <= ptlOrigin.x) &&
                            (prclClip->top    <= ptlOrigin.y) &&
                            (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                            (prclClip->bottom >= ptlOrigin.y + cyGlyph))
                            {

                            //**************************************************
                            // Unclipped glyph
                            //**************************************************

                            //**************************************************
                            // Specify SizeInWidth as multiple of 32 since
                            // we always output DWORDS at a time. The excess
                            // pixels will get clipped according to the width
                            // we specify in Size. SizeInWidth corresponds to the
                            // amount of data that the NV Engine expects.
                            //**************************************************

                            width = cxGlyph;
                            height= cyGlyph;
                            SizeInWidth = (width + 31) & 0xffe0;
                            NumBytesPerScan = (width+7) >> 3;   // Divide by 8

                            //**************************************************
                            // As far as I can tell, the beginning of the
                            // glyph (according to the GLYPHBITS structure)
                            // appears to always start on a DWORD boundary.
                            // In addition, the DDK specifies that the bits
                            // will always be DWORD padded at the end.
                            // So let's just deal with DWORDS for performance.
                            // Otherwise, use the slow byte-by-byte routine.
                            //**************************************************

                            //**************************************************
                            // Calculate total number of DWORDS NV engine expects
                            // to receive for this glyph.  Add 3 so that
                            // 1->4 bytes means 1 dword, 5-8 bytes means 2 dwords..etc..
                            //**************************************************

                            NumDwordsPerGlyph = ((NumBytesPerScan*height)+3) >> 2 ; // Divide by 4

                            //**************************************************
                            // Specify SizeInWidth as multiple of 8 since
                            // the incoming glyph data is always row ordered
                            // and BYTE packed. We will always output up to a
                            // BYTE boundary. The excess pixels will get clipped
                            // according to the width we specify in Size.
                            // 'SizeIn' corresponds to the amount of data
                            // that the NV Engine expects to receive, and it
                            // specifies how the data will be layed out on the
                            // screen.. 'Size' just corresponds to the clipping
                            // rectangle. Add 7 so that 1->8 means 8, 9-16 means 16, etc...
                            //**************************************************

                            SizeInWidth = (width + 7) & 0xfff8;

                            //**************************************************
                            // Only send the clip rectangle if this is the first
                            // time, or we've changed the state of the hardware
                            // (by using another class).  Otherwise, we don't
                            // have to constantly send these values thru the FIFO.
                            //**************************************************

                            if (LocalClipResetFlag)
                                {
                                while (FreeCount < 3*4)
                                    FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
                                FreeCount -= 3*4;

                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint0D = ((0 << 16) | 0);
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint1D = ( ((ppdev->cyMemory)<<16) | (ppdev->cxMemory) ) ;
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color1D = Color1;

                                LocalClipResetFlag=0;
                                }


                            while (FreeCount < 3*4)
                               FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
                            FreeCount -= 3*4;

                            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeInD = ( (height <<16) | SizeInWidth );
                            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeOutD = ( (height <<16) | width );
                            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.PointD =  ( ((ptlOrigin.y) <<16) | ((ptlOrigin.x) & 0xffff) );


                            //**************************************************
                            // Get pointer to monochrome bitmap
                            //**************************************************

                            myGlyph = (DWORD *)pjGlyph;

                            //**************************************************
                            // Check if Bitmap pointer is DWORD aligned
                            //**************************************************

                            ASSERTDD( (((ULONG_PTR)pjGlyph & 3) == 0), "NOT dword aligned !!!");

                            //**************************************************
                            // Blast out the data as fast as possible
                            // in assembly routine
                            //**************************************************
// IA64 Assembly is NOT feasible under IA64
#ifndef _WIN64
                            NV3_Transfer_Text_Data(NumDwordsPerGlyph,&FreeCount,&myGlyph[0],nv);
#endif

                            }

                        else

                            {

                            //**************************************************
                            // Clipped glyph
                            //**************************************************

                            //**************************************************
                            // Find the intersection of the glyph rectangle
                            // and the clip rectangle:
                            //**************************************************

                            xLeft   = max(prclClip->left,   ptlOrigin.x);
                            yTop    = max(prclClip->top,    ptlOrigin.y);
                            xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                            yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                            //**************************************************
                            // Check for trivial rejection:
                            //**************************************************

                            if (((cx = xRight - xLeft) > 0) &&
                                ((cy = yBottom - yTop) > 0))
                                {
                                //**********************************************
                                // Specify the hardware clipping rectangle
                                //**********************************************

                                while (FreeCount < 2*4)
                                   FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
                                FreeCount -= 2*4;

                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint0D = (((prclClip->top) << 16) | ((prclClip->left)&0xffff) );
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint1D = ((prclClip->bottom <<16) | ((prclClip->right&0xffff)));


                                //**********************************************
                                // The clipping rectangle has changed.
                                // We need to re-specify it if we subsequently
                                // draw unclipped text
                                //**********************************************

                                LocalClipResetFlag=1;


                                width = cxGlyph;
                                height= cyGlyph;
                                SizeInWidth = (width + 31) & 0xffe0;
                                NumBytesPerScan = (width+7) >> 3;   // Divide by 8
                                NumDwords = (width + 31) >> 5;      // Divide by 32

                                //**********************************************
                                // As far as I can tell, the beginning of the
                                // glyph (according to the GLYPHBITS structure)
                                // appears to always start on a DWORD boundary.
                                // In addition, the DDK specifies that the bits
                                // will always be DWORD padded at the end.
                                // So let's just deal with DWORDS for performance.
                                // Otherwise, use the slow byte-by-byte routine.
                                //**********************************************

                                //**********************************************
                                // Calculate total number of DWORDS NV engine expects
                                // to receive for this glyph.  Add 3 so that
                                // 1->4 bytes means 1 dword, 5-8 bytes means 2 dwords..etc..
                                //**********************************************

                                NumDwordsPerGlyph = ((NumBytesPerScan*height)+3) >> 2; // Divide by 4

                                //**********************************************
                                // Specify SizeInWidth as multiple of 8 since
                                // the incoming glyph data is always row ordered
                                // and BYTE packed. We will always output up to a
                                // BYTE boundary. The excess pixels will get clipped
                                // according to the width we specify in Size.
                                // 'SizeIn' corresponds to the amount of data
                                // that the NV Engine expects to receive, and it
                                // specifies how the data will be layed out on the
                                // screen.. 'Size' just corresponds to the clipping
                                // rectangle. Add 7 so that 1->8 means 8, 9-16 means 16, etc...
                                //**********************************************

                                SizeInWidth = (width + 7) & 0xfff8;

                                //**********************************************
                                // Set the ALPHA bits to make the color visible.
                                // Clear the ALPHA bits to make the color transparent.
                                // 8bpp is in  X16A8Y8 format
                                // 16bpp is in A1R5G5B5 format
                                // 32bpp is in A8R8G8B8 format
                                //**********************************************

                                while (FreeCount < 4*4)
                                   FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
                                FreeCount -= 4*4;

                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color1D = Color1;
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeInD = ( (height <<16) | SizeInWidth );
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeOutD = ( (height <<16) | width );
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.PointD =  ( ((ptlOrigin.y) <<16) | ((ptlOrigin.x) & 0xffff) );

                                //**********************************************
                                // Get pointer to monochrome bitmap
                                //**********************************************

                                myGlyph = (DWORD *)pjGlyph;

                                //**********************************************
                                // Check if Bitmap pointer is DWORD aligned
                                //**********************************************

                                ASSERTDD( (((ULONG_PTR)pjGlyph & 3) == 0), "NOT dword aligned !!!");

                                //**********************************************
                                // Blast out the data as fast as possible
                                // in assembly routine
                                //**********************************************

// IA64 Assembly is NOT feasible under IA64
#ifndef _WIN64
                                NV3_Transfer_Text_Data(NumDwordsPerGlyph,&FreeCount,&myGlyph[0],nv);
#endif

                                }  // cx=xright-xleft

                            } // clipped glyph

                        if (--cGlyph == 0)
                            break;

                        //******************************************************
                        // Get ready for next glyph:
                        //******************************************************

                        pgp++;
                        pgb = pgp->pgdf->pgb;

                        if (ulCharInc == 0)
                            {
                            ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                            ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
                            }
                        else
                            {
                            ptlOrigin.x += ulCharInc;
                            }

                        }  // while TRUE...

                    } // For prclClip...

                } while (bMore);  // do while loop

            } // if (cglyphoriginal)...

        } while (bMoreGlyphs); // main do while loop

    //**************************************************************************
    // Make sure to update the global cached free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    }



//******************************************************************************
//
// Function: NV3TextOut()
//
// Routine Description:
//
//   Outputs text using the 'buffer expansion' method.  The CPU draws to a
//   1bpp buffer, and the result is colour-expanded to the screen using the
//   hardware.
//
//   Note that this is x86 only ('vFastText', which draws the glyphs to the
//   1bpp buffer, is writen in Asm).
//
//   If you're just getting your driver working, this is the fastest way to
//   bring up working accelerated text.  All you have to do is write the
//   'Xfer1bpp' function that's also used by the blt code.  This
//   'bBufferExpansion' routine shouldn't need to be modified at all.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//******************************************************************************


BOOL NV3TextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)

    {
    PDEV*           ppdev;
    BYTE            iDComplexity;
    RECTL           rclOpaque;

    Nv3ChannelPio   *nv;
    ULONG   x,y;
    ULONG   width,height;
    USHORT  FreeCount;
    ULONG   AlphaEnableValue;

    //*************************************************************************
    // Initialize NV specific pointers
    //*************************************************************************

    ppdev = (PDEV*) pso->dhpdev;
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    //*************************************************************************
    // Initialize NV specific registers
    //*************************************************************************

    nv = (Nv3ChannelPio *)ppdev->pjMmBase;

    //*************************************************************************
    // Get first FreeCount
    //*************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //*************************************************************************
    // Determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;


    //*************************************************************************
    // Check if we need to draw the opaque rectangle first
    //*************************************************************************

    if (prclOpaque != NULL)
        {

        //**********************************************************************
        // Opaque Initialization - No clipping necessary
        //**********************************************************************

        while (FreeCount < 2*4)
             FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = NV_SRCCOPY ;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color1A = AlphaEnableValue | pboOpaque->iSolidColor;


        if (iDComplexity == DC_TRIVIAL)
            {

DrawOpaqueRect:

            x = prclOpaque->left;
            y = prclOpaque->top;
            width = prclOpaque->right - prclOpaque->left;
            height = prclOpaque->bottom - prclOpaque->top;

            while (FreeCount < 2*4)
                FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
            FreeCount -= 2*4;

            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.UnclippedRectangle[0].point = ( ((x) << 16) | (y) );
            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.UnclippedRectangle[0].size = ( (width << 16) | height );

            }

        //**********************************************************************
        // Opaque Initialization - Check for single clipping rectangle
        //**********************************************************************

        else if (iDComplexity == DC_RECT)

            {
            if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
                {
                prclOpaque = &rclOpaque;
                goto DrawOpaqueRect;
                }
            }

        else

        //**********************************************************************
        // Opaque Initialization - Check for multiple rectangles to be drawn
        //**********************************************************************

            {
            //******************************************************************
            // WARNING: Make sure to update global freecount here first,because
            //          vClipSolid ALSO updates the FreeCount!
            //******************************************************************

            ppdev->NVFreeCount = FreeCount;

            vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);

            //******************************************************************
            // WARNING: Now make sure our local FreeCount has been updated
            //          because we'll use it below!
            //******************************************************************

            FreeCount = ppdev->NVFreeCount;

            }


        }

    //**************************************************************************
    // Make sure to update global freecount here first, because
    // NV1GeneralText relies on it being set correctly
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    NV3GeneralText(ppdev, pstro, pco, pboFore);

    return(TRUE);

    }

#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4lines.c ===
//******************************************************************************
//
// Module Name: NV4LINES.C
// 
// Contains most of the required GDI line support.  Supports drawing
// lines in short 'strips' when clipping is complex or coordinates
// are too large to be drawn by the line hardware.
// 
// Copyright (c) 1990-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

#define PO_ALL_INTEGERS     0x00000004
#define PO_ENUM_AS_INTEGERS 0x00000008

#define POINT_OUTOFBOUNDS(x,y) \
(\
  ((x) ^ ((int)(x) >> 31) |  \
   (y) ^ ((int)(y) >> 31)  ) \
  & 0xFFFF8000               \
)
//*****************************************************************************
// Externs
//*****************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );


    
//*****************************************************************************
//  Function:     vector_has_tiebreaker_pixels
//  Routine Description: 
//                Checks to see if the line contains pixels which will be
//                affected by tiebreaker rules
//  Arguments:    All coordinates are integer.
//  Return Value: TRUE if tiebreaker pixels exist, FALSE otherwise
//*****************************************************************************
BOOL vector_has_tiebreaker_pixels
(
    LONG x1,
    LONG y1,
    LONG x2,
    LONG y2
)
{
    LONG    delta_x = x2 - x1;
    LONG    delta_y = y2 - y1;

    /*
    ** No tiebreakers in vectors with no minor steps.
    */
    if ((delta_x==0) || (delta_y==0))
        return FALSE;

    /*
    ** Calculate magnitudes of delta_major and delta_minor.
    */
    if (delta_x < 0)
        delta_x = -delta_x;

    if (delta_y < 0)
        delta_y = -delta_y;

    /*
    ** A bresenham pattern repeats "common factors" times over the length of
    ** the vector where "common factors" is the product of the common factors
    ** in delta_x and delta_y.  We don't care about odd common factors because
    ** that case can never create a tiebreaker situation.  We'll refer to this
    ** result of eliminating the 2^n factor as the "2^n reduced slope".
    **
    ** If the "2^n reduced slope" is such that reduced delta_major is EVEN and
    ** reduced delta_minor is ODD then the bresenham will step at least one
    ** case were the pure (not tiebreaker biased) bresenham error will be 0.
    ** 
    ** We don't need the actual reduced delta values.  Since we have already
    ** eliminated the '0' cases, taking the largest 2^n common factor out the
    ** delta_* values results in at least one of them being ODD.  The only way
    ** then for the reduced delta_major to be EVEN and the reduced delta_minor
    ** to be ODD is if delta_major has a larger 2^n factor than delta_minor.
    **
    ** ANDing a number and its 2's complement gives the highest 2^n factor.
    */

    if (delta_x > delta_y)
    {
        // x major vector

        if ((delta_x & -delta_x) > (delta_y & -delta_y))
            return TRUE;
    }
    else
    {
        // y major vector

        if ((delta_y & -delta_y) > (delta_x & -delta_x))
            return TRUE;
    }

    return FALSE;
}

//*****************************************************************************
//
//  Function:   vLinesSimple
//
//  Routine Description:
//
//              Strokes the path.
//
//  Arguments:  All coordinates are integer.
//
//  Return Value:
//
//      None.
//
//*****************************************************************************
VOID vLinesSimple(
PDEV*       ppdev,
PATHOBJ*    ppo,
BRUSHOBJ*  pbo,
RECTL*  prclClip
)
{
    BOOL        bMore;
    PATHDATA    pd;
    LONG        cVertex;
    POINTFIX*   pptfx;
    POINTFIX    ptfxStartFigure = {0, 0};
    ULONG       i;
    DECLARE_DMA_FIFO;
 
    INIT_LOCAL_DMA_FIFO;

    PATHOBJ_vEnumStart(ppo);    
    ppo->fl |= PO_ENUM_AS_INTEGERS;
    
    //**********************************************************
    // Set Point and Size methods for clip:
    //    NV019_SET_POINT
    //    NV019_SET_SIZE
    //**********************************************************
    NV_DMAPUSH_CHECKFREE( ((ULONG)(5)));  
    
    if((prclClip == NULL) && (ppdev->NVClipResetFlag))
    {
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 
        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
    }
    else if(prclClip != NULL)
    {
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = (( prclClip->top << 16) |  prclClip->left);
        NV_DMA_FIFO = (((prclClip->bottom - prclClip->top) << 16) 
                    | (prclClip->right - prclClip->left) ); 
        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
    }
    
    
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_COLOR, pbo->iSolidColor);
    do {
    
        bMore  = PATHOBJ_bEnum(ppo, &pd);
        cVertex = pd.count;
        pptfx  = pd.pptfx;

        //**************************************************************
        // Check if we've got enough room in the push buffer
        //**************************************************************
        
        NV_DMAPUSH_CHECKFREE( ((ULONG)( 4 + cVertex*2 + cVertex / 16 )));  
        
        if (pd.flags & PD_BEGINSUBPATH)
        {
            // New path; can be multiple paths
            ptfxStartFigure.x = pptfx->x;
            ptfxStartFigure.y = pptfx->y;
        
            cVertex--;
            pptfx++;
        }
  
        NV_DMAPUSH_START( 4, SOLID_LIN_SUBCHANNEL, NV05C_LIN32(0));
        NV_DMA_FIFO = ptfxStartFigure.x;
        NV_DMA_FIFO = ptfxStartFigure.y;
        NV_DMA_FIFO = pptfx->x;
        NV_DMA_FIFO = pptfx->y;
        
        if(--cVertex)
            pptfx++;
        
        while(cVertex > 16)
        {
            NV_DMAPUSH_START(32, SOLID_LIN_SUBCHANNEL, NV05C_POLY_LIN32(0));
        
            for(i = 0; i < 16; i++, --cVertex)
            {
                NV_DMA_FIFO = pptfx->x;
                NV_DMA_FIFO = pptfx->y;
        
                pptfx++;
            }
        }
        
        if(cVertex > 0)
        {
            NV_DMAPUSH_START( 2*cVertex, SOLID_LIN_SUBCHANNEL, NV05C_POLY_LIN32(0));
            while (cVertex > 0)
            {
                NV_DMA_FIFO = pptfx->x;
                NV_DMA_FIFO = pptfx->y;
                if(--cVertex)
                    pptfx++;
            }
        }

        if (pd.flags & PD_CLOSEFIGURE)
        {
            pd.flags &= ~PD_CLOSEFIGURE;
            NV_DMAPUSH_START( 2, SOLID_LIN_SUBCHANNEL, NV05C_POLY_LIN32(0));
            NV_DMA_FIFO = ptfxStartFigure.x;
            NV_DMA_FIFO = ptfxStartFigure.y;
        }
        
        if(!bMore) break;
        
        // Multiple paths
        ptfxStartFigure.x = pptfx->x;
        ptfxStartFigure.y = pptfx->y;
            
    } while (1);
    
    //******************************************************************
    // Update global push buffer count
    //******************************************************************
    
    UPDATE_PDEV_DMA_COUNT;

    //******************************************************************
    // Send data on thru to the DMA push buffer
    //******************************************************************

    NV4_DmaPushSend(ppdev);
}


//*****************************************************************************
//
//  Function:   NV4DmaPushStrokePath
//
//  Routine Description:
//
//              Strokes the path.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************

BOOL NV4DmaPushStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)

    {
    PDEV*       ppdev;
    DSURF*      pdsurf;
    RECTL       arclClip[4];                  // For rectangular clipping

    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    PuntPtr;

    BOOL        bMore;
    ULONG       VertexCount;
    POINTFIX    *CurrentVertexPtr;
    POINTFIX    *FirstVertexPtr;
    POINTFIX    *NextVertexPtr;
    POINTFIX    *LastVertexPtr;

    POINTFIX    *CurrPt = NULL;
    POINTFIX    *PrevPt = NULL;
    POINTFIX    *FrstPt = NULL;
    POINTFIX    *LastPt = NULL;

    LONG        x0,y0;
    LONG        x1,y1;
    ULONG       width,height;
    ULONG       AlphaEnableValue;
    PATHDATA    pd;
    ULONG       temp;
    ULONG       LineVisibleFlag;
    ULONG       Rop3;
    ULONG       i;
    LONG        curX, curY;
    BYTE        jClip;
    RECTFX      BoundingRect;

    DECLARE_DMA_FIFO;


    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Default to the original surface object passed in to us
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = ppdev->psoPunt;

    pdsurf = (DSURF*) pso->dhsurf;

    //**************************************************************************
    // As of NT 4.0 SP2, the rasterization convention has been loosened
    // for paths that have the PO_ALL_INTEGERS flag set.  For those paths,
    // you may do the 'tie-breaker' pixels anyway you like, which usually
    // means that you can use the point-to-point line drawing capabilities
    // of the hardware.
    //**************************************************************************
    if ((ppo->fl & PO_ALL_INTEGERS) &&      // Points must be integer
        !(pla->fl & LA_STYLED))             // Solid lines, no styles
    {
        CLIPENUM  ce;
    
        //**************************************************************************
        //  Check that the points sent to us are not going to be out
        //  of range for our hardware. Also check that the lines to be drawn
        //  don't have tiebreakers, since hw handles tiebreakers differently from
        //  NT4/W2K gdi.  
        //**************************************************************************
        PATHOBJ_vEnumStart(ppo);
        ppo->fl |= PO_ENUM_AS_INTEGERS;
        do
        {
            pd.flags = 0;
            bMore = PATHOBJ_bEnum(ppo, &pd);
            CurrPt = &(pd.pptfx[0]);
            if (POINT_OUTOFBOUNDS(CurrPt->x,CurrPt->y))
                goto DMAPUSH_GDI_StrokePathIt;


            if (pd.flags & PD_BEGINSUBPATH || LastPt == NULL)
            {
                FrstPt = CurrPt;
                PrevPt = CurrPt;
                CurrPt++;
                pd.count --;
            }
            else
            {
                FrstPt = LastPt;
                PrevPt = LastPt;
            }

            // check first line to get count/ptrs coordinated. There will always be at
            // least one line
            if (vector_has_tiebreaker_pixels(CurrPt->x,CurrPt->y,PrevPt->x,PrevPt->y) ||
                POINT_OUTOFBOUNDS(CurrPt->x,CurrPt->y))
            {
                goto DMAPUSH_GDI_StrokePathIt;
            }

            pd.count --;
            PrevPt = CurrPt;
            while (pd.count)
            {
                CurrPt++;
                if (vector_has_tiebreaker_pixels(CurrPt->x,CurrPt->y,PrevPt->x,PrevPt->y) ||
                    POINT_OUTOFBOUNDS(CurrPt->x,CurrPt->y))
                {
                    goto DMAPUSH_GDI_StrokePathIt;
                }
                PrevPt++;
                pd.count--;
            }

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (vector_has_tiebreaker_pixels(CurrPt->x,CurrPt->y,FrstPt->x,FrstPt->y))
                {
                    goto DMAPUSH_GDI_StrokePathIt;
                }
            }
            LastPt = CurrPt;

        } while (bMore);

        NV_DMAPUSH_CHECKFREE(( (ULONG) (4) ));  
    
        if(ppdev->dDrawSpareSubchannelObject != DD_IMAGE_ROP_AND_LIN)
        {
            NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_ROP_AND_LIN);
            ppdev->dDrawSpareSubchannelObject     = DD_IMAGE_ROP_AND_LIN;
        }

        //**************************************************************
        // Reset clipping rectangle to full screen extents if necessary
        // Resetting the clipping rectangle causes delays so we want to
        // do it as little as possible!
        //**************************************************************
    
                                  
        Rop3 = (mix & 0x0f) - 1;
        Rop3 |= (Rop3 << 4);
    
        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);
    
    
        UPDATE_PDEV_DMA_COUNT;
    
        if (pco->iDComplexity == DC_TRIVIAL)
        {
            vLinesSimple(ppdev, ppo, pbo, NULL);
            return(TRUE);
        }
        else
        {
            if (pco->iDComplexity == DC_RECT)
            {
                vLinesSimple(ppdev, ppo, pbo, &pco->rclBounds);
            }
            else
            {
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN,
                                   0);

                do {
                    // Get a batch of region rectangles:

                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*) &ce);
                    for (i = 0; i < (ULONG)ce.c; i++)
                    {
                        vLinesSimple(ppdev, ppo, pbo, &ce.arcl[i]);
                    }
                } while (bMore);
            }
            return(TRUE);
        }
        return(TRUE);
    }

    //**************************************************************************
    // Only SIMPLE, STRAIGHT lines implemented, the rest go thru GDI
    //
    // If we get to this point, the line is to be drawn onscreen
    // We'll currently use NV hardware to ONLY draw straight integer lines.
    // (Because #1) The line object is not yet implemented, just the solid
    //              rectangle object, so we'll use that to draw only straight lines
    //          #2) Currently don't have time to verify the lines are drawn
    //              exactly correct.  We'll just handle the extremely simple
    //              lines, and let GDI worry about the rest.
    //**************************************************************************

    //**************************************************************************
    // ONLY handle solid single pixel wide lines
    // Line Style is solid if pstyle array ptr is NULL
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;
    else
        jClip = pco->iDComplexity;

    if ((pla->pstyle == (FLOAT_LONG*) NULL) && !(pla->fl & (LA_GEOMETRIC | LA_ALTERNATE)))
        {

        //**********************************************************************
        // ONLY handle non-clipped lines or single rectangle clipped lines
        //**********************************************************************

        if ((jClip == DC_TRIVIAL) || (jClip == DC_RECT))
            {
            //******************************************************************
            // If this is a mix which uses the destination, then we cannot punt to GDI
            // in the middle of a path enumeration since GDI will draw the same lines
            // which we have already drawn. So we MUST prescan the list of lines in the
            // path to ensure that none of the vertices in the path have a fractional
            // component, and that ALL of the lines are either horiz or vert. For now
            // we'll just check for a SRCCOPY mix.
            //******************************************************************
            if ((mix & 0xf) != R2_COPYPEN)
            {
                PATHOBJ_vEnumStart(ppo);
                do
                {
                    pd.flags = 0;
                    bMore = PATHOBJ_bEnum(ppo, &pd);
                    curX = pd.pptfx[0].x >> 4;
                    curY = pd.pptfx[0].y >> 4;

                    for (i = 0; i < pd.count; i++)
                    {
                        if ((((pd.pptfx[i].x | pd.pptfx[i].y) & 0xf) != 0) ||
                            !((pd.pptfx[i].x >> 4) == curX || (pd.pptfx[i].y >> 4) == curY))
                            goto DMAPUSH_GDI_StrokePathIt;
                        else
                            {
                            curX = pd.pptfx[i].x >> 4;
                            curY = pd.pptfx[i].y >> 4;
                            }
                    }
                    if (pd.flags & PD_BEGINSUBPATH)
                    {
                        //**********************************************************
                        // Get ptr to coordinates of the first vertex
                        //**********************************************************
                        FirstVertexPtr      = pd.pptfx;
                    }
                    if (pd.flags & PD_CLOSEFIGURE)
                    {
                        if(!((FirstVertexPtr->x >> 4) == curX || (FirstVertexPtr->y >> 4) == curY))
                            goto DMAPUSH_GDI_StrokePathIt;
                    }
                } while (bMore);
            }

            //******************************************************************
            // First, copy the clipping rectangle if it's present
            //******************************************************************

            if (jClip == DC_RECT)
                {
                arclClip[0] = pco->rclBounds;
                }

            //******************************************************************
            // Convert mix to a Rop3 value.
            //******************************************************************
            Rop3 = (mix & 0x0f) - 1;
            Rop3 |= (Rop3 << 4);

            NV_DMAPUSH_CHECKFREE(( (ULONG) (7) ));  
                
            NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

            //**************************************************************
            // Reset clipping rectangle to full screen extents if necessary
            // Resetting the clipping rectangle causes delays so we want to
            // do it as little as possible!
            //**************************************************************
    
            if (ppdev->NVClipResetFlag)
                {
                //**********************************************************
                // Set Point and Size methods for clip:
                //    NV019_SET_POINT
                //    NV019_SET_SIZE
                //**********************************************************
    
                NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
                NV_DMA_FIFO = 0;
                NV_DMA_FIFO = ppdev->dwMaxClip; 
    
                ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
                }

            NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL,
                                  NV04A_COLOR1_A,
                                  pbo->iSolidColor);
    
            PATHOBJ_vEnumStart(ppo);
            do  {

                pd.flags = 0;

                //**************************************************************
                // Get the current group of lines
                //**************************************************************

                bMore = PATHOBJ_bEnum(ppo, &pd);

                //**************************************************************
                // Get number of vertices in this record.
                //**************************************************************

                VertexCount = pd.count;

                //**************************************************************
                // Check if we've got enough room in the push buffer
                //**************************************************************
    
                NV_DMAPUSH_CHECKFREE(((ULONG)(5 + (VertexCount*4))));  
    
                //**************************************************************
                // Check to see if we need to 'reset' the starting vertex
                //**************************************************************

                if (pd.flags & PD_BEGINSUBPATH)
                    {
                    //**********************************************************
                    // Get ptr to coordinates of the first vertex
                    //**********************************************************

                    CurrentVertexPtr    = pd.pptfx;
                    NextVertexPtr       = pd.pptfx+1;
                    FirstVertexPtr      = pd.pptfx;
                    }

                else

                    {
                    //**********************************************************
                    // Get coordinates of first vertex.
                    // Since we didn't get a BEGIN_SUBPATH notification,
                    // use the last vertex from the last line record
                    // as the first vertex.
                    //**********************************************************

                    CurrentVertexPtr    = LastVertexPtr;
                    NextVertexPtr       = pd.pptfx;

                    // We didn't get a BEGIN_SUBPATH.  Since the next PATHDATA
                    // retreived from the PATHOBJ could have only 1 point in it
                    // (a case that occurs in w2k), if we don't inc the VertexCount,
                    // we will skip a line segment (the joint between the lastvertex
                    // from the last PATHDATA and this 1 point) because the linedrawing
                    // loop will immediatly exit (VertexCount will be < 2).
                    
                    VertexCount++;
                    }


                //**************************************************************
                // Exit if there aren't at least 2 vertices
                //**************************************************************

                if (VertexCount < 2)
                    goto DMAPUSH_NV_LinesAreDone;

                //**************************************************************
                //
                // Save a ptr to the last vertex in this record
                //
                // ( there is no chance of getting a dangling reference because
                //  to pointer saved points to an element of the PATHDATA we
                //  are currently processing. In the next fetch from the PATHOBJ
                // (with PATHOBJ_bEnum), we will get a new PATHDATA, and the 
                // pointer will be invalid, but is not used before we get here
                // again. (And when we get here, we make the ptr valid) )
                //**************************************************************

                
                LastVertexPtr = &( pd.pptfx[ pd.count - 1 ] );


                //**************************************************************
                // Need a minimum of 2 vertices per line
                //**************************************************************

                do  {
                    //**********************************************************
                    // Check each line and see if it's an integer and straight
                    // Get the first PATHDATA record
                    //**********************************************************

                    x0 = CurrentVertexPtr->x;
                    y0 = CurrentVertexPtr->y;

                    x1 = NextVertexPtr->x;
                    y1 = NextVertexPtr->y;

                    //**********************************************************
                    // Send to GDI if we get a non-integer line
                    //**********************************************************

                    if (((x0 | y0 | x1 | y1) & 0xf) != 0)
                        goto DMAPUSH_GDI_StrokePathIt;

                    //**********************************************************
                    // Get rid of fixed fractional component
                    //**********************************************************

                    x0 >>=4;
                    y0 >>=4;
                    x1 >>=4;
                    y1 >>=4;

                    //**********************************************************
                    // Default to always drawing the line
                    //**********************************************************

                    LineVisibleFlag = TRUE;

                    //**********************************************************
                    // Only draw line if it's horizontal or vertical
                    //**********************************************************

                    if (x0==x1)

                        {
                        //******************************************************
                        // We're dealing with a VERTICAL line
                        // Make sure to calculate a positive height and
                        // swap the coordinates if necessary
                        //******************************************************

                        width=1;
                        if (y0 > y1)
                            {
                            temp=y0;
                            y0=y1+1;
                            y1=temp+1;
                            }

                        //******************************************************
                        // Vertical Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((x0 < arclClip[0].left) || (x0 >= arclClip[0].right) ||
                                (y1 <= arclClip[0].top) || (y0 >= arclClip[0].bottom))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the height.
                                //**********************************************

                                if (y1 > arclClip[0].bottom)
                                    y1 = arclClip[0].bottom;

                                if (y0 < arclClip[0].top)
                                    y0 = arclClip[0].top;
                                }
                            }
                        height = y1 - y0;
                        }

                   else if (y0==y1)

                        {
                        //******************************************************
                        // We're dealing with a HORIZONTAL line
                        // Make sure to calculate a positive width and
                        // swap the coordinates if necessary
                        //******************************************************

                        height=1;
                        if (x0 > x1)
                            {
                            temp=x0;
                            x0=x1+1;
                            x1=temp+1;
                            }

                        //******************************************************
                        // Horizontal Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((y0 < arclClip[0].top) || (y0 >= arclClip[0].bottom) ||
                                (x1 <= arclClip[0].left) || (x0 >= arclClip[0].right))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the width.
                                //**********************************************

                                if (x1 > arclClip[0].right)
                                    x1 = arclClip[0].right;

                                if (x0 < arclClip[0].left)
                                    x0 = arclClip[0].left;

                                }
                            }
                        width = x1 - x0;
                        }

                    else

                        {
                        //******************************************************
                        // This group of lines contains a NON straight line.
                        // Just punt it back to GDI
                        //******************************************************
                        goto DMAPUSH_GDI_StrokePathIt;

                        }

                    //**********************************************************
                    // Time to output a straight line if visible
                    //**********************************************************

                    if (LineVisibleFlag == TRUE)
                        {
                        DISPDBG((6,"x,y: %x %x h,w: %x %x", x0, y0, height, width));

                        //******************************************************
                        // Set Point and Size methods for rectangle:
                        //******************************************************

                        NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL,
                                          NV04A_UNCLIPPED_RECTANGLE_POINT(0))

                        NV_DMA_FIFO = (x0 << 16) | (y0 & 0xffff);
                        NV_DMA_FIFO = ( width << (16) | height );
                        
                        //******************************************************
                        // Advance to next line (must have at least 2 vertices)
                        //******************************************************
                        }

                    VertexCount--;

                    CurrentVertexPtr = NextVertexPtr;
                    NextVertexPtr++;

                    } while (VertexCount >= 2);

                //**************************************************************
                // Draw closing line if specified and if it's straight
                //**************************************************************

                if (pd.flags & PD_CLOSEFIGURE)
                    {

                    x0 = LastVertexPtr->x;
                    y0 = LastVertexPtr->y;

                    x1 = FirstVertexPtr->x;
                    y1 = FirstVertexPtr->y;

                    //**********************************************************
                    // Send to GDI if we get a non-integer line
                    //**********************************************************

                    if (((x0 | y0 | x1 | y1) & 0xf) != 0)
                        goto DMAPUSH_GDI_StrokePathIt;

                    //**********************************************************
                    // Get rid of fixed fractional component
                    //**********************************************************

                    x0 >>=4;
                    y0 >>=4;
                    x1 >>=4;
                    y1 >>=4;

                    //**********************************************************
                    // Default to always drawing the closing line
                    //**********************************************************

                    LineVisibleFlag = TRUE;

                    //**********************************************************
                    // Make sure line is straight!
                    //**********************************************************

                    if (x0==x1)

                        {
                        //******************************************************
                        // We're dealing with a VERTICAL line
                        // Make sure to calculate a positive height and
                        // swap the coordinates if necessary
                        //******************************************************

                        width=1;
                        if (y0 > y1)
                            {
                            temp=y0;
                            y0=y1+1;
                            y1=temp+1;
                            }

                        //******************************************************
                        // Vertical Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((x0 < arclClip[0].left) || (x0 >= arclClip[0].right) ||
                                (y1 <= arclClip[0].top) || (y0 >= arclClip[0].bottom))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the height.
                                //**********************************************

                                if (y0 < arclClip[0].top)
                                    y0 = arclClip[0].top;

                                if (y1 > arclClip[0].bottom)
                                    y1 = arclClip[0].bottom;
                                }
                            }
                        height = y1 - y0;
                        }

                   else if (y0==y1)

                        {
                        //******************************************************
                        // We're dealing with a HORIZONTAL line
                        // Make sure to calculate a positive width and
                        // swap the coordinates if necessary
                        //******************************************************

                        height=1;
                        if (x0 > x1)
                            {
                            temp=x0;
                            x0=x1+1;
                            x1=temp+1;
                            }

                        //******************************************************
                        // Horizontal Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((y0 < arclClip[0].top) || (y0 >= arclClip[0].bottom) ||
                                (x1 <= arclClip[0].left) || (x0 >= arclClip[0].right))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the width.
                                //**********************************************

                                if (x0 < arclClip[0].left)
                                    x0 = arclClip[0].left;

                                if (x1 > arclClip[0].right)
                                    x1 = arclClip[0].right;
                                }
                            }
                        width = x1 - x0;
                        }


                    else

                        {
                        //******************************************************
                        // This group of lines contains a NON straight line.
                        // Just punt it back to GDI
                        //******************************************************
                        goto DMAPUSH_GDI_StrokePathIt;

                        }


                    //**********************************************************
                    // Time to output a straight line if visible
                    //**********************************************************

                    if (LineVisibleFlag == TRUE)
                        {
                        DISPDBG((6,"x,y: %x %x h,w: %x %x", x0, y0, height, width));

                        //******************************************************
                        // Set Point and Size methods for rectangle:
                        //******************************************************

                        NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL,
                                          NV04A_UNCLIPPED_RECTANGLE_POINT(0))

                        NV_DMA_FIFO = (x0 << 16) | (y0 & 0xffff);
                        NV_DMA_FIFO = ( width << (16) | height );
                        
                        }

                    }

                } while (bMore) ;

DMAPUSH_NV_LinesAreDone:
            //******************************************************************
            // Update global push buffer count
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            
            //******************************************************************
            // Send data on thru to the DMA push buffer
            //******************************************************************

            NV4_DmaPushSend(ppdev);

            return(TRUE);

            } // Only handle non-clipped lines or lines clipped to a single rectangle


        } // Only handle solid-lines


    //**************************************************************************
    // Send all other lines thru GDI
    //**************************************************************************

DMAPUSH_GDI_StrokePathIt:

    if (pdsurf !=0)

        {

        //******************************************************************
        // This is an offscreen DFB (DT_SCREEN).  Let GDI draw the line
        // using the wrapper 'punt' surface object
        //******************************************************************

        PuntPtr->dhsurf = 0;               // Behave like a standard DIB
        PuntPtr->sizlBitmap = pdsurf->sizl;

        //******************************************************************
        // Set linear offset and stride for source and destination buffers
        //******************************************************************

        PuntPtr->cjBits  = pdsurf->LinearStride * pdsurf->sizl.cy;
        PuntPtr->pvBits  = pdsurf->LinearPtr;
        PuntPtr->pvScan0 = pdsurf->LinearPtr;
        PuntPtr->lDelta  = pdsurf->LinearStride;

        PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;

        TempDstSurfObjPtr = PuntPtr;

        }

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;
    
    NV4_DmaPushSend(ppdev);

    ppdev->pfnWaitEngineBusy(ppdev);
    return(EngStrokePath(TempDstSurfObjPtr, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));


    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4linto.c ===
//*****************************Module*Header************************************
// 
// Module Name: NV4LINTO.C
// 
// DrvLineTo for NV driver
// 
// Copyright (c) 1995-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

//*****************************************************************************
// Externs
//*****************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

// The our hardware clipping coordinates are limited to 16-bit signed values:



/******************************Public*Routine******************************\
* VOID vLineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line.
*
\**************************************************************************/

VOID vLineToTrivial(
PDEV*       ppdev,
LONG        x1,              // Passed in x1
LONG        y1,              // Passed in y1
LONG        x2,             // Passed in x2
LONG        y2,             // Passed in y2
ULONG       iSolidColor,
MIX         mix)
{
    ULONG       Rop3;
    
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************
    
    INIT_LOCAL_DMA_FIFO;
    
    NV_DMAPUSH_CHECKFREE(( (ULONG) (11) ));  

    if(ppdev->dDrawSpareSubchannelObject != DD_IMAGE_ROP_AND_LIN)
        {
        NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_ROP_AND_LIN);
        ppdev->dDrawSpareSubchannelObject     = DD_IMAGE_ROP_AND_LIN;
        }

    //**************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to
    // do it as little as possible!
    //**************************************************************
    
                              
    Rop3 = (mix & 0x0f) - 1;
    Rop3 |= (Rop3 << 4);
    
    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_COLOR, iSolidColor);

    NV_DMAPUSH_START( 4, SOLID_LIN_SUBCHANNEL, NV05C_LIN32(0));
    NV_DMA_FIFO = x1;
    NV_DMA_FIFO = y1;
    NV_DMA_FIFO = x2;
    NV_DMA_FIFO = y2;
    
    //******************************************************************
    // Update global push buffer count
    //******************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //******************************************************************
    // Send data on thru to the DMA push buffer
    //******************************************************************

    NV4_DmaPushSend(ppdev);
    
    return;
}



//*****************************************************************************
//
//  Function:   NV4DmaPushLineTo
//
//  Routine Description:
//
//          Draws a single solid integer-only cosmetic line.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************


BOOL NV4DmaPushLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)

    {
    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    PuntPtr;
    
    PDEV*       ppdev;
    DSURF*      pdsurf;
    ULONG       *DstBits;
    ULONG       *ScreenBitmap;
    RECTL*      prclClip;
    ULONG       ulHeight, ulWidth;
    BOOL        bMore;
    CLIPENUM    ce;
    LONG        c;

    
    DECLARE_DMA_FIFO;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;
    
    //**************************************************************************
    // Default to the original surface object passed in to us
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = ppdev->psoPunt;

    //**************************************************************************
    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:
    //**************************************************************************

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf !=0)
        {

        //**********************************************************************
        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:
        //**********************************************************************

        if (pdsurf->dt == DT_DIB)
            {
            //******************************************************************
            // NOTE: We use pdsurf->pso, NOT just pso, because this is
            //       a DFB that exists in system memory.
            //******************************************************************
            ppdev->pfnWaitEngineBusy(ppdev);
            return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix));

            }
        }

    //*************************************************************************
    // Only handle line drawing to VRAM.  Send lines drawn
    // to system memory back to GDI.
    //*************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

    if ((pdsurf == 0) && (DstBits != ScreenBitmap))
        goto DMAPUSH_GDI_EngLineToIt;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    ulHeight = prclBounds->bottom - prclBounds->top;
    ulWidth = prclBounds->right - prclBounds->left;
    
    if ((prclBounds->left   < MIN_INTEGER_BOUND) ||
        (prclBounds->top    < MIN_INTEGER_BOUND) ||
        (ulHeight           > MAX_INTEGER_BOUND) ||
        (ulWidth            > MAX_INTEGER_BOUND))
        {
        goto DMAPUSH_GDI_EngLineToIt;
        }
    if (pco == NULL)
        {
        if (ppdev->NVClipResetFlag)
            {
            NV_DMAPUSH_CHECKFREE(( (ULONG) (3) ));  
            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = 0;
            NV_DMA_FIFO = ppdev->dwMaxClip; 
            ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
            }
        
        UPDATE_PDEV_DMA_COUNT;
        vLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix);
        
        return(TRUE);
        }
    else if (pco->iDComplexity <= DC_RECT) 
        {
        prclClip = &pco->rclBounds;
        ulHeight = prclClip->bottom - prclClip->top;
        ulWidth = prclClip->right - prclClip->left;

        NV_DMAPUSH_CHECKFREE(( (ULONG) (3) ));  
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = (( prclClip->top << 16) |  prclClip->left);
        NV_DMA_FIFO = (( ulHeight << 16) | ulWidth ); 
        UPDATE_PDEV_DMA_COUNT;

        vLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix);

        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset

        return(TRUE);
        }
    else if (pco->iDComplexity == DC_COMPLEX) 
        {
        //**********************************************************
        // Clip region must be enumerated
        //**********************************************************
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do  {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

            c = cIntersect(prclBounds, ce.arcl, ce.c);

            prclClip = ce.arcl;
            while (c--)
                {
                ulHeight = prclClip->bottom - prclClip->top;
                ulWidth = prclClip->right - prclClip->left;

                NV_DMAPUSH_CHECKFREE(( (ULONG) (3) ));  
                NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
                NV_DMA_FIFO = (( prclClip->top << 16) |  prclClip->left);
                NV_DMA_FIFO = (( ulHeight << 16) | ulWidth ); 
                UPDATE_PDEV_DMA_COUNT;

                vLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix);
                INIT_LOCAL_DMA_FIFO;
                prclClip++;
                }
            } while (bMore);

        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
        return(TRUE);

        }
DMAPUSH_GDI_EngLineToIt:

    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************
    if (pdsurf !=0 )
        {
        PuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurf->dt == DT_SCREEN)
            {
            PuntPtr->sizlBitmap  = pdsurf->sizl;

            //*************************************************************
            // Set linear offset and stride for source and destination buffers
            //*************************************************************

            PuntPtr->cjBits  = pdsurf->LinearStride * pdsurf->sizl.cy;
            PuntPtr->pvBits  = pdsurf->LinearPtr;
            PuntPtr->pvScan0 = pdsurf->LinearPtr;
            PuntPtr->lDelta  = pdsurf->LinearStride;

            PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;

            }
        else
            {
            //*************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //*************************************************************
            PuntPtr->sizlBitmap  = pdsurf->pso->sizlBitmap;
            PuntPtr->cjBits      = pdsurf->pso->lDelta * pdsurf->pso->sizlBitmap.cy;
            PuntPtr->pvBits  = pdsurf->pso->pvBits;
            PuntPtr->pvScan0 = pdsurf->pso->pvScan0;
            PuntPtr->lDelta  = pdsurf->pso->lDelta;
            PuntPtr->iBitmapFormat = pdsurf->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempDstSurfObjPtr       = PuntPtr;
        }
        
    ppdev->pfnWaitEngineBusy(ppdev);
    return(EngLineTo(TempDstSurfObjPtr, pco, pbo, x1, y1, x2, y2, prclBounds, mix));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4hw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV4HW.C
//
// Abstract:
//
//     Implements NV4 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "nv32.h"
#include "driver.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif

#include "nv4_ref.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

//******************************************************************************
// We'll add the 565 bitmap format functions here
// (We'll use the NV3 functions for 555 format)
//******************************************************************************

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV4_DmaPushSend(PDEV *);
VOID NV_DmaPush_Wrap(PDEV *, ULONG );
VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG);

VOID MagicDelay (VOID);

#define LOOP_WAIT   450*8

#ifdef _WIN64
VOID MagicDelay (VOID)
{
    volatile int i;

    for (i = 0; i < LOOP_WAIT; i++);
}
#else
VOID MagicDelay (VOID)
{
    _asm              mov     ecx, LOOP_WAIT
    _asm WaitLoop:    loop    WaitLoop
}
#endif


//******************************************************************************
//
// Function: NV4_DmaPushSetSourceBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_DmaPushSetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    DECLARE_DMA_FIFO;

    if ((Offset == ppdev->CurrentSourceOffset) &&
        (Stride == (LONG)ppdev->CurrentSourcePitch))

        return;                 // current settings are correct - just return

    //**************************************************************************
    // Get push buffer information
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;


    //**************************************************************************
    // NOTE: BitBlt/Text/Lines currently assume that there are 2 surface objects
    //       (Surface0 and Surface1).  However, in NV4, instead of 2 surface objects,
    //       there is now JUST 1 surface object (NV4_CONTEXT_SURFACES_2D).
    //**************************************************************************

    //**************************************************************************
    // Make sure that pitch is at least 32 (NV4 requirement for CONTEXT_SURFACES_2D)
    // even when NO source is being used during the blit operation
    // (A newly created ppdev ZERO's out these values)
    //**************************************************************************

    if (ppdev->CurrentDestPitch <= ppdev->ulSurfaceAlign)       // Destination Pitch
        ppdev->CurrentDestPitch = ppdev->ulSurfaceAlign+1;

    if ((ULONG)Stride <= ppdev->ulSurfaceAlign)                        // Source Pitch
        Stride = ppdev->ulSurfaceAlign+1;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(6)));

    //**************************************************************************
    // Setup DSTIMAGE_IN_MEMORY object.
    //**************************************************************************

    if (ppdev->dDrawSpareSubchannelObject != DD_PRIMARY_IMAGE_IN_MEMORY)
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_PRIMARY_IMAGE_IN_MEMORY);
        ppdev->dDrawSpareSubchannelObject     = DD_PRIMARY_IMAGE_IN_MEMORY;
        }

    //**************************************************************************
    // Send methods to DMA push buffer
    //**************************************************************************

    NV_DMAPUSH_START(3, DD_SPARE , NV042_SET_PITCH )
    NV_DMA_FIFO = ((ppdev->CurrentDestPitch <<16) | (Stride));
    NV_DMA_FIFO = Offset;
    NV_DMA_FIFO = ppdev->CurrentDestOffset;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentSourceOffset = Offset;
    ppdev->CurrentSourcePitch  = Stride;

    //**************************************************************************
    // Make sure to update the DMA count before we exit!!
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    }


//******************************************************************************
//
// Function: NV4_DmaPushSetDestBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_DmaPushSetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {

    DECLARE_DMA_FIFO;

    if ((Offset == ppdev->CurrentDestOffset) &&
        (Stride == (LONG)ppdev->CurrentDestPitch))

        return;                 // current settings are correct - just return

    //**************************************************************************
    // Get push buffer information
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;


    //**************************************************************************
    // NOTE: BitBlt/Text/Lines currently assume that there are 2 surface objects
    //       (Surface0 and Surface1).  However, in NV4, instead of 2 surface objects,
    //       there is now JUST 1 surface object (NV4_CONTEXT_SURFACES_2D).
    //**************************************************************************

    //**************************************************************************
    // Make sure that pitch is at least 32 (NV4 requirement for CONTEXT_SURFACES_2D)
    // even when NO source is being used during the blit operation
    // (A newly created ppdev ZERO's out these values)
    //**************************************************************************

    if (ppdev->CurrentSourcePitch <= ppdev->ulSurfaceAlign)     // Source Pitch
        ppdev->CurrentSourcePitch = ppdev->ulSurfaceAlign+1;

    if ((ULONG)Stride <= ppdev->ulSurfaceAlign)                        // Destination Pitch
        Stride = ppdev->ulSurfaceAlign+1;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(6)));

    //**************************************************************************
    // Setup DSTIMAGE_IN_MEMORY object.
    //**************************************************************************

    if (ppdev->dDrawSpareSubchannelObject != DD_PRIMARY_IMAGE_IN_MEMORY)
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_PRIMARY_IMAGE_IN_MEMORY);
        ppdev->dDrawSpareSubchannelObject     = DD_PRIMARY_IMAGE_IN_MEMORY;
        }

    //**************************************************************************
    // Send methods to DMA push buffer
    //**************************************************************************

    NV_DMAPUSH_START(3, DD_SPARE , NV042_SET_PITCH )
    NV_DMA_FIFO = ((Stride <<16) | (ppdev->CurrentSourcePitch));
    NV_DMA_FIFO = ppdev->CurrentSourceOffset;
    NV_DMA_FIFO = Offset;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentDestOffset = Offset;
    ppdev->CurrentDestPitch  = Stride;

    //**************************************************************************
    // Make sure to update the DMA count before we exit!!
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    }

//******************************************************************************
//
// Function: NV4_DmaPushSend()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_DmaPushSend(PDEV *ppdev)

    {
    Nv04ControlDma      *nvDmaChannel;
    BOOL                 bReleaseOpenGLMutex = FALSE;

    nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

    //**********************************************************************
    // Check if the ALI 1541 chipset is present.
    // If so, then we need to workaround a cache issue by doing an out to port
    //**********************************************************************

    if (ppdev->AliFixupIoNeeded)
        {
// Assembly is not feasible for IA64
#ifndef _WIN64
        outp(ppdev->AliFixupIoBase, 0);      // This will flush the cache
#endif
        }
        
    //**************************************************************************
    // Some OGL CAD apps need GDI & OGL to be sync'ed up.
    //**************************************************************************
    if (ppdev->oglSyncGdi)
        {
        ppdev->pfnAcquireOglMutex(ppdev);
        ppdev->pfnWaitForChannelSwitch(ppdev);
        ppdev->NVFreeCount = 0;
        bReleaseOpenGLMutex = TRUE;
        }

#ifdef NVD3D    // DX6
    //**********************************************************************
    // If there is another DMA push channel active, wait til it's finished.
    //
    // It hurts performance to check this with every kickoff, so we only do
    // this check when:
    // 1) This is a DX6 build. We can only successfully sync with other DMA
    //    Push Channels and not PIO channels (DX3 is PIO only).
    // 2) DirectDraw is enabled and ddraw objects have been created
    //   (determined by checking if surfaces have been created).
    //
    //**********************************************************************

    if ((ppdev->DDrawEnabledFlag) &&
        (ppdev->pDriverData->DDrawVideoSurfaceCount))
        {
        if (ppdev->pfnWaitForChannelSwitch)
            ppdev->pfnWaitForChannelSwitch(ppdev);
        }
#else
    //**********************************************************************
    // It's possible the DX3 PIO channel is still active. We need to wait
    // til it's finished. It hurts performance to check this with every
    // kickoff, so we only do this check when DirectDraw is enabled.
    //**********************************************************************
    if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
        {
        NV4_DdPioSync(ppdev);
        ppdev->bDDChannelActive = FALSE;
        }
#endif // #ifndef NVD3D

    //**************************************************************************
    // Convert the PUT ptr to a byte address
    //**************************************************************************

    ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;

    //**************************************************************************
    // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
    // Then 'OR' it near the end of the push buffer
    //**************************************************************************

    if (ppdev->nvDmaCount >0)
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
    else
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

    *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;

    //**************************************************************************
    // Tell the hardware to start processing the push buffer
    //**************************************************************************

    nvDmaChannel->Put = ppdev->nvDmaCachedPut;

    ppdev->oglLastChannel = GDI_CHANNEL_ID;

    if (bReleaseOpenGLMutex)
        {
        ppdev->pfnReleaseOglMutex(ppdev);
        }

    }

//******************************************************************************
//
// Function: NV_DmaPush_Wrap()
//
// Routine Description:
//
//         This function causes a WRAP around to occur
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV_DmaPush_Wrap(PDEV *ppdev, ULONG Dwords_Needed)

    {
    ULONG               totalBytesNeeded;
    Nv04ControlDma      *nvDmaChannel;

    nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

    ASSERTDD(Dwords_Needed < ( (ppdev->DmaPushBufTotalSize>>2) - DMAPUSH_PADDING), "ERROR:  PushBuffer Size TOO small !!!");

#ifdef NVD3D    // DX6
    //**********************************************************************
    // If there is another DMA push channel active, wait til it's finished.
    //
    // It hurts performance to check this with every kickoff, so we only do
    // this check when:
    // 1) This is a DX6 build. We can only successfully sync with other DMA
    //    Push Channels and not PIO channels (DX3 is PIO only).
    // 2) DirectDraw is enabled and ddraw objects have been created
    //   (determined by checking if surfaces have been created).
    //
    //**********************************************************************

    if ((ppdev->DDrawEnabledFlag) &&
        (ppdev->pDriverData->DDrawVideoSurfaceCount))
        {
        if (ppdev->pfnWaitForChannelSwitch)
            ppdev->pfnWaitForChannelSwitch(ppdev);
        }
#else
    //**********************************************************************
    // It's possible the DX3 PIO channel is still active. We need to wait
    // til it's finished. It hurts performance to check this with every
    // kickoff, so we only do this check when DirectDraw is enabled.
    //**********************************************************************
    if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
        {
        NV4_DdPioSync(ppdev);
        ppdev->bDDChannelActive = FALSE;
        }
#endif // #ifndef NVD3D

    //**************************************************************************
    //
    // Write a jump to prepare for wrap.
    //
    //  WRAP_FLAG = TRUE
    //
    //         ---------  0
    //   ---> |         |
    //  |     |         |
    //  |     |         |  <-- Get Ptr
    //  |     |         |
    //  |     |  Push   |
    //  |     | Buffer  |  <-- Put Ptr
    //  |     |         |
    //  |     |         |
    //  |     |         |
    //   ---- |JUMP CMD |  <-- DMA Count
    //         ---------
    //
    //**************************************************************************

    ppdev->nvDmaFifo[ppdev->nvDmaCount] = NV4_JUMP(0);

    //**************************************************************************
    // Check if get pointer is way behind. If it is, wait until it starts to
    // catch up. This way we can distinguish between a pointer that is way behind
    // from a pointer that has wrapped.
    //**************************************************************************

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;

    while (ppdev->nvDmaCachedGet == 0)
        {
        MagicDelay ();
        ppdev->nvDmaCachedGet = nvDmaChannel->Get;
        }

    //**************************************************************************
    // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
    // Then 'OR' it near the end of the push buffer
    //**************************************************************************

    if (ppdev->nvDmaCount >0)
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
    else
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

    *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


    //******************************************************************
    // Force a kickoff. This will cause the engine to process the current
    // push buffer data and then wraparound to zero.
    //******************************************************************

    nvDmaChannel->Put = 0;
    ppdev->nvDmaCount = 0;

    //**********************************************************************
    //
    //  WRAP_FLAG = TRUE
    //
    //  Wait until Get >= Dwords_Needed
    //
    //         ---------  0
    //        |         |  <-- Put Ptr <------ DMA Count
    //        |         |                         ^
    //        |         |                         |
    //        |         |                         |--- Dwords Needed
    //        |  Push   |                         |
    //        | Buffer  |                         v
    //        |         |  <-- Get Ptr     <-------
    //        |         |
    //        |         |
    //        |JUMP CMD |
    //         ---------
    //
    //**********************************************************************

    totalBytesNeeded = (Dwords_Needed + (DMAPUSH_PADDING)) << 2;

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;

    while (ppdev->nvDmaCachedGet > 0)
        {
        if (totalBytesNeeded < ppdev->nvDmaCachedGet)
            {
            ppdev->nvDmaWrapFlag = TRUE;
            return;
            }

        MagicDelay ();
        ppdev->nvDmaCachedGet = nvDmaChannel->Get;

        }


    //**********************************************************************
    //
    // WRAP_FLAG = FALSE
    //
    // We are no longer wrapped, Get == 0, wrap has occurred. We should have
    // enough room now.
    //
    //         ---------   <- Put Ptr  <- DMA Count <- Get Ptr
    //        |         |
    //        |         |
    //        |         |
    //        |         |
    //        |  PUSH   |
    //        | BUFFER  |
    //        |         |
    //        |         |
    //        |         |
    //        |         |
    //         ---------
    //
    //**********************************************************************

    ppdev->nvDmaWrapFlag = FALSE;
    return;

    }

//******************************************************************************
//
// Function: NV_DmaPush_CheckWrapped()
//
// Routine Description:
//
//          Make sure that the DmaCount PUT ptr does NOT go past the
//          GET ptr (this occurs when DmaCount is wrapped around and
//          catching up to the GET ptr).
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV_DmaPush_CheckWrapped(PDEV *ppdev, ULONG Dwords_Needed)

    {
    ULONG               totalBytesNeeded;
    Nv04ControlDma      *nvDmaChannel;
    nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

    //**************************************************************************
    //
    //         WRAP_FLAG = TRUE
    //
    //         ---------  0
    //        |         |  <---- Put Ptr
    //        |         |
    //        |         |
    //        |  Push   |  <----- DMA Count (Where CPU currently writes data)
    //        | Buffer  |    |
    //        |         |    |
    //        |         |    v
    //        |         |  <----- Get Ptr
    //        |         |    |
    //        |         |    v
    //        |JUMP CMD |
    //         ---------
    //
    //**************************************************************************

    ASSERTDD(Dwords_Needed < ((ppdev->DmaPushBufTotalSize>>2) - DMAPUSH_PADDING), "ERROR:  PushBuffer Size TOO small !!!");

#ifdef NVD3D    // DX6
    //**********************************************************************
    // If there is another DMA push channel active, wait til it's finished.
    //
    // It hurts performance to check this with every kickoff, so we only do
    // this check when:
    // 1) This is a DX6 build. We can only successfully sync with other DMA
    //    Push Channels and not PIO channels (DX3 is PIO only).
    // 2) DirectDraw is enabled and ddraw objects have been created
    //   (determined by checking if surfaces have been created).
    //
    //**********************************************************************

    if ((ppdev->DDrawEnabledFlag) &&
        (ppdev->pDriverData->DDrawVideoSurfaceCount))
        {
        if (ppdev->pfnWaitForChannelSwitch)
            ppdev->pfnWaitForChannelSwitch(ppdev);
        }
#else
    //**********************************************************************
    // It's possible the DX3 PIO channel is still active. We need to wait
    // til it's finished. It hurts performance to check this with every
    // kickoff, so we only do this check when DirectDraw is enabled.
    //**********************************************************************
    if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
        {
        NV4_DdPioSync(ppdev);
        ppdev->bDDChannelActive = FALSE;
        }
#endif // #ifndef NVD3D

    //**************************************************************************
    // Calculate the number of bytes needed in the push buffer
    //**************************************************************************

    totalBytesNeeded = (ppdev->nvDmaCount + Dwords_Needed + DMAPUSH_PADDING) << 2;

    //**************************************************************************
    // Get the current GET ptr from hardware
    //**************************************************************************

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;

    //**************************************************************************
    // Check if the GET ptr is still ahead of the DMA count ptr
    //**************************************************************************

    if (ppdev->nvDmaCount < (ppdev->nvDmaCachedGet>>2))
        {
        //******************************************************************
        //
        //  CASE 1:
        //
        //  WRAP_FLAG = TRUE
        //
        //  CachedGet >= Dwords_Needed, just return immediately
        //
        //         ---------  0
        //        |         |
        //        |         |  <------------------ DMA Count
        //        |         |                         ^
        //        |  Push   |                         |
        //        | Buffer  |                         |--- Dwords Needed
        //        |         |                         |
        //        |         |                  <------
        //        |         |  <-- Get Ptr
        //        |         |    |
        //        |         |    |
        //        |         |    v
        //        |JUMP CMD |
        //         ---------
        //
        //******************************************************************

        if (totalBytesNeeded < ppdev->nvDmaCachedGet)
            return;

        //******************************************************************
        //
        // CASE 2:
        //
        //      WRAP_FLAG = TRUE
        //
        //      Dwords Needed < remaining space available
        //      Then need to wait for get pointer to advance
        //
        //         ---------  0
        //        |         |
        //        |         |
        //        |  Push   |  <----- DMA Count (Where CPU currently writes data)
        //        | Buffer  |    |                  |
        //        |         |    |                  |
        //        |         |    v                  |
        //        |         |  <----- Get Ptr       |-- Dwords Needed < remaining space
        //        |         |    |                  |
        //        |         |    v                  |
        //        |JUMP CMD |  <--------------------
        //         ---------
        //
        //******************************************************************

        else if (totalBytesNeeded < (ppdev->DmaPushBufTotalSize))
            {
            while (ppdev->nvDmaCount < (ppdev->nvDmaCachedGet>>2))
                {
                if (totalBytesNeeded < ppdev->nvDmaCachedGet)
                    return;

                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            //*************************************************************
            //
            //      WRAP_FLAG = FALSE
            //
            // We are no longer wrapped
            //
            //         ---------   <- Get Ptr
            //        |         |
            //        |         |
            //        |         |
            //        |  Push   |  <----- DMA Count (Where CPU currently writes data)
            //        | Buffer  |                       |
            //        |         |                       |
            //        |         |                       |
            //        |         |                       |-- Dwords Needed < remaining space
            //        |         |                       |
            //        |         |                       |
            //        |         |  <--------------------
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaWrapFlag = FALSE;
            return;

            }

        //******************************************************************
        //
        // CASE 3:
        //
        //      WRAP_FLAG = TRUE
        //
        //      Dwords Needed > remaining space available
        //
        //      We are way behind here, so we need to wait and catch up or else
        //      we will overwrite data.
        //
        //         ---------  0
        //        |         |
        //        |         |
        //        |  Push   |
        //        | Buffer  |
        //        |         |
        //        |         |
        //        |         |  <----- DMA Count (Where CPU currently writes data)
        //        |         |    |                  |
        //        |         |    v                  |
        //        |         |  <----- Get Ptr       |-- Dwords Needed > remaining space
        //        |         |    |                  |
        //        |JUMP CMD |    v                  |
        //         ---------                        |
        //                                          |
        //                     <--------------------
        //
        //******************************************************************

        else    // (totalBytesNeeded > DMAPUSH_BUFFER_SIZE)
            {

            //******************************************************************
            //
            // Wait for wraparound to occur
            //
            //         ---------   <- Get Ptr
            //        |         |
            //        |         |
            //        |  Push   |
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |         |  <----- DMA Count (Where CPU currently writes data)
            //        |         |                       |
            //        |         |                       |
            //        |         |                       |-- Dwords Needed > remaining space
            //        |         |                       |
            //         ---------                        |
            //                                          |
            //                     <--------------------
            //
            //******************************************************************

            while (ppdev->nvDmaCount < (ppdev->nvDmaCachedGet>>2))
                {
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            //******************************************************************
            // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
            // Then 'OR' it near the end of the push buffer
            //******************************************************************

            if (ppdev->nvDmaCount >0)
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
            else
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

            *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


            //******************************************************************
            //
            // Kick off so pointers catch up to DMA count
            //
            //         ---------
            //        |         |
            //        |         | <-- Get Ptr
            //        |  Push   |
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |JUMP CMD |  <----- DMA Count <- Put Ptr
            //        |         |                       |
            //        |         |                       |
            //        |         |                       |-- Dwords Needed > remaining space
            //        |         |                       |
            //         ---------                        |
            //                                          |
            //                     <--------------------
            //
            //******************************************************************

            ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;

            nvDmaChannel->Put = ppdev->nvDmaCachedPut;

            //******************************************************************
            // Make sure Get ptr is not zero, otherwise we can't distinguish between
            // a pointer that is way behind from a pointer that has wrapped.
            //******************************************************************

            ppdev->nvDmaCachedGet = nvDmaChannel->Get;

            while (ppdev->nvDmaCachedGet == 0)
                {
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            //******************************************************************
            //
            // Force a kickoff. This will cause the engine to process the current
            // push buffer data and then wraparound to zero.
            //
            //         ---------   <- Put Ptr  <- DMA Count
            //        |         |
            //        |         |
            //        |  Push   |  <-- Get Ptr
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |JUMP CMD |
            //        |         |
            //        |         |
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaFifo[ppdev->nvDmaCount] = NV4_JUMP(0);

            //******************************************************************
            // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
            // Then 'OR' it near the end of the push buffer
            //******************************************************************

            if (ppdev->nvDmaCount >0)
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
            else
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

            *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


            ppdev->nvDmaCount = 0;
            nvDmaChannel->Put = 0;

            totalBytesNeeded = (Dwords_Needed + DMAPUSH_PADDING) << 2;

            ppdev->nvDmaCachedGet = nvDmaChannel->Get;

            while (ppdev->nvDmaCachedGet > 0)
                {
                if (totalBytesNeeded < ppdev->nvDmaCachedGet)
                    {
                    ppdev->nvDmaWrapFlag = TRUE;
                    return;
                    }
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }


            //******************************************************************
            //
            //      WRAP_FLAG = FALSE
            //
            // Get pointer has wrapped.
            //
            //         ---------   <- Put Ptr  <- DMA Count <-- Get Ptr
            //        |         |
            //        |         |
            //        |  Push   |
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaWrapFlag = FALSE;
            return;

            }
        }
    else        // (ppdev->nvDmaCount > (ppdev->nvDmaCachedGet>>2))
        {

        //******************************************************************
        //
        //  CASE 4:
        //
        //      WRAP_FLAG = FALSE
        //
        //         ---------  0
        //        |         |
        //        |         |
        //        |         |  <-- Get Ptr
        //        |         |
        //        |         |  <-------------- DMA Count
        //        |         |                         |
        //        |         |                         |--- Dwords Needed
        //        |  Push   |                         |
        //        | Buffer  |                         |
        //        |         |                 <-------
        //        |         |
        //         ---------
        //
        //         Total Size of Push Buffer
        //
        //******************************************************************

        if (totalBytesNeeded <= (ppdev->DmaPushBufTotalSize))
            {
            ppdev->nvDmaWrapFlag = FALSE;       // no longer wrapped
            return;
            }

        //******************************************************************
        //
        //  CASE 5:
        //
        //      WRAP_FLAG = FALSE
        //
        //         ---------  0
        //        |         |
        //        |         |
        //        |         |  <-- Get Ptr
        //        |         |
        //        |         |
        //        |         |  <-------------- DMA Count
        //        |  Push   |                         |
        //        | Buffer  |                         |
        //        |         |                         |
        //        |         |                         |--- Dwords Needed
        //        |         |                         |
        //         ---------                          |
        //                                    <-------
        //******************************************************************

        else        // totalBytesNeeded > DMAPUSH_BUFFER_SIZE
            {

            //******************************************************************
            // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
            // Then 'OR' it near the end of the push buffer
            //******************************************************************

            if (ppdev->nvDmaCount >0)
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
            else
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

            *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


            //******************************************************************
            //
            // WRAP_FLAG = TRUE
            //
            // Force a kickoff. This will cause the engine to process the current
            // push buffer data and then wraparound to zero.
            //
            //         ---------   <- Put Ptr  <- DMA Count
            //        |         |
            //        |         |
            //        |  Push   |
            //        | Buffer  |
            //        |         |  <- Get Ptr
            //        |         |
            //        |         |
            //        |         |
            //        |JUMP CMD |
            //        |         |
            //        |         |
            //        |         |
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;

            nvDmaChannel->Put = ppdev->nvDmaCachedPut;

            //******************************************************************
            // Make sure Get ptr is not zero, otherwise we can't distinguish between
            // a pointer that is way behind from a pointer that has wrapped.
            //******************************************************************

            ppdev->nvDmaCachedGet = nvDmaChannel->Get;

            while (ppdev->nvDmaCachedGet == 0)
                {
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            ppdev->nvDmaFifo[ppdev->nvDmaCount] = NV4_JUMP(0);

            //******************************************************************
            // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
            // Then 'OR' it near the end of the push buffer
            //******************************************************************

            if (ppdev->nvDmaCount >0)
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
            else
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

            *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


            ppdev->nvDmaCount = 0;
            nvDmaChannel->Put = 0;

            totalBytesNeeded = (Dwords_Needed + DMAPUSH_PADDING) << 2;

            ppdev->nvDmaCachedGet = nvDmaChannel->Get;

            while (ppdev->nvDmaCachedGet > 0)
                {
                if (totalBytesNeeded < ppdev->nvDmaCachedGet)
                    {
                    ppdev->nvDmaWrapFlag = TRUE;
                    return;
                    }
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            //******************************************************************
            //
            //      WRAP_FLAG = FALSE
            //
            // We are no longer wrapped, Get == 0, wrap has occurred
            //
            //         ---------   <- Put Ptr  <- DMA Count <- Get Ptr
            //        |         |
            //        |         |
            //        |  Push   |
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaWrapFlag = FALSE;
            return;

            }
        }
    }


//******************************************************************************
//
// Function: NV4_DmaPushWaitOnSync
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV4_DmaPushWaitOnSync(PDEV *ppdev)

    {
    Nv04ControlDma      *nvDmaChannel;

    nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

#ifdef NVD3D    // DX6
    //**********************************************************************
    // If there is another DMA push channel active, wait til it's finished.
    //
    // It hurts performance to check this with every kickoff, so we only do
    // this check when:
    // 1) This is a DX6 build. We can only successfully sync with other DMA
    //    Push Channels and not PIO channels (DX3 is PIO only).
    // 2) DirectDraw is enabled and ddraw objects have been created
    //   (determined by checking if surfaces have been created).
    //
    //**********************************************************************

    if ((ppdev->DDrawEnabledFlag) &&
        (ppdev->pDriverData->DDrawVideoSurfaceCount))
        {
        if (ppdev->pfnWaitForChannelSwitch)
            ppdev->pfnWaitForChannelSwitch(ppdev);
        }
#else
    //**********************************************************************
    // It's possible the DX3 PIO channel is still active. We need to wait
    // til it's finished. It hurts performance to check this with every
    // kickoff, so we only do this check when DirectDraw is enabled.
    //**********************************************************************
    if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
        {
        NV4_DdPioSync(ppdev);
        ppdev->bDDChannelActive = FALSE;
        }
#endif // #ifndef NVD3D

    //**************************************************************************
    // Wait for all commands to be processed
    //**************************************************************************

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;
    while (ppdev->nvDmaCachedGet != ppdev->nvDmaCachedPut)
        {
        MagicDelay ();
        ppdev->nvDmaCachedGet = nvDmaChannel->Get;
        }

    //**************************************************************************
    // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
    // Then 'OR' it near the end of the push buffer
    //**************************************************************************

    if (ppdev->nvDmaCount >0)
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
    else
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

    *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;

    //**************************************************************************
    // Kickoff again
    //**************************************************************************

    nvDmaChannel->Put = 0;

    //**************************************************************************
    // Wait for jump wraparound
    //**************************************************************************

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;
    while (ppdev->nvDmaCachedGet != 0)
        {
        MagicDelay ();
        ppdev->nvDmaCachedGet = nvDmaChannel->Get;
        }
    }

//******************************************************************************
//
// Function: NV4_DdPioSync
//
// Routine Description:
// This routine is called from the GDI driver (as well as the the DD PIO
// code) to wait until the PIO channel has completed processing.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV4_DdPioSync(PDEV *ppdev)
{
    Nv3ChannelPio *nvDDChannel = (Nv03ChannelPio *)(ppdev->ddChannelPtr);
    USHORT freeCount = NvGetFreeCount(nvDDChannel, 2);
    NvNotification *pSyncNotifier = (NvNotification *)ppdev->Notifiers->Sync;

    //**************************************************************
    // Sync on method notification for NV_IMAGE_BLACK_RECTANGLE object.
    // This should ensure all processing of PIO channel has completed.
    //**************************************************************
    while (freeCount < 2 * 4)
        freeCount = NvGetFreeCount(nvDDChannel, 2);
    freeCount -= 2 * 4;

    while ((volatile) pSyncNotifier[NV019_NOTIFIERS_NOTIFY].status == NV019_NOTIFICATION_STATUS_IN_PROGRESS);
    pSyncNotifier[NV019_NOTIFIERS_NOTIFY].status = NV019_NOTIFICATION_STATUS_IN_PROGRESS;
    nvDDChannel->subchannel[6].nv1ImageBlackRectangle.Notify = NV019_NOTIFY_WRITE_ONLY;
    nvDDChannel->subchannel[6].nv1ImageBlackRectangle.NoOperation = 0;
    while ((volatile) pSyncNotifier[NV019_NOTIFIERS_NOTIFY].status == NV019_NOTIFICATION_STATUS_IN_PROGRESS);
    ppdev->NVFreeCount = freeCount;
}

//*****************************Public*Routine******************************\
// void NvSetDacImageOffset
//
// This routine set the new offset of Dac so that the display window can be
// on any part of frame buffer.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     ulDac - Which Dac is going to set, 0 - primary DAC
//     ulOffset - New offset in in the display desktop [ulDac] area.
//              - it is offset from the ppdev->ulPrimarySurfaceOffset
//
// Return Value:
//
//     None.
//**************************************************************************/
void __cdecl NvSetDacImageOffset(PDEV* ppdev, ULONG ulDac, ULONG ulOffset)
{
    // !!! To Do
    // ulDac is not current used; will be used for NV11 Dual View.
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    // Wait for previous image completed
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

    NV_DMAPUSH_CHECKFREE( ((ULONG)(6)));

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulDac);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_OFFSET(0), ulOffset + ppdev->ulPrimarySurfaceOffset);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_FORMAT(0), ppdev->lDelta |
                    NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31);

    UPDATE_PDEV_DMA_COUNT;

    //******************************************************************
    // Send data on thru to the DMA push buffer
    //******************************************************************
    NV4_DmaPushSend(ppdev);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4pal.c ===
//******************************Module*Header***********************************
// 
// Module Name: NV4PAL.C
// 
// Copyright (c) 1992-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

#include "nvapi.h"


//******************************************************************************
// Extern declarations
//******************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );


//******************************************************************************
//
//  Function:   NV4DmaPushSetPalette
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushSetPalette(
PDEV* ppdev,
ULONG start,
ULONG length)
    {
    ULONG i;
    ULONG ulHead;

#if _WIN32_WINNT >= 0x0500

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
	{
        ulHead = ppdev->ulDeviceDisplay[i];
#if (_WIN32_WINNT >= 0x0500) && defined(NVD3D) && !defined(_WIN64)

        if( (ppdev->pDriverData->vpp.dwOverlayFSNumSurfaces != 0))
        {
        // Disable pan & scan because Video is rendering on the head now.
            if(ppdev->pDriverData->vpp.dwOverlayFSHead == ulHead)
            {
                continue;
            }
        }
#endif
        ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_OFFSET(0), 0);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_FORMAT(0), NV046_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY);
        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);
        while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    }
    return;

#else
    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
	{
        ulHead = ppdev->ulDeviceDisplay[i];
        // setup LUT using Direct Method Call -- no notification needed
        if (
            NvDirectMethodCall(
                ppdev->hDriver,
                ppdev->hClient,
                ppdev->hDmaChannel,
                NV_VIDEO_LUT_CURSOR_DAC + ulHead,
                NV046_SET_LUT_OFFSET(0),
                0
            ) != NVOS1D_STATUS_SUCCESS
        )
        {
            DISPDBG((2, "NVDD: Cannot perform set LUT offset"));
        }
        if (
            NvDirectMethodCall(
                ppdev->hDriver,
                ppdev->hClient,
                ppdev->hDmaChannel,
                NV_VIDEO_LUT_CURSOR_DAC + ulHead,
                NV046_SET_LUT_FORMAT(0),
                0                                   // don't need notification w/DMC
            ) != NVOS1D_STATUS_SUCCESS
        )
        {
            DISPDBG((2, "NVDD: Cannot perform set LUT format"));
        }
    } //for each head
    return;
        
#endif // _WIN32_WINNT >= 0x0500

    }


/******************************Public*Routine******************************\
* ULONG nvSetGammaRamp
\**************************************************************************/
BOOL nvSetHeadGammaRamp(PDEV *ppdev, ULONG ulHead, PUSHORT fpRampVals)
{
    ULONG i, ulOffset;
    ULONG ulNumEntries = 256;

    DECLARE_DMA_FIFO;

    if (!ppdev) return(FALSE);

    if(ppdev->iBitmapFormat != BMF_8BPP)
    {
        ulOffset = ulHead*256;

        for (i = 0; i < ulNumEntries; i++) 
        {
            ppdev->ajClutData[i + ulOffset].Blue  = (UCHAR) (fpRampVals[512 + i] >> 8); /* blue value */
            ppdev->ajClutData[i + ulOffset].Green = (UCHAR) (fpRampVals[256 + i] >> 8); /* green value */
            ppdev->ajClutData[i + ulOffset].Red   = (UCHAR) (fpRampVals[i] >> 8); /* red value */
        }

        INIT_LOCAL_DMA_FIFO;

        ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_OFFSET(0), 0);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_FORMAT(0), NV046_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY);
        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);
        while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);

        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}



/******************************Public*Routine******************************\
* ULONG nvSetGammaRamp
\**************************************************************************/
BOOL nvGetHeadGammaRamp(PDEV *ppdev, ULONG ulHead, PUSHORT fpRampVals)
{
    ULONG i, ulOffset;
    ULONG ulNumEntries = 256;

    DECLARE_DMA_FIFO;

    if (!ppdev) return(FALSE);

    if(ppdev->iBitmapFormat != BMF_8BPP)
    {
        ulOffset = ulHead*256;

        for (i = 0; i < ulNumEntries; i++) 
        {
            fpRampVals[512 + i] = ((USHORT)ppdev->ajClutData[i + ulOffset].Blue << 8); // blue value
            fpRampVals[256 + i] = ((USHORT)ppdev->ajClutData[i + ulOffset].Green << 8);// green value
            fpRampVals[i]       = ((USHORT)ppdev->ajClutData[i + ulOffset].Red << 8);  // red value
        }
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4bltc.c ===
//******************************Module*Header***********************************
//
// Module Name: NV4BLTC.C
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"

//******************************************************************************
// NV4 vs. NV3
//
// This file is almost exactly the same as the NV3 version.
// The difference, is that since we'll be using 565 bitmap format on NV4, 
// we need to use NV4 specific objects (The NV4 RECTANGLE_TEXT object has 
// changed significantly from the NV3 RECTANGLE_TEXT object... the method
// offsets are *NOT* the same as NV3).
//
// (i.e. we can only use the original NV3 functions on NV4 when running in 555 format)
//******************************************************************************

#define NV_MTMF_FORMAT_INPUT_INC_1     0x00000001
#define NV_MTMF_FORMAT_OUTPUT_INC_1    0x00000100

//******************************************************************************
// Externs
//******************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

#ifdef _X86_

//******************************************************************************
// X86 Assembly routine to xfer host bitmap->screen
//******************************************************************************

void NV4_DmaPush_Transfer_MemToScreen_Data(PDEV *, LONG, ULONG, ULONG *,LONG);

#endif

#if 1 // Enable xlate caching
//******************************************************************************
// Replacing all (BYTE)XLATEOBJ_iXlate(pxlo,DWORD) with a macro that is caching
// the last value.
// The call to XLATEOBJ_iXlate is expensive. Until now it was done per pixel. 
// This caused our NV4ScreenToMem32to8bppBlt to be slower than a return FALSE 
// and punt to Eng. 
// Now we cache the last xlated value and index and only xlate if necessary. 
// This gives us 25 % speedup in SolidWorks2000 I/O bench (1280TC) and some 
// points in WinBench99 (NT4 1024TC).
//
// Because the entire Xfer stuff is a macro it is very hard to debug or modify 
// code. so I choose a macro, too :-(
// Everywhere NV_XLATEOBJ_IXLATE is used the NV_XLATE_INIT macro must be added 
// to define and intialize the cache variables:
//******************************************************************************
//
    // Macro to initialize cached xlate values
    #define NV_XLATE_INIT                                                \
        DWORD cachedXlIndex = 0;                                         \
        BYTE  jXlCached     = (BYTE)XLATEOBJ_iXlate(pxlo,cachedXlIndex);


    #if DBG
        // In a debug environment we count the misses and hits to the cached value.
        DWORD cacheXlHits = 0; // counter for xlated cache hits
        DWORD cacheXlMiss = 0; // counter for xlated cache misses

        #define NV_XLATEOBJ_IXLATE(pxlo,cIndex) ( ((cIndex) == cachedXlIndex) ?                                       \
            ( cacheXlHits++, jXlCached ) :                                                                            \
            ( cacheXlMiss++, (cachedXlIndex = (cIndex)), (jXlCached = (BYTE)XLATEOBJ_iXlate((pxlo),cachedXlIndex))) )
    #else
        // free build
        // if (index==prev index) {take cached xlated value} else {remember this index, calculate and remember xlated value}
        #define NV_XLATEOBJ_IXLATE(pxlo,cIndex) ( ((cIndex) == cachedXlIndex) ?                                       \
            (                jXlCached ) :                                                                            \
            (                (cachedXlIndex = (cIndex)), (jXlCached = (BYTE)XLATEOBJ_iXlate((pxlo),cachedXlIndex))) )
    #endif

#else
    // original 1:1 xlate without caching
    #define NV_XLATE_INIT
    #define NV_XLATEOBJ_IXLATE(pxlo,cIndex) XLATEOBJ_iXlate(pxlo,cIndex)
#endif

//******************************************************************************
//
//  Function:   NV4DmaPushFillSolid
//
//  Routine Description:
//
//      Fills a list of rectangles with a solid colour.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushFillSolid(       // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used

    {
    LONG  xDst;
    LONG  yDst;
    ULONG width,height;
    ULONG Rop3;
    ULONG temp;
    ULONG AlphaWithColor;

    DECLARE_DMA_FIFO;
    
    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;
    
    //**************************************************************************
    // Equation to convert to Rop4 to Rop3 (We don't get patterns here)
    //
    // Rop4:
    //                 Truth table for a Rop 3.
    //                 ------------------------
    //                                    R
    //                                    O
    //                        (SD)        P
    //                  11  10  01  00    3
    //                  --------------
    //          (P) 1  |         x   x    High nibble    Example Value = 0xf0
    //              0  | x   x            Low nibble
    //
    //
    // After rop4 >> 2:
    //
    //                 Truth table for a Rop 3.
    //                 ------------------------
    //                                    R
    //                                    O
    //                        (SD)        P
    //                  11  10  01  00    3
    //                  --------------
    //          (P) 1  |                  High nibble    Value = 0x3c
    //              0  | x   x   x   x    Low nibble
    //
    //
    // After (rop4 >> 2 ) & 0xf:
    //
    //                                                   Value = 0x0c
    //
    // Final Rop3 equivalent value of a Rop2 value = 0xcc
    //
    //         This value does not depend on the Pattern
    //**************************************************************************

    AlphaWithColor = ((ppdev->AlphaEnableValue) | rbc.iSolidColor);
    temp = ((rop4 >> 2) & 0xf);         // Get bottom nibble
    Rop3 = temp | (temp << 4);        // Duplicate in top nibble

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(5+(4*c))));  

    //**************************************************************************
    // Set Rop
    //**************************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**********************************************************************
    // Since the sub-channel is same in the while loop, the color is set 
    // out of the while loop.
    //**********************************************************************
    NV_DMAPUSH_START (1, RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_A)
    NV_DMA_FIFO = AlphaWithColor;
    
    while(TRUE)
        {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of pixels drawn.
        // So, adjusting by 1 pixel is NOT necessary when calculating width and height.
        //**********************************************************************

        xDst = prcl->left;
        yDst = prcl->top;
        width = prcl->right - xDst;
        height = prcl->bottom - yDst;

        NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL, NV04A_UNCLIPPED_RECTANGLE(0))
        NV_DMA_FIFO = (xDst << 16) | (yDst & 0xffff);
        NV_DMA_FIFO = (width << (16) | (height & 0xffff));
        
        if (--c == 0)
            {
            //******************************************************************
            // Update global push buffer count
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;

            //******************************************************************
            // Send data on thru to the DMA push buffer
            //******************************************************************

            NV4_DmaPushSend(ppdev);

            return;
            }

        prcl++;
        }

    }


//******************************************************************************
//
//  Function:   NV4DmaPushCopyBlit
//
//  Routine Description:
//
//      Does a screen-to-screen blt of a list of rectangles.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushCopyBlt(    // Type FNCOPY
    PDEV*   ppdev,
    LONG    c,          // Can't be zero
    RECTL*  prcl,       // Array of relative coordinates destination rectangles
    ULONG   rop4,       // rop4
    POINTL* pptlSrc,    // Original unclipped source point
    RECTL*  prclDst,    // Original unclipped destination rectangle
    BLENDOBJ *pBlendObj)
    {
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source

    ULONG   width,height;
    ULONG   xsrc,ysrc;
    ULONG   xdst,ydst;
    ULONG   Rop3;
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),"Expect only a rop2");
    ASSERTDD((pBlendObj==NULL), "Must use NV4DmaPushCopyAlphaBlt for blended CopyBlt");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************
    NV_DMAPUSH_CHECKFREE((ULONG)(5 + (4*c)));

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        
        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Set Rop
    //**************************************************************************

    Rop3 = (rop4 & 0xff);

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

    //**************************************************************************
    // Do a copy blit for each clip rectangle
    //**************************************************************************

    do  {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        xdst = prcl->left;
        ydst = prcl->top;

        width = prcl->right - xdst;
        height = prcl->bottom - ydst;

        dx = xdst - prclDst->left;      // prcl is always within prcldst???
        dy = ydst - prclDst->top;       // prcl is always within prcldst???

        xsrc = pptlSrc->x + dx;
        ysrc = pptlSrc->y + dy;

        //**********************************************************************
        // Wait for FIFO to be ready, then draw

        //**********************************************************************
        // Set methods for image_blit:
        //    NV05F_CONTROL_POINT_IN 
        //    NV05F_CONTROL_POINT_OUT
        //    NV05F_SIZE             
        //**********************************************************************

        NV_DMAPUSH_START(3, BLIT_SUBCHANNEL, NV05F_CONTROL_POINT_IN );
        NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );
        NV_DMA_FIFO = ( (ydst << 16) | (xdst & 0xffff) );
        NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));

        prcl++;

    } while (--c != 0);

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    }




//******************************************************************************
//
//  Function:   NV4DmaScreenToScreenWithPatBlt
//
//  Routine Description:
//
//      Does a screen-to-screen blt of a list of rectangles, supporting brushes
//      and all rops.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4ScreenToScreenWithPatBlt(
    
    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    BRUSHOBJ*   pbo,                // Brush object
    POINTL*     pptlBrush,          // Brush start coordinate in the pattern bits.
    ROP4        rop4)               // Op that describes the blit (must be 1 byte max)

{
    ULONG       rop3;
    RBRUSH*     prb;
    
    ULONG       xsrc,ysrc;

    ULONG       Color0;
    ULONG       Color1;
    ULONG       width;
    ULONG       height;
    LONG        xShift;
    LONG        yShift;
    LONG        BytesPerSrcScan;
    BYTE*       SrcBits;
    BYTE*       DstBits;
    ULONG*      ScanPtr;
    ULONG*      NextScan;
    LONG        ScanInc;
    LONG        cjLeft;
    LONG        cjRight;
    ULONG       i, ix,iy;


    DECLARE_DMA_FIFO;

    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4DmaScreenToScreenWithPatBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL destination rectangles supplied !" );
        
    ASSERTDD( pptlSrc != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL destination rectangle supplied !" );
    
    ASSERTDD( pbo != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL brush object supplied !" );
    
    ASSERTDD( pptlBrush != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL upper left point of brush supplied !" );

    ASSERTDD( ( (rop4 & 0xff00) >> 8 ) == (rop4 & 0xff),
              "NV4DmaScreenToScreenWithPatBlt: The rop has more than one byte set");


    //**************************************************************************
    // Init the local dma variables with the ones in ppdev.
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Setup variables
    //**************************************************************************
    
    rop3 = (ULONG)(rop4 & 0xff);            /* Get ROP3 (1 byte only)        */
    prb  = (RBRUSH*) pbo->pvRbrush;         /* Get pointer to realized brush */
    
    //**************************************************************************
    // Check if there is enough free space in the push buffer. We check ONE
    // time because this seems to be a great deal of overhead.  Furthermore,
    // we check for the largest possible amount we will use in the rest of the
    // function...
    //**************************************************************************
    
    NV_DMAPUSH_CHECKFREE((  (ULONG)(  3+8+65+ (c<<2)  )   ));  
    
    
    /* Max between:                                                            */
    /*                                                                         */
    /*  Solid case:    3+12+4*c                                                */
    /*                                                                         */
    /*                  and                                                    */
    /*                                                                         */
    /*  NonSolid case: 3+12+4*c                                                */
    /*                                                                         */
    /*                                                                         */
    /*                  and                                                    */
    /*                                                                         */
    /*                 3+8+65+4*c                                              */
    /*                                                                         */
    
    
    //**************************************************************************
    // Restore clip rect if there is need to...
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
    {
        //NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag = 0;       // Clear the "clipper is not to max"
                                          // flag
    }

    
    if(prb != NULL)  goto NV4StoSPat_NonSolid;

    //**************************************************************************
    //***[ BEGIN "Brush is Solid" ]*********************************************
    //**************************************************************************
       
    //**************************************************************************
    // 
    // Set the pattern object to all the same color (I'm not sure this is the
    // best way to do it, there might be another way to setup the NV4_IMAGE_BLIT
    // object so that it understands that the brush is solid, and that we only
    // need to give it the solid color...)
    // 
    // We are going to write a monochrome pattern to the pattern object, but all
    // "111..." so that we only have to set the foreground color.  This is better
    // than realizing a color pattern because it will take less data output to
    // the hardware
    //**************************************************************************


    // Determine the color format of our frame buffer and set the format of the
    // pattern object accordingly

    switch (ppdev->iBitmapFormat)
    {
        case BMF_32BPP:
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
           break;
        case BMF_16BPP:
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
           break;
        default:
        case BMF_8BPP:
           // Must be set to a legal value but hardware ignores it otherwise 
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
           break;
    }            
        
    //**********************************************************************
    // Set the following methods for context_pattern
    //    NV044_SET_MONOCHROME_FORMAT 
    //    NV044_SET_MONOCHROME_SHAPE  
    //    NV044_SET_PATTERN_SELECT    
    //    NV044_SET_MONOCHROME_COLOR0  
    //    NV044_SET_MONOCHROME_COLOR1,  
    //    NV044_SET_MONOCHROME_PATTERN0
    //    NV044_SET_MONOCHROME_PATTERN1
    //**********************************************************************

    NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
    NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
    NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
    NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
    NV_DMA_FIFO = 0;                                             // Not used (color0)
    NV_DMA_FIFO = (pbo->iSolidColor | ppdev->AlphaEnableValue);  // Color to use when bit is "1" 

    NV_DMA_FIFO = (ULONG) 0xFFFFFFFF;                  // 8x8 = 64 bit pattern
    NV_DMA_FIFO = (ULONG) 0xFFFFFFFF;                  // " "

    
    // Set the rop
    
    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);   

    
    /***********************************************************************/
    /* Blit all rectangle regions                                          */
    /***********************************************************************/

    do 
    {
        //******************************************************************
        // Get width and height of the destination rectangle
        //******************************************************************

        width = parcl->right - parcl->left;
        height= parcl->bottom - parcl->top;


        xsrc = pptlSrc->x + (parcl->left - prclDst->left);
        ysrc = pptlSrc->y + (parcl->top - prclDst->top);


        //******************************************************************
        // Set methods for image_blit:
        //    NV05F_CONTROL_POINT_IN 
        //    NV05F_CONTROL_POINT_OUT
        //    NV05F_SIZE             
        //******************************************************************

        NV_DMAPUSH_START(3, BLIT_SUBCHANNEL, NV05F_CONTROL_POINT_IN );
        NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );
        NV_DMA_FIFO = ( (parcl->top << 16) | (parcl->left & 0xffff) );
        NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));


        parcl++;

    } while (--c != 0);
    
    
    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    
    return;  

    
    //**************************************************************************
    //***[ END OF "Brush is Solid" ]********************************************
    //**************************************************************************

NV4StoSPat_NonSolid:
    

    //**************************************************************************
    // 
    // Set the pattern object with the data of our brush
    // (if we end here, the brush pattern is required, the brush is nonsolid)
    //
    //**************************************************************************

    if (prb->fl & RBRUSH_2COLOR)
    {
        /* Brush is monochrome                                                */
        /*                                                                    */
        /* Note: this code is copy pasted from fillpatfast for brush pattern  */
        /*       setup. if we see it's worth it, we might try to find a way   */
        /*       to optimize the alignement procedure (this seems it could    */
        /*       be done) or better yet, use brush caching)                   */
        

        //**********************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // The brush is aligned in absolute coordinates, so we have to add
        // in the surface offset:
        //
        // NV: We DON'T need to manually account for the position of the pattern
        //     on the screen, like we do for the Memory to Screen blits for
        //     multi-color patterns (below).
        //**********************************************************************

        //**********************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //**********************************************************************

        xShift = pptlBrush->x & 7;
        yShift = pptlBrush->y & 7;

        //**********************************************************************
        // Shift Mono pattern bits appropriately (vertically)
        // First we'll align it properly by copying it to a temporary buffer:
        //**********************************************************************

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift;                              // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //**********************************************************************
        // Now copy the pattern , row by row (byte by byte) and
        // align it vertically and horizontally at the same time
        //**********************************************************************

        do  
        {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;

        } while (--i != 0);

        //**********************************************************************
        // Now copy the 'top' part
        //**********************************************************************

        DstBits -=8;                    // Move back to beginning of destination

        for (; yShift != 0; yShift--)
        {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;
        }

        //**********************************************************************
        // Init foreground and background color
        //**********************************************************************

        Color1 = prb->ulForeColor | (ppdev->AlphaEnableValue); // Background color
        Color0 = prb->ulBackColor | (ppdev->AlphaEnableValue); // Foreground color

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        //NV_DMAPUSH_CHECKFREE(((ULONG)((c<<2)+12)));  

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        // Determine the color format
        switch (ppdev->iBitmapFormat)
        {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
        }            

        //**********************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //    NV044_SET_MONOCHROME_COLOR0  
        //    NV044_SET_MONOCHROME_COLOR,  
        //    NV044_SET_MONOCHROME_PATTERN0
        //    NV044_SET_MONOCHROME_PATTERN1
        //**********************************************************************

        NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
        NV_DMA_FIFO = Color0; 
        NV_DMA_FIFO = Color1;
        NV_DMA_FIFO = ppdev->AlignedBrush[0];
        NV_DMA_FIFO = ppdev->AlignedBrush[1];
        
                
        /***********************************************************************/
        /* Blit all rectangle regions                                          */
        /***********************************************************************/
        
        do 
        {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = parcl->right - parcl->left;
            height= parcl->bottom - parcl->top;

            
            xsrc = pptlSrc->x + (parcl->left - prclDst->left);
            ysrc = pptlSrc->y + (parcl->top - prclDst->top);
            
            
            //******************************************************************
            // Set methods for image_blit:
            //    NV05F_CONTROL_POINT_IN 
            //    NV05F_CONTROL_POINT_OUT
            //    NV05F_SIZE             
            //******************************************************************
            
            NV_DMAPUSH_START(3, BLIT_SUBCHANNEL, NV05F_CONTROL_POINT_IN );
            NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );
            NV_DMA_FIFO = ( (parcl->top << 16) | (parcl->left & 0xffff) );
            NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));

            
            parcl++;

        } while (--c != 0);

    }

    else
    {
        /*******************************************************************/
        /* Else we have a color brush                                      */
        /*                                                                 */
        /* Note that the code to setup the pattern is copy pasted from     */
        /* fillpatfast                                                     */
        /*******************************************************************/

        //******************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // NV4: Colored Pattern fills are now supported in hardware
        //******************************************************************

        xShift = pptlBrush->x;
        yShift = pptlBrush->y;

        //******************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //******************************************************************

        xShift &= 7;
        yShift &= 7;

        //******************************************************************
        // We're going to do a straight of the Xbpp 8x8 pattern to the screen.
        // First we'll align it properly by copying it to a temporary buffer:
        //******************************************************************

        cjLeft  = CONVERT_TO_BYTES(xShift, ppdev);      // Number of bytes pattern
                                                        //   is shifted to the right
        cjRight = CONVERT_TO_BYTES(8, ppdev) - cjLeft;  // Number of bytes pattern
                                                        // is shifted to the left

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift * CONVERT_TO_BYTES(8, ppdev); // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //******************************************************************
        // Now copy the pattern and align it, in 2 steps.
        // The 'left' part, and 'right' part (as well as the 'bottom' and 'top')
        // We'll start copying the 'bottom' part first.
        //******************************************************************

        do  
        {
            RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
            RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

            DstBits += cjLeft + cjRight;
            SrcBits += cjLeft + cjRight;

        } while (--i != 0);

        //******************************************************************
        // Now copy the 'top' part
        //******************************************************************

        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

        for (; yShift != 0; yShift--)
        {
            RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
            RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

            DstBits += cjLeft + cjRight;
            SrcBits += cjLeft + cjRight;
        }
        
        //******************************************************************
        // Ptr to pattern data
        //******************************************************************

        SrcBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

        //******************************************************************
        // Get ptr to start of SRC
        //******************************************************************

        NextScan = (ULONG *)(SrcBits);

        //******************************************************************
        // We only ever support 8x8 patterns
        //******************************************************************

        BytesPerSrcScan = ppdev->cjPelSize << 3; /* cjPelsize * 8 */

        //******************************************************************
        // Amount to increment for each scanline (in dwords)
        //******************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

        //******************************************************************
        // Check if we've got enough room in the push buffer for max amount
        // of data possible for the later code...
        //******************************************************************

        //NV_DMAPUSH_CHECKFREE(((ULONG)(8+65+4*c)));  

        //******************************************************************
        // Send the Rop straight on through 
        // (We now support colored patterns in hardware)
        //******************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        //******************************************************************
        // Init color pattern in hardware
        //******************************************************************

        // Determine the color format
        switch (ppdev->iBitmapFormat)
        {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
        }            


        //******************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //******************************************************************

        NV_DMAPUSH_START(3, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_COLOR;


        //******************************************************************
        // Init the 8x8 pattern for 8,16, or 32bpp 
        //******************************************************************

        if (ppdev->cjPelSize == 4)  // 32bpp
        {
            //**************************************************************
            // Init the 8x8 colored pattern
            //**************************************************************

            NV_DMAPUSH_START(64, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_X8R8G8B8(0));

            for (iy=0;iy<8;iy++)
            {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<8;ix++)
                {                    
                    NV_DMA_FIFO = ScanPtr[ix];
                }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
            }
        }
        
        else if (ppdev->cjPelSize == 2) // 16bpp
        {
            //**************************************************************
            // 16bpp
            //**************************************************************

            //**************************************************************
            // Init the 8x8 colored pattern for 16bpp
            //**************************************************************

            NV_DMAPUSH_START(32, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_R5G6B5(0));
                       

            for (iy=0;iy<8;iy++)
            {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<4;ix++)
                {                    
                    NV_DMA_FIFO = ScanPtr[ix];  // 2 16bpp pixels at a time
                }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
            }
        }
                                         

        else
        {
            //**************************************************************
            // 8bpp
            //**************************************************************

            //**************************************************************
            // Init the 8x8 colored pattern for 8bpp
            //**************************************************************

            NV_DMAPUSH_START(16, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_Y8(0));

            for (iy=0;iy<8;iy++)
            {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<2;ix++)
                {                    
                    NV_DMA_FIFO = ScanPtr[ix];  // 4 8bpp pixels at a time
                }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
            }
                                                    
            
        }
            
        //**********************************************************************
        // Loop thru all the clipping rectangles
        //**********************************************************************
    
        do  
        {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************
    
            width = parcl->right - parcl->left;
            height= parcl->bottom - parcl->top;
    

            xsrc = pptlSrc->x + (parcl->left - prclDst->left);
            ysrc = pptlSrc->y + (parcl->top - prclDst->top);

            
            //******************************************************************
            // Set methods for image_blit:
            //    NV05F_CONTROL_POINT_IN 
            //    NV05F_CONTROL_POINT_OUT
            //    NV05F_SIZE             
            //******************************************************************

            NV_DMAPUSH_START(3, BLIT_SUBCHANNEL, NV05F_CONTROL_POINT_IN );
            NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );
            NV_DMA_FIFO = ( (parcl->top << 16) | (parcl->left & 0xffff) );
            NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));
            
            //******************************************************************
            // Onto the next clipping rectangle
            //******************************************************************
    
            parcl++;
    
        } while (--c != 0);

    } // ...else the brush pattern is color (not mono)

    
    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

}
//**************** End of function: NV4DmaScreenToScreenWithPatBlt *************
//******************************************************************************





//******************************************************************************
//
//  Function:   NV4DmaPushFillPatFast
//
//  Routine Description:
//      Using NV04_GDI_RECTANGLE_TEXT class to fill with patterns.
//      The IMAGE_APTTERN_SUBCHANNEL set up the pattern first,
//      and then the RECT_AND_TEXT_SUBCHANNEL fill up the rectangle with 
//      the pattern.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment

    {
    //BOOL        bTransparent;
    //BRUSHENTRY* pbe;          // Pointer to brush entry data, which is used
                                //   for keeping track of the location and status
                                //   of the pattern bits cached in off-screen
                                //   memory

    ULONG       Color0;
    ULONG       Color1;
    ULONG       AlphaEnableValue;
    ULONG       width;
    ULONG       height;
    ULONG       rop3;
    LONG        xShift;
    LONG        yShift;
    LONG        BytesPerSrcScan;
    BYTE*       SrcBits;
    BYTE*       DstBits;
    ULONG*      ScanPtr;
    RBRUSH*     prb;
    ULONG*      NextScan;
    LONG        ScanInc;
    LONG        cjLeft;
    LONG        cjRight;
    ULONG       i, ix,iy;


    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // TODO: Do I need to do anything special for transparent cases?
    //**************************************************************************
    
    rop3 = (ULONG)(rop4 & 0xff);
    
    //bTransparent = (((rop4 >> 8) & 0xff) != rop3);

    //**************************************************************************
    // Get pointer to brush entry
    //**************************************************************************

    prb = rbc.prb;
    
    //pbe = prb->apbe[IBOARD(ppdev)];

    //**************************************************************************
    // Need to add if statement if brush pattern hasn't changed
    // For now, just always re-calculate brush pattern
    // Performance boost of how much?
    //**************************************************************************

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    
    //**************************************************************************
    // Check if there is enough free space in the push buffer. We check ONE
    // time because this is faster.  Furthermore, we check for the largest 
    // possible amount we will use in the rest of the function...
    //**************************************************************************


    //MAX of :  NV_DMAPUSH_CHECKFREE(((ULONG)(3+14+3*c     )));   and
    //          NV_DMAPUSH_CHECKFREE(((ULONG)(3+8+65+3*c     )));  

    NV_DMAPUSH_CHECKFREE(((ULONG)( 3+8+65+3*c )));  

    
    
    //**************************************************************************
    // Restore clip rect if we need to
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // I considered doing the colour expansion for 1bpp brushes in
    // software, but by letting the hardware do it, we don't have
    // to do as many OUTs to transfer the pattern.
    //**************************************************************************

    if (prb->fl & RBRUSH_2COLOR)
        {

        //**********************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // The brush is aligned in absolute coordinates, so we have to add
        // in the surface offset:
        //
        // NV: We DON'T need to manually account for the position of the pattern
        //     on the screen, like we do for the Memory to Screen blits for
        //     multi-color patterns (below).
        //**********************************************************************

        //**********************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //**********************************************************************

        xShift = pptlBrush->x & 7;
        yShift = pptlBrush->y & 7;

        //**********************************************************************
        // Shift Mono pattern bits appropriately (vertically)
        // First we'll align it properly by copying it to a temporary buffer:
        //**********************************************************************

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift;                              // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //**********************************************************************
        // Now copy the pattern , row by row (byte by byte) and
        // align it vertically and horizontally at the same time
        //**********************************************************************

        do  {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;

            } while (--i != 0);

        //**********************************************************************
        // Now copy the 'top' part
        //**********************************************************************

        DstBits -=8;                    // Move back to beginning of destination

        for (; yShift != 0; yShift--)
            {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;
            }

        //**********************************************************************
        // Init foreground and background color
        //**********************************************************************

        Color1 = rbc.prb->ulForeColor | (AlphaEnableValue); // Background color
        Color0 = rbc.prb->ulBackColor | (AlphaEnableValue); // Foreground color

        
        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        // Determine the color format
        switch (ppdev->iBitmapFormat)
            {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            }            

        //**********************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //    NV044_SET_MONOCHROME_COLOR0  
        //    NV044_SET_MONOCHROME_COLOR,  
        //    NV044_SET_MONOCHROME_PATTERN0
        //    NV044_SET_MONOCHROME_PATTERN1
        //**********************************************************************

        NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
        NV_DMA_FIFO = Color0; 
        NV_DMA_FIFO = Color1;
        NV_DMA_FIFO = ppdev->AlignedBrush[0];
        NV_DMA_FIFO = ppdev->AlignedBrush[1];
        
        //**********************************************************************
        // Since the sub-channel is same in the do-while loop, the color is set 
        // out of the do-while loop. (value can be anything tough, it's never
        // used anyway but method state must be valid, and it is volatile, being
        // invalidated when we use another subchannel or switch channels) - steph
        //**********************************************************************
        
        NV_DMAPUSH_START (1, RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_A);
        NV_DMA_FIFO = 0;

        do {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = prcl->right - prcl->left;
            height= prcl->bottom - prcl->top;

            NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL, NV04A_UNCLIPPED_RECTANGLE(0))
            NV_DMA_FIFO = (prcl->left << 16) | prcl->top;
            NV_DMA_FIFO = (width << (16) | height);

            prcl++;

            } while (--c != 0);

        }


    else

        {
        //******************************************************************
        // Handle multi-color patterns in hardware (new for NV4)
        //******************************************************************

        //******************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // NV4: Colored Pattern fills are now supported in hardware
        //******************************************************************

        xShift = pptlBrush->x;
        yShift = pptlBrush->y;

        //******************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //******************************************************************

        xShift &= 7;
        yShift &= 7;

        //******************************************************************
        // We're going to do a straight of the Xbpp 8x8 pattern to the screen.
        // First we'll align it properly by copying it to a temporary buffer:
        //******************************************************************

        cjLeft  = CONVERT_TO_BYTES(xShift, ppdev);      // Number of bytes pattern
                                                        //   is shifted to the right
        cjRight = CONVERT_TO_BYTES(8, ppdev) - cjLeft;  // Number of bytes pattern
                                                        // is shifted to the left

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift * CONVERT_TO_BYTES(8, ppdev); // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //******************************************************************
        // Now copy the pattern and align it, in 2 steps.
        // The 'left' part, and 'right' part (as well as the 'bottom' and 'top')
        // We'll start copying the 'bottom' part first.
        //******************************************************************

        do  {
            RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
            RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

            DstBits += cjLeft + cjRight;
            SrcBits += cjLeft + cjRight;

            } while (--i != 0);

        //******************************************************************
        // Now copy the 'top' part
        //******************************************************************

        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

        for (; yShift != 0; yShift--)
            {
            RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
            RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

            DstBits += cjLeft + cjRight;
            SrcBits += cjLeft + cjRight;
            }
        
        //******************************************************************
        // Ptr to pattern data
        //******************************************************************

        SrcBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

        //******************************************************************
        // Get ptr to start of SRC
        //******************************************************************

        NextScan = (ULONG *)(SrcBits);

        //******************************************************************
        // We only ever support 8x8 patterns
        //******************************************************************

        BytesPerSrcScan = 8 * ppdev->cjPelSize;

        //******************************************************************
        // Amount to increment for each scanline (in dwords)
        //******************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

        //******************************************************************
        // Send the Rop straight on through 
        // (We now support colored patterns in hardware)
        //******************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        //******************************************************************
        // Init color pattern in hardware
        //******************************************************************

        // Determine the color format
        switch (ppdev->iBitmapFormat)
            {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            }            


        //******************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //******************************************************************

        NV_DMAPUSH_START(3, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_COLOR;

        //******************************************************************
        // Init the 8x8 pattern for 8,16, or 32bpp 
        //******************************************************************

        if (ppdev->cjPelSize == 4)  // 32bpp
            {
            //**************************************************************
            // Init the 8x8 colored pattern
            //**************************************************************

            NV_DMAPUSH_START(64, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_X8R8G8B8(0));

            for (iy=0;iy<8;iy++)
                {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<8;ix++)
                    {                    
                    NV_DMA_FIFO = ScanPtr[ix];
                    }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
                }
            }
        else if (ppdev->cjPelSize == 2) // 16bpp
        
            {
            //**************************************************************
            // 16bpp
            //**************************************************************

            //**************************************************************
            // Init the 8x8 colored pattern for 16bpp
            //**************************************************************

            NV_DMAPUSH_START(32, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_R5G6B5(0));
                       

            for (iy=0;iy<8;iy++)
                {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<4;ix++)
                    {                    
                    NV_DMA_FIFO = ScanPtr[ix];  // 2 16bpp pixels at a time
                    }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
                }
                                                    
            }
                                         

        else
        
            {
            //**************************************************************
            // 8bpp
            //**************************************************************

            //**************************************************************
            // Init the 8x8 colored pattern for 8bpp
            //**************************************************************

            NV_DMAPUSH_START(16, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_Y8(0));
                       

            for (iy=0;iy<8;iy++)
                {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<2;ix++)
                    {                    
                    NV_DMA_FIFO = ScanPtr[ix];  // 4 8bpp pixels at a time
                    }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
                }
                                                    
            
            }
        
        //**********************************************************************
        //* Set the color method even tough we don't use it
        //**********************************************************************

        NV_DMAPUSH_START (1, RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_A);  
        NV_DMA_FIFO = 0;
        
        //**********************************************************************
        // Loop thru all the clipping rectangles
        //**********************************************************************
        do  {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = prcl->right - prcl->left;
            height= prcl->bottom - prcl->top;                             

            NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL, NV04A_UNCLIPPED_RECTANGLE(0))
            NV_DMA_FIFO = (prcl->left << 16) | prcl->top;
            NV_DMA_FIFO = (width << (16) | height);

            //******************************************************************
            // Onto the next clipping rectangle
            //******************************************************************

            prcl++;

            } while (--c != 0);


        } // Multi-color pattern

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

} // End of FillPatFast routine



//******************************************************************************
//
//  Function:   NV4DmaPushMonoScanlineImageTransfer
//
//  Routine Description:
//
//       Low-level routine for transferring a bitmap image via RENDER_GDI0_RECT_AND_TEXT
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

#ifdef UNUSED_FUNC

VOID NV4DmaPushMonoScanlineImageTransfer(
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
ULONG   NumDwordsPerScan)
    {
    ULONG *SrcDataPtr;
    ULONG i;
    
    DECLARE_DMA_FIFO;
    //**************************************************************************
    // Init dma pusher variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Dword Ptr to Src Data
    //**************************************************************************

    SrcDataPtr = (DWORD *)pjSrc;

    //**************************************************************************
    // Class 'E' can output a maximum of 128 dwords at a time
    // If we've got less than 128 dwords, blast them out all at once.
    //**************************************************************************

    while (NumDwordsPerScan >= 128)

        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(129)));  

        //**********************************************************************
        // Blast out all glyph data to push buffer
        //**********************************************************************

        NV_DMAPUSH_START(128, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );
    
        //**********************************************************************
        // Set the following methods for RECT_AND_TEXT
        //     NV04A_MONOCHROME_COLOR01_E(0)
        //     NV04A_MONOCHROME_COLOR01_E(1)
        //     NV04A_MONOCHROME_COLOR01_E(2)
        //      ...
        //**********************************************************************
    
        for (i=0 ; i< 128; i++)
            NV_DMA_FIFO = SrcDataPtr[i];    

        NumDwordsPerScan-=128;
        SrcDataPtr += 128;

        }
                

    //**************************************************************************
    // Handle remaining dwords
    //**************************************************************************

    if (NumDwordsPerScan>0)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(NumDwordsPerScan+1)));  

        //**********************************************************************
        // Blast out all glyph data to push buffer
        //**********************************************************************

        NV_DMAPUSH_START(NumDwordsPerScan, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );
    
        //**********************************************************************
        // Set the following methods for RECT_AND_TEXT
        //     NV04A_MONOCHROME_COLOR01_E(0)
        //     NV04A_MONOCHROME_COLOR01_E(1)
        //     NV04A_MONOCHROME_COLOR01_E(2)
        //      ...
        //**********************************************************************
    
        for (i=0;i<NumDwordsPerScan;i++)
            NV_DMA_FIFO = SrcDataPtr[i];    

        }


    //**************************************************************************
    // Update cached dma count variable
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    }
    
#endif    

#define DWORD_BLK_XFER                                                                                  \
{                                                                                                       \
    ULONG i;                                                                                            \
    ULONG *SrcDataPtr;                                                                                  \
                                                                                                        \
    SrcDataPtr = (DWORD *)pjSrc;                                                                        \
    while (NumDwordsPerScan >= 128)                                                                     \
    {                                                                                                   \
        NV_DMAPUSH_CHECKFREE(((ULONG)(129)));                                                           \
                                                                                                        \
        NV_DMAPUSH_START(128, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );                \
                                                                                                        \
        for (i=0 ; i< 128; i++)                                                                         \
            NV_DMA_FIFO = SrcDataPtr[i];                                                                \
                                                                                                        \
        NumDwordsPerScan-=128;                                                                          \
        SrcDataPtr += 128;                                                                              \
    }                                                                                                   \
                                                                                                        \
    NV_DMAPUSH_CHECKFREE(((ULONG)(NumBytesPerScan)));                                                   \
    if (NumDwordsPerScan>0)                                                                             \
    {                                                                                                   \
        NV_DMAPUSH_START(NumDwordsPerScan, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );   \
                                                                                                        \
        for (i=0;i<NumDwordsPerScan;i++)                                                                \
            NV_DMA_FIFO = SrcDataPtr[i];                                                                \
                                                                                                        \
    }                                                                                                   \
}

#define LAST_DWORD_XFER                                                                                 \
    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));                                                                 \
    NV_DMAPUSH_START(1, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );                      \
    NV_DMA_FIFO = LastDword;    


//******************************************************************************
//
//  Function:   NV4DmaPushXfer1bpp
//
//  Routine Description:
//
//     This routine colour expands a monochrome bitmap, possibly with different
//     Rop2's for the foreground and background.  It will be called in the
//     following cases:
//
//     1) To colour-expand the monochrome text buffer for the vFastText routine.
//     2) To blt a 1bpp source with a simple Rop2 between the source and
//        destination.
//  x  3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
//        white and black, and the pattern is a solid colour.
//     4) To handle a true Rop4 that works out to be two Rop2's between the
//        pattern and destination.
//
//     Needless to say, making this routine fast can leverage a lot of
//     performance.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushXfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,     // Solid Color of pattern
BLENDOBJ*   pBlendObj)
    {
    LONG    dxSrc;
    LONG    dySrc;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;
    LONG    xLeft;
    LONG    yTop;
    LONG    xBias;

    ULONG Color0;
    ULONG Color1;
    ULONG AlphaEnableValue;
    ULONG NumBytesPerScan;
    ULONG NumDwordsPerScan;
    ULONG OffsetOfLastDword;
    ULONG LastDword;
    ULONG width;
    ULONG height;
    ULONG SizeInWidth;
    ULONG rop3;
    ULONG ClipLeft;
    ULONG ClipTop;
    ULONG ClipWidth;
    ULONG ClipHeight;
    RECTL DstRect;
    
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Make sure following conditions are true before continuing on
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");
    ASSERTDD(((((rop4 & 0xff00) >> 8) == (rop4 & 0xff)) || (rop4 == 0xaacc)),
             "Expect weird rops only when opaquing");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // Init foreground and background color
    //**************************************************************************

    Color0 = pxlo->pulXlate[0] | (AlphaEnableValue); // Background color
    Color1 = pxlo->pulXlate[1] | (AlphaEnableValue); // Foreground color

    //**************************************************************************
    // Find the pitch and starting location of the source mono (pattern) bitmap
    //
    // NOTE:  Normally, we'd need to check if this source SURFOBJ was a
    //        standard DIB or a DFB that was moved to system memory.
    //        However, since we don't store 1bpp SURFOBJs in offscreen memory
    //        (see drvCreateDeviceBitmap), we know that the this source SURFOBJ
    //        is just a plain standard DIB. (i.e.  we don't need to get the
    //        'lDelta' and 'pvScan0' values from psoSrc->dhsurf->pso->lDelta
    //        and psoSrc->dhsurf->pso->pvScan0.
    //
    //**************************************************************************

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    //**************************************************************************
    // Safety check  ...check and see if source bitmap is dword aligned
    // This is a requirement....bitmap should never start on non-dword alignment..
    // Otherwise, that will invalidate some assumptions made...we currently
    // always read dword multiples...at dword alignments...if source bitmap
    // doesn't start on a dword boundary, then we might not be able to get
    // the first dword of data on a dword boundary ...Send back to DIBengine?
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3), "Unaligned source bitmap");

    //**************************************************************************
    // Adjust dest rect in case it is in offscreen memory
    //**************************************************************************

    DstRect.top = prclDst->top;
    DstRect.left = prclDst->left;
    DstRect.right = prclDst->right;
    DstRect.bottom = prclDst->bottom;

    do  {
        //**********************************************************************
        //
        //  First, we need to determine the XBIAS required (where the starting bit
        //  of the monochrome source bitmap is located).  XBIAS is affected
        //  by 3 values as follows:
        //
        //          1) pptlSrc->x    ( value x1 shown below )
        //
        //                  This is simply the bit at which we want to
        //                  start in the monochrome pattern bitmap
        //
        //          2) prclDst->x    ( value x2 shown below )
        //
        //                  Location of the original unclipped destination rectangle
        //
        //          3) prcl->x       ( value x3 shown below)
        //
        //                  Current clip rectangle with coordinates relative
        //                  to prclDst
        //
        //  Screen Origin
        //  +--------------------------------------------------------------->
        //  |
        //  |
        //  |           x2 = prclDst->left
        //  |           +-----------------------------------------------
        //  |           |                             ^                 |-Original
        //  |           |                             | dySrc           |  Unclipped
        //  |           |                             |                 |   Destination
        //  |           |         x3 = prcl->left     v                 |    Rectangle
        //  |           |         +------------       -                 |
        //  |           |         |            |                        |
        //  |           |<-dxSrc->|            |                        |
        //  |           |         |            |                        |
        //  |           |         |            |-Current                |
        //  |           |         |            |  Clip                  |
        //  |           |          ------------    Rectangle            |
        //  |           |                                               |
        //  |           |                                               |
        //  |           |                                               |
        //  |            -----------------------------------------------
        //  |
        //  v
        //
        //            Source MonoChrome Bitmap
        //          +--------+--------+--------+------->
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |           ^
        //          v           |
        //                      |
        //                      |
        //          |-- x1 ---->|
        //
        //**********************************************************************

        //**********************************************************************
        //
        // Once we determine the starting bit in the monochrome bitmap,
        // we can calculate the XBIAS value.  The left portion of the 1st source
        // dword that we will read will end up getting clipped by hardware.
        // This will allow us to NOT have to align subsequent source data.
        //
        //    xbias =  ( x1 + (x3 - x2) ) & 0x1f
        //
        //    xbias =  ( x1 + (dxSrc)   ) & 0x1f  ( starting bit position in dword)
        //                                                 from 0 - 31
        //
        //           --------------------------
        //          |00011001|00010010|00010011|  1st dword of source data
        //           --------------------------
        //          |               |          |
        //          |<--- xbias --->|          |
        //          |               |   This   |
        //          | This region is| region is|
        //          |   clipped     |  drawn   |
        //          v               v          v
        //
        //**********************************************************************

        //**********************************************************************
        // Set initial destination coordinates of blit
        //**********************************************************************

        yTop  = prcl->top;
        xLeft = prcl->left;

        //**********************************************************************
        // Init dimensions of clip rectangle.
        //**********************************************************************

        ClipTop = prcl->top;
        ClipLeft = prcl->left;

        ClipHeight = prcl->bottom - prcl->top;
        ClipWidth = prcl->right - prcl->left;

        //**********************************************************************
        // Find starting bit location of pattern.  We really only care about
        // the dword alignment (bottom 5 bits) of this value.
        //**********************************************************************

        dxSrc = prcl->left - DstRect.left;
        dySrc = prcl->top  - DstRect.top;

        //**********************************************************************
        // Determine the bias of the bitmap
        //**********************************************************************

        xBias = ( (pptlSrc->x + dxSrc) & 0x1f);     // Value from 0 thru 31
        if (xBias != 0)
            {
            //******************************************************************
            // NV: Set the hardware clip rectangle so we don't have to
            //     manually align the pattern bitmap.  Then make sure
            //     to adjust the starting point of the blit to account
            //     for this xbias.
            //
            // We should probably remove the  if (xBias !=0) statement
            // since it's not necessary.
            //******************************************************************

            xLeft -= xBias;
            }

        //**********************************************************************
        // Get width and height of the destination rectangle
        // Then calculate the DWORDS we'll send to the NV engine
        // (we always output DWORDS at a time), and the number of bytes per scan
        // SizeInWidth will always be a multiple of 32 pixels (1 dword's worth)
        //
        // Remember, xLeft has now been adjusted to account for the XBias value
        //**********************************************************************

        width = prcl->right - xLeft;
        height= prcl->bottom - yTop;

        //**********************************************************************
        // Get values required by NV hardware engine
        //**********************************************************************

        SizeInWidth = (width + 31) & 0xffe0;    // Always a multiple of 32 pixels
        NumBytesPerScan = SizeInWidth >> 3;     // Divide mono pixels by 8 to get bytes


        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(20)));  

        // Determine the color format
        switch (ppdev->iBitmapFormat)
            {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            }            

        //**********************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //    NV044_SET_MONOCHROME_COLOR0  
        //    NV044_SET_MONOCHROME_COLOR,  
        //    NV044_SET_MONOCHROME_PATTERN0
        //    NV044_SET_MONOCHROME_PATTERN1
        //**********************************************************************

        NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_64X_1Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
        NV_DMA_FIFO = (PatternColor | AlphaEnableValue); 
        NV_DMA_FIFO = (PatternColor | AlphaEnableValue);
        NV_DMA_FIFO = 0xffffffff;
        NV_DMA_FIFO = 0xffffffff;

        //**********************************************************************
        // Notify the rest of the driver that we changed the pattern
        //**********************************************************************

        ppdev->NVPatternResetFlag=1;

        //**********************************************************************
        // Get Rop3 value from Rop4
        //**********************************************************************

        rop3 = (ULONG)((BYTE)rop4);

        //**********************************************************************
        // Set Rop
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        //**********************************************************************
        // Set the following methods for RECT_AND_TEXT
        //      NV04A_CLIP_POINT0_E  
        //      NV04A_CLIP_POINT1_E  
        //      NV04A_COLOR0_E      
        //      NV04A_COLOR1_E      
        //      NV04A_SIZE_IN_E     
        //      NV04A_SIZE_OUT_E    
        //      NV04A_POINT_E       
        //**********************************************************************

        NV_DMAPUSH_START(7, RECT_AND_TEXT_SUBCHANNEL, NV04A_CLIP_POINT0_E );
        NV_DMA_FIFO = (  (ClipTop << 16) | (ClipLeft & 0xffff) );
        NV_DMA_FIFO = (((ClipTop+ClipHeight)<<16) | (ClipLeft+ClipWidth) );
        NV_DMA_FIFO = Color0 ;
        NV_DMA_FIFO = Color1 ;
        NV_DMA_FIFO = ( (height <<16) | SizeInWidth  );
        NV_DMA_FIFO = ( (height <<16) | width      );
        NV_DMA_FIFO = ( (yTop <<16) | (xLeft & 0xffff) );

        //**********************************************************************
        // Get starting byte address of source pattern bitmap
        // Once we have the starting byte address, we can get the starting dword address
        //
        // ?: Is it possible that pptlSrc->y + dySrc will go past
        //    end of Source Bitmap??
        //**********************************************************************

        pjSrc = pjSrcScan0 + (pptlSrc->y + dySrc) * lSrcDelta
                           + ((pptlSrc->x + dxSrc) >> 3);

        (ULONG_PTR)pjSrc &= ~0x3;

        //**********************************************************************
        // Get values pertinent for each scanline
        //**********************************************************************

        NumDwordsPerScan = SizeInWidth >> 5; //SizeInWidth / 32;
        OffsetOfLastDword = NumDwordsPerScan << 2;

        //**********************************************************************
        //
        // For performance, we have 2 main objectives as follows:
        //
        //   a) When reading src data, we'd like it to be dword aligned
        //   b) When outputting data, we'd like to output dwords as much as possible
        //
        // With that in mind, we accomplish objective (a) by calculating an
        // xbias value and reading the dword that the first byte of source data
        // is contained in.  That is, we'll grab the first dword of source data
        // and clip the left part of it using the hardware clip rectangle.
        // As a result, any subsequent reads of src data will not require
        // alignment.
        //
        // Example:
        //          Src data begins here --+
        //          at this bit            |
        //                                 v
        //           -----------------------------------
        //          |        |        |        |        |   1st dword of src data
        //           -----------------------------------
        //            byte 0    byte1    byte2    byte3
        //
        //          |<------ xbias ------->|
        //                                 |
        //                                 |<-- used -->|
        //                                 |    data
        //          |<- hardware clipped ->|
        //
        //
        // Objective (b) is accomplished by examining how many dwords we
        // need to output.  The key here is to make sure we don't read past
        // the end of the source bitmap. If the number of bytes we need to
        // output is a dword multiple, then we don't need to worry about it.
        // However, if it's not, we need to check the last couple of bytes
        // and not read past the end of the src data. Otherwise, we'll
        // generate a protection fault. This is done simply by using
        // a switch statement that handles 0,1,2, or 3 remaining bytes of src data.
        //
        //          Switch (Number Of src bytes left)
        //              0:  We are dword aligned already
        //              1:  Just read 1 more byte
        //              2:  Just read 2 more bytes
        //              3:  just read 3 more bytes
        //
        //**********************************************************************


        //**********************************************************************
        // Get src data, depending on how many bytes we will output
        // TO DO:  Since we now read the starting dword of the source bitmap
        //         (instead of the starting byte), isn't it true that
        //         we don't need to worry about straggling bytes going past
        //         end of bitmap...i.e. bitmaps are always allocated as
        //         multiples of dwords?  VERIFY!
        //
        //**********************************************************************

        switch (NumBytesPerScan & 3)
            {

            //******************************************************************
            // Output dwords at a time, then output last 3 bytes of data (in last dword)
            //******************************************************************

            case 3:
                do  {
                    if (NumDwordsPerScan > 0)
                        DWORD_BLK_XFER;

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword))  |
                            (*(pjSrc + OffsetOfLastDword + 1) << 8) |
                            (*(pjSrc + OffsetOfLastDword + 2) << 16);
                      
                    LAST_DWORD_XFER;        
                    
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // Output dwords at a time, then output last 2 bytes of data (in last dword)
            //******************************************************************

            case 2:
                do  {
                    if (NumDwordsPerScan > 0)
                        DWORD_BLK_XFER;


                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword))  |
                            (*(pjSrc + OffsetOfLastDword + 1) << 8);

                    LAST_DWORD_XFER;        
                    
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // Output dwords at a time, then output last byte of data (in last dword)
            //******************************************************************

            case 1:
                do  {
                    if (NumDwordsPerScan > 0)
                        DWORD_BLK_XFER;

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword));

                    LAST_DWORD_XFER;        
                    
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // The amount of data we will send is already a multiple of 4.
            // We will blast out all data in dwords
            //******************************************************************

            case 0:
                do  {
                    DWORD_BLK_XFER;
                    
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            } // Switch (NumBytesPerScan)

        prcl++;
        } while (--c != 0); // Next Clipping rectangle

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    }



//******************************************************************************
//
//  Function:   NV4_DmaPush_Send_Data
//
//  Routine Description:
//
//       Low-level routine for transferring a bitmap image via IMAGE_MONO_FROM_CPU
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4_DmaPush_Send_Data(
PDEV*   ppdev,
ULONG*  SrcDataPtr,              // Source pointer
ULONG   PixelCount)


    {
    ULONG DwordCount;
    ULONG i;
    
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    DwordCount = (PixelCount+3)>>2; // was /4 

    //**************************************************************************
    // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time
    // If we've got less than that, blast them out all at once.
    //**************************************************************************

    while (DwordCount >= 1024)

        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(1025)));  

        NV_DMAPUSH_START(1024, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_COLOR(0)
        //     NV061_COLOR(1)
        //     NV061_COLOR(2)
        //      ...
        //**********************************************************************
    
        for (i=0 ; i< 1024; i++)
            NV_DMA_FIFO = SrcDataPtr[i];    

        DwordCount-=1024;
        SrcDataPtr += 1024;

        }
                

    //**************************************************************************
    // Handle remaining dwords
    //**************************************************************************

    if (DwordCount>0)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(DwordCount+1)));  

        //**********************************************************************
        // Blast out remaining data
        //**********************************************************************

        NV_DMAPUSH_START(DwordCount, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_COLOR(0)
        //     NV061_COLOR(1)
        //     NV061_COLOR(2)
        //      ...
        //**********************************************************************
    
        for (i=0;i<DwordCount;i++)
            NV_DMA_FIFO = SrcDataPtr[i];    

        }


    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;


    }

//******************************************************************************
//
//  Function:   NV4DmaPushXfer4bpp
//
//  Routine Description:
//
//      Does a 4bpp transfer from a bitmap to the screen.
//
//      NOTE: The screen must be 8bpp for this function to be called!
//
//      The reason we implement this is that a lot of resources are kept as 4bpp,
//      and used to initialize DFBs, some of which we of course keep off-screen.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


//******************************************************************************
// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.
//
// NV_HALF_BUFFER_SIZE -> NV fifo can hold up to 32 DWORDS (128 bytes)
//                        Here, we output the data when we've reach half of that
//******************************************************************************

#define XLATE_BUFFER_SIZE 256
#define NV_HALF_FIFO_SIZE 16*4

VOID NV4DmaPushXfer4bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG PatternColor,
BLENDOBJ*   pBlendObj)  // Not used

    {
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;

    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG Rop3;
    LONG xsrc,ysrc;
    BYTE *NextScan;
    ULONG yscan;
    BYTE *ScanPtr;
    LONG ScanInc;
    BYTE *DstBits;
    ULONG SizeInWidth;
    LONG clip_x,clip_y;
    ULONG clip_width,clip_height;
    BYTE TempPixelData[XLATE_BUFFER_SIZE];
    DSURF*  pdsurfSrc;
    ULONG*  pulXlate;
    BYTE  PixelDataByte;
    ULONG PixelDataDword;
    ULONG   LoopCount;
    ULONG PixelCount;
    ULONG i;

    DECLARE_DMA_FIFO;
    
    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get ready to translate the 4bpp colors
    //**************************************************************************

    ASSERTDD(pxlo != NULL, "Xfer4BPP, NULL XLATEOBJ");
    pulXlate  =  pxlo->pulXlate;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    if (pdsurfSrc != NULL)
        pjSrcScan0 = pdsurfSrc->pso->pvScan0;
    else
        pjSrcScan0 = psoSrc->pvScan0;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************
    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3),
        "Unaligned source bitmap");// ACK!....src bitmap is not dword aligned !!!

    //**************************************************************************
    // Get Rop3 value
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
    else
        BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************
    ASSERTDD(!((ULONG) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = BytesPerSrcScan ;      // Number of bytes to increment

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //***************************************************************************

    if (ppdev->NVClipResetFlag)
       {
       //***********************************************************************
       // Check if we've got enough room in the push buffer
       //***********************************************************************

       NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

       //***********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //***********************************************************************

       NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
       NV_DMA_FIFO = 0;
       NV_DMA_FIFO = ppdev->dwMaxClip; 

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
       }

    //**************************************************************************
    // Blit for each clipping rectangle
    //**************************************************************************

    while(TRUE)
        {

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + prcl->left - prclDst->left;
        ysrc = pptlSrc->y + prcl->top  - prclDst->top;

        //**********************************************************************
        // Get ptr to start of SRC (Remember, there are 2 pixels per byte!)
        //**********************************************************************

        NextScan = &(pjSrcScan0[(LONG)((xsrc>>1) + ysrc*BytesPerSrcScan)]);

        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - prcl->left;
        clip_height = prcl->bottom - prcl->top;

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

        //**********************************************************************
        // Setup NV Blit parameters for CPU to SCREEN blit
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ( ( clip_y << 16) | ( clip_x & 0xffff)  );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width  );

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        if (depth == 8)
            SizeInWidth = ((clip_width + 3) & 0xfffc);
        else if (depth == 16)
            SizeInWidth = ((clip_width + 1) & 0xfffe);
        else
            SizeInWidth = clip_width;

        //*********************************************************************
        //     NV061_SIZE_IN 
        //*********************************************************************

        NV_DMA_FIFO = ( (clip_height <<16) | (SizeInWidth)  );

        //*********************************************************************
        //
        // 4bpp Source Bitmap:
        //
        // nibble| hi lo | hi  lo| hi lo | hi lo | hi  lo|
        //        -----------------------------------------------
        //       | Byte0 | Byte1 | Byte2 | Byte3 | Byte4 | etc..
        //        -----------------------------------------------
        // Pixels  0  1    2  3     4  5    6  7    8  9
        //
        // Pixels are displayed on screen as UPPER NYBBLE, then LOWER NYBBLE
        //
        // We must be careful not to read past end of 4bpp bitmap
        // We do this by breaking up the operation into 2 cases:
        //
        // If the starting pixel is ODD, then we need to read
        // the LOWER nybble of the source byte first, and proceed from there.
        // If the starting pixel is EVEN, then we need to read
        // the UPPER nybble of the source byte first, and proceed from there.
        //
        //*********************************************************************

        //*********************************************************************
        //
        // The IA64 will fault on unaligned addresses.  Therefore use
        // the "odd" path in these cases to prevent DWORD sized accesses
        // that have this problem. Note that xsrc being divisible by 8
        // implies that the source address is divisible by 4.
        //
        //*********************************************************************

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

#ifdef _WIN64
        if ( xsrc & 0x7)
#else
        if ( xsrc & 0x1)
#endif
            {

            for (yscan=0;yscan < clip_height; yscan++)
                {
                ScanPtr = NextScan;
                PixelCount=0;
                //**************************************************************
                // For each byte, we read 2 pixels.  We will count by bytes.
                // If xsrc is ODD, we start on the ODD pixel so we read the LOWER
                // nibble of the current source byte FIRST, then we read the UPPER nibble
                // Vice Versa if xsrc is Even (which it can be for Win64's enforcement of DWord aligned access)
                // 
                //**************************************************************

                LoopCount= clip_width>>1 ;      // Odd pel handled separately

                //**************************************************************
                // Get the current 2 pixels of data
                //**************************************************************

                PixelDataByte = *ScanPtr;

                while (LoopCount-- > 0)
                    {
                    // If xsrc is ODD - no shift since first read in loop is lower nibble of current BYTE
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataByte >> ((xsrc & 0x1) ? 0 : 4)) & 0xf];

                    // If xsrc is ODD, prior read was lower nibble of BYTE, so advance to next BYTE
                    if (xsrc & 0x1) 
                        {
                        ScanPtr++;
                        PixelDataByte =*ScanPtr ;
                        }
                    
                    // If xsrc is ODD - shift since second read in loop is upper nibble of new byte read above
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataByte >> ((xsrc & 0x1) ? 4 : 0)) & 0xf];

                    // If xsrc is EVEN, prior read was lower nibble of BYTE, so advance to next BYTE
                    if (!(xsrc & 0x1))
                        {
                        ScanPtr++;
                        PixelDataByte =*ScanPtr ;
                        }


                    //**********************************************************
                    // Check if we need to flush the data and
                    // send it to NV hardware
                    //**********************************************************

                    if (PixelCount >= NV_HALF_FIFO_SIZE)
                        {
                        UPDATE_PDEV_DMA_COUNT;
                        NV4_DmaPush_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount);
                        UPDATE_LOCAL_DMA_COUNT;
                        PixelCount=0;
                        }
                    }

                //**************************************************************
                // Check for any straggling pixel leftover
                // If xsrc is ODD - no shift since we want lower nibble of current BYTE
                //**************************************************************
                if (clip_width & 1)
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataByte >> ((xsrc & 0x1) ? 0 : 4)) & 0xf];

                //**************************************************************
                // Flush any remaining pixel data
                //**************************************************************

                if (PixelCount!=0)
                    {
                    UPDATE_PDEV_DMA_COUNT;
                    NV4_DmaPush_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount);
                    UPDATE_LOCAL_DMA_COUNT;
                    }
                    
                NextScan+=ScanInc;

            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

                UPDATE_PDEV_DMA_COUNT;
                NV4_DmaPushSend(ppdev);             // Time to kickoff the buffer
                UPDATE_LOCAL_DMA_COUNT;

                }
            }
        else
            {

            for (yscan=0;yscan < clip_height; yscan++)
                {
                ScanPtr = NextScan;
                PixelCount=0;
                //**************************************************************
                // Pixels are displayed on screen as UPPER NYBBLE, then LOWER NYBBLE
                //**************************************************************

                LoopCount = (clip_width + 1) >> 1;  // Each loop handles 2 pels

                do  {
                    //**********************************************************
                    // See if we can speed things up a bit by reading DWORDS
                    //**********************************************************

                    if (LoopCount>=4)               // 8 pels or more to go?
                        {
                        PixelDataDword = *((DWORD *)ScanPtr);
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >> 4) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword     ) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>12) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >> 8) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>20) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>16) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>28) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>24) & 0xf];

                        ScanPtr+=4;                 // Advance by 8 source pels

                        LoopCount-=4;               // 4 groups of 2 pels = 8 pels
                        }

                    else
                        {
                        PixelDataByte = *ScanPtr;

                        TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte >> 4];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte & 0xf];

                        ScanPtr++;                  // Advance by 2 source pels

                        LoopCount--;                // 1 group of 2 pels = 2 pels
                        }

                    //**********************************************************
                    // Check if we need to flush the data and
                    // send it to NV hardware
                    //**********************************************************

                    if (PixelCount >= NV_HALF_FIFO_SIZE)
                        {
                        UPDATE_PDEV_DMA_COUNT;
                        NV4_DmaPush_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount);
                        UPDATE_LOCAL_DMA_COUNT;
                        PixelCount=0;
                        }

                    } while (LoopCount != 0);

                //**************************************************************
                // Flush any remaining pixel data
                //**************************************************************

                if (PixelCount!=0)
                    {
                    UPDATE_PDEV_DMA_COUNT;
                    NV4_DmaPush_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount);
                    UPDATE_LOCAL_DMA_COUNT;
                    }
                    

                NextScan+=ScanInc;
                
            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

                UPDATE_PDEV_DMA_COUNT;
                NV4_DmaPushSend(ppdev);             // Time to kickoff the buffer
                UPDATE_LOCAL_DMA_COUNT;
                }
            }

        if (--c == 0)
            {
            return;
            }

        prcl++;

        } // while (TRUE)...




    }


//******************************************************************************
//
//  Function:   NV4DmaPushXferNative
//
//      Transfers a bitmap that is the same colour depth as the display to
//      the screen via the data transfer register, with no translation.
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushXferNative(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,
BLENDOBJ*   pBlendObj)
{
    LONG    lSrcDelta;
    BYTE*   SrcBits;
    BYTE*   pjSrc;
    LONG    cjSrc;

    ULONG   BytesPerSrcPixel;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    LONG    xsrc,ysrc;
    ULONG   xsrcOffset;
    ULONG   AlignMask;
    ULONG*  NextScan;
    ULONG   BytesPerDstScan;
    ULONG   yscan;
    ULONG*  ScanPtr;
    LONG    ScanInc;
    BYTE*   DstBits;
    ULONG   SizeInWidth;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    DSURF*  pdsurfSrc;
    ULONG   ByteCount;
    ULONG   i;
    ULONG   TempPixelData1;
    ULONG   BytesWritten;

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD((pxlo == NULL) || !pxlo->flXlate || (pxlo->flXlate & XO_TRIVIAL) ||
            ((pxlo->flXlate == 0x10) && (OglIsEnabled(ppdev))),
            "Can handle trivial xlate only");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff), "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Setup Blender if needed  -paul
    // Only supported on Win2k
    //**************************************************************************
    
#if (_WIN32_WINNT >= 0x0500)
    
    if (pBlendObj) 
        {
        //**************************************************************************
        // Need to load alpha value into all bytes of the word since the hardware
        // uses each byte independently as an alpha value
        //**************************************************************************
        ULONG constAlpha = 0x00000000;
        
        constAlpha = pBlendObj->BlendFunction.SourceConstantAlpha & 0x000000FF;
        constAlpha |=constAlpha <<  8;
        constAlpha |=constAlpha <<  16;

        NV_DMAPUSH_CHECKFREE(((ULONG)(5*2)));
        
        if (ppdev->dDrawSpareSubchannelObject != NV_DD_CONTEXT_BETA4)
            {
            NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), NV_DD_CONTEXT_BETA4);
            ppdev->dDrawSpareSubchannelObject = NV_DD_CONTEXT_BETA4;
            }
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NV072_SET_BETA_FACTOR, constAlpha);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION, NV061_SET_OPERATION_BLEND_PREMULT);
        
        // If Alpha in source pixels, change source format - default 061 format has no alpha
        if (pBlendObj->BlendFunction.AlphaFormat & AC_SRC_ALPHA) 
            {
            // 32bpp source if it has alpha
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_A8R8G8B8);
            }
            else
            {
            // If no alpha, set to 16bpp or 32bpp format, w/ no src alpha.  HW then treats alpha as 0xff (1.0)
            // Note caller may have called AlphaPreserve to set source (061) format to format w/ alpha
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, 
                              (psoSrc->iBitmapFormat == BMF_16BPP) ? NV061_SET_COLOR_FORMAT_LE_R5G6B5 : 
                                                                     NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
            }
        
        if ((ppdev->iBitmapFormat == BMF_16BPP) &&
            (ppdev->CurrentClass.ContextSurfaces2D != NV04_CONTEXT_SURFACES_2D))
            {
            // For post NV4 hw, we turn dither off for the blend
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV065_SET_COLOR_CONVERSION, NV065_SET_COLOR_CONVERSION_TRUNCATE);
            }

        }
    else if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
        {
        // Some non-blend Native Xfers support source format different from vidmem (eg. TransparentBlt)
        NV_DMAPUSH_CHECKFREE(((ULONG)(1*2)));
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, 
                      (psoSrc->iBitmapFormat == BMF_16BPP) ? NV061_SET_COLOR_FORMAT_LE_R5G6B5 : 
                                                             NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
        }
#endif //(_WIN32_WINNT >= 0x0500)
    
    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**********************************************************************
    // Compute the alignment mask for rounding up SizeIn and for computing
    // correctly aligned addresses for IA64.
    //**********************************************************************

    if (psoSrc->iBitmapFormat == BMF_8BPP)
        {
        BytesPerSrcPixel = 1;
        AlignMask = 0x3;
        }
    else if (psoSrc->iBitmapFormat == BMF_16BPP)
        {
        BytesPerSrcPixel = 2;
        AlignMask = 0x1;
        }
    else
        {
        BytesPerSrcPixel = 4;
        AlignMask = 0x0;
        }

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        if ((prclDst->right - prclDst->left) < (prcl->right - clip_x))
            {
            clip_width = prclDst->right - prclDst->left;
            }
        else
            {
            clip_width = prcl->right - clip_x;
            }
        if ((prclDst->bottom - prclDst->top) < (prcl->bottom - clip_y))
            {
            clip_height = prclDst->bottom - prclDst->top;
            }
        else
            {
            clip_height = prcl->bottom - clip_y;
            }

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional (ignored) pixels
        //**********************************************************************

        //**********************************************************************
        // The IA64 architecture provides an additional complication: unaligned
        // accesses cause the process to fault.  Detect the unaligned cases and
        // mask off the offending address bits; once again we'll be sending more
        // bits to the NV engine as necessary.  Rely on the clipper (in this
        // case only) to drop the leading left edge of pixels.
        //**********************************************************************


        //**********************************************************************
        // Determine whether we will have a misaligned access on the IA64.
        // Alignment poses no problem for the X86 so clear the adjustment.
        //**********************************************************************

#ifdef _WIN64
        xsrcOffset = xsrc & AlignMask;
#else
        xsrcOffset = 0;
#endif

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(12)));

#if defined(_WIN64)

        if (xsrcOffset)
            {
            //**********************************************************************
            // For unaligned (DWORD) accesses, set the clipping region to the
            // original dest size to prevent drawing any more than requested.
            //**********************************************************************

            //******************************************************************
            // Set Point and Size methods for clip:
            //    NV019_SET_POINT
            //    NV019_SET_SIZE
            //******************************************************************

            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = ((0 << 16) |  clip_x);
            NV_DMA_FIFO = ((ppdev->cyMemory << 16) | clip_width); 

            ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset

            // adjust src x to DWORD boundary
            xsrc -= xsrcOffset;

            // adjust clip_x, clip_width - used for Dst x and width from here on
            clip_x -= xsrcOffset;
            clip_width += xsrcOffset;
            }
    else
#endif
        //**********************************************************************
        // Reset clipping rectangle to full screen extents if necessary
        // Resetting the clipping rectangle causes delays so we want to do it
        // as little as possible!
        //**********************************************************************

        if (ppdev->NVClipResetFlag)
            {

            //******************************************************************
            // Set Point and Size methods for clip:
            //    NV019_SET_POINT
            //    NV019_SET_SIZE
            //******************************************************************

            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = 0;
            NV_DMA_FIFO = ppdev->dwMaxClip; 

            ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
            }

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ( (clip_y <<16) | (clip_x & 0xffff) );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width );

        //**********************************************************************
        // Calculate the number of DWORDs to output for each scanline and
        // compute the address to the start of the source.  If the original 
        // value would have created an unaligned source address, back up the
        // left margin and increase the width to compensate.  In either case
        // round the SizeIn argument as described above.
        //**********************************************************************
    
        SizeInWidth = ((clip_width + AlignMask) & ~AlignMask);
        NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc*BytesPerSrcPixel) +
                                              (ysrc*BytesPerSrcScan))]));

        BytesPerDstScan = clip_width * BytesPerSrcPixel;

        //**********************************************************************
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMA_FIFO = ( (clip_height <<16) | SizeInWidth  );

        //**********************************************************************
        // Amount to increment for each scanline
        //**********************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

#ifdef _X86_
        //**********************************************************************
        // Use assembly to output as fast as possible
        //**********************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPush_Transfer_MemToScreen_Data(ppdev,BytesPerDstScan,clip_height,NextScan,ScanInc);
        UPDATE_LOCAL_DMA_COUNT;

#else   // ifdef _x86_

        //*********************************************************************
        // The following C code is the exact equivalent of
        // NV4_Transfer_MemToScreen_Data in assembly.
        //*********************************************************************

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0;yscan < clip_height; yscan++)
            {
            ByteCount=BytesPerDstScan; 
            ScanPtr = NextScan;

            //******************************************************************
            // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time
            // If we've got less than that, blast them out all at once.
            //******************************************************************

            while (ByteCount >= 1024 * sizeof(ULONG))

                {
                //**************************************************************
                // Check if we've got enough room in the push buffer
                //**************************************************************

                NV_DMAPUSH_CHECKFREE(((ULONG)(1025)));  

                NV_DMAPUSH_START(1024, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
                //**************************************************************
                // Set the following methods for IMAGE_FROM_CPU
                //     NV061_COLOR(0)
                //     NV061_COLOR(1)
                //     NV061_COLOR(2)
                //      ...
                //**************************************************************
            
                for (i=0 ; i< 1024; i++)
                    NV_DMA_FIFO = ScanPtr[i];    

                ByteCount -= (1024 * sizeof(ULONG));
                ScanPtr += 1024;

                }


            //******************************************************************
            // Handle remaining dwords
            //******************************************************************

            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)((ByteCount>>2) + 3)));  

            if (ByteCount>=4)
                {

                //**************************************************************
                // Blast out remaining data
                //**************************************************************

                NV_DMAPUSH_START((ByteCount>>2), IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
                //**************************************************************
                // Set the following methods for IMAGE_FROM_CPU
                //     NV061_COLOR(0)
                //     NV061_COLOR(1)
                //     NV061_COLOR(2)
                //      ...
                //**************************************************************
        
                for (i=0;i<(ByteCount>>2);i++)
                    NV_DMA_FIFO = ScanPtr[i];    
        
                ScanPtr += (ByteCount>>2);
                ByteCount -= ((ByteCount>>2) * sizeof(ULONG));

                }

            //
            // Pad src scanline.
            //
            if (ByteCount)
                {
                //**************************************************************
                // Check if we've got enough room in the push buffer
                //**************************************************************

                TempPixelData1 = 0;
                for (i = 0; i < ByteCount; i++)
                {
                    TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) ,  TempPixelData1  );

                }

            NextScan+=ScanInc;

            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }
#endif  // ifdef else _X86_

        if (--c == 0)
            {
            goto All_Done;
            }

        prcl++;

        } // while (TRUE)...
All_Done:
    
#if (_WIN32_WINNT >= 0x0500)
                                                                     
    // If blending, restore Object state to defaults before return
    if (pBlendObj) 
        {
        NV_DMAPUSH_CHECKFREE((ULONG)(3*2));  
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION, NV061_SET_OPERATION_ROP_AND);
        // Restore color format which was changed to be the source image format
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, 
                              (ppdev->iBitmapFormat == BMF_16BPP) ? NV061_SET_COLOR_FORMAT_LE_R5G6B5 : 
                                                                    NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
        if ((ppdev->iBitmapFormat == BMF_16BPP) &&
            (ppdev->CurrentClass.ContextSurfaces2D != NV04_CONTEXT_SURFACES_2D))
            {
            // For post NV4 hw, we turned dither off for the blend, so restore here
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV065_SET_COLOR_CONVERSION, NV065_SET_COLOR_CONVERSION_DITHER);
            }

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
        }   
    else if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
        {
        // Restore source format if earlier changed since is different from vidmem format
        NV_DMAPUSH_CHECKFREE(((ULONG)(1*2)));
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, 
                              (ppdev->iBitmapFormat == BMF_16BPP) ? NV061_SET_COLOR_FORMAT_LE_R5G6B5 : 
                                                                    NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
        }

#endif //(_WIN32_WINNT >= 0x0500)
 
    return;
}

//******************************************************************************
//
//  Function:   NV4DmaPushMemToScreenBlit
//
//  Routine Description:
//
//      Does a memory-to-screen blt
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushMemToScreenBlt(
PDEV*   ppdev,
SURFOBJ* psoSrc,
POINTL* pptlSrc,
RECTL*  prclDst)

    {
    ULONG width,height;
    ULONG xscan,yscan;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    ULONG xsrcOffset;
    ULONG depth;
    ULONG AlignMask;
    LONG BytesPerSrcScan;
    ULONG ByteCount;
    ULONG SizeInWidth;
    ULONG BytesPerDstScan;
    ULONG *ScanPtr;
    ULONG *NextScan;
    LONG ScanInc;
    BYTE* SrcBits;
    DSURF* pdsurfSrc;
    ULONG TempPixelData1;
    ULONG BytesWritten;
    ULONG i;

    DECLARE_DMA_FIFO;
    //**************************************************************************
    // This function is exactly the same as XferNative, except
    // that 1) Rop = SRCCOPY always
    //      2) No clipping is done here
    //      3) No color translation
    //**************************************************************************

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = (BytesPerSrcScan+3) >> 2;
        
    //**************************************************************************
    // Top left coordinate of destination on destination surface
    //**************************************************************************

    xdst = prclDst->left;
    ydst = prclDst->top;

    //**************************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**************************************************************************

    width = prclDst->right - xdst;
    height = prclDst->bottom - ydst;

    //**************************************************************************
    // Top left coordinate of source bitmap on source surface
    //**************************************************************************

    xsrc = pptlSrc->x;
    ysrc = pptlSrc->y;

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    //**************************************************************************

    //**************************************************************************
    // The IA64 architecture provides an additional complication: unaligned
    // accesses cause the process to fault.  Detect the unaligned cases and
    // mask off the offending address bits; once again we'll be sending more
    // bits to the NV engine as necessary.  Rely on the clipper (in this case
    // only) to drop the leading left edge of pixels.
    //**************************************************************************

    //**************************************************************************
    // Compute the alignment mask for rounding up SizeIn and for computing
    // correctly aligned addresses for IA64.
    //**************************************************************************

    if (depth == 8)
        AlignMask = 0x3;
    else if (depth == 16)
        AlignMask = 0x1;
    else
        AlignMask = 0x0;

    //**************************************************************************
    // Determine whether we will have a misaligned access on the IA64.
    // Alignment poses no problem for the X86 so clear the offset.
    //**************************************************************************

#ifdef _WIN64
    xsrcOffset = xsrc & AlignMask;
#else
    xsrcOffset = 0;
#endif

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(9)));

#if defined(_WIN64)
   //***************************************************************************
   // For unaligned (DWORD) accesses, set the clipping region to the
   // original dest size to prevent drawing any more than requested.
   //***************************************************************************

   if (xsrcOffset)
       {
       //***********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //***********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = ((0 << 16) |  xdst);
        NV_DMA_FIFO = ((ppdev->cyMemory << 16) | width); 
        
        // adjust src x to DWORD boundary
        xsrc -= xsrcOffset;

        // adjust xdst, width - used for Dst x and width from here on
        xdst -= xsrcOffset;
        width += xsrcOffset;

        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
       }
   else
#endif
   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

   if (ppdev->NVClipResetFlag)
       {
       //***********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //***********************************************************************

       NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
       NV_DMA_FIFO = 0;
       NV_DMA_FIFO = ppdev->dwMaxClip; 

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
       }

    //**************************************************************************
    // Initialize the ImageFromCpu object
    //**************************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , NV_SRCCOPY);

    //**************************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_POINT     
    //     NV061_SIZE_OUT  
    //     NV061_SIZE_IN 
    //**************************************************************************

    NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
    NV_DMA_FIFO = ( (ydst <<16) | (xdst & 0xffff) );
    NV_DMA_FIFO = ( (height <<16) | width );

    //**************************************************************************
    // Calculate the number of DWORDs to output for each scanline and
    // compute the address to the start of the source.  If the original 
    // value would have created an unaligned source address, back up the
    // left margin and increase the width to compensate.  In either case
    // round the SizeIn argument as described above.
    //**************************************************************************
    
    SizeInWidth = ((width + AlignMask) & ~AlignMask);
    BytesPerDstScan = width * (depth>>3);
    NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc*(depth>>3)) +
                                          (ysrc*BytesPerSrcScan))]));

    //**************************************************************************
    //     NV061_SIZE_IN 
    //**************************************************************************

    NV_DMA_FIFO = ( (height <<16) | (SizeInWidth) );

#ifdef _X86_
    //**************************************************************************
    // Use assembly to output as fast as possible
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPush_Transfer_MemToScreen_Data(ppdev,BytesPerDstScan,height,NextScan,ScanInc);

#else   // ifdef _x86_

    //**************************************************************************
    // The following C code is the exact equivalent of
    // NV4_Transfer_MemToScreen_Data in assembly.
    //**************************************************************************

    //***************************************************************************
    // Output one scan at a time
    //***************************************************************************

    for (yscan=0;yscan < height; yscan++)
        {
        ByteCount = BytesPerDstScan;

        ScanPtr = NextScan;

        //**********************************************************************
        // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time
        // If we've got less than that, blast them out all at once.
        //**********************************************************************

        while (ByteCount >= 1024 * sizeof(ULONG))

            {
            //******************************************************************
            // Check if we've got enough room in the push buffer
            //******************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)(1025)));  


            NV_DMAPUSH_START(1024, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //******************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //******************************************************************
        
            for (i=0 ; i< 1024; i++)
                NV_DMA_FIFO = ScanPtr[i];    

            ByteCount -= (1024 * sizeof(ULONG));
            ScanPtr += 1024;

            }


        //******************************************************************
        // Check if we've got enough room in the push buffer
        //******************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)((ByteCount>>2) + 3)));  

        //**********************************************************************
        // Handle remaining dwords
        //**********************************************************************

        if (ByteCount>=4)
            {
            //******************************************************************
            // Blast out remaining data
            //******************************************************************

            NV_DMAPUSH_START((ByteCount>>2), IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //******************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //******************************************************************
    
            for (i=0;i<(ByteCount>>2);i++)
                NV_DMA_FIFO = ScanPtr[i];    
    
            ScanPtr += (ByteCount>>2);
            ByteCount -= ((ByteCount>>2) * sizeof(ULONG));
            }


        //**********************************************************************
        // Pad src scanline.
        //**********************************************************************
        if (ByteCount)
            {
            ULONG   i;
            TempPixelData1 = 0;
            for (i = 0; i < ByteCount; i++)
                {
                TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) , TempPixelData1  );
            }

        NextScan+=ScanInc;

        //*********************************************************************
        // Kickoff buffer after each scanline
        //*********************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
        UPDATE_LOCAL_DMA_COUNT;
        }

#endif  // _X86_

    }

//******************************************************************************
//
//  Function:   NV4DmaPushMemToScreenWithPatternBlt()
//
//  Routine Description:
//
//              Does a memory-to-screen with pattern blt
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushMemToScreenWithPatternBlt(
PDEV*   ppdev,
SURFOBJ* psoSrc,
POINTL* pptlSrc,
RECTL*  prclDst,
ULONG rop3,
RBRUSH_COLOR   *rbc,
RECTL*  prclClip
)


    {
    ULONG width,height;
    ULONG xscan,yscan;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    ULONG depth;
    ULONG xsrcOffset;
    LONG BytesPerSrcScan;
    ULONG ByteCount;
    ULONG SizeInWidth;
    ULONG BytesPerDstScan;
    ULONG TempPixelData1;
    ULONG *ScanPtr;
    ULONG *NextScan;
    LONG ScanInc;
    BYTE* SrcBits;
    DSURF* pdsurfSrc;
    ULONG   i;
    ULONG AlphaEnableValue;
    DECLARE_DMA_FIFO;


    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**************************************************************************

    width = prclDst->right - prclDst->left;
    height = prclDst->bottom - prclDst->top;

    //**************************************************************************
    // Top left coordinate of source bitmap on source surface
    //**************************************************************************

    xsrc = pptlSrc->x;
    ysrc = pptlSrc->y;

    //**************************************************************************
    // Top left coordinate of destination on destination surface
    //**************************************************************************

    xdst = prclDst->left;
    ydst = prclDst->top;

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Determine whether we will have a misaligned access on the IA64.
    // Alignment poses no problem for the X86 so clear the offset.
    //**************************************************************************

#ifdef _WIN64
    if (depth == 8)
        xsrcOffset = xsrc & 0x3;
    else if (depth == 16)
        xsrcOffset = xsrc & 0x1;
    else
        xsrcOffset = 0x0;
#else
    xsrcOffset = 0;
#endif

    //***********************************************************************
    // Check if we've got enough room in the push buffer
    //***********************************************************************
 
    NV_DMAPUSH_CHECKFREE(((ULONG)(19)));  


#if defined(_WIN64)
   //***************************************************************************
   // For unaligned (DWORD) accesses, set the clipping region to the
   // original dest size to prevent drawing any more than requested.
   //***************************************************************************

   if (xsrcOffset)
       {
       //***********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //***********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = ((0 << 16) |  xdst);
        NV_DMA_FIFO = ((ppdev->cyMemory << 16) | width); 
        
        // adjust src x to DWORD boundary
        xsrc -= xsrcOffset;

        // adjust xdst, width - used for Dst x and width from here on
        xdst -= xsrcOffset;
        width += xsrcOffset;

        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
       }
   else
#endif


   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

    if((prclClip == NULL) && (ppdev->NVClipResetFlag))
    {
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 
        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
    }
    else if(prclClip != NULL)
    {
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = (( prclClip->top << 16) |  prclClip->left);
        NV_DMA_FIFO = (((prclClip->bottom - prclClip->top) << 16) 
                    | (prclClip->right - prclClip->left) ); 
        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
    }

    //**************************************************************************
    // Wait for FIFO, then set pattern registers
    //**************************************************************************

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
           break;
        case BMF_16BPP:
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
           break;
        default:
        case BMF_8BPP:
           // Must be set to a legal value but hardware ignores it otherwise 
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
           break;
        }            

    //**************************************************************************
    // Set the following methods for context_pattern
    //    NV044_SET_MONOCHROME_FORMAT 
    //    NV044_SET_MONOCHROME_SHAPE  
    //    NV044_SET_PATTERN_SELECT    
    //    NV044_SET_MONOCHROME_COLOR0  
    //    NV044_SET_MONOCHROME_COLOR,  
    //    NV044_SET_MONOCHROME_PATTERN0
    //    NV044_SET_MONOCHROME_PATTERN1
    //**************************************************************************

    NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
    NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
    NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_64X_1Y;
    NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
    NV_DMA_FIFO = (ULONG)(rbc->iSolidColor | AlphaEnableValue); 
    NV_DMA_FIFO = (ULONG)(rbc->iSolidColor | AlphaEnableValue);
    NV_DMA_FIFO = 0xffffffff;
    NV_DMA_FIFO = 0xffffffff;

    //**************************************************************************
    // Notify the rest of the driver that we changed the pattern
    //**************************************************************************

    ppdev->NVPatternResetFlag=1;

    //**************************************************************************
    // Wait for FIFO, then set IMAGE_FROM_CPU registers
    //**************************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

    //**************************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_POINT     
    //     NV061_SIZE_OUT  
    //     NV061_SIZE_IN 
    //**************************************************************************

    NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
    NV_DMA_FIFO = ( (ydst <<16) | (xdst & 0xffff) );
    NV_DMA_FIFO = ( (height <<16) | width );

    //**************************************************************************
    // Specifying 1 more pixel (example: in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    // SizeIn is specified in pixels.
    //**************************************************************************

    //**************************************************************************
    // Calculate number of dwords to output per scanline
    // This is the actual amount of data that the NV engine expects per scanline.
    // SizeInWidth is guaranteed to be a multiple of 2 (for 16bpp) and
    // a multiple of 4 (for 8bpp).  So we'll always be outputting DWORDS.
    // (No leftover words or bytes, they get clipped)
    //**************************************************************************

    //**************************************************************************
    // Get ptr to start of SRC
    //**************************************************************************

    if (depth == 8)
        {        
        SizeInWidth = ((width + 3) & 0xfffc);       // We always send 4 pixels at a time
        BytesPerDstScan = width;
        NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc) + (ysrc*BytesPerSrcScan))]));
        }
    else if (depth == 16)
        {        
        SizeInWidth = ((width + 1) & 0xfffe);       // We always send 2 pixels at a time
        BytesPerDstScan = width * 2;
        NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc*2) + (ysrc*BytesPerSrcScan))]));
        }
    else
        {        
        SizeInWidth = width;                        // We always send 1 pixel at a time
        BytesPerDstScan = width * 4;
        NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc*4) + (ysrc*BytesPerSrcScan))]));
        }

    //**************************************************************************
    //     NV061_SIZE_IN 
    //**************************************************************************

    NV_DMA_FIFO = ( (height <<16) | (SizeInWidth)  );

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

#ifdef _X86_

    //**********************************************************************
    // Use assembly to output as fast as possible
    //**********************************************************************

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPush_Transfer_MemToScreen_Data(ppdev,BytesPerDstScan,height,NextScan,ScanInc);

#else   // ifdef _x86_

    //**************************************************************************
    // Output one scan at a time
    //**************************************************************************

    for (yscan=0;yscan < height; yscan++)
        {
        ByteCount=BytesPerDstScan;

        ScanPtr = NextScan;

        //**********************************************************************
        // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time
        // If we've got less than that, blast them out all at once.
        //**********************************************************************

        while (ByteCount >= 1024 * sizeof(ULONG))

            {

            //******************************************************************
            // Check if we've got enough room in the push buffer
            //******************************************************************
 
            NV_DMAPUSH_CHECKFREE(((ULONG)(1025)));  


            NV_DMAPUSH_START(1024, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //******************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //******************************************************************
        
            for (i=0 ; i< 1024; i++)
                NV_DMA_FIFO = ScanPtr[i];    

            ByteCount -= (1024 * sizeof(ULONG));
            ScanPtr += 1024;

            }


        //******************************************************************
        // Check if we've got enough room in the push buffer
        //******************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(ByteCount>>2) + 3));  

        //**********************************************************************
        // Handle remaining dwords
        //**********************************************************************

        if (ByteCount >= 4)
            {
            //******************************************************************
            // Blast out remaining data
            //******************************************************************

            NV_DMAPUSH_START((ByteCount>>2), IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //******************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //******************************************************************
    
            for (i=0;i<(ByteCount>>2);i++)
                NV_DMA_FIFO = ScanPtr[i];    
    
            ScanPtr += (ByteCount>>2);
            ByteCount -= ((ByteCount>>2) * sizeof(ULONG));
            }

        //
        // Pad src scanline.
        //
        if (ByteCount)
            {
            TempPixelData1 = 0;
            for (i = 0; i < ByteCount; i++)
                {
                TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0), TempPixelData1);
            }


        NextScan+=ScanInc;
        
        //******************************************************************
        // Kickoff buffer after each scanline
        //******************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
        UPDATE_LOCAL_DMA_COUNT;


        }

#endif  // ifdef else _X86_

    //**************************************************************************
    // Notify the rest of the driver that we changed the pattern
    //**************************************************************************

    ppdev->NVPatternResetFlag=1;

    }

//******************************************************************************
//
//  Function:   NV4ScreenTo1bppMemBlit
//
//  Routine Description:
//
//      Does a memory-to-screen blt
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

//*****************************Public*Table*************************************
// BYTE gajLeftMask[] and BYTE gajRightMask[]
//
// Edge tables for vXferScreenTo1bpp.
//******************************************************************************

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

BOOL NV4ScreenTo1bppMemBlt(
PDEV*   ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
SURFOBJ* psoSrc,
SURFOBJ* psoDst,
POINTL* pptlSrc,
RECTL*  prclDst,
XLATEOBJ*   pxlo)               // Provides colour-compressions information

    {
    DSURF*  pdsurfSrc;
    ULONG   width,height;
    ULONG*  pulXlate;
    SURFOBJ soTmp;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    VOID*   pfnCompute;
    BYTE*   pjDst;
    LONG    cjPelSize;
    LONG    cyToGo;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    ULONG   numbytes;
    RECTL*  ptmp_rcl;
    LONG    tmp_c;
    BOOL    status;
    BYTE*   jSrcPtr;
    USHORT* sSrcPtr;
    ULONG*  lSrcPtr;

    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(MEM_TO_MEM_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cjPelSize),
                "Temp buffer has to be larger than widest possible scan");

    //**************************************************************************
    // Assume call succeeded
    //**************************************************************************

    status = TRUE;
    
    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*)psoSrc->dhsurf;

    //**************************************************************************
    // Get a ptr to the clip list and the count of clip rectangles
    //**************************************************************************

    ptmp_rcl = prcl;
    tmp_c    = c;

    //**********************************************************************
    // Destination pel size is either 1,2 or 4
    //**********************************************************************

    cjPelSize = ppdev->cjPelSize;

    
    //**************************************************************************
    // Check that the temporary buffer is large enough
    //**************************************************************************

    do  {

        //**********************************************************************
        // Get height, and the number of bytes required to hold the bitmap
        //
        // Number of bytes in bitmap is  width * height * bytesPerPixel.
        //**********************************************************************

        height = ptmp_rcl->bottom - ptmp_rcl->top;
        width = (((ptmp_rcl->right + 7L) & ~7L) - (ptmp_rcl->left & ~7L));

        numbytes = width * height * cjPelSize;
        
        //**********************************************************************
        // Check if our temporary buffer was large enough.
        // If not, then punt the call back to GDI.
        //**********************************************************************

        if (numbytes >= ppdev->MemToMemBufferSize)
            return(FALSE);            

        ptmp_rcl++;
        tmp_c--;
        } while (tmp_c != 0);
    

    //**************************************************************************
    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.
    //**************************************************************************

    if (ppdev->iBitmapFormat == BMF_8BPP)

        {

        //**********************************************************************
        // When the source is 8bpp or less, we find the foreground colour
        // by searching the translate table for the only '1':
        //**********************************************************************

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        //**********************************************************************
        // Get color index (from 0 to 255)
        //**********************************************************************

        ulForeColor = (ULONG)(pulXlate - pxlo->pulXlate);

        }

    else

        {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        //**********************************************************************
        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':
        //**********************************************************************

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
        }


    //**************************************************************************
    // We use the temporary buffer to keep a copy of the source
    // rectangle:
    //**************************************************************************

    soTmp.pvScan0 = ppdev->pMemToMemBuffer;

    do  {
        
        //**********************************************************************
        //
        //          1) pptlSrc->x    ( value x1 shown below )
        //
        //          2) prclDst->x    ( value x2 shown below )
        //
        //                  Location of the original unclipped destination rectangle
        //
        //          3) prcl->x       ( value x3 shown below)
        //
        //                  Current clip rectangle with coordinates relative to prclDst
        //
        //
        //   Origin  (Dst bitmap 1bpp)
        //  +--------------------------------------------------------------->
        //  |
        //  |
        //  |           x2 = prclDst->left
        //  |           +-----------------------------------------------
        //  |           |                             ^                 |-Original
        //  |           |                             | dySrc           |  Unclipped
        //  |           |                             |                 |   Destination
        //  |           |         x3 = prcl->left     v                 |    Rectangle
        //  |           |         +------------       -                 |
        //  |           |         |            |                        |
        //  |           |<-dxSrc->|            |                        |
        //  |           |         |            |                        |
        //  |           |         |            |-Current                |
        //  |           |         |            |  Clip                  |
        //  |           |          ------------    Rectangle            |
        //  |           |                                               |
        //  |           |                                               |
        //  |           |                                               |
        //  |            -----------------------------------------------
        //  |
        //  v
        //
        //
        //            Source Bitmap Color
        //          +--------+--|-----+--------+------->
        //          |           x1
        //          |
        //          |
        //          |
        //          |           ^
        //          v           |
        //                      |
        //                      |
        //          |-- x1 ---->|   x1 = pptlSrc->x
        //
        //**********************************************************************

        //**********************************************************************
        // ptlSrc points to the upper-left corner of the src screen rectangle
        //**********************************************************************

        ptlSrc.x = pptlSrc->x +  prcl->left - prclDst->left;
        ptlSrc.y = pptlSrc->y +  prcl->top  - prclDst->top;

        //**********************************************************************
        // Determine ptr for Destination 1bpp bitmap (we are actually determining
        // a byte address but the x position actually correponds to a bit address)
        //**********************************************************************

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        //**********************************************************************
        // Here, we determine the number of bytes required per each SRC scanline
        // that we will read into the temporary buffer (from the source screen bitmap)
        // (Right pel is exclusive)
        //
        // Left Pel Address         Right Pel address        
        // ----------------         -----------------        
        // 0->7    maps to 0         0     maps to 0         
        // 8->15   maps to 8         1->8  maps to 8         
        // 16->24  maps to 16        9->16 maps to 16        
        //
        // The following calculation should give us the amount
        // of bytes needed to hold a scanline of pixels, while also being a multiple
        // of 8 pixels.
        //**********************************************************************

        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L))
                       * cjPelSize;

        //**********************************************************************
        // cyToGo is the total number of scans we have to do for this rectangle.
        //**********************************************************************

        cyToGo     = prcl->bottom - prcl->top;

        //**********************************************************************
        // rclTmp is the temporary buffer destination rectangle
        // Initialize variables that don't change within the loop:
        // (rclTmp is passed to vGetBits)
        // Left destination coordinate is byte aligned
        //**********************************************************************

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;    
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;
        rclTmp.bottom = cyToGo;

        //**********************************************************************
        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).
        //
        // That is, the gajRightMask table data has been adjusted to account for
        // rclTmp.right being right-exclusive.  If rcl.right == 8, then
        // we would only access byte 0 , and not byte 1.  Therefore, the right
        // mask = 0xff for rcl.right = 8.
        //**********************************************************************

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];

        //**********************************************************************
        // Since the destination is mono, we need to calculate the number of bytes
        // that will hold the corresponding monochrome bits (shift right by 3)
        //
        // |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|  pixel position
        //     |             | |
        //     |             | v
        //     |             |  right
        //     |             |     
        //     v             v
        //  (rclTmp.left)  (rclTmp.right - 1)   This is exclusive 
        //
        //
        //
        // 
        // Shift by 3 (divide by 8) to determine the which byte contains the position        
        // This will give us a 'left byte' address and a 'right' byte address
        //
        //       Left Byte  = (rclTmp.left)      >> 3
        //       Right Byte = (rclTmp.right - 1) >> 3
        //
        //
        //
        // This then leaves us with 3 cases:
        //
        //
        // - Case 1:  Left Byte and Right Byte are the same byte
        // 
        //   |        |        |        |        |        |
        //   | byte 0 | byte 1 | byte 2 | byte 3 | byte 4 | etc....
        //   |        |        |        |        |        |
        //      ^  ^
        //      |  |                    no 'middle' bytes
        //      L  R
        //
        //
        // - Case 2:  Left Byte and Right Byte are next to each other
        // 
        //   |        |        |        |        |        |
        //   | byte 0 | byte 1 | byte 2 | byte 3 | byte 4 | etc....
        //   |        |        |        |        |        |
        //         
        //      ^       ^
        //      |       |               no 'middle' bytes
        //      L       R
        //
        //
        // - Case 3:  Left Byte and Right Byte are more than 1 byte away
        //            from each other
        // 
        //   |        |        |        |        |        |
        //   | byte 0 | byte 1 | byte 2 | byte 3 | byte 4 | etc....
        //   |        |        |        |        |        |
        //         
        //      ^                 ^
        //      |                 |      some 'middle' bytes
        //      L                 R
        // 
        //**********************************************************************

        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        //**********************************************************************
        // We are left with the following cases:
        //
        //   right - left   = 0     No middle byte
        //   right - left   = 1     No middle byte, just left and right bytes
        //   right - left   > 1     Middle byte present
        //
        // This can be simplified by subtracting 1 as follows:
        //
        //   right - left - 1  = negative     No middle byte, blt starts and ends in same byte
        //   right - left - 1  = 0            No middle byte, just left and right bytes
        //   right - left - 1  > 0            Middle byte present
        //
        //**********************************************************************

        if (cjMiddle < 0)
            {
            //******************************************************************
            // The blt starts and ends in the same byte:
            //******************************************************************

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
            }

        //**********************************************************************
        // Calculate the 'NOT' masks ahead of time
        //**********************************************************************

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;

        //**********************************************************************
        // Mono destination bitmap delta:
        // Delta from the END of one scan to the START on the next scan,
        // accounting for 'left' and 'right' bytes 
        //**********************************************************************

        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                
        //**********************************************************************
        // Color source bitmap delta: (temporary buffer)
        // Compute source delta for special cases like when cjMiddle gets bumped
        // up to '0', and to correct aligned cases
        // (Delta from the END of one scan to the START on the next scan)
        //**********************************************************************

        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) * cjPelSize);

        //**********************************************************************
        // Copy a rectangle of data from SCREEN and read it to the temporary buffer
        // Specify SRC PDSURF,  Dst surfobj (temporary buffer),  dest rectangle,
        // src x and y (pptlsrc)
        //**********************************************************************

        (ppdev->pfnGetScreenBits)(ppdev, pdsurfSrc, &soTmp, &rclTmp, &ptlSrc);
                                
        //**********************************************************************
        // Convert the color bitmap to mono bitmap scanline by scanline
        //**********************************************************************

#ifndef _WIN64
        do  {

           _asm {
                mov     eax,ulForeColor     ; eax = foreground colour
                                            ; ebx = temporary storage
                                            ; ecx = count of middle dst bytes
                                            ; dl  = destination byte accumulator
                                            ; dh  = temporary storage
                mov     esi,soTmp.pvScan0   ; esi = source pointer (from temp buffer)
                mov     edi,pjDst           ; edi = destination pointer

                ;***************************************************************
                ; Figure out the appropriate compute routine:
                ;***************************************************************

                mov     ebx,cjPelSize       ; 1,2 or 4
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

                ;***************************************************************
                ; Convert any 'left' bytes present
                ;***************************************************************

            Do_Left_Byte:
                call    pfnCompute          ; DL = 8 bits of monochrome data
                and     dl,jLeftMask        ; Mask off unnecessary bits
                mov     dh,jNotLeftMask     ; Get mask for destination data
                and     dh,[edi]            ; Get bits from dest that we won't touch
                or      dh,dl               ; Get resultant 8 bits of mono data
                mov     [edi],dh            ; Update the destination bitmap
                inc     edi                 ; Advance dst ptr by a byte
                mov     ecx,cjMiddle        ; Check for middle bytes
                dec     ecx                 ; We can skip it if there are none
                jl      short Do_Right_Byte ; Skip middle bytes code

            Do_Middle_Bytes:
                call    pfnCompute          ; DL = 8 bits of monochrome data
                mov     [edi],dl            ; Store the data directly into dst
                inc     edi                 ; Advance dst ptr by a byte
                dec     ecx                 ; Check for remaining middle bytes
                jge     short Do_Middle_Bytes ; Continue processing bitmap

            Do_Right_Byte:
                call    pfnCompute          ; DL = 8 bits of monochrome data
                and     dl,jRightMask       ; Mask off unnecessary bits
                mov     dh,jNotRightMask    ; Get mask for destination data
                and     dh,[edi]            ; Get bits from dest that we won't touch  
                or      dh,dl               ; Get resultant 8 bits of mono data
                mov     [edi],dh            ; Update the destination bitmap
                inc     edi                 ; Advance the dst ptr by a byte

                add     edi,lDstDelta       ; Advance dst bitmap ptr by a scanline
                add     esi,lSrcDelta       ; Advance src (tmp buffer) ptr by a scanline
                dec     cyToGo              ; Continue converting next scanline              
                jnz     short Do_Left_Byte  ; Check if we're done

                jmp     All_Done            ; We're done

                ;***************************************************************
                ; Convert 8bpp color bitmap to 1bpp monochrome
                ;***************************************************************

            Compute_Destination_Byte_From_8bpp:

                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 7

                add     esi,8               ; Advance the source
                ret

                ;***************************************************************
                ; Convert 16bpp color bitmap to 1bpp monochrome
                ;***************************************************************

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 7

                add     esi,16              ; Advance the source
                ret

                ;***************************************************************
                ; Convert 32bpp color bitmap to 1bpp monochrome
                ;***************************************************************

            Compute_Destination_Byte_From_32bpp:

                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 7

                add     esi,32              ; Advance the source
                ret

All_Done:
                }   

            } while (cyToGo > 0);

#else // _WIN64

#define CONVERT_TO_MONO(Src, Dst)                                         \
    {                                                                     \
    BYTE jVal = 0;                                                        \
    BYTE *DstPtr = Dst;                                                   \
    LONG i, j;                                                            \
                                                                          \
    do  {                                                                 \
        for (i = 0; i < 8; i++)                                           \
            jVal = (jVal << 1) + (*(Src)++ == ulForeColor);               \
        *DstPtr++ = (jVal & jLeftMask) | (*DstPtr & jNotLeftMask);        \
        for (j = 0; j < cjMiddle; j++)  {                                 \
            for (i = 0; i < 8; i++)                                       \
                jVal = (jVal << 1) + (*(Src)++ == ulForeColor);           \
            *DstPtr++ = jVal;                                             \
            }                                                             \
        for (i = 0; i < 8; i++)                                           \
            jVal = (jVal << 1) + (*(Src)++ == ulForeColor);               \
        *DstPtr++ = (jVal & jRightMask) | (*DstPtr & jNotRightMask);      \
        (BYTE *)(Src) += lSrcDelta;                                       \
        DstPtr += lDstDelta;                                              \
        } while (--cyToGo > 0);                                           \
    }

        switch (cjPelSize)
            {
            case 1:
               jSrcPtr = (BYTE *)soTmp.pvScan0;
               CONVERT_TO_MONO(jSrcPtr, pjDst);
               break;
            case 2:
               sSrcPtr = (USHORT *)soTmp.pvScan0;
               CONVERT_TO_MONO(sSrcPtr, pjDst);
               break;
            case 4:
               lSrcPtr = (ULONG *)soTmp.pvScan0;
               CONVERT_TO_MONO(lSrcPtr, pjDst);
               break;
            }

#endif // _WIN64

        prcl++;
        } while (--c != 0);


    return(status);

    }
    


    
//******************************************************************************
//
//  Function:   NV4ScreenToMemBlt
//
//  Routine Description:
//
//      Does a screen-to-memory blt (called when bitmap formats from src to 
//      dest are the same; THERE IS NO COLOR TRANSLATION GOING ON.)
//
//      Ask a DMA transfer to the hardware;
//      The Xfer is from VRAM to the locked MEM2MEM buffer in 
//      PDEV. Then, it transfers the content of the buffer to the actual dest. surface
//      (with normal, cpu transfer).
//      (The SRC bitmap must be in VRAM.)
//
//      Since there is no translation going on, if we could lock the dest. surface
//      and *quickly* create a dma context on-the-fly out of this surface, we 
//      could avoid using a intermediate buffer.  But DMA context allocation is
//      slow so...   
//
//      ***IMPORTANT*** Read comments about assumptions this function makes
//
//
//  Arguments:
//
//      (see header)
//
//  Return Value:
//
//      BOOL :  TRUE if call succeeded, else, FALSE.
//
//  Comments:
//
//      At the time of it's writing, this function makes these asumptions:
//
//          - A surface that has it's bitmap in VRAM can be a GDI managed DIB
//            (no DSURF associated, psoSrc->dhsurf == NULL )
//            if and only if it is the primary surface (what most
//            comments in the whole display driver code call the "SCREEN"), that
//            is, the surface which has PDEV.pjScreen as it's associated bitmap.
//          - Otherwise the surface is device managed and has a DSURF struct
//            associated with it
//          - We use PDEV.cjPelSize to know the number of bytes per pixel
//            EVEN when dealing with a src surface that is NOT the primary
//            one (the one which is actually associated with the PDEV).  So,
//            how come can we say that cjPelSize FROM PDEV is really the format
//            of our src bitmap ?  Because right now, the display memory must
//            contain only bitmaps of the same format.
//
//      (this is the way the whole NV display driver is done at this time)
//  
//          - Like ScreenTo1Bpp, this function assumes that the array of rectangles
//            that constrain (clip) the DST rectangle are already INSIDE this 
//            dst rectangle (so, already clipped by it).
//
//          - Like DMAGetScreenBits, this function makes assumption about the 
//            the value of the static data of the MEM_TO_MEM nv object.
//            It assumes that the SetContextDmaBufferIn() has been set to
//            the VRAM dma context, and that SetContextDmaBufferOut() has
//            been set to the mem2mem DMA buffer
//
//      Instead of using a temp SURFOBJ and passing the call to GetScreenBits
//      like in ScreenTo1Bpp, I have coded a different algo here, where I 
//      directly initiate
//      the transfer. That way, we don't have to use a temp SURFOBJ, and
//      we have more control over the DMA transfer. That is, we 
//      initiate transfer for a certain number of bytes (or pixels) and 
//      wait for a notifier event. When this first part of the transfer is 
//      finished, we initiate the next transfer and start copying from 
//      the mem2mem locked buffer to the final dest surface. This enable
//      parallel tranfer from/to the intermediate mem2mem buffer and almost
//      eleminate the overhead of this inter. buffer.  In fact, only the first
//      fill of this buffer would be overhead in the ideal case. But to really
//      be optimal we would have to determine HOW MANY pixels/bytes
//      to copy at each tranfer ? ( I've done a math model for this xfer case
//      that I tried to optimize after that.  From this, I did the whole 
//      calibration, and optbytesperxfer calcultion algorythm.  This is the 
//      only thing in this function that is not too well documented)
//
//        - Stephane
//
//
//******************************************************************************
                                         

#define  CALIBRATION_ENABLED        // Enable calibration

    
#ifdef  CALIBRATION_ENABLED
    
//****************************************
//    For fast MSBit position localization
//****************************************

BYTE Byte2_MSBitPos_LUT[256] = {

    0,  0,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  
    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
};
    

//*****************************************
//    For fast int squareroot approximation
//*****************************************

ULONG BitPos2SquRtAprox_LUT[32] = {

           1,           2,           2,           3,           5,           7,
          10,          14,          20,          28,          39,          55,
          78,         111,         157,         222,         314,         443,
         627,         887,        1254,        1774,        2508,        3547,
        5017,        7094,       10033,       14189,       20066,       28378,
       40132,       56756

};

#endif



BOOL NV4ScreenToMemBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;                // Total number of lines left to Xfer

    ULONG           bytes2Xfer;               // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;             // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;          // Optimal bytes per Xfer (calculated based on mathematic model 
                                              // and profiling data, see notes)
    ULONG           linesPerXfer;             // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;         // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;         // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;                // Pitch of the source surface
    
    LONG            lDstPitch;                // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;                // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;             // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;          // Pointer to the beg. of the dest. bits (in the final surface)
                                              // (will also be incremented to advance in the destination bits during xfer)
    
    BYTE*           pjDmaRead;                // Pointer in the mem2mem dma buffer that we are going to use in the
                                              // CPU-Xfers to keep track of where we are currently reading 
    
    
    BYTE*           pjDmaRead_lastXfer;       // Var to hold where to read the last CPU-Xfer

    BYTE*           pjDmaRead_start;          // Start of the Mem2Mem buffer

    BYTE*           pjDmaRead_2ndPart;        // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;             // Left top corner of current clipped region/rectangle in Src surface
                                              // to xfer
    
    ULONG           DstDMAOffset;             // Offset (relative to DMA base)
                                              // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;             // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset;      // Offset of the 2nd part of the Mem2Mem buffer
       
    NvNotification* pNotifier;                // Pointer to MemToMem notifier array

    DECLARE_DMA_FIFO;                         // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
                                          
    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));

    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
                
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMemBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMemBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMemBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMemBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMemBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMemBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMemBlt: NULL destination rectangle supplied !" );

    ASSERTDD( psoDst->iBitmapFormat == ppdev->iBitmapFormat,
              "NV4ScreenToMemBlt: Src and Dst bitmap formats must be the same" ); // ok

    ASSERTDD( (pxlo==NULL) || (pxlo->flXlate & XO_TRIVIAL),
              "NV4ScreenToMemBlt: Non-trivial color Xlation asked"); // ok

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMemBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************


    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }

    //UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
    //NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer                      
    //
    // let it be there until the next xfer...
    //

    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pjDmaRead_start   = ppdev->pMemToMemBuffer;  
    pjDmaRead_2ndPart = (BYTE *)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1);
    
    
    //**************************************************************************
    //  Transfer all rectangles regions in the array
    //**************************************************************************
    
    for(i=0; i < c; i++) // For all rectangles
    {
        // Calculate the number of bytes it takes to hold this bitmap that
        // we want to transfer.

        height = parcl[i].bottom - parcl[i].top;        // parcl[i]
        width  = parcl[i].right - parcl[i].left;
               
        bytesPerLine = width * ppdev->cjPelSize;        // This value is reused later
        bytes2Xfer   = height * bytesPerLine;
        
        // ( We check if the Mem2Mem buffer is large enough later )


        //**********************************************************************
        //
        // Decide the number of lines to Xfer at a time. We must round to a #
        // of lines for each rectangle because MEM2MEM objects Xfer by count 
        // of lines, so we can't stop in the middle
        // of a line, and start a Xfer with the width of the first line to xfer
        // being different from the width of all of the lines following it.
        //
        //**********************************************************************

        // (Use optimal equation with profiling data)
        //
        // I have modified the Newton method using a lut so that 
        // I can have a nearly perfect INT result of the square root
        // with only 2 iterations.
        //
        // to calculate optBytesPerXfer = squareroot(bytes2Xfer*overhead_of_setup*average_speed_of_dma_xfer)
        //
        // We already have squareroot(overhead_of_setup*average_speed_of_dma_xfer) in the global
        // var "globalXferOverheadFactor"
        //

        //optBytesPerXfer = bytesPerLine;      // Force perscanline xfers for the moment (test)

        //optBytesPerXfer = bytes2Xfer;        // Force non-overlapping xfer (test)



        #ifdef  CALIBRATION_ENABLED

        // We are going to compute a fast squareroot (of a 32bit int)
        // (see notes for more detail -stephane)
        
        // - First, find the position of the MSBit in the 32 bits

        if ( (bytes2Xfer & 0xFFFF0000 ) != 0 ) 
        {
            // Search in the MSWord

            tempUlong = (bytes2Xfer & 0xFF000000);

            if ( tempUlong != 0 ) 
            {
                // the MSBit is in this MSByte, let the LUT do the rest of the job
                
                // ( bytes2Xfer >> 24 ) slide the MSByte in the LSByte position
                
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 24 ] + 24;
            }
            else // the  LSByte of the MSWord contains the bit we are looking for
            {
                // Our number is 0x00??????
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 16 ] + 16;
            }

        }
        else
        {
            // Search the LSWord
            
            tempUlong = (bytes2Xfer & 0x0000FF00);

            if ( tempUlong != 0 ) 
            {
                // the MSBit is in this MSByte of the LSWord let the LUT do the rest of the job

                // ( bytes2Xfer >> 8 ) slide the MSByte in the LSByte position

                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 8 ] + 8;
            }
            else // the  LSByte of the LSWord contains the bit we are looking for
            {
                // Our number is 0x000000??
                
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer ];
            }
        
        } // ... else the MSBit is in the LSWord of our 32 bit "bytes2Xfer" number

        //
        // We now have msbitPos, plug it into the other LUT to get a very good
        // initial approximation of the squareroot of bytes2Xfer.
        //

        tempUlong = BitPos2SquRtAprox_LUT[ msbitPos ];
        
        // Do Newton 2 times 
        // We could actually use only 1 iteration and it would be enough for our
        // needs.

        tempUlong = (tempUlong + bytes2Xfer/tempUlong) >> 1 ;
        tempUlong = (tempUlong + bytes2Xfer/tempUlong) >> 1 ;
        
        // We now have our squareroot(bytes2Xfer), all we need is to mul it
        // by our profiled constant

        optBytesPerXfer = tempUlong * ppdev->globalXferOverheadFactor;
                                

        #else  // else if NOT #ifdef  CALIBRATION_ENABLED
        
        optBytesPerXfer = bytesPerLine << 3;   //Force per-8-scanline xfers
        
        //optBytesPerXfer = bytes2Xfer;        // Force non-overlapping xfer (test)

        #endif // ...#ifdef  CALIBRATION_ENABLED        
        

        //**********************************************************************
        // We have our optBytesPerXfer, now convert it in linesPerXfer
        //**********************************************************************

        // But first check if the Mem2Mem buffer is large enough to hold 2 chunks
        // of this size

        // NOTE:
        //
        // ( We try to reduce the Xfer size to 1 scanline (the minimum);
        //   we could try reducing it by half and recheck, but it's not
        //   really worth it, if mem2mem buffer is too small, we are
        //   already in a case that will be handled more slowly )
        
        
        // Check if we are not in the special case where it is more
        // efficient to do the xfer without overlapping ( in that case,
        // we need "bytes2Xfer" bytes in the mem2mem buffer)
        // (Clamp optBytesPerXfer to bytes2Xfer in that case)

        if( optBytesPerXfer > bytes2Xfer )                  
        {
            optBytesPerXfer = bytes2Xfer;  // clamp the size of the chunk
                                           // to total bytes to xfer

            if( optBytesPerXfer > ppdev->MemToMemBufferSize )
            {
                // We must do one xfer, but mem2membuffer is too small.
                // Reduce it to the minimum
    
                optBytesPerXfer = bytesPerLine;
    
                if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                
                    return(FALSE);  // we can't even store 2 scanlines!
            }
        
        } // ...if optxfersize > total2xfer
        
        //  Else, check if we need to clamp to at least 1 scanline
        // (indeed, if optBytesPerXfer calculated is
        //  lower than a scanline, we are going to use
        //  a scanline-based transfer anyway, so we
        //  must check the size of mem2mem buffer VS 
        //  at least a scanline )
        
        else if( optBytesPerXfer < bytesPerLine )
        {                
            optBytesPerXfer = bytesPerLine;
            
            if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                
                return(FALSE);  // we can't even store 2 scanlines!
        }            

        // Else optBytesPerXfer is within boundaries, check if we can
        // store two chunks of that size

        else if( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )
        {
            // Mem2Mem buffer size is too small for the size of 2 Xfer chunks.
            // Try to reduce the xfer chunk to the minimum
        
            optBytesPerXfer = bytesPerLine;
        
            if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                
                return(FALSE);  // we can't even store 2 scanlines!
        }


        // There are many ways to round: clamp to unit by truncating, or clamp to
        // higher unit as soon as there is a rest, etc.  Simplest is truncating
        //
        
        linesPerXfer = ( optBytesPerXfer / bytesPerLine );

       
        // Clamp to higher unit instead of truncate with ( bytesPerXfer / bytesPerLine );
        //
        // Let's limit bytersPerXfer to 33 MB, so we have 7 bits (MSBits) out of
        // 32 to use to do fixed point math. ( 32-7 = 25, 2^25 = 33 MB )
        //
        // [ (bytesPerXfer << 7 ) / ( bytesPerLine << 7 )  + 0x7F (which is 1111111b) ]  >> 7        
                

        

        //**********************************************************************
        //  An object of NV_MEM_TO_MEM class must be attached to 2 DMA contexts.
        //  The src and dst must be given through method writes, and these src
        //  and dst ptr must be in offset RELATIVE to the address of the BASE
        //  (so relative to the beginning) of the DMA region.
        //
        //  So, we are going to:
        //
        //      - First, find the coordinates of the current clip rectangle
        //        in the SRC RECTL. (see below)
        //      - Find the offset in byte of these coordinates, relative to the
        //        beginning of the source bits, and find the absolute address 
        //        of these coordinates by adding the base of the source bits.        
        //      - Substract the base of the DMA region from this ptr to obtain
        //        an offset relative to the base.
        //
        //**********************************************************************

        
        //**********************************************************************
        //      - First, find the coordinates of the current clip rectangle
        //        in the SRC RECTL. (see below)
        //**********************************************************************

        
        //**********************************************************************
        //
        //          1) pptlSrc->x    ( value x1 shown below )
        //
        //          2) prclDst->x    ( value x2 shown below )
        //
        //                  Location of the original unclipped destination rectangle
        //
        //          3) parcl[i]       ( value x3 shown below)
        //
        //                  Current clip rectangle with coordinates relative to origin
        //                                                                  of Dst
        //
        //   Origin  (Destination bitmap )
        //  +--------------------------------------------------------------->
        //  |
        //  |
        //  |           x2 = prclDst->left
        //  |           +-----------------------------------------------
        //  |           |                              ^                |-Original
        //  |           |                              | dySrc          |  Unclipped
        //  |           |                              |                |   Destination
        //  |           |         x3 = parcl[i].left   v                |    Rectangle
        //  |           |         +------------        -                |
        //  |           |         |            |                        |
        //  |           |<-dxSrc->|            |                        |
        //  |           |         |            |                        |
        //  |           |         |            |-Current                |
        //  |           |         |            |  Clip                  |
        //  |           |          ------------    Rectangle            |
        //  |           |                                               |
        //  |           |                                               |
        //  |           |                                               |
        //  |            -----------------------------------------------
        //  |
        //  v
        //
        //
        //           Origin (Source bitmap)
        //          +--------+--|-----+--------+------->
        //          |           x1
        //          |
        //          |
        //          |
        //          |           ^
        //          v           |
        //          |           |
        //          |           |
        //          |-- x1 ---->|   x1 = pptlSrc->x
        //          |           +-----------------------------------------------
        //          |           |                             ^                 |-Source
        //          |           |                             | dySrc           | Rectangle 
        //          |           |                             |                 |   
        //          |           |         x? = x1 + dxSrc     v                 |    
        //          |           |         +------------       -                 |
        //          |           |         |            |                        |
        //          |           |<-dxSrc->|            |                        |
        //          |           |         |            |                        |
        //          |           |         |            |-Current                |
        //          |           |         |            |  Clip                  |
        //          |           |          ------------    Rectangle            |
        //          |           |                        ( but in SRC surface)  |
        //          |           |                                               |
        //          |           |                                               |
        //          |            -----------------------------------------------
        //
        //**********************************************************************


        ptlSrcRegion.x  = pptlSrc->x + (parcl[i].left - prclDst->left);
        ptlSrcRegion.y  = pptlSrc->y + (parcl[i].top  - prclDst->top);

        //**************************************************************************
        //      - Find the offset in byte of these coordinates, relative to the
        //        beginning of the source bits, and find the absolute address 
        //        of these coordinates by adding the base of the source bits.        
        //
        // (Calculate the pointer to the upper-left corner of Source clipped region)
        //**************************************************************************
        
        pjSrcRclBits    =     pjSrcBits                             // base of Src Bits
                              + ( ptlSrcRegion.y  * lSrcPitch ) 
                              + ptlSrcRegion.x * ppdev->cjPelSize ;   
                                // CONVERT_TO_BYTES(x,pdev) == (x) * pdev->cjPelSize        

        
        // We don't have to calculate the dst address for the DMA transfer: 
        // we have it, it is the dst
        // of the mem2mem DMA buffer, but we have to calculate the address in
        // the final destination surface, for the cpu transfer

        //**************************************************************************
        // Calculate the pointer to the upper-left corner of Destination clipped region
        // (THE FINAL DESTINATION, not the MEM2MEM buffer)
        //**************************************************************************

        pjFinalDstWrite =  (BYTE*) psoDst->pvScan0 
                          + ( parcl[i].top  * lDstPitch )
                          + ( parcl[i].left * ppdev->cjPelSize );
                            
                            // Remember, we don't do any format conversion, and the
                            // src is in screen mem, and the format descriptor of
                            // the src mem is the pdev. That's why we can use
                            // pdev->cjPelSize to
                            // calculate an "x" offset from pixel to bytes.
        
        //**************************************************************************
        //
        //  Now, we need to setup the first Xfer, wait for it to end, and enter
        //  the main Xfer loop, were we kick a Xfer for the next chunk, and Xfer
        //  the last chunk from mem2mem buffer to final sys mem destination.
        //  Finally, we are going to Xfer the remaining data 
        //  ( total_lines_to_xfer % optimal_lines_by_xfer )
        //  
        //**************************************************************************


        //**************************************************************************
        // Calculate the offsets of the transfer src and dst from the beginning of 
        // their respective DMA region base
        //**************************************************************************

        DstDMAOffset = 0;         // Init the current DMAoffset where to write
        
        
                                  // Init current source DMAoffset where to read

        SrcDMAOffset = (ULONG)( pjSrcRclBits - ppdev->pjFrameBufbase ); 
                                  // We are assuming that base of VRAM DMA context
                                  // is == pjFrameBufbase, that is, that the DMAoffset of pjFrameBufbase
                                  // is always 0. That's why we use ppdev->pjFrameBufbase for
                                  // base of DMA region
        
        //**********************************************************************
        //
        // Precalculate the num of bytes to add to the SrcDmaOffset for each 
        // transfer and the address of the second chunk in the DstDMA 
        // (the mem2mem buffer) 
        //
        // ( We could use linesPerXfer * bytesPerLine,
        // and that would also be the number of bytes to add to the
        // DstDmaOffset if we would be user a mem2mem buffer the size of the
        // whole transfer. In other words, not using the strict minimum to be
        // able to do overlapping, that is 2 chunks in the buffer (one to which
        // DMA write, the other to which CPU read, and then, the opposite...)
        // 
        // Instead we use ppdev->MemToMemBufferSize/2, because that value never
        // changes (for any xfer size), so we can put that calculation out of
        // the rectangle loop. (for all rectangles)
        //
        //
        // Also init some variables before going on to the Xfers
        //
        // Reminder: the pitch include the linelenght (bytesperline)!
        //**********************************************************************
        
        
        //DstDMA2ndPartOffset   =  (ppdev->MemToMemBufferSize >> 1);  does not change
        SrcDMAincPerXfer      = linesPerXfer * lSrcPitch;

        
        // Calculate the jump to get to the next line of the 
        // final destination rectangle (in the final Dst surface)
        // AFTER having transfered "bytesPerLine" (in other words,
        // pitch is the num of bytes to the jump AT THE SAME POSITION
        // in the bitmap but one line lower; what we want is the jump
        // value to jump from the end of a line TO THE BEGINNING
        // of the next line )
        
        FinalDstJump2NextLineBeg = lDstPitch - bytesPerLine;

        
        //pjDmaRead_start        = ppdev->pMemToMemBuffer;  // These var will not change for different rectangles

        //pjDmaRead_2ndPart      = ppdev->pMemToMemBuffer + (ppdev->MemToMemBufferSize >> 1);

        
        pjDmaRead                = pjDmaRead_start;  // Init the reading ptr for the second
                                                     // transfer "pipe" (the CPU-Xfers)
        
        linesToGo                = height;           // Init the number of lines left to transfer


        
        
        //**********************************************************************
        //                      Setup the first transfer
        //
        //  NOTE: Somebody looking at this code (further below) might think:
        //        why doing this first xfer outside of the main xfer loop ? 
        //        "Everything looks the same inside the loop"  This is not
        //        exactly right: the loop is done so when it rolls we wait 
        //        for the last notifier being setup, just before resetting 
        //        this notifier and kicking off the new transfer. If we would
        //        remove that special-casing of the first xfer, we would be 
        //        waiting inside the start of the xfer loop forever because
        //        no xfer has been setup yet...
        //
        //
        //**********************************************************************

        //**********************************************************************
        // Set methods for memory_to_memory dma blit
        //   NV039_OFFSET_IN                                            
        //   NV039_OFFSET_OUT                                           
        //   NV039_PITCH_IN                                             
        //   NV039_PITCH_OUT                                            
        //   NV039_LINE_LENGTH_IN                                       
        //   NV039_LINE_COUNT                                           
        //   NV039_FORMAT                                               
        //   NV039_BUFFER_NOTIFY                                        
        //**********************************************************************

        //**************************************************************************
        // Check if we've got enough room in the push buffer
        //**************************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));

        //**************************************************************************
        // Set notifier to 'BUSY' value (use second notification structure)
        //**************************************************************************

        pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

        NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
        NV_DMA_FIFO = SrcDMAOffset;                             // Offset In
        NV_DMA_FIFO = DstDMAOffset;                             // Offset Out
        NV_DMA_FIFO = lSrcPitch;                                // Pitch In
        NV_DMA_FIFO = bytesPerLine;                               // Pitch Out == bytesPerLine because
                                                                  // we dont want any memory "hole" between
                                                                  // two contiguous lines in the mem2mem buffer

        NV_DMA_FIFO = bytesPerLine;                             // Line Length in bytes
        NV_DMA_FIFO = linesPerXfer;                             // Line Count (num to copy)
        NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | 
                      NV_MTMF_FORMAT_OUTPUT_INC_1;              // Format
        NV_DMA_FIFO = 0;                                        // Set Buffer Notify and kickoff

        //**************************************************************************
        // Update global push buffer count
        //**************************************************************************

        UPDATE_PDEV_DMA_COUNT;

        //**************************************************************************
        // Send data on thru to the DMA push buffer
        //**************************************************************************

        NV4_DmaPushSend(ppdev);

        //**************************************************************************
        // Here we incremented the offsets before the Xfer completes, so we can
        // cover a bit the processing (make these calculations during the time
        // the first Xfer execute)
        //**************************************************************************

        linesToGo       -= linesPerXfer;          // Susbtract the lines that have been done.
        SrcDMAOffset    += SrcDMAincPerXfer;      // Advance in the source DMA region
        DstDMAOffset     = DstDMA2ndPartOffset;   // Advance in the dest. DMA region
                                                  // (the mem2mem buffer) so we use the 
                                                  // 2nd part the next time.

        //
        // REMINDER: ANY CODE FOLLOWING THIS MUST CHECK THE NOTIFIER
        // IF IT WANTS TO BE SURE THAT THE MEM2MEM BUFFER DATA IS VALID
        //
        
        //***[ Make sure there are still enough lines to Xfer before starting  *****
        //*                                                  another DMA Xfer ]    *
        
        if ( linesToGo < linesPerXfer )  // if there are not "linesPerXfer" lines to Xfer
        {
            // Now what is left is a CPU Xfer of "linesPerXfer" plus at most
            // one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...
            //
            // We save the value to which we must set the position of pjDmaRead
            // for the very last CPU read ( of size height % linesPerXfer)
    
            pjDmaRead_lastXfer = pjDmaRead_2ndPart;
        

        } // ...if there are less than linesPerXfer left to Xfer
        
        else
        {
            //  else, enter the main Xfer loop.
        
            //**************************************************************************
            //                Main transfer loop with overlapping Xfers
            //
            //  Note that we are starting to setup the next DMA
            //  xfer even before checking if the last one is finished. We only do so
            //  at the last minute, before resetting the notifier, and kicking the next
            //  DMA Xfer for maximum overlapping of processing
            //
            //
            //**************************************************************************                        
        
            for(;;)   // (for all Xfers that can be done in linesPerXfer chunks):
                      // - this is a 2 part loop with 
                      //   2 breakout cases, so that's why we use a for(;;))
                      //   (2 cases because we are doing either one or the other part of
                      //   the mem2mem buffer)
            {
                //
                // START another DMA-Xfer:    remember, we use ( 2*bytesperxfer ) bytes
                //                            in our Mem2Mem buffer. (So we alternate
                //                            using it's two parts )
                //
                //                            We started Xfering to the first part
                //                            (before entering the loop, and at the end
                //                            of this for(;;) loop),
                //                            (the NV hw is writting to the first part)
                //                            so we are going to read from that first part
                //                            while we kick another Xfer in the second
                //                            part.
                //
                // (Note that the first time we enter this loop, we will wait without
                //  overlapping: this is normal, we need to wait for the **FIRST** xfer
                //  to be done, because in the other part of the 2part buffer, there
                //  isn't any data available yet for our CPU.)
                //          

                //---[ So now: ]-------------------------
                //                                      -
                // DstDMAOffset == DstDMA2ndPartOffset; -
                //    pjDMAread == pjDmaRead_start;     -
                //                                      -
                //---------------------------------------

                //
                // START another DMA-Xfer
                //
    
    
                NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  

                NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
                NV_DMA_FIFO = SrcDMAOffset;                             // Offset In
                NV_DMA_FIFO = DstDMAOffset;                             // Offset Out
                NV_DMA_FIFO = lSrcPitch;                                // Pitch In
                NV_DMA_FIFO = bytesPerLine;                               // Pitch Out == bytesPerLine because
                                                                          // we dont want any memory "hole" between
                                                                          // two contiguous lines in the mem2mem buffer

                NV_DMA_FIFO = bytesPerLine;                             // Line Length in bytes
                NV_DMA_FIFO = linesPerXfer;                             // Line Count (num to copy)
                NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | 
                              NV_MTMF_FORMAT_OUTPUT_INC_1;              // Format
                NV_DMA_FIFO = 0;                                        // Set Buffer Notify and kickoff
    
                //**************************************************************************
                // Wait for the last DMA-Xfer kicked to be completed (use second notification structure)
                // ( if it is not yet completed )
                //**************************************************************************
    
                while ( pNotifier->status != 0 );
    
    
                //**************************************************************************
                // Set notifier to 'BUSY' value (use second notification structure)
                //**************************************************************************
    
                pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
    
                UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
                NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer
    
    
                linesToGo    -= linesPerXfer;          // Susbtract the lines that have been done.
                SrcDMAOffset += SrcDMAincPerXfer;      // Advance in the source DMA region (VRAM)
                DstDMAOffset  = 0;                     // Go back to the first part of the mem2mem
                                                       // DMA buffer in the next DMA Xfer.
    
                //**************************************************************************
                //  In the meantime, CPU-Xfer what has been DMA-Xfered.
                //
                //  Note that here we have two chases that can go on: if DMA-Xfer is faster,
                //  the while(!notified) active-wait will always be true by the time we
                //  get here. We could, to be fancier, check after a certain number of bytes
                //  CPU-Xfered, if the notification has been trigered (using the profiling
                //  data, we can do it), but it's not really worth it. Indeed, if the DMA-Xfer
                //  is faster, and we launch more than 1 per CPU-Xfered-chunk, (let's say 1.2
                //  on average), at the end, all the DMA-Xfers will be over, yes, and the 
                //  hardware will be idle yes, but we will still have to finish here, in this
                //  function, with our CPU transfer, and THAT is going to be the limiting speed.
                //  (And since the driver is not re-entrant, the idle hardware won't be used
                //  anyway during this time)
                //  Repeat a similar reasoning for the other chase condition, that is,
                //  if the CPU-Xfers are faster than the DMA-Xfers.
                //**************************************************************************
    
                //
                // NOTE: The next loop can be optimized...
                //
    
                // Xfer all lines
                //
                for(j=0; j < linesPerXfer; j++)
                {            
                    // Xfer a whole line
                    //
                    for(limit = pjDmaRead + bytesPerLine; 
                        pjDmaRead < limit; 
                        pjDmaRead++, pjFinalDstWrite++ )
                    {
                        *pjFinalDstWrite = *pjDmaRead ;
                    }
    
                    pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                                 // next line in the dest surface
    
                } // ...for all bytes in chunk to cpu-xfer
    
                // Set our pjDmaRead ptr at the beginning of the second part of our mem2mem buffer
                // (For the next CPU-Xfer)

                pjDmaRead = pjDmaRead_2ndPart;

                //
                // ... CPU Xfer done.                    
                
                
                //***[ Make sure there are still lines to Xfer before starting         *****
                //*                                                  another DMA Xfer ]    *

                if ( linesToGo < linesPerXfer )  // if there are no more chunk to Xfer
                {
                    
                    // Now what is left is a CPU Xfer of "linesPerXfer" plus at most
                    // one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...
                    //
                    // We save the value to which we must set the position of pjDmaRead
                    // for the very last CPU read ( of size height % linesPerXfer)
    
                    pjDmaRead_lastXfer = pjDmaRead_start;
                    
                    break;          // break out of the Xfer loop (for(;;))
                }
                //*                                                                        *
                //**************************************************************************
                                    
                //
                // START another DMA-Xfer:    Remember, we use ( 2*bytesPerXfer ) bytes
                //                            in our Mem2Mem buffer. (So we alternate
                //                            using it's two parts )
                //
                //                            The last Xfer kicked used the 2nd part.
                //                            Next Xfer is going to use the first part
                //                            again.
        
                //---[ So now: ]-------------------------
                //                                      -
                // DstDMAOffset == 0;                   -
                //    pjDMAread == pjDmaRead_2ndPart;   -
                //                                      -
                //---------------------------------------

        
                NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  
        
                NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
                NV_DMA_FIFO = SrcDMAOffset;                         // Offset In
                NV_DMA_FIFO = DstDMAOffset;                         // Offset Out
                NV_DMA_FIFO = lSrcPitch;                            // Pitch In
                NV_DMA_FIFO = bytesPerLine;                         // Pitch Out == bytesPerLine because
                                                                      // we dont want any memory "hole" between
                                                                      // two contiguous lines in the mem2mem buffer
                NV_DMA_FIFO = bytesPerLine;                         // Line Length in bytes
                NV_DMA_FIFO = linesPerXfer;                         // Line Count (num to copy)
                NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | 
                              NV_MTMF_FORMAT_OUTPUT_INC_1;          // Format
                NV_DMA_FIFO = 0;                                    // Set Buffer Notify and kickoff
        
        
                //**************************************************************************
                // Wait for the last DMA-Xfer kicked to be completed (use second notification structure)
                // ( if it is not yet completed )
                //**************************************************************************
        
                while ( pNotifier->status != 0 );
        
        
                //**************************************************************************
                // Set notifier to 'BUSY' value (use second notification structure)
                //**************************************************************************
        
                pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        
                UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
                NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer
        
        
                linesToGo       -= linesPerXfer;          // Susbtract the lines that have been done.
                SrcDMAOffset    += SrcDMAincPerXfer;      // Advance in the source DMA region (VRAM)                    
                DstDMAOffset     = DstDMA2ndPartOffset;   // Advance in the dest. DMA region
                                                          // (the mem2mem buffer) so we use the 
                                                          // 2nd part the next time.
        
                //**************************************************************************
                //  In the meantime, CPU-Xfer what has been DMA-Xfered in the 2nd part
                //**************************************************************************
                
                // Xfer all lines
                //
                for(j=0; j < linesPerXfer; j++)
                {            
                    // Xfer a whole line
                    //
                    for(limit = pjDmaRead + bytesPerLine; 
                        pjDmaRead < limit; 
                        pjDmaRead++, pjFinalDstWrite++ )
                    {
                        *pjFinalDstWrite = *pjDmaRead ;
                    }
    
                    pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                                 // next line in the dest surface
    
                } // ...for all bytes in chunk to cpu-xfer
                
                // Set our pjDmaRead ptr at the beginning of the first part of our mem2mem buffer
                
                pjDmaRead = pjDmaRead_start;                 // Reset the read ptr at the 
                                                             // first part (beginning) of the
                                                             // MEM2MEM buffer
                // ... CPU Xfer Done.
                

                //***[ Make sure there are still lines to Xfer before starting         *****
                //*                                                  another DMA Xfer ]    *
                
                if ( linesToGo < linesPerXfer )  // if there are no more lines to Xfer
                {
                    
                    // Now what is left is a CPU Xfer of "linesPerXfer" plus at most
                    // one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...
                    //
                    // We save the value to which we must set the position of pjDmaRead
                    // for the very last CPU read ( of size height % linesPerXfer)
    
                    pjDmaRead_lastXfer = pjDmaRead_2ndPart;

                    break;          // break out of the Xfer loop (for(;;))

                } // ...if there are less than "linesPerXfer" left to Xfer
                
                //*                                                                        *
                //**************************************************************************

    
            } // ...for(;;)  ( while(linesToGo >= linesPerXfer )  )
              // 
              // (this is a special cased 2 part loop)

        
        } //  ...else enter the main Xfer loop (if there are at least linesPerXfer left to Xfer)

        //**************************************************************************
        //
        //                Last transfer: Time to execute the last transfer
        //
        //  There is at most one DMA transfer left to execute, and at most 2 mem2mem
        //  chunks to transfer (the last DMA that is about to be completed, and the 
        //  one that we are about to start, if there is one)
        //
        //**************************************************************************

        if ( linesToGo == 0 ) // only 1 CPU-Xfer left to execute
                              // (that means that totalLinesToXfer was a multiple
                              // of linesPerXfer, => total % linesPerXfer == 0
        {
            //**************************************************************************
            // Wait for the last DMA to be completed (use second notification structure)
            //**************************************************************************

            while ( pNotifier->status != 0 );

            // Xfer the last "linesPerXfer" lines
            //
            for(j=0; j < linesPerXfer; j++)
            {            
                // Xfer a whole line
                //
                for(limit = pjDmaRead + bytesPerLine; 
                    pjDmaRead < limit; 
                    pjDmaRead++, pjFinalDstWrite++ )
                {
                    *pjFinalDstWrite = *pjDmaRead ;
                }

                pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                             // next line in the dest surface

            } // ...for all bytes in chunk to cpu-xfer

            //****************************************
            // And this rectangle is done, at last...
            //****************************************

        } // ...if ( linesToGo == 0 )

        else // else, setup one last DMA Xfer
        {
            // This last DMA-Xfer is different in that the line count is
            // linesToGo (the rest of the lines, which is < than our linesPerXfer calculated )
            //

            NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  

            NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
            NV_DMA_FIFO = SrcDMAOffset;                    // Offset In
            NV_DMA_FIFO = DstDMAOffset;                    // Offset Out
            NV_DMA_FIFO = lSrcPitch;                       // Pitch In
            NV_DMA_FIFO = bytesPerLine;                      // Pitch Out == bytesPerLine because
                                                             // we dont want any memory "hole" between
                                                             // two contiguous lines in the mem2mem buffer
            NV_DMA_FIFO = bytesPerLine;                    // Line Length in bytes
            NV_DMA_FIFO = linesToGo;                       // Line Count (num to copy)
            NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
            NV_DMA_FIFO = 0;                               // Set Buffer Notify and kickoff

            //**************************************************************************
            // Wait for the last DMA-Xfer kicked to be completed (use second notification structure)
            // ( if it is not yet completed )
            //**************************************************************************

            while ( pNotifier->status != 0 );


            //**************************************************************************
            // Set notifier to 'BUSY' value (use second notification structure)
            //**************************************************************************

            pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

            UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
            NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer                      

            
            //**************************************************************************
            // Now that this last DMA-Xfer is running, transfer the last "linesPerXfer"
            // long chunk. (this is our last but one CPU-Xfer)
            //                
            // We might think of one complication here: we do not know where we broke in
            // our main for(;;) loop.  So we do not know to which part of the mem2mem 
            // buffer we must read our last cpu xfer. (In other words, where to put the 
            // pjDmaRead ptr. This is solved in the loop by saving the next value to which 
            // it must be set (this is to avoid doing an additionnal "IF" here, to know 
            // were we broke in the for(;;) )
            //
            //**************************************************************************

            // Xfer the "linesPerXfer" lines
            //
            for(j=0; j < linesPerXfer; j++)
            {            
                // Xfer a whole line
                //
                for(limit = pjDmaRead + bytesPerLine; 
                    pjDmaRead < limit; 
                    pjDmaRead++, pjFinalDstWrite++ )
                {
                    *pjFinalDstWrite = *pjDmaRead ;
                }

                pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                             // next line in the dest surface
            } // ...for all bytes in chunk to cpu-xfer

            // Set our pjDmaRead ptr at the beginning of the ? part of our mem2mem buffer
            // (the right part for our last cpu xfer; this was selected in the for(;;)

            pjDmaRead = pjDmaRead_lastXfer;

            
            //**************************************************************************
            // Wait for the LAST DMA-Xfer to be completed
            // ( if it is not yet completed ) and CPU-Xfer these remainder lines
            //**************************************************************************

            while ( pNotifier->status != 0 );


            for(j=0; j < linesToGo; j++)
            {            
                // Xfer a whole line
                //
                for(limit = pjDmaRead + bytesPerLine; 
                    pjDmaRead < limit; 
                    pjDmaRead++, pjFinalDstWrite++ )
                {
                    *pjFinalDstWrite = *pjDmaRead ;
                }

                pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                             // next line in the dest surface

            } // ...for all lines left

            //****************************************
            // And this rectangle is done, at last...
            //****************************************

        } // ...else ( linesToGo != 0 )  ( one last DMA xfer to setup )

    
    } // ...for(i=0; i < c; i++) // For all rectangles
    
    return TRUE;
}

// ...End of NV4ScreenToMem()
    


//******************************************************************************
//  ------------------------------------------------------------------
//            BEGIN NV4ScreenToMem*to*bppBlt FUNCTIONS
//  ------------------------------------------------------------------
//******************************************************************************

//******************************************************************************
//
//  NV4ScreenToMem*to*bppBlt functions and macro definitions for these
//  ------------------------------------------------------------------
//
//
//  NOTE: These macros are NOT meant to be used alone. These uses local variables
//        of NV4ScreenToMem*to*bppBlt functions, and the order in which they are
//        used is obviously important. ( For example, ScreenToMemXbpp_Common must
//        be executed before "height, width, ..." are usable; See ScreenToMem4bpp
//        for an example)
//
//  After the macros, these functions are defined:
//
//      NV4ScreenToMem32to4bppBlt
//      NV4ScreenToMem32to8bppBlt
//      NV4ScreenToMem16to4bppBlt
//      NV4ScreenToMem16to8bppBlt
//
//  These functions do a ScreenToMem Blt (like NV4ScreenToMemBlt) but with
//  color translation between non indexed (high/true color) to indexed color
//  formats (4bpp and 8bpp).  (It seems that this read from frame buffer happens
//  every time a window with very small icons pop, like the advance display applet
//  with the small NV logo, or when going to display properties and listing all
//  available patterns and bmp for the desktop (the icons there) )
//
//  The reason why these different functions are aliased instead of having one
//  NV4ScreenToMemWithXlate function is that we don't want to have a big "IF"
//  in the high level code (bitblt) and then, recheck again the same variables
//  but this time to isolate the cases of the "big IF". (This is similar to
//  the PushXfer??to?? functions...
//
//
//
//      ***IMPORTANT*** Read comments about assumptions these function makes
//                      (further below, after macro descriptions - these 
//                      are the same comments then in NV4ScreenToMemBlt)
//
//
//
//  ---------------------------------------------------------------------------          
//  Macro:                  [ GiveOptBytesPerXfer( optBytesPerXfer ) ]
//
//  Macro Description:      optBytesPerXfer will = optimal num. of bytes/xfer
//
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMemXbpp_Common ]
//
//  Macro Description:      Insert the code common to all core ScreenToMemXbpp
//                          functions in the beginning of the for(all rectangles)
//                          loop.
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMemXbpp_Common2 ]
//
//  Macro Description:      Insert the code common to all core ScreenToMemXbpp
//                          functions.  This contain the core of the transfer
//                          code. The 3th parameter is the name of the macro
//                          to use for all CPUXFER. This macro must accept 
//                          2 params, as described in CpuXferTo4bpp for example
//  ---------------------------------------------------------------------------          
//  Macro:                  [ PushSendDMAXfer_forXlines(linesPerXfer) ]
//
//  Macro Description:      Insert the code to push and send a DMA Xfer for
//                          "linesPerXfer" lines. (Does not update the variables
//                          it uses like "SrcDMAOffset", etc.)
//  ---------------------------------------------------------------------------          
//
//  Macro:                  [ PushWaitSendDMAXfer_forXlines(linesPerXfer) ]
//
//  Macro Description:      Insert the code to push, wait for the last DMA Xfer
//                          to end, reset the notifier and send a DMA Xfer for
//                          "linesPerXfer" lines. (Does not update the variables
//                          it uses like "SrcDMAOffset", etc.)
//  ---------------------------------------------------------------------------          
//
//  Macro:                  [ CpuXferTo4bpp(pxxDmaRead,linesPerXfer) ]
//                          
//  Macro Description:      Core of a CPU Xfer to convert a part of the MemToMem
//                          DMA buffer to 4bpp and write it in the final surface;
//                          This macro is used when we have at least 2 bytes per
//                          scanline (the case when there is a width of 1 or 2       
//                          pixels inside THE SAME byte must be special cased)
//                          
//                          pxxDmaRead is ULONG* if the source is 32bpp, USHORT*
//                          if the source is 16bpp, etc.
//
//                          (Source must be converted from non-indexed,
//                          to indexed)
//
//  ---------------------------------------------------------------------------          
//  Macro:                  [ CpuXferTo4bpp_1ByteWidth(pxxDmaRead,linesPerXfer) ]
//                          
//  Macro Description:      See CpuXferTo4bpp...
//                          
//  ---------------------------------------------------------------------------          
//  Macro:                  [ CpuXferTo8bpp(pxxDmaRead,linesPerXfer) ]
//                          
//  Macro Description:      Core of a CPU transfer when destination is 8bpp 
//                          (and source must be converted from non-indexed,
//                          to indexed)
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMem4bpp_Core(pxxDmaRead, cast) ]
//                          
//  Macro Description:      Core of a ScreenToMem with non-indexed to indexed
//                          translation, when dest. is 4bpp (and scanline is
//                          at least 2 bytes wide) (See CpuXferTo4bpp)
//
//                          The "cast" parameter MUST MATCH the pointer type:
//                          "cast" is (ULONG*) when "pxxDmaRead" is a (ULONG*)
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMem4bpp_Core_1ByteWidth(pxxDmaRead, cast) ]
//                          
//  Macro Description:      Core of a ScreenToMem with non-indexed to indexed
//                          translation, when dest. is 4bpp (and scanline is
//                          1 byte wide) (See CpuXferTo4bpp_1ByteWidth)
//
//                          The "cast" parameter MUST MATCH the pointer type:
//                          "cast" is (ULONG*) when "pxxDmaRead" is a (ULONG*)
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMem4bpp(pxxDmaRead,cast) ]
//                          
//  Macro Description:      Upper level macro to do a StoMblt with non-indexed
//                          to indexed translation, when dest. is 4bpp.
//                          Basically, it has the "for all rectangles" loop,
//                          calculate the "middleWidth" of a scanline and 
//                          exec the appropriate ScreenToMem4bpp_Core macro.
//
//                          The "cast" parameter MUST MATCH the pointer type:
//                          "cast" is (ULONG*) when "pxxDmaRead" is a (ULONG*)
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMem8bpp(pxxDmaRead,cast) ]
//                          
//  Macro Description:      Similar to ScreenToMem4bpp...
//                          
//                          
//  ---------------------------------------------------------------------------          
//
//  Here is a figure that shows a "macro-dependancy" example:
//
//                         ScreenToMem32to4bppBlt
//                         |
//                         |
//                         v
//                         ScreenToMem4bpp
//                           |
//                           |
//                           v
//                          .ScreenToMemXbpp_Common
//                          .       |
//                          .       v
//                          .       GiveOptBytesPerXfer
//                          .ScreenToMem4bpp_Core    
//                            |
//                            |
//                            v
//                            ScreenToMemXbpp_Common2
//                              |
//                              |
//                              v
//                             .PushSendDMAXfer_forXlines
//                             .PushWaitSendDMAXfer_forXlines
//                             .CpuXferTo4bpp
//
//  
//  Comments:
//
//      At the time of it's writing, this function makes these asumptions:
//
//          - A surface that has it's bitmap in VRAM can be a GDI managed DIB
//            (no DSURF associated, psoSrc->dhsurf == NULL )
//            if and only if it is the primary surface (what most
//            comments in the whole display driver code call the "SCREEN"), that
//            is, the surface which has PDEV.pjScreen as it's associated bitmap.
//          - Otherwise the surface is device managed and has a DSURF struct
//            associated with it
//          - We use PDEV.cjPelSize to know the number of bytes per pixel
//            EVEN when dealing with a src surface that is NOT the primary
//            one (the one which is actually associated with the PDEV).  So,
//            how come can we say that cjPelSize FROM PDEV is really the format
//            of our src bitmap ?  Because right now, the display memory must
//            contain only bitmaps of the same format.
//
//      (this is the way the whole NV display driver is done at this time)
//  
//          - Like ScreenTo1Bpp, this function assumes that the array of rectangles
//            that constrain (clip) the DST rectangle are already INSIDE this 
//            dst rectangle (so, already clipped by it).
//
//          - Like DMAGetScreenBits, this function makes assumption about the 
//            the value of the static data of the MEM_TO_MEM nv object.
//            It assumes that the SetContextDmaBufferIn() has been set to
//            the VRAM dma context, and that SetContextDmaBufferOut() has
//            been set to the mem2mem DMA buffer
//
//
//******************************************************************************

//******************************************************************************
// To get an approximation of the optimal "BytesPerXfer":
//
// We use the same ppdev->globalXferOverheadFactor than in ScreenToMem.  This is
// wrong, because this factor is based on calibration data that is calculated 
// in DrvEnableSurface based on the code of screentomem.  We have specified there,
// that any changes in the screentomem code must me made to the xfer loop being
// calibrated, otherwise, the calibration data is faulty.  So, ideally, calib
// data would have to give one factor for each different cpu/dma xfer algo.
// But since this calibration doesn't seem to affect benchmarks that much 
// after all (except for blitting lots of small icons ?), we use the same factor
//******************************************************************************


#ifdef  CALIBRATION_ENABLED
                                                                                                                  
#define GiveOptBytesPerXfer( optBytesPerXfer )                                                                    \
{                                                                                                                 \
        /* We are going to compute a fast squareroot (of a 32bit int)   */                                        \
        /* (see notes for more detail -stephane)                        */                                        \
                                                                                                                  \
        /* - First, find the position of the MSBit in the 32 bits       */                                        \
                                                                                                                  \
        if ( (bytes2Xfer & 0xFFFF0000 ) != 0 )                                                                    \
        {                                                                                                         \
            /* Search in the MSWord */                                                                            \
                                                                                                                  \
            tempUlong = (bytes2Xfer & 0xFF000000);                                                                \
                                                                                                                  \
            if ( tempUlong != 0 )                                                                                 \
            {                                                                                                     \
                /* the MSBit is in this MSByte, let the LUT do the rest of the job  */                            \
                                                                                                                  \
                /* ( bytes2Xfer >> 24 ) slide the MSByte in the LSByte position     */                            \
                                                                                                                  \
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 24 ] + 24;                                           \
            }                                                                                                     \
            else /* the  LSByte of the MSWord contains the bit we are looking for   */                            \
            {                                                                                                     \
                /* Our number is 0x00??????  */                                                                   \
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 16 ] + 16;                                           \
            }                                                                                                     \
                                                                                                                  \
        }                                                                                                         \
        else                                                                                                      \
        {                                                                                                         \
            /* Search the LSWord  */                                                                              \
                                                                                                                  \
            tempUlong = (bytes2Xfer & 0x0000FF00);                                                                \
                                                                                                                  \
            if ( tempUlong != 0 )                                                                                 \
            {                                                                                                     \
                /* the MSBit is in this MSByte of the LSWord let the LUT do the rest of the job  */               \
                                                                                                                  \
                /* ( bytes2Xfer >> 8 ) slide the MSByte in the LSByte position  */                                \
                                                                                                                  \
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 8 ] + 8;                                             \
            }                                                                                                     \
            else /* the  LSByte of the LSWord contains the bit we are looking for  */                             \
            {                                                                                                     \
                /* Our number is 0x000000??  */                                                                   \
                                                                                                                  \
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer ];                                                      \
            }                                                                                                     \
                                                                                                                  \
        } /* ... else the MSBit is in the LSWord of our 32 bit "bytes2Xfer" number  */                            \
                                                                                                                  \
        /*                                                                        */                              \
        /* We now have msbitPos, plug it into the other LUT to get a very good    */                              \
        /* initial approximation of the squareroot of bytes2Xfer.                 */                              \
        /*                                                                        */                              \
                                                                                                                  \
        tempUlong = BitPos2SquRtAprox_LUT[ msbitPos ];                                                            \
                                                                                                                  \
        /* Do Newton 2 times                                                      */                              \
        /* We could actually use only 1 iteration and it would be enough for our  */                              \
        /* needs.                                                                 */                              \
                                                                                                                  \
        tempUlong = (tempUlong + bytes2Xfer/tempUlong) >> 1 ;                                                     \
        tempUlong = (tempUlong + bytes2Xfer/tempUlong) >> 1 ;                                                     \
                                                                                                                  \
        /* We now have our squareroot(bytes2Xfer), all we need is to mul it       */                              \
        /* by our profiled constant                                               */                              \
                                                                                                                  \
        optBytesPerXfer = tempUlong * ppdev->globalXferOverheadFactor;                                            \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/******************************* End of GiveOptBytesPerXfer( optBytesPerXfer ) ***********************************/

#else  /* else if NOT #ifdef  CALIBRATION_ENABLED */
                                                                                                                  
            
#define GiveOptBytesPerXfer( optBytesPerXfer )                                                                    \
{                                                                                                                 \
        optBytesPerXfer = bytesPerLine << 3;   /* Force per-8-scanline xfers */                                   \
                                                                                                                  \
        /* optBytesPerXfer = bytes2Xfer;  */   /* Force non-overlapping xfer (test) */                            \
}                                                                                                                 \
/******************************* End of GiveOptBytesPerXfer( optBytesPerXfer ) ***********************************/


#endif /* ...#ifdef  CALIBRATION_ENABLED         */






#define ScreenToMemXbpp_Common                                                                                    \
{                                                                                                                 \
                                                                                                                  \
                                                                                                                  \
        /* Calculate the number of bytes it takes to hold this bitmap that   */                                   \
        /* we want to transfer.                                              */                                   \
        /*                                                                   */                                   \
                                                                                                                  \
        height = parcl[i].bottom - parcl[i].top;        /* parcl[i]  */                                           \
        width  = parcl[i].right - parcl[i].left;                                                                  \
                                                                                                                  \
        bytesPerLine = width * ppdev->cjPelSize;        /* This value is reused later */                          \
        bytes2Xfer   = height * bytesPerLine;                                                                     \
                                                                                                                  \
                                                                                                                  \
        /* ( We check if the Mem2Mem buffer is large enough later )   */                                          \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*                                                                      */                                \
        /* Decide the number of lines to Xfer at a time. We must round to a #   */                                \
        /* of lines for each rectangle because MEM2MEM objects Xfer by count    */                                \
        /* of lines, so we can't stop in the middle                             */                                \
        /* of a line, and start a Xfer with the width of the first line to xfer */                                \
        /* being different from the width of all of the lines following it.     */                                \
        /*                                                                      */                                \
        /************************************************************************/                                \
                                                                                                                  \
        /* (Use optimal equation with profiling data)                                                        */   \
        /*                                                                                                   */   \
        /* I have modified the Newton method using a lut so that                                             */   \
        /* I can have a nearly perfect INT result of the square root                                         */   \
        /* with only 2 iterations.                                                                           */   \
        /*                                                                                                   */   \
        /* to calculate optBytesPerXfer = squareroot(bytes2Xfer*overhead_of_setup*average_speed_of_dma_xfer) */   \
        /*                                                                                                   */   \
        /* We already have squareroot(overhead_of_setup*average_speed_of_dma_xfer) in the global             */   \
        /* var "globalXferOverheadFactor"                                                                    */   \
        /*                                                                                                   */   \
                                                                                                                  \
        /* optBytesPerXfer = bytesPerLine; */     /* Force perscanline xfers for the moment (test)   */           \
                                                                                                                  \
        /* optBytesPerXfer = bytes2Xfer;   */     /* Force non-overlapping xfer (test)               */           \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
         GiveOptBytesPerXfer( optBytesPerXfer );                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /* We have our optBytesPerXfer, now convert it in linesPerXfer          */                                \
        /************************************************************************/                                \
                                                                                                                  \
        /* But first check if the Mem2Mem buffer is large enough to hold 2 chunks */                              \
        /* of this size                                                           */                              \
                                                                                                                  \
        /* NOTE:                                                                  */                              \
        /*                                                                        */                              \
        /* ( We try to reduce the Xfer size to 1 scanline (the minimum);          */                              \
        /*   we could try reducing it by half and recheck, but it's not           */                              \
        /*   really worth it, if mem2mem buffer is too small, we are              */                              \
        /*   already in a case that will be handled more slowly )                 */                              \
                                                                                                                  \
                                                                                                                  \
        /* Check if we are not in the special case where it is more               */                              \
        /* efficient to do the xfer without overlapping ( in that case,           */                              \
        /* we need "bytes2Xfer" bytes in the mem2mem buffer)                      */                              \
        /* (Clamp optBytesPerXfer to bytes2Xfer in that case)                     */                              \
                                                                                                                  \
        if( optBytesPerXfer > bytes2Xfer )                                                                        \
        {                                                                                                         \
            optBytesPerXfer = bytes2Xfer;  /* clamp the size of the chunk */                                      \
                                           /* to total bytes to xfer      */                                      \
                                                                                                                  \
            if( optBytesPerXfer > ppdev->MemToMemBufferSize )                                                     \
            {                                                                                                     \
                /* We must do one xfer, but mem2membuffer is too small. */                                        \
                /* Reduce it to the minimum                             */                                        \
                                                                                                                  \
                optBytesPerXfer = bytesPerLine;                                                                   \
                                                                                                                  \
                if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                                       \
                    return(FALSE);  /* we can't even store 2 scanlines! */                                        \
            }                                                                                                     \
                                                                                                                  \
        } /* ...if optxfersize > total2xfer  */                                                                   \
                                                                                                                  \
        /*  Else, check if we need to clamp to at least 1 scanline   */                                           \
        /* (indeed, if optBytesPerXfer calculated is                 */                                           \
        /*  lower than a scanline, we are going to use               */                                           \
        /*  a scanline-based transfer anyway, so we                  */                                           \
        /*  must check the size of mem2mem buffer VS                 */                                           \
        /*  at least a scanline )                                    */                                           \
                                                                                                                  \
        else if( optBytesPerXfer < bytesPerLine )                                                                 \
        {                                                                                                         \
            optBytesPerXfer = bytesPerLine;                                                                       \
                                                                                                                  \
            if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                                           \
                return(FALSE);  /* we can't even store 2 scanlines!   */                                          \
        }                                                                                                         \
                                                                                                                  \
        /* Else optBytesPerXfer is within boundaries, check if we can */                                          \
        /* store two chunks of that size                              */                                          \
                                                                                                                  \
        else if( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                                           \
        {                                                                                                         \
            /* Mem2Mem buffer size is too small for the size of 2 Xfer chunks. */                                 \
            /* Try to reduce the xfer chunk to the minimum                     */                                 \
                                                                                                                  \
            optBytesPerXfer = bytesPerLine;                                                                       \
                                                                                                                  \
            if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                                           \
                return(FALSE);  /* we can't even store 2 scanlines!     */                                        \
        }                                                                                                         \
                                                                                                                  \
                                                                                                                  \
        /* There are many ways to round: clamp to unit by truncating, or clamp to */                              \
        /* higher unit as soon as there is a rest, etc.  Simplest is truncating   */                              \
        /*                                                                        */                              \
                                                                                                                  \
        linesPerXfer = ( optBytesPerXfer / bytesPerLine );                                                        \
                                                                                                                  \
                                                                                                                  \
        /* Clamp to higher unit instead of truncate with ( bytesPerXfer / bytesPerLine );       */                \
        /*                                                                                      */                \
        /* Let's limit bytersPerXfer to 33 MB, so we have 7 bits (MSBits) out of                */                \
        /* 32 to use to do fixed point math. ( 32-7 = 25, 2^25 = 33 MB )                        */                \
        /*                                                                                      */                \
        /* [ (bytesPerXfer << 7 ) / ( bytesPerLine << 7 )  + 0x7F (which is 1111111b) ]  >> 7   */                \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*  An object of NV_MEM_TO_MEM class must be attached to 2 DMA contexts.*/                                \
        /*  The src and dst must be given through method writes, and these src  */                                \
        /*  and dst ptr must be in offset RELATIVE to the address of the BASE   */                                \
        /*  (so relative to the beginning) of the DMA region.                   */                                \
        /*                                                                      */                                \
        /*  So, we are going to:                                                */                                \
        /*                                                                      */                                \
        /*      - First, find the coordinates of the current clip rectangle     */                                \
        /*        in the SRC RECTL. (see below)                                 */                                \
        /*      - Find the offset in byte of these coordinates, relative to the */                                \
        /*        beginning of the source bits, and find the absolute address   */                                \
        /*        of these coordinates by adding the base of the source bits.   */                                \
        /*      - Substract the base of the DMA region from this ptr to obtain  */                                \
        /*        an offset relative to the base.                               */                                \
        /*                                                                      */                                \
        /************************************************************************/                                \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*      - First, find the coordinates of the current clip rectangle     */                                \
        /*        in the SRC RECTL. (see below)                                 */                                \
        /************************************************************************/                                \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*                                                                      */                                \
        /*          1) pptlSrc->x    ( value x1 shown below )                   */                                \
        /*                                                                      */                                \
        /*          2) prclDst->x    ( value x2 shown below )                   */                                \
        /*                                                                      */                                \
        /*             Location of the original unclipped destination rectangle */                                \
        /*                                                                      */                                \
        /*          3) parcl[i]       ( value x3 shown below)                   */                                \
        /*                                                                      */                                \
        /*            Current clip rectangle with coordinates relative to origin*/                                \
        /*                                                                of Dst*/                                \
        /*                                                                      */                                \
        /*   Origin  (Destination bitmap )                                      */                                \
        /*  +--------------------------------------------------------------->   */                                \
        /*  |                                                                   */                                \
        /*  |                                                                   */                                \
        /*  |           x2 = prclDst->left                                      */                                \
        /*  |           +-----------------------------------------------                  */                      \
        /*  |           |                              ^                |-Original        */                      \
        /*  |           |                              | dySrc          |  Unclipped      */                      \
        /*  |           |                              |                |   Destination   */                      \
        /*  |           |         x3 = parcl[i].left   v                |    Rectangle    */                      \
        /*  |           |         +------------        -                |                 */                      \
        /*  |           |         |            |                        |       */                                \
        /*  |           |<-dxSrc->|            |                        |       */                                \
        /*  |           |         |            |                        |       */                                \
        /*  |           |         |            |-Current                |       */                                \
        /*  |           |         |            |  Clip                  |       */                                \
        /*  |           |          ------------    Rectangle            |       */                                \
        /*  |           |                                               |       */                                \
        /*  |           |                                               |       */                                \
        /*  |           |                                               |       */                                \
        /*  |            -----------------------------------------------        */                                \
        /*  |                                                                   */                                \
        /*  v                                                                   */                                \
        /*                                                                      */                                \
        /*                                                                      */                                \
        /*           Origin (Source bitmap)                                     */                                \
        /*          +--------+--|-----+--------+------->                        */                                \
        /*          |           x1                                              */                                \
        /*          |                                                           */                                \
        /*          |                                                           */                                \
        /*          |                                                           */                                \
        /*          |           ^                                               */                                \
        /*          v           |                                               */                                \
        /*          |           |                                               */                                \
        /*          |           |                                                           */                    \
        /*          |-- x1 ---->|   x1 = pptlSrc->x                                         */                    \
        /*          |           +-----------------------------------------------            */                    \
        /*          |           |                             ^                 |-Source    */                    \
        /*          |           |                             | dySrc           | Rectangle */                    \
        /*          |           |                             |                 |           */                    \
        /*          |           |         x? = x1 + dxSrc     v                 |           */                    \
        /*          |           |         +------------       -                 |           */                    \
        /*          |           |         |            |                        |           */                    \
        /*          |           |<-dxSrc->|            |                        |           */                    \
        /*          |           |         |            |                        |           */                    \
        /*          |           |         |            |-Current                |           */                    \
        /*          |           |         |            |  Clip                  |           */                    \
        /*          |           |          ------------    Rectangle            |           */                    \
        /*          |           |                        ( but in SRC surface)  |           */                    \
        /*          |           |                                               |           */                    \
        /*          |           |                                               |           */                    \
        /*          |            -----------------------------------------------            */                    \
        /*                                                                                  */                    \
        /***********************************************************************            */                    \
                                                                                                                  \
                                                                                                                  \
        ptlSrcRegion.x  = pptlSrc->x + (parcl[i].left - prclDst->left);                                           \
        ptlSrcRegion.y  = pptlSrc->y + (parcl[i].top  - prclDst->top);                                            \
                                                                                                                  \
        /****************************************************************************/                            \
        /*      - Find the offset in byte of these coordinates, relative to the     */                            \
        /*        beginning of the source bits, and find the absolute address       */                            \
        /*        of these coordinates by adding the base of the source bits.       */                            \
        /*                                                                          */                            \
        /* (Calculate the pointer to the upper-left corner of Source clipped region)*/                            \
        /****************************************************************************/                            \
                                                                                                                  \
        pjSrcRclBits    =     pjSrcBits                             /* base of Src Bits */                        \
                              + ( ptlSrcRegion.y  * lSrcPitch )                                                   \
                              + ptlSrcRegion.x * ppdev->cjPelSize ;                                               \
                                /* CONVERT_TO_BYTES(x,pdev) == (x) * pdev->cjPelSize    */                        \
                                                                                                                  \
                                                                                                                  \
        /* We don't have to calculate the dst address for the DMA transfer:    */                                 \
        /* we have it, it is the dst                                           */                                 \
        /* of the mem2mem DMA buffer, but we have to calculate the address in  */                                 \
        /* the final destination surface, for the cpu transfer                 */                                 \
                                                                                                                  \
                                                                                                                  \
        /****************************************************************************/                            \
        /*                                                                          */                            \
        /*  Now, we need to setup the first Xfer, wait for it to end, and enter     */                            \
        /*  the main Xfer loop, were we kick a Xfer for the next chunk, and Xfer    */                            \
        /*  the last chunk from mem2mem buffer to final sys mem destination.        */                            \
        /*  Finally, we are going to Xfer the remaining data                        */                            \
        /*  ( total_lines_to_xfer % optimal_lines_by_xfer )                         */                            \
        /*                                                                          */                            \
        /****************************************************************************/                            \
                                                                                                                  \
                                                                                                                  \
        /****************************************************************************/                            \
        /* Calculate the offsets of the transfer src and dst from the beginning of  */                            \
        /* their respective DMA region base                                         */                            \
        /****************************************************************************/                            \
                                                                                                                  \
        DstDMAOffset = 0;         /* Init the current DMAoffset where to write    */                              \
                                                                                                                  \
                                                                                                                  \
                                  /* Init current source DMAoffset where to read  */                              \
                                                                                                                  \
        SrcDMAOffset = (ULONG)(pjSrcRclBits - ppdev->pjFrameBufbase);                                                   \
                                  /* We are assuming that base of VRAM DMA context             */                 \
                                  /* is == pjFrameBufbase, that is, that the DMAoffset of pjFrameBufbase   */                 \
                                  /* is always 0. That's why we use ppdev->pjFrameBufbase for        */                 \
                                  /* base of DMA region                                        */                 \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*                                                                      */                                \
        /* Precalculate the num of bytes to add to the SrcDmaOffset for each    */                                \
        /* transfer and the address of the second chunk in the DstDMA           */                                \
        /* (the mem2mem buffer)                                                 */                                \
        /*                                                                      */                                \
        /* ( We could use linesPerXfer * bytesPerLine,                          */                                \
        /* and that would also be the number of bytes to add to the             */                                \
        /* DstDmaOffset if we would be user a mem2mem buffer the size of the    */                                \
        /* whole transfer. In other words, not using the strict minimum to be   */                                \
        /* able to do overlapping, that is 2 chunks in the buffer (one to which */                                \
        /* DMA write, the other to which CPU read, and then, the opposite...)   */                                \
        /*                                                                      */                                \
        /* Instead we use ppdev->MemToMemBufferSize/2, because that value never */                                \
        /* changes (for any xfer size), so we can put that calculation out of   */                                \
        /* the rectangle loop. (for all rectangles)                             */                                \
        /*                                                                      */                                \
        /*                                                                      */                                \
        /* Also init some variables before going on to the Xfers                */                                \
        /*                                                                      */                                \
        /* Reminder: the pitch include the linelenght (bytesperline)!           */                                \
        /************************************************************************/                                \
                                                                                                                  \
                                                                                                                  \
        SrcDMAincPerXfer         = linesPerXfer * lSrcPitch;                                                      \
                                                                                                                  \
                                                                                                                  \
        linesToGo                = height;      /* Init the number of lines left to transfer  */                  \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/*************************************** End of ScreenToMemXbpp_Common *******************************************/






#define ScreenToMemXbpp_Common2(pxxDmaRead, cast, CpuXferMACRONAME)                                               \
{                                                                                                                 \
                                                                                                                  \
        pxxDmaRead               = cast(pulDmaRead_start); /* Init the reading ptr for the second  */             \
                                                           /* transfer "pipe" (the CPU-Xfers)      */             \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
        /***********************************************************************************/                     \
        /*                      Setup the first transfer                                   */                     \
        /*                                                                                 */                     \
        /*  NOTE: Somebody looking at this code (further below) might think:               */                     \
        /*        why doing this first xfer outside of the main xfer loop ?                */                     \
        /*        "Everything looks the same inside the loop"  This is not                 */                     \
        /*        exactly right: the loop is done so when it rolls we wait                 */                     \
        /*        for the last notifier being setup, just before resetting                 */                     \
        /*        this notifier and kicking off the new transfer. If we would              */                     \
        /*        remove that special-casing of the first xfer, we would be                */                     \
        /*        waiting inside the start of the xfer loop forever because                */                     \
        /*        no xfer has been setup yet...                                            */                     \
        /*                                                                                 */                     \
        /*                                                                                 */                     \
        /***********************************************************************************/                     \
                                                                                                                  \
        PushSendDMAXfer_forXlines(linesPerXfer);                                                                  \
                                                                                                                  \
        /***********************************************************************************/                     \
        /* Here we incremented the offsets before the Xfer completes, so we can            */                     \
        /* cover a bit the processing (make these calculations during the time             */                     \
        /* the first Xfer execute)                                                         */                     \
        /***********************************************************************************/                     \
                                                                                                                  \
        linesToGo       -= linesPerXfer;          /* Susbtract the lines that have been done. */                  \
        SrcDMAOffset    += SrcDMAincPerXfer;      /* Advance in the source DMA region         */                  \
        DstDMAOffset     = DstDMA2ndPartOffset;   /* Advance in the dest. DMA region          */                  \
                                                  /* (the mem2mem buffer) so we use the       */                  \
                                                  /* 2nd part the next time.                  */                  \
                                                                                                                  \
        /*                                                                  */                                    \
        /* REMINDER: ANY CODE FOLLOWING THIS MUST CHECK THE NOTIFIER        */                                    \
        /* IF IT WANTS TO BE SURE THAT THE MEM2MEM BUFFER DATA IS VALID     */                                    \
        /*                                                                  */                                    \
                                                                                                                  \
        /***[ Make sure there are still enough lines to Xfer before starting  *****/                              \
        /*                                                  another DMA Xfer ]    */                              \
                                                                                                                  \
        if ( linesToGo < linesPerXfer )  /* if there are not "linesPerXfer" lines to Xfer     */                  \
        {                                                                                                         \
            /* Now what is left is a CPU Xfer of "linesPerXfer" plus at most      */                              \
            /* one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...   */                              \
            /*                                                                    */                              \
            /* We save the value to which we must set the position of pulDmaRead  */                              \
            /* for the very last CPU read ( of size height % linesPerXfer)        */                              \
                                                                                                                  \
            pulDmaRead_lastXfer = pulDmaRead_2ndPart;                                                             \
                                                                                                                  \
                                                                                                                  \
        } /* ...if there are less than linesPerXfer left to Xfer                  */                              \
                                                                                                                  \
        else                                                                                                      \
        {                                                                                                         \
            /*  else, enter the main Xfer loop. */                                                                \
                                                                                                                  \
            /*******************************************************************************/                     \
            /*                Main transfer loop with overlapping Xfers                    */                     \
            /*                                                                             */                     \
            /*  Note that we are starting to setup the next DMA                            */                     \
            /*  xfer even before checking if the last one is finished. We only do so       */                     \
            /*  at the last minute, before resetting the notifier, and kicking the next    */                     \
            /*  DMA Xfer for maximum overlapping of processing                             */                     \
            /*                                                                             */                     \
            /*                                                                             */                     \
            /*******************************************************************************/                     \
                                                                                                                  \
            for(;;)   /* (for all Xfers that can be done in linesPerXfer chunks):         */                      \
                      /* - this is a 2 part loop with                                     */                      \
                      /*   2 breakout cases, so that's why we use a for(;;))              */                      \
                      /*   (2 cases because we are doing either one or the other part of  */                      \
                      /*   the mem2mem buffer)                                            */                      \
            {                                                                                                     \
                /*                                                                          */                    \
                /* START another DMA-Xfer:    remember, we use ( 2*bytesperxfer ) bytes     */                    \
                /*                            in our Mem2Mem buffer. (So we alternate       */                    \
                /*                            using it's two parts )                        */                    \
                /*                                                                          */                    \
                /*                            We started Xfering to the first part          */                    \
                /*                            (before entering the loop, and at the end     */                    \
                /*                            of this for(;;) loop),                        */                    \
                /*                            (the NV hw is writting to the first part)     */                    \
                /*                            so we are going to read from that first part  */                    \
                /*                            while we kick another Xfer in the second      */                    \
                /*                            part.                                         */                    \
                /*                                                                          */                    \
                /* (Note that the first time we enter this loop, we will wait without       */                    \
                /*  overlapping: this is normal, we need to wait for the **FIRST** xfer     */                    \
                /*  to be done, because in the other part of the 2part buffer, there        */                    \
                /*  isn't any data available yet for our CPU.)                              */                    \
                /*                                                                          */                    \
                                                                                                                  \
                /*---[ So now: ]------------------------*/                                                        \
                /*                                      */                                                        \
                /* DstDMAOffset == DstDMA2ndPartOffset; */                                                        \
                /*   pulDmaRead == pulDmaRead_start;    */                                                        \
                /*                                      */                                                        \
                /*--------------------------------------*/                                                        \
                                                                                                                  \
                /*                                                                                    */          \
                /* START another DMA-Xfer (but this time with wait for notification before resetting  */          \
                /*                         the notifier and kicking it)                               */          \
                /*                                                                                    */          \
                                                                                                                  \
                                                                                                                  \
                PushWaitSendDMAXfer_forXlines(linesPerXfer);                                                      \
                                                                                                                  \
                linesToGo    -= linesPerXfer;          /* Susbtract the lines that have been done.  */            \
                SrcDMAOffset += SrcDMAincPerXfer;      /* Advance in the source DMA region (VRAM)   */            \
                DstDMAOffset  = 0;                     /* Go back to the first part of the mem2mem  */            \
                                                       /* DMA buffer in the next DMA Xfer.          */            \
                                                                                                                  \
                /***************************************************************************/                     \
                /*  In the meantime, CPU-Xfer what has been DMA-Xfered.                    */                     \
                /*                                                                         */                     \
                /*  Note that here we have two chases that can go on: if DMA-Xfer is faster,     */               \
                /*  the while(!notified) active-wait will always be true by the time we          */               \
                /*  get here. We could, to be fancier, check after a certain number of bytes     */               \
                /*  CPU-Xfered, if the notification has been trigered (using the profiling       */               \
                /*  data, we can do it), but it's not really worth it. Indeed, if the DMA-Xfer   */               \
                /*  is faster, and we launch more than 1 per CPU-Xfered-chunk, (let's say 1.2    */               \
                /*  on average), at the end, all the DMA-Xfers will be over, yes, and the        */               \
                /*  hardware will be idle yes, but we will still have to finish here, in this    */               \
                /*  function, with our CPU transfer, and THAT is going to be the limiting speed. */               \
                /*  (And since the driver is not re-entrant, the idle hardware won't be used     */               \
                /*  anyway during this time)                                                     */               \
                /*  Repeat a similar reasoning for the other chase condition, that is,     */                     \
                /*  if the CPU-Xfers are faster than the DMA-Xfers.                        */                     \
                /***************************************************************************/                     \
                                                                                                                  \
                CpuXferMACRONAME(pxxDmaRead,linesPerXfer);                                                        \
                                                                                                                  \
                /* Set our pjDmaRead ptr at the beginning of the second part of our mem2mem buffer */             \
                /* (For the next CPU-Xfer)                                                         */             \
                                                                                                                  \
                pxxDmaRead = cast(pulDmaRead_2ndPart);                                                            \
                                                                                                                  \
                /*                              */                                                                \
                /* ... CPU Xfer done.           */                                                                \
                                                                                                                  \
                                                                                                                  \
                /***[ Make sure there are still lines to Xfer before starting         *****/                      \
                /*                                                  another DMA Xfer ]    */                      \
                                                                                                                  \
                if ( linesToGo < linesPerXfer )  /* if there are no more chunk to Xfer    */                      \
                {                                                                                                 \
                                                                                                                  \
                    /* Now what is left is a CPU Xfer of "linesPerXfer" plus at most      */                      \
                    /* one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...   */                      \
                    /*                                                                    */                      \
                    /* We save the value to which we must set the position of pjDmaRead   */                      \
                    /* for the very last CPU read ( of size height % linesPerXfer)        */                      \
                                                                                                                  \
                    pulDmaRead_lastXfer = pulDmaRead_start;                                                       \
                                                                                                                  \
                    break;          /* break out of the Xfer loop (for(;;))  */                                   \
                }                                                                                                 \
                /*                                                                        */                      \
                /**************************************************************************/                      \
                                                                                                                  \
                /*                                                                        */                      \
                /* START another DMA-Xfer:    Remember, we use ( 2*bytesPerXfer ) bytes   */                      \
                /*                            in our Mem2Mem buffer. (So we alternate     */                      \
                /*                            using it's two parts )                      */                      \
                /*                                                                        */                      \
                /*                            The last Xfer kicked used the 2nd part.     */                      \
                /*                            Next Xfer is going to use the first part    */                      \
                /*                            again.                                      */                      \
                                                                                                                  \
                /*---[ So now: ]------------------------*/                                                        \
                /*                                      */                                                        \
                /* DstDMAOffset == 0;                   */                                                        \
                /*   pulDMAread == pulDmaRead_2ndPart;  */                                                        \
                /*                                      */                                                        \
                /*--------------------------------------*/                                                        \
                                                                                                                  \
                PushWaitSendDMAXfer_forXlines(linesPerXfer);                                                      \
                                                                                                                  \
                linesToGo       -= linesPerXfer;          /* Susbtract the lines that have been done. */          \
                SrcDMAOffset    += SrcDMAincPerXfer;      /* Advance in the source DMA region (VRAM)  */          \
                DstDMAOffset     = DstDMA2ndPartOffset;   /* Advance in the dest. DMA region          */          \
                                                          /* (the mem2mem buffer) so we use the       */          \
                                                          /* 2nd part the next time.                  */          \
                                                                                                                  \
                /***************************************************************************/                     \
                /*  In the meantime, CPU-Xfer what has been DMA-Xfered in the 2nd part     */                     \
                /***************************************************************************/                     \
                                                                                                                  \
                                                                                                                  \
                CpuXferMACRONAME(pxxDmaRead,linesPerXfer);                                                        \
                                                                                                                  \
                                                                                                                  \
                /* Set our pjDmaRead ptr at the beginning of the first part of our mem2mem buffer  */             \
                                                                                                                  \
                pxxDmaRead = cast(pulDmaRead_start);         /* Reset the read ptr at the        */               \
                                                             /* first part (beginning) of the    */               \
                                                             /* MEM2MEM buffer                   */               \
                /* ... CPU Xfer Done.  */                                                                         \
                                                                                                                  \
                                                                                                                  \
                /***[ Make sure there are still lines to Xfer before starting         *****/                      \
                /*                                                  another DMA Xfer ]    */                      \
                                                                                                                  \
                if ( linesToGo < linesPerXfer )  /* if there are no more lines to Xfer    */                      \
                {                                                                                                 \
                                                                                                                  \
                    /* Now what is left is a CPU Xfer of "linesPerXfer" plus at most      */                      \
                    /* one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...   */                      \
                    /*                                                                    */                      \
                    /* We save the value to which we must set the position of pjDmaRead   */                      \
                    /* for the very last CPU read ( of size height % linesPerXfer)        */                      \
                                                                                                                  \
                    pulDmaRead_lastXfer = pulDmaRead_2ndPart;                                                     \
                                                                                                                  \
                    break;          /* break out of the Xfer loop (for(;;)) */                                    \
                                                                                                                  \
                } /* ...if there are less than "linesPerXfer" left to Xfer  */                                    \
                                                                                                                  \
                /*                                                                        */                      \
                /**************************************************************************/                      \
                                                                                                                  \
                                                                                                                  \
            } /* ...for(;;)  ( while(linesToGo >= linesPerXfer )  )  */                                           \
              /*                                                     */                                           \
              /* (this is a special cased 2 part loop)               */                                           \
                                                                                                                  \
                                                                                                                  \
        } /*  ...else enter the main Xfer loop (if there are at least linesPerXfer left to Xfer) */               \
                                                                                                                  \
        /***********************************************************************************/                     \
        /*                                                                                 */                     \
        /*                Last transfer: Time to execute the last transfer                 */                     \
        /*                                                                                 */                     \
        /*  There is at most one DMA transfer left to execute, and at most 2 mem2mem       */                     \
        /*  chunks to transfer (the last DMA that is about to be completed, and the        */                     \
        /*  one that we are about to start, if there is one)                               */                     \
        /*                                                                                 */                     \
        /***********************************************************************************/                     \
                                                                                                                  \
        if ( linesToGo == 0 ) /* only 1 CPU-Xfer left to execute                   */                             \
                              /* (that means that totalLinesToXfer was a multiple  */                             \
                              /* of linesPerXfer, => total % linesPerXfer == 0     */                             \
        {                                                                                                         \
            /*******************************************************************************/                     \
            /* Wait for the last DMA to be completed (use second notification structure)   */                     \
            /*******************************************************************************/                     \
                                                                                                                  \
            while ( pNotifier->status != 0 );                                                                     \
                                                                                                                  \
            CpuXferMACRONAME(pxxDmaRead,linesPerXfer);                                                            \
                                                                                                                  \
            /******************************************/                                                          \
            /* And this rectangle is done, at last... */                                                          \
            /******************************************/                                                          \
                                                                                                                  \
        } /* ...if ( linesToGo == 0 ) */                                                                          \
                                                                                                                  \
        else /* else, setup one last DMA Xfer */                                                                  \
        {                                                                                                         \
            /* This last DMA-Xfer is different in that the line count is                        */                \
            /* linesToGo (the rest of the lines, which is < than our linesPerXfer calculated )  */                \
            /*                                                                                  */                \
                                                                                                                  \
            PushWaitSendDMAXfer_forXlines(linesToGo);                                                             \
                                                                                                                  \
            /*******************************************************************************/                     \
            /* Now that this last DMA-Xfer is running, transfer the last "linesPerXfer"    */                     \
            /* long chunk. (this is our last but one CPU-Xfer)                             */                     \
            /*                                                                             */                     \
            /* We might think of one complication here: we do not know where we broke in   */                     \
            /* our main for(;;) loop.  So we do not know to which part of the mem2mem      */                     \
            /* buffer we must read our last cpu xfer. (In other words, where to put the    */                     \
            /* pjDmaRead ptr. This is solved in the loop by saving the next value to which */                     \
            /* it must be set (this is to avoid doing an additionnal "IF" here, to know    */                     \
            /* were we broke in the for(;;) )                                              */                     \
            /*                                                                             */                     \
            /*******************************************************************************/                     \
                                                                                                                  \
            CpuXferMACRONAME(pxxDmaRead,linesPerXfer);                                                            \
                                                                                                                  \
            /* Set our pjDmaRead ptr at the beginning of the ? part of our mem2mem buffer  */                     \
            /* (the right part for our last cpu xfer; this was selected in the for(;;)     */                     \
                                                                                                                  \
            pxxDmaRead = cast(pulDmaRead_lastXfer);                                                               \
                                                                                                                  \
                                                                                                                  \
            /*******************************************************************************/                     \
            /* Wait for the LAST DMA-Xfer to be completed                                  */                     \
            /* ( if it is not yet completed ) and CPU-Xfer these remainder lines           */                     \
            /*******************************************************************************/                     \
                                                                                                                  \
            while ( pNotifier->status != 0 );                                                                     \
                                                                                                                  \
            CpuXferMACRONAME(pxxDmaRead,linesToGo);                                                               \
                                                                                                                  \
            /*****************************************/                                                           \
            /* And this rectangle is done, at last...*/                                                           \
            /*****************************************/                                                           \
                                                                                                                  \
        } /* ...else ( linesToGo != 0 )  ( one last DMA xfer to setup )   */                                      \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/************************ End of ScreenToMemXbpp_Common2(pxxDmaRead,cast,CpuXferMACRONAME) ***********************/





#define PushSendDMAXfer_forXlines(linesPerXfer)                                                                   \
{                                                                                                                 \
    /***********************************************************************/                                     \
    /* Set methods for memory_to_memory dma blit                           */                                     \
    /*   NV039_OFFSET_IN                                                   */                                     \
    /*   NV039_OFFSET_OUT                                                  */                                     \
    /*   NV039_PITCH_IN                                                    */                                     \
    /*   NV039_PITCH_OUT                                                   */                                     \
    /*   NV039_LINE_LENGTH_IN                                              */                                     \
    /*   NV039_LINE_COUNT                                                  */                                     \
    /*   NV039_FORMAT                                                      */                                     \
    /*   NV039_BUFFER_NOTIFY                                               */                                     \
    /***********************************************************************/                                     \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Set notifier to 'BUSY' value (use second notification structure)        */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;                                                    \
                                                                                                                  \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Check if we've got enough room in the push buffer                       */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    NV_DMAPUSH_CHECKFREE(((ULONG)(9)));                                                                           \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
    NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );                                                              \
    NV_DMA_FIFO = SrcDMAOffset;                         /* Offset In  */                                          \
    NV_DMA_FIFO = DstDMAOffset;                         /* Offset Out */                                          \
    NV_DMA_FIFO = lSrcPitch;                            /* Pitch In   */                                          \
    NV_DMA_FIFO = bytesPerLine;                         /* Pitch Out == bytesPerLine because          */          \
                                                        /* we dont want any memory "hole" between     */          \
                                                        /* two contiguous lines in the mem2mem buffer */          \
                                                                                                                  \
    NV_DMA_FIFO = bytesPerLine;                         /* Line Length in bytes          */                       \
    NV_DMA_FIFO = linesPerXfer;                         /* Line Count (num to copy)      */                       \
    NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 |                                                                    \
                  NV_MTMF_FORMAT_OUTPUT_INC_1;          /* Format                        */                       \
    NV_DMA_FIFO = 0;                                    /* Set Buffer Notify and kickoff */                       \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Update global push buffer count                                         */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    UPDATE_PDEV_DMA_COUNT;                                                                                        \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Send data on thru to the DMA push buffer                                */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    NV4_DmaPushSend(ppdev);                                                                                       \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/*********************** End of PushSendDMAXfer_forXlines(linesPerXfer) ******************************************/
                                                                                                                   


#define PushWaitSendDMAXfer_forXlines(linesPerXfer)                                                               \
{                                                                                                                 \
    /***********************************************************************/                                     \
    /* Set methods for memory_to_memory dma blit                           */                                     \
    /*   NV039_OFFSET_IN                                                   */                                     \
    /*   NV039_OFFSET_OUT                                                  */                                     \
    /*   NV039_PITCH_IN                                                    */                                     \
    /*   NV039_PITCH_OUT                                                   */                                     \
    /*   NV039_LINE_LENGTH_IN                                              */                                     \
    /*   NV039_LINE_COUNT                                                  */                                     \
    /*   NV039_FORMAT                                                      */                                     \
    /*   NV039_BUFFER_NOTIFY                                               */                                     \
    /***********************************************************************/                                     \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Check if we've got enough room in the push buffer                       */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    NV_DMAPUSH_CHECKFREE(((ULONG)(9)));                                                                           \
                                                                                                                  \
                                                                                                                  \
    NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );                                                              \
    NV_DMA_FIFO = SrcDMAOffset;                         /* Offset In  */                                          \
    NV_DMA_FIFO = DstDMAOffset;                         /* Offset Out */                                          \
    NV_DMA_FIFO = lSrcPitch;                            /* Pitch In   */                                          \
    NV_DMA_FIFO = bytesPerLine;                         /* Pitch Out == bytesPerLine because          */          \
                                                        /* we dont want any memory "hole" between     */          \
                                                        /* two contiguous lines in the mem2mem buffer */          \
                                                                                                                  \
    NV_DMA_FIFO = bytesPerLine;                         /* Line Length in bytes          */                       \
    NV_DMA_FIFO = linesPerXfer;                         /* Line Count (num to copy)      */                       \
    NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 |                                                                    \
                  NV_MTMF_FORMAT_OUTPUT_INC_1;          /* Format                        */                       \
    NV_DMA_FIFO = 0;                                    /* Set Buffer Notify and kickoff */                       \
                                                                                                                  \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Wait for the last DMA-Xfer kicked to be completed (use 2nd notif.struct)*/                                 \
    /* ( if it is not yet completed )                                          */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    while ( pNotifier->status != 0 );                                                                             \
                                                                                                                  \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Set notifier to 'BUSY' value (use second notification structure)        */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;                                                    \
                                                                                                                  \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Update global push buffer count                                         */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    UPDATE_PDEV_DMA_COUNT;                                                                                        \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Send data on thru to the DMA push buffer                                */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    NV4_DmaPushSend(ppdev);                                                                                       \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/********************************* End of PushWaitSendDMAXfer_forXlines ******************************************/


// CpuXferTo4bpp(pxxDmaRead,linesPerXfer)
//
// Here we do:
//
//  For the left 
//
//   1) Read the final dest byte (containing the left pixel)
//      by masking also the bits we will modifie (read with an AND
//      between our mask and dest byte)
//
//   2) Read and translate the pixel (32bit) in the DMA mem2mem buffer
//   3) Shift translated byte to put it's 4 bits in the correct part
//      of the byte
//   4) Write the 4bits of the xlated byte (this is our new pixel!)
//      inside the byte "created" at step 1. (by doing step1_byte |= xlated_byte;
//   5) Write back the resulting byte from step 4 in it's final destination
//      (same address then the one we read from at step 1)
//
//   After doing the left byte, we do the middle bytes in a similar way
//   except that we don't have to mask because all the byte must be overwritten.
//   Then we do the right byte in a similar way than the left byte.

// ********************
// Do the Left byte
// ********************

// If the left coordinate was starting on the low nibble of the byte containing
// the pixel, we need to process another pixel before going on to the middle bytes

// (We could have done this to avoid doing this if:
//
//   (similar to the ScreenTo1Bpp code )
//
// Transfer more than we need (by clamping the right coordinate
// to the highest even number, and clamping the left one the lowest even)
// This is done to avoid special casing when we translate the LEFT byte
// in the CPU-Xfer loop: if the left coordinate start in the low nibble
// of a byte in the dest scanline, this means that we are going to read
// only 1 32bit pixel in the mem2mem buffer, before doing the middle
// bytes. But if the left coordinate start on the high nibble, we will
// have to convert 2 pixels from the mem2mem buffer and combine them
// in 1 byte to write before going on the middle bytes. (We would also use
// a real mask, pretty much like ScreenTo1Bpp but only a 2 entry LUT, we have 4bpp)
//
//
// But is it really worth it ?  Because when u think of it: you have more overhead
// by reading more than you need (insignificant for the DMA I agree), overhead to
// clamp the coordinates (insignificant), and (more significant) overhead of always
// Xlating a pixel for nothing (in the case where there is a rest)
//  (call to the Xlate macro). (Because this pixel is not in the destination region
// to modifie and it will get masked out anyway by our mask, if there's a rest)
//
// SO, to summarize, we use "IFs" instead of a general algo like 
// " transfer an even number of byte + always convert all pixels in the byte + and only
// write back, at the dest, the pixels we really need to modifie " we use IF's to avoid
// converting pixels for nothing (because this is expensive)

            
#define CpuXferTo4bpp(pxxDmaRead,linesPerXfer)                                                                    \
{                                                                                                                 \
    /* Xfer all lines    */                                                                                       \
    /*                   */                                                                                       \
    for(j=0; j < linesPerXfer; j++)                                                                               \
    {                                                                                                             \
        /*************************/                                                                               \
        /* Do the Left byte      */                                                                               \
        /*************************/                                                                               \
                                                                                                                  \
        if ( leftRest == 0) /* There is no rest, so that we must modifie the whole left byte */                   \
        {                                                                                                         \
            XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* xlate first pixel             */   \
            pxxDmaRead++;                                                                                         \
            XlatedByte <<= 4;                                           /* place the nibble in the MS Nibble */   \
            XlatedByte  |= (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* xlate & combine second pixel  */   \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
                /* NOTE: Here we know the destination is 4Bpp,                       */                           \
                /*       so even if the macro returns a ULONG,                       */                           \
                /*       it will only have it's lower 4 bits                         */                           \
                /*       equal to the color, the rest of them                        */                           \
                /*       will be 0. If they are not 0, we will                       */                           \
                /*       have garbage in XlatedByte, and will                        */                           \
                /*       have a faulty convertion.  We assume                        */                           \
                /*       that the macro function correctly, but                      */                           \
                /*       a defensive code would be:                                  */                           \
                /*  |= (BYTE) ( XLATEOBJ_iXlate(pxlo, *pulDmaRead++) & 0x0000000F)   */                           \
                                                                                                                  \
            *pjFinalDstWrite++ = XlatedByte; /* Write the byte in the dest region */                              \
        }                                                                                                         \
        else                                                                                                      \
        {                                                                                                         \
            /* Else there is a rest, we must modifie the LOW Nibble only */                                       \
                                                                                                                  \
            TempByte   = *pjFinalDstWrite;                                                                        \
            TempByte  &= 0xF0;            /* TempByte = DestSurfByte & Mask (clear the bits         */            \
                                          /*                                 we are going to mod.)  */            \
                                                                                                                  \
            XlatedByte = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* Translate source pixel     */        \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
            TempByte  |= XlatedByte;                                                                              \
                                                                                                                  \
            *pjFinalDstWrite++ = TempByte; /* Write back the left byte.    */                                     \
                                                                                                                  \
        }                                                                                                         \
                                                                                                                  \
        /*************************/                                                                               \
        /* Do the Middle byte(s) */                                                                               \
        /*************************/                                                                               \
                                                         /* Reminder of ptr arythmetics (if ptr is ULONG*): */    \
        for(limit = (BYTE*)( pxxDmaRead + middleWidth);  /* limit = the ptr + width*4 bytes/pixel           */    \
            (BYTE*) pxxDmaRead < limit;                                                                           \
            pjFinalDstWrite++ )                                                                                   \
        {                                                                                                         \
            XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo,*pxxDmaRead);                                        \
            pxxDmaRead++;                                                                                         \
            XlatedByte <<= 4;                                                                                     \
            XlatedByte  |= (BYTE) NV_XLATEOBJ_IXLATE(pxlo,*pxxDmaRead);                                        \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
            *pjFinalDstWrite = XlatedByte;                                                                        \
        }                                                                                                         \
                                                                                                                  \
        /*************************/                                                                               \
        /* Do the Right byte     */                                                                               \
        /*************************/                                                                               \
                                                                                                                  \
        if( rightRest != 0 ) /* there is a rest */                                                                \
        {                                                                                                         \
            /* Modifie the HIGH NIBBLE of the right byte (the LOW one, corresponding to  */                       \
            /* the coordinate, is exclusive)                                             */                       \
                                                                                                                  \
            TempByte   = *pjFinalDstWrite;                                                                        \
            TempByte  &= 0x0F;             /* TempByte = DestSurfByte & Mask (clear the bits          */          \
                                           /*                                 we are going to mod.)   */          \
                                                                                                                  \
            XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead);  /* Translate source pixel    */      \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
            XlatedByte <<= 4;             /* Place the pixel in the high nibble (filling in zeros     */          \
                                          /* in the low nibble so we don't modifie the low nibble     */          \
                                          /* when ORing next)                                         */          \
                                                                                                                  \
            TempByte |= XlatedByte;       /* Combine the translated pixel to the pixel we don't */                \
                                          /* want to modifie                                    */                \
                                                                                                                  \
            *pjFinalDstWrite++ = TempByte;   /* Write back the right byte. */                                     \
                                                                                                                  \
                                                                                                                  \
        }                                                                                                         \
        else                                                                                                      \
        {                                                                                                         \
            /* Else, we do a full byte: Indeed, in our calculation for "middleWidth", middleWidth = number of */  \
            /* FULL bytes AFTER the left byte (containing the right coordinate) minus 1.  Thus, if the scan-  */  \
            /* line ends with a FULL byte to modifie (rightRest = 0), this full byte is not included in the   */  \
            /* "middleWidth" and is considered the right byte (so if there's only 2 bytes, all in all, in the */  \
            /* scanline, even if they are full, they are considered the "left and right bytes"                */  \
            /*                                                                                                */  \
            /* ALSO, we might think "what if the byte previous (left) to the one containing the right coordi- */  \
            /* nate, is not one full byte ?" Well, the only way this can happen is to have the computation    */  \
            /* of "middleWidth" to be -1  (see in the code ScreenToMem?bpp), and we handle those cases with   */  \
            /* a different function (yes, it could be the same, like in ScreenTo1Bpp, but it is faster to do  */  \
            /* this a different way, because we do not convert a bunch of pixels for nothing                  */  \
                                                                                                                  \
            XlatedByte       = (BYTE) NV_XLATEOBJ_IXLATE(pxlo,*pxxDmaRead);                                    \
            pxxDmaRead++;                                                                                         \
            XlatedByte     <<= 4;                                                                                 \
            XlatedByte      |= (BYTE) NV_XLATEOBJ_IXLATE(pxlo,*pxxDmaRead);                                    \
            pxxDmaRead++;                                                                                         \
            *pjFinalDstWrite++ = XlatedByte;                                                                      \
                                                                                                                  \
        }                                                                                                         \
                                                                                                                  \
        pjFinalDstWrite += FinalDstJump2NextLineBeg;  /* Switch to beginning of the    */                         \
                                                      /* next line in the dest surface */                         \
    } /* ...for all bytes in chunk to cpu-xfer  */                                                                \
                                                                                                                  \
}                                                                                                                 \
/******************************** End of CpuXferTo4bpp(pxxDmaRead,linesPerXfer) **********************************/


#define CpuXferTo4bpp_1ByteWidth(pxxDmaRead,linesPerXfer)                                                         \
{                                                                                                                 \
    /* Xfer all lines    */                                                                                       \
    /*                   */                                                                                       \
    for(j=0; j < linesPerXfer; j++)                                                                               \
    {                                                                                                             \
        /*************************/                                                                               \
        /* Do the Left byte      */                                                                               \
        /*************************/                                                                               \
                                                                                                                  \
        if ( leftRest == 0 )  /* There is no rest */                                                              \
        {                                                                                                         \
            if ( rightRest == 0 )   /* AND the right coord. has no rest (even). We have 2 pixels */               \
            {                                                                                                     \
                XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead);  /* xlate first pixel */          \
                pxxDmaRead++;                                                                                     \
                                                                                                                  \
                XlatedByte <<= 4;     /* place the nibble in the MS Nibble */                                     \
                                                                                                                  \
                XlatedByte  |= (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead);/* xlate & combine second pixel */ \
                pxxDmaRead++;                                                                                     \
                                                                                                                  \
                *pjFinalDstWrite++ = XlatedByte;  /* Write the byte in the dest region */                         \
            }                                                                                                     \
            else                                                                                                  \
            {                                                                                                     \
                /* Else just do the high nibble */                                                                \
                                                                                                                  \
                TempByte   = *pjFinalDstWrite;                                                                    \
                TempByte  &= 0x0F;             /* TempByte = DestSurfByte & Mask (clear the bits        */        \
                                               /*                                 we are going to mod.) */        \
                                                                                                                  \
                XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* Translate source pixel   */    \
                pxxDmaRead++;                                                                                     \
                                                                                                                  \
                XlatedByte <<= 4;              /* Place the pixel in the high nibble (filling in zeros  */        \
                                               /* in the low nibble so we don't modifie the low nibble  */        \
                                               /* when ORing next)                                      */        \
                                                                                                                  \
                TempByte |= XlatedByte;        /* Combine the translated pixel to the pixel we don't    */        \
                                               /* want to modifie                                       */        \
                                                                                                                  \
                *pjFinalDstWrite++ = TempByte;  /* Write back the right byte.                           */        \
                                                                                                                  \
            }                                                                                                     \
        }                                                                                                         \
        else                                                                                                      \
        {                                                                                                         \
            /* Else there is a rest, we must modifie the LOW Nibble only and we are finished!    */               \
                                                                                                                  \
            TempByte   = *pjFinalDstWrite;                                                                        \
            TempByte  &= 0xF0;             /* TempByte = DestSurfByte & Mask (clear the bits            */        \
                                           /*                                 we are going to mod.)     */        \
                                                                                                                  \
            XlatedByte = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead);   /* Translate source pixel       */    \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
            TempByte  |= XlatedByte;                                                                              \
                                                                                                                  \
            *pjFinalDstWrite++ = TempByte;   /* Write back the left byte. */                                      \
                                                                                                                  \
        }                                                                                                         \
                                                                                                                  \
                                                                                                                  \
        pjFinalDstWrite += FinalDstJump2NextLineBeg;   /* Switch to beginning of the              */              \
                                                       /* next line in the dest surface           */              \
    } /* ...for all bytes in chunk to cpu-xfer */                                                                 \
}                                                                                                                 \
/**************************** End of CpuXferTo4bpp_1ByteWidth(pxxDmaRead,linesPerXfer) ***************************/


#define CpuXferTo8bpp(pxxDmaRead,linesPerXfer)                                                                    \
{                                                                                                                 \
    for(j=0; j < linesPerXfer; j++)                                                                               \
    {                                                                                                             \
        /* Xfer a whole line */                                                                                   \
        /*                   */                                                                                   \
                                                         /* Reminder of ptr arythmetics (if ptr is ULONG*): */    \
        for(limit = (BYTE*)( pxxDmaRead + width);        /* limit = the ptr + width*4 bytes/pixel           */    \
            (BYTE*) pxxDmaRead < limit;                                                                           \
            pxxDmaRead++, pjFinalDstWrite++ )                                                                     \
        {                                                                                                         \
            *pjFinalDstWrite = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* Translate source pixel & write */ \
        }                                                                                                         \
                                                                                                                  \
        pjFinalDstWrite += FinalDstJump2NextLineBeg;    /* Switch to beginning of the    */                       \
                                                        /* next line in the dest surface */                       \
                                                                                                                  \
    } /* ...for all bytes in chunk to cpu-xfer */                                                                 \
}                                                                                                                 \
/****************************** End of CpuXferTo8bpp(pxxDmaRead,linesPerXfer) ************************************/





#define ScreenToMem4bpp(pxxDmaRead,cast)                                                                          \
{                                                                                                                 \
    /***************************************************************************/                                 \
    /*  Transfer all rectangles regions in the array                           */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    for(i=0; i < c; i++) /* For all rectangles */                                                                 \
    {                                                                                                             \
                                                                                                                  \
        /* Calculate the number of full bytes we have per scanline              */                                \
        /* (this will need to be clamped to 0 if it is negative; we do that     */                                \
        /*  later because this value will make us decide which function         */                                \
        /*  we use in case the destination is 4Bpp)                             */                                \
                                                                                                                  \
        /*  Explanation for this formula: the right coordinate is exclusive, so we substract 1,    */             \
        /*  and clamp it to the lowest multiple of 2. We clamp the left coordinate to the lowest   */             \
        /*  multiple of 2 also.  (This is because we have 2 pixel / bytes when the dest is 4BPP)   */             \
        /*  (We only use this "middleWidth" when dest is 4 BPP.) We substract both of them, and    */             \
        /*  -1 also, because we want 0 => when there is a left byte and a right byte (2 byte that  */             \
        /*  contains the pixels), -1 when the width is at most 1 byte (the pixel(s) of one         */             \
        /*  scanline are in a single byte), and else, "middleWidth" gives us the number of bytes   */             \
        /*  taking aside the first byte we process and the last one. We multiply by 2 the whole    */             \
        /*  formula ( << 1 at the end) because we want middleWidth in NUMBER OF PIXELS.            */             \
                                                                                                                  \
        middleWidth = ( ((parcl[i].right - 1) >> 1) - (parcl[i].left >> 1) - 1 ) << 1 ;                           \
                                                                                                                  \
        /* Calculate the rest of the left and right coordinates (this is out of ScreenToMemXbpp_Common */         \
        /* because for 8bpp destination, we don't need this )                                          */         \
                                                                                                                  \
        leftRest  = (BYTE)( parcl[i].left & 1 );        /* leftRest = 1 if left coordinate is odd  */             \
        rightRest = (BYTE)( parcl[i].right & 1 );                                                                 \
                                                                                                                  \
        ScreenToMemXbpp_Common;    /* This is the beginning of the Xfer loop (for all rectangles) common */       \
                                   /* to all ScreenToMemXbpp functions.                                  */       \
                                   /* In this macro, we setup the linesPerXfer, and all variables needed */       \
                                   /* after this point in the for(all rectangles) (dma offsets, read/    */       \
                                   /* write ptr addresses, ... )                                         */       \
                                                                                                                  \
        /* Now we must chose the core routine for our ScreenToMem4bpp blit:     */                                \
                                                                                                                  \
        if(middleWidth < 0)                                                                                       \
        {                                                                                                         \
            /*middleWidth = 0;   No need to, in CpuXferTo4bpp_1ByteWidth, we don't use it  */                     \
            ScreenToMem4bpp_Core_1ByteWidth(pxxDmaRead, cast);                                                    \
        }                                                                                                         \
        else ScreenToMem4bpp_Core(pxxDmaRead, cast);                                                              \
                                                                                                                  \
    } /* ...for(i=0; i < c; i++)  For all rectangles  */                                                          \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/********************************** End of ScreenToMem4bpp(pxxDmaRead,cast) **************************************/





//
// Usage: ScreenToMem4bpp_Core( pjDmaread, (BYTE*))
//

    
#define ScreenToMem4bpp_Core(pxxDmaRead,cast)                                                                     \
{                                                                                                                 \
                                                                                                                  \
                                                                                                                  \
        /***************************************************************************    */                        \
        /* Calculate the pointer to the upper-left corner of Destination clipped region */                        \
        /* (THE FINAL DESTINATION, not the MEM2MEM buffer)                              */                        \
        /***************************************************************************    */                        \
                                                                                                                  \
        pjFinalDstWrite =  (BYTE*) psoDst->pvScan0                                                                \
                          + ( parcl[i].top  * lDstPitch )                                                         \
                          + ( parcl[i].left >> 1 );                                                               \
                                                                                                                  \
                                                                                                                  \
        /* Calculate the jump to get to the next line of the             */                                       \
        /* final destination rectangle (in the final Dst surface)        */                                       \
        /* AFTER having transfered "bytesPerLine" (in other words,       */                                       \
        /* pitch is the num of bytes to the jump AT THE SAME POSITION    */                                       \
        /* in the bitmap but one line lower; what we want is the jump    */                                       \
        /* value to jump from the end of a line TO THE BEGINNING         */                                       \
        /* of the next line )                                            */                                       \
        /*                                                               */                                       \
        /* We add 1 to width so that we round to the upper multiple      */                                       \
        /* of 2 (we have 2 pixels per byte, and the scanline must be     */                                       \
        /* of at least 1 byte wide even if it is 1 pixel wide only...    */                                       \
                                                                                                                  \
        FinalDstJump2NextLineBeg = lDstPitch - ((width+1) >> 1);                                                  \
                                                                                                                  \
                                                                                                                  \
        /* Do the rest of the loop (all the core of the xfer/convertion  */                                       \
                                                                                                                  \
                                                                                                                  \
        ScreenToMemXbpp_Common2(pxxDmaRead, cast,CpuXferTo4bpp);                                                  \
                                                                                                                  \
}                                                                                                                 \
/****************************** End of ScreenToMem4bpp_Core(pxxDmaRead,cast) *************************************/




#define ScreenToMem4bpp_Core_1ByteWidth(pxxDmaRead,cast)                                                          \
{                                                                                                                 \
                                                                                                                  \
                                                                                                                  \
        /***************************************************************************    */                        \
        /* Calculate the pointer to the upper-left corner of Destination clipped region */                        \
        /* (THE FINAL DESTINATION, not the MEM2MEM buffer)                              */                        \
        /***************************************************************************    */                        \
                                                                                                                  \
        pjFinalDstWrite =  (BYTE*) psoDst->pvScan0                                                                \
                          + ( parcl[i].top  * lDstPitch )                                                         \
                          + ( parcl[i].left >> 1 );                                                               \
                                                                                                                  \
                                                                                                                  \
        /* Calculate the jump to get to the next line of the             */                                       \
        /* final destination rectangle (in the final Dst surface)        */                                       \
        /* AFTER having transfered "bytesPerLine" (in other words,       */                                       \
        /* pitch is the num of bytes to the jump AT THE SAME POSITION    */                                       \
        /* in the bitmap but one line lower; what we want is the jump    */                                       \
        /* value to jump from the end of a line TO THE BEGINNING         */                                       \
        /* of the next line )                                            */                                       \
        /*                                                               */                                       \
        /* We add 1 to width so that we round to the upper multiple      */                                       \
        /* of 2 (we have 2 pixels per byte, and the scanline must be     */                                       \
        /* of at least 1 byte wide even if it is 1 pixel wide only...    */                                       \
                                                                                                                  \
        FinalDstJump2NextLineBeg = lDstPitch - 1;                                                                 \
                                                                                                                  \
        /* Do the rest of the loop (all the core of the xfer/convertion  */                                       \
                                                                                                                  \
        ScreenToMemXbpp_Common2(pxxDmaRead, cast, CpuXferTo4bpp_1ByteWidth);                                      \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/*************************** End of ScreenToMem4bpp_Core_1ByteWidth(pxxDmaRead,cast) *****************************/






#define ScreenToMem8bpp(pxxDmaRead,cast)                                                                          \
{                                                                                                                 \
    /***************************************************************************/                                 \
    /*  Transfer all rectangles regions in the array                           */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    for(i=0; i < c; i++) /* For all rectangles */                                                                 \
    {                                                                                                             \
                                                                                                                  \
        ScreenToMemXbpp_Common;    /* This is the beginning of the Xfer loop (for all rectangles) common */       \
                                   /* to all ScreenToMemXbpp functions.                                  */       \
                                   /* In this macro, we setup the linesPerXfer, and all variables needed */       \
                                   /* after this point in the for(all rectangles) (dma offsets, read/    */       \
                                   /* write ptr addresses, ... )                                         */       \
                                                                                                                  \
                                                                                                                  \
        /***************************************************************************    */                        \
        /* Calculate the pointer to the upper-left corner of Destination clipped region */                        \
        /* (THE FINAL DESTINATION, not the MEM2MEM buffer)                              */                        \
        /***************************************************************************    */                        \
                                                                                                                  \
        pjFinalDstWrite =  (BYTE*) psoDst->pvScan0                                                                \
                          + ( parcl[i].top  * lDstPitch )                                                         \
                          + ( parcl[i].left );                                                                    \
                                                                                                                  \
                                                                                                                  \
        /* Calculate the jump to get to the next line of the             */                                       \
        /* final destination rectangle (in the final Dst surface)        */                                       \
        /* AFTER having transfered "bytesPerLine" (in other words,       */                                       \
        /* pitch is the num of bytes to the jump AT THE SAME POSITION    */                                       \
        /* in the bitmap but one line lower; what we want is the jump    */                                       \
        /* value to jump from the end of a line TO THE BEGINNING         */                                       \
        /* of the next line )                                            */                                       \
        /*                                                               */                                       \
        /* (We use width directly because if we are here, we know        */                                       \
        /*  we have 8bpp in the destination, 1 byte per pixel...)        */                                       \
                                                                                                                  \
        FinalDstJump2NextLineBeg = lDstPitch - width;                                                             \
                                                                                                                  \
        /* Do the rest of the loop (all the core of the xfer/convertion  */                                       \
                                                                                                                  \
        ScreenToMemXbpp_Common2(pxxDmaRead, cast, CpuXferTo8bpp);                                                 \
                                                                                                                  \
    } /* ...for(i=0; i < c; i++)  For all rectangles  */                                                          \
                                                                                                                  \
}                                                                                                                 \
/********************************** End of ScreenToMem8bpp(pxxDmaRead,cast) **************************************/
    
    



BOOL NV4ScreenToMem32to4bppBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;           // Total number of lines left to Xfer

    ULONG           bytes2Xfer;          // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;        // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;     // Optimal bytes per Xfer (calculated based on mathematic model 
                                         // and profiling data, see notes)
    ULONG           linesPerXfer;        // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;    // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;    // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;           // Pitch of the source surface
    
    LONG            lDstPitch;           // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;           // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;        // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;     // Pointer to the beg. of the dest. bits (in the final surface)
                                         // (will also be incremented to advance in the destination bits during xfer)
    
    ULONG*          pulDmaRead;          // Pointer in the mem2mem dma buffer that we are going to use in the
                                         // CPU-Xfers to keep track of where we are currently reading 
    
    //USHORT*         psDmaRead;
    //BYTE*           pjDmaRead;
    
    BYTE            XlatedByte, TempByte;

    ULONG*          pulDmaRead_lastXfer; // Var to hold where to read the last CPU-Xfer

    ULONG*          pulDmaRead_start;    // Start of the Mem2Mem buffer

    ULONG*          pulDmaRead_2ndPart;  // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;        // Left top corner of current clipped region/rectangle in Src surface
                                         // to xfer
    
    ULONG           DstDMAOffset;        // Offset (relative to DMA base)
                                         // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;        // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset; // Offset of the 2nd part of the Mem2Mem buffer
       
    BYTE            leftRest, rightRest; // Rest of ( %(modulo) 2 ) of the left and right coordinates 

    LONG            middleWidth;         // Number of bytes to process with the "middle" loop (when Dest == 4 bpp)
    
    NvNotification* pNotifier;           // Pointer to MemToMem notifier array
    NV_XLATE_INIT                        // Initialize cached xlate values
    DECLARE_DMA_FIFO;                    // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
                                          

    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
                
    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMem32to4bppBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL destination rectangle supplied !" );

    ASSERTDD( (psoDst->iBitmapFormat == BMF_4BPP),
              "NV4ScreenToMem32to4bppBlt: Dst bitmap format must be 4bpp" );

    ASSERTDD( (psoSrc->iBitmapFormat == BMF_32BPP),
              "NV4ScreenToMem32to4bppBlt: Src bitmap format must be 32bpp" );

    ASSERTDD( pxlo != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL translation object");

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG is not defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMem32to4bppBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pulDmaRead_start   = (ULONG *)( ppdev->pMemToMemBuffer  );
    pulDmaRead_2ndPart = (ULONG *)( (BYTE*)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1) );
            

    /***********************************************************************/
    /*                                                                     */
    /*  We are ready to start the transfer                                 */
    /*                                                                     */
    /***********************************************************************/
    
    pulDmaRead = pulDmaRead_start;

    ScreenToMem4bpp(pulDmaRead, (ULONG*));
    
    return TRUE;
}
            

BOOL NV4ScreenToMem32to8bppBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;           // Total number of lines left to Xfer

    ULONG           bytes2Xfer;          // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;        // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;     // Optimal bytes per Xfer (calculated based on mathematic model 
                                         // and profiling data, see notes)
    ULONG           linesPerXfer;        // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;    // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;    // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;           // Pitch of the source surface
    
    LONG            lDstPitch;           // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;           // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;        // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;     // Pointer to the beg. of the dest. bits (in the final surface)
                                         // (will also be incremented to advance in the destination bits during xfer)
    
    ULONG*          pulDmaRead;          // Pointer in the mem2mem dma buffer that we are going to use in the
                                         // CPU-Xfers to keep track of where we are currently reading 
    
    //USHORT*         psDmaRead;
    //BYTE*           pjDmaRead;
    
    BYTE            XlatedByte, TempByte;

    ULONG*          pulDmaRead_lastXfer; // Var to hold where to read the last CPU-Xfer

    ULONG*          pulDmaRead_start;    // Start of the Mem2Mem buffer

    ULONG*          pulDmaRead_2ndPart;  // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;        // Left top corner of current clipped region/rectangle in Src surface
                                         // to xfer
    
    ULONG           DstDMAOffset;        // Offset (relative to DMA base)
                                         // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;        // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset; // Offset of the 2nd part of the Mem2Mem buffer
       
    BYTE            leftRest, rightRest; // Rest of ( %(modulo) 2 ) of the left and right coordinates 

    LONG            middleWidth;         // Number of bytes to process with the "middle" loop (when Dest == 4 bpp)
    
    NvNotification* pNotifier;           // Pointer to MemToMem notifier array
    NV_XLATE_INIT                        // Initialize cached xlate values
    DECLARE_DMA_FIFO;                    // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)

    DISPDBG((9, "S32M8: %d (%d*%d) %s src:%s %s (%d,%d), dst:%s %s (%d,%d %d*%d)",
        c, parcl->right-parcl->left,parcl->bottom-parcl->top,
        pxlo?szDbg_XLATEOBJflXlate(pxlo->flXlate):"XO_trivial",
        psoSrc?szDbg_SURFOBJiBitmapFormat(psoSrc->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoSrc), pptlSrc->x, pptlSrc->y, 
        psoDst?szDbg_SURFOBJiBitmapFormat(psoDst->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoDst), prclDst->left, prclDst->top, prclDst->right-prclDst->left, prclDst->bottom-prclDst->top
        ));


    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
                
    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMem32to8bppBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL destination rectangle supplied !" );

    ASSERTDD( (psoDst->iBitmapFormat == BMF_8BPP),
              "NV4ScreenToMem32to8bppBlt: Dst bitmap format must be 8bpp" );

    ASSERTDD( (psoSrc->iBitmapFormat == BMF_32BPP),
              "NV4ScreenToMem32to8bppBlt: Src bitmap format must be 32bpp" );

    ASSERTDD( pxlo != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL translation object");

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG is not defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMem32to8bppBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pulDmaRead_start   = (ULONG *)( ppdev->pMemToMemBuffer  );
    pulDmaRead_2ndPart = (ULONG *)( (BYTE*)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1) );
            

    /***********************************************************************/
    /*                                                                     */
    /*  We are ready to start the transfer                                 */
    /*                                                                     */
    /***********************************************************************/
    
    pulDmaRead = pulDmaRead_start;

    ScreenToMem8bpp(pulDmaRead, (ULONG*));
    
    return TRUE;
}



BOOL NV4ScreenToMem16to4bppBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;           // Total number of lines left to Xfer

    ULONG           bytes2Xfer;          // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;        // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;     // Optimal bytes per Xfer (calculated based on mathematic model 
                                         // and profiling data, see notes)
    ULONG           linesPerXfer;        // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;    // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;    // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;           // Pitch of the source surface
    
    LONG            lDstPitch;           // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;            // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;         // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;      // Pointer to the beg. of the dest. bits (in the final surface)
                                          // (will also be incremented to advance in the destination bits during xfer)
    
    //ULONG*          pulDmaRead;         // Pointer in the mem2mem dma buffer that we are going to use in the
                                          // CPU-Xfers to keep track of where we are currently reading 
    
    USHORT*         psDmaRead;
    //BYTE*           pjDmaRead;
    
    BYTE            XlatedByte, TempByte;

    ULONG*          pulDmaRead_lastXfer; // Var to hold where to read the last CPU-Xfer

    ULONG*          pulDmaRead_start;    // Start of the Mem2Mem buffer

    ULONG*          pulDmaRead_2ndPart;  // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;        // Left top corner of current clipped region/rectangle in Src surface
                                         // to xfer
    
    ULONG           DstDMAOffset;        // Offset (relative to DMA base)
                                         // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;        // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset; // Offset of the 2nd part of the Mem2Mem buffer
       
    BYTE            leftRest, rightRest; // Rest of ( %(modulo) 2 ) of the left and right coordinates 

    LONG            middleWidth;         // Number of bytes to process with the "middle" loop (when Dest == 4 bpp)
    
    NV_XLATE_INIT                        // Initialize cached xlate values
    NvNotification* pNotifier;           // Pointer to MemToMem notifier array
    DECLARE_DMA_FIFO;                    // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
                                          

    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMem16to4bppBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL destination rectangle supplied !" );

    ASSERTDD( (psoDst->iBitmapFormat == BMF_4BPP),
              "NV4ScreenToMem16to4bppBlt: Dst bitmap format must be 4bpp" );

    ASSERTDD( (psoSrc->iBitmapFormat == BMF_16BPP),
              "NV4ScreenToMem16to4bppBlt: Src bitmap format must be 16bpp" );

    ASSERTDD( pxlo != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL translation object");

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG is not defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMem16to4bppBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pulDmaRead_start   = (ULONG *)( ppdev->pMemToMemBuffer  );
    pulDmaRead_2ndPart = (ULONG *)( (BYTE*)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1) );
            

    /***********************************************************************/
    /*                                                                     */
    /*  We are ready to start the transfer                                 */
    /*                                                                     */
    /***********************************************************************/
    
    psDmaRead = (USHORT*) pulDmaRead_start;

    ScreenToMem4b