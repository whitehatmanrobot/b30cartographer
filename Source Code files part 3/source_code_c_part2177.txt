 << 2)
#define D3DVIS_INSIDE_RIGHT         0
#define D3DVIS_INTERSECT_RIGHT      (1 << 4)
#define D3DVIS_OUTSIDE_RIGHT        (2 << 4)
#define D3DVIS_INSIDE_TOP           0
#define D3DVIS_INTERSECT_TOP        (1 << 6)
#define D3DVIS_OUTSIDE_TOP          (2 << 6)
#define D3DVIS_INSIDE_BOTTOM        0
#define D3DVIS_INTERSECT_BOTTOM     (1 << 8)
#define D3DVIS_OUTSIDE_BOTTOM       (2 << 8)
#define D3DVIS_INSIDE_NEAR          0
#define D3DVIS_INTERSECT_NEAR       (1 << 10)
#define D3DVIS_OUTSIDE_NEAR         (2 << 10)
#define D3DVIS_INSIDE_FAR           0
#define D3DVIS_INTERSECT_FAR        (1 << 12)
#define D3DVIS_OUTSIDE_FAR          (2 << 12)

#define D3DVIS_MASK_FRUSTUM         (3 << 0)
#define D3DVIS_MASK_LEFT            (3 << 2)
#define D3DVIS_MASK_RIGHT           (3 << 4)
#define D3DVIS_MASK_TOP             (3 << 6)
#define D3DVIS_MASK_BOTTOM          (3 << 8)
#define D3DVIS_MASK_NEAR            (3 << 10)
#define D3DVIS_MASK_FAR             (3 << 12)

#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION < 0x0800)

#if(DIRECT3D_VERSION >= 0x0700)

// To be used with GetInfo()
#define D3DDEVINFOID_TEXTUREMANAGER    1
#define D3DDEVINFOID_D3DTEXTUREMANAGER 2
#define D3DDEVINFOID_TEXTURING         3

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0xffffffff
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRENDERSTATE_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBLEND_DISABLE  = 0, // Disable vertex blending
    D3DVBLEND_1WEIGHT  = 1, // blend between 2 matrices
    D3DVBLEND_2WEIGHTS = 2, // blend between 3 matrices
    D3DVBLEND_3WEIGHTS = 3, // blend between 4 matrices
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS {
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


#endif /* DIRECT3D_VERSION >= 0x0700 */

#else
//
// legacy vertex blend names
//
typedef enum _D3DVERTEXBLENDFLAGS D3DVERTEXBLENDFLAGS;
#define D3DVBLEND_DISABLE  (D3DVERTEXBLENDFLAGS)0
#define D3DVBLEND_1WEIGHT  (D3DVERTEXBLENDFLAGS)1
#define D3DVBLEND_2WEIGHTS (D3DVERTEXBLENDFLAGS)2
#define D3DVBLEND_3WEIGHTS (D3DVERTEXBLENDFLAGS)3

#endif //(DIRECT3D_VERSION < 0x0800)

#pragma pack()
#pragma warning(default:4201)

#endif /* _D3DTYPES_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\d3dkmthk.h ===
/******************************Module*Header**********************************\
*
* Module Name: d3dkmthk.h
*
* Content: longhorn display driver model kernel mode thunk interfaces
*
* Copyright (c) 2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef _D3DKMTHK_H_
#define _D3DKMTHK_H_
#include <d3dukmdt.h>

typedef struct _D3DKMT_CREATEDEVICEFLAGS
{
    UINT    LegacyMode   :  1;   // 0x00000001
    UINT    RequestVSync :  1;   // 0x00000002
    UINT    Reserved     : 30;   // 0xFFFFFFFC
} D3DKMT_CREATEDEVICEFLAGS;

typedef struct _D3DKMT_CREATEDEVICE
{
    union
    {
        D3DKMT_HANDLE           hAdapter;           // in: identifies the adapter for user-mode creation
        VOID*                   pAdapter;           // in: identifies the adapter for kernel-mode creation
    };

    D3DKMT_CREATEDEVICEFLAGS    Flags;

    D3DKMT_HANDLE               hDevice;                // out: Indentifies the device
    VOID*                       pCommandBuffer;         // out: D3D10 compatibility.
    UINT                        CommandBufferSize;      // out: D3D10 compatibility.
    D3DDDI_ALLOCATIONLIST*      pAllocationList;        // out: D3D10 compatibility.
    UINT                        AllocationListSize;     // out: D3D10 compatibility.
    D3DDDI_PATCHLOCATIONLIST*   pPatchLocationList;     // out: D3D10 compatibility.
    UINT                        PatchLocationListSize;  // out: D3D10 compatibility.
} D3DKMT_CREATEDEVICE;

typedef struct _D3DKMT_DESTROYDEVICE
{
    D3DKMT_HANDLE     hDevice;              // in: Indentifies the device
}D3DKMT_DESTROYDEVICE;

typedef enum _D3DKMT_CLIENTHINT
{
    D3DKMT_CLIENTHINT_UNKNOWN     = 0,
    D3DKMT_CLIENTHINT_OPENGL      = 1,
    D3DKMT_CLIENTHINT_CDD         = 2,       // Internal   ;internal
    D3DKMT_CLIENTHINT_DX7         = 7,
    D3DKMT_CLIENTHINT_DX8         = 8,
    D3DKMT_CLIENTHINT_DX9         = 9,
    D3DKMT_CLIENTHINT_DX10        = 10,
} D3DKMT_CLIENTHINT;

typedef struct _D3DKMT_CREATECONTEXT
{
    D3DKMT_HANDLE               hDevice;                    // in:  Handle to the device owning this context.
    UINT                        NodeOrdinal;                // in:  Identifier for the node targetted by this context.
    UINT                        EngineAffinity;             // in:  Engine affinity within the specified node.
    D3DDDI_CREATECONTEXTFLAGS   Flags;                      // in:  Context creation flags.
    VOID*                       pPrivateDriverData;         // in:  Private driver data
    UINT                        PrivateDriverDataSize;      // in:  Size of private driver data
    D3DKMT_CLIENTHINT           ClientHint;                 // in:  Hints which client is creating this
    D3DKMT_HANDLE               hContext;                   // out: Handle of the created context.
    VOID*                       pCommandBuffer;             // out: Pointer to the first command buffer.
    UINT                        CommandBufferSize;          // out: Command buffer size (bytes).
    D3DDDI_ALLOCATIONLIST*      pAllocationList;            // out: Pointer to the first allocation list.
    UINT                        AllocationListSize;         // out: Allocation list size (elements).
    D3DDDI_PATCHLOCATIONLIST*   pPatchLocationList;         // out: Pointer to the first patch location list.
    UINT                        PatchLocationListSize;      // out: Patch location list size (elements).
} D3DKMT_CREATECONTEXT;

typedef struct _D3DKMT_DESTROYCONTEXT
{
    D3DKMT_HANDLE               hContext;                   // in:  Identifies the context being destroyed.
} D3DKMT_DESTROYCONTEXT;

typedef struct _D3DKMT_CREATESYNCHRONIZATIONOBJECT
{
    D3DKMT_HANDLE                           hDevice;                    // in:  Handle to the device.
    D3DDDI_SYNCHRONIZATIONOBJECTINFO        Info;                       // in:  Attributes of the synchronization object.
    D3DKMT_HANDLE                           hSyncObject;                // out: Handle to the synchronization object created.
} D3DKMT_CREATESYNCHRONIZATIONOBJECT;

typedef struct _D3DKMT_DESTROYSYNCHRONIZATIONOBJECT
{
    D3DKMT_HANDLE               hSyncObject;                // in:  Identifies the synchronization objects being destroyed.
} D3DKMT_DESTROYSYNCHRONIZATIONOBJECT;

typedef struct _D3DKMT_WAITFORSYNCHRONIZATIONOBJECT
{
    D3DKMT_HANDLE               hContext;                   // in: Identifies the context that needs to wait.
    UINT                        ObjectCount;                // in: Specifies the number of object to wait on.
    D3DKMT_HANDLE               ObjectHandleArray[D3DDDI_MAX_OBJECT_WAITED_ON]; // in: Specifies the object to wait on.
} D3DKMT_WAITFORSYNCHRONIZATIONOBJECT;

typedef struct _D3DKMT_SIGNALSYNCHRONIZATIONOBJECT
{
    D3DKMT_HANDLE               hContext;                                       // in: Identifies the context that needs to signal.
    UINT                        ObjectCount;                                    // in: Specifies the number of object to signal.
    D3DKMT_HANDLE               ObjectHandleArray[D3DDDI_MAX_OBJECT_SIGNALED];  // in: Specifies the object to be signaled.
    D3DDDICB_SIGNALFLAGS        Flags;                                          // in: Specifies signal behavior.
} D3DKMT_SIGNALSYNCHRONIZATIONOBJECT;

typedef struct _D3DKMT_LOCK
{
    D3DKMT_HANDLE       hDevice;            // in: identifies the device
    D3DKMT_HANDLE       hAllocation;        // in: allocation to lock
                                            // out: New handle representing the allocation after the lock.
    UINT                PrivateDriverData;  // in: Used by UMD for AcquireAperture
    UINT                NumPages;
    CONST UINT*         pPages;
    VOID*               pData;              // out: pointer to memory
    D3DDDICB_LOCKFLAGS  Flags;              // in: Bit field defined by D3DDDI_LOCKFLAGS
} D3DKMT_LOCK;

typedef struct _D3DKMT_UNLOCK
{
    D3DKMT_HANDLE           hDevice;        // in: Identifies the device
    UINT                    NumAllocations; // in: Number of allocations in the array
    CONST D3DKMT_HANDLE*    phAllocations;  // in: array of allocations to unlock
} D3DKMT_UNLOCK;


typedef enum _D3DKMDT_MODE_PRUNING_REASON
{
    D3DKMDT_MPR_UNINITIALIZED                               = 0, // mode was pruned or is supported because of:
    D3DKMDT_MPR_ALLCAPS                                     = 1, //   all of the monitor caps (only used to imply lack of support - for support, specific reason is always indicated)
    D3DKMDT_MPR_DESCRIPTOR_MONITOR_SOURCE_MODE              = 2, //   monitor source mode in the monitor descriptor
    D3DKMDT_MPR_DESCRIPTOR_MONITOR_FREQUENCY_RANGE          = 3, //   monitor frequency range in the monitor descriptor
    D3DKMDT_MPR_DESCRIPTOR_OVERRIDE_MONITOR_SOURCE_MODE     = 4, //   monitor source mode in the monitor descriptor override
    D3DKMDT_MPR_DESCRIPTOR_OVERRIDE_MONITOR_FREQUENCY_RANGE = 5, //   monitor frequency range in the monitor descriptor override
    D3DKMDT_MPR_DEFAULT_PROFILE_MONITOR_SOURCE_MODE         = 6, //   monitor source mode in the default monitor profile
    D3DKMDT_MPR_DRIVER_RECOMMENDED_MONITOR_SOURCE_MODE      = 7, //   monitor source mode recommended by the driver
    D3DKMDT_MPR_MONITOR_FREQUENCY_RANGE_OVERRIDE            = 8, //   monitor frequency range override
    D3DKMDT_MPR_MAXVALID                                    = 9
}
D3DKMDT_MODE_PRUNING_REASON;

typedef struct _D3DKMDT_DISPLAYMODE_FLAGS
{
    BOOLEAN                      ValidatedAgainstMonitorCaps : 1;
    BOOLEAN                      RoundedFakeMode             : 1;
    D3DKMDT_MODE_PRUNING_REASON  ModePruningReason           : 4;
    UINT                         Reserved                    : 26;
}
D3DKMDT_DISPLAYMODE_FLAGS;

typedef struct _D3DKMT_DISPLAYMODE
{
    UINT                                   Width;
    UINT                                   Height;
    D3DDDIFORMAT                           Format;
    UINT                                   IntegerRefreshRate;
    D3DDDI_RATIONAL                        RefreshRate;
    D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING  ScanLineOrdering;
    D3DDDI_ROTATION                        DisplayOrientation;
    UINT                                   DisplayFixedOutput;
    D3DKMDT_DISPLAYMODE_FLAGS              Flags;
} D3DKMT_DISPLAYMODE;

typedef struct _D3DKMT_GETDISPLAYMODELIST
{
    D3DKMT_HANDLE                   hAdapter;       // in: adapter handle
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;  // in: adapter's VidPN source ID
    D3DKMT_DISPLAYMODE*             pModeList;      // out:
    UINT                            ModeCount;      // in/out:
} D3DKMT_GETDISPLAYMODELIST;

typedef struct _D3DKMT_SETDISPLAYMODE
{
    D3DKMT_HANDLE                          hDevice;                         // in: Identifies the device
    D3DKMT_HANDLE                          hPrimaryAllocation;              // in:
    D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING  ScanLineOrdering;                // in:
    D3DDDI_ROTATION                        DisplayOrientation;              // in:
    UINT                                   PrivateDriverFormatAttribute;    // out: Private Format Attribute of the current primary surface if DxgkSetDisplayMode failed with STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT
} D3DKMT_SETDISPLAYMODE;

typedef struct _D3DKMT_MULTISAMPLEMETHOD
{
    UINT    NumSamples;
    UINT    NumQualityLevels;
    UINT    Reserved;   //workaround for NTRAID#Longhorn-1124385-2005/03/14-kanqiu
} D3DKMT_MULTISAMPLEMETHOD;

typedef struct _D3DKMT_GETMULTISAMPLEMETHODLIST
{
    D3DKMT_HANDLE                   hAdapter;       // in: adapter handle
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;  // in: adapter's VidPN source ID
    UINT                            Width;          // in:
    UINT                            Height;         // in:
    D3DDDIFORMAT                    Format;         // in:
    D3DKMT_MULTISAMPLEMETHOD*       pMethodList;    // out:
    UINT                            MethodCount;    // in/out:
} D3DKMT_GETMULTISAMPLEMETHODLIST;

typedef struct _D3DKMT_PRESENTFLAGS
{
    union
    {
        struct
        {
            UINT    Blt                 : 1;        // 0x00000001
            UINT    ColorFill           : 1;        // 0x00000002
            UINT    Flip                : 1;        // 0x00000004
            UINT    FlipDoNotFlip       : 1;        // 0x00000008
            UINT    FlipDoNotWait       : 1;        // 0x00000010
            UINT    FlipRestart         : 1;        // 0x00000020
            UINT    DstRectValid        : 1;        // 0x00000040
            UINT    SrcRectValid        : 1;        // 0x00000080
            UINT    RestrictVidPnSource : 1;        // 0x00000100
            UINT    SrcColorKey         : 1;        // 0x00000200
            UINT    DstColorKey         : 1;        // 0x00000400
            UINT    LinearToSrgb        : 1;        // 0x00000800
            UINT    PresentCountValid   : 1;        // 0x00001000
            UINT    Rotate              : 1;        // 0x00002000
            UINT    Reserved            :18;        // 0xFFFFC000
        };
        UINT    Value;
    };
} D3DKMT_PRESENTFLAGS;

typedef struct _D3DKMT_PRESENT
{
    union
    {
        D3DKMT_HANDLE               hDevice;            // in: D3D10 compatibility.
        D3DKMT_HANDLE               hContext;           // in: Indentifies the context
    };
    HWND                            hWindow;            // in: window to present to
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;      // in: VidPn source ID if RestrictVidPnSource is flagged
    D3DKMT_HANDLE                   hSource;            // in: Source allocation to present from
    D3DKMT_HANDLE                   hDestination;       // in: Destination allocation whenever non-zero
    UINT                            Color;              // in: color value in ARGB 32 bit format
    RECT                            DstRect;            // in: unclipped dest rect
    RECT                            SrcRect;            // in: unclipped src rect
    UINT                            SubRectCnt;         // in: count of sub rects
    CONST RECT*                     pSrcSubRects;       // in: sub rects in source space
    UINT                            PresentCount;       // in: present counter
    D3DDDI_FLIPINTERVAL_TYPE        FlipInterval;       // in: flip interval
    D3DKMT_PRESENTFLAGS             Flags;              // in:
    ULONG                           BroadcastContextCount;                          // in: Specifies the number of context
                                                                                    //     to broadcast this command buffer to.
    D3DKMT_HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT]; // in: Specifies the handle of the context to
                                                                                    //     broadcast to.
} D3DKMT_PRESENT;

typedef struct _D3DKMT_RENDERFLAGS
{
    UINT    ResizeCommandBuffer     :  1;  // 0x00000001
    UINT    ResizeAllocationList    :  1;  // 0x00000002
    UINT    ResizePatchLocationList :  1;  // 0x00000004
    UINT    NullRendering           :  1;  // 0x00000008
    UINT    PresentRedirected       :  1;  // 0x00000010
    UINT    Reserved                : 27;  // 0xFFFFFFE0
} D3DKMT_RENDERFLAGS;

typedef struct _D3DKMT_RENDER
{
    union
    {
        D3DKMT_HANDLE               hDevice;                    // in: D3D10 compatibility.
        D3DKMT_HANDLE               hContext;                   // in: Indentifies the context
    };
    UINT                            CommandOffset;              // in: offset in bytes from start
    UINT                            CommandLength;              // in: number of bytes
    UINT                            AllocationCount;            // in: Number of allocations in allocation list.
    UINT                            PatchLocationCount;         // in: Number of patch locations in patch allocation list.
    VOID*                           pNewCommandBuffer;          // out: Pointer to the next command buffer to use.
    UINT                            NewCommandBufferSize;       // in: Size requested for the next command buffer.
                                                                // out: Size of the next command buffer to use.
    D3DDDI_ALLOCATIONLIST*          pNewAllocationList;         // out: Pointer to the next allocation list to use.
    UINT                            NewAllocationListSize;      // in: Size requested for the next allocation list.
                                                                // out: Size of the new allocation list.
    D3DDDI_PATCHLOCATIONLIST*       pNewPatchLocationList;      // out: Pointer to the next patch location list.
    UINT                            NewPatchLocationListSize;   // in: Size requested for the next patch location list.
                                                                // out: Size of the new patch location list.
    D3DKMT_RENDERFLAGS              Flags;                      // in:
    ULONGLONG                       PresentHistoryToken;        // in: Present history token for redirected present calls
    ULONG                           BroadcastContextCount;                          // in: Specifies the number of context
                                                                                    //     to broadcast this command buffer to.
    D3DKMT_HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT]; // in: Specifies the handle of the context to
                                                                                    //     broadcast to.
    ULONG                           QueuedBufferCount;          // out: Number of DMA buffer queued to this context after this submission.
} D3DKMT_RENDER;

typedef struct _D3DKMT_CREATEALLOCATIONFLAGS
{
    UINT    CreateResource              :  1;    // 0x00000001
    UINT    CreateShared                :  1;    // 0x00000002
    UINT    NonSecure                   :  1;    // 0x00000004
    UINT    Reserved                    : 29;    // 0xFFFFFFF8
} D3DKMT_CREATEALLOCATIONFLAGS;

typedef struct _D3DKMT_CREATEALLOCATION
{
                                            D3DKMT_HANDLE                   hDevice;
                                            D3DKMT_HANDLE                   hResource;      //in/out:valid only within device
                                            D3DKMT_HANDLE                   hGlobalShare;   //out:Shared handle if CreateShared
    __field_bcount(PrivateRuntimeDataSize)  CONST VOID*                     pPrivateRuntimeData;
                                            UINT                            PrivateRuntimeDataSize;
    __field_bcount(PrivateDriverDataSize)   CONST VOID*                     pPrivateDriverData;
                                            UINT                            PrivateDriverDataSize;
                                            UINT                            NumAllocations;
   __field_ecount(NumAllocations)           D3DDDI_ALLOCATIONINFO*          pAllocationInfo;
                                            D3DKMT_CREATEALLOCATIONFLAGS    Flags;
                                            HANDLE                          hPrivateRuntimeResourceHandle; // opaque handle used for event tracing
} D3DKMT_CREATEALLOCATION;

typedef struct _D3DKMT_OPENRESOURCE
{
                                                        D3DKMT_HANDLE               hDevice;                            // in : Indentifies the device
                                                        D3DKMT_HANDLE               hGlobalShare;                       // in : Shared resource handle
                                                        UINT                        NumAllocations;                     // in : Number of allocations associated with the resource
    __field_ecount(NumAllocations)                      D3DDDI_OPENALLOCATIONINFO*  pOpenAllocationInfo;                // in : Array of open allocation structs
    __field_bcount(PrivateRuntimeDataSize)              VOID*                       pPrivateRuntimeData;                // in : Caller supplied buffer where the runtime private data associated with this resource will be copied
                                                        UINT                        PrivateRuntimeDataSize;             // in : Size in bytes of the pPrivateRuntimeData buffer
    __field_bcount(ResourcePrivateDriverDataSize)       VOID*                       pResourcePrivateDriverData;         // in : Caller supplied buffer where the driver private data associated with the resource will be copied
                                                        UINT                        ResourcePrivateDriverDataSize;      // in : Size in bytes of the pResourcePrivateDriverData buffer
    __field_bcount(TotalPrivateDriverDataBufferSize)    VOID*                       pTotalPrivateDriverDataBuffer;      // in : Caller supplied buffer where the Driver private data will be stored
                                                        UINT                        TotalPrivateDriverDataBufferSize;   // in/out : Size in bytes of pTotalPrivateDriverDataBuffer / Size in bytes of data written to pTotalPrivateDriverDataBuffer
                                                        D3DKMT_HANDLE               hResource;                          // out : Handle for this resource in this process
}D3DKMT_OPENRESOURCE;

typedef struct _D3DKMT_QUERYRESOURCEINFO
{
    D3DKMT_HANDLE   hDevice;                        // in : Indentifies the device
    D3DKMT_HANDLE   hGlobalShare;                   // in : Global resource handle to open
    VOID*           pPrivateRuntimeData;            // in : Ptr to buffer that will receive runtime private data for the resource
    UINT            PrivateRuntimeDataSize;         // in/out : Size in bytes of buffer passed in for runtime private data / If pPrivateRuntimeData was NULL then size in bytes of buffer required for the runtime private data otherwise size in bytes of runtime private data copied into the buffer
    UINT            TotalPrivateDriverDataSize;     // out : Size in bytes of buffer required to hold all the DriverPrivate data for all of the allocations associated withe the resource
    UINT            ResourcePrivateDriverDataSize;  // out : Size in bytes of the driver's resource private data
    UINT            NumAllocations;                 // out : Number of allocations associated with this resource
}D3DKMT_QUERYRESOURCEINFO;

typedef struct _D3DKMT_DESTROYALLOCATION
{
    D3DKMT_HANDLE           hDevice;            // in: Indentifies the device
    D3DKMT_HANDLE           hResource;
    CONST D3DKMT_HANDLE*    phAllocationList;   // in: pointer to an array allocation handles to destroy
    UINT                    AllocationCount;    // in: Number of allocations in phAllocationList
} D3DKMT_DESTROYALLOCATION;

typedef struct _D3DKMT_SETALLOCATIONPRIORITY
{
    D3DKMT_HANDLE           hDevice;            // in: Indentifies the device
    D3DKMT_HANDLE           hResource;          // in: Specify the resource to set priority to.
    CONST D3DKMT_HANDLE*    phAllocationList;   // in: pointer to an array allocation to set priority to.
    UINT                    AllocationCount;    // in: Number of allocations in phAllocationList
    CONST UINT*             pPriorities;        // in: New priority for each of the allocation in the array.
} D3DKMT_SETALLOCATIONPRIORITY;

typedef enum _D3DKMT_ALLOCATIONRESIDENCYSTATUS
{
    D3DKMT_ALLOCATIONRESIDENCYSTATUS_RESIDENTINGPUMEMORY=1,
    D3DKMT_ALLOCATIONRESIDENCYSTATUS_RESIDENTINSHAREDMEMORY=2,
    D3DKMT_ALLOCATIONRESIDENCYSTATUS_NOTRESIDENT=3,
} D3DKMT_ALLOCATIONRESIDENCYSTATUS;

typedef struct _D3DKMT_QUERYALLOCATIONRESIDENCY
{
    D3DKMT_HANDLE                       hDevice;            // in: Indentifies the device
    D3DKMT_HANDLE                       hResource;          // in: pointer to resource owning the list of allocation.
    CONST D3DKMT_HANDLE*                phAllocationList;   // in: pointer to an array allocation to get residency status.
    UINT                                AllocationCount;    // in: Number of allocations in phAllocationList
    D3DKMT_ALLOCATIONRESIDENCYSTATUS*   pResidencyStatus;   // out: Residency status of each allocation in the array.
} D3DKMT_QUERYALLOCATIONRESIDENCY;

typedef struct _D3DKMT_GETRUNTIMEDATA
{
    D3DKMT_HANDLE       hAdapter;
    D3DKMT_HANDLE       hGlobalShare;       // in: shared handle
    VOID*               pRuntimeData;       // out: in: for a version?
    UINT                RuntimeDataSize;    // in:
} D3DKMT_GETRUNTIMEDATA;

typedef enum _KMTUMDVERSION
{
    KMTUMDVERSION_DX9 = 0,
    KMTUMDVERSION_DX10,
    KMTUMDVERSION_DX11,
} KMTUMDVERSION;

typedef struct _D3DKMT_UMDFILENAMEINFO
{
    KMTUMDVERSION       Version;                // In: UMD version
    WCHAR               UmdFileName[MAX_PATH];  // Out: UMD file name
} D3DKMT_UMDFILENAMEINFO;

typedef struct _D3DKMT_OPENGLINFO
{
    WCHAR               UmdOpenGlIcdFileName[MAX_PATH];
    ULONG               Version;
    ULONG               Flags;
} D3DKMT_OPENGLINFO;

typedef struct _D3DKMT_SEGMENTSIZEINFO
{
    ULONGLONG           DedicatedVideoMemorySize;
    ULONGLONG           DedicatedSystemMemorySize;
    ULONGLONG           SharedSystemMemorySize;
} D3DKMT_SEGMENTSIZEINFO;

typedef struct _D3DKMT_WORKINGSETFLAGS
{
    UINT    UseDefault   :  1;   // 0x00000001
    UINT    Reserved     : 31;   // 0xFFFFFFFE
} D3DKMT_WORKINGSETFLAGS;

typedef struct _D3DKMT_WORKINGSETINFO
{
    D3DKMT_WORKINGSETFLAGS Flags;
    ULONG MinimumWorkingSetPercentile;
    ULONG MaximumWorkingSetPercentile;
} D3DKMT_WORKINGSETINFO;

typedef struct _D3DKMT_FLIPINFOFLAGS
{
    UINT                FlipInterval :  1; // 0x00000001 // Set when kmd driver support FlipInterval natively
    UINT                Reserved     : 31; // 0xFFFFFFFE
} D3DKMT_FLIPINFOFLAGS;

typedef struct _D3DKMT_FLIPQUEUEINFO
{
    UINT                 MaxHardwareFlipQueueLength; // Max flip can be queued for hardware flip queue.
    UINT                 MaxSoftwareFlipQueueLength; // Max flip can be queued for software flip queue for non-legacy device.
    D3DKMT_FLIPINFOFLAGS FlipFlags;
} D3DKMT_FLIPQUEUEINFO;

typedef struct _D3DKMT_ADAPTERADDRESS
{
    UINT   BusNumber;              // Bus number on which the physical device is located.
    UINT   DeviceNumber;           // Index of the physical device on the bus.
    UINT   FunctionNumber;         // Function number of the adapter on the physical device.
} D3DKMT_ADAPTERADDRESS;

typedef struct _D3DKMT_ADAPTERREGISTRYINFO
{
    WCHAR   AdapterString[MAX_PATH];
    WCHAR   BiosString[MAX_PATH];
    WCHAR   DacType[MAX_PATH];
    WCHAR   ChipType[MAX_PATH];
} D3DKMT_ADAPTERREGISTRYINFO;

typedef struct _D3DKMT_CURRENTDISPLAYMODE
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId;
    D3DKMT_DISPLAYMODE DisplayMode;
} D3DKMT_CURRENTDISPLAYMODE;

typedef enum _KMTQUERYADAPTERINFOTYPE
{
     KMTQAITYPE_UMDRIVERPRIVATE         =  0,
     KMTQAITYPE_UMDRIVERNAME            =  1,
     KMTQAITYPE_UMOPENGLINFO            =  2,
     KMTQAITYPE_GETSEGMENTSIZE          =  3,
     KMTQAITYPE_ADAPTERGUID             =  4,
     KMTQAITYPE_FLIPQUEUEINFO           =  5,
     KMTQAITYPE_ADAPTERADDRESS          =  6,
     KMTQAITYPE_SETWORKINGSETINFO       =  7,
     KMTQAITYPE_ADAPTERREGISTRYINFO     =  8,
     KMTQAITYPE_CURRENTDISPLAYMODE      =  9,
     KMTQAITYPE_MODELIST                = 10,
     KMTQAITYPE_CHECKDRIVERUPDATESTATUS = 11,
} KMTQUERYADAPTERINFOTYPE;

typedef struct _D3DKMT_QUERYADAPTERINFO
{
    D3DKMT_HANDLE           hAdapter;
    KMTQUERYADAPTERINFOTYPE Type;
    VOID*                   pPrivateDriverData;
    UINT                    PrivateDriverDataSize;
} D3DKMT_QUERYADAPTERINFO;

typedef struct _D3DKMT_OPENADAPTERFROMHDC
{
    HDC                             hDc;            // in:  DC that maps to a single display
    D3DKMT_HANDLE                   hAdapter;       // out: adapter handle
    LUID                            AdapterLuid;    // out: adapter LUID
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;  // out: VidPN source ID for that particular display
} D3DKMT_OPENADAPTERFROMHDC;

typedef struct _D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME
{
    WCHAR                           DeviceName[32]; // in:  Name of GDI device from which to open an adapter instance
    D3DKMT_HANDLE                   hAdapter;       // out: adapter handle
    LUID                            AdapterLuid;    // out: adapter LUID
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;  // out: VidPN source ID for that particular display
} D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME;

typedef struct _D3DKMT_OPENADAPTERFROMDEVICENAME
{
    PCWSTR                          pDeviceName;    // in:  NULL terminated string containing the device name to open
    D3DKMT_HANDLE                   hAdapter;       // out: adapter handle
    LUID                            AdapterLuid;    // out: adapter LUID
} D3DKMT_OPENADAPTERFROMDEVICENAME;

typedef struct _D3DKMT_CLOSEADAPTER
{
    D3DKMT_HANDLE   hAdapter;   // in: adapter handle
} D3DKMT_CLOSEADAPTER;

typedef struct _D3DKMT_GETSHAREDPRIMARYHANDLE
{
    D3DKMT_HANDLE                   hAdapter;       // in: adapter handle
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;  // in: adapter's VidPN source ID
    D3DKMT_HANDLE                   hSharedPrimary; // out: global shared primary handle (if one exists currently)
} D3DKMT_GETSHAREDPRIMARYHANDLE;

typedef struct _D3DKMT_SHAREDPRIMARYLOCKNOTIFICATION
{
    LUID                            AdapterLuid;
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
    RECTL                           LockRect;               // in: If zero rect then we are locking the whole primary else the lock sub-rect
} D3DKMT_SHAREDPRIMARYLOCKNOTIFICATION;

typedef struct _D3DKMT_SHAREDPRIMARYUNLOCKNOTIFICATION
{
    LUID                            AdapterLuid;
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
} D3DKMT_SHAREDPRIMARYUNLOCKNOTIFICATION;

typedef enum _D3DKMT_ESCAPETYPE
{
    D3DKMT_ESCAPE_DRIVERPRIVATE           = 0,
    D3DKMT_ESCAPE_VIDMM                   = 1,
    D3DKMT_ESCAPE_TDRDBGCTRL              = 2,
    D3DKMT_ESCAPE_VIDSCH                  = 3,
    D3DKMT_ESCAPE_DEVICE                  = 4,
    D3DKMT_ESCAPE_DMM                     = 5,
    D3DKMT_ESCAPE_DEBUG_SNAPSHOT          = 6,
    D3DKMT_ESCAPE_SETDRIVERUPDATESTATUS   = 7
} D3DKMT_ESCAPETYPE;

typedef enum _D3DKMT_TDRDBGCTRLTYPE
{
    D3DKMT_TDRDBGCTRLTYPE_FORCETDR      = 0, //Simulate a TDR
    D3DKMT_TDRDBGCTRLTYPE_DISABLEBREAK  = 1, //Disable DebugBreak on timeout
    D3DKMT_TDRDBGCTRLTYPE_ENABLEBREAK   = 2, //Enable DebugBreak on timeout
    D3DKMT_TDRDBGCTRLTYPE_UNCONDITIONAL = 3, //Disables all safety conditions (e.g. check for consecutive recoveries)
    D3DKMT_TDRDBGCTRLTYPE_VSYNCTDR      = 4, //Simulate a Vsync TDR
    D3DKMT_TDRDBGCTRLTYPE_GPUTDR        = 5, //Simulate a GPU TDR
} D3DKMT_TDRDBGCTRLTYPE;

typedef enum _D3DKMT_VIDMMESCAPETYPE
{
    D3DKMT_VIDMMESCAPETYPE_SETFAULT                     = 0,
    D3DKMT_VIDMMESCAPETYPE_RUN_COHERENCY_TEST           = 1,
    D3DKMT_VIDMMESCAPETYPE_RUN_UNMAP_TO_DUMMY_PAGE_TEST = 2,
    D3DKMT_VIDMMESCAPETYPE_APERTURE_CORRUPTION_CHECK    = 3,
    D3DKMT_VIDMMESCAPETYPE_SUSPEND_CPU_ACCESS_TEST      = 4
} D3DKMT_VIDMMESCAPETYPE;

typedef enum _D3DKMT_VIDSCHESCAPETYPE
{
    D3DKMT_VIDSCHESCAPETYPE_PREEMPTIONCONTROL = 0, //Enable/Disable preemption
    D3DKMT_VIDSCHESCAPETYPE_SUSPENDSCHEDULER  = 1, //Suspend/Resume scheduler
    D3DKMT_VIDSCHESCAPETYPE_TDRCONTROL        = 2, //Tdr control
} D3DKMT_VIDSCHESCAPETYPE;

typedef enum _D3DKMT_DMMESCAPETYPE
{
    D3DKMT_DMMESCAPETYPE_UNINITIALIZED                       =  0,
    D3DKMT_DMMESCAPETYPE_GET_SUMMARY_INFO                    =  1,
    D3DKMT_DMMESCAPETYPE_GET_VIDEO_PRESENT_SOURCES_INFO      =  2,
    D3DKMT_DMMESCAPETYPE_GET_VIDEO_PRESENT_TARGETS_INFO      =  3,
    D3DKMT_DMMESCAPETYPE_GET_ACTIVEVIDPN_INFO                =  4,
    D3DKMT_DMMESCAPETYPE_GET_MONITORS_INFO                   =  5,
    D3DKMT_DMMESCAPETYPE_RECENTLY_COMMITTED_VIDPNS_INFO      =  6,
    D3DKMT_DMMESCAPETYPE_RECENT_MODECHANGE_REQUESTS_INFO     =  7,
    D3DKMT_DMMESCAPETYPE_RECENTLY_RECOMMENDED_VIDPNS_INFO    =  8,
    D3DKMT_DMMESCAPETYPE_RECENT_MONITOR_PRESENCE_EVENTS_INFO =  9,
    D3DKMT_DMMESCAPETYPE_ACTIVEVIDPN_SOURCEMODESET_INFO      = 10,
    D3DKMT_DMMESCAPETYPE_ACTIVEVIDPN_COFUNCPATHMODALITY_INFO = 11,
    D3DKMT_DMMESCAPETYPE_GET_LASTCLIENTCOMMITTEDVIDPN_INFO   = 12
} D3DKMT_DMMESCAPETYPE;

typedef struct _D3DKMT_VIDMM_ESCAPE
{
    D3DKMT_VIDMMESCAPETYPE Type;
    union
    {
        struct
        {
            union
            {
                struct
                {
                    ULONG ProbeAndLock : 1;
                    ULONG SplitPoint : 1;
                    ULONG HotAddMemory : 1;
                    ULONG SwizzlingAperture : 1;
                    ULONG PagingPathLockSubRange : 1;
                    ULONG PagingPathLockMinRange : 1;
                    ULONG ComplexLock : 1;
                    ULONG FailVARotation : 1;
                    ULONG NoWriteCombined : 1;
                    ULONG NoPrePatching : 1;
                    ULONG AlwaysRepatch : 1;
                    ULONG ExpectPreparationFailure : 1;
                    ULONG FailUserModeVAMapping : 1;
                    ULONG Reserved : 19;
                };
                ULONG Value;
            };
        } SetFault;
    };
} D3DKMT_VIDMM_ESCAPE;

typedef struct _D3DKMT_VIDSCH_ESCAPE
{
    D3DKMT_VIDSCHESCAPETYPE Type;
    union
    {
        BOOL PreemptionControl; // enable/disable preemption
        BOOL SuspendScheduler;  // suspend/resume scheduler
        ULONG TdrControl;       // control tdr
    };
} D3DKMT_VIDSCH_ESCAPE;

// Upper boundary on the DMM escape data size (in bytes).
enum
{
    D3DKMT_MAX_DMM_ESCAPE_DATASIZE = 10*1024
};

// Can't be included at top of this header because it depends on D3DKMT_DISPLAYMODE.
#include <dmmdiag.h>

typedef struct _D3DKMDT_DMMESCARG_GET_ACTIVEVIDPN_SOURCEMODESET_INFO
{
    __in  D3DDDI_VIDEO_PRESENT_SOURCE_ID        VidPnSourceId;
    __out DMM_VIDPNSOURCEMODESET_SERIALIZATION  VidPnSourceModeSet;

} D3DKMDT_DMMESCARG_GET_ACTIVEVIDPN_SOURCEMODESET_INFO;

typedef struct _D3DKMDT_DMMESCARG_GET_ACTIVEVIDPN_COFUNCPATHMODALITY_INFO
{
    __in  D3DDDI_VIDEO_PRESENT_SOURCE_ID         VidPnSourceId;
    __in  D3DKMDT_VIDPN_SOURCE_MODE              VidPnSourceMode;
    __out DMM_COFUNCPATHSMODALITY_SERIALIZATION  CofuncPathModality;

} D3DKMDT_DMMESCARG_GET_ACTIVEVIDPN_COFUNCPATHMODALITY_INFO;


// NOTE: If (ProvidedBufferSize >= MinRequiredBufferSize), then MinRequiredBufferSize = size of the actual complete data set in the Data[] array.
//
// See dmmdiag.h for definitions of corresponding serialization formats.
typedef struct _D3DKMT_DMM_ESCAPE
{
    __in  D3DKMT_DMMESCAPETYPE  Type;
    __in  SIZE_T                ProvidedBufferSize;     // actual size of Data[] array, in bytes.
    __out SIZE_T                MinRequiredBufferSize;  // minimum required size of Data[] array to contain requested data.

    union
    {
        // NOTE: These types are not defined in the public header, since they are for test consumption only.
        //       They are listed here only for reference.
        //
        DMM_DIAG_INFO_INDEX                                        DmmSummaryInfo;                        // (Type == D3DKMT_DMMESCAPETYPE_GET_SUMMARY_INFO)
        DMM_VIDEOPRESENTSOURCESET_SERIALIZATION                    VideoPresentSourceSetInfo;             // (Type == D3DKMT_DMMESCAPETYPE_GET_VIDEO_PRESENT_SOURCES_INFO)
        DMM_VIDEOPRESENTTARGETSET_SERIALIZATION                    VideoPresentTargetSetInfo;             // (Type == D3DKMT_DMMESCAPETYPE_GET_VIDEO_PRESENT_TARGETS_INFO)
        DMM_VIDPN_SERIALIZATION                                    ActiveVidPnInfo;                       // (Type == D3DKMT_DMMESCAPETYPE_GET_ACTIVEVIDPN_INFO)
        DMM_MONITORSET_SERIALIZATION                               ConnectedMonitorsInfo;                 // (Type == D3DKMT_DMMESCAPETYPE_GET_MONITORS_INFO)
        DMM_VIDPNSET_SERIALIZATION                                 RecentlyCommittedVidPnsInfo;           // (Type == D3DKMT_DMMESCAPETYPE_RECENTLY_COMMITTED_VIDPNS_INFO)
        DMM_VIDPNSET_SERIALIZATION                                 RecentlyRecommendedVidPnsInfo;         // (Type == D3DKMT_DMMESCAPETYPE_RECENTLY_RECOMMENDED_VIDPNS_INFO)
        DMM_DISPMODECHANGEREQUESTSET_SERIALIZATION                 RecentlyRequestedDispModeChangesInfo;  // (Type == D3DKMT_DMMESCAPETYPE_RECENT_MODECHANGE_REQUESTS_INFO)
        D3DKMDT_DMMESCARG_GET_ACTIVEVIDPN_SOURCEMODESET_INFO       ActiveVidPnSourceModeSetInfo;          // (Type == D3DKMT_DMMESCAPETYPE_ACTIVEVIDPN_SOURCEMODESET_INFO)
        D3DKMDT_DMMESCARG_GET_ACTIVEVIDPN_COFUNCPATHMODALITY_INFO  ActiveVidPnCofuncPathModalityInfo;     // (Type == D3DKMT_DMMESCAPETYPE_ACTIVEVIDPN_COFUNCPATHMODALITY_INFO)

        __out_bcount(ProvidedBufferSize) UCHAR  Data[1];
    };

} D3DKMT_DMM_ESCAPE;

typedef enum _D3DKMT_DEVICEESCAPE_TYPE
{
    D3DKMT_DEVICEESCAPE_VIDPNFROMALLOCATION = 0,
} D3DKMT_DEVICEESCAPE_TYPE;

typedef struct _D3DKMT_DEVICE_ESCAPE
{
    D3DKMT_DEVICEESCAPE_TYPE Type;
    union
    {
        struct
        {
            D3DKMT_HANDLE                   hPrimaryAllocation; // in: Primary allocation handle
            D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;      // out: VidPnSoureId of primary allocation
        } VidPnFromAllocation;
    };
} D3DKMT_DEVICE_ESCAPE;

typedef struct _D3DKMT_DEBUG_SNAPSHOT_ESCAPE
{
    ULONG Length;   // out: Actual length of the snapshot written in Buffer
    BYTE Buffer[1]; // out: Buffer to place snapshot
} D3DKMT_DEBUG_SNAPSHOT_ESCAPE;

typedef struct _D3DKMT_ESCAPE
{
    D3DKMT_HANDLE       hAdapter;               // in: adapter handle
    D3DKMT_HANDLE       hDevice;                // in: device handle [Optional]
    D3DKMT_ESCAPETYPE   Type;                   // in: escape type.
    D3DDDI_ESCAPEFLAGS  Flags;                  // in: flags
    VOID*               pPrivateDriverData;     // in/out: escape data
    UINT                PrivateDriverDataSize;  // in: size of escape data
    D3DKMT_HANDLE       hContext;               // in: context handle [Optional]
} D3DKMT_ESCAPE;

typedef enum _D3DKMT_QUERYSTATISTICS_TYPE
{
    D3DKMT_QUERYSTATISTICS_ADAPTER  =  0,
    D3DKMT_QUERYSTATISTICS_PROCESS  =  1
} D3DKMT_QUERYSTATISTICS_TYPE;

typedef struct _D3DKMT_QUERYSTATISTICS
{
    D3DKMT_QUERYSTATISTICS_TYPE Type;
    VOID*                       pBuffer;        // in/out: statistics data
    UINT                        BufferSize;     // in: size of statistics data buffer
    union
    {
        struct
        {
            D3DKMT_HANDLE   hAdapter;
        } QueryAdapter;
        struct
        {
            LUID            AdapterLuid;
            HANDLE          hProcess;
        } QueryProcess;
    } u;
} D3DKMT_QUERYSTATISTICS;

typedef enum _D3DKMT_VIDPNSOURCEOWNER_TYPE
{
     D3DKMT_VIDPNSOURCEOWNER_UNOWNED        = 0,    //Has no owner or GDI is the owner   ;internal
     D3DKMT_VIDPNSOURCEOWNER_SHARED         = 1,    //Has shared owner, that is owner can yield to any exclusive owner, not available to legacy devices
     D3DKMT_VIDPNSOURCEOWNER_EXCLUSIVE      = 2,    //Has exclusive owner without shared gdi primary,
     D3DKMT_VIDPNSOURCEOWNER_EXCLUSIVEGDI   = 3,    //Has exclusive owner with shared gdi primary and must be exclusive owner of all VidPn sources, only available to legacy devices
} D3DKMT_VIDPNSOURCEOWNER_TYPE;

typedef struct _D3DKMT_SETVIDPNSOURCEOWNER
{
    D3DKMT_HANDLE                           hDevice;            // in: Device handle
    CONST D3DKMT_VIDPNSOURCEOWNER_TYPE*     pType;              // in: OwnerType array
    CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID*   pVidPnSourceId;     // in: VidPn source ID array
    UINT                                    VidPnSourceCount;   // in: Number of valid entries in above array
} D3DKMT_SETVIDPNSOURCEOWNER;

#define D3DKMT_GETPRESENTHISTORY_MAXTOKENS  2048

typedef struct _D3DKMT_GETPRESENTHISTORY
{
    D3DKMT_HANDLE                   hAdapter;                   // in:  Adapter handle
    ULONGLONG*                      pPresentHistory;            // out: buffer for completed present tokens
    UINT                            PresentHistoryTokenCount;   // in/out: max/returned number of present tokens
} D3DKMT_GETPRESENTHISTORY;

typedef struct _D3DKMT_CREATEOVERLAY
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;      // in
    D3DKMT_HANDLE                   hDevice;            // in: Indentifies the device
    D3DDDI_KERNELOVERLAYINFO        OverlayInfo;        // in
    D3DKMT_HANDLE                   hOverlay;           // out: Kernel overlay handle
} D3DKMT_CREATEOVERLAY;

typedef struct _D3DKMT_UPDATEOVERLAY
{
    D3DKMT_HANDLE            hDevice;           // in: Indentifies the device
    D3DKMT_HANDLE            hOverlay;          // in: Kernel overlay handle
    D3DDDI_KERNELOVERLAYINFO OverlayInfo;       // in
} D3DKMT_UPDATEOVERLAY;

typedef struct _D3DKMT_FLIPOVERLAY
{
    D3DKMT_HANDLE        hDevice;               // in: Indentifies the device
    D3DKMT_HANDLE        hOverlay;              // in: Kernel overlay handle
    D3DKMT_HANDLE        hSource;               // in: Allocation currently displayed
    VOID*                pPrivateDriverData;    // in: Private driver data
    UINT                 PrivateDriverDataSize; // in: Size of private driver data
} D3DKMT_FLIPOVERLAY;

typedef struct _D3DKMT_DESTROYOVERLAY
{
    D3DKMT_HANDLE        hDevice;               // in: Indentifies the device
    D3DKMT_HANDLE        hOverlay;              // in: Kernel overlay handle
} D3DKMT_DESTROYOVERLAY;

typedef struct _D3DKMT_WAITFORVERTICALBLANKEVENT
{
    D3DKMT_HANDLE                   hAdapter;      // in: adapter handle
    D3DKMT_HANDLE                   hDevice;       // in: device handle [Optional]
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId; // in: adapter's VidPN Source ID
} D3DKMT_WAITFORVERTICALBLANKEVENT;

typedef struct _D3DKMT_SETGAMMARAMP
{
    D3DKMT_HANDLE                   hDevice;       // in: device handle
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId; // in: adapter's VidPN Source ID
    D3DDDI_GAMMARAMP_TYPE           Type;          // in: Gamma ramp type
    union
    {
        D3DDDI_GAMMA_RAMP_RGB256x3x16* pGammaRampRgb256x3x16;
        D3DDDI_GAMMA_RAMP_DXGI_1*      pGammaRampDXGI1;
    };
    UINT                            Size;
} D3DKMT_SETGAMMARAMP;

typedef enum _D3DKMT_DEVICEEXECUTION_STATE
{
    D3DKMT_DEVICEEXECUTION_ACTIVE               = 1,
    D3DKMT_DEVICEEXECUTION_RESET                = 2,
    D3DKMT_DEVICEEXECUTION_HUNG                 = 3,
    D3DKMT_DEVICEEXECUTION_STOPPED              = 4,
    D3DKMT_DEVICEEXECUTION_ERROR_OUTOFMEMORY    = 5,
    D3DKMT_DEVICEEXECUTION_ERROR_DMAFAULT       = 6,
} D3DKMT_DEVICEEXECUTION_STATE;

typedef struct _D3DKMT_DEVICERESET_STATE
{
    union
    {
        struct
        {
            UINT    DesktopSwitched : 1;        // 0x00000001
            UINT    Reserved        :31;        // 0xFFFFFFFE
        };
        UINT    Value;
    };
} D3DKMT_DEVICERESET_STATE;

typedef struct _D3DKMT_PRESENT_STATS
{
    UINT PresentCount;
    UINT PresentRefreshCount;
    UINT SyncRefreshCount;
    LARGE_INTEGER SyncQPCTime;
    LARGE_INTEGER SyncGPUTime;
} D3DKMT_PRESENT_STATS;

typedef struct _D3DKMT_DEVICEPRESENT_STATE
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId; // in: present source id
    D3DKMT_PRESENT_STATS           PresentStats;  // out: present stats
} D3DKMT_DEVICEPRESENT_STATE;

typedef enum _D3DKMT_DEVICESTATE_TYPE
{
    D3DKMT_DEVICESTATE_EXECUTION = 1,
    D3DKMT_DEVICESTATE_PRESENT   = 2,
    D3DKMT_DEVICESTATE_RESET     = 3,
} D3DKMT_DEVICESTATE_TYPE;

typedef struct _D3DKMT_GETDEVICESTATE
{
    D3DKMT_HANDLE                   hDevice;       // in: device handle
    D3DKMT_DEVICESTATE_TYPE         StateType;     // in: device state type
    union
    {
        D3DKMT_DEVICEEXECUTION_STATE ExecutionState; // out: device state
        D3DKMT_DEVICEPRESENT_STATE   PresentState;   // in/out: present state
        D3DKMT_DEVICERESET_STATE     ResetState;     // out: reset state
    };
} D3DKMT_GETDEVICESTATE;

typedef struct _D3DKMT_CREATEDCFROMMEMORY
{
    VOID*                           pMemory;       // in: memory for DC
    D3DDDIFORMAT                    Format;        // in: Memory pixel format
    UINT                            Width;         // in: Memory Width
    UINT                            Height;        // in: Memory Height
    UINT                            Pitch;         // in: Memory pitch
    HDC                             hDeviceDc;     // in: DC describing the device
    PALETTEENTRY*                   pColorTable;   // in: Palette
    HDC                             hDc;           // out: HDC
    HANDLE                          hBitmap;       // out: Handle to bitmap
} D3DKMT_CREATEDCFROMMEMORY;

typedef struct _D3DKMT_DESTROYDCFROMMEMORY
{
    HDC                             hDc;           // in:
    HANDLE                          hBitmap;       // in:
} D3DKMT_DESTROYDCFROMMEMORY;

typedef struct _D3DKMT_SETCONTEXTSCHEDULINGPRIORITY
{
    D3DKMT_HANDLE                   hContext;      // in: context handle
    INT                             Priority;      // in: context priority
} D3DKMT_SETCONTEXTSCHEDULINGPRIORITY;

typedef struct _D3DKMT_CHANGESURFACEPOINTER
{
    HDC                             hDC;             // in: dc handle
    HANDLE                          hBitmap;         // in: bitmap handle
    LPVOID                          pSurfacePointer; // in: new surface pointer
    UINT                            Width;           // in: Memory Width
    UINT                            Height;          // in: Memory Height
    UINT                            Pitch;           // in: Memory pitch
} D3DKMT_CHANGESURFACEPOINTER;

typedef struct _D3DKMT_GETCONTEXTSCHEDULINGPRIORITY
{
    D3DKMT_HANDLE                   hContext;      // in: context handle
    INT                             Priority;      // out: context priority
} D3DKMT_GETCONTEXTSCHEDULINGPRIORITY;

typedef enum _D3DKMT_SCHEDULINGPRIORITYCLASS
{
    D3DKMT_SCHEDULINGPRIORITYCLASS_IDLE         = 0,
    D3DKMT_SCHEDULINGPRIORITYCLASS_BELOW_NORMAL = 1,
    D3DKMT_SCHEDULINGPRIORITYCLASS_NORMAL       = 2,
    D3DKMT_SCHEDULINGPRIORITYCLASS_ABOVE_NORMAL = 3,
    D3DKMT_SCHEDULINGPRIORITYCLASS_HIGH         = 4,
    D3DKMT_SCHEDULINGPRIORITYCLASS_REALTIME     = 5,
} D3DKMT_SCHEDULINGPRIORITYCLASS;

typedef struct _D3DKMT_GETSCANLINE
{
    D3DKMT_HANDLE                   hAdapter;           // in: Adapter handle
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;      // in: Adapter's VidPN Source ID
    BOOLEAN                         InVerticalBlank;    // out: Within vertical blank
    UINT                            ScanLine;           // out: Current scan line
} D3DKMT_GETSCANLINE;

typedef enum _D3DKMT_QUEUEDLIMIT_TYPE
{
    D3DKMT_SET_QUEUEDLIMIT_PRESENT     = 1,
    D3DKMT_GET_QUEUEDLIMIT_PRESENT     = 2,
} D3DKMT_QUEUEDLIMIT_TYPE;

typedef struct _D3DKMT_SETQUEUEDLIMIT
{
    D3DKMT_HANDLE                   hDevice;            // in: device handle
    D3DKMT_QUEUEDLIMIT_TYPE         Type;               // in: limit type
    union
    {
        UINT                        QueuedPresentLimit; // in (or out): queued present limit
        struct
        {
            D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId;          // in: adapter's VidPN source ID
            UINT                           QueuedPendingFlipLimit; // in (or out): flip pending limit
        };
    };
} D3DKMT_SETQUEUEDLIMIT;

typedef struct _D3DKMT_POLLDISPLAYCHILDREN
{
    D3DKMT_HANDLE                   hAdapter;           // in: Adapter handle
    BOOLEAN                         NonDestructiveOnly; // in: Destructive or not
} D3DKMT_POLLDISPLAYCHILDREN;

typedef struct _D3DKMT_INVALIDATEACTIVEVIDPN
{
    D3DKMT_HANDLE                   hAdapter;               // in: Adapter handle
    VOID*                           pPrivateDriverData;     // in: Private driver data
    UINT                            PrivateDriverDataSize;  // in: Size of private driver data
} D3DKMT_INVALIDATEACTIVEVIDPN;

typedef struct _D3DKMT_CHECKOCCLUSION
{
    HWND            hWindow;        // in:  Destination window handle
} D3DKMT_CHECKOCCLUSION;

typedef struct _D3DKMT_WAITFORIDLE
{
    D3DKMT_HANDLE   hDevice;        // in:  Device to wait for idle
} D3DKMT_WAITFORIDLE;

typedef struct _D3DKMT_CHECKMONITORPOWERSTATE
{
    D3DKMT_HANDLE    hAdapter;    // in: Adapter to check on
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;      // in: Adapter's VidPN Source ID
} D3DKMT_CHECKMONITORPOWERSTATE;

typedef struct _D3DKMT_SETDISPLAYPRIVATEDRIVERFORMAT
{
    D3DKMT_HANDLE                   hDevice;                         // in: Identifies the device
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;                   // in: Identifies which VidPn we are changing the private driver format attribute for
    UINT                            PrivateDriverFormatAttribute;    // In: Requested private format attribute for VidPn specified
} D3DKMT_SETDISPLAYPRIVATEDRIVERFORMAT;

typedef NTSTATUS (APIENTRY *PFND3DKMT_CREATEALLOCATION)(IN OUT D3DKMT_CREATEALLOCATION*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_QUERYRESOURCEINFO)(IN OUT D3DKMT_QUERYRESOURCEINFO*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_OPENRESOURCE)(IN OUT D3DKMT_OPENRESOURCE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_DESTROYALLOCATION)(IN CONST D3DKMT_DESTROYALLOCATION*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SETALLOCATIONPRIORITY)(IN CONST D3DKMT_SETALLOCATIONPRIORITY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_QUERYALLOCATIONRESIDENCY)(IN CONST D3DKMT_QUERYALLOCATIONRESIDENCY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CREATEDEVICE)(IN OUT D3DKMT_CREATEDEVICE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_DESTROYDEVICE)(IN CONST D3DKMT_DESTROYDEVICE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CREATECONTEXT)(IN OUT D3DKMT_CREATECONTEXT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_DESTROYCONTEXT)(IN CONST D3DKMT_DESTROYCONTEXT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CREATESYNCHRONIZATIONOBJECT)(IN OUT D3DKMT_CREATESYNCHRONIZATIONOBJECT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_DESTROYSYNCHRONIZATIONOBJECT)(IN CONST D3DKMT_DESTROYSYNCHRONIZATIONOBJECT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_WAITFORSYNCHRONIZATIONOBJECT)(IN OUT D3DKMT_WAITFORSYNCHRONIZATIONOBJECT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SIGNALSYNCHRONIZATIONOBJECT)(IN CONST D3DKMT_SIGNALSYNCHRONIZATIONOBJECT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_LOCK)(IN OUT D3DKMT_LOCK*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_UNLOCK)(IN CONST D3DKMT_UNLOCK*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETDISPLAYMODELIST)(IN OUT D3DKMT_GETDISPLAYMODELIST*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SETDISPLAYMODE)(IN CONST D3DKMT_SETDISPLAYMODE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETMULTISAMPLEMETHODLIST)(IN OUT D3DKMT_GETMULTISAMPLEMETHODLIST*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_PRESENT)(IN CONST D3DKMT_PRESENT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_RENDER)(IN OUT D3DKMT_RENDER*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETRUNTIMEDATA)(IN CONST D3DKMT_GETRUNTIMEDATA*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_QUERYADAPTERINFO)(IN CONST D3DKMT_QUERYADAPTERINFO*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_OPENADAPTERFROMHDC)(IN OUT D3DKMT_OPENADAPTERFROMHDC*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_OPENADAPTERFROMGDIDISPLAYNAME)(IN OUT D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_OPENADAPTERFROMDEVICENAME)(IN OUT D3DKMT_OPENADAPTERFROMDEVICENAME*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CLOSEADAPTER)(IN CONST D3DKMT_CLOSEADAPTER*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETSHAREDPRIMARYHANDLE)(IN OUT D3DKMT_GETSHAREDPRIMARYHANDLE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_ESCAPE)(IN CONST D3DKMT_ESCAPE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_QUERYSTATISTICS)(IN CONST D3DKMT_QUERYSTATISTICS*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SETVIDPNSOURCEOWNER)(IN CONST D3DKMT_SETVIDPNSOURCEOWNER*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETPRESENTHISTORY)(IN OUT D3DKMT_GETPRESENTHISTORY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CREATEOVERLAY)(IN OUT D3DKMT_CREATEOVERLAY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_UPDATEOVERLAY)(IN CONST D3DKMT_UPDATEOVERLAY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_FLIPOVERLAY)(IN CONST D3DKMT_FLIPOVERLAY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_DESTROYOVERLAY)(IN CONST D3DKMT_DESTROYOVERLAY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_WAITFORVERTICALBLANKEVENT)(IN CONST D3DKMT_WAITFORVERTICALBLANKEVENT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SETGAMMARAMP)(IN CONST D3DKMT_SETGAMMARAMP*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETDEVICESTATE)(IN OUT D3DKMT_GETDEVICESTATE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CREATEDCFROMMEMORY)(IN OUT D3DKMT_CREATEDCFROMMEMORY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_DESTROYDCFROMMEMORY)(IN CONST D3DKMT_DESTROYDCFROMMEMORY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SETCONTEXTSCHEDULINGPRIORITY)(IN CONST D3DKMT_SETCONTEXTSCHEDULINGPRIORITY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETCONTEXTSCHEDULINGPRIORITY)(IN OUT D3DKMT_GETCONTEXTSCHEDULINGPRIORITY*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SETPROCESSSCHEDULINGPRIORITYCLASS)(IN HANDLE, IN D3DKMT_SCHEDULINGPRIORITYCLASS);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETPROCESSSCHEDULINGPRIORITYCLASS)(IN HANDLE, OUT D3DKMT_SCHEDULINGPRIORITYCLASS*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_RELEASEPROCESSVIDPNSOURCEOWNERS)(IN HANDLE);
typedef NTSTATUS (APIENTRY *PFND3DKMT_GETSCANLINE)(IN OUT D3DKMT_GETSCANLINE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CHANGESURFACEPOINTER)(IN CONST D3DKMT_CHANGESURFACEPOINTER*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SETQUEUEDLIMIT)(IN CONST D3DKMT_SETQUEUEDLIMIT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_POLLDISPLAYCHILDREN)(IN CONST D3DKMT_POLLDISPLAYCHILDREN*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_INVALIDATEACTIVEVIDPN)(IN CONST D3DKMT_INVALIDATEACTIVEVIDPN*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CHECKOCCLUSION)(IN CONST D3DKMT_CHECKOCCLUSION*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_WAITFORIDLE)(IN CONST D3DKMT_WAITFORIDLE*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_CHECKMONITORPOWERSTATE)(IN CONST D3DKMT_CHECKMONITORPOWERSTATE*);
typedef BOOLEAN  (APIENTRY *PFND3DKMT_CHECKEXCLUSIVEOWNERSHIP)();
typedef NTSTATUS (APIENTRY *PFND3DKMT_SETDISPLAYPRIVATEDRIVERFORMAT)(IN CONST D3DKMT_SETDISPLAYPRIVATEDRIVERFORMAT*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SHAREDPRIMARYLOCKNOTIFICATION)(IN CONST D3DKMT_SHAREDPRIMARYLOCKNOTIFICATION*);
typedef NTSTATUS (APIENTRY *PFND3DKMT_SHAREDPRIMARYUNLOCKNOTIFICATION)(IN CONST D3DKMT_SHAREDPRIMARYUNLOCKNOTIFICATION*);

#ifdef __cplusplus
extern "C"
{
#endif

EXTERN_C NTSTATUS APIENTRY D3DKMTCreateAllocation(IN OUT D3DKMT_CREATEALLOCATION*);
EXTERN_C NTSTATUS APIENTRY D3DKMTQueryResourceInfo(IN OUT D3DKMT_QUERYRESOURCEINFO*);
EXTERN_C NTSTATUS APIENTRY D3DKMTOpenResource(IN OUT D3DKMT_OPENRESOURCE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTDestroyAllocation(IN CONST D3DKMT_DESTROYALLOCATION*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSetAllocationPriority(IN CONST D3DKMT_SETALLOCATIONPRIORITY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTQueryAllocationResidency(IN CONST D3DKMT_QUERYALLOCATIONRESIDENCY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTCreateDevice(IN OUT D3DKMT_CREATEDEVICE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTDestroyDevice(IN CONST D3DKMT_DESTROYDEVICE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTCreateContext(IN OUT D3DKMT_CREATECONTEXT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTDestroyContext(IN CONST D3DKMT_DESTROYCONTEXT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTCreateSynchronizationObject(IN OUT D3DKMT_CREATESYNCHRONIZATIONOBJECT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTDestroySynchronizationObject(IN CONST D3DKMT_DESTROYSYNCHRONIZATIONOBJECT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTWaitForSynchronizationObject(IN OUT D3DKMT_WAITFORSYNCHRONIZATIONOBJECT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSignalSynchronizationObject(IN CONST D3DKMT_SIGNALSYNCHRONIZATIONOBJECT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTLock(IN OUT D3DKMT_LOCK*);
EXTERN_C NTSTATUS APIENTRY D3DKMTUnlock(IN CONST D3DKMT_UNLOCK*);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetDisplayModeList(IN OUT D3DKMT_GETDISPLAYMODELIST*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSetDisplayMode(IN CONST D3DKMT_SETDISPLAYMODE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetMultisampleMethodList(IN OUT D3DKMT_GETMULTISAMPLEMETHODLIST*);
EXTERN_C NTSTATUS APIENTRY D3DKMTPresent(IN CONST D3DKMT_PRESENT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTRender(IN OUT D3DKMT_RENDER*);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetRuntimeData(IN CONST D3DKMT_GETRUNTIMEDATA*);
EXTERN_C NTSTATUS APIENTRY D3DKMTQueryAdapterInfo(IN CONST D3DKMT_QUERYADAPTERINFO*);
EXTERN_C NTSTATUS APIENTRY D3DKMTOpenAdapterFromHdc(IN OUT D3DKMT_OPENADAPTERFROMHDC*);
EXTERN_C NTSTATUS APIENTRY D3DKMTOpenAdapterFromGdiDisplayName(IN OUT D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME*);
EXTERN_C NTSTATUS APIENTRY D3DKMTOpenAdapterFromDeviceName(IN OUT D3DKMT_OPENADAPTERFROMDEVICENAME*);
EXTERN_C NTSTATUS APIENTRY D3DKMTCloseAdapter(IN CONST D3DKMT_CLOSEADAPTER*);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetSharedPrimaryHandle(IN OUT D3DKMT_GETSHAREDPRIMARYHANDLE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTEscape(IN CONST D3DKMT_ESCAPE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSetVidPnSourceOwner(IN CONST D3DKMT_SETVIDPNSOURCEOWNER*);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetPresentHistory(IN OUT D3DKMT_GETPRESENTHISTORY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTCreateOverlay(IN OUT D3DKMT_CREATEOVERLAY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTUpdateOverlay(IN CONST D3DKMT_UPDATEOVERLAY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTFlipOverlay(IN CONST D3DKMT_FLIPOVERLAY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTDestroyOverlay(IN CONST D3DKMT_DESTROYOVERLAY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTWaitForVerticalBlankEvent(IN CONST D3DKMT_WAITFORVERTICALBLANKEVENT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSetGammaRamp(IN CONST D3DKMT_SETGAMMARAMP*);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetDeviceState(IN OUT D3DKMT_GETDEVICESTATE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTCreateDCFromMemory(IN OUT D3DKMT_CREATEDCFROMMEMORY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTDestroyDCFromMemory(IN CONST D3DKMT_DESTROYDCFROMMEMORY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSetContextSchedulingPriority(IN CONST D3DKMT_SETCONTEXTSCHEDULINGPRIORITY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetContextSchedulingPriority(IN OUT D3DKMT_GETCONTEXTSCHEDULINGPRIORITY*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSetProcessSchedulingPriorityClass(IN HANDLE, IN D3DKMT_SCHEDULINGPRIORITYCLASS);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetProcessSchedulingPriorityClass(IN HANDLE, OUT D3DKMT_SCHEDULINGPRIORITYCLASS*);
EXTERN_C NTSTATUS APIENTRY D3DKMTReleaseProcessVidPnSourceOwners(IN HANDLE);
EXTERN_C NTSTATUS APIENTRY D3DKMTGetScanLine(IN OUT D3DKMT_GETSCANLINE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTChangeSurfacePointer(IN CONST D3DKMT_CHANGESURFACEPOINTER*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSetQueuedLimit(IN CONST D3DKMT_SETQUEUEDLIMIT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTPollDisplayChildren(IN CONST D3DKMT_POLLDISPLAYCHILDREN*);
EXTERN_C NTSTATUS APIENTRY D3DKMTInvalidateActiveVidPn(IN CONST D3DKMT_INVALIDATEACTIVEVIDPN*);
EXTERN_C NTSTATUS APIENTRY D3DKMTCheckOcclusion(IN CONST D3DKMT_CHECKOCCLUSION*);
EXTERN_C NTSTATUS APIENTRY D3DKMTWaitForIdle(IN CONST D3DKMT_WAITFORIDLE*);
EXTERN_C NTSTATUS APIENTRY D3DKMTCheckMonitorPowerState(IN CONST D3DKMT_CHECKMONITORPOWERSTATE*);
EXTERN_C BOOLEAN  APIENTRY D3DKMTCheckExclusiveOwnership(VOID);
EXTERN_C NTSTATUS APIENTRY D3DKMTSetDisplayPrivateDriverFormat(IN CONST D3DKMT_SETDISPLAYPRIVATEDRIVERFORMAT*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSharedPrimaryLockNotification(IN CONST D3DKMT_SHAREDPRIMARYLOCKNOTIFICATION*);
EXTERN_C NTSTATUS APIENTRY D3DKMTSharedPrimaryUnLockNotification(IN CONST D3DKMT_SHAREDPRIMARYUNLOCKNOTIFICATION*);

#ifdef __cplusplus
}
#endif

#endif /* _D3DKMTHK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\d3dkmddi.h ===
/******************************Module*Header**********************************\
*
* Module Name: d3dkmddi.h
*
* Content: longhorn display driver kernel mode interfaces
*
* Copyright (c) 2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef _D3DKMDDI_H_
#define _D3DKMDDI_H_

#include <d3dkmdt.h>

typedef struct _DXGK_SEGMENTPREFERENCE
{
    union
    {
        struct
        {
            UINT SegmentId0 : 5;                // 0x0000001F
            UINT Direction0 : 1;                // 0x00000020
            UINT SegmentId1 : 5;                // 0x000007C0
            UINT Direction1 : 1;                // 0x00000800
            UINT SegmentId2 : 5;                // 0x0001F000
            UINT Direction2 : 1;                // 0x00020000
            UINT SegmentId3 : 5;                // 0x007C0000
            UINT Direction3 : 1;                // 0x00800000
            UINT SegmentId4 : 5;                // 0x1F000000
            UINT Direction4 : 1;                // 0x20000000
            UINT Reserved   : 2;                // 0xC0000000
        };
        UINT Value;
    };
} DXGK_SEGMENTPREFERENCE;

typedef struct _DXGK_SEGMENTBANKPREFERENCE
{
    union
    {
        struct
        {
            UINT Bank0          : 7;    // 0x0000007F
            UINT Direction0     : 1;    // 0x00000080
            UINT Bank1          : 7;    // 0x00007F00
            UINT Direction1     : 1;    // 0x00008000
            UINT Bank2          : 7;    // 0x007F0000
            UINT Direction2     : 1;    // 0x00800000
            UINT Bank3          : 7;    // 0x7F000000
            UINT Direction3     : 1;    // 0x80000000
        };
        UINT Value;
    };
} DXGK_SEGMENTBANKPREFERENCE;

typedef struct _DXGK_ALLOCATIONLIST
{
    HANDLE              hDeviceSpecificAllocation;
    struct
    {
        UINT            WriteOperation  : 1;    // 0x00000001
        UINT            SegmentId       : 5;    // 0x0000002E
        UINT            Reserved        : 26;   // 0xFFFFFFC0
    };
    PHYSICAL_ADDRESS    PhysicalAddress;
} DXGK_ALLOCATIONLIST;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Define parameter types for SAL-annotated DDI parameters.  These are used by DDI function
//          name typedefs in dispmprt.h and d3dkmddi.h.  They are not needed in a driver's DDI function
//          definitions, and should not be used in driver code.
//
//  Naming convention: Concatenate all SAL annotations, an underscore, other modifiers
//                     such as CONST, and the type of the parameter, and use uppercase
//                     only.
//
typedef __in          BOOLEAN               IN_BOOLEAN;
typedef __in          UCHAR                 IN_UCHAR;
typedef __in          DEVICE_POWER_STATE    IN_DEVICE_POWER_STATE;
typedef __in    CONST HANDLE                IN_CONST_HANDLE;
typedef __inout       UINT*                 INOUT_PUINT;
typedef __in          ULONG                 IN_ULONG;
typedef __out         PULONG                OUT_PULONG;
typedef __in          POWER_ACTION          IN_POWER_ACTION;
typedef __in          PVOID                 IN_PVOID;
typedef __in    CONST PVOID                 IN_CONST_PVOID;
typedef __out         PVOID*                OUT_PPVOID;


typedef struct _DXGKARG_RENDER
{
    CONST VOID* CONST           pCommand;
    CONST UINT                  CommandLength;
    VOID*                       pDmaBuffer;
    UINT                        DmaSize;
    VOID*                       pDmaBufferPrivateData;
    UINT                        DmaBufferPrivateDataSize;
    DXGK_ALLOCATIONLIST*        pAllocationList;
    UINT                        AllocationListSize;
    D3DDDI_PATCHLOCATIONLIST*   pPatchLocationListIn;
    UINT                        PatchLocationListInSize;
    D3DDDI_PATCHLOCATIONLIST*   pPatchLocationListOut;
    UINT                        PatchLocationListOutSize;
    UINT                        MultipassOffset;
    UINT                        DmaBufferSegmentId;
    PHYSICAL_ADDRESS            DmaBufferPhysicalAddress;
} DXGKARG_RENDER;

typedef __inout DXGKARG_RENDER*     INOUT_PDXGKARG_RENDER;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_RENDER(
    IN_CONST_HANDLE         hContext,
    INOUT_PDXGKARG_RENDER   pRender
    );

#define DXGK_PRESENT_SOURCE_INDEX       1
#define DXGK_PRESENT_DESTINATION_INDEX  2
#define DXGK_PRESENT_MAX_INDEX          DXGK_PRESENT_DESTINATION_INDEX

typedef struct _DXGK_PRESENTFLAGS
{
    union
    {
        struct
        {
            UINT    Blt             : 1;    // 0x00000001
            UINT    ColorFill       : 1;    // 0x00000002
            UINT    Flip            : 1;    // 0x00000004
            UINT    FlipWithNoWait  : 1;    // 0x00000008
            UINT    SrcColorKey     : 1;    // 0x00000010
            UINT    DstColorKey     : 1;    // 0x00000020
            UINT    LinearToSrgb    : 1;    // 0x00000040
            UINT    Rotate          : 1;    // 0x00000080
            UINT    Reserved        :24;    // 0xFFFFFF00
        };
        UINT Value;
    };
} DXGK_PRESENTFLAGS;

typedef struct _DXGKARG_PRESENT
{
    VOID*                       pDmaBuffer;
    UINT                        DmaSize;
    VOID*                       pDmaBufferPrivateData;
    UINT                        DmaBufferPrivateDataSize;
    DXGK_ALLOCATIONLIST*        pAllocationList;
    D3DDDI_PATCHLOCATIONLIST*   pPatchLocationListOut;
    UINT                        PatchLocationListOutSize;
    UINT                        MultipassOffset;
    UINT                        Color;
    RECT                        DstRect;
    RECT                        SrcRect;
    UINT                        SubRectCnt;
    CONST RECT*                 pDstSubRects;
    D3DDDI_FLIPINTERVAL_TYPE    FlipInterval;
    DXGK_PRESENTFLAGS           Flags;
    UINT                        DmaBufferSegmentId;
    PHYSICAL_ADDRESS            DmaBufferPhysicalAddress;    
} DXGKARG_PRESENT;

typedef __inout DXGKARG_PRESENT*    INOUT_PDXGKARG_PRESENT;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_PRESENT(
    IN_CONST_HANDLE         hContext,
    INOUT_PDXGKARG_PRESENT  pPresent
    );

typedef struct _DXGKARG_STOPCAPTURE
{
    HANDLE                      hAllocation;
} DXGKARG_STOPCAPTURE;

typedef __in CONST DXGKARG_STOPCAPTURE*     IN_CONST_PDXGKARG_STOPCAPTURE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_STOPCAPTURE(
    IN_CONST_HANDLE                 hAdapter,
    IN_CONST_PDXGKARG_STOPCAPTURE   pStopCapture
    );

// Definition for Scheduler Interrupt Event Type.
//
typedef enum _DXGK_INTERRUPT_TYPE
{
    DXGK_INTERRUPT_DMA_COMPLETED  = 1,
    DXGK_INTERRUPT_DMA_PREEMPTED  = 2,
    DXGK_INTERRUPT_CRTC_VSYNC     = 3,
    DXGK_INTERRUPT_DMA_FAULTED    = 4,
} DXGK_INTERRUPT_TYPE;

typedef struct _DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS
{
    union
    {
        struct
        {
            UINT            ValidPhysicalAdapterMask : 1; // 0x00000001
            UINT            Reserved                 :31; // 0xFFFFFFFE
        };
        UINT                Value;
    };
} DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS;

typedef struct _DXGKARGCB_NOTIFY_INTERRUPT_DATA
{
    DXGK_INTERRUPT_TYPE  InterruptType;        // in: interrupt type
    union
    {
        struct
        {
            UINT             SubmissionFenceId;         // in: submission id of completed command.
            UINT             NodeOrdinal;               // in: Node ordinal of engine generating the notification.
            UINT             EngineOrdinal;             // in: Engine ordinal of engine generating the notification.
        } DmaCompleted;
        struct
        {
            UINT             PreemptionFenceId;    // in: submission id of preemption request.
            UINT             LastCompletedFenceId; // in: submission id of last completed command before preemption.
            UINT             NodeOrdinal;          // in: Node ordinal of engine generating the notification.
            UINT             EngineOrdinal;        // in: Engine ordinal of engine generating the notification.
        } DmaPreempted;
        struct
        {
            UINT             FaultedFenceId;       // in: submission id of faulted command.
            NTSTATUS         Status;               // in: status of fault
            UINT             NodeOrdinal;          // in: Node ordinal of engine generating the notification.
            UINT             EngineOrdinal;        // in: Engine ordinal of engine generating the notification.
        } DmaFaulted;
        struct
        {
            D3DDDI_VIDEO_PRESENT_TARGET_ID VidPnTargetId;       // in: VidPnTarget id (where vsync occurs).
            PHYSICAL_ADDRESS               PhysicalAddress;     // in: Physical Address of displaying buffer.
            UINT                           PhysicalAdapterMask; // in: Physical adapter mask (where vsync occurs).
                                                                //     (Must set Flags.ValidPhysicalAdapterMask as well)
        } CrtcVsync;
        struct
        {
            UINT            Reserved[16];
        } Reserved;
    };
    DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS Flags;      // in: event flags
} DXGKARGCB_NOTIFY_INTERRUPT_DATA;

// Device Driver Interface fence update at ISR.
//
typedef VOID (APIENTRY CALLBACK *DXGKCB_NOTIFY_INTERRUPT)(HANDLE hAdapter, CONST DXGKARGCB_NOTIFY_INTERRUPT_DATA*);

// Device Driver Interface fence update at DPC.
//
typedef VOID (APIENTRY CALLBACK *DXGKCB_NOTIFY_DPC)(HANDLE hAdapter);

typedef struct _DXGK_OPENALLOCATIONINFO
{
    D3DKMT_HANDLE   hAllocation;                        // in: dxg assigned per Device handle
    VOID*           pPrivateDriverData;                 // in/out: Private data for each allocation allocated by the user mode driver
    UINT            PrivateDriverDataSize;              // in: Size of the private data
    HANDLE          hDeviceSpecificAllocation;          // out: driver set it
} DXGK_OPENALLOCATIONINFO;

typedef struct _DXGK_OPENALLOCATIONFLAGS
{
    union
    {
        struct
        {
            UINT    Create          : 1;    // 0x00000001       // Indicates that this allocation is being created, if not set then allocation is being opened
            UINT    Reserved        :31;    // 0xFFFFFFFE
        };
        UINT Value;
    };
} DXGK_OPENALLOCATIONFLAGS;

typedef struct _DXGKARG_OPENALLOCATION
{
    UINT                            NumAllocations;
    DXGK_OPENALLOCATIONINFO*        pOpenAllocation;
    VOID*                           pPrivateDriverData;
    UINT                            PrivateDriverSize;
    DXGK_OPENALLOCATIONFLAGS        Flags;
} DXGKARG_OPENALLOCATION;

typedef __inout CONST DXGKARG_OPENALLOCATION*   INOUT_CONST_PDXGKARG_OPENALLOCATION;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_OPENALLOCATIONINFO(
    IN_CONST_HANDLE                         hDevice,
    INOUT_CONST_PDXGKARG_OPENALLOCATION     pOpenAllocation
    );

typedef struct _DXGKARG_CLOSEALLOCATION
{
    UINT            NumAllocations;
    CONST HANDLE*   pOpenHandleList;    //in: hDeviceSpecificAllocation list
} DXGKARG_CLOSEALLOCATION;

typedef __in    CONST DXGKARG_CLOSEALLOCATION*  IN_CONST_PDXGKARG_CLOSEALLOCATION;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_CLOSEALLOCATION(
    IN_CONST_HANDLE                     hDevice,
    IN_CONST_PDXGKARG_CLOSEALLOCATION   pCloseAllocation
    );

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_DESTROYDEVICE(
    IN_CONST_HANDLE     hDevice
    );

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_DESTROYCONTEXT(
    IN_CONST_HANDLE     hContext
    );

typedef D3DKMT_HANDLE (APIENTRY CALLBACK *DXGKCB_GETHANDLEPARENT)(D3DKMT_HANDLE hAllocation);

typedef enum _DXGK_HANDLE_TYPE
{
    DXGK_HANDLE_ALLOCATION  = 1,
    DXGK_HANDLE_RESOURCE    = 2,
} DXGK_HANDLE_TYPE;

typedef struct _DXGKCB_GETHANDLEDATAFLAGS
{
    union
    {
        struct
        {
            UINT                DeviceSpecific  : 1;    // 0x00000001
            UINT                Reserved        :31;    // 0xFFFFFFFE
        };
        UINT Value;
    };
} DXGKCB_GETHANDLEDATAFLAGS;

typedef struct _DXGKARGCB_GETHANDLEDATA
{
    D3DKMT_HANDLE           hObject;
    DXGK_HANDLE_TYPE        Type;
    DXGKCB_GETHANDLEDATAFLAGS Flags;
} DXGKARGCB_GETHANDLEDATA;
typedef VOID*  (APIENTRY CALLBACK *DXGKCB_GETHANDLEDATA)(CONST DXGKARGCB_GETHANDLEDATA*);

typedef struct _DXGKARGCB_ENUMHANDLECHILDREN
{
    D3DKMT_HANDLE   hObject;
    UINT            Index;
} DXGKARGCB_ENUMHANDLECHILDREN;
typedef D3DKMT_HANDLE (APIENTRY CALLBACK *DXGKCB_ENUMHANDLECHILDREN)(CONST DXGKARGCB_ENUMHANDLECHILDREN*);

typedef struct _DXGKARGCB_GETCAPTUREADDRESS
{
    D3DKMT_HANDLE      hAllocation;          // in:  Allocation handle
    UINT               SegmentId;            // out: Segment ID of capture buffer
    PHYSICAL_ADDRESS   PhysicalAddress;      // out: Physical address of capture buffer
} DXGKARGCB_GETCAPTUREADDRESS;
typedef NTSTATUS (APIENTRY CALLBACK *DXGKCB_GETCAPTUREADDRESS)(DXGKARGCB_GETCAPTUREADDRESS*);

typedef struct _DXGK_DEVICEINFOFLAGS
{
    union
    {
        struct
        {
            UINT    GuaranteedDmaBufferContract : 1;    // 0x00000001
            UINT    Reserved                    :31;    // 0xFFFFFFFE
        };
        UINT Value;
    };
 } DXGK_DEVICEINFOFLAGS;

typedef struct _DXGK_DEVICEINFO
{
    UINT        DmaBufferSize;
    UINT        DmaBufferSegmentSet;
    UINT        DmaBufferPrivateDataSize;
    UINT        AllocationListSize;
    UINT        PatchLocationListSize;
    DXGK_DEVICEINFOFLAGS Flags;
} DXGK_DEVICEINFO;

typedef struct _DXGK_CREATEDEVICEFLAGS
{
    union
    {
        struct
        {

            UINT    SystemDevice   :  1;  // 0x00000001
            UINT    Reserved       : 31;  // 0xFFFFFFFE
        };
        UINT Value;
    };
} DXGK_CREATEDEVICEFLAGS;

typedef struct _DXGKARG_CREATEDEVICE
{
    HANDLE               hDevice;            // in:  Runtime handle/out: Driver handle
    union
    {
        DXGK_CREATEDEVICEFLAGS Flags;        // in:  device creation flags
        DXGK_DEVICEINFO*       pInfo;        // out: device info from driver (obsolate: backward compatibility only)
    };
} DXGKARG_CREATEDEVICE;

typedef __inout DXGKARG_CREATEDEVICE*   INOUT_PDXGKARG_CREATEDEVICE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_CREATEDEVICE(
    IN_CONST_HANDLE                 hAdapter,
    INOUT_PDXGKARG_CREATEDEVICE     pCreateDevice
    );

typedef struct _DXGK_CREATECONTEXTFLAGS
{
    union
    {
        struct
        {
            UINT    SystemContext   : 1;
            UINT    Reserved        : 31;
        };
        UINT Value;
    };
} DXGK_CREATECONTEXTFLAGS;

typedef struct _DXGK_CONTEXTINFO
{
    UINT        DmaBufferSize;
    UINT        DmaBufferSegmentSet;
    UINT        DmaBufferPrivateDataSize;
    UINT        AllocationListSize;
    UINT        PatchLocationListSize;
} DXGK_CONTEXTINFO;

typedef struct _DXGKARG_CREATECONTEXT
{
    HANDLE                  hContext;              // in:  Runtime handle/out: Driver handle
    UINT                    NodeOrdinal;           // in:  Node targetted for this context.
    UINT                    EngineAffinity;        // in:  Engine affinity.
    DXGK_CREATECONTEXTFLAGS Flags;                 // in:  Context creation flags.
    VOID*                   pPrivateDriverData;    // in:  Private driver data
    UINT                    PrivateDriverDataSize; // in:  Size of private driver data
    DXGK_CONTEXTINFO        ContextInfo;           // out: context info from driver
} DXGKARG_CREATECONTEXT;

typedef __inout DXGKARG_CREATECONTEXT*   INOUT_PDXGKARG_CREATECONTEXT;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_CREATECONTEXT(
    IN_CONST_HANDLE                 hDevice,
    INOUT_PDXGKARG_CREATECONTEXT    pCreateContext
    );

typedef __in CONST DXGKARG_SETPALETTE*      IN_CONST_PDXGKARG_SETPALETTE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_SETPALETTE(
    IN_CONST_HANDLE                 hAdapter,
    IN_CONST_PDXGKARG_SETPALETTE    pSetPalette
    );

typedef struct _DXGK_POINTERFLAGS
{
    union
    {
        struct
        {
            UINT    Monochrome      : 1;    // 0x00000001
            UINT    Color           : 1;    // 0x00000002
            UINT    MaskedColor     : 1;    // 0x00000004
            UINT    Reserved        :29;    // 0xFFFFFFF8
        };
        UINT        Value;
    };
} DXGK_POINTERFLAGS;

typedef struct _DXGKARG_SETPOINTERSHAPE
{
    DXGK_POINTERFLAGS               Flags;
    UINT                            Width;
    UINT                            Height;
    UINT                            Pitch;
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
    CONST VOID*                     pPixels;
    UINT                            XHot;
    UINT                            YHot;
} DXGKARG_SETPOINTERSHAPE;

//
//Flags specifies monochrome or color pointer or color pointer with alpha.
//
//Width is Width of the pointer in pixels.
//
//Height is Height of the pointer in scans.
//
//Pitch is Width of the pointer in bytes.
//
//VidPnSourceId is VidPN source ID of this adapter on which the pointer is being set.
//
//pPixels points to the start of color bitmap size of specified Width and Height
// in 32-bpp ARGB DIB format for non-monochrome pointers, or points to the start of
// monochrome bitmap size of specified Width and Height in 1-bpp DIB format AND mask
// followed by another 1-bpp DIB format XOR mask of the same size for monochrome pointers.
//
//XHot is column on which hot pixel is located from top left of pointer bitmap in pixels.
//
//YHot is row on which hot pixel is located from top left of pointer bitmap in pixels.
//

typedef __in CONST DXGKARG_SETPOINTERSHAPE*     IN_CONST_PDXGKARG_SETPOINTERSHAPE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_SETPOINTERSHAPE(
    IN_CONST_HANDLE                     hAdapter,
    IN_CONST_PDXGKARG_SETPOINTERSHAPE   pSetPointerShape
    );

typedef struct _DXGK_SETPOINTERPOSITIONFLAGS
{
    union
    {
        struct
        {
            UINT                        Visible : 1;    // 0x00000001
            UINT                        Reserved:31;    // 0xFFFFFFFE
        };
        UINT Value;
    };
} DXGK_SETPOINTERPOSITIONFLAGS;

typedef struct _DXGKARG_SETPOINTERPOSITION
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
    INT                             X;
    INT                             Y;
    DXGK_SETPOINTERPOSITIONFLAGS    Flags;
} DXGKARG_SETPOINTERPOSITION;

//
//Visible indicates if the pointer should be visible or not.
//X and Y should be ignored by driver if FALSE.
//
//Output is output index of this adapter.
//
//X is Column on which the top left pixel of cursor image is located
//from the top left pixel of the VidPN source in pixels.
//
//Y is Row on which the top left pixel of cusor image is located from
//the top left pixel of the VidPN source in pixels.
//

typedef __in CONST DXGKARG_SETPOINTERPOSITION*      IN_CONST_PDXGKARG_SETPOINTERPOSITION;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_SETPOINTERPOSITION(
    IN_CONST_HANDLE                         hAdapter,
    IN_CONST_PDXGKARG_SETPOINTERPOSITION    pSetPointerPosition
    );

typedef enum _DXGK_QUERYADAPTERINFOTYPE
{
    DXGKQAITYPE_UMDRIVERPRIVATE = 0,
    DXGKQAITYPE_DRIVERCAPS      = 1,
    DXGKQAITYPE_QUERYSEGMENT    = 2,
} DXGK_QUERYADAPTERINFOTYPE;

typedef struct _DXGK_GAMMARAMPCAPS
{
    union
    {
        struct
        {
            UINT    Gamma_Rgb256x3x16  : 1;    // 0x00000001
            UINT    Reserved           :31;    // 0xFFFFFFFC
        };
        UINT        Value;
    };
} DXGK_GAMMARAMPCAPS;

typedef struct _DXGK_PRESENTATIONCAPS
{
    union
    {
        struct
        {
            UINT    NoScreenToScreenBlt : 1;
            UINT    NoOverlapScreenBlt  : 1;
            UINT    Reserved            : 30;
        };
        UINT        Value;
    };
} DXGK_PRESENTATIONCAPS;

typedef struct _DXGK_FLIPCAPS
{
    union
    {
        struct
        {
            UINT    FlipOnVSyncWithNoWait : 1; // Support Flip on vsync via command buffer without wait.
            UINT    FlipOnVSyncMmIo       : 1; // Support Flip as mmio at vsync interrupt.
            UINT    FlipInterval          : 1; // Support FLIPINTERVAL_TWO, _THREE, _FOUR.
            UINT    FlipImmediateMmIo     : 1; // Support Flip as mmio immediate. 
            UINT    Reserved              :28;
        };
        UINT        Value;
    };
} DXGK_FLIPCAPS;

typedef struct _DXGK_VIDSCHCAPS
{
    union
    {
        struct
        {
            UINT    MultiEngineAware       :1;
            UINT    VSyncPowerSaveAware    :1;
            UINT    Reserved               :30;
        };
        UINT        Value;
    };
} DXGK_VIDSCHCAPS;

typedef struct _DXGK_VIDMMCAPS
{
    union
    {
        struct
        {
            UINT    OutOfOrderLock        : 1;
            UINT    Reserved              :31;
        };
        UINT        Value;
    };
    UINT            PagingNode;
} DXGK_VIDMMCAPS;

#define DXGK_MAX_ASYMETRICAL_PROCESSING_NODES  64
typedef struct _DXGK_GPUENGINETOPOLOGY
{
    UINT NbAsymetricProcessingNodes;
    UINT Reserved[DXGK_MAX_ASYMETRICAL_PROCESSING_NODES];
} DXGK_GPUENGINETOPOLOGY;

typedef struct _DXGK_DRIVERCAPS
{
    PHYSICAL_ADDRESS        HighestAcceptableAddress;
    UINT                    MaxAllocationListSlotId;
    SIZE_T                  ApertureSegmentCommitLimit;
    UINT                    MaxPointerWidth;
    UINT                    MaxPointerHeight;
    DXGK_POINTERFLAGS       PointerCaps;
    UINT                    InterruptMessageNumber;
    UINT                    NumberOfSwizzlingRanges;
    UINT                    MaxOverlays;
    DXGK_GAMMARAMPCAPS      GammaRampCaps;
    DXGK_PRESENTATIONCAPS   PresentationCaps;
    UINT                    MaxQueuedFlipOnVSync;
    DXGK_FLIPCAPS           FlipCaps;
    DXGK_VIDSCHCAPS         SchedulingCaps;
    DXGK_VIDMMCAPS          MemoryManagementCaps;
    DXGK_GPUENGINETOPOLOGY  GpuEngineTopology;
} DXGK_DRIVERCAPS;

// Segment Caps
typedef struct _DXGK_SEGMENTFLAGS
{
    union
    {
        struct
        {
            UINT    Aperture                    : 1;    // 0x00000001
            UINT    Agp                         : 1;    // 0x00000002
            UINT    CpuVisible                  : 1;    // 0x00000004
            UINT    UseBanking                  : 1;    // 0x00000008
            UINT    CacheCoherent               : 1;    // 0x00000010
            UINT    PitchAlignment              : 1;    // 0x00000020
            UINT    PopulatedFromSystemMemory   : 1;    // 0x00000040
            UINT    Reserved                    :25;    // 0xFFFFFF80
        };
        UINT        Value;
    };
} DXGK_SEGMENTFLAGS;

typedef struct _DXGK_SEGMENTDESCRIPTOR
{
    PHYSICAL_ADDRESS        BaseAddress;            // GPU logical base address for
                                                    // the segment.
    PHYSICAL_ADDRESS        CpuTranslatedAddress;   // CPU translated base address
                                                    // for the segment if CPU visible.
    SIZE_T                  Size;                   // Size of the segment.
    UINT                    NbOfBanks;              // Number of bank in the segment.
    SIZE_T*                 pBankRangeTable;        // Range delimiting each bank.
    SIZE_T                  CommitLimit;            // Maximum number of bytes that can be
                                                    // commited to this segment, apply to
                                                    // aperture segment only.
    DXGK_SEGMENTFLAGS   Flags;                  // Segment bit field flags
} DXGK_SEGMENTDESCRIPTOR;

typedef struct _DXGK_QUERYSEGMENTIN
{
    PHYSICAL_ADDRESS        AgpApertureBase;        // AGP aperture base address.
    LARGE_INTEGER           AgpApertureSize;        // Size of the available AGP aperture.
    DXGK_SEGMENTFLAGS   AgpFlags;               // Segment bit field flags
} DXGK_QUERYSEGMENTIN;

typedef struct _DXGK_QUERYSEGMENTOUT
{
    UINT                        NbSegment;              // Number of segment described.
    DXGK_SEGMENTDESCRIPTOR* pSegmentDescriptor;     // Buffer describing the segment.
    UINT                        PagingBufferSegmentId;  // SegmentId the paging buffer
                                                        // should be allocated from.
    UINT                        PagingBufferSize;       // Paging buffer size.
    UINT                        PagingBufferPrivateDataSize;
} DXGK_QUERYSEGMENTOUT;

typedef struct _DXGKARG_QUERYADAPTERINFO
{
    DXGK_QUERYADAPTERINFOTYPE   Type;
    VOID*                           pInputData;
    UINT                            InputDataSize;
    VOID*                           pOutputData;
    UINT                            OutputDataSize;
} DXGKARG_QUERYADAPTERINFO;

typedef __inout CONST DXGKARG_QUERYADAPTERINFO*   INOUT_CONST_PDXGKARG_QUERYADAPTERINFO;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_QUERYADAPTERINFO(
    IN_CONST_HANDLE                         hAdapter,
    INOUT_CONST_PDXGKARG_QUERYADAPTERINFO   pQueryAdapterInfo
    );

typedef struct _DXGKARG_ACQUIRESWIZZLINGRANGE
{
    HANDLE              hAllocation;
    UINT                PrivateDriverData;  // in: Passed in when UMD calls LockCB
    UINT                RangeId;
    UINT                SegmentId;
    SIZE_T              RangeSize;
    PHYSICAL_ADDRESS    CPUTranslatedAddress;
} DXGKARG_ACQUIRESWIZZLINGRANGE;

typedef __inout DXGKARG_ACQUIRESWIZZLINGRANGE*      INOUT_PDXGKARG_ACQUIRESWIZZLINGRANGE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_ACQUIRESWIZZLINGRANGE(
    IN_CONST_HANDLE                         hAdapter,
    INOUT_PDXGKARG_ACQUIRESWIZZLINGRANGE    pAcquireSwizzlingRange
    );

typedef struct _DXGKARG_RELEASESWIZZLINGRANGE
{
    HANDLE              hAllocation;
    UINT                PrivateDriverData;
    UINT                RangeId;
} DXGKARG_RELEASESWIZZLINGRANGE;

typedef __in CONST DXGKARG_RELEASESWIZZLINGRANGE*   IN_CONST_PDXGKARG_RELEASESWIZZLINGRANGE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_RELEASESWIZZLINGRANGE(
    IN_CONST_HANDLE                             hAdapter,
    IN_CONST_PDXGKARG_RELEASESWIZZLINGRANGE     pReleaseSwizzlingRange
    );

typedef struct _DXGK_ALLOCATIONINFOFLAGS
{
    union
    {
        struct
        {
            UINT    CpuVisible              : 1;    // 0x00000001
            UINT    PermanentSysMem         : 1;    // 0x00000002
            UINT    Cached                  : 1;    // 0x00000004
            UINT    Protected               : 1;    // 0x00000008
            UINT    ExistingSysMem          : 1;    // 0x00000010
            UINT    ExistingKernelSysMem    : 1;    // 0x00000020
            UINT    FromEndOfSegment        : 1;    // 0x00000040
            UINT    Swizzled                : 1;    // 0x00000080
            UINT    Overlay                 : 1;    // 0x00000100
            UINT    Capture                 : 1;    // 0x00000200
            UINT    UseAlternateVA          : 1;    // 0x00000400
            UINT    SynchronousPaging       : 1;    // 0x00000800
            UINT    LinkMirrored            : 1;    // 0x00001000
            UINT    LinkInstanced           : 1;    // 0x00002000
            UINT    Reserved                :13;    // 0x07FFC000 Following fields are RESERVED and
        };
        UINT Value;
    };
} DXGK_ALLOCATIONINFOFLAGS;

typedef struct _DXGK_ALLOCATIONUSAGEINFO1
{
    union
    {
        struct
        {
            UINT        PrivateFormat  : 1;     // 0x00000001 - Allocation is a private IHV format. Default is standard format.
            UINT        Swizzled       : 1;     // 0x00000002 - Allocation is swizzled/tiled.
            UINT        MipMap         : 1;     // 0x00000004 - Allocation is a mip mapped texture.
            UINT        Cube           : 1;     // 0x00000008 - Allocation is a cube texture.
            UINT        Volume         : 1;     // 0x00000010 - Allocation is a volume texture.
            UINT        Vertex         : 1;     // 0x00000020 - Allocation is a vertex buffer.
            UINT        Index          : 1;     // 0x00000040 - Allocation is an index buffer.
            UINT        Reserved       : 25;    // 0xFFFFFF80 - Reserved must be set to zero.
        };
        UINT            Value;
    } Flags;

    union
    {
        D3DDDIFORMAT    Format;                 // Allocation format (Flags.PrivateFormat==0)
        UINT            PrivateFormat;          // Allocation format (Flags.PrivateFormat==1)
    };

    UINT                SwizzledFormat;         // Swizzled format for the allocation (IHV private).
    UINT                ByteOffset;             // Offset within the VidMm allocation to the start of this allocation.
    UINT                Width;                  // Width (in pixel) of the allocation.
    UINT                Height;                 // Height (in line) of the allocation.
    UINT                Pitch;                  // Pitch (in bytes) of the allocation.
    UINT                Depth;                  // Depth (in level) of the allocation (mipmap/volume only).
    UINT                SlicePitch;             // Pitch from one level to another (cube/volume only).
} DXGK_ALLOCATIONUSAGEINFO1;

typedef struct _DXGK_ALLOCATIONUSAGEHINT
{
    UINT                            Version;
    DXGK_ALLOCATIONUSAGEINFO1       v1;
} DXGK_ALLOCATIONUSAGEHINT;

typedef struct _DXGK_ALLOCATIONINFO
{
    VOID*                             pPrivateDriverData;               // in: Private data for each allocation allocated by the user mode driver
    UINT                              PrivateDriverDataSize;            // in: Size of the private data
    UINT                              Alignment;
    SIZE_T                            Size;                             // out: Allocation size
    SIZE_T                            PitchAlignedSize;                 // out: Allocation pitch aligned size (for aperture segment requiring Pitch alignment only).
    DXGK_SEGMENTBANKPREFERENCE        HintedBank;
    DXGK_SEGMENTPREFERENCE            PreferredSegment;
    UINT                              SupportedReadSegmentSet;
    UINT                              SupportedWriteSegmentSet;
    UINT                              EvictionSegmentSet;
    UINT                              MaximumRenamingListLength;
    HANDLE                            hAllocation;                      // out: Private driver data for allocation
    DXGK_ALLOCATIONINFOFLAGS          Flags;                            // out: Except the reserved fields
    DXGK_ALLOCATIONUSAGEHINT*         pAllocationUsageHint;
    UINT                              AllocationPriority;               // out: Starting allocation priority.
} DXGK_ALLOCATIONINFO;

typedef struct _DXGK_CREATEALLOCATIONFLAGS
{
    union
    {
        struct
        {
            UINT                Resource    : 1;    // 0x00000001
            UINT                Reserved    :31;    // 0xFFFFFFFE
        };
        UINT                    Value;
    };
} DXGK_CREATEALLOCATIONFLAGS;

typedef struct _DXGKARG_CREATEALLOCATION
{
    CONST VOID*                 pPrivateDriverData;
    UINT                        PrivateDriverDataSize;
    UINT                        NumAllocations;
    DXGK_ALLOCATIONINFO*    pAllocationInfo;
    HANDLE                      hResource;
    DXGK_CREATEALLOCATIONFLAGS  Flags;
} DXGKARG_CREATEALLOCATION;

typedef __inout DXGKARG_CREATEALLOCATION*     INOUT_PDXGKARG_CREATEALLOCATION;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_CREATEALLOCATION(
    IN_CONST_HANDLE                     hAdapter,
    INOUT_PDXGKARG_CREATEALLOCATION     pCreateAllocation
    );

typedef struct _DXGKARG_DESCRIBEALLOCATION
{
    HANDLE                          hAllocation;                    //in: Driver returned handle in DXGK_ALLOCATIONINFO upon CreateAllocation
    UINT                            Width;                          //out:Width of specified allocation
    UINT                            Height;                         //out:Height of specified allocation
    D3DDDIFORMAT                    Format;                         //out:Format of specified allocation
    D3DDDI_MULTISAMPLINGMETHOD      MultisampleMethod;              //out:Multisample method used of specified allocation
    D3DDDI_RATIONAL                 RefreshRate;                    //out:RefreshRate the primary surface created with if applicable
    UINT                            PrivateDriverFormatAttribute;   //out:Private format attribute of specified allocation
} DXGKARG_DESCRIBEALLOCATION;

typedef __inout DXGKARG_DESCRIBEALLOCATION*     INOUT_PDXGKARG_DESCRIBEALLOCATION;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_DESCRIBEALLOCATION(
    IN_CONST_HANDLE                         hAdapter,
    INOUT_PDXGKARG_DESCRIBEALLOCATION       pDescribeAllocation
    );

typedef struct _DXGKARG_GETSTANDARDALLOCATIONDRIVERDATA
{
    D3DKMDT_STANDARDALLOCATION_TYPE         StandardAllocationType;     // in : Type of standard allocation to describe
    union
    {
        D3DKMDT_SHAREDPRIMARYSURFACEDATA*   pCreateSharedPrimarySurfaceData;
        D3DKMDT_SHADOWSURFACEDATA*          pCreateShadowSurfaceData;
        D3DKMDT_STAGINGSURFACEDATA*         pCreateStagingSurfaceData;
    };
    VOID*                                   pAllocationPrivateDriverData;       // in/out : If non-NULL ptr to buffer driver should place the PrivateDriverData that describes the allocation associated with this standard allocation
    UINT                                    AllocationPrivateDriverDataSize;    // out : Size of buffer required to hold the PrivateDriverData that describes the allocation for this standard allocation
    VOID*                                   pResourcePrivateDriverData;         // in/out : If non-NULL ptr to buffer driver should place the PrivateDriverData that describes the resource associated with this standard allocation
    UINT                                    ResourcePrivateDriverDataSize;      // out : Size of buffer required to hold the PrivateDriverData that describes the resource for this standard allocation
} DXGKARG_GETSTANDARDALLOCATIONDRIVERDATA;

typedef __inout DXGKARG_GETSTANDARDALLOCATIONDRIVERDATA*    INOUT_PDXGKARG_GETSTANDARDALLOCATIONDRIVERDATA;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_GETSTANDARDALLOCATIONDRIVERDATA(
    IN_CONST_HANDLE                                 hAdapter,
    INOUT_PDXGKARG_GETSTANDARDALLOCATIONDRIVERDATA  pGetStandardAllocationDriverData
    );

typedef struct _DXGK_DESTROYALLOCATIONFLAGS
{
    union
    {
        struct
        {
            UINT    DestroyResource : 1;    // 0x00000001
            UINT    Reserved        :31;    // 0xFFFFFFFE
        };
        UINT        Value;
    };
} DXGK_DESTROYALLOCATIONFLAGS;

typedef struct _DXGKARG_DESTROYALLOCATION
{
    UINT            NumAllocations;
    CONST HANDLE*   pAllocationList;
    HANDLE          hResource;
    DXGK_DESTROYALLOCATIONFLAGS Flags;
} DXGKARG_DESTROYALLOCATION;

typedef __in CONST DXGKARG_DESTROYALLOCATION*   IN_CONST_PDXGKARG_DESTROYALLOCATION;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_DESTROYALLOCATION(
    IN_CONST_HANDLE                         hAdapter,
    IN_CONST_PDXGKARG_DESTROYALLOCATION     pDestroyAllocation
    );

typedef struct _DXGK_PATCHFLAGS
{
    union
    {
        struct
        {
            UINT                    Paging              : 1;            // 0x00000001 command buffer is a paging buffer.
            UINT                    Present             : 1;            // 0x00000002 command buffer contain a present operation.
            UINT                    RedirectedPresent   : 1;            // 0x00000004 command buffer contains a redirected present operation.
            UINT                    NullRendering       : 1;            // 0x00000008 GPU should skip rendering of DMA buffer (perf analysis)
            UINT                    Reserved            :28;            // 0xFFFFFFF0
        };
        UINT                        Value;
    };
} DXGK_PATCHFLAGS;

typedef struct _DXGKARG_PATCH
{
    union
    {
        HANDLE                          hDevice;                                // in: driver device handle for driver not MultiEngineAware.
        HANDLE                          hContext;                               // in: driver context handle for MultiEngineAware driver.
    };
    UINT                            DmaBufferSegmentId;                         // in: segment id of DMA buffer
    PHYSICAL_ADDRESS                DmaBufferPhysicalAddress;                   // in: physical address of DMA buffer
    VOID*                           pDmaBuffer;                                 // in: Virtual address to beginning of
                                                                                //     the DMA buffer.
    UINT                            DmaBufferSize;                              // in: lenght of the DMA buffer..
    UINT                            DmaBufferSubmissionStartOffset;             // in: Byte offset from the beginning
                                                                                //     of the DMA buffer to the start
                                                                                //     of this submission.
    UINT                            DmaBufferSubmissionEndOffset;               // in: Byte offset from the beginning
                                                                                //     of the DMA buffer to the end of
                                                                                //     this submission.
    VOID*                           pDmaBufferPrivateData;                      // in: Virtual address to the private
                                                                                //     data associated with this DMA buffer.
    UINT                            DmaBufferPrivateDataSize;                   // in: Size of the private data.
    UINT                            DmaBufferPrivateDataSubmissionStartOffset;  // in: Byte offset from the beginning of the
                                                                                //     private data to the start of this
                                                                                //     submission.
    UINT                            DmaBufferPrivateDataSubmissionEndOffset;    // in: Byte offset from the beginning of the
                                                                                //     private data to the end of this
                                                                                //     submission.
    CONST DXGK_ALLOCATIONLIST*      pAllocationList;                            // in: Pointer to the allocation list
                                                                                //     associated with this DMA buffer.
    UINT                            AllocationListSize;                         // in: Size of the allocation list.
    CONST D3DDDI_PATCHLOCATIONLIST* pPatchLocationList;                         // in: Pointer to the patch location list associated
                                                                                //     with this DMA buffer.
    UINT                            PatchLocationListSize;                      // in: Size of the patch location list.
    UINT                            PatchLocationListSubmissionStart;           // in: First element for this submission.
    UINT                            PatchLocationListSubmissionLength;          // in: Number of element in this submission.
    UINT                            SubmissionFenceId;                          // in: Submission fence id.
    DXGK_PATCHFLAGS                 Flags;                                      // in: Flags
    UINT                            EngineOrdinal;                              // in: Engine Ordinal within it's node.
} DXGKARG_PATCH;

typedef __in CONST DXGKARG_PATCH*   IN_CONST_PDXGKARG_PATCH;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_PATCH(
    IN_CONST_HANDLE             hAdapter,
    IN_CONST_PDXGKARG_PATCH     pPatch
    );

typedef struct _DXGK_SUBMITCOMMANDFLAGS
{
    union
    {
        struct
        {
            UINT        Paging              : 1;    // command buffer is a paging buffer.
            UINT        Present             : 1;    // command buffer contain a present operation.
            UINT        RedirectedPresent   : 1;    // command buffer contains a redirected present operation.
            UINT        NullRendering       : 1;    // GPU should skip rendering of DMA buffer (perf analysis)
            UINT        Flip                : 1;    // command buffer is for flip.
            UINT        FlipWithNoWait      : 1;    // command buffer is for flip with no built-in-wait for next vsync.
            UINT        Reserved            :26;
        };
        UINT            Value;
    };
} DXGK_SUBMITCOMMANDFLAGS;

// Definition for DXGKARG_SUBMITCOMMAND
//
typedef struct _DXGKARG_SUBMITCOMMAND
{
    union
    {
        HANDLE          hDevice;                                    // in: driver device handle for driver not MultiEngineAware.
        HANDLE          hContext;                                   // in: driver context handle for MultiEngineAware driver.
    };
    UINT                DmaBufferSegmentId;                         // in: segment id of DMA buffer
    PHYSICAL_ADDRESS    DmaBufferPhysicalAddress;                   // in: physical address of DMA buffer
    UINT                DmaBufferSize;                              // in: lenght of the DMA buffer..
    UINT                DmaBufferSubmissionStartOffset;             // in: Byte offset from the beginning
                                                                    //     of the DMA buffer to the start
                                                                    //     of this submission.
    UINT                DmaBufferSubmissionEndOffset;               // in: Byte offset from the beginning
                                                                    //     of the DMA buffer to the end of
                                                                    //     this submission.
    VOID*               pDmaBufferPrivateData;                      // in: Virtual address to the private
                                                                    //     data associated with this DMA buffer.
    UINT                DmaBufferPrivateDataSize;                   // in: Size of the private data.
    UINT                DmaBufferPrivateDataSubmissionStartOffset;  // in: Byte offset from the beginning of the
                                                                    //     private data to the start of this
                                                                    //     submission.
    UINT                DmaBufferPrivateDataSubmissionEndOffset;    // in: Byte offset from the beginning of the
                                                                    //     private data to the end of this
                                                                    //     submission.
    UINT                SubmissionFenceId;                          // in: Submission fence id.
    D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId;                   // in: VidPnSourceId (flip only)
    D3DDDI_FLIPINTERVAL_TYPE       FlipInterval;                    // in: Flip Interval (flip only)
    DXGK_SUBMITCOMMANDFLAGS Flags;                                  // in: Flags
    UINT                EngineOrdinal;                              // in: Engine Ordinal within it's node.
} DXGKARG_SUBMITCOMMAND;

// Device Driver Interface to submit command buffer to h/w command execution unit.
//
typedef __in CONST DXGKARG_SUBMITCOMMAND*   IN_CONST_PDXGKARG_SUBMITCOMMAND;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_SUBMITCOMMAND(
    IN_CONST_HANDLE                     hAdapter,
    IN_CONST_PDXGKARG_SUBMITCOMMAND     pSubmitCommand
    );

typedef struct _DXGK_PREEMPTCOMMANDFLAGS
{
    union
    {
        struct
        {
            UINT        Reserved    :32;    // 0xFFFFFFFF
        };
        UINT            Value;
    };
} DXGK_PREEMPTCOMMANDFLAGS;

// Definition for DXGKARG_PREEMPTCOMMAND
//
typedef struct _DXGKARG_PREEMPTCOMMAND
{
    UINT                PreemptionFenceId;  // in: preemption uniqueness id
    UINT                NodeOrdinal;        // in: node ordinal to preempt
    UINT                EngineOrdinal;      // in: engine ordinal to preempt
    DXGK_PREEMPTCOMMANDFLAGS Flags;         // in: flags
} DXGKARG_PREEMPTCOMMAND;

// Device Driver Interface to preempt command.
//
typedef __in CONST DXGKARG_PREEMPTCOMMAND*      IN_CONST_PDXGKARG_PREEMPTCOMMAND;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_PREEMPTCOMMAND(
    IN_CONST_HANDLE                     hAdapter,
    IN_CONST_PDXGKARG_PREEMPTCOMMAND    pPreemptCommand
    );

// Definition for DXGKARG_QUERYCURRENTFENCE
//
typedef struct _DXGKARG_QUERYCURRENTFENCE
{
    UINT     CurrentFence;
    UINT     NodeOrdinal;
    UINT     EngineOrdinal;
} DXGKARG_QUERYCURRENTFENCE;

// Device Driver Interface to query completed submission fence.
//
typedef __inout DXGKARG_QUERYCURRENTFENCE* INOUT_PDXGKARG_QUERYCURRENTFENCE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_QUERYCURRENTFENCE(
    IN_CONST_HANDLE                    hAdapter,
    INOUT_PDXGKARG_QUERYCURRENTFENCE   pCurrentFence
    );

// Device Driver Interface to control vertical sync interrupt.
//
typedef __in CONST DXGK_INTERRUPT_TYPE      IN_CONST_DXGK_INTERRUPT_TYPE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_CONTROLINTERRUPT(
    IN_CONST_HANDLE                 hAdapter,
    IN_CONST_DXGK_INTERRUPT_TYPE    InterruptType,
    IN_BOOLEAN                      EnableInterrupt
    );

typedef enum _DXGK_BUILDPAGINGBUFFER_OPERATION
{
    DXGK_OPERATION_TRANSFER                 = 0,
    DXGK_OPERATION_FILL                     = 1,
    DXGK_OPERATION_DISCARD_CONTENT          = 2,
    DXGK_OPERATION_READ_PHYSICAL            = 3,
    DXGK_OPERATION_WRITE_PHYSICAL           = 4,
    DXGK_OPERATION_MAP_APERTURE_SEGMENT     = 5,
    DXGK_OPERATION_UNMAP_APERTURE_SEGMENT   = 6,
    DXGK_OPERATION_SPECIAL_LOCK_TRANSFER    = 7
} DXGK_BUILDPAGINGBUFFER_OPERATION;

typedef struct _DXGK_TRANSFERFLAGS
{
    union
    {
        struct
        {
            UINT    Swizzle             : 1;    // 0x00000001
            UINT    Unswizzle           : 1;    // 0x00000002
            UINT    AllocationIsIdle    : 1;    // 0x00000004
            UINT    TransferStart       : 1;    // 0x00000010
            UINT    TransferEnd         : 1;    //
            UINT    Reserved            :27;    // 0xFFFFFFF8
        };
        UINT        Value;
    };
} DXGK_TRANSFERFLAGS;

typedef struct _DXGK_DISCARDCONTENTFLAGS
{
    union
    {
        struct
        {
            UINT    AllocationIsIdle    : 1;    // 0x00000001
            UINT    Reserved            :31;    // 0xFFFFFFFE
        };
        UINT        Value;
    };
} DXGK_DISCARDCONTENTFLAGS;

typedef struct _DXGK_MAPAPERTUREFLAGS
{
    union
    {
        struct
        {
            UINT    CacheCoherent   : 1;    // 0x00000001
            UINT    Reserved        :31;    // 0xFFFFFFFE
        };
        UINT Value;
    };
} DXGK_MAPAPERTUREFLAGS;

typedef struct _DXGKARG_BUILDPAGINGBUFFER
{
    VOID*                                   pDmaBuffer;
    UINT                                    DmaSize;
    VOID*                                   pDmaBufferPrivateData;
    UINT                                    DmaBufferPrivateDataSize;
    DXGK_BUILDPAGINGBUFFER_OPERATION        Operation;
    UINT                                    MultipassOffset;
    union
    {
        struct
        {
            HANDLE  hAllocation;
            UINT    TransferOffset;
            SIZE_T  TransferSize;
            struct
            {
                UINT    SegmentId;
                union
                {
                    LARGE_INTEGER SegmentAddress;
                    MDL* pMdl;
                };
            } Source;
            struct
            {
                UINT    SegmentId;
                union
                {
                    LARGE_INTEGER SegmentAddress;
                    MDL* pMdl;
                };
            } Destination;
            DXGK_TRANSFERFLAGS  Flags;
            UINT MdlOffset;
        } Transfer;

        struct
        {
            HANDLE  hAllocation;
            SIZE_T  FillSize;
            UINT    FillPattern;
            struct
            {
                UINT SegmentId;
                LARGE_INTEGER SegmentAddress;
            } Destination;
        } Fill;

        struct
        {
            HANDLE hAllocation;
            DXGK_DISCARDCONTENTFLAGS Flags;
            UINT SegmentId;
            PHYSICAL_ADDRESS SegmentAddress;
        } DiscardContent;

        struct
        {
            UINT SegmentId;
            PHYSICAL_ADDRESS PhysicalAddress;
        } ReadPhysical;

        struct
        {
            UINT SegmentId;
            PHYSICAL_ADDRESS PhysicalAddress;
        } WritePhysical;

        struct
        {
            HANDLE  hDevice;
            HANDLE  hAllocation;
            UINT    SegmentId;
            SIZE_T  OffsetInPages;
            SIZE_T  NumberOfPages;
            PMDL    pMdl;
            DXGK_MAPAPERTUREFLAGS Flags;
            ULONG   MdlOffset;
        } MapApertureSegment;

        struct
        {
            HANDLE  hDevice;
            HANDLE  hAllocation;
            UINT    SegmentId;
            SIZE_T  OffsetInPages;
            SIZE_T  NumberOfPages;
            PHYSICAL_ADDRESS DummyPage;
        } UnmapApertureSegment;

        struct
        {
            HANDLE hAllocation;
            UINT   TransferOffset;
            SIZE_T TransferSize;
            struct
            {
                UINT SegmentId;
                union
                {
                    LARGE_INTEGER SegmentAddress;
                    MDL* pMdl;
                };
            } Source;
            struct
            {
                UINT SegmentId;
                union
                {
                    LARGE_INTEGER SegmentAddress;
                    MDL* pMdl;
                };
            } Destination;
            DXGK_TRANSFERFLAGS  Flags;
            UINT SwizzlingRangeId;
            UINT SwizzlingRangeData;
        } SpecialLockTransfer;

        struct
        {
            UINT    Reserved[64];
        } Reserved;
    };
    HANDLE hSystemContext;
} DXGKARG_BUILDPAGINGBUFFER;

// Device Driver Interface to build a paging buffer.
//
typedef __in DXGKARG_BUILDPAGINGBUFFER*     IN_PDXGKARG_BUILDPAGINGBUFFER;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_BUILDPAGINGBUFFER(
    IN_CONST_HANDLE                 hAdapter,
    IN_PDXGKARG_BUILDPAGINGBUFFER   pBuildPagingBuffer
    );

// DXGK_TRANSFERFLAGS.Swizzle
//
//   This indicates that the source should be swizzled to the destination.
//
// DXGK_TRANSFERFLAGS.Unswizzle
//
//   This indicates that the source should be unswizzled to the destination.
//
// DXGK_TRANSFERFLAGS.AllocationIsIdle
//
//   This indicates that the given allocation is idle, i.e. no work
//   has been queued or will be queued to the GPU referencing this
//   allocation until the call to DdiBuildPagingBuffer returns.
//
// DXGK_TRANSFERFLAGS.FillDestination
//
//   This indicates that the driver should fill the destination
//   with the provided pattern. No source is provided.
//

typedef struct _DXGKARG_ESCAPE
{
    HANDLE             hDevice;                // in: driver device handle
    D3DDDI_ESCAPEFLAGS Flags;                  // in: flags
    VOID*              pPrivateDriverData;     // in/out: escape data
    UINT               PrivateDriverDataSize;  // in: size of escape data
    HANDLE             hContext;               // in: driver context handle
} DXGKARG_ESCAPE;

typedef __inout CONST DXGKARG_ESCAPE*   INOUT_CONST_PDXGKARG_ESCAPE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_ESCAPE(
    IN_CONST_HANDLE                 hAdapter,
    INOUT_CONST_PDXGKARG_ESCAPE     pEscape
    );

#define DXGK_SECONDARY_BUCKETING_TAG ((DWORD)'bSsM')

typedef struct _DXGKARG_COLLECTDBGINFO_EXT
{
    UINT BucketingKey;           // out: Key for IHV specific secondary OCA bucketing
    UINT CurrentDmaBufferOffset; // out: execution offset in the current DMA buffer
    UINT Reserved2;
    UINT Reserved3;
    UINT Reserved4;
    UINT Reserved5;
    UINT Reserved6;
    UINT Reserved7;
} DXGKARG_COLLECTDBGINFO_EXT;

typedef struct _DXGKARG_COLLECTDBGINFO
{
    UINT    Reason;                         // in:  bugcheck code for debug report
    VOID*   pBuffer;                        // out: pointer to the buffer to save the info
    SIZE_T  BufferSize;                     // in:  maximum size of the buffer in bytes
    DXGKARG_COLLECTDBGINFO_EXT* pExtension; // out: optional extension
} DXGKARG_COLLECTDBGINFO;

typedef __inout CONST DXGKARG_COLLECTDBGINFO*   INOUT_CONST_PDXGKARG_COLLECTDBGINFO;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_COLLECTDBGINFO(
    IN_CONST_HANDLE                         hAdapter,
    INOUT_CONST_PDXGKARG_COLLECTDBGINFO     pCollectDbgInfo
    );

typedef struct _DXGK_OVERLAYINFO
{
    HANDLE                 hAllocation;           // in: Allocation to be displayed
    PHYSICAL_ADDRESS       PhysicalAddress;       // in: Physical address of allocation
    UINT                   SegmentId;             // in: Segment ID of allocation
    RECT                   DstRect;               // in: Source rect
    RECT                   SrcRect;               // in: Dest rect
    VOID*                  pPrivateDriverData;    // in: Private driver data
    UINT                   PrivateDriverDataSize; // in: Size of private driver data
} DXGK_OVERLAYINFO;

typedef struct _DXGKARG_CREATEOVERLAY
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId; // in:  VidPn where overlay is displayed
    DXGK_OVERLAYINFO               OverlayInfo;   // in:  Overlay info
    HANDLE                         hOverlay;      // out: Driver handle
} DXGKARG_CREATEOVERLAY;

typedef __inout DXGKARG_CREATEOVERLAY*      INOUT_PDXGKARG_CREATEOVERLAY;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_CREATEOVERLAY(
    IN_CONST_HANDLE                 hAdapter,
    INOUT_PDXGKARG_CREATEOVERLAY    pCreateOverlay
    );

typedef struct _DXGKARG_UPDATEOVERLAY
{
    DXGK_OVERLAYINFO       OverlayInfo;            // in: Overlay info
} DXGKARG_UPDATEOVERLAY;

typedef __in CONST DXGKARG_UPDATEOVERLAY*   IN_CONST_PDXGKARG_UPDATEOVERLAY;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_UPDATEOVERLAY(
    IN_CONST_HANDLE                     hOverlay,
    IN_CONST_PDXGKARG_UPDATEOVERLAY     pUpdateOverlay
    );

typedef struct _DXGKARG_FLIPOVERLAY
{
    HANDLE                 hSource;                // in: Source allocation
    PHYSICAL_ADDRESS       SrcPhysicalAddress;     // in: Physical address of source allocation
    UINT                   SrcSegmentId;           // in: Segment ID of source allocation
    VOID*                  pPrivateDriverData;     // in: Private driver data
    UINT                   PrivateDriverDataSize;  // in: Size of private driver data
} DXGKARG_FLIPOVERLAY;

typedef __in CONST DXGKARG_FLIPOVERLAY*     IN_CONST_PDXGKARG_FLIPOVERLAY;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_FLIPOVERLAY(
    IN_CONST_HANDLE                 hOverlay,
    IN_CONST_PDXGKARG_FLIPOVERLAY   pFlipOverlay
    );

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_DESTROYOVERLAY(
    IN_CONST_HANDLE     hOverlay
    );

typedef struct _DXGKARG_GETSCANLINE
{
    D3DDDI_VIDEO_PRESENT_TARGET_ID  VidPnTargetId;      // in: adapter's VidPN Target ID
    BOOLEAN                         InVerticalBlank;    // out: Within vertical blank
    UINT                            ScanLine;           // out: Current scan line
} DXGKARG_GETSCANLINE;

typedef __inout DXGKARG_GETSCANLINE*    INOUT_PDXGKARG_GETSCANLINE;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_GETSCANLINE(
    IN_CONST_HANDLE             hAdapter,
    INOUT_PDXGKARG_GETSCANLINE  pGetScanLine
    );

///////////////////////// LDDM display miniport VidPN management DDI /////////////////////////////


/*++
Routine Description:
    IsSupportedVidPn LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter                - LDDM display miniport adapter handle.

    pIsSupportedVidPnArg
       ->pDesiredVidPn      - VidPN whose support with respect to display adapter's capabilities
                              is in question.

       ->bIsVidPnSupported - Placeholder for the predicate specifying whether the specified VidPN
                             is supported by the specified display adapter.

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

    STATUS_NO_MEMORY
      - Low memory condition prevented successful completion of this request.

    One of the invalid parameter STATUS_GRAPHICS_* codes that can be returned by the OS via
    DXGDDI_VIDPN* interfaces. These codes should only occur during development since they
    indicate a bug in the driver or OS.

Remarks:
    Predicate specifying whether the provided VidPN configuration is supported (i.e. can be extended
    to a functional VidPN).

Assumptions:
    Specified VidPN must at a minimum specify a valid topology, but can also have some or all
    of its targets/sources configured with respectively pinned modes.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/
typedef struct _DXGKARG_ISSUPPORTEDVIDPN
{
    IN   D3DKMDT_HVIDPN                       hDesiredVidPn;
    OUT  BOOLEAN                              IsVidPnSupported;
} DXGKARG_ISSUPPORTEDVIDPN;

typedef __inout DXGKARG_ISSUPPORTEDVIDPN*     INOUT_PDXGKARG_ISSUPPORTEDVIDPN;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_ISSUPPORTEDVIDPN(
    IN_CONST_HANDLE                     hAdapter,
    INOUT_PDXGKARG_ISSUPPORTEDVIDPN     pIsSupportedVidPn
    );


/*++
Routine Description:
    EnumVidPnCofuncModality LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter                - LDDM display miniport adapter handle.

    hConstrainingVidPn      - VidPN whose cofunctional mode sets are to be (re)enumerated
                              with respect to its topology and pinned modes (if any).

    EnumPivotType           - Specifies what is the type of the mode enumeration pivot (if any).
                              No pivot is specified using D3DKMDT_EPT_NOPIVOT.

    EnumPivot.VidPnSourceId - If (EnumPivotType == D3DKMDT_EPT_VIDPNSOURCE), specifies the ID
                              of the VidPN source whose mode set must not be changed during the enumeration.
                              If EnumPivotType is D3DKMDT_EPT_SCALING or D3DKMDT_EPT_ROTATION,
                              the VidPnSourceId and VidPnTargetId specifies the path whose scaling or rotation support does
                              not need to be updated.
                              Undefined otherwise.

    EnumPivot.VidPnSourceId - If (EnumPivotType == D3DKMDT_EPT_VIDPNTARGET), specifies the ID
                              of the VidPN source whose mode set must not be changed during the enumeration.
                              If EnumPivotType is D3DKMDT_EPT_SCALING or D3DKMDT_EPT_ROTATION,
                              the VidPnSourceId and VidPnTargetId specifies the path whose scaling or rotation support does
                              not need to be updated.
                              Undefined otherwise.

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

    STATUS_NO_MEMORY
      - Low memory condition prevented successful completion of this request.

    One of the invalid parameter STATUS_GRAPHICS_* codes that can be returned by the OS via
    DXGDDI_VIDPN* interfaces. These codes should only occur during development since they
    indicate a bug in the driver or OS.

Remarks:
   Enumerates cofunctional video present source and target mode sets on each video present path
   in the specified VidPN's topology.

Assumptions:
    Specified VidPN's support has been confirmed via IsSupportedVidPn call by the OS.
    Miniport can assume it reported that it supports this VidPN.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/
typedef struct _DXGK_ENUM_PIVOT
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
    D3DDDI_VIDEO_PRESENT_TARGET_ID  VidPnTargetId;
} DXGK_ENUM_PIVOT;


typedef struct _DXGKARG_ENUMVIDPNCOFUNCMODALITY
{
    IN  D3DKMDT_HVIDPN                         hConstrainingVidPn;
    IN  D3DKMDT_ENUMCOFUNCMODALITY_PIVOT_TYPE  EnumPivotType;
    IN  DXGK_ENUM_PIVOT                        EnumPivot;
} DXGKARG_ENUMVIDPNCOFUNCMODALITY;

typedef __in CONST DXGKARG_ENUMVIDPNCOFUNCMODALITY* CONST       IN_CONST_PDXGKARG_ENUMVIDPNCOFUNCMODALITY_CONST;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_ENUMVIDPNCOFUNCMODALITY(
    IN_CONST_HANDLE                                     hAdapter,
    IN_CONST_PDXGKARG_ENUMVIDPNCOFUNCMODALITY_CONST     pEnumCofuncModality
    );


/*++
Routine Description:
    RecommendFunctionalVidPn LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter
      - LDDM display miniport adapter handle.

    pRecommendFunctionalVidPnArg

       ->NumberOfVidPnTargets
           - Number of VidPN target IDs listed in pVidPnTargetPrioritizationVector.

       ->pVidPnTargetPrioritizationVector
           - Vector of VidPN targets IDs, ordered most important first, representing the
             importance of monitors connected to them.

       ->hRecommendedFunctionalVidPn
           - Handle of an empty VidPN object to be populated by miniport with the
             functional VidPN recommended for the current state of display adapter.

       ->RequestReason
           - Type of reason behind OS'es request of a new functional VidPN.
             Note that hotkey, power, and thermal events are mapped directly from the
             respective invalidation reasons specified via
             DXGK_INTERFACESPECIFICDATA::pfnInvalidateActiveVidPn.

       ->hContext
           - Optional context originating from the miniport on calls such as
             DXGK_INTERFACESPECIFICDATA::pfnInvalidateActiveVidPn. When miniport needs
             to invalidate an active VidPN, it should pass private context to be received
             via this parameter so it could distinguish between different concurrent requests
             of the same type leading OS to request a new functional VidPN.

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

    STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN
      - Installed LDDM display adapter miniport has no VidPN recommendation
      for the current configuration of the display adapter.

    STATUS_NO_MEMORY
      - Low memory condition prevented successful completion of this request.

    One of the invalid parameter STATUS_GRAPHICS_* codes that can be returned by the OS via
    DXGDDI_{VIDPN|MONITOR}* interfaces. These codes should only occur during development since they
    indicate a bug in the driver or OS.

Remarks:
    Obtains a VidPN recommended by the LDDM display miniport, given the current state of the h/w.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/
typedef enum _DXGK_RECOMMENDFUNCTIONALVIDPN_REASON
{
    DXGK_RFVR_UNINITIALIZED  = 0,
    DXGK_RFVR_HOTKEY         = 1,
    DXGK_RFVR_USERMODE       = 2,
}
DXGK_RECOMMENDFUNCTIONALVIDPN_REASON;

typedef struct _DXGKARG_RECOMMENDFUNCTIONALVIDPN
{
    IN  UINT                                    NumberOfVidPnTargets;
    IN  CONST D3DDDI_VIDEO_PRESENT_TARGET_ID*   pVidPnTargetPrioritizationVector;
    IN  D3DKMDT_HVIDPN                          hRecommendedFunctionalVidPn;
    IN  DXGK_RECOMMENDFUNCTIONALVIDPN_REASON    RequestReason;
    IN  OPTIONAL VOID*                          pPrivateDriverData;
    IN  UINT                                    PrivateDriverDataSize;
} DXGKARG_RECOMMENDFUNCTIONALVIDPN;

typedef __in CONST DXGKARG_RECOMMENDFUNCTIONALVIDPN* CONST      IN_CONST_PDXGKARG_RECOMMENDFUNCTIONALVIDPN_CONST;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_RECOMMENDFUNCTIONALVIDPN(
    IN_CONST_HANDLE                                     hAdapter,
    IN_CONST_PDXGKARG_RECOMMENDFUNCTIONALVIDPN_CONST    pRecommendFunctionalVidPn
    );

/*++
Routine Description:
    SetVidPnSourceAddress LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter              - LDDM display miniport adapter handle.

    pSetVidPnSourceVisibility
       ->VidPnSourceId    - ID of the VidPN source whose state needs to be changed.

       ->PrimarySegment   - Segment of the primary surface to scan from.

       ->PrimaryAddress   - Address of the primary surface to scan from.

       ->hAllocation      - Driver assigned allocation handle for the primary surface

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

Side-effects:
    On success, adapters starts scanning from the specified primary surface on the specified VidPN source.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/

typedef struct _DXGK_SETVIDPNSOURCEADDRESS_FLAGS
{
    union
    {
        struct
        {

            UINT ModeChange      : 1;    // 0x00000001
            UINT FlipImmediate   : 1;    // 0x00000002
            UINT FlipOnNextVSync : 1;    // 0x00000004
            UINT Reserved        :29;    // 0xFFFFFFF8
        };
        UINT Value;
    };
} DXGK_SETVIDPNSOURCEADDRESS_FLAGS;

typedef struct _DXGKARG_SETVIDPNSOURCEADDRESS
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID   VidPnSourceId;
    UINT                             PrimarySegment;
    PHYSICAL_ADDRESS                 PrimaryAddress;
    HANDLE                           hAllocation;
    UINT                             ContextCount;
    HANDLE                           Context[1+D3DDDI_MAX_BROADCAST_CONTEXT];
    DXGK_SETVIDPNSOURCEADDRESS_FLAGS Flags;
} DXGKARG_SETVIDPNSOURCEADDRESS;

typedef __in CONST DXGKARG_SETVIDPNSOURCEADDRESS*   IN_CONST_PDXGKARG_SETVIDPNSOURCEADDRESS;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_SETVIDPNSOURCEADDRESS(
    IN_CONST_HANDLE                             hAdapter,
    IN_CONST_PDXGKARG_SETVIDPNSOURCEADDRESS     pSetVidPnSourceAddress
    );

/*++
Routine Description:
    SetVidPnSourceVisibility LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter              - LDDM display miniport adapter handle.

    pSetVidPnSourceVisibility
       ->VidPnSourceId    - ID of the VidPN source whose state needs to be changed.

       ->Visible          - Visible or not for the specified VidPN source.

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

Side-effects:
    When Visible == TRUE, tells the miniport to scan out data from the primary surface
    associated with the the specified VidPN source to the VidPN target(s) connected
    to that source by the active VidPN's topology.
    When Visible == FALSE, tells miniport the miniport to stop reading from the primary surface
    associated with the specified VidPN source and present black on all the VidPN targets
    connected to that source via by active VidPN's topology.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/

typedef struct _DXGKARG_SETVIDPNSOURCEVISIBILITY
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
    BOOLEAN                         Visible;
} DXGKARG_SETVIDPNSOURCEVISIBILITY;

typedef __in CONST DXGKARG_SETVIDPNSOURCEVISIBILITY*    IN_CONST_PDXGKARG_SETVIDPNSOURCEVISIBILITY;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_SETVIDPNSOURCEVISIBILITY(
    IN_CONST_HANDLE                             hAdapter,
    IN_CONST_PDXGKARG_SETVIDPNSOURCEVISIBILITY  pSetVidPnSourceVisibility
    );

/*++
Routine Description:
    CommitVidPn LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter                       - LDDM display miniport adapter handle.

    pCommitVidPnArg
       ->hFunctionalVidPn          - Handle of a functional VidPN to commit to h/w.

       ->AffectedVidPnSourceId     - ID of the VidPN source for which the commit should take place.

       ->MonitorConnectivityChecks - Specifies miniport whether to validate specified VidPN's topology
                                     against connected monitors or ignore its monitor connectivity checks.

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

    STATUS_NO_MEMORY
      - There is insufficient memory to complete this request.

    One of the invalid parameter STATUS_GRAPHICS_* codes that can be returned by the OS via
    DXGDDI_VIDPN* interfaces. These codes should only occur during development since they
    indicate a bug in the driver or OS.

Side-effects:
    Commits the specified functional VidPN to h/w.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/
typedef struct _DXGKARG_COMMITVIDPN_FLAGS
{
    UINT PathPowerTransition   :  1;
    UINT PathPoweredOff        :  1;
    UINT Reserved              : 30;
} DXGKARG_COMMITVIDPN_FLAGS;

typedef struct _DXGKARG_COMMITVIDPN
{
    IN  D3DKMDT_HVIDPN                      hFunctionalVidPn;
    IN  D3DDDI_VIDEO_PRESENT_SOURCE_ID      AffectedVidPnSourceId;
    IN  D3DKMDT_MONITOR_CONNECTIVITY_CHECKS MonitorConnectivityChecks;
    IN  HANDLE                              hPrimaryAllocation; // Driver assigned primary surface allocation handle.
    IN  DXGKARG_COMMITVIDPN_FLAGS           Flags;
} DXGKARG_COMMITVIDPN;

typedef __in CONST DXGKARG_COMMITVIDPN* CONST       IN_CONST_PDXGKARG_COMMITVIDPN_CONST;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_COMMITVIDPN(
    IN_CONST_HANDLE                         hAdapter,
    IN_CONST_PDXGKARG_COMMITVIDPN_CONST     pCommitVidPn
    );


/*++
Routine Description:
    UpdateActiveVidPnPresentPath LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter                   - LDDM display miniport adapter handle.

    pUpdateActiveVidPnPresentPathArg
       ->VidPnPresentPathInfo - VidPN present path information to update the respective
                                present path in the active VidPN with.

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

    STATUS_NO_MEMORY
      - There is insufficient memory to complete this request.

    One of the invalid parameter STATUS_GRAPHICS_* codes that can be returned by the OS via
    DXGDDI_VIDPN* interfaces. These codes should only occur during development since they
    indicate a bug in the driver or OS.

Side-effects:
    Updates settings on the specified VidPN present path of the active VidPN set on the adapter.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/
typedef struct _DXGKARG_UPDATEACTIVEVIDPNPRESENTPATH
{
    IN D3DKMDT_VIDPN_PRESENT_PATH  VidPnPresentPathInfo;
} DXGKARG_UPDATEACTIVEVIDPNPRESENTPATH;

typedef __in CONST DXGKARG_UPDATEACTIVEVIDPNPRESENTPATH* CONST      IN_CONST_PDXGKARG_UPDATEACTIVEVIDPNPRESENTPATH_CONST;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_UPDATEACTIVEVIDPNPRESENTPATH(
    IN_CONST_HANDLE                                         hAdapter,
    IN_CONST_PDXGKARG_UPDATEACTIVEVIDPNPRESENTPATH_CONST    pUpdateActiveVidPnPresentPath
    );


/*++
Routine Description:
    RecommendVidPnTopology LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter - LDDM display miniport adapter handle.

    pUpdateActiveVidPnPresentPathArg
       ->hVidPn - Handle of the VidPN whose topology is to be augmented with miniport's recommendation.

       ->VidPnSourceId - ID of the VidPN source for which miniport is asked to recommend path(s).

       ->RequestReason - Reason why OS asked for recommendation.

       ->hFallbackVidPn - Handle of the VidPN that OS will use if miniport provides no recommendation.

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

    STATUS_NO_MEMORY
      - There is insufficient memory to complete this request.

    STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY
      - Miniport has no recommendation for augmentation of the specified VidPN's topology.

    One of the invalid parameter STATUS_GRAPHICS_* codes that can be returned by the OS via
    DXGDDI_{VIDPN|MONITOR|* interfaces. These codes should only occur during development since they
    indicate a bug in the driver or OS.

Side-effects:
    On success, topology of the specified VidPN is augmented with miniport's recommendation with path(s)
    originating from the specified source.

Remarks:
    On success, miniport must add at least one path to the specified VidPN's source.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/
typedef enum _DXGK_RECOMMENDVIDPNTOPOLOGY_REASON
{
    DXGK_RVT_UNINITIALIZED              = 0,
    DXGK_RVT_INITIALIZATION_NOLKG       = 1,
    DXGK_RVT_AUGMENTATION_NOLKG         = 2,
    DXGK_RVT_AUGMENTATION_LKGOVERRIDE   = 3,
    DXGK_RVT_INITIALIZATION_LKGOVERRIDE = 4,

    // DEPRECATED: To be removed in RC0.
    // NOTE: These are left to avoid forcing IHVs to update their code with the new enum names this late in Beta2.
    DXGK_RVT_INITIALIZATION                       = 1,
    DXGK_RVT_FIRSTAVAILTARGETAUGMENTATIONOVERRIDE = 2,
    DXGK_RVT_LKGTARGETAUGMENTATIONOVERRIDE        = 3,
}
DXGK_RECOMMENDVIDPNTOPOLOGY_REASON;

typedef struct _DXGKARG_RECOMMENDVIDPNTOPOLOGY
{
    IN D3DKMDT_HVIDPN                      hVidPn;
    IN D3DDDI_VIDEO_PRESENT_SOURCE_ID      VidPnSourceId;
    IN DXGK_RECOMMENDVIDPNTOPOLOGY_REASON  RequestReason;
    IN D3DKMDT_HVIDPNTOPOLOGY              hFallbackTopology;
} DXGKARG_RECOMMENDVIDPNTOPOLOGY;

typedef __in CONST DXGKARG_RECOMMENDVIDPNTOPOLOGY* CONST    IN_CONST_PDXGKARG_RECOMMENDVIDPNTOPOLOGY_CONST;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_RECOMMENDVIDPNTOPOLOGY(
    IN_CONST_HANDLE                                 hAdapter,
    IN_CONST_PDXGKARG_RECOMMENDVIDPNTOPOLOGY_CONST  pRecommendVidPnTopology
    );


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DXGK_VIDPNTOPOLOGY_INTERFACE
// NOTE: Exposed by OS to miniport via DXGK_VIDPN_INTERFACE::pfnGetTopology

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_GETNUMPATHS)
        (CONST D3DKMDT_HVIDPNTOPOLOGY  hVidPnTopology,
         __out SIZE_T*                 pNumPaths);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_GETNUMPATHSFROMSOURCE)
        (CONST D3DKMDT_HVIDPNTOPOLOGY          hVidPnTopology,
         CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId,
         __out SIZE_T*                         pNumPathsFromSource);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_ENUMPATHTARGETSFROMSOURCE)
        (CONST D3DKMDT_HVIDPNTOPOLOGY            hVidPnTopology,
         CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID    VidPnSourceId,
         CONST D3DKMDT_VIDPN_PRESENT_PATH_INDEX  VidPnPresentPathIndex,
         __out D3DDDI_VIDEO_PRESENT_TARGET_ID*   pVidPnTargetId);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_GETPATHSOURCEFROMTARGET)
        (CONST D3DKMDT_HVIDPNTOPOLOGY           hVidTopology,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID   VidPnTargetId,
         __out D3DDDI_VIDEO_PRESENT_SOURCE_ID*  pVidPnSourceId);

// NOTE: To dispose of use DXGDMM_VIDPNTOPOLOGY_INTERFACE::pfnReleasePathInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_ACQUIREPATHINFO)
        (CONST D3DKMDT_HVIDPNTOPOLOGY              hVidPnTopology,
         CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID      VidPnSourceId,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID      VidPnTargetId,
         __out CONST D3DKMDT_VIDPN_PRESENT_PATH**  pVidPnPresentPathInfo);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_ACQUIREFIRSTPATHINFO)
        (CONST D3DKMDT_HVIDPNTOPOLOGY              hVidPnTopology,
         __out CONST D3DKMDT_VIDPN_PRESENT_PATH**  ppFirstVidPnPresentPathInfo);


typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_ACQUIRENEXTPATHINFO)
        (CONST D3DKMDT_HVIDPNTOPOLOGY              hVidPnTopology,
         CONST D3DKMDT_VIDPN_PRESENT_PATH* CONST   pVidPnPresentPathInfo,
         __out CONST D3DKMDT_VIDPN_PRESENT_PATH**  ppNextVidPnPresentPathInfo);

// NOTE: This updates what the path supports for transformations.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_UPDATEPATHSUPPORTINFO)
        (CONST D3DKMDT_HVIDPNTOPOLOGY              i_hVidPnTopology,
         CONST D3DKMDT_VIDPN_PRESENT_PATH*         i_pVidPnPresentPathInfo);

// NOTE: To dispose of use DXGDMM_VIDPNTOPOLOGY_INTERFACE::pfnReleasePathInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_RELEASEPATHINFO)
        (CONST D3DKMDT_HVIDPNTOPOLOGY             hVidPnTopology,
         CONST D3DKMDT_VIDPN_PRESENT_PATH* CONST  pVidPnPresentPathInfo);

// NOTE: To dispose of use DXGDMM_VIDPNTOPOLOGY_INTERFACE::pfnReleasePathInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_CREATENEWPATHINFO)
        (CONST D3DKMDT_HVIDPNTOPOLOGY        hVidPnTopology,
         __out D3DKMDT_VIDPN_PRESENT_PATH**  ppNewVidPnPresentPathInfo);

// NOTE: Releases the new path info, rendering it inaccessible.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_ADDPATH)
        (D3DKMDT_HVIDPNTOPOLOGY             hVidPnTopology,
         D3DKMDT_VIDPN_PRESENT_PATH* CONST  pVidPnPresentPath);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTOPOLOGY_REMOVEPATH)
        (D3DKMDT_HVIDPNTOPOLOGY                hVidPnTopology,
         CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID  VidPnTargetId);

typedef struct _DXGK_VIDPNTOPOLOGY_INTERFACE
{
    DXGKDDI_VIDPNTOPOLOGY_GETNUMPATHS                pfnGetNumPaths;
    DXGKDDI_VIDPNTOPOLOGY_GETNUMPATHSFROMSOURCE      pfnGetNumPathsFromSource;
    DXGKDDI_VIDPNTOPOLOGY_ENUMPATHTARGETSFROMSOURCE  pfnEnumPathTargetsFromSource;
    DXGKDDI_VIDPNTOPOLOGY_GETPATHSOURCEFROMTARGET    pfnGetPathSourceFromTarget;
    DXGKDDI_VIDPNTOPOLOGY_ACQUIREPATHINFO            pfnAcquirePathInfo;
    DXGKDDI_VIDPNTOPOLOGY_ACQUIREFIRSTPATHINFO       pfnAcquireFirstPathInfo;
    DXGKDDI_VIDPNTOPOLOGY_ACQUIRENEXTPATHINFO        pfnAcquireNextPathInfo;
    DXGKDDI_VIDPNTOPOLOGY_UPDATEPATHSUPPORTINFO      pfnUpdatePathSupportInfo;
    DXGKDDI_VIDPNTOPOLOGY_RELEASEPATHINFO            pfnReleasePathInfo;
    DXGKDDI_VIDPNTOPOLOGY_CREATENEWPATHINFO          pfnCreateNewPathInfo;
    DXGKDDI_VIDPNTOPOLOGY_ADDPATH                    pfnAddPath;
    DXGKDDI_VIDPNTOPOLOGY_REMOVEPATH                 pfnRemovePath;
} DXGK_VIDPNTOPOLOGY_INTERFACE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DXGK_VIDPNSOURCEMODESET_INTERFACE (exposed by OS to miniport)
// NOTE: Exposed by OS to miniport via DXGK_VIDPN_INTERFACE::pfnAcquireSourceModeSet.

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNSOURCEMODESET_GETNUMMODES)
        (CONST D3DKMDT_HVIDPNSOURCEMODESET  hVidPnSourceModeSet,
         __out SIZE_T* CONST                pNumSourceModes);

// NOTE: To dispose of use DXGK_VIDPNSOURCEMODESET_INTERFACE::pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNSOURCEMODESET_ACQUIREFIRSTMODEINFO)
        (CONST D3DKMDT_HVIDPNSOURCEMODESET        hVidPnSourceModeSet,
         __out CONST D3DKMDT_VIDPN_SOURCE_MODE**  ppFirstVidPnSourceModeInfo);

// NOTE: To dispose of use DXGK_VIDPNSOURCEMODESET_INTERFACE::pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNSOURCEMODESET_ACQUIRENEXTMODEINFO)
        (CONST D3DKMDT_HVIDPNSOURCEMODESET        hVidPnSourceModeSet,
         CONST D3DKMDT_VIDPN_SOURCE_MODE* CONST   pVidPnSourceModeInfo,
         __out CONST D3DKMDT_VIDPN_SOURCE_MODE**  ppNextVidPnSourceModeInfo);

// NOTE: To dispose of use DXGK_VIDPNSOURCEMODESET_INTERFACE::pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNSOURCEMODESET_ACQUIREPINNEDMODEINFO)
        (CONST D3DKMDT_HVIDPNSOURCEMODESET        hVidPnSourceModeSet,
         __out CONST D3DKMDT_VIDPN_SOURCE_MODE**  ppPinnedVidPnSourceModeInfo);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNSOURCEMODESET_RELEASEMODEINFO)
        (CONST D3DKMDT_HVIDPNSOURCEMODESET       hVidPnSourceModeSet,
         CONST D3DKMDT_VIDPN_SOURCE_MODE* CONST  pVidPnSourceModeInfo);

// NOTE: To dispose of use DXGK_VIDPNSOURCEMODESET_INTERFACE::pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNSOURCEMODESET_CREATENEWMODEINFO)
        (CONST D3DKMDT_HVIDPNSOURCEMODESET  hVidPnSourceModeSet,
         __out D3DKMDT_VIDPN_SOURCE_MODE**  ppNewVidPnSourceModeInfo);

// NOTE: On success, releases the new mode info, rendering it inaccessible.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNSOURCEMODESET_ADDMODE)
        (D3DKMDT_HVIDPNSOURCEMODESET        hVidPnSourceModeSet,
         D3DKMDT_VIDPN_SOURCE_MODE* CONST   pVidPnSourceModeInfo);

// NOTE: Mode ID is assigned to the mode by Windows Graphics Kernel at creation time
//       using DXGK_VIDPNSOURCEMODESET_INTERFACE::pfnCreateNewModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNSOURCEMODESET_PINMODE)
        (D3DKMDT_HVIDPNSOURCEMODESET                 hVidPnSourceModeSet,
         CONST D3DKMDT_VIDEO_PRESENT_SOURCE_MODE_ID  VidPnSourceModeId);

typedef struct _DXGK_VIDPNSOURCEMODESET_INTERFACE
{
    DXGKDDI_VIDPNSOURCEMODESET_GETNUMMODES              pfnGetNumModes;
    DXGKDDI_VIDPNSOURCEMODESET_ACQUIREFIRSTMODEINFO     pfnAcquireFirstModeInfo;
    DXGKDDI_VIDPNSOURCEMODESET_ACQUIRENEXTMODEINFO      pfnAcquireNextModeInfo;
    DXGKDDI_VIDPNSOURCEMODESET_ACQUIREPINNEDMODEINFO    pfnAcquirePinnedModeInfo;
    DXGKDDI_VIDPNSOURCEMODESET_RELEASEMODEINFO          pfnReleaseModeInfo;
    DXGKDDI_VIDPNSOURCEMODESET_CREATENEWMODEINFO        pfnCreateNewModeInfo;
    DXGKDDI_VIDPNSOURCEMODESET_ADDMODE                  pfnAddMode;
    DXGKDDI_VIDPNSOURCEMODESET_PINMODE                  pfnPinMode;
} DXGK_VIDPNSOURCEMODESET_INTERFACE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DXGK_VIDPNTARGETMODESET_INTERFACE
// NOTE: Exposed by OS to miniport via DXGK_VIDPN_INTERFACE::pfnAcquireTargetModeSet.

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTARGETMODESET_GETNUMMODES)
        (CONST D3DKMDT_HVIDPNTARGETMODESET  hVidPnTargetModeSet,
         __out SIZE_T* CONST                pNumTargetModes);

// NOTE: To dispose of use pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTARGETMODESET_ACQUIREFIRSTMODEINFO)
        (CONST D3DKMDT_HVIDPNTARGETMODESET        hVidPnTargetModeSet,
         __out CONST D3DKMDT_VIDPN_TARGET_MODE**  ppFirstVidPnTargetModeInfo);

// NOTE: To dispose of use pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTARGETMODESET_ACQUIRENEXTMODEINFO)
        (CONST D3DKMDT_HVIDPNTARGETMODESET        hVidPnTargetModeSet,
         CONST D3DKMDT_VIDPN_TARGET_MODE* CONST   pVidPnTargetModeInfo,
         __out CONST D3DKMDT_VIDPN_TARGET_MODE**  ppNextVidPnTargetModeInfo);

// NOTE: To dispose of use pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTARGETMODESET_ACQUIREPINNEDMODEINFO)
        (CONST D3DKMDT_HVIDPNTARGETMODESET        hVidPnTargetModeSet,
         __out CONST D3DKMDT_VIDPN_TARGET_MODE**  ppPinnedVidPnTargetModeInfo);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTARGETMODESET_RELEASEMODEINFO)
        (CONST D3DKMDT_HVIDPNTARGETMODESET       hVidPnTargetModeSet,
         CONST D3DKMDT_VIDPN_TARGET_MODE* CONST  pVidPnTargetModeInfo);

// NOTE: To dispose of use pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTARGETMODESET_CREATENEWMODEINFO)
        (CONST D3DKMDT_HVIDPNTARGETMODESET  hVidPnTargetModeSet,
         __out D3DKMDT_VIDPN_TARGET_MODE**  ppNewVidPnTargetModeInfo);

// NOTE: On success, releases the new mode info, rendering it inaccessible.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTARGETMODESET_ADDMODE)
        (D3DKMDT_HVIDPNTARGETMODESET        hVidPnTargetModeSet,
         D3DKMDT_VIDPN_TARGET_MODE* CONST   pVidPnTargetModeInfo);

// NOTE: Mode ID is assigned to the mode by Windows Graphics Kernel at creation time
//       using DXGKTARGETMODESET_INTERFACE::pfnCreateNewModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPNTARGETMODESET_PINMODE)
        (D3DKMDT_HVIDPNTARGETMODESET                 hVidPnTargetModeSet,
         CONST D3DKMDT_VIDEO_PRESENT_TARGET_MODE_ID  VidPnTargetModeId);

typedef struct _DXGK_VIDPNTARGETMODESET_INTERFACE
{
    DXGKDDI_VIDPNTARGETMODESET_GETNUMMODES              pfnGetNumModes;
    DXGKDDI_VIDPNTARGETMODESET_ACQUIREFIRSTMODEINFO     pfnAcquireFirstModeInfo;
    DXGKDDI_VIDPNTARGETMODESET_ACQUIRENEXTMODEINFO      pfnAcquireNextModeInfo;
    DXGKDDI_VIDPNTARGETMODESET_ACQUIREPINNEDMODEINFO    pfnAcquirePinnedModeInfo;
    DXGKDDI_VIDPNTARGETMODESET_RELEASEMODEINFO          pfnReleaseModeInfo;
    DXGKDDI_VIDPNTARGETMODESET_CREATENEWMODEINFO        pfnCreateNewModeInfo;
    DXGKDDI_VIDPNTARGETMODESET_ADDMODE                  pfnAddMode;
    DXGKDDI_VIDPNTARGETMODESET_PINMODE                  pfnPinMode;
} DXGK_VIDPNTARGETMODESET_INTERFACE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DXGK_VIDPN_INTERFACE
// NOTE: Exposed by OS to miniport via DXGK_INTERFACESPECIFICDATA::pfnQueryVidPnInterface.

//////////////
// Topology //
//////////////

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_GETTOPOLOGY)
        (CONST D3DKMDT_HVIDPN                         hVidPn,
         __out D3DKMDT_HVIDPNTOPOLOGY*                phVidPnTopology,
         __out CONST DXGK_VIDPNTOPOLOGY_INTERFACE**   ppVidPnTopologyInterface);


/////////////////////
// Source modality //
/////////////////////

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_ACQUIRESOURCEMODESET)
        (CONST D3DKMDT_HVIDPN                              hVidPn,
         CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID              VidPnSourceId,
         __out D3DKMDT_HVIDPNSOURCEMODESET*                phVidPnSourceModeSet,
         __out CONST DXGK_VIDPNSOURCEMODESET_INTERFACE**   ppVidPnSourceModeSetInterface);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_RELEASESOURCEMODESET)
        (CONST D3DKMDT_HVIDPN               hVidPn,
         CONST D3DKMDT_HVIDPNSOURCEMODESET  hVidPnSourceModeSet);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_CREATENEWSOURCEMODESET)
        (CONST D3DKMDT_HVIDPN                             hVidPn,
         CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID             VidPnSourceId,
         __out D3DKMDT_HVIDPNSOURCEMODESET*               phNewVidPnSourceModeSet,
         __out CONST DXGK_VIDPNSOURCEMODESET_INTERFACE**  ppVidPnSourceModeSetInterface);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_ASSIGNSOURCEMODESET)
        (D3DKMDT_HVIDPN                        hVidPn,
         CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId,
         CONST D3DKMDT_HVIDPNSOURCEMODESET     hVidPnSourceModeSet);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_ASSIGNMULTISAMPLINGMETHODSET)
        (D3DKMDT_HVIDPN                        hVidPn,
         CONST D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId,
         CONST SIZE_T                          NumMethods,
         CONST D3DDDI_MULTISAMPLINGMETHOD*     pSupportedMethodSet);


/////////////////////
// Target modality //
/////////////////////

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_ACQUIRETARGETMODESET)
        (CONST D3DKMDT_HVIDPN                              hVidPn,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID              VidPnTargetId,
         __out D3DKMDT_HVIDPNTARGETMODESET*                phVidPnTargetModeSet,
         __out CONST DXGK_VIDPNTARGETMODESET_INTERFACE**   ppVidPnTargetModeSetInterface);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_RELEASETARGETMODESET)
        (CONST D3DKMDT_HVIDPN               hVidPn,
         CONST D3DKMDT_HVIDPNTARGETMODESET  hVidPnTargetModeSet);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_CREATENEWTARGETMODESET)
        (CONST D3DKMDT_HVIDPN                              hVidPn,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID              VidPnTargetId,
         __out D3DKMDT_HVIDPNTARGETMODESET*                phNewVidPnTargetModeSet,
         __out CONST DXGK_VIDPNTARGETMODESET_INTERFACE**   ppVidPnTargetModeSetInterace);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_VIDPN_ASSIGNTARGETMODESET)
        (D3DKMDT_HVIDPN                        hVidPn,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID  VidPnTargetId,
         CONST D3DKMDT_HVIDPNTARGETMODESET     hVidPnTargetModeSet);


// DXGK_VIDPN_INTERFACE interface versions.
typedef enum _DXGK_VIDPN_INTERFACE_VERSION
{
    DXGK_VIDPN_INTERFACE_VERSION_UNINITIALIZED = 0,
    DXGK_VIDPN_INTERFACE_VERSION_V1            = 1,
} DXGK_VIDPN_INTERFACE_VERSION;

typedef struct _DXGK_VIDPN_INTERFACE
{
    // Specifies the version of this interface as well as all the sub-interfaces, which are accessible
    // only via this interface (i.e. DXGK_VIDPNTOPOLOGY_INTERFACE, DXGK_VIDPNSOURCEMODESET_INTERFACE,
    // and DXGK_VIDPNTARGETMODESET_INTERFACE).
    DXGK_VIDPN_INTERFACE_VERSION                 Version;

    // Topology
    DXGKDDI_VIDPN_GETTOPOLOGY                    pfnGetTopology;

    // Source modality
    DXGKDDI_VIDPN_ACQUIRESOURCEMODESET           pfnAcquireSourceModeSet;
    DXGKDDI_VIDPN_RELEASESOURCEMODESET           pfnReleaseSourceModeSet;
    DXGKDDI_VIDPN_CREATENEWSOURCEMODESET         pfnCreateNewSourceModeSet;
    DXGKDDI_VIDPN_ASSIGNSOURCEMODESET            pfnAssignSourceModeSet;
    DXGKDDI_VIDPN_ASSIGNMULTISAMPLINGMETHODSET   pfnAssignMultisamplingMethodSet;

    // Target modality
    DXGKDDI_VIDPN_ACQUIRETARGETMODESET           pfnAcquireTargetModeSet;
    DXGKDDI_VIDPN_RELEASETARGETMODESET           pfnReleaseTargetModeSet;
    DXGKDDI_VIDPN_CREATENEWTARGETMODESET         pfnCreateNewTargetModeSet;
    DXGKDDI_VIDPN_ASSIGNTARGETMODESET            pfnAssignTargetModeSet;
}
DXGK_VIDPN_INTERFACE;


// Callback miniport uses to query DXGK_VIDPN_INTERFACE.
typedef NTSTATUS
        (APIENTRY CALLBACK *DXGKCB_QUERYVIDPNINTERFACE)
        (CONST D3DKMDT_HVIDPN                hVidPn,
         CONST DXGK_VIDPN_INTERFACE_VERSION  VidPnInterfaceVersion,
         __out CONST DXGK_VIDPN_INTERFACE**  ppVidPnInterface);


/////////////////////////////
// Monitor source modality //
/////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DXGK_MONITORSOURCEMODESET_INTERFACE
// NOTE: Exposed by OS to miniport via DXGK_MONITOR_INTERFACE::pfnAcquireMonitorSourceModeSet.

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORSOURCEMODESET_GETNUMMODES)
        (CONST D3DKMDT_HMONITORSOURCEMODESET  hMonitorSourceModeSet,
         __out SIZE_T* CONST                  pNumMonitorSourceModes);

// NOTE: To dispose of use pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORSOURCEMODESET_ACQUIREPREFERREDMODEINFO)
        (CONST D3DKMDT_HMONITORSOURCEMODESET        hMonitorSourceModeSet,
         __out CONST D3DKMDT_MONITOR_SOURCE_MODE**  ppFirstMonitorSourceModeInfo);

// NOTE: To dispose of use pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORSOURCEMODESET_ACQUIREFIRSTMODEINFO)
        (CONST D3DKMDT_HMONITORSOURCEMODESET        hMonitorSourceModeSet,
         __out CONST D3DKMDT_MONITOR_SOURCE_MODE**  ppFirstMonitorSourceModeInfo);

// NOTE: To dispose of use pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORSOURCEMODESET_ACQUIRENEXTMODEINFO)
        (CONST D3DKMDT_HMONITORSOURCEMODESET        hMonitorSourceModeSet,
         CONST D3DKMDT_MONITOR_SOURCE_MODE* CONST   pMonitorSourceModeInfo,
         __out CONST D3DKMDT_MONITOR_SOURCE_MODE**  ppNextMonitorSourceModeInfo);

// NOTE: To dispose of use pfnReleaseModeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORSOURCEMODESET_CREATENEWMODEINFO)
        (CONST D3DKMDT_HMONITORSOURCEMODESET  hMonitorSourceModeSet,
         __out D3DKMDT_MONITOR_SOURCE_MODE**  ppNewMonitorSourceModeInfo);

// NOTE: On success, releases the new mode info, rendering it inaccessible.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORSOURCEMODESET_ADDMODE)
        (D3DKMDT_HMONITORSOURCEMODESET        hMonitorSourceModeSet,
         D3DKMDT_MONITOR_SOURCE_MODE* CONST   pMonitorSourceModeInfo);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORSOURCEMODESET_RELEASEMODEINFO)
        (CONST D3DKMDT_HMONITORSOURCEMODESET       hMonitorSourceModeSet,
         CONST D3DKMDT_MONITOR_SOURCE_MODE* CONST  pMonitorSourceModeInfo);


typedef struct _DXGK_MONITORSOURCEMODESET_INTERFACE
{
    DXGKDDI_MONITORSOURCEMODESET_GETNUMMODES               pfnGetNumModes;
    DXGKDDI_MONITORSOURCEMODESET_ACQUIREPREFERREDMODEINFO  pfnAcquirePreferredModeInfo;
    DXGKDDI_MONITORSOURCEMODESET_ACQUIREFIRSTMODEINFO      pfnAcquireFirstModeInfo;
    DXGKDDI_MONITORSOURCEMODESET_ACQUIRENEXTMODEINFO       pfnAcquireNextModeInfo;
    DXGKDDI_MONITORSOURCEMODESET_CREATENEWMODEINFO         pfnCreateNewModeInfo;
    DXGKDDI_MONITORSOURCEMODESET_ADDMODE                   pfnAddMode;
    DXGKDDI_MONITORSOURCEMODESET_RELEASEMODEINFO           pfnReleaseModeInfo;
} DXGK_MONITORSOURCEMODESET_INTERFACE;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DXGK_MONITORFREQUENCYRANGESET_INTERFACE
// NOTE: Exposed by OS to miniport via DXGK_MONITOR_INTERFACE::pfnAcquireMonitorFrequencyRangeSet.

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORFREQUENCYRANGESET_GETNUMFREQUENCYRANGES)
        (CONST D3DKMDT_HMONITORFREQUENCYRANGESET  hMonitorFrequencyRangeSet,
         __out SIZE_T* CONST                      pNumMonitorFrequencyRanges);

// NOTE: To dispose of use pfnReleaseFrequencyRangeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORFREQUENCYRANGESET_ACQUIREFIRSTFREQUENCYRANGEINFO)
        (CONST D3DKMDT_HMONITORFREQUENCYRANGESET        hMonitorFrequencyRangeSet,
         __out CONST D3DKMDT_MONITOR_FREQUENCY_RANGE**  ppFirstMonitorFrequencyRangeInfo);

// NOTE: To dispose of use pfnReleaseFrequencyRangeInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORFREQUENCYRANGESET_ACQUIRENEXTFREQUENCYRANGEINFO)
        (CONST D3DKMDT_HMONITORFREQUENCYRANGESET        hMonitorFrequencyRangeSet,
         CONST D3DKMDT_MONITOR_FREQUENCY_RANGE* CONST   pMonitorFrequencyRangeInfo,
         __out CONST D3DKMDT_MONITOR_FREQUENCY_RANGE**  ppNextMonitorFrequencyRangeInfo);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORFREQUENCYRANGESET_RELEASEFREQUENCYRANGEINFO)
        (CONST D3DKMDT_HMONITORFREQUENCYRANGESET       hMonitorFrequencyRangeSet,
         CONST D3DKMDT_MONITOR_FREQUENCY_RANGE* CONST  pMonitorFrequencyRangeInfo);

typedef struct _DXGK_MONITORFREQUENCYRANGESET_INTERFACE
{
    DXGKDDI_MONITORFREQUENCYRANGESET_GETNUMFREQUENCYRANGES           pfnGetNumFrequencyRanges;
    DXGKDDI_MONITORFREQUENCYRANGESET_ACQUIREFIRSTFREQUENCYRANGEINFO  pfnAcquireFirstFrequencyRangeInfo;
    DXGKDDI_MONITORFREQUENCYRANGESET_ACQUIRENEXTFREQUENCYRANGEINFO   pfnAcquireNextFrequencyRangeInfo;
    DXGKDDI_MONITORFREQUENCYRANGESET_RELEASEFREQUENCYRANGEINFO       pfnReleaseFrequencyRangeInfo;
} DXGK_MONITORFREQUENCYRANGESET_INTERFACE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DXGK_MONITORDESCRIPTORSET_INTERFACE
// NOTE: Exposed by OS to miniport via DXGK_MONITOR_INTERFACE::pfnAcquireMonitorDescriptorSet.

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORDESCRIPTORSET_GETNUMDESCRIPTORS)
        (CONST D3DKMDT_HMONITORDESCRIPTORSET  hMonitorDescriptorSet,
         __out SIZE_T* CONST                  pNumMonitorDescriptors);

// NOTE: To dispose of use pfnReleaseDescriptorInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORDESCRIPTORSET_ACQUIREFIRSTDESCRIPTORINFO)
        (CONST D3DKMDT_HMONITORDESCRIPTORSET       hMonitorDescriptorSet,
         __out CONST D3DKMDT_MONITOR_DESCRIPTOR**  ppFirstMonitorDescriptorInfo);

// NOTE: To dispose of use pfnReleaseDescriptorInfo.
typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORDESCRIPTORSET_ACQUIRENEXTDESCRIPTORINFO)
        (CONST D3DKMDT_HMONITORDESCRIPTORSET       hMonitorDescriptorSet,
         CONST D3DKMDT_MONITOR_DESCRIPTOR* CONST   pMonitorDescriptorInfo,
         __out CONST D3DKMDT_MONITOR_DESCRIPTOR**  ppNextMonitorDescriptorInfo);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITORDESCRIPTORSET_RELEASEDESCRIPTORINFO)
        (CONST D3DKMDT_HMONITORDESCRIPTORSET      hMonitorDescriptorSet,
         CONST D3DKMDT_MONITOR_DESCRIPTOR* CONST  pMonitorDescriptorInfo);

typedef struct _DXGK_MONITORDESCRIPTORSET_INTERFACE
{
    DXGKDDI_MONITORDESCRIPTORSET_GETNUMDESCRIPTORS           pfnGetNumDescriptors;
    DXGKDDI_MONITORDESCRIPTORSET_ACQUIREFIRSTDESCRIPTORINFO  pfnAcquireFirstDescriptorInfo;
    DXGKDDI_MONITORDESCRIPTORSET_ACQUIRENEXTDESCRIPTORINFO   pfnAcquireNextDescriptorInfo;
    DXGKDDI_MONITORDESCRIPTORSET_RELEASEDESCRIPTORINFO       pfnReleaseDescriptorInfo;
} DXGK_MONITORDESCRIPTORSET_INTERFACE;



typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITOR_ACQUIREMONITORSOURCEMODESET)
        (CONST D3DKMDT_ADAPTER                              hAdapter,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID               VideoPresentTargetId,
         __out D3DKMDT_HMONITORSOURCEMODESET*               phMonitorSourceModeSet,
         __out CONST DXGK_MONITORSOURCEMODESET_INTERFACE**  ppMonitorSourceModeSetInterface);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITOR_RELEASEMONITORSOURCEMODESET)
        (CONST D3DKMDT_ADAPTER                hAdapter,
         CONST D3DKMDT_HMONITORSOURCEMODESET  hMonitorSourceModeSet);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITOR_GETMONITORFREQUENCYRANGESET)
        (CONST D3DKMDT_ADAPTER                                  hAdapter,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID                   VideoPresentTargetId,
         __out D3DKMDT_HMONITORFREQUENCYRANGESET*               phMonitorFrequencyRangeSet,
         __out CONST DXGK_MONITORFREQUENCYRANGESET_INTERFACE**  ppMonitorFrequencyRangeSetInterface);

typedef NTSTATUS
        (APIENTRY *DXGKDDI_MONITOR_GETMONITORDESCRIPTORSET)
        (CONST D3DKMDT_ADAPTER                              hAdapter,
         CONST D3DDDI_VIDEO_PRESENT_TARGET_ID               VideoPresentTargetId,
         __out D3DKMDT_HMONITORDESCRIPTORSET*               phMonitorDescriptorSet,
         __out CONST DXGK_MONITORDESCRIPTORSET_INTERFACE**  ppMonitorDescriptorSetInterface);


// DXGK_MONITOR_INTERFACE interface versions.
typedef enum _DXGK_MONITOR_INTERFACE_VERSION
{
    DXGK_MONITOR_INTERFACE_VERSION_UNINITIALIZED = 0,
    DXGK_MONITOR_INTERFACE_VERSION_V1            = 1,
} DXGK_MONITOR_INTERFACE_VERSION;

typedef struct _DXGK_MONITOR_INTERFACE
{
    // Specifies the version of this interface as well as all the sub-interfaces, which are accessible
    // only via this interface (i.e. DXGK_VIDPNTOPOLOGY_INTERFACE, DXGK_VIDPNSOURCEMODESET_INTERFACE,
    // and DXGK_VIDPNTARGETMODESET_INTERFACE).
    DXGK_MONITOR_INTERFACE_VERSION                 Version;

    DXGKDDI_MONITOR_ACQUIREMONITORSOURCEMODESET    pfnAcquireMonitorSourceModeSet;
    DXGKDDI_MONITOR_RELEASEMONITORSOURCEMODESET    pfnReleaseMonitorSourceModeSet;
    DXGKDDI_MONITOR_GETMONITORFREQUENCYRANGESET    pfnGetMonitorFrequencyRangeSet;
    DXGKDDI_MONITOR_GETMONITORDESCRIPTORSET        pfnGetMonitorDescriptorSet;
}
DXGK_MONITOR_INTERFACE;

// Callback miniport uses to query DXGK_MONITOR_INTERFACE.
typedef NTSTATUS
        (APIENTRY CALLBACK *DXGKCB_QUERYMONITORINTERFACE)
        (CONST HANDLE                          hAdapter,
         CONST DXGK_MONITOR_INTERFACE_VERSION  MonitorInterfaceVersion,
         __out CONST DXGK_MONITOR_INTERFACE**  ppMonitorInterface);



//////////////////// Timeout Detection and Recovery /////////////////////////////////////////////////////////
typedef
    __checkReturn
NTSTATUS
APIENTRY CALLBACK
DXGKDDI_RESETFROMTIMEOUT(
    IN_CONST_HANDLE     hAdapter
    );

typedef
    __checkReturn
NTSTATUS
APIENTRY CALLBACK
DXGKDDI_RESTARTFROMTIMEOUT(
    IN_CONST_HANDLE     hAdapter
    );

typedef enum _DXGK_ACTIVE_VIDPN_INVALIDATION_REASON
{
    DXGK_AVIR_UNINITIALIZED = DXGK_RFVR_UNINITIALIZED,
    DXGK_AVIR_HOTKEY        = DXGK_RFVR_HOTKEY,
    DXGK_AVIR_USERMODE      = DXGK_RFVR_USERMODE,
}
DXGK_ACTIVE_VIDPN_INVALIDATION_REASON;

typedef struct _DXGK_INTERFACESPECIFICDATA
{
    HANDLE hAdapter;       // in: handle to dxgkrnl's adapter object

    //
    // D3DDDI interface callback functions
    //
    DXGKCB_GETHANDLEDATA          pfnGetHandleDataCb;
    DXGKCB_GETHANDLEPARENT        pfnGetHandleParentCb;
    DXGKCB_ENUMHANDLECHILDREN     pfnEnumHandleChildrenCb;
    DXGKCB_NOTIFY_INTERRUPT       pfnNotifyInterruptCb;
    DXGKCB_NOTIFY_DPC             pfnNotifyDpcCb;
    DXGKCB_QUERYVIDPNINTERFACE    pfnQueryVidPnInterfaceCb;
    DXGKCB_GETCAPTUREADDRESS      pfnGetCaptureAddressCb;
} DXGK_INTERFACESPECIFICDATA;


typedef struct _DXGKARG_SETDISPLAYPRIVATEDRIVERFORMAT
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;                  // in: Identifies which VidPn we are changing the private driver format attribute of
    HANDLE                          PrimaryAllocation;              // in: If non zero specifies the current primary allocation for the given VidPn    
    UINT                            PrivateDriverFormatAttribute;   // in: PrivateFormatAttribute to set for the given VidPn
} DXGKARG_SETDISPLAYPRIVATEDRIVERFORMAT;

typedef __in DXGKARG_SETDISPLAYPRIVATEDRIVERFORMAT*    IN_CONST_PDXGKARG_SETDISPLAYPRIVATEDRIVERFORMAT;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_SETDISPLAYPRIVATEDRIVERFORMAT(
    IN_CONST_HANDLE                                 hAdapter,
    IN_CONST_PDXGKARG_SETDISPLAYPRIVATEDRIVERFORMAT pSetDisplayPrivateDriverFormat
    );


/*++
Routine Description:
    RecommendMonitorModes LDDM display miniport VidPN management DDI method

Arguments:
    hAdapter           - LDDM display miniport adapter handle.

    pUpdateActiveVidPnPresentPathArg
       ->VideoPresentTargetId - ID of the video present target to which the monitor in question is connected.

       ->hMonitorSourceModeSet - Handle of the monitor mode set.

       ->pMonitorSourceModeSetInterface - Reference to the monitor mode set interface.

Return Value:
    STATUS_SUCCESS
      - Request has been completed successfully.

    STATUS_NO_MEMORY
      - There is insufficient memory to complete this request.

    One of the invalid parameter STATUS_GRAPHICS_* codes that can be returned by the OS via
    DXGDDI_{VIDPN|MONITOR|* interfaces. These codes should only occur during development since they
    indicate a bug in the driver or OS.

Side-effects:
    On success, optionally, adds one or more monitor source modes to the mode set of the monitor connected to the specified target.

Environment:
    Kernel mode. PASSIVE_LEVEL.

--*/
typedef struct _DXGKARG_RECOMMENDMONITORMODES
{
    IN D3DDDI_VIDEO_PRESENT_TARGET_ID              VideoPresentTargetId;
    IN D3DKMDT_HMONITORSOURCEMODESET               hMonitorSourceModeSet;
    IN CONST DXGK_MONITORSOURCEMODESET_INTERFACE*  pMonitorSourceModeSetInterface;

} DXGKARG_RECOMMENDMONITORMODES;

typedef __in CONST DXGKARG_RECOMMENDMONITORMODES* CONST     IN_CONST_PDXGKARG_RECOMMENDMONITORMODES_CONST;

typedef
    __checkReturn
NTSTATUS
APIENTRY
DXGKDDI_RECOMMENDMONITORMODES(
    IN_CONST_HANDLE                                 hAdapter,
    IN_CONST_PDXGKARG_RECOMMENDMONITORMODES_CONST   pRecommendMonitorModes
    );

//
//     Function pointer typedefs
//

typedef DXGKDDI_QUERYADAPTERINFO                *PDXGKDDI_QUERYADAPTERINFO;
typedef DXGKDDI_CREATEDEVICE                    *PDXGKDDI_CREATEDEVICE;
typedef DXGKDDI_CREATEALLOCATION                *PDXGKDDI_CREATEALLOCATION;
typedef DXGKDDI_DESTROYALLOCATION               *PDXGKDDI_DESTROYALLOCATION;
typedef DXGKDDI_DESCRIBEALLOCATION              *PDXGKDDI_DESCRIBEALLOCATION;
typedef DXGKDDI_GETSTANDARDALLOCATIONDRIVERDATA *PDXGKDDI_GETSTANDARDALLOCATIONDRIVERDATA;
typedef DXGKDDI_ACQUIRESWIZZLINGRANGE           *PDXGKDDI_ACQUIRESWIZZLINGRANGE;
typedef DXGKDDI_RELEASESWIZZLINGRANGE           *PDXGKDDI_RELEASESWIZZLINGRANGE;
typedef DXGKDDI_PATCH                           *PDXGKDDI_PATCH;
typedef DXGKDDI_SUBMITCOMMAND                   *PDXGKDDI_SUBMITCOMMAND;
typedef DXGKDDI_PREEMPTCOMMAND                  *PDXGKDDI_PREEMPTCOMMAND;
typedef DXGKDDI_BUILDPAGINGBUFFER               *PDXGKDDI_BUILDPAGINGBUFFER;
typedef DXGKDDI_SETPALETTE                      *PDXGKDDI_SETPALETTE;
typedef DXGKDDI_SETPOINTERPOSITION              *PDXGKDDI_SETPOINTERPOSITION;
typedef DXGKDDI_SETPOINTERSHAPE                 *PDXGKDDI_SETPOINTERSHAPE;
typedef DXGKDDI_RESETFROMTIMEOUT                *PDXGKDDI_RESETFROMTIMEOUT;
typedef DXGKDDI_RESTARTFROMTIMEOUT              *PDXGKDDI_RESTARTFROMTIMEOUT;
typedef DXGKDDI_ESCAPE                          *PDXGKDDI_ESCAPE;
typedef DXGKDDI_COLLECTDBGINFO                  *PDXGKDDI_COLLECTDBGINFO;
typedef DXGKDDI_QUERYCURRENTFENCE               *PDXGKDDI_QUERYCURRENTFENCE;
typedef DXGKDDI_ISSUPPORTEDVIDPN                *PDXGKDDI_ISSUPPORTEDVIDPN;
typedef DXGKDDI_RECOMMENDFUNCTIONALVIDPN        *PDXGKDDI_RECOMMENDFUNCTIONALVIDPN;
typedef DXGKDDI_ENUMVIDPNCOFUNCMODALITY         *PDXGKDDI_ENUMVIDPNCOFUNCMODALITY;
typedef DXGKDDI_SETVIDPNSOURCEADDRESS           *PDXGKDDI_SETVIDPNSOURCEADDRESS;
typedef DXGKDDI_SETVIDPNSOURCEVISIBILITY        *PDXGKDDI_SETVIDPNSOURCEVISIBILITY;
typedef DXGKDDI_COMMITVIDPN                     *PDXGKDDI_COMMITVIDPN;
typedef DXGKDDI_UPDATEACTIVEVIDPNPRESENTPATH    *PDXGKDDI_UPDATEACTIVEVIDPNPRESENTPATH;
typedef DXGKDDI_RECOMMENDMONITORMODES           *PDXGKDDI_RECOMMENDMONITORMODES;
typedef DXGKDDI_RECOMMENDVIDPNTOPOLOGY          *PDXGKDDI_RECOMMENDVIDPNTOPOLOGY;
typedef DXGKDDI_GETSCANLINE                     *PDXGKDDI_GETSCANLINE;
typedef DXGKDDI_STOPCAPTURE                     *PDXGKDDI_STOPCAPTURE;
typedef DXGKDDI_CONTROLINTERRUPT                *PDXGKDDI_CONTROLINTERRUPT;
typedef DXGKDDI_CREATEOVERLAY                   *PDXGKDDI_CREATEOVERLAY;
typedef DXGKDDI_DESTROYDEVICE                   *PDXGKDDI_DESTROYDEVICE;
typedef DXGKDDI_OPENALLOCATIONINFO              *PDXGKDDI_OPENALLOCATIONINFO;
typedef DXGKDDI_CLOSEALLOCATION                 *PDXGKDDI_CLOSEALLOCATION;
typedef DXGKDDI_RENDER                          *PDXGKDDI_RENDER;
typedef DXGKDDI_PRESENT                         *PDXGKDDI_PRESENT;
typedef DXGKDDI_UPDATEOVERLAY                   *PDXGKDDI_UPDATEOVERLAY;
typedef DXGKDDI_FLIPOVERLAY                     *PDXGKDDI_FLIPOVERLAY;
typedef DXGKDDI_DESTROYOVERLAY                  *PDXGKDDI_DESTROYOVERLAY;
typedef DXGKDDI_CREATECONTEXT                   *PDXGKDDI_CREATECONTEXT;
typedef DXGKDDI_DESTROYCONTEXT                  *PDXGKDDI_DESTROYCONTEXT;
typedef DXGKDDI_SETDISPLAYPRIVATEDRIVERFORMAT   *PDXGKDDI_SETDISPLAYPRIVATEDRIVERFORMAT;

#endif /* _D3DKMDDI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\datacontainerversion.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for datacontainerversion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __datacontainerversion_h__
#define __datacontainerversion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSDataContainerVersion_FWD_DEFINED__
#define __IWMSDataContainerVersion_FWD_DEFINED__
typedef interface IWMSDataContainerVersion IWMSDataContainerVersion;
#endif 	/* __IWMSDataContainerVersion_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_datacontainerversion_0000_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from datacontainerversion.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_IWMSDataContainerVersion, 0x3AE75C14,0x2B3A,0x11d2,0x9E,0xF7,0x00,0x60,0x97,0xD2,0xD7,0xCF );
typedef /* [public] */ 
enum WMS_DATA_CONTAINER_VERSION_CACHE_FLAGS
    {	WMS_DATA_CONTAINER_VERSION_ALLOW_PROXY_CACHING	= 0x1,
	WMS_DATA_CONTAINER_VERSION_ALLOW_PLAYER_CACHING	= 0x2,
	WMS_DATA_CONTAINER_VERSION_ALLOW_STREAM_SPLITTING	= 0x4
    } 	WMS_DATA_CONTAINER_VERSION_CACHE_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_datacontainerversion_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_datacontainerversion_0000_0000_v0_0_s_ifspec;

#ifndef __IWMSDataContainerVersion_INTERFACE_DEFINED__
#define __IWMSDataContainerVersion_INTERFACE_DEFINED__

/* interface IWMSDataContainerVersion */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSDataContainerVersion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3AE75C14-2B3A-11d2-9EF7-006097D2D7CF")
    IWMSDataContainerVersion : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLastModifiedTime( 
            /* [out] */ __RPC__out DATE *pdateLastModifiedTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLastModifiedTime( 
            /* [in] */ DATE dateLastModifiedTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExpirationTime( 
            /* [out] */ __RPC__out DATE *pdateExpirationTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetExpirationTime( 
            /* [in] */ DATE dateExpirationTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCacheFlags( 
            /* [out] */ __RPC__out long *plFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCacheFlags( 
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetContentSize( 
            /* [out] */ __RPC__out long *plContentSizeLow,
            /* [out] */ __RPC__out long *plContentSizeHigh) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetContentSize( 
            /* [in] */ long lContentSizeLow,
            /* [in] */ long lContentSizeHigh) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetEntityTagCount( 
            /* [out] */ __RPC__out long *plNumEntityTags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetEntityTag( 
            /* [in] */ long lTagNum,
            /* [out] */ __RPC__deref_out_opt BSTR *pszEntityTag) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetEntityTag( 
            /* [in] */ __RPC__in BSTR szEntityTag) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ __RPC__in_opt IWMSDataContainerVersion *pVersion,
            /* [out] */ __RPC__out VARIANT_BOOL *pvfEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSDataContainerVersionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSDataContainerVersion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSDataContainerVersion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSDataContainerVersion * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLastModifiedTime )( 
            IWMSDataContainerVersion * This,
            /* [out] */ __RPC__out DATE *pdateLastModifiedTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLastModifiedTime )( 
            IWMSDataContainerVersion * This,
            /* [in] */ DATE dateLastModifiedTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExpirationTime )( 
            IWMSDataContainerVersion * This,
            /* [out] */ __RPC__out DATE *pdateExpirationTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetExpirationTime )( 
            IWMSDataContainerVersion * This,
            /* [in] */ DATE dateExpirationTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCacheFlags )( 
            IWMSDataContainerVersion * This,
            /* [out] */ __RPC__out long *plFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCacheFlags )( 
            IWMSDataContainerVersion * This,
            /* [in] */ long lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetContentSize )( 
            IWMSDataContainerVersion * This,
            /* [out] */ __RPC__out long *plContentSizeLow,
            /* [out] */ __RPC__out long *plContentSizeHigh);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetContentSize )( 
            IWMSDataContainerVersion * This,
            /* [in] */ long lContentSizeLow,
            /* [in] */ long lContentSizeHigh);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetEntityTagCount )( 
            IWMSDataContainerVersion * This,
            /* [out] */ __RPC__out long *plNumEntityTags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetEntityTag )( 
            IWMSDataContainerVersion * This,
            /* [in] */ long lTagNum,
            /* [out] */ __RPC__deref_out_opt BSTR *pszEntityTag);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetEntityTag )( 
            IWMSDataContainerVersion * This,
            /* [in] */ __RPC__in BSTR szEntityTag);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IWMSDataContainerVersion * This,
            /* [in] */ __RPC__in_opt IWMSDataContainerVersion *pVersion,
            /* [out] */ __RPC__out VARIANT_BOOL *pvfEqual);
        
        END_INTERFACE
    } IWMSDataContainerVersionVtbl;

    interface IWMSDataContainerVersion
    {
        CONST_VTBL struct IWMSDataContainerVersionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSDataContainerVersion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSDataContainerVersion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSDataContainerVersion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSDataContainerVersion_GetLastModifiedTime(This,pdateLastModifiedTime)	\
    ( (This)->lpVtbl -> GetLastModifiedTime(This,pdateLastModifiedTime) ) 

#define IWMSDataContainerVersion_SetLastModifiedTime(This,dateLastModifiedTime)	\
    ( (This)->lpVtbl -> SetLastModifiedTime(This,dateLastModifiedTime) ) 

#define IWMSDataContainerVersion_GetExpirationTime(This,pdateExpirationTime)	\
    ( (This)->lpVtbl -> GetExpirationTime(This,pdateExpirationTime) ) 

#define IWMSDataContainerVersion_SetExpirationTime(This,dateExpirationTime)	\
    ( (This)->lpVtbl -> SetExpirationTime(This,dateExpirationTime) ) 

#define IWMSDataContainerVersion_GetCacheFlags(This,plFlags)	\
    ( (This)->lpVtbl -> GetCacheFlags(This,plFlags) ) 

#define IWMSDataContainerVersion_SetCacheFlags(This,lFlags)	\
    ( (This)->lpVtbl -> SetCacheFlags(This,lFlags) ) 

#define IWMSDataContainerVersion_GetContentSize(This,plContentSizeLow,plContentSizeHigh)	\
    ( (This)->lpVtbl -> GetContentSize(This,plContentSizeLow,plContentSizeHigh) ) 

#define IWMSDataContainerVersion_SetContentSize(This,lContentSizeLow,lContentSizeHigh)	\
    ( (This)->lpVtbl -> SetContentSize(This,lContentSizeLow,lContentSizeHigh) ) 

#define IWMSDataContainerVersion_GetEntityTagCount(This,plNumEntityTags)	\
    ( (This)->lpVtbl -> GetEntityTagCount(This,plNumEntityTags) ) 

#define IWMSDataContainerVersion_GetEntityTag(This,lTagNum,pszEntityTag)	\
    ( (This)->lpVtbl -> GetEntityTag(This,lTagNum,pszEntityTag) ) 

#define IWMSDataContainerVersion_SetEntityTag(This,szEntityTag)	\
    ( (This)->lpVtbl -> SetEntityTag(This,szEntityTag) ) 

#define IWMSDataContainerVersion_Compare(This,pVersion,pvfEqual)	\
    ( (This)->lpVtbl -> Compare(This,pVersion,pvfEqual) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSDataContainerVersion_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\datacontainer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for datacontainer.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __datacontainer_h__
#define __datacontainer_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSDataSourcePlugin_FWD_DEFINED__
#define __IWMSDataSourcePlugin_FWD_DEFINED__
typedef interface IWMSDataSourcePlugin IWMSDataSourcePlugin;
#endif 	/* __IWMSDataSourcePlugin_FWD_DEFINED__ */


#ifndef __IWMSDataSourcePluginCallback_FWD_DEFINED__
#define __IWMSDataSourcePluginCallback_FWD_DEFINED__
typedef interface IWMSDataSourcePluginCallback IWMSDataSourcePluginCallback;
#endif 	/* __IWMSDataSourcePluginCallback_FWD_DEFINED__ */


#ifndef __IWMSDataContainer_FWD_DEFINED__
#define __IWMSDataContainer_FWD_DEFINED__
typedef interface IWMSDataContainer IWMSDataContainer;
#endif 	/* __IWMSDataContainer_FWD_DEFINED__ */


#ifndef __IWMSDataContainerCallback_FWD_DEFINED__
#define __IWMSDataContainerCallback_FWD_DEFINED__
typedef interface IWMSDataContainerCallback IWMSDataContainerCallback;
#endif 	/* __IWMSDataContainerCallback_FWD_DEFINED__ */


#ifndef __IWMSDirectory_FWD_DEFINED__
#define __IWMSDirectory_FWD_DEFINED__
typedef interface IWMSDirectory IWMSDirectory;
#endif 	/* __IWMSDirectory_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "WMSBuffer.h"
#include "WMSContext.h"
#include "DataContainerVersion.h"
#include "wmsPacket.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_datacontainer_0000_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from datacontainer.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************






#define WMS_DATA_CONTAINER_NONSEEKABLE 0xFFFFFFFFFFFFFFFF
EXTERN_GUID( IID_IWMSDataSourcePlugin, 0xE1CD3525,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSDataSourcePluginCallback, 0xE1CD3526,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSDataContainer, 0xE6EE9A13,0x0FCC,0x11d2,0x9E,0xEE,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSDataContainerCallback, 0x2E34AB82,0x0D3D,0x11d2,0x9E,0xEE,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSDirectory, 0x6fa365e7, 0xe8b9, 0x437a, 0x8c, 0x4b, 0x65, 0x52, 0xdf, 0xbb, 0xc, 0x57 );
EXTERN_GUID( IID_IWMSUnknownFormat, 0x9b6c9e51, 0x4813, 0x11d2, 0x9e, 0xff, 0x00, 0x60, 0x97, 0xd2, 0xd7, 0xcf );
EXTERN_GUID( IID_IWMSDirectoryFormat, 0x7408ceb0, 0x3a5a, 0x41b6, 0xa5, 0xec, 0x9a, 0x4e, 0x81, 0x1c, 0x96, 0x73 );
EXTERN_GUID( IID_IWMSPlaylistSmilFormat, 0xc34294ea, 0xe111, 0x4fb2, 0xbe, 0x6b, 0xec, 0x68, 0x6a, 0x1a, 0x97, 0x57 );
typedef /* [public] */ 
enum WMS_DATA_CONTAINER_OPEN_FLAGS
    {	WMS_DATA_CONTAINER_READ_ACCESS	= 0x1,
	WMS_DATA_CONTAINER_WRITE_ACCESS	= 0x2,
	WMS_DATA_CONTAINER_CREATE_NEW_CONTAINER	= 0x4,
	WMS_DATA_CONTAINER_ALLOW_BUFFER_IO	= 0x8,
	WMS_DATA_CONTAINER_SHARED_SOURCE	= 0x10
    } 	WMS_DATA_CONTAINER_OPEN_FLAGS;

typedef /* [public] */ 
enum WMS_DIRECTORY_ENTRY_FLAGS
    {	WMS_DIRECTORY_ENTRY_IS_DIRECTORY	= 0x1
    } 	WMS_DIRECTORY_ENTRY_FLAGS;

typedef /* [public] */ 
enum WMS_DATA_CONTAINER_GETINFO_VALUES
    {	WMS_DATA_CONTAINER_SIZE	= 1,
	WMS_DATA_CONTAINER_MAX_SUPPORTED_READ_SIZE	= 2
    } 	WMS_DATA_CONTAINER_GETINFO_VALUES;

typedef /* [public] */ 
enum WMS_DATA_CONTAINER_GETINFO_FLAGS
    {	WMS_SEEKABLE_CONTAINER	= 0x1,
	WMS_LOCAL_DATA_CONTAINER	= 0x2
    } 	WMS_DATA_CONTAINER_GETINFO_FLAGS;

typedef /* [public] */ 
enum WMS_DATA_CONTAINER_ATTRIBUTES
    {	WMS_DATA_CONTAINER_SUPPORTS_ENUMERATION	= 0x1
    } 	WMS_DATA_CONTAINER_ATTRIBUTES;

typedef unsigned __int64 QWORD;



extern RPC_IF_HANDLE __MIDL_itf_datacontainer_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_datacontainer_0000_0000_v0_0_s_ifspec;

#ifndef __IWMSDataSourcePlugin_INTERFACE_DEFINED__
#define __IWMSDataSourcePlugin_INTERFACE_DEFINED__

/* interface IWMSDataSourcePlugin */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSDataSourcePlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3525-03D7-11d2-9EED-006097D2D7CF")
    IWMSDataSourcePlugin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataSourceAttributes( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRootDirectories( 
            /* [in] */ __RPC__deref_in_opt LPWSTR *pstrRootDirectoryList,
            /* [in] */ DWORD dwMaxRoots,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OpenDataContainer( 
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommandContext,
            /* [in] */ __RPC__in_opt IWMSContext *pUserContext,
            /* [in] */ __RPC__in_opt IWMSContext *pPresentationContext,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSBufferAllocator *pBufferAllocator,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OpenDirectory( 
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommandContext,
            /* [in] */ __RPC__in_opt IWMSContext *pUserContext,
            /* [in] */ __RPC__in_opt IWMSContext *pPresentationContext,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSBufferAllocator *pBufferAllocator,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteDataContainer( 
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataContainerVersion( 
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommandContext,
            /* [in] */ __RPC__in_opt IWMSContext *pUserContext,
            /* [in] */ __RPC__in_opt IWMSContext *pPresContext,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateDataSourceDirectory( 
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommandContext,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteDirectory( 
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSDataSourcePluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSDataSourcePlugin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSDataSourcePlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSDataSourcePlugin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDataSourceAttributes )( 
            IWMSDataSourcePlugin * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRootDirectories )( 
            IWMSDataSourcePlugin * This,
            /* [in] */ __RPC__deref_in_opt LPWSTR *pstrRootDirectoryList,
            /* [in] */ DWORD dwMaxRoots,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OpenDataContainer )( 
            IWMSDataSourcePlugin * This,
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommandContext,
            /* [in] */ __RPC__in_opt IWMSContext *pUserContext,
            /* [in] */ __RPC__in_opt IWMSContext *pPresentationContext,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSBufferAllocator *pBufferAllocator,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OpenDirectory )( 
            IWMSDataSourcePlugin * This,
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommandContext,
            /* [in] */ __RPC__in_opt IWMSContext *pUserContext,
            /* [in] */ __RPC__in_opt IWMSContext *pPresentationContext,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSBufferAllocator *pBufferAllocator,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteDataContainer )( 
            IWMSDataSourcePlugin * This,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDataContainerVersion )( 
            IWMSDataSourcePlugin * This,
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommandContext,
            /* [in] */ __RPC__in_opt IWMSContext *pUserContext,
            /* [in] */ __RPC__in_opt IWMSContext *pPresContext,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateDataSourceDirectory )( 
            IWMSDataSourcePlugin * This,
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommandContext,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteDirectory )( 
            IWMSDataSourcePlugin * This,
            /* [in] */ __RPC__in LPWSTR pszContainerName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataSourcePluginCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        END_INTERFACE
    } IWMSDataSourcePluginVtbl;

    interface IWMSDataSourcePlugin
    {
        CONST_VTBL struct IWMSDataSourcePluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSDataSourcePlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSDataSourcePlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSDataSourcePlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSDataSourcePlugin_GetDataSourceAttributes(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetDataSourceAttributes(This,pdwFlags) ) 

#define IWMSDataSourcePlugin_GetRootDirectories(This,pstrRootDirectoryList,dwMaxRoots,pCallback,qwContext)	\
    ( (This)->lpVtbl -> GetRootDirectories(This,pstrRootDirectoryList,dwMaxRoots,pCallback,qwContext) ) 

#define IWMSDataSourcePlugin_OpenDataContainer(This,pCommandContext,pUserContext,pPresentationContext,pszContainerName,dwFlags,pBufferAllocator,pCallback,qwContext)	\
    ( (This)->lpVtbl -> OpenDataContainer(This,pCommandContext,pUserContext,pPresentationContext,pszContainerName,dwFlags,pBufferAllocator,pCallback,qwContext) ) 

#define IWMSDataSourcePlugin_OpenDirectory(This,pCommandContext,pUserContext,pPresentationContext,pszContainerName,dwFlags,pBufferAllocator,pCallback,qwContext)	\
    ( (This)->lpVtbl -> OpenDirectory(This,pCommandContext,pUserContext,pPresentationContext,pszContainerName,dwFlags,pBufferAllocator,pCallback,qwContext) ) 

#define IWMSDataSourcePlugin_DeleteDataContainer(This,pszContainerName,dwFlags,pCallback,qwContext)	\
    ( (This)->lpVtbl -> DeleteDataContainer(This,pszContainerName,dwFlags,pCallback,qwContext) ) 

#define IWMSDataSourcePlugin_GetDataContainerVersion(This,pCommandContext,pUserContext,pPresContext,pszContainerName,dwFlags,pCallback,qwContext)	\
    ( (This)->lpVtbl -> GetDataContainerVersion(This,pCommandContext,pUserContext,pPresContext,pszContainerName,dwFlags,pCallback,qwContext) ) 

#define IWMSDataSourcePlugin_CreateDataSourceDirectory(This,pCommandContext,pszContainerName,dwFlags,pCallback,qwContext)	\
    ( (This)->lpVtbl -> CreateDataSourceDirectory(This,pCommandContext,pszContainerName,dwFlags,pCallback,qwContext) ) 

#define IWMSDataSourcePlugin_DeleteDirectory(This,pszContainerName,dwFlags,pCallback,qwContext)	\
    ( (This)->lpVtbl -> DeleteDirectory(This,pszContainerName,dwFlags,pCallback,qwContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSDataSourcePlugin_INTERFACE_DEFINED__ */


#ifndef __IWMSDataSourcePluginCallback_INTERFACE_DEFINED__
#define __IWMSDataSourcePluginCallback_INTERFACE_DEFINED__

/* interface IWMSDataSourcePluginCallback */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSDataSourcePluginCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3526-03D7-11d2-9EED-006097D2D7CF")
    IWMSDataSourcePluginCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnOpenDataContainer( 
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in_opt IWMSDataContainer *pDataContainer,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnOpenDirectory( 
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in_opt IWMSDirectory *pDirectory,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnOpenPacketStreamDataContainer( 
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in_opt IUnknown *pLiveDataContainer,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnDeleteDataContainer( 
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnGetDataContainerVersion( 
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in_opt IWMSDataContainerVersion *pVersion,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnGetRootDirectories( 
            /* [in] */ HRESULT hr,
            /* [in] */ DWORD dwNumReturnedRoots,
            /* [in] */ DWORD dwTotalNumRoots,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnCreateDirectory( 
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnDeleteDirectory( 
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSDataSourcePluginCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSDataSourcePluginCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSDataSourcePluginCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnOpenDataContainer )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in_opt IWMSDataContainer *pDataContainer,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnOpenDirectory )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in_opt IWMSDirectory *pDirectory,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnOpenPacketStreamDataContainer )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in_opt IUnknown *pLiveDataContainer,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnDeleteDataContainer )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnGetDataContainerVersion )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in_opt IWMSDataContainerVersion *pVersion,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnGetRootDirectories )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ DWORD dwNumReturnedRoots,
            /* [in] */ DWORD dwTotalNumRoots,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnCreateDirectory )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnDeleteDirectory )( 
            IWMSDataSourcePluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext);
        
        END_INTERFACE
    } IWMSDataSourcePluginCallbackVtbl;

    interface IWMSDataSourcePluginCallback
    {
        CONST_VTBL struct IWMSDataSourcePluginCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSDataSourcePluginCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSDataSourcePluginCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSDataSourcePluginCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSDataSourcePluginCallback_OnOpenDataContainer(This,hr,pDataContainer,qwContext)	\
    ( (This)->lpVtbl -> OnOpenDataContainer(This,hr,pDataContainer,qwContext) ) 

#define IWMSDataSourcePluginCallback_OnOpenDirectory(This,hr,pDirectory,qwContext)	\
    ( (This)->lpVtbl -> OnOpenDirectory(This,hr,pDirectory,qwContext) ) 

#define IWMSDataSourcePluginCallback_OnOpenPacketStreamDataContainer(This,hr,pLiveDataContainer,qwContext)	\
    ( (This)->lpVtbl -> OnOpenPacketStreamDataContainer(This,hr,pLiveDataContainer,qwContext) ) 

#define IWMSDataSourcePluginCallback_OnDeleteDataContainer(This,hr,qwContext)	\
    ( (This)->lpVtbl -> OnDeleteDataContainer(This,hr,qwContext) ) 

#define IWMSDataSourcePluginCallback_OnGetDataContainerVersion(This,hr,pVersion,qwContext)	\
    ( (This)->lpVtbl -> OnGetDataContainerVersion(This,hr,pVersion,qwContext) ) 

#define IWMSDataSourcePluginCallback_OnGetRootDirectories(This,hr,dwNumReturnedRoots,dwTotalNumRoots,qwContext)	\
    ( (This)->lpVtbl -> OnGetRootDirectories(This,hr,dwNumReturnedRoots,dwTotalNumRoots,qwContext) ) 

#define IWMSDataSourcePluginCallback_OnCreateDirectory(This,hr,qwContext)	\
    ( (This)->lpVtbl -> OnCreateDirectory(This,hr,qwContext) ) 

#define IWMSDataSourcePluginCallback_OnDeleteDirectory(This,hr,qwContext)	\
    ( (This)->lpVtbl -> OnDeleteDirectory(This,hr,qwContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSDataSourcePluginCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_datacontainer_0000_0002 */
/* [local] */ 

typedef /* [public][public] */ struct __MIDL___MIDL_itf_datacontainer_0000_0002_0001
    {
    LPOLESTR pstrName;
    DWORD dwFlags;
    QWORD qwSize;
    } 	WMSDirectoryEntryInfo;



extern RPC_IF_HANDLE __MIDL_itf_datacontainer_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_datacontainer_0000_0002_v0_0_s_ifspec;

#ifndef __IWMSDataContainer_INTERFACE_DEFINED__
#define __IWMSDataContainer_INTERFACE_DEFINED__

/* interface IWMSDataContainer */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSDataContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E6EE9A13-0FCC-11d2-9EEE-006097D2D7CF")
    IWMSDataContainer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetContainerFormat( 
            /* [out] */ __RPC__out GUID *pFormat) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataSourcePlugin( 
            /* [out] */ __RPC__deref_out_opt IWMSDataSourcePlugin **ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ DWORD dwInfoValueId,
            /* [in] */ __RPC__in_opt IWMSDataContainerCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ __RPC__in BYTE *pbBuffer,
            /* [in] */ QWORD qwOffset,
            /* [in] */ DWORD dwMaxDataSize,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataContainerCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ __RPC__in BYTE *pbBuffer,
            /* [in] */ DWORD dwDataSize,
            /* [in] */ QWORD qwWritePosition,
            /* [in] */ __RPC__in_opt IWMSDataContainerCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTransferParameters( 
            /* [in] */ QWORD qwDesiredOffset,
            /* [in] */ DWORD dwDesiredMinSize,
            /* [in] */ DWORD dwDesiredMaxSize,
            /* [out] */ __RPC__out QWORD *pqwOffset,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [out] */ __RPC__out DWORD *pdwBufferAlignment) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DoDataContainerExtendedCommand( 
            /* [in] */ __RPC__in LPWSTR szCommandName,
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommand,
            /* [in] */ DWORD dwCallFlags,
            /* [in] */ __RPC__in_opt IWMSDataContainerCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FinishParsingPacketlist( 
            /* [in] */ __RPC__in_opt IWMSPacketList *pPacketList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSDataContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSDataContainer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSDataContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSDataContainer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            IWMSDataContainer * This,
            /* [out] */ __RPC__out GUID *pFormat);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDataSourcePlugin )( 
            IWMSDataContainer * This,
            /* [out] */ __RPC__deref_out_opt IWMSDataSourcePlugin **ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IWMSDataContainer * This,
            /* [in] */ DWORD dwInfoValueId,
            /* [in] */ __RPC__in_opt IWMSDataContainerCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IWMSDataContainer * This,
            /* [in] */ __RPC__in BYTE *pbBuffer,
            /* [in] */ QWORD qwOffset,
            /* [in] */ DWORD dwMaxDataSize,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IWMSDataContainerCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IWMSDataContainer * This,
            /* [in] */ __RPC__in BYTE *pbBuffer,
            /* [in] */ DWORD dwDataSize,
            /* [in] */ QWORD qwWritePosition,
            /* [in] */ __RPC__in_opt IWMSDataContainerCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTransferParameters )( 
            IWMSDataContainer * This,
            /* [in] */ QWORD qwDesiredOffset,
            /* [in] */ DWORD dwDesiredMinSize,
            /* [in] */ DWORD dwDesiredMaxSize,
            /* [out] */ __RPC__out QWORD *pqwOffset,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [out] */ __RPC__out DWORD *pdwBufferAlignment);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DoDataContainerExtendedCommand )( 
            IWMSDataContainer * This,
            /* [in] */ __RPC__in LPWSTR szCommandName,
            /* [in] */ __RPC__in_opt IWMSCommandContext *pCommand,
            /* [in] */ DWORD dwCallFlags,
            /* [in] */ __RPC__in_opt IWMSDataContainerCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FinishParsingPacketlist )( 
            IWMSDataContainer * This,
            /* [in] */ __RPC__in_opt IWMSPacketList *pPacketList);
        
        END_INTERFACE
    } IWMSDataContainerVtbl;

    interface IWMSDataContainer
    {
        CONST_VTBL struct IWMSDataContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSDataContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSDataContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSDataContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSDataContainer_GetContainerFormat(This,pFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pFormat) ) 

#define IWMSDataContainer_GetDataSourcePlugin(This,ppDataSource)	\
    ( (This)->lpVtbl -> GetDataSourcePlugin(This,ppDataSource) ) 

#define IWMSDataContainer_GetInfo(This,dwInfoValueId,pCallback,qwContext)	\
    ( (This)->lpVtbl -> GetInfo(This,dwInfoValueId,pCallback,qwContext) ) 

#define IWMSDataContainer_Read(This,pbBuffer,qwOffset,dwMaxDataSize,dwFlags,pCallback,qwContext)	\
    ( (This)->lpVtbl -> Read(This,pbBuffer,qwOffset,dwMaxDataSize,dwFlags,pCallback,qwContext) ) 

#define IWMSDataContainer_Write(This,pbBuffer,dwDataSize,qwWritePosition,pCallback,qwContext)	\
    ( (This)->lpVtbl -> Write(This,pbBuffer,dwDataSize,qwWritePosition,pCallback,qwContext) ) 

#define IWMSDataContainer_GetTransferParameters(This,qwDesiredOffset,dwDesiredMinSize,dwDesiredMaxSize,pqwOffset,pdwSize,pdwBufferAlignment)	\
    ( (This)->lpVtbl -> GetTransferParameters(This,qwDesiredOffset,dwDesiredMinSize,dwDesiredMaxSize,pqwOffset,pdwSize,pdwBufferAlignment) ) 

#define IWMSDataContainer_DoDataContainerExtendedCommand(This,szCommandName,pCommand,dwCallFlags,pCallback,qwContext)	\
    ( (This)->lpVtbl -> DoDataContainerExtendedCommand(This,szCommandName,pCommand,dwCallFlags,pCallback,qwContext) ) 

#define IWMSDataContainer_FinishParsingPacketlist(This,pPacketList)	\
    ( (This)->lpVtbl -> FinishParsingPacketlist(This,pPacketList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSDataContainer_INTERFACE_DEFINED__ */


#ifndef __IWMSDataContainerCallback_INTERFACE_DEFINED__
#define __IWMSDataContainerCallback_INTERFACE_DEFINED__

/* interface IWMSDataContainerCallback */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSDataContainerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2E34AB82-0D3D-11d2-9EEE-006097D2D7CF")
    IWMSDataContainerCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnGetInfo( 
            /* [in] */ HRESULT hr,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD qwInfoValue,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnRead( 
            /* [in] */ HRESULT hr,
            /* [in] */ DWORD dwActualBytesTransferred,
            /* [in] */ DWORD dwChangeType,
            /* [in] */ QWORD qwChangeParameter,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnWrite( 
            /* [in] */ HRESULT hr,
            /* [in] */ DWORD dwActualBytesTransferred,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnDoDataContainerExtendedCommand( 
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSDataContainerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSDataContainerCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSDataContainerCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSDataContainerCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnGetInfo )( 
            IWMSDataContainerCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD qwInfoValue,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnRead )( 
            IWMSDataContainerCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ DWORD dwActualBytesTransferred,
            /* [in] */ DWORD dwChangeType,
            /* [in] */ QWORD qwChangeParameter,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnWrite )( 
            IWMSDataContainerCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ DWORD dwActualBytesTransferred,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnDoDataContainerExtendedCommand )( 
            IWMSDataContainerCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext);
        
        END_INTERFACE
    } IWMSDataContainerCallbackVtbl;

    interface IWMSDataContainerCallback
    {
        CONST_VTBL struct IWMSDataContainerCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSDataContainerCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSDataContainerCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSDataContainerCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSDataContainerCallback_OnGetInfo(This,hr,dwFlags,qwInfoValue,qwContext)	\
    ( (This)->lpVtbl -> OnGetInfo(This,hr,dwFlags,qwInfoValue,qwContext) ) 

#define IWMSDataContainerCallback_OnRead(This,hr,dwActualBytesTransferred,dwChangeType,qwChangeParameter,qwContext)	\
    ( (This)->lpVtbl -> OnRead(This,hr,dwActualBytesTransferred,dwChangeType,qwChangeParameter,qwContext) ) 

#define IWMSDataContainerCallback_OnWrite(This,hr,dwActualBytesTransferred,qwContext)	\
    ( (This)->lpVtbl -> OnWrite(This,hr,dwActualBytesTransferred,qwContext) ) 

#define IWMSDataContainerCallback_OnDoDataContainerExtendedCommand(This,hr,qwContext)	\
    ( (This)->lpVtbl -> OnDoDataContainerExtendedCommand(This,hr,qwContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSDataContainerCallback_INTERFACE_DEFINED__ */


#ifndef __IWMSDirectory_INTERFACE_DEFINED__
#define __IWMSDirectory_INTERFACE_DEFINED__

/* interface IWMSDirectory */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FA365E7-E8B9-437a-8C4B-6552DFBB0C57")
    IWMSDirectory : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataSourcePlugin( 
            /* [out] */ __RPC__deref_out_opt IWMSDataSourcePlugin **ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ __RPC__deref_out_opt LPOLESTR *pstrValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildInfo( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out WMSDirectoryEntryInfo *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSDirectory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSDirectory * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDataSourcePlugin )( 
            IWMSDirectory * This,
            /* [out] */ __RPC__deref_out_opt IWMSDataSourcePlugin **ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IWMSDirectory * This,
            /* [out] */ __RPC__deref_out_opt LPOLESTR *pstrValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChildInfo )( 
            IWMSDirectory * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out WMSDirectoryEntryInfo *pInfo);
        
        END_INTERFACE
    } IWMSDirectoryVtbl;

    interface IWMSDirectory
    {
        CONST_VTBL struct IWMSDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSDirectory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSDirectory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSDirectory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSDirectory_GetDataSourcePlugin(This,ppDataSource)	\
    ( (This)->lpVtbl -> GetDataSourcePlugin(This,ppDataSource) ) 

#define IWMSDirectory_GetName(This,pstrValue)	\
    ( (This)->lpVtbl -> GetName(This,pstrValue) ) 

#define IWMSDirectory_GetChildInfo(This,dwIndex,pInfo)	\
    ( (This)->lpVtbl -> GetChildInfo(This,dwIndex,pInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSDirectory_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\d3dumddi.h ===
/******************************Module*Header**********************************\
*
* Module Name: d3dumddi.h
*
* Content: longhorn display driver user mode interfaces
*
* Copyright (c) 2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef _D3DUMDDI_H_
#define _D3DUMDDI_H_
#include <d3dukmdt.h>
#include <winerror.h>

#define D3D_UMD_INTERFACE_VERSION  0x0000000C

typedef struct _D3DDDIARG_SETDISPLAYMODE
{
    HANDLE                      hResource;              // Source surface
    UINT                        SubResourceIndex;       // Index of surface level
} D3DDDIARG_SETDISPLAYMODE;

typedef struct _D3DDDI_PRESENTFLAGS
{
    union
    {
        struct
        {
            UINT    Blt                 : 1;        // 0x00000001
            UINT    ColorFill           : 1;        // 0x00000002
            UINT    Flip                : 1;        // 0x00000004
            UINT    Reserved            :29;        // 0xFFFFFFF8            
        };
        UINT    Value;
    };            
} D3DDDI_PRESENTFLAGS;

typedef struct _D3DDDIARG_PRESENT
{
    HANDLE                      hSrcResource;           // in: Source surface
    UINT                        SrcSubResourceIndex;    // in: Index of surface level
    HANDLE                      hDstResource;           // in: if non-zero, it's the destination of the present
    UINT                        DstSubResourceIndex;    // in: Index of surface level
    D3DDDI_PRESENTFLAGS         Flags;                  // in: Presentation flags.
    D3DDDI_FLIPINTERVAL_TYPE    FlipInterval;           // in: Presentation interval (flip only)
} D3DDDIARG_PRESENT;

typedef struct _D3DDDIBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DDDIBOX;

typedef struct _D3DDDIRANGE
{
    UINT                Offset;
    UINT                Size;
} D3DDDIRANGE;

typedef enum _D3DDDIRENDERSTATETYPE
{
    D3DDDIRS_ZENABLE                    = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
    D3DDDIRS_FILLMODE                   = 8,    /* D3DFILLMODE */
    D3DDDIRS_SHADEMODE                  = 9,    /* D3DSHADEMODE */
    D3DDDIRS_LINEPATTERN                = 10,
    D3DDDIRS_ZWRITEENABLE               = 14,   /* TRUE to enable z writes */
    D3DDDIRS_ALPHATESTENABLE            = 15,   /* TRUE to enable alpha tests */
    D3DDDIRS_LASTPIXEL                  = 16,   /* TRUE for last-pixel on lines */
    D3DDDIRS_SRCBLEND                   = 19,   /* D3DBLEND */
    D3DDDIRS_DESTBLEND                  = 20,   /* D3DBLEND */
    D3DDDIRS_CULLMODE                   = 22,   /* D3DCULL */
    D3DDDIRS_ZFUNC                      = 23,   /* D3DCMPFUNC */
    D3DDDIRS_ALPHAREF                   = 24,   /* D3DFIXED */
    D3DDDIRS_ALPHAFUNC                  = 25,   /* D3DCMPFUNC */
    D3DDDIRS_DITHERENABLE               = 26,   /* TRUE to enable dithering */
    D3DDDIRS_ALPHABLENDENABLE           = 27,   /* TRUE to enable alpha blending */
    D3DDDIRS_FOGENABLE                  = 28,   /* TRUE to enable fog blending */
    D3DDDIRS_SPECULARENABLE             = 29,   /* TRUE to enable specular */
    D3DDDIRS_ZVISIBLE                   = 30,
    D3DDDIRS_FOGCOLOR                   = 34,   /* D3DCOLOR */
    D3DDDIRS_FOGTABLEMODE               = 35,   /* D3DFOGMODE */
    D3DDDIRS_FOGSTART                   = 36,   /* Fog start (for both vertex and pixel fog) */
    D3DDDIRS_FOGEND                     = 37,   /* Fog end      */
    D3DDDIRS_FOGDENSITY                 = 38,   /* Fog density  */
    D3DDDIRS_EDGEANTIALIAS              = 40,
    D3DDDIRS_COLORKEYENABLE             = 41,
    D3DDDIRS_OLDALPHABLENDENABLE        = 42,
    D3DDDIRS_ZBIAS                      = 47,
    D3DDDIRS_RANGEFOGENABLE             = 48,   /* Enables range-based fog */
    D3DDDIRS_TRANSLUCENTSORTINDEPENDENT = 51,
    D3DDDIRS_STENCILENABLE              = 52,   /* BOOL enable/disable stenciling */
    D3DDDIRS_STENCILFAIL                = 53,   /* D3DSTENCILOP to do if stencil test fails */
    D3DDDIRS_STENCILZFAIL               = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    D3DDDIRS_STENCILPASS                = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    D3DDDIRS_STENCILFUNC                = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DDDIRS_STENCILREF                 = 57,   /* Reference value used in stencil test */
    D3DDDIRS_STENCILMASK                = 58,   /* Mask value used in stencil test */
    D3DDDIRS_STENCILWRITEMASK           = 59,   /* Write mask applied to values written to stencil buffer */
    D3DDDIRS_TEXTUREFACTOR              = 60,   /* D3DCOLOR used for multi-texture blend */
    D3DDDIRS_SCENECAPTURE               = 62,   // DDI only to replace SceneCapture
    D3DDDIRS_STIPPLEPATTERN00           = 64,
    D3DDDIRS_STIPPLEPATTERN01           = 65,
    D3DDDIRS_STIPPLEPATTERN02           = 66,
    D3DDDIRS_STIPPLEPATTERN03           = 67,
    D3DDDIRS_STIPPLEPATTERN04           = 68,
    D3DDDIRS_STIPPLEPATTERN05           = 69,
    D3DDDIRS_STIPPLEPATTERN06           = 70,
    D3DDDIRS_STIPPLEPATTERN07           = 71,
    D3DDDIRS_STIPPLEPATTERN08           = 72,
    D3DDDIRS_STIPPLEPATTERN09           = 73,
    D3DDDIRS_STIPPLEPATTERN10           = 74,
    D3DDDIRS_STIPPLEPATTERN11           = 75,
    D3DDDIRS_STIPPLEPATTERN12           = 76,
    D3DDDIRS_STIPPLEPATTERN13           = 77,
    D3DDDIRS_STIPPLEPATTERN14           = 78,
    D3DDDIRS_STIPPLEPATTERN15           = 79,
    D3DDDIRS_STIPPLEPATTERN16           = 80,
    D3DDDIRS_STIPPLEPATTERN17           = 81,
    D3DDDIRS_STIPPLEPATTERN18           = 82,
    D3DDDIRS_STIPPLEPATTERN19           = 83,
    D3DDDIRS_STIPPLEPATTERN20           = 84,
    D3DDDIRS_STIPPLEPATTERN21           = 85,
    D3DDDIRS_STIPPLEPATTERN22           = 86,
    D3DDDIRS_STIPPLEPATTERN23           = 87,
    D3DDDIRS_STIPPLEPATTERN24           = 88,
    D3DDDIRS_STIPPLEPATTERN25           = 89,
    D3DDDIRS_STIPPLEPATTERN26           = 90,
    D3DDDIRS_STIPPLEPATTERN27           = 91,
    D3DDDIRS_STIPPLEPATTERN28           = 92,
    D3DDDIRS_STIPPLEPATTERN29           = 93,
    D3DDDIRS_STIPPLEPATTERN30           = 94,
    D3DDDIRS_STIPPLEPATTERN31           = 95,
    D3DDDIRS_WRAP0                      = 128,  /* wrap for 1st texture coord. set */
    D3DDDIRS_WRAP1                      = 129,  /* wrap for 2nd texture coord. set */
    D3DDDIRS_WRAP2                      = 130,  /* wrap for 3rd texture coord. set */
    D3DDDIRS_WRAP3                      = 131,  /* wrap for 4th texture coord. set */
    D3DDDIRS_WRAP4                      = 132,  /* wrap for 5th texture coord. set */
    D3DDDIRS_WRAP5                      = 133,  /* wrap for 6th texture coord. set */
    D3DDDIRS_WRAP6                      = 134,  /* wrap for 7th texture coord. set */
    D3DDDIRS_WRAP7                      = 135,  /* wrap for 8th texture coord. set */
    D3DDDIRS_CLIPPING                   = 136,
    D3DDDIRS_LIGHTING                   = 137,
    D3DDDIRS_AMBIENT                    = 139,
    D3DDDIRS_FOGVERTEXMODE              = 140,
    D3DDDIRS_COLORVERTEX                = 141,
    D3DDDIRS_LOCALVIEWER                = 142,
    D3DDDIRS_NORMALIZENORMALS           = 143,
    D3DDDIRS_COLORKEYBLENDENABLE        = 144,
    D3DDDIRS_DIFFUSEMATERIALSOURCE      = 145,
    D3DDDIRS_SPECULARMATERIALSOURCE     = 146,
    D3DDDIRS_AMBIENTMATERIALSOURCE      = 147,
    D3DDDIRS_EMISSIVEMATERIALSOURCE     = 148,
    D3DDDIRS_VERTEXBLEND                = 151,
    D3DDDIRS_CLIPPLANEENABLE            = 152,
    D3DDDIRS_SOFTWAREVERTEXPROCESSING   = 153,
    D3DDDIRS_POINTSIZE                  = 154,   /* float point size */
    D3DDDIRS_POINTSIZE_MIN              = 155,   /* float point size min threshold */
    D3DDDIRS_POINTSPRITEENABLE          = 156,   /* BOOL point texture coord control */
    D3DDDIRS_POINTSCALEENABLE           = 157,   /* BOOL point size scale enable */
    D3DDDIRS_POINTSCALE_A               = 158,   /* float point attenuation A value */
    D3DDDIRS_POINTSCALE_B               = 159,   /* float point attenuation B value */
    D3DDDIRS_POINTSCALE_C               = 160,   /* float point attenuation C value */
    D3DDDIRS_MULTISAMPLEANTIALIAS       = 161,  // BOOL - set to do FSAA with multisample buffer
    D3DDDIRS_MULTISAMPLEMASK            = 162,  // DWORD - per-sample enable/disable
    D3DDDIRS_PATCHEDGESTYLE             = 163,  // Sets whether patch edges will use float style tessellation
    D3DDDIRS_PATCHSEGMENTS              = 164,
    D3DDDIRS_DEBUGMONITORTOKEN          = 165,  // DEBUG ONLY - token to debug monitor
    D3DDDIRS_POINTSIZE_MAX              = 166,   /* float point size max threshold */
    D3DDDIRS_INDEXEDVERTEXBLENDENABLE   = 167,
    D3DDDIRS_COLORWRITEENABLE           = 168,  // per-channel write enable
    D3DDDIRS_DELETERTPATCH              = 169,
    D3DDDIRS_TWEENFACTOR                = 170,   // float tween factor
    D3DDDIRS_BLENDOP                    = 171,   // D3DBLENDOP setting
    D3DDDIRS_POSITIONDEGREE             = 172,   // NPatch position interpolation degree. D3DDEGREE_LINEAR or D3DDEGREE_CUBIC (default)
    D3DDDIRS_NORMALDEGREE               = 173,   // NPatch normal interpolation degree. D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC
    D3DDDIRS_SCISSORTESTENABLE          = 174,
    D3DDDIRS_SLOPESCALEDEPTHBIAS        = 175,
    D3DDDIRS_ANTIALIASEDLINEENABLE      = 176,
    D3DDDIRS_MINTESSELLATIONLEVEL       = 178,
    D3DDDIRS_MAXTESSELLATIONLEVEL       = 179,
    D3DDDIRS_ADAPTIVETESS_X             = 180,
    D3DDDIRS_ADAPTIVETESS_Y             = 181,
    D3DDDIRS_ADAPTIVETESS_Z             = 182,
    D3DDDIRS_ADAPTIVETESS_W             = 183,
    D3DDDIRS_ENABLEADAPTIVETESSELLATION = 184,
    D3DDDIRS_TWOSIDEDSTENCILMODE        = 185,   /* BOOL enable/disable 2 sided stenciling */
    D3DDDIRS_CCW_STENCILFAIL            = 186,   /* D3DSTENCILOP to do if ccw stencil test fails */
    D3DDDIRS_CCW_STENCILZFAIL           = 187,   /* D3DSTENCILOP to do if ccw stencil test passes and Z test fails */
    D3DDDIRS_CCW_STENCILPASS            = 188,   /* D3DSTENCILOP to do if both ccw stencil and Z tests pass */
    D3DDDIRS_CCW_STENCILFUNC            = 189,   /* D3DCMPFUNC fn.  ccw Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DDDIRS_COLORWRITEENABLE1          = 190,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DDDIRS_COLORWRITEENABLE2          = 191,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DDDIRS_COLORWRITEENABLE3          = 192,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DDDIRS_BLENDFACTOR                = 193,   /* D3DCOLOR used for a constant blend factor during alpha blending for devices that support D3DPBLENDCAPS_BLENDFACTOR */
    D3DDDIRS_SRGBWRITEENABLE            = 194,   /* Enable rendertarget writes to be DE-linearized to SRGB (for formats that expose D3DUSAGE_QUERY_SRGBWRITE) */
    D3DDDIRS_DEPTHBIAS                  = 195,
    D3DDDIRS_WRAP8                      = 198,   /* Additional wrap states for vs_3_0+ attributes with D3DDECLUSAGE_TEXCOORD */
    D3DDDIRS_WRAP9                      = 199,
    D3DDDIRS_WRAP10                     = 200,
    D3DDDIRS_WRAP11                     = 201,
    D3DDDIRS_WRAP12                     = 202,
    D3DDDIRS_WRAP13                     = 203,
    D3DDDIRS_WRAP14                     = 204,
    D3DDDIRS_WRAP15                     = 205,
    D3DDDIRS_SEPARATEALPHABLENDENABLE   = 206,  /* TRUE to enable a separate blending function for the alpha channel */
    D3DDDIRS_SRCBLENDALPHA              = 207,  /* SRC blend factor for the alpha channel when D3DDDIRS_SEPARATEDESTALPHAENABLE is TRUE */
    D3DDDIRS_DESTBLENDALPHA             = 208,  /* DST blend factor for the alpha channel when D3DDDIRS_SEPARATEDESTALPHAENABLE is TRUE */
    D3DDDIRS_BLENDOPALPHA               = 209,  /* Blending operation for the alpha channel when D3DDDIRS_SEPARATEDESTALPHAENABLE is TRUE */

    D3DDDIRS_FORCE_DWORD                = 0x7fffffff, /* force 32-bit size enum */
} D3DDDIRENDERSTATETYPE;

typedef struct _D3DDDIARG_RENDERSTATE
{
    D3DDDIRENDERSTATETYPE  State;
    UINT                   Value;
} D3DDDIARG_RENDERSTATE;

typedef struct _D3DDDIARG_WINFO
{
    FLOAT               WNear;
    FLOAT               WFar;
} D3DDDIARG_WINFO;

typedef struct _D3DDDIARG_VALIDATETEXTURESTAGESTATE
{
    UINT                NumPasses;      // out: Number of passes the hardware
                                        //      can perform the operation in
} D3DDDIARG_VALIDATETEXTURESTAGESTATE;

typedef enum _D3DDDITEXTURESTAGESTATETYPE
{
    D3DDDITSS_TEXTUREMAP             =  0,
    D3DDDITSS_COLOROP                =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
    D3DDDITSS_COLORARG1              =  2, /* D3DTA_* (texture arg) */
    D3DDDITSS_COLORARG2              =  3, /* D3DTA_* (texture arg) */
    D3DDDITSS_ALPHAOP                =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
    D3DDDITSS_ALPHAARG1              =  5, /* D3DTA_* (texture arg) */
    D3DDDITSS_ALPHAARG2              =  6, /* D3DTA_* (texture arg) */
    D3DDDITSS_BUMPENVMAT00           =  7, /* float (bump mapping matrix) */
    D3DDDITSS_BUMPENVMAT01           =  8, /* float (bump mapping matrix) */
    D3DDDITSS_BUMPENVMAT10           =  9, /* float (bump mapping matrix) */
    D3DDDITSS_BUMPENVMAT11           = 10, /* float (bump mapping matrix) */
    D3DDDITSS_TEXCOORDINDEX          = 11, /* identifies which set of texture coordinates index this texture */
    D3DDDITSS_ADDRESSU               = 13,
    D3DDDITSS_ADDRESSV               = 14,
    D3DDDITSS_BORDERCOLOR            = 15,
    D3DDDITSS_MAGFILTER              = 16,
    D3DDDITSS_MINFILTER              = 17,
    D3DDDITSS_MIPFILTER              = 18,
    D3DDDITSS_MIPMAPLODBIAS          = 19,
    D3DDDITSS_MAXMIPLEVEL            = 20,
    D3DDDITSS_MAXANISOTROPY          = 21,
    D3DDDITSS_BUMPENVLSCALE          = 22, /* float scale for bump map luminance */
    D3DDDITSS_BUMPENVLOFFSET         = 23, /* float offset for bump map luminance */
    D3DDDITSS_TEXTURETRANSFORMFLAGS  = 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */
    D3DDDITSS_ADDRESSW               = 25,
    D3DDDITSS_COLORARG0              = 26, /* D3DTA_* third arg for triadic ops */
    D3DDDITSS_ALPHAARG0              = 27, /* D3DTA_* third arg for triadic ops */
    D3DDDITSS_RESULTARG              = 28, /* D3DTA_* arg for result (CURRENT or TEMP) */
    D3DDDITSS_SRGBTEXTURE            = 29,
    D3DDDITSS_ELEMENTINDEX           = 30,
    D3DDDITSS_DMAPOFFSET             = 31,
    D3DDDITSS_CONSTANT               = 32, /* Per-stage constant D3DTA_CONSTANT */
    D3DDDITSS_DISABLETEXTURECOLORKEY = 33,
    D3DDDITSS_TEXTURECOLORKEYVAL     = 34,

    D3DDDITSS_FORCE_DWORD            = 0x7fffffff, /* force 32-bit size enum */
} D3DDDITEXTURESTAGESTATETYPE;

typedef struct _D3DDDIARG_TEXTURESTAGESTATE
{
    UINT                        Stage;
    D3DDDITEXTURESTAGESTATETYPE State;
    UINT                        Value;
} D3DDDIARG_TEXTURESTAGESTATE;

typedef struct _D3DDDIARG_SETPIXELSHADERCONST
{
    UINT    Register;   // Const register to start copying
    UINT    Count;      // Number of 4-float vectors to copy for D3DDP2OP_SETPIXELSHADERCONST
                        // Number of 4-integer vectors to copy for D3DDP2OP_SETPIXELSHADERCONSTI
                        // Number of BOOL values to copy for D3DDP2OP_SETPIXELSHADERCONSTB
                        // Data follows
} D3DDDIARG_SETPIXELSHADERCONST;

typedef D3DDDIARG_SETPIXELSHADERCONST D3DDDIARG_SETPIXELSHADERCONSTI;
typedef D3DDDIARG_SETPIXELSHADERCONST D3DDDIARG_SETPIXELSHADERCONSTB;

typedef struct _D3DDDIARG_SETSTREAMSOURCEUM
{
    UINT    Stream;     // Stream index, starting from zero
    UINT    Stride;     // Vertex size in bytes
} D3DDDIARG_SETSTREAMSOURCEUM;

typedef struct _D3DDDIARG_SETINDICES
{
    HANDLE  hIndexBuffer;   // Index buffer handle
    UINT    Stride;         // Index size in bytes (2 or 4)
} D3DDDIARG_SETINDICES;

typedef struct _D3DDDIARG_DRAWPRIMITIVE
{
    D3DPRIMITIVETYPE PrimitiveType;
    UINT    VStart;
    UINT    PrimitiveCount;
} D3DDDIARG_DRAWPRIMITIVE;

typedef struct _D3DDDIARG_DRAWINDEXEDPRIMITIVE
{
    D3DPRIMITIVETYPE PrimitiveType;
    INT     BaseVertexIndex;    // Vertex which corresponds to index 0
    UINT    MinIndex;           // Min vertex index in the vertex buffer
    UINT    NumVertices;        // Number of vertices starting from MinIndex
    UINT    StartIndex;         // Start index in the index buffer
    UINT    PrimitiveCount;
} D3DDDIARG_DRAWINDEXEDPRIMITIVE;

typedef struct _D3DDDIARG_DRAWRECTPATCH
{
    UINT    Handle;
} D3DDDIARG_DRAWRECTPATCH;

typedef struct _D3DDDIARG_DRAWTRIPATCH
{
    UINT    Handle;
} D3DDDIARG_DRAWTRIPATCH;

typedef struct _D3DDDIARG_DRAWPRIMITIVE2
{
    D3DPRIMITIVETYPE PrimitiveType;
    UINT    FirstVertexOffset;    // Offset in bytes in the stream 0
    UINT    PrimitiveCount;
} D3DDDIARG_DRAWPRIMITIVE2;

typedef struct _D3DDDIARG_DRAWINDEXEDPRIMITIVE2
{
    D3DPRIMITIVETYPE PrimitiveType;
    INT   BaseVertexOffset;     // Stream 0 offset of the vertex which
                                // corresponds to index 0. This offset could be
                                // negative, but when an index is added to the
                                // offset the result is positive
    UINT  MinIndex;             // Min vertex index in the vertex buffer
    UINT  NumVertices;          // Number of vertices starting from MinIndex
    UINT  StartIndexOffset;     // Offset of the start index in the index buffer
    UINT  PrimitiveCount;       // Number of triangles (points, lines)
} D3DDDIARG_DRAWINDEXEDPRIMITIVE2;

typedef struct _D3DDDIARG_VOLUMEBLT
{
    HANDLE      hDstResource;   // dest resource
    HANDLE      hSrcResource;   // src resource
    UINT        DstX;           // dest X (width)
    UINT        DstY;           // dest Y (height)
    UINT        DstZ;           // dest Z (depth)
    D3DDDIBOX   SrcBox;         // src box
} D3DDDIARG_VOLUMEBLT;

typedef struct _D3DDDIARG_BUFFERBLT
{
    HANDLE      hDstResource;   // dest resource
    HANDLE      hSrcResource;   // src resource
    UINT        Offset;         // Offset in the dest surface (in BYTES)
    D3DDDIRANGE SrcRange;       // src range
} D3DDDIARG_BUFFERBLT;

typedef struct _D3DDDIARG_TEXBLT
{
    HANDLE      hDstResource;   // dest resource
    HANDLE      hSrcResource;   // src resource
    UINT        CubeMapFace;
    POINT       DstPoint;
    RECT        SrcRect;        // src rect
} D3DDDIARG_TEXBLT;

typedef struct _D3DDDIARG_STATESET
{
    UINT                Operation;  // in: D3DHAL_STATESET* enum
                                    // D3DHAL_STATESETDELETE and D3DHAL_STATESETCAPTURE
    D3DSTATEBLOCKTYPE   StateBlockType;     // in: Type use with D3DHAL_STATESETBEGIN/END
    HANDLE              hStateSet;  // out: Device handle returned from D3DHAL_STATESETBEGIN and
                                    //      D3DHAL_STATESETCREATE
                                    // in: State set handle passed with D3DHAL_STATESETEXECUTE,
} D3DDDIARG_STATESET;

typedef struct _D3DDDIARG_SETPRIORITY
{
    HANDLE  hResource;
    UINT    Priority;
} D3DDDIARG_SETPRIORITY;

typedef struct _D3DDDIARG_CLEAR
{
    // Flags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, D3DCLEAR_STENCIL and/or D3DCLEAR_COMPUTERECTS
    UINT                Flags;          // in:  surfaces to clear
    UINT                FillColor;      // in:  Color value for rtarget
    FLOAT               FillDepth;      // in:  Depth value for Z buffer (0.0-1.0)
    UINT                FillStencil;    // in:  value used to clear stencil buffer
} D3DDDIARG_CLEAR;

typedef struct _D3DDDIARG_UPDATEPALETTE
{
    UINT    PaletteHandle;
    UINT    StartIndex;
    UINT    NumEntries;
} D3DDDIARG_UPDATEPALETTE;

#define D3DDDISETPALETTE_256        0x00000001l
#define D3DDDISETPALETTE_ALLOW256   0x00000200l
#define D3DDDISETPALETTE_ALPHA      0x00002000l

typedef struct _D3DDDIARG_SETPALETTE
{
    UINT    PaletteHandle;
    UINT    PaletteFlags;
    HANDLE  hResource;
} D3DDDIARG_SETPALETTE;

// Used with all types of vertex shader constants
typedef struct _D3DDDIARG_SETVERTEXSHADERCONST
{
    UINT    Register;   // Const register to start copying
    UINT    Count;      // Number of 4-float vectors to copy for D3DDP2OP_SETVERTEXSHADERCONST
                        // Number of 4-integer vectors to copy for D3DDP2OP_SETVERTEXSHADERCONSTI
                        // Number of BOOL values to copy for D3DDP2OP_SETVERTEXSHADERCONSTB
                        // Data follows
} D3DDDIARG_SETVERTEXSHADERCONST;

typedef D3DDDIARG_SETVERTEXSHADERCONST D3DDDIARG_SETVERTEXSHADERCONSTI;
typedef D3DDDIARG_SETVERTEXSHADERCONST D3DDDIARG_SETVERTEXSHADERCONSTB;

typedef struct _D3DDDIARG_MULTIPLYTRANSFORM
{
    D3DTRANSFORMSTATETYPE   TransformType;
    D3DMATRIX               Matrix;
} D3DDDIARG_MULTIPLYTRANSFORM;

typedef struct _D3DDDIARG_SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE   TransformType;
    D3DMATRIX               Matrix;
} D3DDDIARG_SETTRANSFORM;

typedef struct _D3DDDIARG_VIEWPORTINFO
{
    UINT    X;
    UINT    Y;
    UINT    Width;
    UINT    Height;
} D3DDDIARG_VIEWPORTINFO;

typedef struct _D3DDDIARG_ZRANGE
{
    FLOAT       MinZ;
    FLOAT       MaxZ;
} D3DDDIARG_ZRANGE;

typedef struct _D3DDDIARG_SETMATERIAL
{
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    FLOAT           Power;          /* Sharpness if specular highlight */
} D3DDDIARG_SETMATERIAL;

typedef enum _D3DDDI_SETLIGHT_TYPE
{
    // Values for DataType in D3DDDIARG_SETLIGHT
    D3DDDI_SETLIGHT_ENABLE  =   0,
    D3DDDI_SETLIGHT_DISABLE =   1,
    // If this is set, light data will be passed in after the
    // D3DLIGHT7 structure
    D3DDDI_SETLIGHT_DATA    =   2,
} D3DDDI_SETLIGHT_TYPE;

typedef struct _D3DDDIARG_SETLIGHT
{
    UINT                    Index;
    D3DDDI_SETLIGHT_TYPE    DataType;
} D3DDDIARG_SETLIGHT;

typedef struct _D3DDDI_LIGHT
{
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    FLOAT           Range;            /* Cutoff range */
    FLOAT           Falloff;          /* Falloff */
    FLOAT           Attenuation0;     /* Constant attenuation */
    FLOAT           Attenuation1;     /* Linear attenuation */
    FLOAT           Attenuation2;     /* Quadratic attenuation */
    FLOAT           Theta;            /* Inner angle of spotlight cone */
    FLOAT           Phi;              /* Outer angle of spotlight cone */
} D3DDDI_LIGHT;

typedef struct _D3DDDIARG_CREATELIGHT
{
    UINT        Index;
} D3DDDIARG_CREATELIGHT;

typedef struct _D3DDDIARG_DESTROYLIGHT
{
    UINT        Index;
} D3DDDIARG_DESTROYLIGHT;

typedef struct _D3DDDIARG_SETCLIPPLANE
{
    UINT        Index;
    FLOAT       Plane[4];
} D3DDDIARG_SETCLIPPLANE;

typedef struct _D3DDDI_LOCKFLAGS
{
    union
    {
        struct
        {
            UINT    ReadOnly        : 1;        // 0x00000001
            UINT    WriteOnly       : 1;        // 0x00000002
            UINT    NoOverwrite     : 1;        // 0x00000004
            UINT    Discard         : 1;        // 0x00000008
            UINT    RangeValid      : 1;        // 0x00000010
            UINT    AreaValid       : 1;        // 0x00000020
            UINT    BoxValid        : 1;        // 0x00000040
            UINT    NotifyOnly      : 1;        // 0x00000080
            UINT    MightDrawFromLocked : 1;    // 0x00000100
            UINT    DoNotWait       : 1;        // 0x00000200
            UINT    Reserved        :22;        // 0xFFFFFC00
        };
        UINT Value;
    };
} D3DDDI_LOCKFLAGS;

typedef struct _D3DDDIARG_LOCK
{
    HANDLE              hResource;          // in: resource to lock, used by Lock to driver
    UINT                SubResourceIndex;   // in: zero based subresource index
    union
    {
        D3DDDIRANGE     Range;              // in: range being locked
        RECT            Area;               // in: area being locked
        D3DDDIBOX       Box;                // in: volume being locked
    };
    VOID*               pSurfData;          // out: pointer to memory
    UINT                Pitch;              // out: pitch of memory
    UINT                SlicePitch;         // out: slice pitch of memory
    D3DDDI_LOCKFLAGS    Flags;              // in: flags
} D3DDDIARG_LOCK;

typedef struct _D3DDDI_UNLOCKFLAGS
{
    union
    {
        struct
        {
            UINT    NotifyOnly      : 1;        // 0x00000001
            UINT    Reserved        :31;        // 0xFFFFFFFE
        };
        UINT Value;
    };
} D3DDDI_UNLOCKFLAGS;

typedef struct _D3DDDIARG_UNLOCK
{
    HANDLE              hResource;          // in: resource to lock, used by Lock to driver
    UINT                SubResourceIndex;   // in: zero based subresource index
    D3DDDI_UNLOCKFLAGS  Flags;              // in: flags
} D3DDDIARG_UNLOCK;

typedef struct _D3DDDI_OPENRESOURCEFLAGS
{
    union
    {
        struct
        {
            UINT    Fullscreen      : 1;        // 0x00000001
            UINT    AlphaOverride   : 1;        // 0x00000002
            UINT    Reserved        :30;        // 0xFFFFFFFC
        };
        UINT Value;
    };
} D3DDDI_OPENRESOURCEFLAGS;

typedef struct _D3DDDI_LOCKASYNCFLAGS
{
    union
    {
        struct
        {
            UINT    NoOverwrite          : 1;           // 0x00000001
            UINT    Discard              : 1;           // 0x00000002
            UINT    RangeValid           : 1;           // 0x00000004
            UINT    AreaValid            : 1;           // 0x00000008
            UINT    BoxValid             : 1;           // 0x00000010
            UINT    NoExistingReferences : 1;           // 0x00000020
            UINT    NotifyOnly           : 1;           // 0x00000040
            UINT    Reserved             : 25;          // 0xFFFFFF80
        };
        UINT Value;
    };
} D3DDDI_LOCKASYNCFLAGS;

typedef struct _D3DDDIARG_LOCKASYNC
{
    HANDLE                hResource;        // in: resource to lock
    UINT                  SubResourceIndex; // in: zero based subresource index
    D3DDDI_LOCKASYNCFLAGS Flags;            // in: lock flags
    union
    {
        D3DDDIRANGE     Range;              // in: range being locked
        RECT            Area;               // in: area being locked
        D3DDDIBOX       Box;                // in: volume being locked
    };
    HANDLE                hCookie;          // out: A handle representing the renamed surface (only valid if Discard flag is set)
    VOID*                 pSurfData;        // out: pointer to surface memory
    UINT                  Pitch;            // out: pitch of memory
    UINT                  SlicePitch;       // out: slice pitch of memory
} D3DDDIARG_LOCKASYNC;

typedef struct _D3DDDI_UNLOCKASYNCFLAGS
{
    union
    {
        struct
        {
            UINT    NotifyOnly      : 1;        // 0x00000001
            UINT    Reserved        :31;        // 0xFFFFFFFE
        };
        UINT Value;
    };
} D3DDDI_UNLOCKASYNCFLAGS;

typedef struct _D3DDDIARG_UNLOCKASYNC
{
    HANDLE                  hResource;         // in: resource to unlock
    UINT                    SubResourceIndex;  // in: zero based subresource index
    D3DDDI_UNLOCKASYNCFLAGS Flags;             // in: lock flags
} D3DDDIARG_UNLOCKASYNC;

typedef struct _D3DDDIARG_RENAME
{
    HANDLE        hResource;        // in: resource
    UINT          SubResourceIndex; // in: zero based subresource index
    HANDLE        hCookie;          // in: handle returned by LockAsync
} D3DDDIARG_RENAME;

typedef struct _D3DDDIARG_OPENRESOURCE
{
    UINT                        NumAllocations;             // in : Number of open allocation structs
    D3DDDI_OPENALLOCATIONINFO*  pOpenAllocationInfo;        // in : Array of open allocation structs
    D3DKMT_HANDLE               hKMResource;                // in : Kernel resource handle
    VOID*                       pPrivateDriverData;         // in : Ptr to per reosurce PrivateDriverData
    UINT                        PrivateDriverDataSize;      // in : Size of resource pPrivateDriverData
    HANDLE                      hResource;                  // in/out : D3D runtime handle / UM driver handle
    D3DDDI_ROTATION             Rotation;                   // in: The orientation of the resource. (0, 90, 180, 270)
    D3DDDI_OPENRESOURCEFLAGS    Flags;                      // in: Flags
}D3DDDIARG_OPENRESOURCE;

typedef struct _D3DDDIARG_CREATEVERTEXSHADERDECL
{
    UINT    NumVertexElements;              // in:  Number of vertex elements
    HANDLE  ShaderHandle;                   // out: Shader function handle
} D3DDDIARG_CREATEVERTEXSHADERDECL;

typedef struct _D3DDDIARG_CREATEVERTEXSHADERFUNC
{
    UINT    Size;           // in:  Shader function size in bytes
    HANDLE  ShaderHandle;   // out: Shader function handle
} D3DDDIARG_CREATEVERTEXSHADERFUNC;

typedef struct _D3DDDIARG_SETSTREAMSOURCE
{
    UINT    Stream;         // Stream index, starting from zero
    HANDLE  hVertexBuffer;  // Vertex buffer handle
    UINT    Offset;         // Offset of the first vertex size in bytes
    UINT    Stride;         // Vertex size in bytes
} D3DDDIARG_SETSTREAMSOURCE;

typedef struct _D3DDDIARG_SETSTREAMSOURCEFREQ
{
    UINT    Stream;         // Stream index, starting from zero
    UINT    Divider;        // Stream source divider
} D3DDDIARG_SETSTREAMSOURCEFREQ;

typedef struct _D3DDDIARG_SETCONVOLUTIONKERNELMONO
{
    UINT    Width;          // Kernel width
    UINT    Height;         // Kernel height
    FLOAT*  pKernelRow;     // Row weights
    FLOAT*  pKernelCol;     // Column weights
} D3DDDIARG_SETCONVOLUTIONKERNELMONO;

typedef enum _D3DDDI_COMPOSERECTSOP
{
    D3DDDICOMPOSERECTS_COPY        = 1,
    D3DDDICOMPOSERECTS_OR          = 2,
    D3DDDICOMPOSERECTS_AND         = 3,
    D3DDDICOMPOSERECTS_NEG         = 4,
    D3DDDICOMPOSERECTS_FORCE_UINT  =0x7fffffff
} D3DDDI_COMPOSERECTSOP;

typedef struct _D3DDDIARG_COMPOSERECTS
{
    HANDLE                hSrcResource;
    UINT                  SrcSubResourceIndex;
    HANDLE                hDstResource;
    UINT                  DstSubResourceIndex;
    HANDLE                hSrcRectDescsVB;
    UINT                  NumRects;
    HANDLE                hDstRectDescsVB;
    D3DDDI_COMPOSERECTSOP Operation;
    INT                   XOffset;
    INT                   YOffset;
} D3DDDIARG_COMPOSERECTS;

typedef struct _D3DDDI_BLTFLAGS
{
    union
    {
        struct
        {
            UINT    Point                : 1;// 0x00000001
            UINT    Linear               : 1;// 0x00000002
            UINT    SrcColorKey          : 1;// 0x00000004
            UINT    DstColorKey          : 1;// 0x00000008
            UINT    MirrorLeftRight      : 1;// 0x00000010
            UINT    MirrorUpDown         : 1;// 0x00000020
            UINT    LinearToSrgb         : 1;// 0x00000040
            UINT    Rotate               : 1;// 0x00000080
            UINT    BeginPresentToDwm    : 1;// 0x00000100
            UINT    ContinuePresentToDwm : 1;// 0x00000200
            UINT    EndPresentToDwm      : 1;// 0x00000400
            UINT    Reserved             :21;// 0xFFFFF800
        };
        UINT        Value;
    };
} D3DDDI_BLTFLAGS;

typedef struct _D3DDDIARG_BLT
{
    HANDLE  hSrcResource;           // Source surface
    UINT    SrcSubResourceIndex;    // Index of surface level
    RECT    SrcRect;                // Source rectangle
    HANDLE  hDstResource;           // Dest surface
    UINT    DstSubResourceIndex;    // Index of surface level
    RECT    DstRect;                // Dest rectangle
    UINT    ColorKey;               // Colorkey value
    D3DDDI_BLTFLAGS Flags;          // Flags
} D3DDDIARG_BLT;

typedef struct _D3DDDI_COLORFILLFLAGS
{
    union
    {
        struct
        {
            UINT    PresentToDwm :  1;// 0x00000001
            UINT    Reserved     : 31;// 0xFFFFFFFE
        };
        UINT        Value;
    };
} D3DDDI_COLORFILLFLAGS;

typedef struct _D3DDDIARG_COLORFILL
{
    HANDLE                hResource;          // Surface getting filled
    UINT                  SubResourceIndex;   // Index of surface level
    RECT                  DstRect;            // Surface dimensions to fill
    D3DCOLOR              Color;              // A8R8G8B8 fill color
    D3DDDI_COLORFILLFLAGS Flags;              // Flags
} D3DDDIARG_COLORFILL;

typedef struct _D3DDDIARG_DEPTHFILL
{
    HANDLE      hResource;          // Surface getting filled
    UINT        SubResourceIndex;   // Index of surface level
    RECT        DstRect;            // Surface dimensions to fill
    UINT        Depth;              // Native depth value
} D3DDDIARG_DEPTHFILL;

typedef enum _D3DDDIQUERYTYPE
{
    D3DDDIQUERYTYPE_VCACHE                 = 4, /* D3DISSUE_END */
    D3DDDIQUERYTYPE_RESOURCEMANAGER        = 5, /* D3DISSUE_END */
    D3DDDIQUERYTYPE_VERTEXSTATS            = 6, /* D3DISSUE_END */
    D3DDDIQUERYTYPE_DDISTATS               = 7, /* D3DISSUE_END */
    D3DDDIQUERYTYPE_EVENT                  = 8, /* D3DISSUE_END */
    D3DDDIQUERYTYPE_OCCLUSION              = 9, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DDDIQUERYTYPE_TIMESTAMP              = 10, /* D3DISSUE_END */
    D3DDDIQUERYTYPE_TIMESTAMPDISJOINT      = 11, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DDDIQUERYTYPE_TIMESTAMPFREQ          = 12, /* D3DISSUE_END */
    D3DDDIQUERYTYPE_PIPELINETIMINGS        = 13, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DDDIQUERYTYPE_INTERFACETIMINGS       = 14, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DDDIQUERYTYPE_VERTEXTIMINGS          = 15, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DDDIQUERYTYPE_PIXELTIMINGS           = 16, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DDDIQUERYTYPE_BANDWIDTHTIMINGS       = 17, /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DDDIQUERYTYPE_CACHEUTILIZATION       = 18, /* D3DISSUE_BEGIN, D3DISSUE_END */
} D3DDDIQUERYTYPE;

typedef struct _D3DDDIARG_CREATEQUERY
{
    D3DDDIQUERYTYPE QueryType;
    HANDLE          hQuery;
} D3DDDIARG_CREATEQUERY;

typedef struct _D3DDDI_ISSUEQUERYFLAGS
{
    union
    {
        struct
        {
            UINT        Begin    :  1;
            UINT        End      :  1;
            UINT        Reserved : 30;
        };
        UINT Value;
    };
} D3DDDI_ISSUEQUERYFLAGS;

typedef struct _D3DDDIARG_ISSUEQUERY
{
    HANDLE          hQuery;
    D3DDDI_ISSUEQUERYFLAGS Flags;
} D3DDDIARG_ISSUEQUERY;

typedef struct _D3DDDIARG_GETQUERYDATA
{
    HANDLE          hQuery;
    VOID*           pData;
} D3DDDIARG_GETQUERYDATA;

typedef struct _D3DDDIARG_SETRENDERTARGET
{
    UINT        RenderTargetIndex;
    HANDLE      hRenderTarget;
    UINT        SubResourceIndex;
} D3DDDIARG_SETRENDERTARGET;

typedef struct _D3DDDIARG_SETDEPTHSTENCIL
{
    HANDLE      hZBuffer;
} D3DDDIARG_SETDEPTHSTENCIL;

typedef enum _D3DDDITEXTUREFILTERTYPE
{
    D3DDDITEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
    D3DDDITEXF_POINT           = 1,    // nearest
    D3DDDITEXF_LINEAR          = 2,    // linear interpolation
    D3DDDITEXF_ANISOTROPIC     = 3,    // anisotropic
    D3DDDITEXF_PYRAMIDALQUAD   = 6,    // 4-sample tent
    D3DDDITEXF_GAUSSIANQUAD    = 7,    // 4-sample gaussian
    D3DDDITEXF_FORCE_UINT      = 0x7fffffff,   // force 32-bit size enum
} D3DDDITEXTUREFILTERTYPE;

typedef struct _D3DDDIARG_GENERATEMIPSUBLEVELS
{
    HANDLE                  hResource;
    D3DDDITEXTUREFILTERTYPE Filter;
} D3DDDIARG_GENERATEMIPSUBLEVELS;

typedef struct _D3DDDIVERTEXELEMENT
{
    USHORT  Stream;     // Stream index
    USHORT  Offset;     // Offset in the stream in bytes
    UCHAR   Type;       // Data type
    UCHAR   Method;     // Processing method
    UCHAR   Usage;      // Semantics
    UCHAR   UsageIndex; // Semantic index
} D3DDDIVERTEXELEMENT;

typedef enum _D3DDDIBASISTYPE
{
    D3DDDIBASIS_BEZIER      = 0,
    D3DDDIBASIS_BSPLINE     = 1,
    D3DDDIBASIS_CATMULL_ROM = 2, /* In D3D8 this used to be D3DBASIS_INTERPOLATE */
    D3DDDIBASIS_FORCE_UINT  = 0x7fffffff,
} D3DDDIBASISTYPE;

typedef enum _D3DDDIDEGREETYPE
{
   D3DDDIDEGREE_LINEAR      = 1,
   D3DDDIDEGREE_QUADRATIC   = 2,
   D3DDDIDEGREE_CUBIC       = 3,
   D3DDDIDEGREE_QUINTIC     = 5,
   D3DDDIDEGREE_FORCE_UINT  = 0x7fffffff,
} D3DDDIDEGREETYPE;

typedef struct _D3DDDIRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DDDIBASISTYPE     Basis;
    D3DDDIDEGREETYPE    Degree;
} D3DDDIRECTPATCH_INFO;

typedef struct _D3DDDITRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DDDIBASISTYPE     Basis;
    D3DDDIDEGREETYPE    Degree;
} D3DDDITRIPATCH_INFO;

typedef struct _D3DDDIARG_CREATEPIXELSHADER
{
    UINT    CodeSize;       // in:  Shader code size in bytes
    HANDLE  ShaderHandle;   // out: Shader handle
} D3DDDIARG_CREATEPIXELSHADER;

typedef struct _DXVADDI_EXTENDEDFORMAT
{
    union {
        struct {
            UINT SampleFormat : 8;           // See DXVADDI_SAMPLEFORMAT
            UINT VideoChromaSubsampling : 4; // See DXVADDI_VIDEOCHROMASUBSAMPLING
            UINT NominalRange : 3;           // See DXVADDI_NOMINALRANGE
            UINT VideoTransferMatrix : 3;    // See DXVADDI_VIDEOTRANSFERMATRIX
            UINT VideoLighting : 4;          // See DXVADDI_VIDEOLIGHTING
            UINT VideoPrimaries : 5;         // See DXVADDI_VIDEOPRIMARIES
            UINT VideoTransferFunction : 5;  // See DXVADDI_VIDEOTRANSFERFUNCTION
        };
        UINT Value;
    };
} DXVADDI_EXTENDEDFORMAT;

typedef enum _DXVADDI_SAMPLEFORMAT
{
    DXVADDI_SampleFormatMask = 0x00FF,   // 8 bits used for DXVA Sample format
    DXVADDI_SampleUnknown = 0,
    DXVADDI_SampleProgressiveFrame = 2,
    DXVADDI_SampleFieldInterleavedEvenFirst = 3,
    DXVADDI_SampleFieldInterleavedOddFirst = 4,
    DXVADDI_SampleFieldSingleEven = 5,
    DXVADDI_SampleFieldSingleOdd = 6,
    DXVADDI_SampleSubStream = 7
} DXVADDI_SAMPLEFORMAT;

typedef enum _DXVADDI_VIDEOCHROMASUBSAMPLING
{
    DXVADDI_VideoChromaSubsamplingMask = 0x0F,
    DXVADDI_VideoChromaSubsampling_Unknown = 0,
    DXVADDI_VideoChromaSubsampling_ProgressiveChroma = 0x8,
    DXVADDI_VideoChromaSubsampling_Horizontally_Cosited = 0x4,
    DXVADDI_VideoChromaSubsampling_Vertically_Cosited = 0x2,
    DXVADDI_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = 0x1,
    // 4:2:0 variations
    DXVADDI_VideoChromaSubsampling_MPEG2  = DXVADDI_VideoChromaSubsampling_Horizontally_Cosited |
                                            DXVADDI_VideoChromaSubsampling_Vertically_AlignedChromaPlanes, 

    DXVADDI_VideoChromaSubsampling_MPEG1  = DXVADDI_VideoChromaSubsampling_Vertically_AlignedChromaPlanes, 

    DXVADDI_VideoChromaSubsampling_DV_PAL  =DXVADDI_VideoChromaSubsampling_Horizontally_Cosited |
                                            DXVADDI_VideoChromaSubsampling_Vertically_Cosited,
    // 4:4:4, 4:2:2, 4:1:1
    DXVADDI_VideoChromaSubsampling_Cosited =DXVADDI_VideoChromaSubsampling_Horizontally_Cosited |
                                            DXVADDI_VideoChromaSubsampling_Vertically_Cosited |
                                            DXVADDI_VideoChromaSubsampling_Vertically_AlignedChromaPlanes

} DXVADDI_VIDEOCHROMASUBSAMPLING;

typedef enum _DXVADDI_NOMINALRANGE
{
    DXVADDI_NominalRangeMask = 0x07,
    DXVADDI_NominalRange_Unknown = 0,
    DXVADDI_NominalRange_Normal = 1,
    DXVADDI_NominalRange_Wide = 2,
    // explicit range forms
    DXVADDI_NominalRange_0_255 = 1,
    DXVADDI_NominalRange_16_235 = 2,
    DXVADDI_NominalRange_48_208 = 3
} DXVADDI_NOMINALRANGE;

typedef enum _DXVADDI_VIDEOTRANSFERMATRIX
{
    DXVADDI_VideoTransferMatrixMask = 0x07,
    DXVADDI_VideoTransferMatrix_Unknown = 0,
    DXVADDI_VideoTransferMatrix_BT709 = 1,
    DXVADDI_VideoTransferMatrix_BT601 = 2,
    DXVADDI_VideoTransferMatrix_SMPTE240M = 3
} DXVADDI_VIDEOTRANSFERMATRIX;

typedef enum _DXVADDI_VIDEOLIGHTING
{
    DXVADDI_VideoLightingMask = 0x0F,
    DXVADDI_VideoLighting_Unknown = 0,
    DXVADDI_VideoLighting_bright = 1,
    DXVADDI_VideoLighting_office = 2,
    DXVADDI_VideoLighting_dim = 3,
    DXVADDI_VideoLighting_dark = 4
} DXVADDI_VIDEOLIGHTING;

typedef enum _DXVADDI_VIDEOPRIMARIES
{
    DXVADDI_VideoPrimariesMask = 0x001f,
    DXVADDI_VideoPrimaries_Unknown = 0,
    DXVADDI_VideoPrimaries_reserved = 1,
    DXVADDI_VideoPrimaries_BT709 = 2,
    DXVADDI_VideoPrimaries_BT470_2_SysM = 3,
    DXVADDI_VideoPrimaries_BT470_2_SysBG = 4,
    DXVADDI_VideoPrimaries_SMPTE170M = 5,
    DXVADDI_VideoPrimaries_SMPTE240M = 6,
    DXVADDI_VideoPrimaries_EBU3213 = 7,
    DXVADDI_VideoPrimaries_SMPTE_C = 8
} DXVADDI_VIDEOPRIMARIES;

typedef enum _DXVADDI_VIDEOTRANSFERFUNCTION
{
    DXVADDI_VideoTransFuncMask = 0x001f,
    DXVADDI_VideoTransFunc_Unknown = 0,
    DXVADDI_VideoTransFunc_10 = 1,
    DXVADDI_VideoTransFunc_18 = 2,
    DXVADDI_VideoTransFunc_20 = 3,
    DXVADDI_VideoTransFunc_22 = 4,
    DXVADDI_VideoTransFunc_709  = 5,
    DXVADDI_VideoTransFunc_240M = 6,
    DXVADDI_VideoTransFunc_sRGB = 7,
    DXVADDI_VideoTransFunc_28 = 8
} DXVADDI_VIDEOTRANSFERFUNCTION;

#define DXVADDI_VideoTransFunc_22_709       DXVADDI_VideoTransFunc_709
#define DXVADDI_VideoTransFunc_22_240M      DXVADDI_VideoTransFunc_240M
#define DXVADDI_VideoTransFunc_22_8bit_sRGB DXVADDI_VideoTransFunc_sRGB

typedef struct _DXVADDI_FREQUENCY
{
    UINT              Numerator;
    UINT              Denominator;
} DXVADDI_FREQUENCY;

typedef struct _DXVADDI_VIDEODESC
{
    UINT                   SampleWidth;
    UINT                   SampleHeight;
    DXVADDI_EXTENDEDFORMAT SampleFormat;
    D3DDDIFORMAT           Format;
    DXVADDI_FREQUENCY      InputSampleFreq;
    DXVADDI_FREQUENCY      OutputFrameFreq;
    UINT                   UABProtectionLevel;
    UINT                   Reserved;
} DXVADDI_VIDEODESC;

typedef struct _DXVADDI_CONFIGPICTUREDECODE
{
    GUID        guidConfigBitstreamEncryption;
    GUID        guidConfigMBcontrolEncryption;
    GUID        guidConfigResidDiffEncryption;
    UINT        ConfigBitstreamRaw;
    UINT        ConfigMBcontrolRasterOrder;
    UINT        ConfigResidDiffHost;
    UINT        ConfigSpatialResid8;
    UINT        ConfigResid8Subtraction;
    UINT        ConfigSpatialHost8or9Clipping;
    UINT        ConfigSpatialResidInterleaved;
    UINT        ConfigIntraResidUnsigned;
    UINT        ConfigResidDiffAccelerator;
    UINT        ConfigHostInverseScan;
    UINT        ConfigSpecificIDCT;
    UINT        Config4GroupedCoefs;
    USHORT      ConfigMinRenderTargetBuffCount;
    USHORT      ConfigDecoderSpecific;
} DXVADDI_CONFIGPICTUREDECODE;

typedef struct _DXVADDI_PRIVATEDATA
{
    VOID*             pData;
    UINT              DataSize;
} DXVADDI_PRIVATEDATA;

typedef struct _D3DDDIARG_CREATEDECODEDEVICE
{
    CONST GUID*                  pGuid;
    DXVADDI_VIDEODESC            VideoDesc;
    DXVADDI_CONFIGPICTUREDECODE* pConfig;
    HANDLE                       hDecode;
} D3DDDIARG_CREATEDECODEDEVICE;

typedef struct _D3DDDIARG_SETDECODERENDERTARGET
{
    HANDLE      hDecode;
    HANDLE      hRenderTarget;
    UINT        SubResourceIndex;
} D3DDDIARG_SETDECODERENDERTARGET;

typedef struct DECLSPEC_ALIGN(16) _DXVADDI_PVP_BLOCK128
{
    BYTE        Data[16];
} DXVADDI_PVP_BLOCK128, DXVADDI_PVP_KEY128;

typedef struct _DXVADDI_PVP_SETKEY
{
    DXVADDI_PVP_KEY128  ContentKey;
} DXVADDI_PVP_SETKEY;

typedef struct _D3DDDIARG_DECODEBEGINFRAME
{
    HANDLE              hDecode;
    DXVADDI_PVP_SETKEY* pPVPSetKey;
} D3DDDIARG_DECODEBEGINFRAME;

typedef struct _D3DDDIARG_DECODEENDFRAME
{
    HANDLE      hDecode;
    HANDLE*     pHandleComplete;        // reserved
} D3DDDIARG_DECODEENDFRAME;

typedef struct DECLSPEC_ALIGN(16) _DXVADDI_PVP_HW_IV
{
    ULONGLONG   IV;         // Big-Endian IV
    ULONGLONG   Count;      // Big-Endian Block Count
} DXVADDI_PVP_HW_IV;

typedef struct _DXVADDI_DECODEBUFFERDESC
{
    HANDLE              hBuffer;
    D3DDDIFORMAT        CompressedBufferType;
    UINT                BufferIndex;    // reserved
    UINT                DataOffset;
    UINT                DataSize;
    UINT                FirstMBaddress;
    UINT                NumMBsInBuffer;
    UINT                Width;          // reserved
    UINT                Height;         // reserved
    UINT                Stride;         // reserved
    UINT                ReservedBits;
    DXVADDI_PVP_HW_IV   *pCipherCounter;
} DXVADDI_DECODEBUFFERDESC;

typedef struct _D3DDDIARG_DECODEEXECUTE
{
    HANDLE                          hDecode;
    UINT                            NumCompBuffers;
    DXVADDI_DECODEBUFFERDESC*       pCompressedBuffers;
} D3DDDIARG_DECODEEXECUTE;

typedef struct _DXVADDI_PRIVATEBUFFER
{
    HANDLE                 hResource;
    UINT                   SubResourceIndex;
    UINT                   DataOffset;
    UINT                   DataSize;
} DXVADDI_PRIVATEBUFFER;

typedef struct _D3DDDIARG_DECODEEXTENSIONEXECUTE
{
    HANDLE                 hDecode;
    UINT                   Function;
    DXVADDI_PRIVATEDATA*   pPrivateInput;
    DXVADDI_PRIVATEDATA*   pPrivateOutput;
    UINT                   NumBuffers;
    DXVADDI_PRIVATEBUFFER* pBuffers;
} D3DDDIARG_DECODEEXTENSIONEXECUTE;

typedef struct _D3DDDIARG_CREATEVIDEOPROCESSDEVICE
{
    CONST GUID*       pVideoProcGuid;
    DXVADDI_VIDEODESC VideoDesc;
    D3DDDIFORMAT      RenderTargetFormat;
    UINT              MaxSubStreams;
    HANDLE            hVideoProcess;
} D3DDDIARG_CREATEVIDEOPROCESSDEVICE;

typedef struct _D3DDDIARG_SETVIDEOPROCESSRENDERTARGET
{
    HANDLE      hVideoProcess;
    HANDLE      hRenderTarget;
    UINT        SubResourceIndex;
} D3DDDIARG_SETVIDEOPROCESSRENDERTARGET;

typedef struct _D3DDDIARG_VIDEOPROCESSENDFRAME
{
    HANDLE      hVideoProcess;
    HANDLE*     pHandleComplete;        // reserved
} D3DDDIARG_VIDEOPROCESSENDFRAME;

typedef struct _DXVADDI_AYUVSAMPLE8
{
    UCHAR     Cr;      // V
    UCHAR     Cb;      // U
    UCHAR     Y;
    UCHAR     Alpha;
} DXVADDI_AYUVSAMPLE8;

typedef struct _DXVADDI_AYUVSAMPLE16
{
    USHORT     Cr;      // V
    USHORT     Cb;      // U
    USHORT     Y;
    USHORT     Alpha;
} DXVADDI_AYUVSAMPLE16;

typedef struct _DXVADDI_FIXED32
{
    union {
        struct {
            USHORT      Fraction;
            SHORT       Value;
        };
        LONG ll;
    };
} DXVADDI_FIXED32;

typedef struct _DXVADDI_PROCAMPVALUES
{
    DXVADDI_FIXED32    Brightness;
    DXVADDI_FIXED32    Contrast;
    DXVADDI_FIXED32    Hue;
    DXVADDI_FIXED32    Saturation;
} DXVADDI_PROCAMPVALUES;

typedef LONGLONG REFERENCE_TIME;

#define DXVADDI_SAMPLEDATA_RFF                  0x0001
#define DXVADDI_SAMPLEDATA_TFF                  0x0002
#define DXVADDI_SAMPLEDATA_RFF_TFF_PRESENT      0x0004

typedef struct _DXVADDI_VIDEOSAMPLEFLAGS
{
    union
    {
        struct
        {
            UINT    PaletteChanged      : 1;    // 0x00000001
            UINT    SrcRectChanged      : 1;    // 0x00000002
            UINT    DstRectChanged      : 1;    // 0x00000004
            UINT    ColorDataChanged    : 1;    // 0x00000008
            UINT    PlanarAlphaChanged  : 1;    // 0x00000010
            UINT    Reserved            :11;    // 0x0000FFE0
            UINT    SampleData          :16;    // 0xFFFF0000
        };
        UINT        Value;
    };
} DXVADDI_VIDEOSAMPLEFLAGS;

typedef struct _DXVADDI_VIDEOSAMPLE
{
    REFERENCE_TIME          Start;
    REFERENCE_TIME          End;
    DXVADDI_EXTENDEDFORMAT  SampleFormat;
    DXVADDI_VIDEOSAMPLEFLAGS SampleFlags;
    HANDLE                  SrcResource;
    UINT                    SrcSubResourceIndex;
    RECT                    SrcRect;
    RECT                    DstRect;
    DXVADDI_AYUVSAMPLE8     Pal[16];
    DXVADDI_FIXED32         PlanarAlpha;
} DXVADDI_VIDEOSAMPLE;

typedef struct _DXVADDI_FILTERVALUES
{
    DXVADDI_FIXED32 Level;
    DXVADDI_FIXED32 Threshold;
    DXVADDI_FIXED32 Radius;
} DXVADDI_FILTERVALUES;

#define DXVADDI_DESTDATA_RFF                    0x0001
#define DXVADDI_DESTDATA_TFF                    0x0002
#define DXVADDI_DESTDATA_RFF_TFF_PRESENT        0x0004

typedef struct _DXVADDI_VIDEOPROCESSBLTFLAGS
{
    union
    {
        struct
        {
            UINT    BackgroundChanged   : 1;    // 0x00000001
            UINT    TargetRectChanged   : 1;    // 0x00000002
            UINT    ColorDataChanged    : 1;    // 0x00000004
            UINT    AlphaChanged        : 1;    // 0x00000008
            UINT    Reserved            :12;    // 0x0000FFF0
            UINT    DestData            :16;    // 0xFFFF0000
        };
        UINT        Value;
    };
} DXVADDI_VIDEOPROCESSBLTFLAGS;

typedef struct _D3DDDIARG_VIDEOPROCESSBLT
{
    REFERENCE_TIME          TargetFrame;
    HANDLE                  hVideoProcess;
    RECT                    TargetRect;
    SIZE                    ConstrictionSize;
    UINT                    StreamingFlags;
    DXVADDI_AYUVSAMPLE16    BackgroundColor;
    DXVADDI_EXTENDEDFORMAT  DestFormat;
    DXVADDI_VIDEOPROCESSBLTFLAGS DestFlags;
    DXVADDI_PROCAMPVALUES   ProcAmpValues;
    DXVADDI_FIXED32         Alpha;
    DXVADDI_FILTERVALUES    NoiseFilterLuma;
    DXVADDI_FILTERVALUES    NoiseFilterChroma;
    DXVADDI_FILTERVALUES    DetailFilterLuma;
    DXVADDI_FILTERVALUES    DetailFilterChroma;
    DXVADDI_VIDEOSAMPLE*    pSrcSurfaces;
    UINT                    NumSrcSurfaces;
} D3DDDIARG_VIDEOPROCESSBLT;

typedef struct _D3DDDIARG_CREATEEXTENSIONDEVICE
{
    CONST GUID*                  pGuid;
    DXVADDI_PRIVATEDATA*         pPrivate;
    HANDLE                       hExtension;
} D3DDDIARG_CREATEEXTENSIONDEVICE;

typedef struct _D3DDDIARG_EXTENSIONEXECUTE
{
    HANDLE                       hExtension;
    UINT                         Function;
    DXVADDI_PRIVATEDATA*         pPrivateInput;
    DXVADDI_PRIVATEDATA*         pPrivateOutput;
    UINT                         NumBuffers;
    DXVADDI_PRIVATEBUFFER*       pBuffers;
} D3DDDIARG_EXTENSIONEXECUTE;

typedef struct _D3DDDI_OVERLAYINFOFLAGS
{
   union
   {
       struct
       {
           UINT          DstColorKey     : 1; // 0x00000001
           UINT          DstColorKeyRange: 1; // 0x00000002
           UINT          SrcColorKey     : 1; // 0x00000004
           UINT          SrcColorKeyRange: 1; // 0x00000008
           UINT          Bob             : 1; // 0x00000010
           UINT          Interleaved     : 1; // 0x00000020
           UINT          MirrorLeftRight : 1; // 0x00000040
           UINT          MirrorUpDown    : 1; // 0x00000080
           UINT          Deinterlace     : 1; // 0x00000100
           UINT          Reserved        :23; // 0xFFFFFE00
       };
       UINT Value;
    };
} D3DDDI_OVERLAYINFOFLAGS;

typedef struct _D3DDDI_OVERLAYINFO
{
    HANDLE            hResource;        // in: Resource to be displayed
    UINT              SubResourceIndex; // in: Sub resource index
    RECT              DstRect;          // in: Dest rect
    RECT              SrcRect;          // in: Source rect
    UINT              DstColorKeyLow;   // in: Low dest colorkey value
    UINT              DstColorKeyHigh;  // in: High dest colorkey value
    UINT              SrcColorKeyLow;   // in: Low source colorkey value
    UINT              SrcColorKeyHigh;  // in: High source colorkey value
    D3DDDI_OVERLAYINFOFLAGS Flags;      // in: Flags
} D3DDDI_OVERLAYINFO;

typedef struct _D3DDDIARG_CREATEOVERLAY
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;      // in
    D3DDDI_OVERLAYINFO              OverlayInfo;        // in
    HANDLE                          hOverlay;           // out: Driver overlay handle
} D3DDDIARG_CREATEOVERLAY;

typedef struct _D3DDDIARG_UPDATEOVERLAY
{
    HANDLE             hOverlay;           // in: Driver overlay handle
    D3DDDI_OVERLAYINFO OverlayInfo;        // in
} D3DDDIARG_UPDATEOVERLAY;

typedef struct _D3DDDI_FLIPOVERLAYFLAGS
{
    union
    {
        struct
        {
            UINT          Even             : 1; // 0x00000001
            UINT          Odd              : 1; // 0x00000002
            UINT          Reserved         :30; // 0xFFFFFFFC
        };
        UINT Value;
    };
} D3DDDI_FLIPOVERLAYFLAGS;

typedef struct _D3DDDIARG_FLIPOVERLAY
{
    HANDLE            hOverlay;             // in: Driver overlay handle
    HANDLE            hSource;              // in: Resource currently displayed
    UINT              SourceIndex;          // in: Sub resource index
    D3DDDI_FLIPOVERLAYFLAGS Flags;          // in: Flags
} D3DDDIARG_FLIPOVERLAY;

typedef struct _D3DDDI_OVERLAYCOLORCONTROLSFLAGS
{
    union
    {
        struct
        {
            UINT           Brightness      :  1;
            UINT           Contrast        :  1;
            UINT           Hue             :  1;
            UINT           Saturation      :  1;
            UINT           Sharpness       :  1;
            UINT           Gamma           :  1;
            UINT           ColorEnable     :  1;
            UINT           Reserved        : 25;
        };
        UINT Value;
    };
} D3DDDI_OVERLAYCOLORCONTROLSFLAGS;

typedef struct _D3DDDI_OVERLAYCOLORCONTROLS
{
    INT                BrightnessSetting;
    INT                ContrastSetting;
    INT                HueSetting;
    INT                SaturationSetting;
    INT                SharpnessSetting;
    INT                GammaSetting;
    INT                ColorEnableSetting;
    D3DDDI_OVERLAYCOLORCONTROLSFLAGS Flags;
} D3DDDI_OVERLAYCOLORCONTROLS;

typedef struct _D3DDDIARG_GETOVERLAYCOLORCONTROLS
{
    HANDLE                      hOverlay;         // in: Driver overlay handle
    HANDLE                      hResource;        // in: Resource associated with the overlay
    D3DDDI_OVERLAYCOLORCONTROLS ColorControls;    // out: Current color controls
} D3DDDIARG_GETOVERLAYCOLORCONTROLS;

typedef struct _D3DDDIARG_SETOVERLAYCOLORCONTROLS
{
    HANDLE                      hOverlay;         // in: Driver overlay handle
    HANDLE                      hResource;        // in: Resource associated with the overlay
    D3DDDI_OVERLAYCOLORCONTROLS ColorControls;    // in: Current color controls
} D3DDDIARG_SETOVERLAYCOLORCONTROLS;

typedef struct _D3DDDIARG_DESTROYOVERLAY
{
    HANDLE             hOverlay;            // in: Driver overlay handle
} D3DDDIARG_DESTROYOVERLAY;

typedef struct _D3DDDIARG_QUERYRESOURCERESIDENCY
{
    CONST HANDLE*   pHandleList;            // in: Driver resource handles
    UINT            NumResources;           // in: Number of resource handles
} D3DDDIARG_QUERYRESOURCERESIDENCY;

typedef struct _D3DDDIARG_GETCAPTUREALLOCATIONHANDLE
{
    HANDLE              hResource;          // in:  Driver resource handle
    D3DKMT_HANDLE       hAllocation;        // out: Kernel mode allocation handle
} D3DDDIARG_GETCAPTUREALLOCATIONHANDLE;

typedef struct _D3DDDIARG_CAPTURETOSYSMEM
{
    HANDLE              hSrcResource;        // in: Capture buffer resource handle
    RECT                SrcRect;             // in: Source rect
    HANDLE              hDstResource;        // in: Sysmem resource handle
    UINT                DstSubResourceIndex; // in: Sysmem resource index
    RECT                DstRect;             // in: Destination rect
} D3DDDIARG_CAPTURETOSYSMEM;

typedef enum _D3DDDICAPS_TYPE
{
    D3DDDICAPS_DDRAW                                    = 1,
    D3DDDICAPS_DDRAW_MODE_SPECIFIC                      = 2,
    D3DDDICAPS_GETFORMATCOUNT                           = 3,
    D3DDDICAPS_GETFORMATDATA                            = 4,
    D3DDDICAPS_GETMULTISAMPLEQUALITYLEVELS              = 5,
    D3DDDICAPS_GETD3DQUERYCOUNT                         = 6,
    D3DDDICAPS_GETD3DQUERYDATA                          = 7,
    D3DDDICAPS_GETD3D3CAPS                              = 8,
    D3DDDICAPS_GETD3D5CAPS                              = 9,
    D3DDDICAPS_GETD3D6CAPS                              =10,
    D3DDDICAPS_GETD3D7CAPS                              =11,
    D3DDDICAPS_GETD3D8CAPS                              =12,
    D3DDDICAPS_GETD3D9CAPS                              =13,
    D3DDDICAPS_GETDECODEGUIDCOUNT                       =14,
    D3DDDICAPS_GETDECODEGUIDS                           =15,
    D3DDDICAPS_GETDECODERTFORMATCOUNT                   =16,
    D3DDDICAPS_GETDECODERTFORMATS                       =17,
    D3DDDICAPS_GETDECODECOMPRESSEDBUFFERINFOCOUNT       =18,
    D3DDDICAPS_GETDECODECOMPRESSEDBUFFERINFO            =19,
    D3DDDICAPS_GETDECODECONFIGURATIONCOUNT              =20,
    D3DDDICAPS_GETDECODECONFIGURATIONS                  =21,
    D3DDDICAPS_GETVIDEOPROCESSORDEVICEGUIDCOUNT         =22,
    D3DDDICAPS_GETVIDEOPROCESSORDEVICEGUIDS             =23,
    D3DDDICAPS_GETVIDEOPROCESSORRTFORMATCOUNT           =24,
    D3DDDICAPS_GETVIDEOPROCESSORRTFORMATS               =25,
    D3DDDICAPS_GETVIDEOPROCESSORRTSUBSTREAMFORMATCOUNT  =26,
    D3DDDICAPS_GETVIDEOPROCESSORRTSUBSTREAMFORMATS      =27,
    D3DDDICAPS_GETVIDEOPROCESSORCAPS                    =28,
    D3DDDICAPS_GETPROCAMPRANGE                          =29,
    D3DDDICAPS_FILTERPROPERTYRANGE                      =30,
    D3DDDICAPS_GETEXTENSIONGUIDCOUNT                    =31,
    D3DDDICAPS_GETEXTENSIONGUIDS                        =32,
    D3DDDICAPS_GETEXTENSIONCAPS                         =33,
    D3DDDICAPS_GETGAMMARAMPCAPS                         =34
} D3DDDICAPS_TYPE;

typedef struct _D3DDDIARG_GETCAPS
{
    D3DDDICAPS_TYPE     Type;
    VOID*               pInfo;
    VOID*               pData;
    UINT                DataSize;
} D3DDDIARG_GETCAPS;

//D3DDDICAPS_DDRAW

    typedef struct _DDRAW_CAPS
    {
        UINT   Caps;
        UINT   Caps2;
        UINT   CKeyCaps;
        UINT   FxCaps;
        UINT   MaxVideoPorts;
    } DDRAW_CAPS;

    // Caps
    #define DDRAW_CAPS_ZBLTS             0x00000001
    #define DDRAW_CAPS_COLORKEY          0x00000002
    #define DDRAW_CAPS_BLTDEPTHFILL      0x00000004

    // Caps2
    #define DDRAW_CAPS2_CANDROPZ16BIT    0x00000002
    #define DDRAW_CAPS2_FLIPINTERVAL     0x00000004
    #define DDRAW_CAPS2_FLIPNOVSYNC      0x00000008
    #define DDRAW_CAPS2_DYNAMICTEXTURES  0x00000010

    // CKeyCaps
    #define DDRAW_CKEYCAPS_SRCBLT        0x00000001
    #define DDRAW_CKEYCAPS_DESTBLT       0x00000002

    // FxCaps
    #define DDRAW_FXCAPS_BLTMIRRORLEFTRIGHT  0x00000001
    #define DDRAW_FXCAPS_BLTMIRRORUPDOWN     0x00000002

//D3DDDICAPS_DDRAW_MODE_SPECIFIC

    typedef struct _DDRAW_MODE_SPECIFIC_CAPS
    {
        UINT    Head;
        UINT    Caps;
        UINT    CKeyCaps;
        UINT    FxCaps;
        UINT    MaxVisibleOverlays;
        UINT    MinOverlayStretch;
        UINT    MaxOverlayStretch;
    } DDRAW_MODE_SPECIFIC_CAPS;

    // Caps
    #define MODE_CAPS_OVERLAY                     0x00000001
    #define MODE_CAPS_OVERLAYSTRETCH              0x00000002
    #define MODE_CAPS_CANBOBINTERLEAVED           0x00000004
    #define MODE_CAPS_CANBOBNONINTERLEAVED        0x00000008
    #define MODE_CAPS_CANFLIPODDEVEN              0x00000010
    #define MODE_CAPS_READSCANLINE                0x00000020
    #define MODE_CAPS_COLORCONTROLOVERLAY         0x00000040

    // CKeyCaps
    #define MODE_CKEYCAPS_DESTOVERLAY             0x00000001
    #define MODE_CKEYCAPS_DESTOVERLAYYUV          0x00000002
    #define MODE_CKEYCAPS_SRCOVERLAY              0x00000004
    #define MODE_CKEYCAPS_SRCOVERLAYCLRSPACE      0x00000008
    #define MODE_CKEYCAPS_SRCOVERLAYCLRSPACEYUV   0x00000010
    #define MODE_CKEYCAPS_SRCOVERLAYYUV           0x00000020

    // FxCaps
    #define MODE_FXCAPS_OVERLAYSHRINKX            0x00000001
    #define MODE_FXCAPS_OVERLAYSHRINKY            0x00000002
    #define MODE_FXCAPS_OVERLAYSTRETCHX           0x00000004
    #define MODE_FXCAPS_OVERLAYSTRETCHY           0x00000008
    #define MODE_FXCAPS_OVERLAYMIRRORLEFTRIGHT    0x00000010
    #define MODE_FXCAPS_OVERLAYMIRRORUPDOWN       0x00000020
    #define MODE_FXCAPS_OVERLAYDEINTERLACE        0x00000040

//D3DDDICAPS_GETFORMATCOUNT

//D3DDDICAPS_GETFORMATDATA

    typedef struct _FORMATOP
    {
        D3DDDIFORMAT  Format;
        UINT          Operations;
        UINT          FlipMsTypes;
        UINT          BltMsTypes;
        UINT          PrivateFormatBitCount;
    } FORMATOP;

    #define FORMATOP_TEXTURE                    0x00000001L
    #define FORMATOP_VOLUMETEXTURE              0x00000002L
    #define FORMATOP_CUBETEXTURE                0x00000004L
    #define FORMATOP_OFFSCREEN_RENDERTARGET     0x00000008L
    #define FORMATOP_SAME_FORMAT_RENDERTARGET   0x00000010L
    #define FORMATOP_ZSTENCIL                   0x00000040L
    #define FORMATOP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L
    #define FORMATOP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET 0x00000100L
    #define FORMATOP_DISPLAYMODE                0x00000400L
    #define FORMATOP_3DACCELERATION             0x00000800L
    #define FORMATOP_PIXELSIZE                  0x00001000L
    #define FORMATOP_CONVERT_TO_ARGB            0x00002000L
    #define FORMATOP_OFFSCREENPLAIN             0x00004000L
    #define FORMATOP_SRGBREAD                   0x00008000L
    #define FORMATOP_BUMPMAP                    0x00010000L
    #define FORMATOP_DMAP                       0x00020000L
    #define FORMATOP_NOFILTER                   0x00040000L
    #define FORMATOP_MEMBEROFGROUP_ARGB         0x00080000L
    #define FORMATOP_SRGBWRITE                  0x00100000L
    #define FORMATOP_NOALPHABLEND               0x00200000L
    #define FORMATOP_AUTOGENMIPMAP              0x00400000L
    #define FORMATOP_VERTEXTEXTURE              0x00800000L
    #define FORMATOP_NOTEXCOORDWRAPNORMIP       0x01000000L
    #define FORMATOP_PLANAR                     0x02000000L
    #define FORMATOP_OVERLAY                    0x04000000L

//D3DDDICAPS_GETMULTISAMPLEQUALITYLEVELS

    typedef struct _DDIMULTISAMPLEQUALITYLEVELSDATA
    {
        D3DDDIFORMAT            Format;
        BOOL                    Flip;
        D3DDDIMULTISAMPLE_TYPE  MsType;
        UINT                    QualityLevels;
    } DDIMULTISAMPLEQUALITYLEVELSDATA;

//D3DDDICAPS_GETD3DQUERYCOUNT
//D3DDDICAPS_GETD3DQUERYDATA
//D3DDDICAPS_GETD3D3CAPS
//D3DDDICAPS_GETD3D5CAPS
//D3DDDICAPS_GETD3D6CAPS
//D3DDDICAPS_GETD3D7CAPS
//D3DDDICAPS_GETD3D8CAPS
//D3DDDICAPS_GETD3D9CAPS

//D3DDDICAPS_GETDECODEGUIDCOUNT
//D3DDDICAPS_GETDECODEGUIDS

    DEFINE_GUID(DXVADDI_ModeMPEG2_MoComp, 0xe6a9f44b, 0x61b0, 0x4563,0x9e,0xa4,0x63,0xd2,0xa3,0xc6,0xfe,0x66);
    DEFINE_GUID(DXVADDI_ModeMPEG2_IDCT,   0xbf22ad00, 0x03ea, 0x4690,0x80,0x77,0x47,0x33,0x46,0x20,0x9b,0x7e);
    DEFINE_GUID(DXVADDI_ModeMPEG2_VLD,    0xee27417f, 0x5e28, 0x4e65,0xbe,0xea,0x1d,0x26,0xb5,0x08,0xad,0xc9);

    DEFINE_GUID(DXVADDI_ModeH264_A,  0x1b81be64, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeH264_B,  0x1b81be65, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeH264_C,  0x1b81be66, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeH264_D,  0x1b81be67, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeH264_E,  0x1b81be68, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeH264_F,  0x1b81be69, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

    DEFINE_GUID(DXVADDI_ModeWMV8_A,  0x1b81be80, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeWMV8_B,  0x1b81be81, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

    DEFINE_GUID(DXVADDI_ModeWMV9_A,  0x1b81be90, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeWMV9_B,  0x1b81be91, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeWMV9_C,  0x1b81be94, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

    DEFINE_GUID(DXVADDI_ModeVC1_A,   0x1b81beA0, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeVC1_B,   0x1b81beA1, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeVC1_C,   0x1b81beA2, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
    DEFINE_GUID(DXVADDI_ModeVC1_D,   0x1b81beA3, 0xa0c7, 0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

    #define DXVADDI_ModeMPEG2_MOCOMP        DXVADDI_ModeMPEG2_MoComp

    #define DXVADDI_ModeWMV8_PostProc       DXVADDI_ModeWMV8_A
    #define DXVADDI_ModeWMV8_MoComp         DXVADDI_ModeWMV8_B

    #define DXVADDI_ModeWMV9_PostProc       DXVADDI_ModeWMV9_A
    #define DXVADDI_ModeWMV9_MoComp         DXVADDI_ModeWMV9_B
    #define DXVADDI_ModeWMV9_IDCT           DXVADDI_ModeWMV9_C

    #define DXVADDI_ModeVC1_PostProc        DXVADDI_ModeVC1_A
    #define DXVADDI_ModeVC1_MoComp          DXVADDI_ModeVC1_B
    #define DXVADDI_ModeVC1_IDCT            DXVADDI_ModeVC1_C
    #define DXVADDI_ModeVC1_VLD             DXVADDI_ModeVC1_D

    #define DXVADDI_ModeH264_MoComp_NoFGT   DXVADDI_ModeH264_A
    #define DXVADDI_ModeH264_MoComp_FGT     DXVADDI_ModeH264_B
    #define DXVADDI_ModeH264_IDCT_NoFGT     DXVADDI_ModeH264_C
    #define DXVADDI_ModeH264_IDCT_FGT       DXVADDI_ModeH264_D
    #define DXVADDI_ModeH264_VLD_NoFGT      DXVADDI_ModeH264_E
    #define DXVADDI_ModeH264_VLD_FGT        DXVADDI_ModeH264_F

//D3DDDICAPS_GETDECODERTFORMATCOUNT
//D3DDDICAPS_GETDECODERTFORMATS
//D3DDDICAPS_GETDECODECOMPRESSEDBUFFERINFOCOUNT
//D3DDDICAPS_GETDECODECOMPRESSEDBUFFERINFO

    typedef struct _DXVADDI_DECODEINPUT
    {
        CONST GUID*        pGuid;
        DXVADDI_VIDEODESC  VideoDesc;
    } DXVADDI_DECODEINPUT;

    typedef struct _DXVADDI_DECODEBUFFERINFO
    {
        D3DDDIFORMAT       CompressedBufferType;
        UINT               CreationWidth;
        UINT               CreationHeight;
        D3DDDI_POOL        CreationPool;
    } DXVADDI_DECODEBUFFERINFO;

//D3DDDICAPS_GETDECODECONFIGURATIONCOUNT
//D3DDDICAPS_GETDECODECONFIGURATIONS

    DEFINE_GUID(DXVADDI_NoEncrypt,  0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

//D3DDDICAPS_GETVIDEOPROCESSORDEVICEGUIDCOUNT
//D3DDDICAPS_GETVIDEOPROCESSORDEVICEGUIDS

    DEFINE_GUID(DXVADDI_VideoProcProgressiveDevice, 0x5a54a0c9,0xc7ec,0x4bd9,0x8e,0xde,0xf3,0xc7,0x5d,0xc4,0x39,0x3b);
    DEFINE_GUID(DXVADDI_VideoProcBobDevice,         0x335aa36e,0x7884,0x43a4,0x9c,0x91,0x7f,0x87,0xfa,0xf3,0xe3,0x7e);

//D3DDDICAPS_GETVIDEOPROCESSORRTFORMATCOUNT
//D3DDDICAPS_GETVIDEOPROCESSORRTFORMATS
//D3DDDICAPS_GETVIDEOPROCESSORRTSUBSTREAMFORMATCOUNT
//D3DDDICAPS_GETVIDEOPROCESSORRTSUBSTREAMFORMATS
//D3DDDICAPS_GETVIDEOPROCESSORCAPS

    typedef struct _DXVADDI_VIDEOPROCESSORCAPS
    {
        D3DDDI_POOL              InputPool;
        UINT                     NumForwardRefSamples;
        UINT                     NumBackwardRefSamples;
        D3DDDIFORMAT             OutputFormat;
        UINT                     DeinterlaceTechnology;
        UINT                     ProcAmpControlCaps;
        UINT                     VideoProcessorOperations;
        UINT                     NoiseFilterTechnology;
        UINT                     DetailFilterTechnology;
    } DXVADDI_VIDEOPROCESSORCAPS;

    #define DXVADDI_DEINTERLACETECH_UNKNOWN                         0x0000
    #define DXVADDI_DEINTERLACETECH_BOBLINEREPLICATE                0x0001
    #define DXVADDI_DEINTERLACETECH_BOBVERTICALSTRETCH              0x0002
    #define DXVADDI_DEINTERLACETECH_BOBVERTICALSTRETCH4TAP          0x0004
    #define DXVADDI_DEINTERLACETECH_MEDIANFILTERING                 0x0008
    #define DXVADDI_DEINTERLACETECH_EDGEFILTERING                   0x0010
    #define DXVADDI_DEINTERLACETECH_FIELDADAPTIVE                   0x0020
    #define DXVADDI_DEINTERLACETECH_PIXELADAPTIVE                   0x0040
    #define DXVADDI_DEINTERLACETECH_MOTIONVECTORSTEERED             0x0080
    #define DXVADDI_DEINTERLACETECH_INVERSETELECINE                 0x0100

    #define DXVADDI_PROCAMP_NONE                                    0x0000
    #define DXVADDI_PROCAMP_BRIGHTNESS                              0x0001
    #define DXVADDI_PROCAMP_CONTRAST                                0x0002
    #define DXVADDI_PROCAMP_HUE                                     0x0004
    #define DXVADDI_PROCAMP_SATURATION                              0x0008

    #define DXVADDI_VIDEOPROCESS_NONE                               0x0000
    #define DXVADDI_VIDEOPROCESS_YUV2RGB                            0x0001
    #define DXVADDI_VIDEOPROCESS_STRETCHX                           0x0002
    #define DXVADDI_VIDEOPROCESS_STRETCHY                           0x0004
    #define DXVADDI_VIDEOPROCESS_ALPHABLEND                         0x0008
    #define DXVADDI_VIDEOPROCESS_SUBRECTS                           0x0010
    #define DXVADDI_VIDEOPROCESS_SUBSTREAMS                         0x0020
    #define DXVADDI_VIDEOPROCESS_SUBSTREAMSEXTENDED                 0x0040
    #define DXVADDI_VIDEOPROCESS_YUV2RGBEXTENDED                    0x0080
    #define DXVADDI_VIDEOPROCESS_ALPHABLENDEXTENDED                 0x0100
    #define DXVADDI_VIDEOPROCESS_CONSTRICTION                       0x0200
    #define DXVADDI_VIDEOPROCESS_NOISEFILTER                        0x0400
    #define DXVADDI_VIDEOPROCESS_DETAILFILTER                       0x0800
    #define DXVADDI_VIDEOPROCESS_PLANARALPHA                        0x1000
    #define DXVADDI_VIDEOPROCESS_LINEARSCALING                      0x2000
    #define DXVADDI_VIDEOPROCESS_GAMMACOMPENSATED                   0x4000
    #define DXVADDI_VIDEOPROCESS_MAINTAINSORIGINALFIELDDATA         0x8000

    #define DXVADDI_NOISEFILTERTECH_UNSUPPORTED                     0x0000
    #define DXVADDI_NOISEFILTERTECH_UNKNOWN                         0x0001
    #define DXVADDI_NOISEFILTERTECH_MEDIAN                          0x0002
    #define DXVADDI_NOISEFILTERTECH_TEMPORAL                        0x0004
    #define DXVADDI_NOISEFILTERTECH_BLOCKNOISE                      0x0008
    #define DXVADDI_NOISEFILTERTECH_MOSQUITONOISE                   0x0010

    #define DXVADDI_DETAILFILTERTECH_UNSUPPORTED                    0x0000
    #define DXVADDI_DETAILFILTERTECH_UNKNOWN                        0x0001
    #define DXVADDI_DETAILFILTERTECH_EDGE                           0x0002
    #define DXVADDI_DETAILFILTERTECH_SHARPENING                     0x0004

    typedef struct _DXVADDI_VIDEOPROCESSORINPUT
    {
        CONST GUID*              pVideoProcGuid;
        DXVADDI_VIDEODESC        VideoDesc;
        D3DDDIFORMAT             RenderTargetFormat;
    } DXVADDI_VIDEOPROCESSORINPUT;

//D3DDDICAPS_GETPROCAMPRANGE

    typedef struct _DXVADDI_QUERYPROCAMPINPUT
    {
        CONST GUID*              pVideoProcGuid;
        DXVADDI_VIDEODESC        VideoDesc;
        D3DDDIFORMAT             RenderTargetFormat;
        UINT                     ProcAmpCap;
    } DXVADDI_QUERYPROCAMPINPUT;

    typedef struct _DXVADDI_VALUERANGE
    {
        DXVADDI_FIXED32          MinValue;
        DXVADDI_FIXED32          MaxValue;
        DXVADDI_FIXED32          DefaultValue;
        DXVADDI_FIXED32          StepSize;
    } DXVADDI_VALUERANGE;

//D3DDDICAPS_FILTERPROPERTYRANGE

    #define DXVADDI_NOISEFILTER_LUMALEVEL                           1
    #define DXVADDI_NOISEFILTER_LUMATHREASHOLD                      2
    #define DXVADDI_NOISEFILTER_LUMARADIUS                          3
    #define DXVADDI_NOISEFILTER_CHROMALEVEL                         4
    #define DXVADDI_NOISEFILTER_CHROMATHREASHOLD                    5
    #define DXVADDI_NOISEFILTER_CHROMARADIUS                        6
    #define DXVADDI_DETAILFILTER_LUMALEVEL                          7
    #define DXVADDI_DETAILFILTER_LUMATHREASHOLD                     8
    #define DXVADDI_DETAILFILTER_LUMARADIUS                         9
    #define DXVADDI_DETAILFILTER_CHROMALEVEL                        10
    #define DXVADDI_DETAILFILTER_CHROMATHREASHOLD                   11
    #define DXVADDI_DETAILFILTER_CHROMARADIUS                       12

    typedef struct _DXVADDI_QUERYFILTERPROPERTYRANGEINPUT
    {
        CONST GUID*              pVideoProcGuid;
        DXVADDI_VIDEODESC        VideoDesc;
        D3DDDIFORMAT             RenderTargetFormat;
        UINT                     FilterSetting;
    } DXVADDI_QUERYFILTERPROPERTYRANGEINPUT;

//D3DDDICAPS_GETEXTENSIONGUIDCOUNT
//D3DDDICAPS_GETEXTENSIONGUIDS
//D3DDDICAPS_GETEXTENSIONCAPS

    #define DXVADDI_EXTENSION_CATEGORY_DECODER                      0x0001
    #define DXVADDI_EXTENSION_CATEGORY_ENCODER                      0x0002
    #define DXVADDI_EXTENSION_CATEGORY_PROCESSOR                    0x0004
    #define DXVADDI_EXTENSION_CATEGORY_ALL                          0x0007

    #define DXVADDI_EXTENSION_CAPTYPE_MIN                           300
    #define DXVADDI_EXTENSION_CAPTYPE_MAX                           400

    typedef struct _DXVADDI_QUERYEXTENSIONCAPSINPUT
    {
        CONST GUID*              pGuid;
        UINT                     CapType;
        DXVADDI_PRIVATEDATA*     pPrivate;
    } DXVADDI_QUERYEXTENSIONCAPSINPUT;

//D3DDDICAPS_GETGAMMARAMPCAPS

    typedef struct _DDIGAMMACAPS
    {
        UINT                     GammaCaps;
    } DDIGAMMACAPS;

    // Caps
    #define GAMMA_CAP_RGB256x3x16           0x00000001    // Standard GDI gamma ramps (256 entries, 3 channels per entry, 16 bits per channel)


//
// GetInfo IDs and structures
//
#define D3DDDIDEVINFOID_VCACHE  4

typedef struct _D3DDDIDEVINFO_VCACHE
{
    UINT    Pattern;            // out: bit pattern, return value must be FOUR_CC('C', 'A', 'C', 'H')
    UINT    OptMethod;          // out: optimization method 0 means longest strips, 1 means vertex cache based
    UINT    CacheSize;          // out: cache size to optimize for (only required if type is 1)
    UINT    MagicNumber;        // out: used to determine when to restart strips (only required if type is 1)
} D3DDDIDEVINFO_VCACHE;


typedef HRESULT (APIENTRY *PFND3DDDI_SETRENDERSTATE)(HANDLE hDevice, CONST D3DDDIARG_RENDERSTATE*);
typedef HRESULT (APIENTRY *PFND3DDDI_UPDATEWINFO)(HANDLE hDevice, CONST D3DDDIARG_WINFO*);
typedef HRESULT (APIENTRY *PFND3DDDI_VALIDATEDEVICE)(HANDLE hDevice, D3DDDIARG_VALIDATETEXTURESTAGESTATE*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETTEXTURESTAGESTATE)(HANDLE hDevice, CONST D3DDDIARG_TEXTURESTAGESTATE*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETTEXTURE)(HANDLE hDevice, UINT, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_SETPIXELSHADER)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_SETPIXELSHADERCONST)(HANDLE hDevice, CONST D3DDDIARG_SETPIXELSHADERCONST*, CONST FLOAT*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETSTREAMSOURCEUM)(HANDLE hDevice, CONST D3DDDIARG_SETSTREAMSOURCEUM*, CONST VOID*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETINDICES)(HANDLE hDevice, CONST D3DDDIARG_SETINDICES*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETINDICESUM)(HANDLE hDevice, UINT, CONST VOID*);
typedef HRESULT (APIENTRY *PFND3DDDI_DRAWPRIMITIVE)(HANDLE hDevice, CONST D3DDDIARG_DRAWPRIMITIVE*, CONST UINT*);
typedef HRESULT (APIENTRY *PFND3DDDI_DRAWINDEXEDPRIMITIVE)(HANDLE hDevice, CONST D3DDDIARG_DRAWINDEXEDPRIMITIVE*);
typedef HRESULT (APIENTRY *PFND3DDDI_DRAWRECTPATCH)(HANDLE hDevice, CONST D3DDDIARG_DRAWRECTPATCH*, CONST D3DDDIRECTPATCH_INFO*, CONST FLOAT*);
typedef HRESULT (APIENTRY *PFND3DDDI_DRAWTRIPATCH)(HANDLE hDevice, CONST D3DDDIARG_DRAWTRIPATCH*, CONST D3DDDITRIPATCH_INFO*, CONST FLOAT*);
typedef HRESULT (APIENTRY *PFND3DDDI_DRAWPRIMITIVE2)(HANDLE hDevice, CONST D3DDDIARG_DRAWPRIMITIVE2*);
typedef HRESULT (APIENTRY *PFND3DDDI_DRAWINDEXEDPRIMITIVE2)(HANDLE hDevice, CONST D3DDDIARG_DRAWINDEXEDPRIMITIVE2*, UINT, CONST VOID*, CONST UINT*);
typedef HRESULT (APIENTRY *PFND3DDDI_VOLBLT)(HANDLE hDevice, CONST D3DDDIARG_VOLUMEBLT*);
typedef HRESULT (APIENTRY *PFND3DDDI_BUFBLT)(HANDLE hDevice, CONST D3DDDIARG_BUFFERBLT*);
typedef HRESULT (APIENTRY *PFND3DDDI_TEXBLT)(HANDLE hDevice, CONST D3DDDIARG_TEXBLT*);
typedef HRESULT (APIENTRY *PFND3DDDI_STATESET)(HANDLE hDevice, D3DDDIARG_STATESET*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETPRIORITY)(HANDLE hDevice, CONST D3DDDIARG_SETPRIORITY*);
typedef HRESULT (APIENTRY *PFND3DDDI_CLEAR)(HANDLE hDevice, CONST D3DDDIARG_CLEAR*, UINT, CONST RECT*);
typedef HRESULT (APIENTRY *PFND3DDDI_UPDATEPALETTE)(HANDLE hDevice, CONST D3DDDIARG_UPDATEPALETTE*, CONST PALETTEENTRY*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETPALETTE)(HANDLE hDevice, CONST D3DDDIARG_SETPALETTE*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETVERTEXSHADERCONST)(HANDLE hDevice, CONST D3DDDIARG_SETVERTEXSHADERCONST*, CONST VOID*);
typedef HRESULT (APIENTRY *PFND3DDDI_MULTIPLYTRANSFORM)(HANDLE hDevice, CONST D3DDDIARG_MULTIPLYTRANSFORM*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETTRANSFORM)(HANDLE hDevice, CONST D3DDDIARG_SETTRANSFORM*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETVIEWPORT)(HANDLE hDevice, CONST D3DDDIARG_VIEWPORTINFO*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETZRANGE)(HANDLE hDevice, CONST D3DDDIARG_ZRANGE*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETMATERIAL)(HANDLE hDevice, CONST D3DDDIARG_SETMATERIAL*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETLIGHT)(HANDLE hDevice, CONST D3DDDIARG_SETLIGHT*, CONST D3DDDI_LIGHT*);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATELIGHT)(HANDLE hDevice, CONST D3DDDIARG_CREATELIGHT*);
typedef HRESULT (APIENTRY *PFND3DDDI_DESTROYLIGHT)(HANDLE hDevice, CONST D3DDDIARG_DESTROYLIGHT*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETCLIPPLANE)(HANDLE hDevice, CONST D3DDDIARG_SETCLIPPLANE*);
typedef HRESULT (APIENTRY *PFND3DDDI_GETINFO)(HANDLE hDevice, UINT, VOID*, UINT);
typedef HRESULT (APIENTRY *PFND3DDDI_LOCK)(HANDLE hDevice, D3DDDIARG_LOCK*);
typedef HRESULT (APIENTRY *PFND3DDDI_UNLOCK)(HANDLE hDevice, CONST D3DDDIARG_UNLOCK*);
typedef HRESULT (APIENTRY *PFND3DDDI_LOCKASYNC)(HANDLE hDevice, D3DDDIARG_LOCKASYNC*);
typedef HRESULT (APIENTRY *PFND3DDDI_UNLOCKASYNC)(HANDLE hDevice, CONST D3DDDIARG_UNLOCKASYNC*);
typedef HRESULT (APIENTRY *PFND3DDDI_RENAME)(HANDLE hDevice, CONST D3DDDIARG_RENAME*);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATERESOURCE)(HANDLE hDevice, D3DDDIARG_CREATERESOURCE*);
typedef HRESULT (APIENTRY *PFND3DDDI_DESTROYRESOURCE)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_SETDISPLAYMODE)(HANDLE hDevice, CONST D3DDDIARG_SETDISPLAYMODE*);
typedef HRESULT (APIENTRY *PFND3DDDI_PRESENT)(HANDLE hDevice, CONST D3DDDIARG_PRESENT*);
typedef HRESULT (APIENTRY *PFND3DDDI_FLUSH)(HANDLE hDevice);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEVERTEXSHADERDECL)(HANDLE hDevice, D3DDDIARG_CREATEVERTEXSHADERDECL*, CONST D3DDDIVERTEXELEMENT*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETVERTEXSHADERDECL)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_DELETEVERTEXSHADERDECL)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEVERTEXSHADERFUNC)(HANDLE hDevice, D3DDDIARG_CREATEVERTEXSHADERFUNC*, CONST UINT*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETVERTEXSHADERFUNC)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_DELETEVERTEXSHADERFUNC)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_SETVERTEXSHADERCONSTI)(HANDLE hDevice, CONST D3DDDIARG_SETVERTEXSHADERCONSTI*, CONST INT*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETVERTEXSHADERCONSTB)(HANDLE hDevice, CONST D3DDDIARG_SETVERTEXSHADERCONSTB*, CONST BOOL*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETSCISSORRECT)(HANDLE hDevice, CONST RECT*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETSTREAMSOURCE)(HANDLE hDevice, CONST D3DDDIARG_SETSTREAMSOURCE*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETSTREAMSOURCEFREQ)(HANDLE hDevice, CONST D3DDDIARG_SETSTREAMSOURCEFREQ*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETCONVOLUTIONKERNELMONO)(HANDLE hDevice, CONST D3DDDIARG_SETCONVOLUTIONKERNELMONO*);
typedef HRESULT (APIENTRY *PFND3DDDI_COMPOSERECTS)(HANDLE hDevice, CONST D3DDDIARG_COMPOSERECTS*);
typedef HRESULT (APIENTRY *PFND3DDDI_BLT)(HANDLE hDevice, CONST D3DDDIARG_BLT*);
typedef HRESULT (APIENTRY *PFND3DDDI_COLORFILL)(HANDLE hDevice, CONST D3DDDIARG_COLORFILL*);
typedef HRESULT (APIENTRY *PFND3DDDI_DEPTHFILL)(HANDLE hDevice, CONST D3DDDIARG_DEPTHFILL*);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEQUERY)(HANDLE hDevice, D3DDDIARG_CREATEQUERY*);
typedef HRESULT (APIENTRY *PFND3DDDI_DESTROYQUERY)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_ISSUEQUERY)(HANDLE hDevice, CONST D3DDDIARG_ISSUEQUERY*);
typedef HRESULT (APIENTRY *PFND3DDDI_GETQUERYDATA)(HANDLE hDevice, CONST D3DDDIARG_GETQUERYDATA*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETRENDERTARGET)(HANDLE hDevice, CONST D3DDDIARG_SETRENDERTARGET*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETDEPTHSTENCIL)(HANDLE hDevice, CONST D3DDDIARG_SETDEPTHSTENCIL*);
typedef HRESULT (APIENTRY *PFND3DDDI_GENERATEMIPSUBLEVELS)(HANDLE hDevice, CONST D3DDDIARG_GENERATEMIPSUBLEVELS*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETPIXELSHADERCONSTI)(HANDLE hDevice, CONST D3DDDIARG_SETPIXELSHADERCONSTI*, CONST INT*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETPIXELSHADERCONSTB)(HANDLE hDevice, CONST D3DDDIARG_SETPIXELSHADERCONSTB*, CONST BOOL*);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEPIXELSHADER)(HANDLE hDevice, D3DDDIARG_CREATEPIXELSHADER*, CONST UINT*);
typedef HRESULT (APIENTRY *PFND3DDDI_DELETEPIXELSHADER)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEDECODEDEVICE)(HANDLE hDevice, D3DDDIARG_CREATEDECODEDEVICE*);
typedef HRESULT (APIENTRY *PFND3DDDI_DESTROYDECODEDEVICE)(HANDLE hDevice, HANDLE);
typedef HRESULT (APIENTRY *PFND3DDDI_SETDECODERENDERTARGET) (HANDLE hDevice, CONST D3DDDIARG_SETDECODERENDERTARGET*);
typedef HRESULT (APIENTRY *PFND3DDDI_DECODEBEGINFRAME) (HANDLE hDevice, D3DDDIARG_DECODEBEGINFRAME*);
typedef HRESULT (APIENTRY *PFND3DDDI_DECODEENDFRAME) (HANDLE hDevice, D3DDDIARG_DECODEENDFRAME*);
typedef HRESULT (APIENTRY *PFND3DDDI_DECODEEXECUTE)(HANDLE hDevice, CONST D3DDDIARG_DECODEEXECUTE*);
typedef HRESULT (APIENTRY *PFND3DDDI_DECODEEXTENSIONEXECUTE)(HANDLE hDevice, CONST D3DDDIARG_DECODEEXTENSIONEXECUTE*);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEVIDEOPROCESSDEVICE) (HANDLE hDevice, D3DDDIARG_CREATEVIDEOPROCESSDEVICE*);
typedef HRESULT (APIENTRY *PFND3DDDI_DESTROYVIDEOPROCESSDEVICE) (HANDLE hDevice, HANDLE hVideoProcessor);
typedef HRESULT (APIENTRY *PFND3DDDI_VIDEOPROCESSBEGINFRAME) (HANDLE hDevice, HANDLE hVideoProcess);
typedef HRESULT (APIENTRY *PFND3DDDI_VIDEOPROCESSENDFRAME) (HANDLE hDevice, D3DDDIARG_VIDEOPROCESSENDFRAME*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETVIDEOPROCESSRENDERTARGET) (HANDLE hDevice, CONST D3DDDIARG_SETVIDEOPROCESSRENDERTARGET*);
typedef HRESULT (APIENTRY *PFND3DDDI_VIDEOPROCESSBLT) (HANDLE hDevice, CONST D3DDDIARG_VIDEOPROCESSBLT*);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEEXTENSIONDEVICE) (HANDLE hDevice, D3DDDIARG_CREATEEXTENSIONDEVICE*);
typedef HRESULT (APIENTRY *PFND3DDDI_DESTROYEXTENSIONDEVICE) (HANDLE hDevice, HANDLE hExtension);
typedef HRESULT (APIENTRY *PFND3DDDI_EXTENSIONEXECUTE) (HANDLE hDevice, CONST D3DDDIARG_EXTENSIONEXECUTE*);
typedef HRESULT (APIENTRY *PFND3DDDI_DESTROYDEVICE)(IN HANDLE hDevice);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEOVERLAY) (HANDLE hDevice, D3DDDIARG_CREATEOVERLAY*);
typedef HRESULT (APIENTRY *PFND3DDDI_UPDATEOVERLAY) (HANDLE hDevice, CONST D3DDDIARG_UPDATEOVERLAY*);
typedef HRESULT (APIENTRY *PFND3DDDI_FLIPOVERLAY) (HANDLE hDevice, CONST D3DDDIARG_FLIPOVERLAY*);
typedef HRESULT (APIENTRY *PFND3DDDI_GETOVERLAYCOLORCONTROLS) (HANDLE hDevice, D3DDDIARG_GETOVERLAYCOLORCONTROLS*);
typedef HRESULT (APIENTRY *PFND3DDDI_SETOVERLAYCOLORCONTROLS) (HANDLE hDevice, CONST D3DDDIARG_SETOVERLAYCOLORCONTROLS*);
typedef HRESULT (APIENTRY *PFND3DDDI_DESTROYOVERLAY) (HANDLE hDevice, CONST D3DDDIARG_DESTROYOVERLAY*);
typedef HRESULT (APIENTRY *PFND3DDDI_QUERYRESOURCERESIDENCY) (HANDLE hDevice, CONST D3DDDIARG_QUERYRESOURCERESIDENCY*);
typedef HRESULT (APIENTRY *PFND3DDDI_OPENRESOURCE) (HANDLE hDevice, D3DDDIARG_OPENRESOURCE*);
typedef HRESULT (APIENTRY *PFND3DDDI_GETCAPTUREALLOCATIONHANDLE)(HANDLE hDevice, D3DDDIARG_GETCAPTUREALLOCATIONHANDLE*);
typedef HRESULT (APIENTRY *PFND3DDDI_CAPTURETOSYSMEM)(HANDLE hDevice, CONST D3DDDIARG_CAPTURETOSYSMEM*);

typedef struct _D3DDDI_DEVICEFUNCS
{
    PFND3DDDI_SETRENDERSTATE                pfnSetRenderState;
    PFND3DDDI_UPDATEWINFO                   pfnUpdateWInfo;
    PFND3DDDI_VALIDATEDEVICE                pfnValidateDevice;
    PFND3DDDI_SETTEXTURESTAGESTATE          pfnSetTextureStageState;
    PFND3DDDI_SETTEXTURE                    pfnSetTexture;
    PFND3DDDI_SETPIXELSHADER                pfnSetPixelShader;
    PFND3DDDI_SETPIXELSHADERCONST           pfnSetPixelShaderConst;
    PFND3DDDI_SETSTREAMSOURCEUM             pfnSetStreamSourceUm;
    PFND3DDDI_SETINDICES                    pfnSetIndices;
    PFND3DDDI_SETINDICESUM                  pfnSetIndicesUm;
    PFND3DDDI_DRAWPRIMITIVE                 pfnDrawPrimitive;
    PFND3DDDI_DRAWINDEXEDPRIMITIVE          pfnDrawIndexedPrimitive;
    PFND3DDDI_DRAWRECTPATCH                 pfnDrawRectPatch;
    PFND3DDDI_DRAWTRIPATCH                  pfnDrawTriPatch;
    PFND3DDDI_DRAWPRIMITIVE2                pfnDrawPrimitive2;
    PFND3DDDI_DRAWINDEXEDPRIMITIVE2         pfnDrawIndexedPrimitive2;
    PFND3DDDI_VOLBLT                        pfnVolBlt;
    PFND3DDDI_BUFBLT                        pfnBufBlt;
    PFND3DDDI_TEXBLT                        pfnTexBlt;
    PFND3DDDI_STATESET                      pfnStateSet;
    PFND3DDDI_SETPRIORITY                   pfnSetPriority;
    PFND3DDDI_CLEAR                         pfnClear;
    PFND3DDDI_UPDATEPALETTE                 pfnUpdatePalette;
    PFND3DDDI_SETPALETTE                    pfnSetPalette;
    PFND3DDDI_SETVERTEXSHADERCONST          pfnSetVertexShaderConst;
    PFND3DDDI_MULTIPLYTRANSFORM             pfnMultiplyTransform;
    PFND3DDDI_SETTRANSFORM                  pfnSetTransform;
    PFND3DDDI_SETVIEWPORT                   pfnSetViewport;
    PFND3DDDI_SETZRANGE                     pfnSetZRange;
    PFND3DDDI_SETMATERIAL                   pfnSetMaterial;
    PFND3DDDI_SETLIGHT                      pfnSetLight;
    PFND3DDDI_CREATELIGHT                   pfnCreateLight;
    PFND3DDDI_DESTROYLIGHT                  pfnDestroyLight;
    PFND3DDDI_SETCLIPPLANE                  pfnSetClipPlane;
    PFND3DDDI_GETINFO                       pfnGetInfo;
    PFND3DDDI_LOCK                          pfnLock;
    PFND3DDDI_UNLOCK                        pfnUnlock;
    PFND3DDDI_CREATERESOURCE                pfnCreateResource;
    PFND3DDDI_DESTROYRESOURCE               pfnDestroyResource;
    PFND3DDDI_SETDISPLAYMODE                pfnSetDisplayMode;
    PFND3DDDI_PRESENT                       pfnPresent;
    PFND3DDDI_FLUSH                         pfnFlush;
    PFND3DDDI_CREATEVERTEXSHADERFUNC        pfnCreateVertexShaderFunc;
    PFND3DDDI_DELETEVERTEXSHADERFUNC        pfnDeleteVertexShaderFunc;
    PFND3DDDI_SETVERTEXSHADERFUNC           pfnSetVertexShaderFunc;
    PFND3DDDI_CREATEVERTEXSHADERDECL        pfnCreateVertexShaderDecl;
    PFND3DDDI_DELETEVERTEXSHADERDECL        pfnDeleteVertexShaderDecl;
    PFND3DDDI_SETVERTEXSHADERDECL           pfnSetVertexShaderDecl;
    PFND3DDDI_SETVERTEXSHADERCONSTI         pfnSetVertexShaderConstI;
    PFND3DDDI_SETVERTEXSHADERCONSTB         pfnSetVertexShaderConstB;
    PFND3DDDI_SETSCISSORRECT                pfnSetScissorRect;
    PFND3DDDI_SETSTREAMSOURCE               pfnSetStreamSource;
    PFND3DDDI_SETSTREAMSOURCEFREQ           pfnSetStreamSourceFreq;
    PFND3DDDI_SETCONVOLUTIONKERNELMONO      pfnSetConvolutionKernelMono;
    PFND3DDDI_COMPOSERECTS                  pfnComposeRects;
    PFND3DDDI_BLT                           pfnBlt;
    PFND3DDDI_COLORFILL                     pfnColorFill;
    PFND3DDDI_DEPTHFILL                     pfnDepthFill;
    PFND3DDDI_CREATEQUERY                   pfnCreateQuery;
    PFND3DDDI_DESTROYQUERY                  pfnDestroyQuery;
    PFND3DDDI_ISSUEQUERY                    pfnIssueQuery;
    PFND3DDDI_GETQUERYDATA                  pfnGetQueryData;
    PFND3DDDI_SETRENDERTARGET               pfnSetRenderTarget;
    PFND3DDDI_SETDEPTHSTENCIL               pfnSetDepthStencil;
    PFND3DDDI_GENERATEMIPSUBLEVELS          pfnGenerateMipSubLevels;
    PFND3DDDI_SETPIXELSHADERCONSTI          pfnSetPixelShaderConstI;
    PFND3DDDI_SETPIXELSHADERCONSTB          pfnSetPixelShaderConstB;
    PFND3DDDI_CREATEPIXELSHADER             pfnCreatePixelShader;
    PFND3DDDI_DELETEPIXELSHADER             pfnDeletePixelShader;
    PFND3DDDI_CREATEDECODEDEVICE            pfnCreateDecodeDevice;
    PFND3DDDI_DESTROYDECODEDEVICE           pfnDestroyDecodeDevice;
    PFND3DDDI_SETDECODERENDERTARGET         pfnSetDecodeRenderTarget;
    PFND3DDDI_DECODEBEGINFRAME              pfnDecodeBeginFrame;
    PFND3DDDI_DECODEENDFRAME                pfnDecodeEndFrame;
    PFND3DDDI_DECODEEXECUTE                 pfnDecodeExecute;
    PFND3DDDI_DECODEEXTENSIONEXECUTE        pfnDecodeExtensionExecute;
    PFND3DDDI_CREATEVIDEOPROCESSDEVICE      pfnCreateVideoProcessDevice;
    PFND3DDDI_DESTROYVIDEOPROCESSDEVICE     pfnDestroyVideoProcessDevice;
    PFND3DDDI_VIDEOPROCESSBEGINFRAME        pfnVideoProcessBeginFrame;
    PFND3DDDI_VIDEOPROCESSENDFRAME          pfnVideoProcessEndFrame;
    PFND3DDDI_SETVIDEOPROCESSRENDERTARGET   pfnSetVideoProcessRenderTarget;
    PFND3DDDI_VIDEOPROCESSBLT               pfnVideoProcessBlt;
    PFND3DDDI_CREATEEXTENSIONDEVICE         pfnCreateExtensionDevice;
    PFND3DDDI_DESTROYEXTENSIONDEVICE        pfnDestroyExtensionDevice;
    PFND3DDDI_EXTENSIONEXECUTE              pfnExtensionExecute;
    PFND3DDDI_CREATEOVERLAY                 pfnCreateOverlay;
    PFND3DDDI_UPDATEOVERLAY                 pfnUpdateOverlay;
    PFND3DDDI_FLIPOVERLAY                   pfnFlipOverlay;
    PFND3DDDI_GETOVERLAYCOLORCONTROLS       pfnGetOverlayColorControls;
    PFND3DDDI_SETOVERLAYCOLORCONTROLS       pfnSetOverlayColorControls;
    PFND3DDDI_DESTROYOVERLAY                pfnDestroyOverlay;
    PFND3DDDI_DESTROYDEVICE                 pfnDestroyDevice;
    PFND3DDDI_QUERYRESOURCERESIDENCY        pfnQueryResourceResidency;
    PFND3DDDI_OPENRESOURCE                  pfnOpenResource;
    PFND3DDDI_GETCAPTUREALLOCATIONHANDLE    pfnGetCaptureAllocationHandle;
    PFND3DDDI_CAPTURETOSYSMEM               pfnCaptureToSysMem;
    PFND3DDDI_LOCKASYNC                     pfnLockAsync;
    PFND3DDDI_UNLOCKASYNC                   pfnUnlockAsync;
    PFND3DDDI_RENAME                        pfnRename;
} D3DDDI_DEVICEFUNCS;

typedef struct _D3DDDICB_QUERYADAPTERINFO
{
    VOID*  pPrivateDriverData;
    UINT   PrivateDriverDataSize;
} D3DDDICB_QUERYADAPTERINFO;

typedef struct _D3DDDICB_GETMULTISAMPLEMETHODLIST
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;  // in: adapter's VidPN source ID
    UINT                            Width;          // in:
    UINT                            Height;         // in:
    D3DDDIFORMAT                    Format;         // in:
    D3DDDI_MULTISAMPLINGMETHOD*     pMethodList;    // out:
    UINT                            MethodCount;    // in/out:
} D3DDDICB_GETMULTISAMPLEMETHODLIST;

typedef struct _D3DDDICB_ALLOCATE
{
    CONST VOID*     pPrivateDriverData;
    UINT            PrivateDriverDataSize;
    HANDLE          hResource;              //in:  D3D runtime resource handle
    D3DKMT_HANDLE   hKMResource;            //out: kernel resource handle
    UINT            NumAllocations;         //in:  number of allocation handles
    D3DDDI_ALLOCATIONINFO* pAllocationInfo; //in:  arrary of allocation structs
} D3DDDICB_ALLOCATE;

typedef struct _D3DDDICB_DEALLOCATE
{
    HANDLE                  hResource;          //in: D3D runtime resource handle
    UINT                    NumAllocations;     //in: number of allocation handles,ignored if hResource != NULL
    CONST D3DKMT_HANDLE*  HandleList; //in: arrary of allocation handles,ignored if hResource != NULL
} D3DDDICB_DEALLOCATE;

typedef struct _D3DDDICB_SETPRIORITY
{
    HANDLE                  hResource;          //in: D3D runtime resource handle
    UINT                    NumAllocations;     //in: number of allocation handles,ignored if hResource != NULL
    CONST D3DKMT_HANDLE*    HandleList;         //in: arrray of allocation handles,ignored if hResource != NULL
    CONST UINT*             pPriorities;            //in: priority to set.
} D3DDDICB_SETPRIORITY;

typedef enum _D3DDDI_RESIDENCYSTATUS
{
    D3DDDI_RESIDENCYSTATUS_RESIDENTINGPUMEMORY=1,
    D3DDDI_RESIDENCYSTATUS_RESIDENTINSHAREDMEMORY=2,
    D3DDDI_RESIDENCYSTATUS_NOTRESIDENT=3,
} D3DDDI_RESIDENCYSTATUS;

typedef struct _D3DDDICB_QUERYRESIDENCY
{
    HANDLE                              hResource;          //in: D3D runtime resource handle
    UINT                                NumAllocations;     //in: number of allocation handles,ignored if hResource != NULL
    CONST D3DKMT_HANDLE*                HandleList;         //in: arrray of allocation handles,ignored if hResource != NULL
    D3DDDI_RESIDENCYSTATUS*             pResidencyStatus;   //out: Residency status of the specified allocation.
} D3DDDICB_QUERYRESIDENCY;

typedef struct _D3DDDICB_LOCK
{
    D3DKMT_HANDLE       hAllocation;        // in: allocation to lock, used by LockCb from driver.
                                            // out: New handle representing the allocation.
    UINT                PrivateDriverData;  // in: from UMD to KMD's AcquireAperture
    UINT                NumPages;
    CONST UINT*         pPages;
    VOID*               pData;              // out: pointer to memory
    D3DDDICB_LOCKFLAGS  Flags;
} D3DDDICB_LOCK;

typedef struct _D3DDDICB_UNLOCK
{
    UINT                    NumAllocations;
    CONST D3DKMT_HANDLE*    phAllocations;
} D3DDDICB_UNLOCK;

typedef struct _D3DDDICB_SETDISPLAYMODE
{
    D3DKMT_HANDLE               hPrimaryAllocation;             // in: The primary allocation for scanning
    UINT                        PrivateDriverFormatAttribute;   // out: Private Format Attribute of the current primary surface if SetDsiplayModeCb returns STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT
} D3DDDICB_SETDISPLAYMODE;

typedef struct _D3DDDICB_SETDISPLAYPRIVATEDRIVERFORMAT
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;                  // in: Identifies which VidPn we are changing the private driver format attribute of
    UINT                            PrivateDriverFormatAttribute;   // in: Private Format Attribute to set for the given VidPn
} D3DDDICB_SETDISPLAYPRIVATEDRIVERFORMAT;

typedef struct _D3DDDICB_PRESENT
{
    D3DKMT_HANDLE               hSrcAllocation;                                 // in: The allocation of which content will be presented
    D3DKMT_HANDLE               hDstAllocation;                                 // in: if non-zero, it's the destination allocation of the present
    HANDLE                      hContext;                                       // in: Context being submitted to.
    UINT                        BroadcastContextCount;                          // in: Specifies the number of context 
                                                                                //     to broadcast this present operation to.
                                                                                //     Only supported for flip operation.
    HANDLE                      BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT]; // in: Specifies the handle of the context to
                                                                                //     broadcast to.    
} D3DDDICB_PRESENT;

typedef struct _D3DDDICB_RENDERFLAGS
{
    union
    {
        struct
        {
            UINT    ResizeCommandBuffer      : 1;     // 0x00000001
            UINT    ResizeAllocationList     : 1;     // 0x00000002
            UINT    ResizePatchLocationList  : 1;     // 0x00000004
            UINT    NullRendering            : 1;     // 0x00000008
            UINT    Reserved                 :28;     // 0xFFFFFFF0
        };
        UINT Value;
    };
} D3DDDICB_RENDERFLAGS;

typedef struct _D3DDDICB_RENDER
{
    UINT                        CommandLength;              // in:  Number of byte to process in the command buffer.
    UINT                        CommandOffset;              // in:  Offset of the command to be process in the
                                                            //      current command buffer.
    UINT                        NumAllocations;             // in: Number of allocation in allocations list.
    UINT                        NumPatchLocations;          // in: Number of patch location in patch allocations list.
    VOID*                       pNewCommandBuffer;          // out: Pointer to the next command buffer to use.
    UINT                        NewCommandBufferSize;       // in: Size requested for the next command buffer.
                                                            // out: Size of the next command buffer to use.
    D3DDDI_ALLOCATIONLIST*      pNewAllocationList;         // out: Pointer to the next allocation list to use.
    UINT                        NewAllocationListSize;      // in: Size requested for the next allocation list.
                                                            // out: Size of the new allocation list.
    D3DDDI_PATCHLOCATIONLIST*   pNewPatchLocationList;      // out: Pointer to the next patch location list.
    UINT                        NewPatchLocationListSize;   // in: Size requested for the next patch location list.
                                                            // out: Size of the new patch location list.
    D3DDDICB_RENDERFLAGS Flags;                             // in: Flags
    HANDLE                      hContext;                   // in: Context being submitted to and owning the specified command buffer.
    UINT                        BroadcastContextCount;                          // in: Specifies the number of context 
                                                                                //     to broadcast this command buffer to.
    HANDLE                      BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT]; // in: Specifies the handle of the context to
                                                                                //     broadcast to.
    ULONG                       QueuedBufferCount;          // out: Number of DMA buffer queued to this context after this submission.
} D3DDDICB_RENDER;

typedef struct _D3DDDICB_ESCAPE
{
    HANDLE             hDevice;                // in: optional device
    D3DDDI_ESCAPEFLAGS Flags;                  // in: flags
    VOID*              pPrivateDriverData;     // in/out: data to/from KMD
    UINT               PrivateDriverDataSize;  // in: size of the data
    HANDLE             hContext;               // in: optional context
} D3DDDICB_ESCAPE;

typedef struct _D3DDDICB_CREATEOVERLAY
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;      // in
    D3DDDI_KERNELOVERLAYINFO        OverlayInfo;       // in
    D3DKMT_HANDLE                   hKernelOverlay;    // out: Kernel overlay handle
} D3DDDICB_CREATEOVERLAY;

typedef struct _D3DDDICB_UPDATEOVERLAY
{
    D3DKMT_HANDLE            hKernelOverlay;    // in: Kernel overlay handle
    D3DDDI_KERNELOVERLAYINFO OverlayInfo;       // in
} D3DDDICB_UPDATEOVERLAY;

typedef struct _D3DDDICB_FLIPOVERLAY
{
    D3DKMT_HANDLE        hKernelOverlay;        // in: Kernel overlay handle
    D3DKMT_HANDLE        hSource;               // in: Allocation currently displayed
    VOID*                pPrivateDriverData;    // in: Private driver data
    UINT                 PrivateDriverDataSize; // in: Size of private driver data
} D3DDDICB_FLIPOVERLAY;

typedef struct _D3DDDICB_DESTROYOVERLAY
{
    D3DKMT_HANDLE        hKernelOverlay;        // in: Kernel overlay handle
} D3DDDICB_DESTROYOVERLAY;

typedef struct _D3DDDICB_CREATECONTEXT
{
    UINT                        NodeOrdinal;                    // in:  Specify the node ordinal this context is targeted to.
    UINT                        EngineAffinity;                 // in:  Specify the engine affinity within the node.
    D3DDDI_CREATECONTEXTFLAGS   Flags;                          // in:  Context creation flags.
    VOID*                       pPrivateDriverData;             // in:  Pointer to private driver data
    UINT                        PrivateDriverDataSize;          // in:  Size of private driver data
    HANDLE                      hContext;                       // out: Handle to the created context.
    VOID*                       pCommandBuffer;                 // out: Pointer to the first command buffer for this context.
    UINT                        CommandBufferSize;              // out: Command buffer size (bytes).
    D3DDDI_ALLOCATIONLIST*      pAllocationList;                // out: Pointer to the first allocation list for this context.
    UINT                        AllocationListSize;             // out: Allocation list size (elements).
    D3DDDI_PATCHLOCATIONLIST*   pPatchLocationList;             // out: Pointer to the first patch location list for this device.
    UINT                        PatchLocationListSize;          // out: Patch location list size (elements).
} D3DDDICB_CREATECONTEXT;

typedef struct _D3DDDICB_DESTROYCONTEXT
{
    HANDLE          hContext;                       // in: Handle to the context to destroy.
} D3DDDICB_DESTROYCONTEXT;

typedef struct _D3DDDICB_CREATESYNCHRONIZATIONOBJECT
{
    D3DDDI_SYNCHRONIZATIONOBJECTINFO        Info;           // in:  Attributes of the synchronization object to create.
    D3DKMT_HANDLE                           hSyncObject;    // out: Handle to the created object.
} D3DDDICB_CREATESYNCHRONIZATIONOBJECT;

typedef struct _D3DDDICB_DESTROYSYNCHRONIZATIONOBJECT
{
    D3DKMT_HANDLE          hSyncObject;                     // in: Handle to the synchronization object to destroy.
} D3DDDICB_DESTROYSYNCHRONIZATIONOBJECT;

typedef struct _D3DDDICB_WAITFORSYNCHRONIZATIONOBJECT
{
    HANDLE                 hContext;                                        // in: Specify the context that should be waiting.
    UINT                   ObjectCount;                                     // in: Number of object to wait on.
    D3DKMT_HANDLE          ObjectHandleArray[D3DDDI_MAX_OBJECT_WAITED_ON];  // in: Handle to synchronization objects to wait on.
} D3DDDICB_WAITFORSYNCHRONIZATIONOBJECT;

typedef struct _D3DDDICB_SIGNALSYNCHRONIZATIONOBJECT
{
    HANDLE                  hContext;                                       // in: Specify the context that should signal the objets.
    UINT                    ObjectCount;                                    // in: Number of object to signal.
    D3DKMT_HANDLE           ObjectHandleArray[D3DDDI_MAX_OBJECT_SIGNALED];  // in: Handle to the synchronization object to signal.
    D3DDDICB_SIGNALFLAGS    Flags;                                          // in: Specify signal behavior.    
} D3DDDICB_SIGNALSYNCHRONIZATIONOBJECT;

typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_ALLOCATECB)(HANDLE hDevice, D3DDDICB_ALLOCATE*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_DEALLOCATECB)(HANDLE hDevice, CONST D3DDDICB_DEALLOCATE*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_SETPRIORITYCB)(HANDLE hDevice, D3DDDICB_SETPRIORITY*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_QUERYRESIDENCYCB)(HANDLE hDevice, CONST D3DDDICB_QUERYRESIDENCY*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_SETDISPLAYMODECB)(HANDLE hDevice, D3DDDICB_SETDISPLAYMODE*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_SETDISPLAYPRIVATEDRIVERFORMATCB)(HANDLE hDevice, CONST D3DDDICB_SETDISPLAYPRIVATEDRIVERFORMAT*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_PRESENTCB)(HANDLE hDevice, CONST D3DDDICB_PRESENT*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_RENDERCB)(HANDLE hDevice, D3DDDICB_RENDER*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_LOCKCB)(HANDLE hDevice, D3DDDICB_LOCK*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_UNLOCKCB)(HANDLE hDevice, CONST D3DDDICB_UNLOCK*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_ESCAPECB)(HANDLE hAdapter, CONST D3DDDICB_ESCAPE*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_CREATEOVERLAYCB)(HANDLE hDevice, D3DDDICB_CREATEOVERLAY*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_UPDATEOVERLAYCB)(HANDLE hDevice, CONST D3DDDICB_UPDATEOVERLAY*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_FLIPOVERLAYCB)(HANDLE hDevice, CONST D3DDDICB_FLIPOVERLAY*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_DESTROYOVERLAYCB)(HANDLE hDevice, CONST D3DDDICB_DESTROYOVERLAY*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_CREATECONTEXTCB)(HANDLE hDevice, D3DDDICB_CREATECONTEXT*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_DESTROYCONTEXTCB)(HANDLE hDevice, CONST D3DDDICB_DESTROYCONTEXT*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_CREATESYNCHRONIZATIONOBJECTCB)(HANDLE hDevice, D3DDDICB_CREATESYNCHRONIZATIONOBJECT*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_DESTROYSYNCHRONIZATIONOBJECTCB)(HANDLE hDevice, CONST D3DDDICB_DESTROYSYNCHRONIZATIONOBJECT*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_WAITFORSYNCHRONIZATIONOBJECTCB)(HANDLE hDevice, CONST D3DDDICB_WAITFORSYNCHRONIZATIONOBJECT*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_SIGNALSYNCHRONIZATIONOBJECTCB)(HANDLE hDevice, CONST D3DDDICB_SIGNALSYNCHRONIZATIONOBJECT*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_SETASYNCCALLBACKSCB)(HANDLE hDevice, BOOL Enable);

typedef struct _D3DDDI_DEVICECALLBACKS
{
    PFND3DDDI_ALLOCATECB                        pfnAllocateCb;
    PFND3DDDI_DEALLOCATECB                      pfnDeallocateCb;
    PFND3DDDI_SETPRIORITYCB                     pfnSetPriorityCb;
    PFND3DDDI_QUERYRESIDENCYCB                  pfnQueryResidencyCb;
    PFND3DDDI_SETDISPLAYMODECB                  pfnSetDisplayModeCb;
    PFND3DDDI_PRESENTCB                         pfnPresentCb;
    PFND3DDDI_RENDERCB                          pfnRenderCb;
    PFND3DDDI_LOCKCB                            pfnLockCb;
    PFND3DDDI_UNLOCKCB                          pfnUnlockCb;
    PFND3DDDI_ESCAPECB                          pfnEscapeCb;
    PFND3DDDI_CREATEOVERLAYCB                   pfnCreateOverlayCb;
    PFND3DDDI_UPDATEOVERLAYCB                   pfnUpdateOverlayCb;
    PFND3DDDI_FLIPOVERLAYCB                     pfnFlipOverlayCb;
    PFND3DDDI_DESTROYOVERLAYCB                  pfnDestroyOverlayCb;
    PFND3DDDI_CREATECONTEXTCB                   pfnCreateContextCb;
    PFND3DDDI_DESTROYCONTEXTCB                  pfnDestroyContextCb;
    PFND3DDDI_CREATESYNCHRONIZATIONOBJECTCB     pfnCreateSynchronizationObjectCb;
    PFND3DDDI_DESTROYSYNCHRONIZATIONOBJECTCB    pfnDestroySynchronizationObjectCb;
    PFND3DDDI_WAITFORSYNCHRONIZATIONOBJECTCB    pfnWaitForSynchronizationObjectCb;
    PFND3DDDI_SIGNALSYNCHRONIZATIONOBJECTCB     pfnSignalSynchronizationObjectCb;
    PFND3DDDI_SETASYNCCALLBACKSCB               pfnSetAsyncCallbacksCb;
    PFND3DDDI_SETDISPLAYPRIVATEDRIVERFORMATCB   pfnSetDisplayPrivateDriverFormatCb;
} D3DDDI_DEVICECALLBACKS;

typedef struct _D3DDDI_CREATEDEVICEFLAGS
{
    union
    {
        struct
        {
            UINT    AllowMultithreading     : 1;    // 0x00000001
            UINT    AllowFlipBatching       : 1;    // 0x00000002
            UINT    Reserved                :30;    // 0xFFFFFFFD
        };
        UINT Value;
    };
} D3DDDI_CREATEDEVICEFLAGS;

typedef struct _D3DDDIARG_CREATEDEVICE
{
    HANDLE                          hDevice;                // in:  Runtime handle/out: Driver handle
    UINT                            Interface;              // in:  Interface version
    UINT                            Version;                // in:  Runtime Version
    CONST D3DDDI_DEVICECALLBACKS*   pCallbacks;             // in:  Pointer to runtime callbacks
    VOID*                           pCommandBuffer;         // in:  Pointer to the first command buffer to use.
    UINT                            CommandBufferSize;      // in:  Size of the first command buffer to use.
    D3DDDI_ALLOCATIONLIST*          pAllocationList;        // out: Pointer to the first allocation list to use.
    UINT                            AllocationListSize;     // in:  Size of the allocation list that will be available
                                                            //      when the first command buffer is submitted.
    D3DDDI_PATCHLOCATIONLIST*       pPatchLocationList;     // out: Pointer to the first patch location list to use.
    UINT                            PatchLocationListSize;  // in:  Size of the patch location list that will be available
                                                            //      when the first command buffer is submitted.
    D3DDDI_DEVICEFUNCS*             pDeviceFuncs;           // out: Driver function table
    D3DDDI_CREATEDEVICEFLAGS        Flags;                  // in:  Flags
} D3DDDIARG_CREATEDEVICE;

typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_QUERYADAPTERINFOCB)(HANDLE hAdapter, CONST D3DDDICB_QUERYADAPTERINFO*);
typedef HRESULT (APIENTRY CALLBACK *PFND3DDDI_GETMULTISAMPLEMETHODLISTCB)(HANDLE hAdapter, D3DDDICB_GETMULTISAMPLEMETHODLIST*);

typedef struct _D3DDDI_ADAPTERCALLBACKS
{
    PFND3DDDI_QUERYADAPTERINFOCB            pfnQueryAdapterInfoCb;
    PFND3DDDI_GETMULTISAMPLEMETHODLISTCB    pfnGetMultisampleMethodListCb;
} D3DDDI_ADAPTERCALLBACKS;

typedef HRESULT (APIENTRY *PFND3DDDI_GETCAPS)(HANDLE hAdapter, CONST D3DDDIARG_GETCAPS*);
typedef HRESULT (APIENTRY *PFND3DDDI_CREATEDEVICE)(IN HANDLE hAdapter, IN D3DDDIARG_CREATEDEVICE*);
typedef HRESULT (APIENTRY *PFND3DDDI_CLOSEADAPTER)(IN HANDLE hAdapter);

typedef struct _D3DDDI_ADAPTERFUNCS
{
    PFND3DDDI_GETCAPS                       pfnGetCaps;
    PFND3DDDI_CREATEDEVICE                  pfnCreateDevice;
    PFND3DDDI_CLOSEADAPTER                  pfnCloseAdapter;
} D3DDDI_ADAPTERFUNCS;

typedef struct _D3DDDIARG_OPENADAPTER
{
    HANDLE                         hAdapter;           // in/out:  Runtime handle/out: Driver handle
    UINT                           Interface;          // in:  Interface version
    UINT                           Version;            // in:  Runtime version
    CONST D3DDDI_ADAPTERCALLBACKS* pAdapterCallbacks;  // in:  Pointer to runtime callbacks
    D3DDDI_ADAPTERFUNCS*           pAdapterFuncs;      // out: Driver function table
    UINT                           DriverVersion;      // out: D3D UMD interface version the 
                                                       //      driver was compiled with. Use 
                                                       //      D3D_UMD_INTERFACE_VERSION.
} D3DDDIARG_OPENADAPTER;

typedef HRESULT (APIENTRY *PFND3DDDI_OPENADAPTER)(IN D3DDDIARG_OPENADAPTER*);


#define _FACD3DDDI  0x876
#define MAKE_D3DDDIHRESULT(code)  MAKE_HRESULT(1, _FACD3DDDI, code)

#define D3DDDIERR_WASSTILLDRAWING               MAKE_D3DDDIHRESULT(540)
#define D3DDDIERR_NOTAVAILABLE                  MAKE_D3DDDIHRESULT(2154)
#define D3DDDIERR_DEVICEREMOVED                 MAKE_D3DDDIHRESULT(2160)
#define D3DDDIERR_PRIVILEGEDINSTRUCTION         MAKE_D3DDDIHRESULT(2161)
#define D3DDDIERR_INVALIDINSTRUCTION            MAKE_D3DDDIHRESULT(2162)
#define D3DDDIERR_INVALIDHANDLE                 MAKE_D3DDDIHRESULT(2163)
#define D3DDDIERR_CANTEVICTPINNEDALLOCATION     ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION
#define D3DDDIERR_CANTRENDERLOCKEDALLOCATION    ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION
#define D3DDDIERR_INVALIDUSERBUFFER             MAKE_D3DDDIHRESULT(2169)
#define D3DDDIERR_INCOMPATIBLEPRIVATEFORMAT     MAKE_D3DDDIHRESULT(2170)

#endif /* _D3DUMDDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dbdao.h ===
/************************************************************************
**      D B D A O . H                                                   *
**                                                                      *
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation			                *
**                 All Rights Reserved                                  *
************************************************************************/
/*
	DBDAO.H

	Class definitions for ddao SDK.  

This is a part of the Microsoft Data Access Objects SDK library.
See the  DAO SDK help information for detailed information regarding the
Microsoft Data Access Objects SDK product.

*/

#ifndef _DBDAO_H_
#define _DBDAO_H_

// Ignore warning "non dll-interface class 'X' used as base for dll-interface class 'Y'
#pragma warning( disable : 4275 )

//DAO must be built with an MFC version >= 4.2 (or you'll get memory problems with CStrings)

#if _MFC_VER < 0x0420
#error The DAOSDK 3.5 libraries will not operate correctly if built with MFC older than 4.2
#endif

#ifndef DAO35
#define DAO35
#endif

#include <dbdaoint.h>
#include <daogetrw.h>
#include <dbdaoid.h>

// Decorations
#define CONSTRUCTOR
#define DESTRUCTOR

//Disable export
#ifndef DLLEXPORT
#define DLLEXPORT __declspec( dllexport )
#endif

//Macro to convert HRESULT to IDA 
#define DBERR(x) SCODE_CODE(GetScode(x))

// Include internal DAO definitions
#include <_dbdao.h>

//      DAO Recordset::GetRowsEx() binding definitions

#define dbBindIndexINT  1
#define dbBindIndexSTR  2

#define dbBindI2                DAO_I2                  // long
#define dbBindI4                DAO_I4                  // short
#define dbBindR4                DAO_R4                  // float
#define dbBindR8                DAO_R8                  // double
#define dbBindCY                DAO_CURRENCY			// Currency
#define dbBindDATE              DAO_DATE                // DATE
#define dbBindBOOL              DAO_BOOL                // VARIANT_BOOL
#define dbBindUI1               DAO_CHAR                // unsigned char
#define dbBindVARIANT			DAO_ANYVARIANT			// VARIANT
#define dbBindWCHAR             DAO_WCHAR               // wchar_t[] (inline)

#define dbBindBookmark			DAO_BOOKMARK			// bookmark psuedo field
#define dbBindLPSTR				DAO_LPSTR				// \0 string in pvVarBuffer
#define dbBindLPWSTR			DAO_LPWSTR				// wide string in pvVarBuffer
#define dbBindBlob				DAO_BLOB				// 

#ifdef _UNICODE
#define dbBindSTRING    dbBindWCHAR     
#define dbBindLPSTRING	dbBindLPWSTR
#else
#define dbBindSTRING    dbBindUI1
#define dbBindLPSTRING	dbBindLPSTR
#endif

//      Binding structure (Used with GetRowsEX)

typedef struct
	{
	DWORD   dwBindIndexType;
	union
		{
		LONG    i;
		LPCTSTR pstr;
		};

	DWORD   dwType;
	DWORD   dwOffset;
	DWORD   cb;

	} DAORSETBINDING, *LPDAORSETBINDING;



/*****************************************************************************
* Forwards
*/
class COleVariant;
class CdbBookmark;
class CdbException;
class CdbOleObject;
class CdbObject;
class CdbError;
class CdbProperty;
class CdbDBEngine;
class CdbWorkspace;
class CdbDatabase;
class CdbConnection;
class CdbRecordset;
class CdbGetRowsEx;
class CdbQueryDef;
class CdbTableDef;
class CdbField;
class CdbRelation;
class CdbIndex;
class CdbUser;
class CdbGroup;
class CdbDocument;
class CdbContainer;
class CdbParameter;
class CdbCollection;
class CdbErrors;
class CdbProperties;
class CdbWorkspaces;
class CdbDatabases;
class CdbConnections;
class CdbRecordsets;
class CdbQueryDefs;
class CdbTableDefs;
class CdbFields;
class CdbRelations;
class CdbIndexes;
class CdbUsers;
class CdbGroups;
class CdbDocuments;
class CdbContainers;
class CdbParameters;


/*****************************************************************************
* CdbException
*/
class DLLEXPORT CdbException 
	{
public:
	CONSTRUCTOR                     CdbException            (HRESULT hr);

	HRESULT                         m_hr;
	};


/*****************************************************************************
* CdbBookmark
*/
class DLLEXPORT CdbBookmark : public COleVariant
	{
	public:

	CONSTRUCTOR                     CdbBookmark                     (LPSAFEARRAY psa);
	CONSTRUCTOR                     CdbBookmark                     ();
	CONSTRUCTOR                     CdbBookmark                     (const CdbBookmark &);
	CdbBookmark &                   operator =                      (const CdbBookmark &);
	operator                        LPSAFEARRAY                     (VOID);
	};


/*****************************************************************************
* CdbIndexFields (special case for index fields)
*/
class DLLEXPORT CdbIndexFields : public CdbFields
	{
	public:
	CdbField                                Item                            (LPCTSTR pstr);
	CdbField                                Item                            (LONG i);
	CdbObject                               ObItem                          (LPCTSTR pstr);
	CdbObject                               ObItem                          (LONG i);
	};


/*****************************************************************************
* CdbLastOLEError
*/
class DLLEXPORT CdbLastOLEError : public CdbOleObject
	{
	public:

	CONSTRUCTOR                             CdbLastOLEError         (VOID);

	CString                                 GetSource                       (VOID);
	CString                                 GetDescription          (VOID);
	CString                                 GetHelpFile                     (VOID);
	DWORD                                   GetHelpContext          (VOID);
	};

/*****************************************************************************
* CdbDBEngine
*/
class DLLEXPORT CdbDBEngine : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDBEngine             (DAODBEngine *peng, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDBEngine             (BOOL bPrivate=FALSE, BOOL bStart=TRUE, LPCTSTR pstrIniPath=NULL, LPCTSTR pstrDefUser=NULL, LPCTSTR pstrDefPW=NULL, LONG lType=dbUseJet);
	CONSTRUCTOR                     CdbDBEngine             (const CdbDBEngine &);
	CdbDBEngine &           operator =                      (const CdbDBEngine &);
	inline CdbWorkspace     operator []                     (LONG lIndex);
	inline CdbWorkspace     operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	VOID                            SetDefaultPassword      (LPCTSTR pstr);
	VOID                            SetDefaultUser          (LPCTSTR pstr);
	VOID                            SetIniPath              (LPCTSTR pstr);
	CString                         GetIniPath              (VOID);
	VOID							SetDefaultType			(LONG l);
	LONG							GetDefaultType			(VOID);
	VOID                            SetLoginTimeout         (SHORT s);
	SHORT                           GetLoginTimeout         (VOID);
	CString                         GetVersion              (VOID);
	CString                         GetSystemDB             (VOID);
	VOID                            SetSystemDB             (LPCTSTR pstr);

	// Methods
	CdbWorkspace					CreateWorkspace         (LPCTSTR pstrName, LPCTSTR pstrUser, LPCTSTR pstrPassword, LONG lType=-1);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, BOOL bExclusive, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, LONG lOption=0L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbConnection					OpenConnection			(LPCTSTR pstrName, LONG lOption=-1L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	VOID                            CompactDatabase			(LPCTSTR pstrOldDatabase, LPCTSTR pstrNewDatabase, LPCTSTR pstrDstConnect = NULL, LONG lOptions=-1, LPCTSTR pstrSrcConnect = NULL);
	VOID                            RepairDatabase          (LPCTSTR pstrDatabase);
	VOID                            RegisterDatabase        (LPCTSTR pstrDatabase, LPCTSTR pstrDriver, BOOL bSilent, LPCTSTR pstrAttributes);
	VOID                            Idle                    (LONG lOptions=-1);
	VOID                            Start                   (VOID);
	VOID							SetOption				(long lOption, LPVARIANT pvValue);
	

	// Collections
	CdbWorkspaces					Workspaces;
	CdbErrors                       Errors;

	private:
	BOOL                            m_bStarted;
	};

/*****************************************************************************
* CdbWorkspace
*/
class DLLEXPORT CdbWorkspace : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbWorkspace            (VOID);
	CONSTRUCTOR                     CdbWorkspace            (DAOWorkspace *pwrk, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbWorkspace            (const CdbWorkspace &);
	CdbWorkspace &          operator =                      (const CdbWorkspace &);
	inline CdbDatabase      operator []                     (LONG lIndex);
	inline CdbDatabase      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetUserName                     (VOID);
	BOOL                            GetIsolateODBCTrans				(VOID);
	VOID                            SetIsolateODBCTrans				(BOOL b);
	LONG							GetType							(VOID);
	LONG							GetDefaultCursorDriver			(VOID);
	VOID							SetDefaultCursorDriver			(LONG l);
	LONG							GetLoginTimeout					(VOID);
	VOID							SetLoginTimeout					(LONG l);

	// Methods
	VOID                            BeginTrans                      (VOID);
	VOID                            CommitTrans                     (LONG lOptions=-1);
	VOID                            Close                           (VOID);
	VOID                            Rollback                        (VOID);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, BOOL bExclusive, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, LONG lOption=0L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbConnection					OpenConnection			(LPCTSTR pstrName, LONG lOption=-1L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     CreateDatabase          (LPCTSTR pstrName, LPCTSTR pstrConnect, LONG lOption=-1);
	CdbUser                         CreateUser                      (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL, LPCTSTR pstrPassword=NULL);
	CdbGroup                        CreateGroup                     (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL);

	// Collections
	CdbDatabases					Databases;
	CdbConnections					Connections;
	CdbUsers                        Users;
	CdbGroups                       Groups;
	};

/*****************************************************************************
* CdbDatabase
*/
class DLLEXPORT CdbDatabase : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDatabase                     (VOID);
	CONSTRUCTOR                     CdbDatabase                     (DAODatabase *pdb, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDatabase                     (const CdbDatabase &);
	CdbDatabase &           operator =                      (const CdbDatabase &);
	inline CdbTableDef      operator []                     (LONG lIndex);
	inline CdbTableDef      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                    GetCollatingOrder       (VOID);
	CString                 GetConnect              (VOID);
	VOID					SetConnect				(LPCTSTR pstrConnect);
	CString                 GetName                 (VOID);
	SHORT                   GetQueryTimeout         (VOID);
	VOID                    SetQueryTimeout         (SHORT s);
	BOOL                    GetTransactions         (VOID);
	BOOL                    GetUpdatable            (VOID);
	CString                 GetVersion              (VOID);
	LONG                    GetRecordsAffected      (VOID);
	CdbConnection			GetConnection			(VOID);
	//Replication properties
	CString					GetReplicaID			(VOID);
	CString					GetDesignMasterID		(VOID);
	VOID					SetDesignMasterID		(LPCTSTR pstrMasterID);


	// Methods
	VOID                    Close                   (VOID);
	VOID                    Execute                 (LPCTSTR pstrQuery, LONG lOption=-1);
	CdbRecordset            OpenRecordset           (LPCTSTR pstrName, LONG lType=-1, LONG lOptions=-1, LONG lLockEdit=-1);
	CdbProperty             CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	CdbRelation             CreateRelation          (LPCTSTR pstrName=NULL, LPCTSTR pstrTable=NULL, LPCTSTR pstrForiegn=NULL, LONG lAttributes=-1);
	CdbTableDef             CreateTableDef          (LPCTSTR pstrName=NULL, LONG lAttributes=-1, LPCTSTR pstrSource=NULL, LPCTSTR pstrConnect=NULL);
	CdbQueryDef             CreateQueryDef          (LPCTSTR pstrName=NULL, LPCTSTR pstrSQL=NULL);
	VOID					NewPassword				(LPCTSTR pstrOld, LPCTSTR pstrNew);
	//Replication methods
	VOID                    Synchronize				(LPCTSTR pstrReplica, LONG lType=-1);
	VOID                    MakeReplica				(LPCTSTR pstrPath, LPCTSTR pstrDescription, LONG lOptions=-1);
	VOID					PopulatePartial			(LPCTSTR pstrDbPathName);

	// Collections
	CdbTableDefs            TableDefs;
	CdbQueryDefs            QueryDefs;
	CdbRelations            Relations;
	CdbContainers           Containers;
	CdbRecordsets           Recordsets;
	};

/*****************************************************************************
* CdbConnection
*/
class DLLEXPORT CdbConnection : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbConnection           (VOID);
	CONSTRUCTOR                     CdbConnection           (DAOConnection *pconn, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbConnection           (const CdbConnection &);
	CdbConnection &					operator =              (const CdbConnection &);
	inline CdbQueryDef				operator []             (LONG lIndex);
	inline CdbQueryDef				operator []             (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetConnect              (VOID);
	CString                         GetName                 (VOID);
	CdbDatabase						GetDatabase				(VOID);
	SHORT                           GetQueryTimeout         (VOID);
	VOID                            SetQueryTimeout         (SHORT s);
	LONG							GetRecordsAffected		(VOID);
	BOOL							GetStillExecuting		(VOID);
	BOOL							GetTransactions         (VOID);
	BOOL                            GetUpdatable            (VOID);

	// Methods
	VOID                            Cancel					(VOID);
	VOID                            Close                   (VOID);
	CdbQueryDef						CreateQueryDef          (LPCTSTR pstrName=NULL, LPCTSTR pstrSQL=NULL);
	VOID                            Execute                 (LPCTSTR pstrQuery, LONG lOption=-1);
	CdbRecordset					OpenRecordset           (LPCTSTR pstrName, LONG lType=-1, LONG lOptions=-1, LONG lLockEdit=-1);

	// Collections
	CdbQueryDefs            QueryDefs;
	CdbRecordsets           Recordsets;
	};

/*****************************************************************************
* CdbRecordset
*/
class DLLEXPORT CdbRecordset : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbRecordset            (VOID);
	CONSTRUCTOR                     CdbRecordset            (DAORecordset *prs, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbRecordset            (const CdbRecordset &);
	CdbRecordset &          operator =                      (const CdbRecordset &);
	inline CdbField     operator []                     (LONG lIndex);
	inline CdbField     operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);
	VOID                            SetGetRowsExInt			(VOID);

	// Properties
	BOOL                            GetBOF                          (VOID);
	CdbBookmark                     GetBookmark                     (VOID);
	VOID                            SetBookmark                     (class CdbBookmark);
	BOOL                            GetBookmarkable         (VOID);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	BOOL                            GetEOF                          (VOID);
	CString                         GetFilter                       (VOID);
	VOID                            SetFilter                       (LPCTSTR pstr);
	CString                         GetIndex                        (VOID);
	VOID                            SetIndex                        (LPCTSTR pstr);
	CdbBookmark                     GetLastModified         (VOID);
	BOOL                            GetLockEdits            (VOID);
	VOID                            SetLockEdits            (BOOL b);
	CString                         GetName                         (VOID);
	BOOL                            GetNoMatch                      (VOID);
	CString                         GetSort                         (VOID);
	VOID                            SetSort                         (LPCTSTR pstr);
	BOOL                            GetTransactions         (VOID);
	SHORT                           GetType                         (VOID);
	LONG                            GetRecordCount          (VOID);
	BOOL                            GetUpdatable            (VOID);
	BOOL                            GetRestartable          (VOID);
	CString                         GetValidationText       (VOID);
	CString                         GetValidationRule       (VOID);
	CdbBookmark                     GetCacheStart           (VOID);
	VOID                            SetCacheStart           (CdbBookmark &pbm);
	LONG                            GetCacheSize            (VOID);
	VOID                            SetCacheSize            (LONG l);
	FLOAT                           GetPercentPosition      (VOID);
	VOID                            SetPercentPosition      (FLOAT f);
	LONG                            GetAbsolutePosition     (VOID);
	VOID                            SetAbsolutePosition     (LONG l);
	SHORT                           GetEditMode				(VOID);
	LONG                            GetUpdateOptions		(VOID);
	VOID                            SetUpdateOptions		(LONG l);
	SHORT                           GetRecordStatus			(VOID);
	BOOL							GetStillExecuting		(VOID);
	LONG                            GetBatchSize			(VOID);
	VOID                            SetBatchSize			(LONG l);
	LONG                            GetBatchCollisionCount	(VOID);
	COleVariant						GetBatchCollisions		(VOID);
	CdbConnection					GetConnection			(VOID);

	// Methods
	VOID                            CancelUpdate            (short sType = dbUpdateRegular);
	VOID                            AddNew                          (VOID);
	VOID                            Close                           (VOID);
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1);
	VOID                            Delete                          (VOID);
	VOID                            Edit                            (VOID);
	VOID                            FindFirst                       (LPCTSTR pstrCriteria);
	VOID                            FindLast                        (LPCTSTR pstrCriteria);
	VOID                            FindNext                        (LPCTSTR pstrCriteria);
	VOID                            FindPrevious            (LPCTSTR pstrCriteria);
	VOID                            MoveFirst                       (VOID);
	VOID                            MoveLast                        (LONG lOptions=-1);
	VOID                            MoveNext                        (VOID);
	VOID                            MovePrevious            (VOID);
	VOID                            Seek                            (LPCTSTR pstrComparison, LONG lNumFields, COleVariant cKey, ...);
	VOID                            Update                          (short sType = dbUpdateRegular, VARIANT_BOOL bForce = FALSE);
	CdbRecordset					Clone                           (VOID);
	VOID                            Requery                         (CdbQueryDef *pq = NULL);
	VOID                            Move                            (LONG lRows, CdbBookmark *bm=NULL);
	VOID                            FillCache                       (LONG lRows=-1, CdbBookmark *pbm=NULL);
	CdbQueryDef                     CopyQueryDef					(VOID);
	COleVariant                     GetRows                         (LONG lRows=-1);
	LONG                            GetRowsEx                       (LPVOID pvBuffer, LONG cbRow, LPDAORSETBINDING prb, LONG cBinding, LPVOID pvVarBuffer = NULL, LONG cbVarBuffer = 0, LONG lRows = -1);
	VOID                            Cancel							(VOID);
	BOOL							NextRecordset					(VOID);

	inline VOID						GetFieldV                       (COleVariant &vIndex, COleVariant &vValue);
	inline VOID                     SetFieldV                       (COleVariant &vIndex, LPVARIANT pv);


	COleVariant                     GetField                        (LPCTSTR pstrIndex);
	COleVariant                     GetField                        (LONG lIndex);
	COleVariant						GetField                        (COleVariant &vIndex);
	COleVariant						GetField                        (CString &str){return GetField((LPCTSTR)str);}

	VOID                            SetField                        (LPCTSTR pstrIndex, LPVARIANT pv);
	VOID                            SetField                        (LONG lIndex, LPVARIANT pv);
	VOID							SetField                        (COleVariant &vIndex, LPVARIANT pv);
	VOID							SetField                        (CString &str, LPVARIANT pv){SetField((LPCTSTR)str, pv);}

	// Collections
	CdbFields                       Fields;
protected:
	// GetRowsEx interface
	CdbGetRowsEx            m_GetRowsInt;
	};


/*****************************************************************************
* CdbField
*/
class DLLEXPORT CdbField : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbField                        (VOID);
	CONSTRUCTOR                     CdbField                        (DAOField *pfld, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbField                        (const CdbField &);
	CdbField &                      operator =                      (const CdbField &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetCollatingOrder       (VOID);
	SHORT                           GetType                         (VOID);
	VOID                            SetType                         (SHORT s);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	LONG                            GetSize                         (VOID);
	VOID                            SetSize                         (LONG l);
	CString                         GetSourceField          (VOID);
	CString                         GetSourceTable          (VOID);
	COleVariant                     GetValue                 (VOID);

	VOID                            SetValue                (LPVARIANT pv);
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG l);
	SHORT                           GetOrdinalPosition      (VOID);
	VOID                            SetOrdinalPosition      (SHORT s);
	CString                         GetValidationText       (VOID);
	VOID                            SetValidationText       (LPCTSTR pstr);
	BOOL                            GetValidateOnSet        (VOID);
	VOID                            SetValidateOnSet        (BOOL b);
	CString                         GetValidationRule       (VOID);
	VOID                            SetValidationRule       (LPCTSTR pstr);
	CString		                    GetDefaultValue         (VOID);
	VOID                            SetDefaultValue         (LPCTSTR pstr);
	VOID                            SetDefaultValue         (LPVARIANT pv);
	BOOL                            GetRequired             (VOID);
	VOID                            SetRequired             (BOOL b);
	BOOL                            GetAllowZeroLength      (VOID);
	VOID                            SetAllowZeroLength      (BOOL b);
	BOOL                            GetDataUpdatable		(VOID);
	CString                         GetForeignName          (VOID);
	VOID                            SetForeignName          (LPCTSTR pstr);
	COleVariant                     GetOriginalValue		(VOID);
	COleVariant                     GetVisibleValue			(VOID);

	// Methods
	VOID                            AppendChunk                     (LPVARIANT pv);
	COleVariant                     GetChunk                        (LONG lOffset, LONG lBytes);
	LONG                            FieldSize                       (VOID);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	};

/*****************************************************************************
* CdbQueryDef
*/
class DLLEXPORT CdbQueryDef : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbQueryDef             (VOID);
	CONSTRUCTOR                     CdbQueryDef             (DAOQueryDef *pqd, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbQueryDef             (const CdbQueryDef &);
	CdbQueryDef &           operator =                      (const CdbQueryDef &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	CString                         GetName                 (VOID);
	VOID                            SetName                 (LPCTSTR pstr);
	SHORT                           GetODBCTimeout          (VOID);
	VOID                            SetODBCTimeout          (SHORT s);
	SHORT                           GetType                 (VOID);
	CString                         GetSQL                  (VOID);
	VOID                            SetSQL                  (LPCTSTR pstr);
	BOOL                            GetUpdatable            (VOID);
	CString                         GetConnect              (VOID);
	VOID                            SetConnect              (LPCTSTR pstr);
	BOOL                            GetReturnsRecords       (VOID);
	VOID                            SetReturnsRecords       (BOOL b);
	LONG                            GetRecordsAffected      (VOID);
	LONG                            GetMaxRecords			(VOID);
	VOID                            SetMaxRecords			(LONG l);
	BOOL							GetStillExecuting		(VOID);
	LONG                            GetCacheSize			(VOID);
	VOID                            SetCacheSize			(LONG l);
	COleVariant						GetPrepare				(VOID);
	VOID                            SetPrepare				(LPVARIANT pv);

	// Methods
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1, LONG lLockEdit=-1);
	VOID                            Execute                 (LONG lOption=-1);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	VOID							Close					(VOID);
	VOID							Cancel					(VOID);

	// Collections
	CdbFields                       Fields;
	CdbParameters					Parameters;
	};

/*****************************************************************************
* CdbTableDef
*/
class DLLEXPORT CdbTableDef : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbTableDef                     (VOID);
	CONSTRUCTOR                     CdbTableDef                     (DAOTableDef *ptd, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbTableDef                     (const CdbTableDef &);
	CdbTableDef &           operator =                      (const CdbTableDef &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG l);
	CString                         GetConnect                      (VOID);
	VOID                            SetConnect                      (LPCTSTR pstr);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetSourceTableName      (VOID);
	VOID                            SetSourceTableName      (LPCTSTR pstr);
	BOOL                            GetUpdatable            (VOID);
	CString                         GetValidationText       (VOID);
	VOID                            SetValidationText       (LPCTSTR pstr);
	CString                         GetValidationRule       (VOID);
	VOID                            SetValidationRule       (LPCTSTR pstr);
	LONG                            GetRecordCount          (VOID);
	CString							GetConflictTable		(VOID);
	COleVariant						GetReplicaFilter		(VOID);
	VOID							SetReplicaFilter		(LPVARIANT pv);

	// Methods
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1);
	VOID                            RefreshLink                     (VOID);
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);
	CdbIndex                        CreateIndex                     (LPCTSTR pstrName=NULL);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);

	// Collections
	CdbFields                       Fields;
	CdbIndexes                      Indexes;
	};

/*****************************************************************************
* CdbIndex
*/
class DLLEXPORT CdbIndex : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbIndex                        (VOID);
	CONSTRUCTOR                     CdbIndex                        (DAOIndex *pidx, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbIndex                        (const CdbIndex &);
	CdbIndex &                      operator =                      (const CdbIndex &);
	inline CdbField         operator []             (LONG lIndex);
	inline CdbField         operator []             (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	BOOL                            GetForeign                      (VOID);
	BOOL                            GetUnique                       (VOID);
	VOID                            SetUnique                       (BOOL b);
	BOOL                            GetClustered            (VOID);
	VOID                            SetClustered            (BOOL b);
	BOOL                            GetRequired                     (VOID);
	VOID                            SetRequired                     (BOOL b);
	BOOL                            GetIgnoreNulls          (VOID);
	VOID                            SetIgnoreNulls          (BOOL b);
	BOOL                            GetPrimary                      (VOID);
	VOID                            SetPrimary                      (BOOL b);
	LONG                            GetDistinctCount        (VOID);

	// Methods
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);

	// Collections
	CdbIndexFields          Fields;
	};

/*****************************************************************************
* CdbParameter
*/
class DLLEXPORT CdbParameter : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbParameter            (VOID);
	CONSTRUCTOR                     CdbParameter            (DAOParameter *pprm, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbParameter            (const CdbParameter &);
	CdbParameter &          operator =                      (const CdbParameter &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName					(VOID);
	COleVariant                     GetValue				(VOID);
	VOID                            SetValue				(LPVARIANT pv);
	SHORT                           GetType					(VOID);
	VOID							SetType					(SHORT i);
	SHORT							GetDirection			(VOID);
	VOID							SetDirection			(SHORT i);
	};

/*****************************************************************************
* CdbRelation
*/
class DLLEXPORT CdbRelation : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbRelation                     (VOID);
	CONSTRUCTOR                     CdbRelation                     (DAORelation *prl, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbRelation                     (const CdbRelation &);
	CdbRelation &           operator =                      (const CdbRelation &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetTable                        (VOID);
	VOID                            SetTable                        (LPCTSTR pstr);
	CString                         GetForeignTable         (VOID);
	VOID                            SetForeignTable         (LPCTSTR pstr);
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG);
	BOOL							GetPartialReplica		(VOID);
	VOID							SetPartialReplica		(BOOL b);

	// Methods
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);

	// Collections
	CdbFields                       Fields;
	};

/*****************************************************************************
* CdbUser
*/
class DLLEXPORT CdbUser : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbUser                         (VOID);
	CONSTRUCTOR                     CdbUser                         (DAOUser *pusr, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbUser                         (const CdbUser &);
	CdbUser &                       operator =                      (const CdbUser &);
	inline CdbGroup         operator []                     (LONG lIndex);
	inline CdbGroup         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	VOID                            SetPID                          (LPCTSTR pstr);
	VOID                            SetPassword                     (LPCTSTR pstr);

	// Methods
	VOID                            NewPassword                     (LPCTSTR pstrOld, LPCTSTR pstrNew);
	CdbGroup                        CreateGroup                     (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL);

	// Collections
	CdbGroups                       Groups;
	};

/*****************************************************************************
* CdbGroup
*/
class DLLEXPORT CdbGroup : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbGroup                        (VOID);
	CONSTRUCTOR                     CdbGroup                        (DAOGroup *pgrp, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbGroup                        (const CdbGroup &);
	CdbGroup &                      operator =                      (const CdbGroup &);
	inline CdbUser          operator []                     (LONG lIndex);
	inline CdbUser          operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	VOID                            SetPID                          (LPCTSTR pstr);

	// Methods
	CdbUser                         CreateUser                      (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL, LPCTSTR pstrPassword=NULL);

	// Collections
	CdbUsers                        Users;
	};

/*****************************************************************************
* CdbDocument
*/
class DLLEXPORT CdbDocument : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDocument                     (VOID);
	CONSTRUCTOR                     CdbDocument                     (DAODocument *pdoc, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDocument                     (const CdbDocument &);
	CdbDocument &           operator =                      (const CdbDocument &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	CString                         GetOwner                        (VOID);
	VOID                            SetOwner                        (LPCTSTR pstr);
	CString                         GetContainer            (VOID);
	CString                         GetUserName                     (VOID);
	VOID                            SetUserName                     (LPCTSTR pstr);
	LONG                            GetPermissions          (VOID);
	VOID                            SetPermissions          (LONG l);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	LONG							GetAllPermissions		(VOID);
	//Methods
	CdbProperty						CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	};

/*****************************************************************************
* CdbContainer
*/
class DLLEXPORT CdbContainer : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbContainer            (VOID);
	CONSTRUCTOR                     CdbContainer            (DAOContainer *pctn, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbContainer            (const CdbContainer &);
	CdbContainer &          operator =                      (const CdbContainer &);
	inline CdbDocument      operator []                     (LONG lIndex);
	inline CdbDocument      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	CString                         GetOwner                        (VOID);
	VOID                            SetOwner                        (LPCTSTR pstr);
	CString                         GetUserName                     (VOID);
	VOID                            SetUserName                     (LPCTSTR pstr);
	LONG                            GetPermissions          (VOID);
	VOID                            SetPermissions          (LONG l);
	BOOL                            GetInherit                      (VOID);
	VOID                            SetInherit                      (BOOL b);
	LONG							GetAllPermissions		(VOID);

	// Collections
	CdbDocuments            Documents;
	};

/*****************************************************************************
* CdbError
*/
class DLLEXPORT CdbError : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbError                        (VOID);
	CONSTRUCTOR                     CdbError                        (DAOError *perr, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbError                        (const CdbError &);
	CdbError &                      operator =                      (const CdbError &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetNumber                       (VOID);
	CString                         GetSource                       (VOID);
	CString                         GetDescription          (VOID);
	CString                         GetHelpFile                     (VOID);
	LONG                            GetHelpContext          (VOID);
	};

/*****************************************************************************
* CdbProperty
*/
class DLLEXPORT CdbProperty : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbProperty                     (VOID);
	CONSTRUCTOR                     CdbProperty                     (DAOProperty *pprp, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbProperty                     (const CdbProperty &);
	CdbProperty &           operator =                      (const CdbProperty &);

	// Properties
	COleVariant                     GetValue                        (VOID);
	VOID                            SetValue                        (LPVARIANT pv);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstrName);
	SHORT                           GetType                         (VOID);
	VOID                            SetType                         (SHORT sType);
	BOOL                            GetInherited            (VOID);
	};


/*****************************************************************************
*  Inline functions
*/
inline BOOL	CdbOleObject::Exists(void)
	{ 
	return (m_punkInterface ? TRUE : FALSE);
	}

/*****************************************************************************
*  Recordset GetField functions
*/


inline VOID				CdbRecordset::GetFieldV(
	COleVariant &vIndex,
	COleVariant &vValue)
{
	DAORecordset *  prs     = (DAORecordset *)GetInterface();

	if (!prs)
		{
		DAOVINIT(vValue);
		return;
		}

	DAOMFC_CALL(prs->get_Collect(vIndex, &vValue));

	return;
}

inline VOID				CdbRecordset::SetFieldV(
	COleVariant &vIndex, 
	LPVARIANT pv)
{
	DAORecordset *  prs     = (DAORecordset *)GetInterface();

	if (!prs)
		return;

	DAOMFC_CALL(prs->put_Collect(vIndex, *pv));
}


/*****************************************************************************
* Default collection operators
*/
inline CdbWorkspace CdbDBEngine::operator []
	(LONG lIndex)
{
return Workspaces[lIndex];
}

inline CdbWorkspace CdbDBEngine::operator []
	(LPCTSTR pstrIndex)
{
return Workspaces[pstrIndex];
}


inline CdbDatabase CdbWorkspace::operator []
	(LONG lIndex)
{
return Databases[lIndex];
}

inline CdbDatabase CdbWorkspace::operator []
	(LPCTSTR pstrIndex)
{
return Databases[pstrIndex];
}

inline CdbTableDef      CdbDatabase::operator []
	(LONG lIndex)
{
return TableDefs[lIndex];
}

inline CdbTableDef      CdbDatabase::operator []
	(LPCTSTR pstrIndex)
{
return TableDefs[pstrIndex];
}

inline CdbQueryDef      CdbConnection::operator []
	(LONG lIndex)
{
return QueryDefs[lIndex];
}

inline CdbQueryDef      CdbConnection::operator []
	(LPCTSTR pstrIndex)
{
return QueryDefs[pstrIndex];
}

inline CdbField      CdbRecordset::operator []
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField      CdbRecordset::operator []
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}



inline CdbField CdbTableDef::operator []        
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbTableDef::operator []        
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbQueryDef::operator []        
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbQueryDef::operator []        
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbIndex::operator []   
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbIndex::operator []   
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbRelation::operator []
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbRelation::operator []
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbGroup CdbUser::operator []
	(LONG lIndex)
{
return Groups[lIndex];
}

inline CdbGroup CdbUser::operator []
	(LPCTSTR pstrIndex)
{
return Groups[pstrIndex];
}

inline CdbUser CdbGroup::operator []
	(LONG lIndex)
{
return Users[lIndex];
}

inline CdbUser CdbGroup::operator []
	(LPCTSTR pstrIndex)
{
return Users[pstrIndex];
}

inline CdbDocument CdbContainer::operator []
	(LONG lIndex)
{
return Documents[lIndex];
}

inline CdbDocument CdbContainer::operator []
	(LPCTSTR pstrIndex)
{
return Documents[pstrIndex];
}

/*****************************************************************************
*  Use different DAO interface for wide (UNICODE) versions
*/

#ifdef _UNICODE

#define dbIID_IDAODBEngine IID_IDAODBEngineW
#define dbIID_IDAOError IID_IDAOErrorW
#define dbIID_IDAOErrors IID_IDAOErrorsW
#define dbIID_IDAOProperty IID_IDAOPropertyW
#define dbIID_IDAOProperties IID_IDAOPropertiesW
#define dbIID_IDAORecordset IID_IDAORecordsetW
#define dbIID_IDAORecordsets IID_IDAORecordsetsW
#define dbIID_IDAOWorkspace IID_IDAOWorkspaceW
#define dbIID_IDAOWorkspaces IID_IDAOWorkspacesW
#define dbIID_IDAOConnection IID_IDAOConnectionW
#define dbIID_IDAOConnections IID_IDAOConnectionsW
#define dbIID_IDAOTableDef IID_IDAOTableDefW
#define dbIID_IDAOTableDefs IID_IDAOTableDefsW
#define dbIID_IDAOField IID_IDAOFieldW
#define dbIID_IDAOFields IID_IDAOFieldsW
#define dbIID_IDAOIndex IID_IDAOIndexW
#define dbIID_IDAOIndexes IID_IDAOIndexesW
#define dbIID_IDAOIndexFields IID_IDAOIndexFieldsW
#define dbIID_IDAOGroup IID_IDAOGroupW
#define dbIID_IDAOGroups IID_IDAOGroupsW
#define dbIID_IDAOUser IID_IDAOUserW
#define dbIID_IDAOUsers IID_IDAOUsersW
#define dbIID_IDAODatabase IID_IDAODatabaseW
#define dbIID_IDAODatabases IID_IDAODatabasesW
#define dbIID_IDAOQueryDef IID_IDAOQueryDefW
#define dbIID_IDAOQueryDefs IID_IDAOQueryDefsW
#define dbIID_IDAOParameter IID_IDAOParameterW
#define dbIID_IDAOParameters IID_IDAOParametersW
#define dbIID_IDAORelation IID_IDAORelationW
#define dbIID_IDAORelations IID_IDAORelationsW
#define dbIID_IDAOContainer IID_IDAOContainerW
#define dbIID_IDAOContainers IID_IDAOContainersW
#define dbIID_IDAODocument IID_IDAODocumentW
#define dbIID_IDAODocuments IID_IDAODocumentsW

#else

#define dbIID_IDAODBEngine IID_IDAODBEngine
#define dbIID_IDAOError IID_IDAOError
#define dbIID_IDAOErrors IID_IDAOErrors
#define dbIID_IDAOProperty IID_IDAOProperty
#define dbIID_IDAOProperties IID_IDAOProperties
#define dbIID_IDAORecordset IID_IDAORecordset
#define dbIID_IDAORecordsets IID_IDAORecordsets
#define dbIID_IDAOWorkspace IID_IDAOWorkspace
#define dbIID_IDAOWorkspaces IID_IDAOWorkspaces
#define dbIID_IDAOConnection IID_IDAOConnection
#define dbIID_IDAOConnections IID_IDAOConnections
#define dbIID_IDAOTableDef IID_IDAOTableDef
#define dbIID_IDAOTableDefs IID_IDAOTableDefs
#define dbIID_IDAOField IID_IDAOField
#define dbIID_IDAOFields IID_IDAOFields
#define dbIID_IDAOIndex IID_IDAOIndex
#define dbIID_IDAOIndexes IID_IDAOIndexes
#define dbIID_IDAOIndexFields IID_IDAOIndexFields
#define dbIID_IDAOGroup IID_IDAOGroup
#define dbIID_IDAOGroups IID_IDAOGroups
#define dbIID_IDAOUser IID_IDAOUser
#define dbIID_IDAOUsers IID_IDAOUsers
#define dbIID_IDAODatabase IID_IDAODatabase
#define dbIID_IDAODatabases IID_IDAODatabases
#define dbIID_IDAOQueryDef IID_IDAOQueryDef
#define dbIID_IDAOQueryDefs IID_IDAOQueryDefs
#define dbIID_IDAOParameter IID_IDAOParameter
#define dbIID_IDAOParameters IID_IDAOParameters
#define dbIID_IDAORelation IID_IDAORelation
#define dbIID_IDAORelations IID_IDAORelations
#define dbIID_IDAOContainer IID_IDAOContainer
#define dbIID_IDAOContainers IID_IDAOContainers
#define dbIID_IDAODocument IID_IDAODocument
#define dbIID_IDAODocuments IID_IDAODocuments

#endif



#endif // _DBDAO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dbdaoerr.h ===
/************************************************************************
**	D B D A O E R R . H													*														*
**																		*
**		History 														*
**		------- 														*
**	5-17-95 Added to DAO SDK				 							*
**	7-17-95 Added DBDAOERR macro, removed internal only codes																	*
**	8-30-96 Added replication and ODBC direct errors																	*
**																		*
**	The following #defines map the integer to a descriptive name
**	i.e.  3270 -> E_DAO_VtoPropNotFound									*
**																		*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 					*
**		   All Rights Reserved					 						*
************************************************************************/

#ifndef _DDAOERR_H_
#define _DDAOERR_H_

#define DBDAOERR(x) MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, x)

#define E_DAO_InternalError					DBDAOERR(3000) //Reserved error (|); there is no message for this error.
#define E_DAO_InvalidParameter				DBDAOERR(3001) //Invalid argument.
#define E_DAO_CantBegin						DBDAOERR(3002) //Couldn't start session.
#define E_DAO_TransTooDeep					DBDAOERR(3003) //Couldn't start transaction; too many transactions already nested.
#define E_DAO_DatabaseNotFound				DBDAOERR(3004) //Couldn't find database '|'.
#define E_DAO_DatabaseInvalidName			DBDAOERR(3005) //'|' isn't a valid database name.
#define E_DAO_DatabaseLocked				DBDAOERR(3006) //Database '|' is exclusively locked.
#define E_DAO_DatabaseOpenError				DBDAOERR(3007) //Can't open library database '|'.
#define E_DAO_TableLocked					DBDAOERR(3008) //Table '|' is exclusively locked.
#define E_DAO_TableInUse					DBDAOERR(3009) //Couldn't lock table '|'; currently in use.
#define E_DAO_TableDuplicate				DBDAOERR(3010) //Table '|' already exists.
#define E_DAO_ObjectNotFound				DBDAOERR(3011) //Couldn't find object '|'.
#define E_DAO_ObjectDuplicate				DBDAOERR(3012) //Object '|' already exists.
#define E_DAO_CannotRename					DBDAOERR(3013) //Couldn't rename installable ISAM file.
#define E_DAO_TooManyOpenTables				DBDAOERR(3014) //Can't open any more tables.
#define E_DAO_IndexNotFound					DBDAOERR(3015) //'|' isn't an index in this table.
#define E_DAO_ColumnDoesNotFit 				DBDAOERR(3016) //Field won't fit in record.
#define E_DAO_ColumnTooBig					DBDAOERR(3017) //The size of a field is too long.
#define E_DAO_ColumnNotFound				DBDAOERR(3018) //Couldn't find field '|'.
#define E_DAO_NoCurrentIndex				DBDAOERR(3019) //Operation invalid without a current index.
#define E_DAO_RecordNoCopy					DBDAOERR(3020) //Update or CancelUpdate without AddNew or Edit.
#define E_DAO_NoCurrentRecord				DBDAOERR(3021) //No current record.
#define E_DAO_KeyDuplicate					DBDAOERR(3022) //Duplicate value in index, primary key, or relationship.  Changes were unsuccessful.
#define E_DAO_AlreadyPrepared				DBDAOERR(3023) //AddNew or Edit already used.
#define E_DAO_FileNotFound					DBDAOERR(3024) //Couldn't find file '|'.
#define E_DAO_TooManyOpenFiles				DBDAOERR(3025) //Can't open any more files.
#define E_DAO_DiskFull						DBDAOERR(3026) //Not enough space on disk.
#define E_DAO_PermissionDenied				DBDAOERR(3027) //Can't update.  Database or object is read-only.
#define E_DAO_CannotOpenSystemDb			DBDAOERR(3028) //Can't start your application. The system database is missing or opened exclusively by another user.
#define E_DAO_InvalidLogon					DBDAOERR(3029) //Not a valid account name or password.
#define E_DAO_InvalidAccountName			DBDAOERR(3030) //'|' isn't a valid account name.
#define E_DAO_InvalidPassword				DBDAOERR(3031) //Not a valid password.
#define E_DAO_InvalidOperation				DBDAOERR(3032) //Can't perform this operation.
#define E_DAO_AccessDenied					DBDAOERR(3033) //No permission for '|'.
#define E_DAO_NotInTransaction				DBDAOERR(3034) //Commit or Rollback without BeginTrans.
#define E_DAO_OutOfMemory					DBDAOERR(3035) //*
#define E_DAO_CantAllocatePage				DBDAOERR(3036) //Database has reached maximum size.
#define E_DAO_NoMoreCursors					DBDAOERR(3037) //Can't open any more tables or queries.
#define E_DAO_OutOfBuffers					DBDAOERR(3038) //*
#define E_DAO_TooManyIndexes				DBDAOERR(3039) //Couldn't create index; too many indexes already defined.
#define E_DAO_ReadVerifyFailure				DBDAOERR(3040) //Disk I/O error during read.
#define E_DAO_FilesysVersion				DBDAOERR(3041) //Can't open a database created with a previous version of your application.
#define E_DAO_NoMoreFiles					DBDAOERR(3042) //Out of MS-DOS file handles.
#define E_DAO_DiskError						DBDAOERR(3043) //Disk or network error.
#define E_DAO_InvalidPath					DBDAOERR(3044) //'|' isn't a valid path.
#define E_DAO_FileShareViolation			DBDAOERR(3045) //Couldn't use '|'; file already in use.
#define E_DAO_FileLockViolation				DBDAOERR(3046) //Couldn't save; currently locked by another user.
#define E_DAO_RecordTooBig					DBDAOERR(3047) //Record is too large.
#define E_DAO_TooManyOpenDatabases			DBDAOERR(3048) //Can't open any more databases.
#define E_DAO_InvalidDatabase				DBDAOERR(3049) //Can't open database '|'.  It may not be a database that your application recognizes, or the file may be corrupt.
#define E_DAO_FileLockingUnavailable		DBDAOERR(3050) //Couldn't lock file.
#define E_DAO_FileAccessDenied				DBDAOERR(3051) //Couldn't open file '|'.
#define E_DAO_SharingBufferExceeded			DBDAOERR(3052) //MS-DOS file sharing lock count exceeded.  You need to increase the number of locks installed with SHARE.EXE.
#define E_DAO_TaskLimitExceeded				DBDAOERR(3053) //Too many client tasks.
#define E_DAO_TooManyLongColumns			DBDAOERR(3054) //Too many Memo or OLE object fields.
#define E_DAO_InvalidFilename				DBDAOERR(3055) //Not a valid file name.
#define E_DAO_AbortSalvage					DBDAOERR(3056) //Couldn't repair this database.
#define E_DAO_LinkNotSupported				DBDAOERR(3057) //Operation not supported on attached, or linked, tables.
#define E_DAO_NullKeyDisallowed				DBDAOERR(3058) //Index or primary key can't contain a null value.
#define E_DAO_OperationCanceled				DBDAOERR(3059) //Operation canceled by user.
#define E_DAO_QueryParmTypeMismatch			DBDAOERR(3060) //Wrong data type for parameter '|'.
#define E_DAO_QueryMissingParmsM			DBDAOERR(3061) //Too few parameters. Expected |.
#define E_DAO_QueryDuplicateAliasM			DBDAOERR(3062) //Duplicate output alias '|'.
#define E_DAO_QueryDuplicateOutputM			DBDAOERR(3063) //Duplicate output destination '|'.
#define E_DAO_QueryIsBulkOp					DBDAOERR(3064) //Can't open action query '|'.
#define E_DAO_QueryIsNotBulkOp				DBDAOERR(3065) //Can't execute a non-action query.
#define E_DAO_QueryNoOutputsM				DBDAOERR(3066) //Query or table must contain at least one output field.
#define E_DAO_QueryNoInputTablesM			DBDAOERR(3067) //Query input must contain at least one table or query.
#define E_DAO_QueryInvalidAlias				DBDAOERR(3068) //Not a valid alias name.
#define E_DAO_QueryInvalidBulkInputM		DBDAOERR(3069) //The action query '|' cannot be used as a row source.
#define E_DAO_QueryUnboundRef				DBDAOERR(3070) //Can't bind name '|'.
#define E_DAO_QueryExprEvaluation			DBDAOERR(3071) //Can't evaluate expression.
#define E_DAO_EvalEBESErr					DBDAOERR(3072) //|
#define E_DAO_QueryNotUpdatable				DBDAOERR(3073) //Operation must use an updatable query.
#define E_DAO_TableRepeatInFromList			DBDAOERR(3074) //Can't repeat table name '|' in FROM clause.
#define E_DAO_QueryExprSyntax				DBDAOERR(3075) //|1 in query expression '|2'.
#define E_DAO_QbeExprSyntax					DBDAOERR(3076) //| in criteria expression.
#define E_DAO_FindExprSyntax				DBDAOERR(3077) //| in expression.
#define E_DAO_InputTableNotFound			DBDAOERR(3078) //Couldn't find input table or query '|'.
#define E_DAO_QueryAmbigRefM				DBDAOERR(3079) //Ambiguous field reference '|'.
#define E_DAO_JoinTableNotInput				DBDAOERR(3080) //Joined table '|' not listed in FROM clause.
#define E_DAO_UnaliasedSelfJoin				DBDAOERR(3081) //Can't join more than one table with the same name (|).
#define E_DAO_ColumnNotInJoinTable			DBDAOERR(3082) //JOIN operation '|' refers to a non-joined table.
#define E_DAO_QueryIsMGB					DBDAOERR(3083) //Can't use internal report query.
#define E_DAO_QueryInsIntoBulkMGB			DBDAOERR(3084) //Can't insert data with action query.
#define E_DAO_ExprUnknownFunctionM			DBDAOERR(3085) //Undefined function '|' in expression.
#define E_DAO_QueryCannotDelete				DBDAOERR(3086) //Couldn't delete from specified tables.
#define E_DAO_QueryTooManyGroupExprs		DBDAOERR(3087) //Too many expressions in GROUP BY clause.
#define E_DAO_QueryTooManyOrderExprs		DBDAOERR(3088) //Too many expressions in ORDER BY clause.
#define E_DAO_QueryTooManyDistExprs			DBDAOERR(3089) //Too many expressions in DISTINCT output.
#define E_DAO_Column2ndSysMaint				DBDAOERR(3090) //Resultant table not allowed to have more than one Counter or Autonumber field.
#define E_DAO_HavingWOGrouping				DBDAOERR(3091) //HAVING clause (|) without grouping or aggregation.
#define E_DAO_HavingOnTransform				DBDAOERR(3092) //Can't use HAVING clause in TRANSFORM statement.
#define E_DAO_OrderVsDistinct				DBDAOERR(3093) //ORDER BY clause (|) conflicts with DISTINCT.
#define E_DAO_OrderVsGroup					DBDAOERR(3094) //ORDER BY clause (|) conflicts with GROUP BY clause.
#define E_DAO_AggregateInArgument			DBDAOERR(3095) //Can't have aggregate function in expression (|).
#define E_DAO_AggregateInWhere				DBDAOERR(3096) //Can't have aggregate function in WHERE clause (|).
#define E_DAO_AggregateInOrderBy			DBDAOERR(3097) //Can't have aggregate function in ORDER BY clause (|).
#define E_DAO_AggregateInGroupBy			DBDAOERR(3098) //Can't have aggregate function in GROUP BY clause (|).
#define E_DAO_AggregateInJoin				DBDAOERR(3099) //Can't have aggregate function in JOIN operation (|).
#define E_DAO_NullInJoinKey					DBDAOERR(3100) //Can't set field '|' in join key to Null.
#define E_DAO_ValueBreaksJoin				DBDAOERR(3101) //There is no record in table '|2' with key matching field(s) '|1'.
#define E_DAO_QueryTreeCycle				DBDAOERR(3102) //Circular reference caused by '|'.
#define E_DAO_OutputAliasCycle				DBDAOERR(3103) //Circular reference caused by alias '|' in query definition's SELECT list.
#define E_DAO_QryDuplicatedFixedSetM		DBDAOERR(3104) //Can't specify Fixed Column Heading '|' in a crosstab query more than once.
#define E_DAO_NoSelectIntoColumnName		DBDAOERR(3105) //Missing destination field name in SELECT INTO statement (|).
#define E_DAO_NoUpdateColumnName			DBDAOERR(3106) //Missing destination field name in UPDATE statement (|).
#define E_DAO_QueryNoInsertPerm				DBDAOERR(3107) //Record(s) can't be added; no Insert Data permission on '|'.
#define E_DAO_QueryNoReplacePerm			DBDAOERR(3108) //Record(s) can't be edited; no Update Data permission on '|'.
#define E_DAO_QueryNoDeletePerm				DBDAOERR(3109) //Record(s) can't be deleted; no Delete Data permission on '|'.
#define E_DAO_QueryNoReadDefPerm			DBDAOERR(3110) //Couldn't read definitions; no Read Design permission for table or query '|'.
#define E_DAO_QueryNoTblCrtPerm				DBDAOERR(3111) //Couldn't create; no Create permission for table or query '|'.
#define E_DAO_QueryNoReadPerm				DBDAOERR(3112) //Record(s) can't be read; no Read Data permission on '|'.
#define E_DAO_QueryColNotUpd				DBDAOERR(3113) //Can't update '|'; field not updatable.
#define E_DAO_QueryLVInDistinct				DBDAOERR(3114) //Can't include Memo or OLE object when you select unique values (|).
#define E_DAO_QueryLVInAggregate			DBDAOERR(3115) //Can't have Memo or OLE object in aggregate argument (|).
#define E_DAO_QueryLVInHaving				DBDAOERR(3116) //Can't have Memo or OLE object in criteria (|) for aggregate function.
#define E_DAO_QueryLVInOrderBy				DBDAOERR(3117) //Can't sort on Memo or OLE object (|).
#define E_DAO_QueryLVInJoin					DBDAOERR(3118) //Can't join on Memo or OLE object (|).
#define E_DAO_QueryLVInGroupBy				DBDAOERR(3119) //Can't group on Memo or OLE object (|).
#define E_DAO_DotStarWithGrouping			DBDAOERR(3120) //Can't group on fields selected with '*' (|).
#define E_DAO_StarWithGrouping				DBDAOERR(3121) //Can't group on fields selected with '*'.
#define E_DAO_IllegalDetailRef				DBDAOERR(3122) //'|' not part of aggregate function or grouping.
#define E_DAO_StarNotAtLevel0				DBDAOERR(3123) //Can't use '*' in crosstab query.
#define E_DAO_QueryInvalidMGBInput			DBDAOERR(3124) //Can't input from internal report query (|).
#define E_DAO_InvalidName					DBDAOERR(3125) //'|' isn't a valid name.
#define E_DAO_QueryBadBracketing			DBDAOERR(3126) //Invalid bracketing of name '|'.
#define E_DAO_InsertIntoUnknownCol			DBDAOERR(3127) //INSERT INTO statement contains unknown field name '|'.
#define E_DAO_QueryNoDeleteTables			DBDAOERR(3128) //Must specify tables to delete from.
#define E_DAO_SQLSyntax						DBDAOERR(3129) //Invalid SQL statement; expected 'DELETE', 'INSERT', 'PROCEDURE', 'SELECT', or 'UPDATE'.
#define E_DAO_SQLDeleteSyntax				DBDAOERR(3130) //Syntax error in DELETE statement.
#define E_DAO_SQLFromSyntax					DBDAOERR(3131) //Syntax error in FROM clause.
#define E_DAO_SQLGroupBySyntax				DBDAOERR(3132) //Syntax error in GROUP BY clause.
#define E_DAO_SQLHavingSyntax				DBDAOERR(3133) //Syntax error in HAVING clause.
#define E_DAO_SQLInsertSyntax				DBDAOERR(3134) //Syntax error in INSERT statement.
#define E_DAO_SQLJoinSyntax					DBDAOERR(3135) //Syntax error in JOIN operation.
#define E_DAO_SQLLevelSyntax				DBDAOERR(3136) //Syntax error in LEVEL clause.
#define E_DAO_SQLMissingSemicolon			DBDAOERR(3137) //Missing semicolon (;) at end of SQL statement.
#define E_DAO_SQLOrderBySyntax				DBDAOERR(3138) //Syntax error in ORDER BY clause.
#define E_DAO_SQLParameterSyntax			DBDAOERR(3139) //Syntax error in PARAMETER clause.
#define E_DAO_SQLProcedureSyntax			DBDAOERR(3140) //Syntax error in PROCEDURE clause.
#define E_DAO_SQLSelectSyntax				DBDAOERR(3141) //Syntax error in SELECT statement.
#define E_DAO_SQLTooManyTokens				DBDAOERR(3142) //Characters found after end of SQL statement.
#define E_DAO_SQLTransformSyntax			DBDAOERR(3143) //Syntax error in TRANSFORM statement.
#define E_DAO_SQLUpdateSyntax				DBDAOERR(3144) //Syntax error in UPDATE statement.
#define E_DAO_SQLWhereSyntax				DBDAOERR(3145) //Syntax error in WHERE clause.
#define E_DAO_RmtSQLCError					DBDAOERR(3146) //ODBC--call failed.
#define E_DAO_RmtDataOverflow				DBDAOERR(3147) //*
#define E_DAO_RmtConnectFailed				DBDAOERR(3148) //*
#define E_DAO_RmtIncorrectSqlcDll			DBDAOERR(3149) //*
#define E_DAO_RmtMissingSqlcDll				DBDAOERR(3150) //*
#define E_DAO_RmtConnectFailedM				DBDAOERR(3151) //ODBC--connection to '|' failed.
#define E_DAO_RmtDrvrVer					DBDAOERR(3152) //*
#define E_DAO_RmtSrvrVer					DBDAOERR(3153) //*
#define E_DAO_RmtMissingOdbcDll				DBDAOERR(3154) //ODBC--couldn't find DLL '|'.
#define E_DAO_RmtInsertFailedM				DBDAOERR(3155) //ODBC--insert failed on attached (linked) table '|'.
#define E_DAO_RmtDeleteFailedM				DBDAOERR(3156) //ODBC--delete failed on attached (linked) table '|'.
#define E_DAO_RmtUpdateFailedM				DBDAOERR(3157) //ODBC--update failed on attached (linked) table '|'.
#define E_DAO_RecordLocked					DBDAOERR(3158) //Couldn't save record; currently locked by another user.
#define E_DAO_InvalidBookmark				DBDAOERR(3159) //Not a valid bookmark.
#define E_DAO_TableNotOpen					DBDAOERR(3160) //Table isn't open.
#define E_DAO_DecryptFail					DBDAOERR(3161) //Couldn't decrypt file.
#define E_DAO_NullInvalid					DBDAOERR(3162) //Null is invalid.
#define E_DAO_InvalidBufferSize				DBDAOERR(3163) //Couldn't perform operation; data too long for field.
#define E_DAO_ColumnNotUpdatable			DBDAOERR(3164) //Field can't be updated.
#define E_DAO_CantMakeINFFile				DBDAOERR(3165) //Couldn't open .INF file.
#define E_DAO_MissingMemoFile				DBDAOERR(3166) //Missing memo file.
#define E_DAO_RecordDeleted					DBDAOERR(3167) //Record is deleted.
#define E_DAO_INFFileError					DBDAOERR(3168) //Invalid .INF file.
#define E_DAO_ExprIllegalType				DBDAOERR(3169) //Illegal type in expression.
#define E_DAO_InstalIsamNotFound			DBDAOERR(3170) //Couldn't find installable ISAM.
#define E_DAO_NoConfigParameters			DBDAOERR(3171) //Couldn't find net path or user name.
#define E_DAO_CantAccessPdoxNetDir			DBDAOERR(3172) //Couldn't open PARADOX.NET.
#define E_DAO_NoMSysAccounts				DBDAOERR(3173) //Couldn't open table 'MSysAccounts' in the system database file.
#define E_DAO_NoMSysGroups					DBDAOERR(3174) //Couldn't open table 'MSysGroups' in the system database file.
#define E_DAO_DateOutOfRange				DBDAOERR(3175) //Date is out of range or is in an invalid format.
#define E_DAO_ImexCantOpenFile				DBDAOERR(3176) //Couldn't open file '|'.
#define E_DAO_ImexBadTableName				DBDAOERR(3177) //Not a valid table name.
#define E_DAO_ImexOutOfMemory				DBDAOERR(3178) //*
#define E_DAO_ImexEndofFile					DBDAOERR(3179) //Encountered unexpected end of file.
#define E_DAO_ImexCantWriteToFile			DBDAOERR(3180) //Couldn't write to file '|'.
#define E_DAO_ImexBadRange					DBDAOERR(3181) //Invalid range.
#define E_DAO_ImexBogusFile					DBDAOERR(3182) //Invalid file format.
#define E_DAO_TempDiskFull					DBDAOERR(3183) //Not enough space on temporary disk.
#define E_DAO_RmtLinkNotFound				DBDAOERR(3184) //Couldn't execute query; couldn't find attached, or linked, table.
#define E_DAO_RmtTooManyColumns				DBDAOERR(3185) //SELECT INTO remote database tried to produce too many fields.
#define E_DAO_ReadConflictM					DBDAOERR(3186) //Couldn't save; currently locked by user '|2' on machine '|1'.
#define E_DAO_CommitConflictM				DBDAOERR(3187) //Couldn't read; currently locked by user '|2' on machine '|1'.
#define E_DAO_SessionWriteConflict			DBDAOERR(3188) //Couldn't update; currently locked by another session on this machine.
#define E_DAO_JetSpecialTableLocked			DBDAOERR(3189) //Table '|1' is exclusively locked by user '|3' on machine '|2'.
#define E_DAO_TooManyColumns				DBDAOERR(3190) //Too many fields defined.
#define E_DAO_ColumnDuplicate				DBDAOERR(3191) //Can't define field more than once.
#define E_DAO_OutputTableNotFound			DBDAOERR(3192) //Couldn't find output table '|'.
#define E_DAO_JetNoUserName					DBDAOERR(3193) //(unknown)
#define E_DAO_JetNoMachineName				DBDAOERR(3194) //(unknown)
#define E_DAO_JetNoColumnName				DBDAOERR(3195) //(expression)
#define E_DAO_DatabaseInUse					DBDAOERR(3196) //Couldn't use '|'; database already in use.
#define E_DAO_DataHasChanged				DBDAOERR(3197) //Data has changed; operation stopped.
#define E_DAO_TooManySessions				DBDAOERR(3198) //Couldn't start session.  Too many sessions already active.
#define E_DAO_ReferenceNotFound				DBDAOERR(3199) //Couldn't find reference.
#define E_DAO_IntegrityViolMasterM			DBDAOERR(3200) //Can't delete or change record.  Since related records exist in table '|', referential integrity rules would be violated.
#define E_DAO_IntegrityViolSlaveM			DBDAOERR(3201) //Can't add or change record.  Referential integrity rules require a related record in table '|'.
#define E_DAO_ReadConflict					DBDAOERR(3202) //Couldn't save; currently locked by another user.
#define E_DAO_AggregatingHigherLevel		DBDAOERR(3203) //Can't specify subquery in expression (|).
#define E_DAO_DatabaseDuplicate				DBDAOERR(3204) //Database already exists.
#define E_DAO_QueryTooManyXvtColumn			DBDAOERR(3205) //Too many crosstab column headers (|).
#define E_DAO_SelfReference					DBDAOERR(3206) //Can't create a relationship between a field and itself.
#define E_DAO_CantUseUnkeyedTable			DBDAOERR(3207) //Operation not supported on Paradox table with no primary key.
#define E_DAO_IllegalDeletedOption			DBDAOERR(3208) //Invalid Deleted entry in the Xbase section of initialization setting.
#define E_DAO_IllegalStatsOption			DBDAOERR(3209) //Invalid Stats entry in the Xbase section of initialization setting.
#define E_DAO_ConnStrTooLong				DBDAOERR(3210) //Connection string too long.
#define E_DAO_TableInUseQM					DBDAOERR(3211) //Couldn't lock table '|'; currently in use.
#define E_DAO_JetSpecialTableInUse			DBDAOERR(3212) //Couldn't lock table '|1'; currently in use by user '|3' on machine '|2'.
#define E_DAO_IllegalDateOption				DBDAOERR(3213) //Invalid Date entry in the Xbase section of initialization setting.
#define E_DAO_IllegalMarkOption				DBDAOERR(3214) //Invalid Mark entry in the Xbase section of initialization setting.
#define E_DAO_BtrieveTooManyTasks			DBDAOERR(3215) //Too many Btrieve tasks.
#define E_DAO_QueryParmNotTableid			DBDAOERR(3216) //Parameter '|' specified where a table name is required.
#define E_DAO_QueryParmNotDatabase			DBDAOERR(3217) //Parameter '|' specified where a database name is required.
#define E_DAO_WriteConflict					DBDAOERR(3218) //Couldn't update; currently locked.
#define E_DAO_IllegalOperation				DBDAOERR(3219) //Invalid operation.
#define E_DAO_WrongCollatingSequence		DBDAOERR(3220) //Incorrect collating sequence.
#define E_DAO_BadConfigParameters			DBDAOERR(3221) //Invalid entries in the Btrieve section of initialization setting.
#define E_DAO_QueryContainsDbParm			DBDAOERR(3222) //Query can't contain a Database parameter.
#define E_DAO_QueryInvalidParmM				DBDAOERR(3223) //'|' isn't a valid parameter name.
#define E_DAO_BtrieveDDCorrupted			DBDAOERR(3224) //Can't read Btrieve data dictionary.
#define E_DAO_BtrieveDeadlock				DBDAOERR(3225) //Encountered record locking deadlock while performing Btrieve operation.
#define E_DAO_BtrieveFailure				DBDAOERR(3226) //Errors encountered while using the Btrieve DLL.
#define E_DAO_IllegalCenturyOption			DBDAOERR(3227) //Invalid Century entry in the Xbase section of initialization setting.
#define E_DAO_IllegalCollatingSeq			DBDAOERR(3228) //Invalid Collating Sequence.
#define E_DAO_NonModifiableKey				DBDAOERR(3229) //Btrieve--can't change field.
#define E_DAO_ObsoleteLockFile				DBDAOERR(3230) //Out-of-date Paradox lock file.
#define E_DAO_RmtColDataTruncated			DBDAOERR(3231) //ODBC--field would be too long; data truncated.
#define E_DAO_RmtCreateTableFailed			DBDAOERR(3232) //ODBC--couldn't create table.
#define E_DAO_RmtOdbcVer					DBDAOERR(3233) //*
#define E_DAO_RmtQueryTimeout				DBDAOERR(3234) //ODBC--remote query timeout expired.
#define E_DAO_RmtTypeIncompat				DBDAOERR(3235) //ODBC--data type not supported on server.
#define E_DAO_RmtUnexpectedNull				DBDAOERR(3236) //*
#define E_DAO_RmtUnexpectedType				DBDAOERR(3237) //*
#define E_DAO_RmtValueOutOfRange			DBDAOERR(3238) //ODBC--data out of range.
#define E_DAO_TooManyActiveUsers			DBDAOERR(3239) //Too many active users.
#define E_DAO_CantStartBtrieve				DBDAOERR(3240) //Btrieve--missing Btrieve engine.
#define E_DAO_OutOfBVResources				DBDAOERR(3241) //Btrieve--out of resources.
#define E_DAO_QueryBadUpwardRefedM			DBDAOERR(3242) //Invalid reference in SELECT statement.
#define E_DAO_ImexNoMatchingColumns			DBDAOERR(3243) //None of the import field names match fields in the appended table.
#define E_DAO_ImexPasswordProtected			DBDAOERR(3244) //Can't import password-protected spreadsheet.
#define E_DAO_ImexUnparsableRecord			DBDAOERR(3245) //Couldn't parse field names from first row of import table.
#define E_DAO_InTransaction					DBDAOERR(3246) //Operation not supported in transactions.
#define E_DAO_RmtLinkOutOfSync				DBDAOERR(3247) //ODBC--linked table definition has changed.
#define E_DAO_IllegalNetworkOption			DBDAOERR(3248) //Invalid NetworkAccess entry in initialization setting.
#define E_DAO_IllegalTimeoutOption			DBDAOERR(3249) //Invalid PageTimeout entry in initialization setting.
#define E_DAO_CantBuildKey					DBDAOERR(3250) //Couldn't build key.
#define E_DAO_FeatureNotAvailable			DBDAOERR(3251) //Operation is not supported for this type of object.
#define E_DAO_IllegalReentrancy				DBDAOERR(3252) //Can't open form whose underlying query contains a user-defined function that attempts to set or get the form's RecordsetClone property.
#define E_DAO_UNUSED						DBDAOERR(3253) //*
#define E_DAO_RmtDenyWriteIsInvalid			DBDAOERR(3254) //ODBC--Can't lock all records.
#define E_DAO_ODBCParmsChanged				DBDAOERR(3255) //*
#define E_DAO_INFIndexNotFound 				DBDAOERR(3256) //Index file not found.
#define E_DAO_SQLOwnerAccessSyntax			DBDAOERR(3257) //Syntax error in WITH OWNERACCESS OPTION declaration.
#define E_DAO_QueryAmbiguousJoins			DBDAOERR(3258) //Query contains ambiguous outer joins.
#define E_DAO_InvalidColumnType				DBDAOERR(3259) //Invalid field data type.
#define E_DAO_WriteConflictM				DBDAOERR(3260) //Couldn't update; currently locked by user '|2' on machine '|1'.
#define E_DAO_TableLockedM					DBDAOERR(3261) //|
#define E_DAO_TableInUseMUQM				DBDAOERR(3262) //|
#define E_DAO_InvalidTableId				DBDAOERR(3263) //Invalid database object.
#define E_DAO_VtoNoFields					DBDAOERR(3264) //No fields defined - cannot append Tabledef or Index.
#define E_DAO_VtoNameNotFound				DBDAOERR(3265) //Item not found in this collection.
#define E_DAO_VtoFieldInCollection			DBDAOERR(3266) //Can't append.  Field is part of a TableDefs collection.
#define E_DAO_VtoNotARecordset				DBDAOERR(3267) //Property can be set only when the field is part of a Recordset object's Fields collection.
#define E_DAO_VtoNoSetObjInDb				DBDAOERR(3268) //Can't set this property once the object is part of a collection.
#define E_DAO_VtoIndexInCollection			DBDAOERR(3269) //Can't append.  Index is part of a TableDefs collection.
#define E_DAO_VtoPropNotFound				DBDAOERR(3270) //Property not found.
#define E_DAO_VtoIllegalValue				DBDAOERR(3271) //Invalid property value.
#define E_DAO_VtoNotArray					DBDAOERR(3272) //Object isn't a collection.
#define E_DAO_VtoNoSuchMethod				DBDAOERR(3273) //Method not applicable for this object.
#define E_DAO_NotExternalFormat				DBDAOERR(3274) //External table isn't in the expected format.
#define E_DAO_UnexpectedEngineReturn		DBDAOERR(3275) //Unexpected error from external database driver (|).
#define E_DAO_InvalidDatabaseId				DBDAOERR(3276) //Invalid database ID.
#define E_DAO_TooManyKeys					DBDAOERR(3277) //Can't have more than 10 fields in an index.
#define E_DAO_NotInitialized				DBDAOERR(3278) //Database engine hasn't been initialized.
#define E_DAO_AlreadyInitialized			DBDAOERR(3279) //Database engine has already been initialized.
#define E_DAO_ColumnInUse					DBDAOERR(3280) //Can't delete a field that is part of an index or is needed by the system.
#define E_DAO_IndexInUse					DBDAOERR(3281) //Can't delete this index.  It is either the current index or is used in a relationship.
#define E_DAO_TableNotEmpty					DBDAOERR(3282) //Can't create field or index in a table that is already defined.
#define E_DAO_IndexHasPrimary				DBDAOERR(3283) //Primary key already exists.
#define E_DAO_IndexDuplicate				DBDAOERR(3284) //Index already exists.
#define E_DAO_IndexInvalidDef				DBDAOERR(3285) //Invalid index definition.
#define E_DAO_WrongMemoFileType				DBDAOERR(3286) //Format of memo file doesn't match specified external database format.
#define E_DAO_ColumnCannotIndex				DBDAOERR(3287) //Can't create index on the given field.
#define E_DAO_IndexHasNoPrimary				DBDAOERR(3288) //Paradox index is not primary.
#define E_DAO_DDLConstraintSyntax			DBDAOERR(3289) //Syntax error in CONSTRAINT clause.
#define E_DAO_DDLCreateTableSyntax			DBDAOERR(3290) //Syntax error in CREATE TABLE statement.
#define E_DAO_DDLCreateIndexSyntax			DBDAOERR(3291) //Syntax error in CREATE INDEX statement.
#define E_DAO_DDLColumnDefSyntax			DBDAOERR(3292) //Syntax error in field definition.
#define E_DAO_DDLAlterTableSyntax			DBDAOERR(3293) //Syntax error in ALTER TABLE statement.
#define E_DAO_DDLDropIndexSyntax			DBDAOERR(3294) //Syntax error in DROP INDEX statement.
#define E_DAO_DDLDropSyntax					DBDAOERR(3295) //Syntax error in DROP TABLE or DROP INDEX.
#define E_DAO_V11NotSupported				DBDAOERR(3296) //Join expression not supported.
#define E_DAO_ImexNothingToImport			DBDAOERR(3297) //Couldn't import table or query.  No records found, or all records contain errors.
#define E_DAO_RmtTableAmbiguous				DBDAOERR(3298) //There are several tables with that name.  Please specify owner in the format 'owner.table'.
#define E_DAO_JetODBCConformanceError		DBDAOERR(3299) //ODBC Specification Conformance Error (|).  This error should be reported to the ODBC driver vendor.
#define E_DAO_IllegalRelationship			DBDAOERR(3300) //Can't create a relationship.
#define E_DAO_DBVerFeatureNotAvailable		DBDAOERR(3301) //Can't perform this operation; features in this version are not available in databases with older formats.
#define E_DAO_RulesLoaded					DBDAOERR(3302) //Can't change a rule while the rules for this table are in use.
#define E_DAO_ColumnInRelationship			DBDAOERR(3303) //Can't delete this field.  It's part of one or more relationships.
#define E_DAO_InvalidPin					DBDAOERR(3304) //You must enter a personal identifier (PID) consisting of at least four and no more than 20 characters and digits.
#define E_DAO_RmtBogusConnStr				DBDAOERR(3305) //Invalid connection string in pass-through query.
#define E_DAO_SingleColumnExpected			DBDAOERR(3306) //At most one field can be returned from a subquery that doesn't use the EXISTS keyword.
#define E_DAO_ColumnCountMismatch			DBDAOERR(3307) //The number of columns in the two selected tables or queries of a union query don't match.
#define E_DAO_InvalidTopArgumentM			DBDAOERR(3308) //Invalid TOP argument in select query.
#define E_DAO_PropertyTooLarge				DBDAOERR(3309) //Property setting can't be larger than 2 KB.
#define E_DAO_JPMInvalidForV1x				DBDAOERR(3310) //This property isn't supported for external data sources or for databases created in a previous version.
#define E_DAO_PropertyExists				DBDAOERR(3311) //Property specified already exists.
#define E_DAO_TLVNativeUserTablesOnly		DBDAOERR(3312) //Validation rules and default values can't be placed on system or attached (linked) tables.
#define E_DAO_TLVInvalidColumn				DBDAOERR(3313) //Can't place this validation expression on this field.
#define E_DAO_TLVNoNullM					DBDAOERR(3314) //Field '|' can't contain a null value.
#define E_DAO_TLVNoBlankM					DBDAOERR(3315) //Field '|' can't be a zero-length string.
#define E_DAO_TLVRuleViolationM				DBDAOERR(3316) //|
#define E_DAO_TLVRuleVioNoMessage			DBDAOERR(3317) //One or more values entered is prohibited by the validation rule '|2' set for '|1'.
#define E_DAO_QueryTopNotAllowedM			DBDAOERR(3318) //Top not allowed in delete queries.
#define E_DAO_SQLUnionSyntax				DBDAOERR(3319) //Syntax error in union query.
#define E_DAO_TLVExprSyntaxM				DBDAOERR(3320) //| in table-level validation expression.
#define E_DAO_NoDbInConnStr					DBDAOERR(3321) //No database specified in connection string or IN clause.
#define E_DAO_QueryBadValueListM			DBDAOERR(3322) //Crosstab query contains one or more invalid fixed column headings.
#define E_DAO_QueryIsNotRowReturning		DBDAOERR(3323) //The query can not be used as a row source.
#define E_DAO_QueryIsDDL					DBDAOERR(3324) //This query is a DDL query and cannot be used as a row source.
#define E_DAO_SPTReturnedNoRecords			DBDAOERR(3325) //Pass-through query with ReturnsRecords property set to True did not return any records.
#define E_DAO_QueryIsSnapshot				DBDAOERR(3326) //This Recordset is not updatable.
#define E_DAO_QueryExprOutput				DBDAOERR(3327) //Field '|' is based on an expression and can't be edited.
#define E_DAO_QueryTableRO					DBDAOERR(3328) //Table '|2' is read-only.
#define E_DAO_QueryRowDeleted				DBDAOERR(3329) //Record in table '|' was deleted by another user.
#define E_DAO_QueryRowLocked				DBDAOERR(3330) //Record in table '|' is locked by another user.
#define E_DAO_QueryFixupChanged				DBDAOERR(3331) //To make changes to this field, first save the record.
#define E_DAO_QueryCantFillIn				DBDAOERR(3332) //Can't enter value into blank field on 'one' side of outer join.
#define E_DAO_QueryWouldOrphan				DBDAOERR(3333) //Records in table '|' would have no record on the 'one' side.
#define E_DAO_V10Format						DBDAOERR(3334) //Can be present only in version 1.0 format.
#define E_DAO_InvalidDelete					DBDAOERR(3335) //DeleteOnly called with non-zero cbData.
#define E_DAO_IllegalIndexDDFOption			DBDAOERR(3336) //Btrieve: Invalid IndexDDF option in initialization setting.
#define E_DAO_IllegalDataCodePage			DBDAOERR(3337) //Invalid DataCodePage option in initialization setting.
#define E_DAO_XtrieveEnvironmentError		DBDAOERR(3338) //Btrieve: Xtrieve options aren't correct in initialization setting.
#define E_DAO_IllegalIndexNumberOption		DBDAOERR(3339) //Btrieve: Invalid IndexDeleteRenumber option in initialization setting.
#define E_DAO_QueryIsCorruptM				DBDAOERR(3340) //Query '|' is corrupt.
#define E_DAO_IncorrectJoinKeyM				DBDAOERR(3341) //Current field must match join key '|' on 'one' side of outer join because it has been updated.
#define E_DAO_QueryLVInSubqueryM			DBDAOERR(3342) //Invalid Memo or OLE object in subquery '|'.
#define E_DAO_InvalidDatabaseM				DBDAOERR(3343) //Unrecognized database format '|'.
#define E_DAO_TLVCouldNotBindRef			DBDAOERR(3344) //Unknown or invalid reference '|1' in validation expression or default value in table '|2'.
#define E_DAO_CouldNotBindRef				DBDAOERR(3345) //Unknown or invalid field reference '|'.
#define E_DAO_QueryWrongNumDestCol			DBDAOERR(3346) //Number of query values and destination fields aren't the same.
#define E_DAO_QueryPKeyNotOutput			DBDAOERR(3347) //Can't add record(s); primary key for table '|' not in recordset.
#define E_DAO_QueryJKeyNotOutput			DBDAOERR(3348) //Can't add record(s); join key of table '|' not in recordset.
#define E_DAO_NumericFieldOverflow			DBDAOERR(3349) //Numeric field overflow.
#define E_DAO_InvalidObject					DBDAOERR(3350) //Object is invalid for operation.
#define E_DAO_OrderVsUnion					DBDAOERR(3351) //ORDER BY expression (|) uses non-output fields.
#define E_DAO_NoInsertColumnNameM			DBDAOERR(3352) //No destination field name in INSERT INTO statement (|).
#define E_DAO_MissingDDFFile				DBDAOERR(3353) //Btrieve: Can't find file FIELD.DDF.
#define E_DAO_SingleRecordExpected			DBDAOERR(3354) //At most one record can be returned by this subquery.
#define E_DAO_DefaultExprSyntax				DBDAOERR(3355) //Syntax error in default value.
#define E_DAO_ExclusiveDBConflict			DBDAOERR(3356) //The database is opened by user '|2' on machine '|1'.
#define E_DAO_QueryIsNotDDL					DBDAOERR(3357) //This query is not a properly formed data-definition query.
#define E_DAO_SysDatabaseOpenError			DBDAOERR(3358) //Can't open Microsoft Jet engine system database.
#define E_DAO_SQLInvalidSPT					DBDAOERR(3359) //Pass-through query must contain at least one character.
#define E_DAO_QueryTooComplex				DBDAOERR(3360) //Query is too complex.
#define E_DAO_SetOpInvalidInSubquery		DBDAOERR(3361) //Unions not allowed in a subquery.
#define E_DAO_RmtMultiRowUpdate				DBDAOERR(3362) //Single-row update/delete affected more than one row of an attached (linked) table.  Unique index contains duplicate values.
#define E_DAO_QueryNoJoinedRecord			DBDAOERR(3363) //Record(s) can't be added; no corresponding record on the 'one' side.
#define E_DAO_QueryLVInSetOp				DBDAOERR(3364) //Can't use Memo or OLE object field '|' in SELECT clause of a union query.
#define E_DAO_VtoInvalidOnRemote			DBDAOERR(3365) //Property value not valid for REMOTE objects.
#define E_DAO_VtoNoFieldsRel				DBDAOERR(3366) //Can't append a relation with no fields defined.
#define E_DAO_VtoObjectInCollection			DBDAOERR(3367) //Can't append.  Object already in collection.
#define E_DAO_DDLDiffNumRelCols				DBDAOERR(3368) //Relationship must be on the same number of fields with the same data types.
#define E_DAO_DDLIndexColNotFound			DBDAOERR(3369) //Can't find field in index definition.
#define E_DAO_DDLPermissionDenied			DBDAOERR(3370) //Can't modify the design of table '|'.  It's in a read-only database.
#define E_DAO_DDLObjectNotFound				DBDAOERR(3371) //Can't find table or constraint.
#define E_DAO_DDLIndexNotFound				DBDAOERR(3372) //No such index '|2' on table '|1'.
#define E_DAO_DDLNoPkeyOnRefdTable			DBDAOERR(3373) //Can't create relationship.  Referenced table '|' doesn't have a primary key.
#define E_DAO_DDLColumnsNotUnique			DBDAOERR(3374) //The specified fields are not uniquely indexed in table '|'.
#define E_DAO_DDLIndexDuplicate				DBDAOERR(3375) //Table '|1' already has an index named '|2'
#define E_DAO_DDLTableNotFound				DBDAOERR(3376) //Table '|' doesn't exist.
#define E_DAO_DDLRelNotFound				DBDAOERR(3377) //No such relationship '|2' on table '|1'.
#define E_DAO_DDLRelDuplicate				DBDAOERR(3378) //There is already a relationship named '|' in the current database.
#define E_DAO_DDLIntegrityViolation			DBDAOERR(3379) //Can't create relationships to enforce referential integrity.  Existing data in table '|2' violates referential integrity rules with related table '|1'.
#define E_DAO_DDLColumnDuplicate			DBDAOERR(3380) //Field '|2' already exists in table '|1'.
#define E_DAO_DDLColumnNotFound				DBDAOERR(3381) //There is no field named '|2' in table '|1'.
#define E_DAO_DDLColumnTooBig				DBDAOERR(3382) //The size of field '|' is too long.
#define E_DAO_DDLColumnInRel				DBDAOERR(3383) //Can't delete field '|'.  It's part of one or more relationships.
#define E_DAO_VtoCantDeleteBuiltIn			DBDAOERR(3384) //Can't delete a built-in property.
#define E_DAO_VtoUDPsDontSupportNull		DBDAOERR(3385) //User-defined properties don't support a Null value.
#define E_DAO_VtoMissingRequiredParm		DBDAOERR(3386) //Property '|' must be set before using this method.
#define E_DAO_JetJetInitInvalidPath			DBDAOERR(3387) //Can't find TEMP directory.
#define E_DAO_TLVExprUnknownFunctionM		DBDAOERR(3388) //Unknown function '|2' in validation expression or default value on '|1'.
#define E_DAO_QueryNotSupported				DBDAOERR(3389) //Query support unavailable.
#define E_DAO_AccountDuplicate				DBDAOERR(3390) //Account name already exists.
#define E_DAO_JetwrnPropCouldNotSave		DBDAOERR(3391) //An error has occurred.  Properties were not saved.
#define E_DAO_RelNoPrimaryIndexM			DBDAOERR(3392) //There is no primary key in table '|'.
#define E_DAO_QueryKeyTooBig				DBDAOERR(3393) //Can't perform join, group, sort, or indexed restriction. A value being searched or sorted on is too long.
#define E_DAO_PropMustBeDDL					DBDAOERR(3394) //Can't save property; property is a schema property.
#define E_DAO_IllegalRIConstraint			DBDAOERR(3395) //Invalid referential integrity constraint.
#define E_DAO_RIViolationMasterCM			DBDAOERR(3396) //Can't perform cascading operation.  Since related records exist in table '|', referential integrity rules would be violated.
#define E_DAO_RIViolationSlaveCM			DBDAOERR(3397) //Can't perform cascading operation.  There must be a related record in table '|'.
#define E_DAO_RIKeyNullDisallowedCM			DBDAOERR(3398) //Can't perform cascading operation.  It would result in a null key in table '|'.
#define E_DAO_RIKeyDuplicateCM				DBDAOERR(3399) //Can't perform cascading operation.  It would result in a duplicate key in table '|'.
#define E_DAO_RIUpdateTwiceCM				DBDAOERR(3400) //Can't perform cascading operation.  It would result in two updates on field '|2' in table '|1'.
#define E_DAO_RITLVNoNullCM					DBDAOERR(3401) //Can't perform cascading operation.  It would cause field '|' to become null, which is not allowed.
#define E_DAO_RITLVNoBlankCM				DBDAOERR(3402) //Can't perform cascading operation.  It would cause field '|' to become a zero-length string, which is not allowed.
#define E_DAO_RITLVRuleViolationCM			DBDAOERR(3403) //Can't perform cascading operation:  '|'
#define E_DAO_RITLVRuleVioCNoMessage		DBDAOERR(3404) //Can't perform cascading operation.  The value entered is prohibited by the validation rule '|2' set for '|1'.
#define E_DAO_TLVRuleEvalEBESErr			DBDAOERR(3405) //Error '|' in validation rule.
#define E_DAO_TLVDefaultEvalEBESErr			DBDAOERR(3406) //Error '|' in default value.
#define E_DAO_BadMSysConf					DBDAOERR(3407) //The server's MSysConf table exists, but is in an incorrect format.  Contact your system administrator.
#define E_DAO_TooManyFindSessions			DBDAOERR(3408) //Too many FastFind Sessions were invoked.
#define E_DAO_InvalidColumnM				DBDAOERR(3409) //Invalid field name '|' in definition of index or relationship.
#define E_DAO_REPReadOnly					DBDAOERR(3410) //*
#define E_DAO_RIInvalidBufferSizeCM			DBDAOERR(3411) //Invalid entry.  Can't perform cascading operation specified in table '|1' because value entered is too big for field '|2'.
#define E_DAO_RIWriteConflictCM				DBDAOERR(3412) //|
#define E_DAO_JetSpecialRIWriteConflictCM	DBDAOERR(3413) //Can't perform cascading update on table '|1' because it is currently in use by user '|3' on machine '|2'.
#define E_DAO_RISessWriteConflictCM			DBDAOERR(3414) //Can't perform cascading update on table '|' because it is currently in use.
#define E_DAO_NoBlank						DBDAOERR(3415) //Zero-length string is valid only in a text or Memo field.
#define E_DAO_FutureError					DBDAOERR(3416) //|
#define E_DAO_QueryInvalidBulkInput			DBDAOERR(3417) //An action query cannot be used as a row source.
#define E_DAO_NetCtrlMismatch				DBDAOERR(3418) //Can't open '|'.  Another user has the table open using a different network control file or locking style.
#define E_DAO_4xTableWith3xLocking			DBDAOERR(3419) //Can't open this Paradox 4.x or Paradox 5.x table because ParadoxNetStyle is set to 3.x in the initialization setting.
#define E_DAO_VtoObjectNotSet				DBDAOERR(3420) //Object is invalid or not set.
#define E_DAO_VtoDataConvError				DBDAOERR(3421) //Data type conversion error.
#define E_DAO_TableNotLocked				DBDAOERR(3422) //Can't modify table structure.  Another user has the table open
#define E_DAO_RmtDriverNotSupported			DBDAOERR(3423) //You cannot use ODBC to attach an external Microsoft Access or ISAM database table to your database
#define E_DAO_InvalidLanguageId				DBDAOERR(3424) //Can't create database; Invalid locale
#define E_DAO_VtoInvalidOpDuringCallback	DBDAOERR(3425) //This method or property is not currently available on this Recordset
#define E_DAO_VtoActionCancelled			DBDAOERR(3426) //The action was cancelled by an associated object
#define E_DAO_VtoOleAutoFailed				DBDAOERR(3427) //Error in DAO automation
#define E_DAO_DatabaseCorrupted_Cmpct		DBDAOERR(3428) //The Jet database engine has encountered a problem in your database.  To correct the problem, you must repair and compact the database
#define E_DAO_IncompatibleIIsam				DBDAOERR(3429) //Incompatible installable ISAM version
#define E_DAO_OLEInitializeFailure			DBDAOERR(3430) //While loading the Excel installable ISAM, OLE was unable to initialize
#define E_DAO_OLENotCompoundFile			DBDAOERR(3431) //This is not an Excel 5 file
#define E_DAO_OLEFailure					DBDAOERR(3432) //Error opening an Excel 5 file
#define E_DAO_IllegalIisamIniOption			DBDAOERR(3433) //Invalid parameter in [Excel ISAM] section of the initialization file
#define E_DAO_TableFull						DBDAOERR(3434) //Can't expand named range
#define E_DAO_TableCantClear				DBDAOERR(3435) //Cannot delete Excel cells
#define E_DAO_CreateFailed					DBDAOERR(3436) //Failure creating file
#define E_DAO_DatabaseFull					DBDAOERR(3437) //Excel spreadsheet is full
#define E_DAO_SpecAndColumnMismatch			DBDAOERR(3438) //File specification and data do not match
#define E_DAO_CantOpenWordMergeFiles		DBDAOERR(3439) //Can't attach or import Word mail merge file
#define E_DAO_FileHasNoColumns				DBDAOERR(3440) //Text file has no columns
#define E_DAO_AmbiguousDelimiters			DBDAOERR(3441) //Text file specification field separator matches decimal seperator or text delimiter
#define E_DAO_FileSpecErrorM				DBDAOERR(3442) //Error in entry |2 of section [|1] in schema.ini
#define E_DAO_NoSpecForFixedFormatM			DBDAOERR(3443) //Can't create fixed width text file without column specification in section [|2] of schema.ini
#define E_DAO_WidthMissInFixedSpecM			DBDAOERR(3444) //Column width required for column |2 in section [|1] of schema.ini
#define E_DAO_VtoWrongDllVersion			DBDAOERR(3445) //Incorrect version of JET DLL found
#define E_DAO_VtoMissingVBA					DBDAOERR(3446) //Could not locate a VBA related file
#define E_DAO_VtoVBAFailed					DBDAOERR(3447) //Failed to initialize VBA
#define E_DAO_VtoOLEFailed					DBDAOERR(3448) //An OLE system function failed
#define E_DAO_InvalidCountry				DBDAOERR(3449) //Missing country code
#define E_DAO_QueryIncompleteRowM			DBDAOERR(3450) //Syntax error in query.  Incomplete query clause
#define E_DAO_QueryParmTypeNotAllowed		DBDAOERR(3451) //Illegal reference in query
#define E_DAO_REPDBNotMaster				DBDAOERR(3452) //You can't make changes to the design of the database at this replica.
#define E_DAO_REPCantRelate					DBDAOERR(3453) //You can't establish or maintain an enforced relationship between a replicated table and a local table.
#define E_DAO_REPNotOwner					DBDAOERR(3454) //*
#define E_DAO_CantMakeReplicable			DBDAOERR(3455) //Can't make the database replicable.
#define E_DAO_CantMakeObjectReplicable		DBDAOERR(3456) //Can't make the |2 object in |1 container replicable.
#define E_DAO_REPCantKeepLocal				DBDAOERR(3457) //You can't set the KeepLocal property for an object that is already replicated.
#define E_DAO_REPCantKeepDBLocal			DBDAOERR(3458) //The KeepLocal property cannot be set on a database; it can be set only on the objects in a database.
#define E_DAO_CantUnreplDatabase			DBDAOERR(3459) //After a database has been replicated, you cannot remove the replication features from the database.
#define E_DAO_ReplConflict					DBDAOERR(3460) //The operation you attempted conflicts with an existing operation involving this member of the replica set.
#define E_DAO_REPSetRepid					DBDAOERR(3461) //The replication property you are attempting to set or delete is read-only and can't be changed.
#define E_DAO_TransportLoadFailure			DBDAOERR(3462) //Failure to load a DLL.
#define E_DAO_TransportLoadFailureM			DBDAOERR(3463) //Can't find the .dll '|2'.
#define E_DAO_TypeMismatchM					DBDAOERR(3464) //Data type mismatch in criteria expression.
#define E_DAO_DiskIOM						DBDAOERR(3465) //The disk drive you are attempting to access is unreadable.
#define E_DAO_FileAccessDeniedM				DBDAOERR(3466) //*
#define E_DAO_InvalidPathM					DBDAOERR(3467) //*
#define E_DAO_TranspAccessDeniedM			DBDAOERR(3468) //Access was denied while accessing dropbox folder '|2'.
#define E_DAO_TransportDiskFullM			DBDAOERR(3469) //The disk for dropbox folder '|2' is full.
#define E_DAO_TransportDiskIOM				DBDAOERR(3470) //Disk failure accessing dropbox folder '|2'.
#define E_DAO_LogWriteFail					DBDAOERR(3471) //Failure to write to the Synchronizer log file.
#define E_DAO_LogDiskFullM					DBDAOERR(3472) //Disk full for path '|1'.
#define E_DAO_LogDiskIOM					DBDAOERR(3473) //Disk failure while accessing log file '|1'.
#define E_DAO_LogFileAccessDeniedM			DBDAOERR(3474) //Can't open the log file '|1' for writing.
#define E_DAO_LogFileShareViolationM		DBDAOERR(3475) //Sharing violation while attempting to open log file '|1' in Deny Write mode.
#define E_DAO_TransportInvalidPathM			DBDAOERR(3476) //Invalid dropbox path '|2'.
#define E_DAO_TranspInvalidAddressM			DBDAOERR(3477) //Dropbox address '|2' is syntactically invalid.
#define E_DAO_RepNotPartial					DBDAOERR(3478) //The replica is not a partial replica.
#define E_DAO_RepPartial					DBDAOERR(3479) //Can't designate a partial replica as the Design Master for the replica set.
#define E_DAO_PARTInvalidRelNameM			DBDAOERR(3480) //The relationship '|' in the partial filter expression is invalid.
#define E_DAO_PARTInvalidTableNameM			DBDAOERR(3481) //The table name '|' in the partial filter expression is invalid.
#define E_DAO_REPInvalidFilter				DBDAOERR(3482) //The filter expression for the partial replica is invalid.
#define E_DAO_TranspInvalidPasswordM		DBDAOERR(3483) //The password supplied for the dropbox folder '|2' is invalid.
#define E_DAO_TransDestInvalidPassword		DBDAOERR(3484) //The password used by the Synchronizer to write to a destination dropbox folder is invalid.
#define E_DAO_REPDBNotRep					DBDAOERR(3485) //The object can't be replicated because the database is not replicated.
#define E_DAO_REPSecondGuid					DBDAOERR(3486) //You can't add a second Replication ID AutoNumber field to a table.
#define E_DAO_REPOnlyBuiltin				DBDAOERR(3487) //The database you are attempting to replicate can't be converted.
#define E_DAO_REPNoSuchRepid				DBDAOERR(3488) //The value specified is not a ReplicaID for any member in the replica set.
#define E_DAO_REPObjectNotRep				DBDAOERR(3489) //The object specified can't be replicated because it is missing a  necessary resource.
#define E_DAO_CantCreateReplica				DBDAOERR(3490) //Can't create a new replica because the '|2' object in '|1' container could not be replicated.
#define E_DAO_MustOpenDbExclusive			DBDAOERR(3491) //The database must be opened in exclusive mode before it can be replicated.
#define E_DAO_CantDoSchemaChange			DBDAOERR(3492) //The synchronization failed because a design change could not be applied to one of the replicas.
#define E_DAO_UnableToSetParam				DBDAOERR(3493) //Can't set the specified Registry parameter for the Synchronizer.
#define E_DAO_UnableToGetParam				DBDAOERR(3494) //Unable to retrieve the specified Registry parameter for the Synchronizer.
#define E_DAO_REPNoSuchSchedule				DBDAOERR(3495) //There are no scheduled synchronizations between the two Synchronizers.
#define E_DAO_REPNoSuchExchange				DBDAOERR(3496) //Replication Manager cannot find the ExchangeID in the MSysExchangeLog table.
#define E_DAO_REPCantSetSchedule			DBDAOERR(3497) //Unable to set a schedule for the Synchronizer.
#define E_DAO_REPCantGetSchedule			DBDAOERR(3498) //*
#define E_DAO_REPCantGetDBPath				DBDAOERR(3499) //Can't retrieve the full path information for a member of the replica set.
#define E_DAO_REPCantSetExchange			DBDAOERR(3500) //You cannot specify two different Synchronizers to manage the same replica.
#define E_DAO_REPNotUpdated					DBDAOERR(3501) //*
#define E_DAO_REPNotManaged					DBDAOERR(3502) //The Design Master or replica is not being managed by a Synchronizer.
#define E_DAO_ValueNotSet					DBDAOERR(3503) //The Synchronizer's Registry has no value set for the key you queried.
#define E_DAO_REPInvalidTID					DBDAOERR(3504) //The Synchronizer ID does not match an existing ID in the MSysTranspAddress table.
#define E_DAO_REPFilterNotFound				DBDAOERR(3505) //You attempted to delete or get information about a partial filter that does not exist in MSysFilters.
#define E_DAO_OpenLog						DBDAOERR(3506) //The Synchronizer is unable to open the Synchronizer log.
#define E_DAO_WriteLog						DBDAOERR(3507) //Failure writing to the Synchronizer log.
#define E_DAO_NoTransport					DBDAOERR(3508) //There is no active transport for the Synchronizer.
#define E_DAO_TransportNotFound				DBDAOERR(3509) //Could not find a valid transport for this Synchronizer.
#define E_DAO_ReplicaAlreadyLocked			DBDAOERR(3510) //The member of the replica set you are attempting to synchronize is currently being used in another synchronization.
#define E_DAO_DBAccess						DBDAOERR(3511) //*
#define E_DAO_TransportReadFailure			DBDAOERR(3512) //Failed to read the dropbox folder.
#define E_DAO_TransportWriteFailure			DBDAOERR(3513) //Failed to write to the dropbox folder.
#define E_DAO_NoExchange					DBDAOERR(3514) //Synchronizer could not find any scheduled or on-demand synchronizations to process.
#define E_DAO_SysClock						DBDAOERR(3515) //The Microsoft Jet database engine could not read the system clock on your computer.
#define E_DAO_NoTransportAddress			DBDAOERR(3516) //Destination synchronizer is not configured to support indirect synchronronization, and the destination replica is unavailable for direct synchronization
#define E_DAO_NoMessage						DBDAOERR(3517) //Synchronizer could not find any messages to process.
#define E_DAO_TransporterNotFound			DBDAOERR(3518) //Could not find Synchronizer in the MSysTranspAddress table.
#define E_DAO_TransportSendFailure			DBDAOERR(3519) //Failed to send a message.
#define E_DAO_ReplicaNotFound				DBDAOERR(3520) //The replica name or ID does not match a currently managed member of the replica set.
#define E_DAO_OutOfSynch					DBDAOERR(3521) //Two members of the replica set cannot be synchronized because there is no common point to start the synchronization.
#define E_DAO_ExchangeNotFound				DBDAOERR(3522) //Synchronizer cannot find the record of a specific synchronization in the MSysExchangeLog table.
#define E_DAO_SchemaNotFound				DBDAOERR(3523) //Synchronizer cannot find a specific version number in the MSysSchChange table.
#define E_DAO_SchemaHistMismatch			DBDAOERR(3524) //The history of design changes in the replica does not match the history in the Design Master.
#define E_DAO_MessageDBAccess				DBDAOERR(3525) //Synchronizer could not access the message database.
#define E_DAO_ObjectAlreadyExists			DBDAOERR(3526) //The name selected for the system object is already in use.
#define E_DAO_ObjectDoesntExist				DBDAOERR(3527) //The Synchronizer or Replication Manager could not find the system object.
#define E_DAO_NoNewData						DBDAOERR(3528) //There is no new data in shared memory for the Synchronizer or Replication Manager to read.
#define E_DAO_PrevDataNotRead				DBDAOERR(3529) //The Synchronizer or Replication Manager found unread data in the shared memory. The existing data will be overwritten.
#define E_DAO_ClientAlreadyExists			DBDAOERR(3530) //The Synchronizer is already serving a client.
#define E_DAO_WaitTimeout					DBDAOERR(3531) //The wait period for an event has timed out.
#define E_DAO_ServerInitialization			DBDAOERR(3532) //Synchronizer could not be initialized.
#define E_DAO_ObjectAbandoned				DBDAOERR(3533) //The system object used by a process still exists after the process has stopped.
#define E_DAO_NoEvent						DBDAOERR(3534) //Synchronizer looked for a system event but did not find one to report to the client.
#define E_DAO_ClientSentTerm				DBDAOERR(3535) //Client has asked the Synchronizer to terminate operation.
#define E_DAO_InvalidMessage				DBDAOERR(3536) //Synchronizer received an invalid message for a member of the replica set that it manages.
#define E_DAO_NoClient						DBDAOERR(3537) //The Synchronizer's client is no longer present and cannot be notified.
#define E_DAO_TooManyTasks					DBDAOERR(3538) //Cannot initialize Synchronizer because there are too many applications running.
#define E_DAO_SysDiskIO						DBDAOERR(3539) //A system error has occurred or your swap file has reached its limit.
#define E_DAO_PageFile						DBDAOERR(3540) //Your swap file has reached its limit or is corrupted.
#define E_DAO_ProcessStillActive			DBDAOERR(3541) //Synchronizer could not be shut down properly and is still active.
#define E_DAO_ProcessAborted				DBDAOERR(3542) //Process stopped when attempting to terminate Synchronizer client.
#define E_DAO_TransporterNotSetup			DBDAOERR(3543) //Synchronizer has not been set up.
#define E_DAO_ServerAlreadyRunning			DBDAOERR(3544) //Synchronizer is already running.
#define E_DAO_DiffReplicaSet				DBDAOERR(3545) //The two replicas you are attempting to synchronize are from different replica sets.
#define E_DAO_BadExchangeType				DBDAOERR(3546) //The type of synchronization you are attempting is not valid.
#define E_DAO_NoReplica						DBDAOERR(3547) //Synchronizer could not find a replica from the correct set to complete the synchronization.
#define E_DAO_GuidMismatch					DBDAOERR(3548) //GUIDs do not match or the requested GUID could not be found.
#define E_DAO_FilenameTooLong				DBDAOERR(3549) //The file name you provided is too long.
#define E_DAO_NoGuidIndex					DBDAOERR(3550) //There is no index on the GUID column.
#define E_DAO_UnableToDeleteParam			DBDAOERR(3551) //Unable to delete the specified Registry parameter for the Synchronizer.
#define E_DAO_ValueTooBig					DBDAOERR(3552) //The size of the Registry parameter exceeds the maximum allowed.
#define E_DAO_REPGuidCreateFailure			DBDAOERR(3553) //The GUID could not be created.
#define E_DAO_REPDBMovedCopied				DBDAOERR(3554) //*
#define E_DAO_REPNoValidNick				DBDAOERR(3555) //All valid nicknames for replicas are already in use.
#define E_DAO_TransportDestInvalidPath		DBDAOERR(3556) //Invalid path for destination dropbox folder.
#define E_DAO_TransDestInvalidAddress		DBDAOERR(3557) //Invalid address for destination dropbox folder.
#define E_DAO_TransportDestDiskIO			DBDAOERR(3558) //Disk I/O error at destination dropbox folder.
#define E_DAO_TransportDestDiskFull			DBDAOERR(3559) //Failure to write because destination disk is full.
#define E_DAO_REPSameReplicaID				DBDAOERR(3560) //The two members of the replica set you are attempting to synchronize have the same ReplicaID.
#define E_DAO_REPBothMasters				DBDAOERR(3561) //The two members of the replica set you are attempting to synchronize are both Design Masters.
#define E_DAO_TransDestAccessDenied			DBDAOERR(3562) //Access denied at destination dropbox folder.
#define E_DAO_TransportSrcAccess			DBDAOERR(3563) //Fatal error accessing a local dropbox folder.
#define E_DAO_TransportSrcFileNotFound		DBDAOERR(3564) //Synchronizer can't find the source file for messages.
#define E_DAO_TransSrcSharingViolation		DBDAOERR(3565) //There is a sharing violation in the source dropbox folder because the message database is open in another application.
#define E_DAO_NetworkIO						DBDAOERR(3566) //Network I/O error.
#define E_DAO_TransportWrongMessage			DBDAOERR(3567) //Message in dropbox folder belongs to the wrong Synchronizer.
#define E_DAO_TransportDeleteFailure		DBDAOERR(3568) //Synchronizer could not delete a file.
#define E_DAO_RepRemoved					DBDAOERR(3569) //This member of the replica set has been logically removed from the set and is no longer available.
#define E_DAO_FiltersChanged				DBDAOERR(3570) //The filters defining a partial replica are out of synch with each other.
#define E_DAO_LimitedUpdate					DBDAOERR(3571) //The attempt  to set a column in a partial replica violated a rule governing partial replicas.
#define E_DAO_TempDiskIO					DBDAOERR(3572) //A disk I/O error occurred while reading or writing to the TEMP directory.
#define E_DAO_DirNotManaged					DBDAOERR(3573) //The directory you queried for a list of replicas is not a managed directory.
#define E_DAO_RepidChanged					DBDAOERR(3574) //The ReplicaID for this member of the replica set was reassigned during a move or copy procedure.
#define E_DAO_DiskFullM						DBDAOERR(3575) //The disk drive you are attempting to write to is full.
#define E_DAO_ShareViolationM				DBDAOERR(3576) //The database you are attempting to open is already in use by another application.
#define E_DAO_UpdateReplCol					DBDAOERR(3577) //Can't update replication system column.
#define E_DAO_GetDbinfoM					DBDAOERR(3578) //Failure to replicate database; can't determine whether the database is open in exclusive mode.
#define E_DAO_MakeRepTablesM				DBDAOERR(3579) //Could not create replication system tables needed to make the database replicable.
#define E_DAO_AddReplicaInfoM				DBDAOERR(3580) //Could not add rows needed to make the database replicable.
#define E_DAO_OpenRepTablesM				DBDAOERR(3581) //Can't open replication system table '|' because the table is already in use.
#define E_DAO_CreateReplicaObjectM			DBDAOERR(3582) //Cannot make a new replica because the |2 object in |1 container could not be made replicable.
#define E_DAO_MakeObjectReplM				DBDAOERR(3583) //Cannot make the |2 object in |1 container replicable.
#define E_DAO_OutOfMemoryM					DBDAOERR(3584) //Insufficient memory to complete operation.
#define E_DAO_RepTooManyColumnsM			DBDAOERR(3585) //Can't replicate the table; the number of columns exceeds the maximum allowed.
#define E_DAO_PARTFilterExprSyntaxM			DBDAOERR(3586) //Syntax error in partial filter expression on table |1.
#define E_DAO_PARTUnknownTokenM				DBDAOERR(3587) //Invalid expression in the ReplicaFilter property.
#define E_DAO_PARTExprEvaluationM			DBDAOERR(3588) //Error when evaluating the partial filter expression.
#define E_DAO_PARTExprUnknownFuncM			DBDAOERR(3589) //The partial filter expression contains an unknown function.
#define E_DAO_LimitedUpdateM				DBDAOERR(3590) //Violates the rules for partial replicas.
#define E_DAO_LogInvalidPathM				DBDAOERR(3591) //Log file path '|1' is invalid.
#define E_DAO_REPPasswdNotAllowed			DBDAOERR(3592) //You can't replicate a password-protected database or set password protection on a replicated database.
#define E_DAO_BadSingleMasterAttrib			DBDAOERR(3593) //You can't change the data master attribute for the replica set.
#define E_DAO_BadMultiMasterAttrib			DBDAOERR(3594) //You can't change the data master attribute for the replica set.  It allows data changes only at the Design Master.
#define E_DAO_REPCantRepair					DBDAOERR(3595) //The system tables in your replica are no longer reliable and the replica should not be used.
#define E_DAO_NoDataIncluded				DBDAOERR(3596) //*
#define E_DAO_SenderNotFound				DBDAOERR(3597) //*
#define E_DAO_CouldnotFindService			DBDAOERR(3598) //*
#define E_DAO_UnableToStartService			DBDAOERR(3599) //*
#define E_DAO_ExprAggIllegalOnGuid			DBDAOERR(3600) //Aggregation expressions cannot use GUIDs.
#define E_DAO_RefreshReplicaList			DBDAOERR(3601) //*
#define E_DAO_MoreWorkNeeded				DBDAOERR(3602) //*
#define E_DAO_SenderTooOld					DBDAOERR(3603) //*
#define E_DAO_RepAccess						DBDAOERR(3604) //*
#define E_DAO_REPDbNotReplicableM			DBDAOERR(3605) //Synchronizing with a non-replicated database is not allowed. The '|' database is not a Design Master or replica.
#define E_DAO_DaemonDied					DBDAOERR(3606) //*
#define E_DAO_REPCantDelete					DBDAOERR(3607) //The replication property you are attempting to delete is read-only and cannot be removed.
#define E_DAO_IndexCantBuild				DBDAOERR(3608) //Record length is too long for an indexed Paradox table.
#define E_DAO_RelNoPrimaryIndex				DBDAOERR(3609) //No unique index found for the referenced field of the primary table.
#define E_DAO_QuerySameSrcDestTableM		DBDAOERR(3610) //Same table '|' referenced as both the source and destination in make-table query.
#define E_DAO_InvalidDDLObject				DBDAOERR(3611) //Can't execute data definition statements on linked data sources.
#define E_DAO_QueryMGBWithSubquery			DBDAOERR(3612) //Multi-level GROUP BY clause is not allowed in a subquery.
#define E_DAO_SQLLinkNotSupported			DBDAOERR(3613) //Can't create a relationship on linked ODBC tables.
#define E_DAO_InvalidFindOnGUID				DBDAOERR(3614) //GUID not allowed in Find method criteria expression.
#define E_DAO_QueryJoinExprInComp			DBDAOERR(3615) //Type mismatch in JOIN expression.
#define E_DAO_UpdateNotAvailable			DBDAOERR(3616) //Updating data in a linked table is not supported by this ISAM.
#define E_DAO_DeleteNotAvailable			DBDAOERR(3617) //Deleting data in a linked table is not supported by this ISAM.
#define E_DAO_ExceptTableCreateFail			DBDAOERR(3618) //Exceptions table could not be created on import/export.
#define E_DAO_ExceptTableWriteFail			DBDAOERR(3619) //Records could not be added to exceptions table.
#define E_DAO_ExcelOLEConnectLost			DBDAOERR(3620) //The connection for viewing your linked Microsoft Excel worksheet was lost.
#define E_DAO_CantChangeDbPwdOnShared		DBDAOERR(3621) //Can't change password on a shared open database.
#define E_DAO_RmtMustCheckTimeStamp			DBDAOERR(3622) //You must use the dbSeeChanges option with OpenRecordset when accessing a SQL Server table that has an IDENTITY column.
#define E_DAO_NotWithBoundFileM				DBDAOERR(3623) //Cannot access the FoxPro 3.0 bound DBF file '|'.
#define E_DAO_CommitConflict				DBDAOERR(3624) //Couldn't read the record; currently locked by another user.
#define E_DAO_NoSuchSpecM					DBDAOERR(3625) //The text file specification '|' does not exist.  You can't import, export, or link using the specification.
#define E_DAO_TooManyIndexesM				DBDAOERR(3626) //The operation failed.  There are too many indexes on table '|'.  Delete some of the indexes on the table and try the operation again.
#define E_DAO_TransExeNotFound				DBDAOERR(3627) //Cannot find the executable file for the Synchronizer (mstran35.exe).
#define E_DAO_RemRepNotManaged				DBDAOERR(3628) //Partner replica is not managed by a Synchronizer.
#define E_DAO_FSDropboxShared				DBDAOERR(3629) //Synchronizer '|1' is also using the same File System dropbox '|2'.
#define E_DAO_FSDropboxSharedM				DBDAOERR(3630) //Synchronizer '|1' is also using the same File System dropbox '|2'.
#define E_DAO_RepInvalidTableInFilter		DBDAOERR(3631) //Invalid Table Name In Filter
#define E_DAO_InetNotEnabled				DBDAOERR(3632) //Internet Transport not enabled on the remote Synchronizer.
#define E_DAO_VtoDllLoadFailed				DBDAOERR(3633) //Can't load DLL:  '|'
#define E_DAO_REPDBIsPartial				DBDAOERR(3634) //Cannot create a replica using a partial replica.
#define E_DAO_CantCreatePartialSys			DBDAOERR(3635) //Cannot create partial replica of a system database.
#define E_DAO_CantPopulateWithErrors		DBDAOERR(3636) //Cannot populate the replica or change the replica's filter because the replica has conflicts or data errors.
#define E_DAO_QueryEmbeddedVarTab			DBDAOERR(3637) //Cannot use the crosstab of a non-fixed column as a subquery.
#define E_DAO_SrcCntrlDB					DBDAOERR(3638) //A Source Controlled database cannot be made replicable.
#define E_DAO_CantCreateSysReplica			DBDAOERR(3639) //Cannot create a replica of a System database.
#define E_DAO_VtoFetchBuffTooSmall			DBDAOERR(3640) //The fetch buffer was too small for the amount of data you requested.
#define E_DAO_VtoEOFDuringFetch				DBDAOERR(3641) //There are fewer records remaining in the recordset than you requested.
#define E_DAO_VtoSilentCancel				DBDAOERR(3642) //A cancel was performed on the operation.
#define E_DAO_VtoRecordDeleted				DBDAOERR(3643) //One of the records in the recordset was deleted by another process.
#define E_DAO_3644							DBDAOERR(3644) //*
#define E_DAO_VtoBadBindInfo				DBDAOERR(3645) //One of the binding parameters is incorrect.
#define E_DAO_VtoRowLenTooSmall				DBDAOERR(3646) //The specified row length is shorter than the sum of the column lengths.
#define E_DAO_VtoColumnMissing				DBDAOERR(3647) //A column requested is not being returned to the recordset.
#define E_DAO_BothPartials					DBDAOERR(3648) //Cannot synchronize a partial replica with another partial replica.
#define E_DAO_InvalidCodePage				DBDAOERR(3649) //The language-specific code page was not specified or could not be found.
#define E_DAO_InetTooSlow					DBDAOERR(3650) //Either the Internet is very slow OR there is some problem in the replication manager setup on the internet server machine.
#define E_DAO_InetInvalidAddress			DBDAOERR(3651) //Invalid internet address.
#define E_DAO_InetLoginFailure				DBDAOERR(3652) //Internet login failure.
#define E_DAO_InetNotSetup					DBDAOERR(3653) //Internet not set up.
#define E_DAO_InetInternalFailure			DBDAOERR(3654) //Internal internet failure.
#define E_DAO_InetServicesUnavailable		DBDAOERR(3655) //The wininet.dll can't be loaded or initialized.
#define E_DAO_PARTExprEvaluation			DBDAOERR(3656) //Error in evaluating a partial expression
#define E_DAO_PARTFilterEvalM				DBDAOERR(3657) //Error in evaluating the boolean filter expression for table '|1'.
#define E_DAO_PARTBinaryNotAllowedM			DBDAOERR(3658) //Binary column '|' cannot be used in a boolean filter.
#define E_DAO_PARTUnenforcedRelM			DBDAOERR(3659) //Relationship '|1' is unenforced. Relationship in a partial filter expression must be enforced.
#define E_DAO_ExchangeFailed				DBDAOERR(3660) //Requested exchange failed because '|1'
#define E_DAO_ExchangeFailedM				DBDAOERR(3661) //Requested exchange failed because '|1'
#define E_DAO_VtoRSNeedsBatchCursorLib		DBDAOERR(3662) //*
#define E_DAO_VtoNeedDiffCursorLibrary		DBDAOERR(3663) //This operation requires a different cursor library.
#define E_DAO_VtoStillConnecting			DBDAOERR(3664) //An asynchronous OpenConnection call is not yet complete, and you cannot yet reference the returned Connection object until it is complete.
#define E_DAO_AccessDeniedRepl				DBDAOERR(3665) //You cannot modify the replication system object '1'
#define E_DAO_AccessDeniedReplM				DBDAOERR(3666) //You cannot modify the replication system object '1'
#define E_DAO_VtoOtherOperBlocking			DBDAOERR(3667) //A different operation is preventing this operation from being executed.
#define E_DAO_VtoNoActiveConnection			DBDAOERR(3668) //Can not perform this operation because there is no active connection.
#define E_DAO_VtoExecCancelled				DBDAOERR(3669) //Execution cancelled.
#define E_DAO_VtoCursorNotValid				DBDAOERR(3670) //Cursor is not valid.
#define E_DAO_VtoCanNotFindTable			DBDAOERR(3671) //Can not find table to update.
#define E_DAO_VtoCanNotFindCursLib			DBDAOERR(3672) //Failed to load RDOCURS.DLL.

#endif // def _DBDAOERR.H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dbdaoid.h ===
/************************************************************************
**	D B D A O I D . H													*
**																		*
**																		*
**	OLE DAO component class id definitions								*
**	DAO has been allocated the GUID::Data1 range of 0x00025eXX			*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 					*
**		   All Rights Reserved					 						*
************************************************************************/

/*	The pre-3.5 GUIDs have been redefined with "30" added to the ID. For example:
	IID_IDAOIndex becomes IID30_IDAOIndex
	This way both the 30 and 3.5 GUIDs can be used at once
*/


DEFINE_OLEGUID(LIBID_CJETSQLHELP,		0x00025f01, 0, 0);

#define DEFINE_DAOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)

// Type library
DEFINE_OLEGUID(LIBID_CDAO,				0x00025e01, 0, 0);
DEFINE_OLEGUID(LIBID_CDAO25,			0x00025e04, 0, 0);

// StdObject
DEFINE_DAOGUID(IID_IDAOStdObject,		0x0000000A);

// StdCollection
DEFINE_DAOGUID(IID_IDAOStdCollection,	0x0000000C);

// Creatable Classes
DEFINE_DAOGUID(CLSID_CDAODBEngine,		0x00000010);
DEFINE_DAOGUID(CLSID_CDAOPrivDBEngine,	0x00000011);
DEFINE_DAOGUID(CLSID_CDAOConnection,	0x00000012);
DEFINE_DAOGUID(CLSID_CDAOTableDef,		0x00000013);
DEFINE_DAOGUID(CLSID_CDAOField, 		0x00000014);
DEFINE_DAOGUID(CLSID_CDAOIndex, 		0x00000015);
DEFINE_DAOGUID(CLSID_CDAOGroup, 		0x00000016);
DEFINE_DAOGUID(CLSID_CDAOUser,			0x00000017);
DEFINE_DAOGUID(CLSID_CDAOQueryDef,		0x00000018);
DEFINE_DAOGUID(CLSID_CDAORelation,		0x00000019);

// DBEngine
DEFINE_DAOGUID(IID_IDAODBEngine,		0x00000020);
DEFINE_DAOGUID(IID_IDAODBEngineW,		0x00000021);

// Error
DEFINE_DAOGUID(IID_IDAOError,			0x00000022);
DEFINE_DAOGUID(IID_IDAOErrorW,			0x00000023);
DEFINE_DAOGUID(IID_IDAOErrors,			0x00000024);
DEFINE_DAOGUID(IID_IDAOErrorsW,			0x00000025);

// Property
DEFINE_DAOGUID(IID_IDAOProperty,		0x00000026);
DEFINE_DAOGUID(IID_IDAOPropertyW,		0x00000027);
DEFINE_DAOGUID(IID_IDAOProperties,		0x00000028);
DEFINE_DAOGUID(IID_IDAOPropertiesW,		0x00000029);

// Recordset
DEFINE_DAOGUID(IID_IDAORecordset,		0x00000030);
DEFINE_DAOGUID(IID_IDAORecordsetW,		0x00000031);
DEFINE_DAOGUID(IID_IDAORecordsets,		0x00000032);
DEFINE_DAOGUID(IID_IDAORecordsetsW,		0x00000033);
DEFINE_OLEGUID(IID_ICDAORecordset,		0x00025e31, 0, 0);	//same as it was in 3.0

// Workspace
DEFINE_DAOGUID(IID_IDAOWorkspace,		0x00000038);
DEFINE_DAOGUID(IID_IDAOWorkspaceW,		0x00000039);
DEFINE_DAOGUID(IID_IDAOWorkspaces,		0x0000003A);
DEFINE_DAOGUID(IID_IDAOWorkspacesW,		0x0000003B);

// Connection
DEFINE_DAOGUID(IID_IDAOConnection,		0x00000040);
DEFINE_DAOGUID(IID_IDAOConnectionW,		0x00000041);
DEFINE_DAOGUID(IID_IDAOConnections,		0x00000042);
DEFINE_DAOGUID(IID_IDAOConnectionsW,	0x00000043);

// TableDef
DEFINE_DAOGUID(IID_IDAOTableDef,		0x00000048);
DEFINE_DAOGUID(IID_IDAOTableDefW,		0x00000049);
DEFINE_DAOGUID(IID_IDAOTableDefs,		0x0000004A);
DEFINE_DAOGUID(IID_IDAOTableDefsW,		0x0000004B);

// Field
DEFINE_DAOGUID(IID_IDAOField,			0x00000050);
DEFINE_DAOGUID(IID_IDAOFieldW,			0x00000051);
DEFINE_DAOGUID(IID_IDAOFields,			0x00000052);
DEFINE_DAOGUID(IID_IDAOFieldsW,			0x00000053);

// Index
DEFINE_DAOGUID(IID_IDAOIndex,			0x00000058);
DEFINE_DAOGUID(IID_IDAOIndexW,			0x00000059);
DEFINE_DAOGUID(IID_IDAOIndexes,			0x0000005A);
DEFINE_DAOGUID(IID_IDAOIndexesW,		0x0000005B);
DEFINE_DAOGUID(IID_IDAOIndexFields,		0x0000005C);
DEFINE_DAOGUID(IID_IDAOIndexFieldsW,	0x0000005D);

// Group
DEFINE_DAOGUID(IID_IDAOGroup,			0x00000060);
DEFINE_DAOGUID(IID_IDAOGroupW,			0x00000061);
DEFINE_DAOGUID(IID_IDAOGroups,			0x00000062);
DEFINE_DAOGUID(IID_IDAOGroupsW,			0x00000063);

// User
DEFINE_DAOGUID(IID_IDAOUser,			0x00000068);
DEFINE_DAOGUID(IID_IDAOUserW,			0x00000069);
DEFINE_DAOGUID(IID_IDAOUsers,			0x0000006A);
DEFINE_DAOGUID(IID_IDAOUsersW,			0x0000006B);

// Database
DEFINE_DAOGUID(IID_IDAODatabase,		0x00000070);
DEFINE_DAOGUID(IID_IDAODatabaseW,		0x00000071);
DEFINE_DAOGUID(IID_IDAODatabases,		0x00000072);
DEFINE_DAOGUID(IID_IDAODatabasesW,		0x00000073);

// QueryDef
DEFINE_DAOGUID(IID_IDAOQueryDef,		0x00000078);
DEFINE_DAOGUID(IID_IDAOQueryDefW,		0x00000079);
DEFINE_DAOGUID(IID_IDAOQueryDefs,		0x0000007A);
DEFINE_DAOGUID(IID_IDAOQueryDefsW,		0x0000007B);

// Parameter
DEFINE_DAOGUID(IID_IDAOParameter,		0x00000080);
DEFINE_DAOGUID(IID_IDAOParameterW,		0x00000081);
DEFINE_DAOGUID(IID_IDAOParameters,		0x00000082);
DEFINE_DAOGUID(IID_IDAOParametersW,		0x00000083);

// Relation
DEFINE_DAOGUID(IID_IDAORelation,		0x00000088);
DEFINE_DAOGUID(IID_IDAORelationW,		0x00000089);
DEFINE_DAOGUID(IID_IDAORelations,		0x0000008A);
DEFINE_DAOGUID(IID_IDAORelationsW,		0x0000008B);

// Container
DEFINE_DAOGUID(IID_IDAOContainer,		0x00000090);
DEFINE_DAOGUID(IID_IDAOContainerW,		0x00000091);
DEFINE_DAOGUID(IID_IDAOContainers,		0x00000092);
DEFINE_DAOGUID(IID_IDAOContainersW,		0x00000093);

// Document
DEFINE_DAOGUID(IID_IDAODocument,		0x00000098);
DEFINE_DAOGUID(IID_IDAODocumentW,		0x00000099);
DEFINE_DAOGUID(IID_IDAODocuments,		0x0000009A);
DEFINE_DAOGUID(IID_IDAODocumentsW,		0x0000009B);

// Collections 
DEFINE_DAOGUID(IID_IDAOCollection,		0x000000A0);
DEFINE_DAOGUID(IID_IDAODynaCollection,	0x000000A2);

// Connection points 
DEFINE_DAOGUID(IID_IDAOQueryCP,			0x000000B0);
DEFINE_DAOGUID(IID_IDAOQueryAS,			0x000000B2);

// Type library
DEFINE_OLEGUID(LIBID30_CDAO,				0x00025e01, 0, 0);
DEFINE_OLEGUID(LIBID30_CDAO25,			0x00025e04, 0, 0);

// StdObject
DEFINE_OLEGUID(IID30_IDAOStdObject,		0x00025e02, 0, 0);

// StdCollection
DEFINE_OLEGUID(IID30_IDAOStdCollection,	0x00025e03, 0, 0);

/*
	NOTES:
	* Two sets of CLSIDs exist for the DBEngine object.
	* DBEngine and DBEngine30.  The 30 extension means
	* that this engine should load the 3.0 typelibrary
	* from the registry.  Otherwise, load the 2.5/3.0
	* compatability type library
*/

// DBEngine
DEFINE_OLEGUID(CLSID30_CDAODBEngine,		0x00025e15, 0, 0);
DEFINE_OLEGUID(IID30_IDAODBEngine,		0x00025e16, 0, 0);
DEFINE_OLEGUID(IID30_IDAODBEngineW,		0x00025e17, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETDBEngine,	0x00025e18, 0, 0);
DEFINE_OLEGUID(CLSID30_CDAOPrivDBEngine,	0x00025e19, 0, 0);

// Error
DEFINE_OLEGUID(IID30_IDAOError,			0x00025e1d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrorW,			0x00025e1e, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrors,			0x00025e1f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrorsW,			0x00025e20, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETError,		0x00025e21, 0, 0);	//used by Access, goes away post 3.0

// Property
DEFINE_OLEGUID(IID30_IDAOProperty,		0x00025e25, 0, 0);
DEFINE_OLEGUID(IID30_IDAOPropertyW,		0x00025e26, 0, 0);
DEFINE_OLEGUID(IID30_IDAOProperties,		0x00025e27, 0, 0);
DEFINE_OLEGUID(IID30_IDAOPropertiesW,		0x00025e28, 0, 0);

// Recordset
DEFINE_OLEGUID(IID30_IDAORecordset,		0x00025e2d, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsetW,		0x00025e2e, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsets,		0x00025e2f, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsetsW,		0x00025e30, 0, 0);
DEFINE_OLEGUID(IID30_ICDAORecordset,		0x00025e31, 0, 0);	//NOTE: No change for 3.1 or 3.5
DEFINE_OLEGUID(IID30_ICDAOJETRecordset,	0x00025e32, 0, 0);

// Snapshot
DEFINE_OLEGUID(IID30_IDAOSnapshot,		0x00025e33, 0, 0);

// Table
DEFINE_OLEGUID(IID30_IDAOTable,			0x00025e34, 0, 0);

// Dynaset
DEFINE_OLEGUID(IID30_IDAODynaset,			0x00025e35, 0, 0);

// Workspace
DEFINE_OLEGUID(IID30_IDAOWorkspace,		0x00025e3a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspaceW,		0x00025e3b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspaces,		0x00025e3c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspacesW,		0x00025e3d, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETWorkspace,	0x00025e3e, 0, 0);

// Connection (new to 3.1)
DEFINE_OLEGUID(CLSID30_CDAOConnection,	0x00025eb1, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnection,		0x00025eb2, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnectionW,		0x00025eb3, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnections,		0x00025eb4, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnectionsW,	0x00025eb5, 0, 0);

// TableDef
DEFINE_OLEGUID(CLSID30_CDAOTableDef,		0x00025e43, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDef,		0x00025e44, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefW,		0x00025e45, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefs,		0x00025e46, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefsW,		0x00025e47, 0, 0);

// Field
DEFINE_OLEGUID(CLSID30_CDAOField, 		0x00025e4c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOField,			0x00025e4d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFieldW,			0x00025e4e, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFields,			0x00025e4f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFieldsW,			0x00025e50, 0, 0);
//DEFINE_OLEGUID(IID30_ICDAOJETField,		0x00025e51, 0, 0);	//used by Access, goes away post 3.0
DEFINE_OLEGUID(IID30_ICDAOJETField,		0x00025e49, 0, 0);	//used by Access, goes away post 3.0

// Index
DEFINE_OLEGUID(CLSID30_CDAOIndex, 		0x00025e55, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndex,			0x00025e56, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexW,			0x00025ed7, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexes,			0x00025e58, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexesW,		0x00025e59, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexFields,		0x00025e5a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexFieldsW,	0x00025e5b, 0, 0);

// Group
DEFINE_OLEGUID(CLSID30_CDAOGroup, 		0x00025e5f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroup,			0x00025e60, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroupW,			0x00025e61, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroups,			0x00025e62, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroupsW,			0x00025e63, 0, 0);

// User
DEFINE_OLEGUID(CLSID30_CDAOUser,			0x00025e68, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUser,			0x00025e69, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUserW,			0x00025e6a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUsers,			0x00025e6b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUsersW,			0x00025e6c, 0, 0);

// Database
DEFINE_OLEGUID(IID30_IDAODatabase,		0x00025e71, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabaseW,		0x00025e72, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabases,		0x00025e73, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabasesW,		0x00025e74, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETDatabase,	0x00025e75, 0, 0);

// QueryDef
DEFINE_OLEGUID(CLSID30_CDAOQueryDef,		0x00025e7a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDef,		0x00025e7b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefW,		0x00025e7c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefs,		0x00025e7d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefsW,		0x00025e7e, 0, 0);

// Parameter
DEFINE_OLEGUID(IID30_IDAOParameter,		0x00025e83, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParameterW,		0x00025e84, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParameters,		0x00025e85, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParametersW,		0x00025e86, 0, 0);

// Relation
DEFINE_OLEGUID(CLSID30_CDAORelation,		0x00025e8b, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelation,		0x00025e8c, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelationW,		0x00025e8d, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelations,		0x00025e8e, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelationsW,		0x00025e8f, 0, 0);

// Container
DEFINE_OLEGUID(IID30_IDAOContainer,		0x00025e94, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainerW,		0x00025e95, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainers,		0x00025e96, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainersW,		0x00025e97, 0, 0);

// Document
DEFINE_OLEGUID(IID30_IDAODocument,		0x00025e9c, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocumentW,		0x00025e9d, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocuments,		0x00025e9e, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocumentsW,		0x00025e9f, 0, 0);

// Collections
DEFINE_OLEGUID(IID30_IDAOCollection,		0x00025ea4, 0, 0);
DEFINE_OLEGUID(IID30_IDAODynaCollection,	0x00025ea5, 0, 0);

// Connection points
DEFINE_OLEGUID(IID30_IDAOQueryCP,			0x00025eaa, 0, 0);	// Connection point
DEFINE_OLEGUID(IID30_IDAOQueryAS,			0x00025eab, 0, 0);	// Advise sink interface
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dbnetlib.h ===
// DBNETLIB.H  -This file contains Windows NT Net-Library prototypes and defines
#ifndef _DBNETLIB_H_
#define _DBNETLIB_H_

#define NETERR		LONG	
#define TIMEINT	    USHORT
#define RETCODE   int
#define IOINT		USHORT

// Special neterr values
#define NETE_NOTSUPPORTED   109
#define NETE_TIMEOUT        -2
#define NETE_ERROR        	-1	
#define NETE_DUPLICATE      -4		
#define NETE_NOT_CONNECTED  233	
#define ENUM_SUCCESS		0
#define MORE_DATA			1
#define NET_NOT_AVAIL		2
#define NETE_NOMAP              0
#define NETE_NOMEMORY           1
#define NETE_NOACCESS           2
#define NETE_CONNBUSY           3
#define NETE_CONNBROKEN         4
#define NETE_TOOMANYCONN        5
#define NETE_SERVERNOTFOUND     6
#define NETE_NETNOTSTARTED      7
#define NETE_NORESOURCE         8
#define NETE_NETBUSY            9
#define NETE_NONETACCESS        10
#define NETE_GENERAL            11
#define NETE_CONNMODE           12
#define NETE_NAMENOTFOUND       13
#define NETE_INVALIDCONN        14
#define NETE_NETDATAERR         15
#define NETE_TOOMANYFILES       16
#define NETE_CANTCONNECT		17
#define NETE_SSLSEC             18
#define NETE_ENCRYPT_REQ        19
#define NETE_ENCRYPT_NOTSUP     20

typedef enum { NLOPT_SET_ENCRYPT, 
			   NLOPT_SET_PACKET_SIZE } OPT_REQUEST;

typedef struct _OPTSTRUCT
{
	int   iSize;
	BOOL  fEncrypt;
	OPT_REQUEST iRequest;
	DWORD dwPacketSize;
} 
OPTSTRUCT;

// Super Socket support with eventually be the only NETLIB support for
// both SQL Servers and their clients.  For now we will still include the
// original NETLIB definitions.
//

IOINT ConnectionObjectSize( void );

IOINT ConnectionRead( void *,
                                  BYTE *,
                                  IOINT,
                                  IOINT,
                                  TIMEINT,
                                  NETERR UNALIGNED * );

IOINT ConnectionWrite( void *,
                                   BYTE *,
                                   IOINT,
                                   NETERR UNALIGNED * );

IOINT ConnectionTransact( void *,
                                      BYTE *,
                                      BYTE *,
                                      IOINT,
                                      IOINT,
                                      IOINT,
                                      TIMEINT,
                                      NETERR UNALIGNED * );

IOINT ConnectionWriteOOB( void *,
                                      BYTE *,
                                      IOINT,
                                      NETERR UNALIGNED * );

RETCODE ConnectionOpen( void *,
                                    CHAR *,
                                    NETERR  * );

RETCODE ConnectionOpenW( void *,
                                     WCHAR *,
                                     NETERR * );

RETCODE ConnectionClose( void *,
                                     NETERR UNALIGNED * );

RETCODE ConnectionCheckForData( void *,
                                            LONG *,
                                            NETERR UNALIGNED * );

BOOL ConnectionError( void *,
                                  NETERR *,
                                  CHAR **,
                                  NETERR * );

BOOL ConnectionErrorW( void *,
                                   NETERR *,
                                   WCHAR **,
                                   NETERR * );

ULONG ConnectionVer(void);

ULONG ConnectionSqlVer( void * );

RETCODE ConnectionServerEnum( CHAR *,
										  IOINT,
										  IOINT UNALIGNED * );

RETCODE ConnectionServerEnumW( WCHAR *,
										   ULONG,
										   IOINT UNALIGNED * );

BOOL ConnectionOption( void * ,
                                   OPTSTRUCT * );

void ConnectionGetSvrUser( void * , 
                           char * );

HANDLE InitEnumServers( LPWSTR , 
                        LPWSTR );

BOOL GetNextEnumeration( HANDLE , 
                         BYTE * , 
                         int * );

void CloseEnumServers( HANDLE );

BOOL InitSSPIPackage (DWORD *pcbMaxMessage);

BOOL TermSSPIPackage (void);

BOOL GenClientContext (DWORD dwKey, BYTE *pIn, DWORD cbIn, BYTE *pOut, DWORD *pcbOut, BOOL *pfDone, CHAR *szUserName);

BOOL InitSession (DWORD dwKey);

BOOL TermSession (DWORD dwKey);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dciman.h ===
/****************************************************************************

 DCIMAN.H

 Copyright (C) 1993-1999 Microsoft Corporation.  All Rights Reserved.

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"         // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

DECLARE_HANDLE(HWINWATCH);  // context handle for WinWatch instance

/****************************************************************************
 ***************************************************************************/

extern HDC WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, DWORD dwCompression, DWORD dwRedMask,
    DWORD dwGreenMask, DWORD dwBlueMask, DWORD dwWidth, DWORD dwHeight,
    DWORD dwDCICaps, DWORD dwBitCount, LPDCIOFFSCREEN FAR *lplpSurface);
extern int WINAPI DCICreateOverlay(HDC hdc, LPVOID lpOffscreenSurf,
    LPDCIOVERLAY FAR *lplpSurface);
extern int WINAPI DCIEnum(HDC hdc, LPRECT lprDst, LPRECT lprSrc, LPVOID lpFnCallback,
    LPVOID lpContext);
extern DCIRVAL WINAPI DCISetSrcDestClip(LPDCIOFFSCREEN pdci, LPRECT srcrc,
			LPRECT destrc, LPRGNDATA prd );

extern HWINWATCH WINAPI WinWatchOpen(HWND hwnd);
extern void      WINAPI WinWatchClose(HWINWATCH hWW);

// API changed to copy region data instead of return pointer to it
extern UINT	 WINAPI WinWatchGetClipList(HWINWATCH hWW, LPRECT prc,
				UINT size,  LPRGNDATA prd);
extern BOOL      WINAPI WinWatchDidStatusChange(HWINWATCH hWW);

extern DWORD     WINAPI GetWindowRegionData(HWND hwnd, DWORD size, LPRGNDATA prd);
extern DWORD     WINAPI GetDCRegionData(HDC hdc, DWORD size, LPRGNDATA prd);


#define WINWATCHNOTIFY_START        0
#define WINWATCHNOTIFY_STOP         1
#define WINWATCHNOTIFY_DESTROY      2
#define WINWATCHNOTIFY_CHANGING     3
#define WINWATCHNOTIFY_CHANGED      4
typedef void (CALLBACK *WINWATCHNOTIFYPROC)(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam);

extern BOOL WINAPI WinWatchNotify(HWINWATCH hWW, WINWATCHNOTIFYPROC NotifyCallback,
						LPARAM NotifyParam );

#ifdef WIN32
/****************************************************************************
 helper functions to call DCIMAN16.DLL
 ***************************************************************************/
extern void WINAPI DCIEndAccess(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
extern void WINAPI DCIDestroy(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIDraw(LPDCIOFFSCREEN pdci);
extern DCIRVAL WINAPI DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd);
extern DCIRVAL WINAPI DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src);


#else

extern int WINAPI DCISendCommand(HDC hdc, VOID FAR *pcmd, int nSize, VOID FAR * FAR * lplpOut);

/****************************************************************************
 helper macros to call DCI callbacks
 ***************************************************************************/
__inline void DCIDestroy(LPDCISURFACEINFO pdci)
{
	if( pdci->DestroySurface != NULL ) {
		pdci->DestroySurface(pdci);
	}
}

__inline void DCIEndAccess(LPDCISURFACEINFO pdci)
{
	if( pdci->EndAccess != NULL ) {
		pdci->EndAccess(pdci);
	}
}

__inline DCIRVAL DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy)
{
    RECT rc;

	if( pdci->BeginAccess != NULL ) {
		rc.left=x;
		rc.top=y;
		rc.right = rc.left+dx;
		rc.bottom = rc.top+dy;
		return pdci->BeginAccess(pdci, &rc);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCIDraw(LPDCIOFFSCREEN pdci)
{
	if( pdci->Draw != NULL ) {
		return pdci->Draw(pdci);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd)
{
	if( pdci->SetClipList != NULL ) {
		return pdci->SetClipList(pdci, prd);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src)
{
	if( pdci->SetDestination != NULL ) {
		return pdci->SetDestination(pdci, dst, src);
	} else {
		return DCI_OK;
	}
}
#endif

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\davclnt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    DavClnt.h

Abstract:

    This module defines the DAV specific functions that are exposed to the user

Revision History:

--*/

#ifndef _DAV_CLNT_H_
#define _DAV_CLNT_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
WINAPI
DavAddConnection(
    __inout HANDLE *ConnectionHandle,
    __in LPCWSTR RemoteName,
    __in_opt LPCWSTR UserName,
    __in_opt LPCWSTR Password,
    __in_bcount(CertSize) PBYTE ClientCert,
    __in DWORD CertSize
    );

DWORD
WINAPI
DavDeleteConnection(
    __in HANDLE ConnectionHandle
    );

DWORD
WINAPI
DavGetUNCFromHTTPPath (
    __in LPCWSTR  HttpPath,
    __out_ecount(*lpSize) LPWSTR UncPath,
    IN OUT  LPDWORD lpSize
    );

DWORD
WINAPI
DavGetHTTPFromUNCPath (
    __in LPCWSTR  UncPath,
    __out_ecount(*lpSize) LPWSTR HttpPath,
    IN OUT  LPDWORD lpSize
    );

DWORD
WINAPI
DavGetTheLockOwnerOfTheFile(
    __in LPCWSTR FileName,
    __out_bcount_opt(*LockOwnerNameLengthInBytes) PWSTR LockOwnerName,
    __inout PULONG LockOwnerNameLengthInBytes
    );

DWORD
WINAPI
DavGetExtendedError(
    __in HANDLE hFile,
    __out DWORD *ExtError,
    __out_ecount(*cChSize) LPWSTR ExtErrorString,
    __inout DWORD *cChSize
    );

DWORD
WINAPI
DavFlushFile(
    __in HANDLE hFile
    );
	
DWORD
WINAPI
DavInvalidateCache(
	__in LPWSTR URLName
	);
        
DWORD
APIENTRY
DavCancelConnectionsToServer(
    __in LPWSTR lpName,
    BOOL fForce
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dbdaoint.h ===
/************************************************************************ 
**	D B D A O I N T. H													*
**																		*
************************************************************************* 
** Copyright (C) 1995-1997 by Microsoft Corporation						*
**		   All Rights Reserved					 						*
************************************************************************/ 
/*
 DBDAOINT.H
 OLE DAO Interface.  
This is a part of the Microsoft Data Access Objects SDK library.
See the dao*.hlp files for detailed information regarding the
Microsoft Data Access Objects SDK product.
 
*/
#ifndef _DBDAOINT_H_
#define _DBDAOINT_H_

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

// Forwards
interface _DAODBEngine;
#define DAODBEngine _DAODBEngine
interface DAOError;
interface _DAOCollection;
#define DAOCollection _DAOCollection
interface DAOErrors;
interface DAOProperty;
interface _DAODynaCollection;
#define DAODynaCollection _DAODynaCollection
interface DAOProperties;
interface DAOWorkspace;
interface DAOWorkspaces;
interface DAOConnection;
interface DAOConnections;
interface DAODatabase;
interface DAODatabases;
interface _DAOTableDef;
#define DAOTableDef _DAOTableDef
interface DAOTableDefs;
interface _DAOQueryDef;
#define DAOQueryDef _DAOQueryDef
interface DAOQueryDefs;
interface DAORecordset;
interface DAORecordsets;
interface _DAOField;
#define DAOField _DAOField
interface DAOFields;
interface _DAOIndex;
#define DAOIndex _DAOIndex
interface DAOIndexes;
interface DAOParameter;
interface DAOParameters;
interface _DAOUser;
#define DAOUser _DAOUser
interface DAOUsers;
interface _DAOGroup;
#define DAOGroup _DAOGroup
interface DAOGroups;
interface _DAORelation;
#define DAORelation _DAORelation
interface DAORelations;
interface DAOContainer;
interface DAOContainers;
interface DAODocument;
interface DAODocuments;
interface DAOIndexFields;



typedef enum RecordsetTypeEnum
    {	dbOpenTable	= 1,
	dbOpenDynaset	= 2,
	dbOpenSnapshot	= 4,
	dbOpenForwardOnly	= 8,
	dbOpenDynamic	= 16
    }	RecordsetTypeEnum;


typedef enum EditModeEnum
    {	dbEditNone	= 0,
	dbEditInProgress	= 1,
	dbEditAdd	= 2,
	dbEditChanged	= 4,
	dbEditDeleted	= 8,
	dbEditNew	= 16
    }	EditModeEnum;


typedef enum RecordsetOptionEnum
    {	dbDenyWrite	= 0x1,
	dbDenyRead	= 0x2,
	dbReadOnly	= 0x4,
	dbAppendOnly	= 0x8,
	dbInconsistent	= 0x10,
	dbConsistent	= 0x20,
	dbSQLPassThrough	= 0x40,
	dbFailOnError	= 0x80,
	dbForwardOnly	= 0x100,
	dbSeeChanges	= 0x200,
	dbRunAsync	= 0x400,
	dbExecDirect	= 0x800
    }	RecordsetOptionEnum;


typedef enum LockTypeEnum
    {	dbPessimistic	= 0x2,
	dbOptimistic	= 0x3,
	dbOptimisticValue	= 0x1,
	dbOptimisticBatch	= 0x5
    }	LockTypeEnum;


typedef enum UpdateCriteriaEnum
    {	dbCriteriaKey	= 0x1,
	dbCriteriaModValues	= 0x2,
	dbCriteriaAllCols	= 0x4,
	dbCriteriaTimestamp	= 0x8,
	dbCriteriaDeleteInsert	= 0x10,
	dbCriteriaUpdate	= 0x20
    }	UpdateCriteriaEnum;


typedef enum FieldAttributeEnum
    {	dbFixedField	= 0x1,
	dbVariableField	= 0x2,
	dbAutoIncrField	= 0x10,
	dbUpdatableField	= 0x20,
	dbSystemField	= 0x2000,
	dbHyperlinkField	= 0x8000,
	dbDescending	= 0x1
    }	FieldAttributeEnum;


typedef enum DataTypeEnum
    {	dbBoolean	= 1,
	dbByte	= 2,
	dbInteger	= 3,
	dbLong	= 4,
	dbCurrency	= 5,
	dbSingle	= 6,
	dbDouble	= 7,
	dbDate	= 8,
	dbBinary	= 9,
	dbText	= 10,
	dbLongBinary	= 11,
	dbMemo	= 12,
	dbGUID	= 15,
	dbBigInt	= 16,
	dbVarBinary	= 17,
	dbChar	= 18,
	dbNumeric	= 19,
	dbDecimal	= 20,
	dbFloat	= 21,
	dbTime	= 22,
	dbTimeStamp	= 23
    }	DataTypeEnum;


typedef enum RelationAttributeEnum
    {	dbRelationUnique	= 0x1,
	dbRelationDontEnforce	= 0x2,
	dbRelationInherited	= 0x4,
	dbRelationUpdateCascade	= 0x100,
	dbRelationDeleteCascade	= 0x1000,
	dbRelationLeft	= 0x1000000,
	dbRelationRight	= 0x2000000
    }	RelationAttributeEnum;


typedef enum TableDefAttributeEnum
    {	dbAttachExclusive	= 0x10000,
	dbAttachSavePWD	= 0x20000,
	dbSystemObject	= 0x80000002,
	dbAttachedTable	= 0x40000000,
	dbAttachedODBC	= 0x20000000,
	dbHiddenObject	= 0x1
    }	TableDefAttributeEnum;


typedef enum QueryDefTypeEnum
    {	dbQSelect	= 0,
	dbQProcedure	= 0xe0,
	dbQAction	= 0xf0,
	dbQCrosstab	= 0x10,
	dbQDelete	= 0x20,
	dbQUpdate	= 0x30,
	dbQAppend	= 0x40,
	dbQMakeTable	= 0x50,
	dbQDDL	= 0x60,
	dbQSQLPassThrough	= 0x70,
	dbQSetOperation	= 0x80,
	dbQSPTBulk	= 0x90,
	dbQCompound	= 0xa0
    }	QueryDefTypeEnum;


typedef enum QueryDefStateEnum
    {	dbQPrepare	= 1,
	dbQUnprepare	= 2
    }	QueryDefStateEnum;


typedef enum DatabaseTypeEnum
    {	dbVersion10	= 1,
	dbEncrypt	= 2,
	dbDecrypt	= 4,
	dbVersion11	= 8,
	dbVersion20	= 16,
	dbVersion30	= 32,
	dbVersion40	= 64
    }	DatabaseTypeEnum;


typedef enum CollatingOrderEnum
    {	dbSortNeutral	= 0x400,
	dbSortArabic	= 0x401,
	dbSortCyrillic	= 0x419,
	dbSortCzech	= 0x405,
	dbSortDutch	= 0x413,
	dbSortGeneral	= 0x409,
	dbSortGreek	= 0x408,
	dbSortHebrew	= 0x40d,
	dbSortHungarian	= 0x40e,
	dbSortIcelandic	= 0x40f,
	dbSortNorwdan	= 0x406,
	dbSortPDXIntl	= 0x409,
	dbSortPDXNor	= 0x406,
	dbSortPDXSwe	= 0x41d,
	dbSortPolish	= 0x415,
	dbSortSpanish	= 0x40a,
	dbSortSwedFin	= 0x41d,
	dbSortTurkish	= 0x41f,
	dbSortJapanese	= 0x411,
	dbSortChineseSimplified	= 0x804,
	dbSortChineseTraditional	= 0x404,
	dbSortKorean	= 0x412,
	dbSortThai	= 0x41e,
	dbSortSlovenian	= 0x424,
	dbSortUndefined	= -1
    }	CollatingOrderEnum;


typedef enum IdleEnum
    {	dbFreeLocks	= 1,
	dbRefreshCache	= 8
    }	IdleEnum;


typedef enum PermissionEnum
    {	dbSecNoAccess	= 0,
	dbSecFullAccess	= 0xfffff,
	dbSecDelete	= 0x10000,
	dbSecReadSec	= 0x20000,
	dbSecWriteSec	= 0x40000,
	dbSecWriteOwner	= 0x80000,
	dbSecDBCreate	= 0x1,
	dbSecDBOpen	= 0x2,
	dbSecDBExclusive	= 0x4,
	dbSecDBAdmin	= 0x8,
	dbSecCreate	= 0x1,
	dbSecReadDef	= 0x4,
	dbSecWriteDef	= 0x1000c,
	dbSecRetrieveData	= 0x14,
	dbSecInsertData	= 0x20,
	dbSecReplaceData	= 0x40,
	dbSecDeleteData	= 0x80
    }	PermissionEnum;


typedef enum SynchronizeTypeEnum
    {	dbRepExportChanges	= 0x1,
	dbRepImportChanges	= 0x2,
	dbRepImpExpChanges	= 0x4,
	dbRepSyncInternet	= 0x10
    }	SynchronizeTypeEnum;


typedef enum ReplicaTypeEnum
    {	dbRepMakeReadOnly	= 0x2,
	dbRepMakePartial	= 0x1
    }	ReplicaTypeEnum;


typedef enum WorkspaceTypeEnum
    {	dbUseODBC	= 1,
	dbUseJet	= 2
    }	WorkspaceTypeEnum;


typedef enum CursorDriverEnum
    {	dbUseDefaultCursor	= -1,
	dbUseODBCCursor	= 1,
	dbUseServerCursor	= 2,
	dbUseClientBatchCursor	= 3,
	dbUseNoCursor	= 4
    }	CursorDriverEnum;


typedef enum DriverPromptEnum
    {	dbDriverPrompt	= 2,
	dbDriverNoPrompt	= 1,
	dbDriverComplete	= 0,
	dbDriverCompleteRequired	= 3
    }	DriverPromptEnum;


typedef enum SetOptionEnum
    {	dbPageTimeout	= 6,
	dbLockRetry	= 57,
	dbMaxBufferSize	= 8,
	dbUserCommitSync	= 58,
	dbImplicitCommitSync	= 59,
	dbExclusiveAsyncDelay	= 60,
	dbSharedAsyncDelay	= 61,
	dbMaxLocksPerFile	= 62,
	dbLockDelay	= 63,
	dbRecycleLVs	= 65,
	dbFlushTransactionTimeout	= 66
    }	SetOptionEnum;


typedef enum ParameterDirectionEnum
    {	dbParamInput	= 1,
	dbParamOutput	= 2,
	dbParamInputOutput	= 3,
	dbParamReturnValue	= 4
    }	ParameterDirectionEnum;


typedef enum UpdateTypeEnum
    {	dbUpdateBatch	= 4,
	dbUpdateRegular	= 1,
	dbUpdateCurrentRecord	= 2
    }	UpdateTypeEnum;


typedef enum RecordStatusEnum
    {	dbRecordUnmodified	= 0,
	dbRecordModified	= 1,
	dbRecordNew	= 2,
	dbRecordDeleted	= 3,
	dbRecordDBDeleted	= 4
    }	RecordStatusEnum;


typedef enum CommitTransOptionsEnum
    {	dbForceOSFlush	= 1
    }	CommitTransOptionsEnum;


typedef enum _DAOSuppHelp
    {	LogMessages	= 0,
	KeepLocal	= 0,
	Replicable	= 0,
	ReplicableBool	= 0,
	V1xNullBehavior	= 0
    }	_DAOSuppHelp;

#define dbLangArabic _T(";LANGID=0x0401;CP=1256;COUNTRY=0")
#define dbLangCzech _T(";LANGID=0x0405;CP=1250;COUNTRY=0")
#define dbLangDutch _T(";LANGID=0x0413;CP=1252;COUNTRY=0")
#define dbLangGeneral _T(";LANGID=0x0409;CP=1252;COUNTRY=0")
#define dbLangGreek _T(";LANGID=0x0408;CP=1253;COUNTRY=0")
#define dbLangHebrew _T(";LANGID=0x040D;CP=1255;COUNTRY=0")
#define dbLangHungarian _T(";LANGID=0x040E;CP=1250;COUNTRY=0")
#define dbLangIcelandic _T(";LANGID=0x040F;CP=1252;COUNTRY=0")
#define dbLangNordic _T(";LANGID=0x041D;CP=1252;COUNTRY=0")
#define dbLangNorwDan _T(";LANGID=0x0414;CP=1252;COUNTRY=0")
#define dbLangPolish _T(";LANGID=0x0415;CP=1250;COUNTRY=0")
#define dbLangCyrillic _T(";LANGID=0x0419;CP=1251;COUNTRY=0")
#define dbLangSpanish _T(";LANGID=0x040A;CP=1252;COUNTRY=0")
#define dbLangSwedFin _T(";LANGID=0x040B;CP=1252;COUNTRY=0")
#define dbLangTurkish _T(";LANGID=0x041F;CP=1254;COUNTRY=0")
#define dbLangJapanese _T(";LANGID=0x0411;CP=932;COUNTRY=0")
#define dbLangChineseSimplified _T(";LANGID=0x0804;CP=936;COUNTRY=0")
#define dbLangChineseTraditional _T(";LANGID=0x0404;CP=950;COUNTRY=0")
#define dbLangKorean _T(";LANGID=0x0412;CP=949;COUNTRY=0")
#define dbLangThai _T(";LANGID=0x041E;CP=874;COUNTRY=0")
#define dbLangSlovenian _T(";LANGID=0x0424;CP=1250;COUNTRY=0")
// Interface: _DAOCollection
#undef INTERFACE
#define INTERFACE _DAOCollection
DECLARE_INTERFACE_(_DAOCollection, IDispatch)
	{
	STDMETHOD(get_Count)						 (THIS_ short FAR* c) PURE;
	STDMETHOD(_NewEnum)							 (THIS_ IUnknown * FAR* ppunk) PURE;
	STDMETHOD(Refresh)							 (THIS) PURE;
	};
 
// Interface: _DAODynaCollection
#undef INTERFACE
#define INTERFACE _DAODynaCollection
DECLARE_INTERFACE_(_DAODynaCollection, _DAOCollection)
	{
	STDMETHOD(Append)							 (THIS_ IDispatch * Object) PURE;
	STDMETHOD(Delete)							 (THIS_ BSTR Name) PURE;
	};
 
// Interface: _DAO
#undef INTERFACE
#define INTERFACE _DAO
DECLARE_INTERFACE_(_DAO, IDispatch)
	{
	STDMETHOD(get_Properties)					 (THIS_ DAOProperties FAR* FAR* ppprops) PURE;
	};
// Interface: _DAODBEngine
#undef INTERFACE
#define INTERFACE _DAODBEngine
DECLARE_INTERFACE_(_DAODBEngine, _DAO)
{
	STDMETHOD( get_Properties )						(
			/* [retval][out] */ DAOProperties __RPC_FAR *__RPC_FAR *ppprops );
	STDMETHOD( get_Version )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_IniPath )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_IniPath )					 ( 
    
 /* [in] */ BSTR path ) PURE;
	STDMETHOD( put_DefaultUser )				 ( 
    
 /* [in] */ BSTR user ) PURE;
	STDMETHOD( put_DefaultPassword )			 ( 
    
 /* [in] */ BSTR pw ) PURE;
	STDMETHOD( get_LoginTimeout )				 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_LoginTimeout )				 ( 
    
 /* [in] */ short Timeout ) PURE;
	STDMETHOD( get_Workspaces )					 ( 
    
 /* [retval][out] */ DAOWorkspaces __RPC_FAR *__RPC_FAR *ppworks ) PURE;
	STDMETHOD( get_Errors )						 ( 
    
 /* [retval][out] */ DAOErrors __RPC_FAR *__RPC_FAR *pperrs ) PURE;
	STDMETHOD( Idle )							 ( 
    
 /* [optional][in] */ VARIANT Action ) PURE;
	STDMETHOD( CompactDatabase )				 ( 
    
 /* [in] */ BSTR SrcName,
 /* [in] */ BSTR DstName,
 /* [optional][in] */ VARIANT DstLocale,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT SrcLocale ) PURE;
	STDMETHOD( RepairDatabase )					 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( RegisterDatabase )				 ( 
    
 /* [in] */ BSTR Dsn,
 /* [in] */ BSTR Driver,
 /* [in] */ VARIANT_BOOL Silent,
 /* [in] */ BSTR Attributes ) PURE;
	STDMETHOD( _30_CreateWorkspace )			 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR UserName,
 /* [in] */ BSTR Password,
 /* [retval][out] */ DAOWorkspace __RPC_FAR *__RPC_FAR *ppwrk ) PURE;
	STDMETHOD( OpenDatabase )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT ReadOnly,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	STDMETHOD( CreateDatabase )					 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR Locale,
 /* [optional][in] */ VARIANT Option,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	STDMETHOD( FreeLocks )						 ( 
   			VOID ) PURE;
	STDMETHOD( BeginTrans )						 ( 
   			VOID ) PURE;
	STDMETHOD( CommitTrans )					 ( 
    
 /* [defaultvalue][in] */ long Option ) PURE;
	STDMETHOD( Rollback )						 ( 
   			VOID ) PURE;
	STDMETHOD( SetDefaultWorkspace )			 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR Password ) PURE;
	STDMETHOD( SetDataAccessOption )			 ( 
    
 /* [in] */ short Option,
 /* [in] */ VARIANT Value ) PURE;
	STDMETHOD( ISAMStats )						 ( 
    
 /* [in] */ long StatNum,
 /* [optional][in] */ VARIANT Reset,
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_SystemDB )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_SystemDB )					 ( 
    
 /* [in] */ BSTR SystemDBPath ) PURE;
	STDMETHOD( CreateWorkspace )				 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR UserName,
 /* [in] */ BSTR Password,
 /* [optional][in] */ VARIANT UseType,
 /* [retval][out] */ DAOWorkspace __RPC_FAR *__RPC_FAR *ppwrk ) PURE;
	STDMETHOD( OpenConnection )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT ReadOnly,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppconn ) PURE;
	STDMETHOD( get_DefaultType )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *Option ) PURE;
	STDMETHOD( put_DefaultType )				 ( 
    
 /* [in] */ long Option ) PURE;
	STDMETHOD( SetOption )						 ( 
    
 /* [in] */ LONG Option,
 /* [in] */ VARIANT Value ) PURE;
	STDMETHOD( DumpObjects )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( DebugPrint )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	};// end interface;

// Interface: DAOError
#undef INTERFACE
#define INTERFACE DAOError
DECLARE_INTERFACE_(DAOError, IDispatch)
{
	STDMETHOD( get_Number )						 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Source )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Description )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_HelpFile )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_HelpContext )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	};// end interface;

// Interface: DAOErrors
#undef INTERFACE
#define INTERFACE DAOErrors
DECLARE_INTERFACE_(DAOErrors, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOError __RPC_FAR *__RPC_FAR *pperr ) PURE;
	};// end interface;

// Interface: DAOProperty
#undef INTERFACE
#define INTERFACE DAOProperty
DECLARE_INTERFACE_(DAOProperty, _DAO)
{
	STDMETHOD( get_Value )						 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pval ) PURE;
	STDMETHOD( put_Value )						 ( 
    
 /* [in] */ VARIANT val ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *ptype ) PURE;
	STDMETHOD( put_Type )						 ( 
    
 /* [in] */ short type ) PURE;
	STDMETHOD( get_Inherited )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	};// end interface;

// Interface: DAOProperties
#undef INTERFACE
#define INTERFACE DAOProperties
DECLARE_INTERFACE_(DAOProperties, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *ppprop ) PURE;
	};// end interface;

// Interface: DAOWorkspace
#undef INTERFACE
#define INTERFACE DAOWorkspace
DECLARE_INTERFACE_(DAOWorkspace, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( get_UserName )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put__30_UserName )				 ( 
    
 /* [in] */ BSTR UserName ) PURE;
	STDMETHOD( put__30_Password )				 ( 
    
 /* [in] */ BSTR Password ) PURE;
	STDMETHOD( get_IsolateODBCTrans )			 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_IsolateODBCTrans )			 ( 
    
 /* [in] */ short s ) PURE;
	STDMETHOD( get_Databases )					 ( 
    
 /* [retval][out] */ DAODatabases __RPC_FAR *__RPC_FAR *ppdbs ) PURE;
	STDMETHOD( get_Users )						 ( 
    
 /* [retval][out] */ DAOUsers __RPC_FAR *__RPC_FAR *ppusrs ) PURE;
	STDMETHOD( get_Groups )						 ( 
    
 /* [retval][out] */ DAOGroups __RPC_FAR *__RPC_FAR *ppgrps ) PURE;
	STDMETHOD( BeginTrans )						 ( 
   			VOID ) PURE;
	STDMETHOD( CommitTrans )					 ( 
    
 /* [defaultvalue][in] */ long Options ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( Rollback )						 ( 
   			VOID ) PURE;
	STDMETHOD( OpenDatabase )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT ReadOnly,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	STDMETHOD( CreateDatabase )					 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR Connect,
 /* [optional][in] */ VARIANT Option,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	STDMETHOD( CreateUser )						 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT PID,
 /* [optional][in] */ VARIANT Password,
 /* [retval][out] */ DAOUser __RPC_FAR *__RPC_FAR *ppusr ) PURE;
	STDMETHOD( CreateGroup )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT PID,
 /* [retval][out] */ DAOGroup __RPC_FAR *__RPC_FAR *ppgrp ) PURE;
	STDMETHOD( OpenConnection )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT ReadOnly,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppconn ) PURE;
	STDMETHOD( get_LoginTimeout )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pTimeout ) PURE;
	STDMETHOD( put_LoginTimeout )				 ( 
    
 /* [in] */ long Timeout ) PURE;
	STDMETHOD( get_DefaultCursorDriver )		 ( 
    
 /* [retval][out] */ long __RPC_FAR *pCursorType ) PURE;
	STDMETHOD( put_DefaultCursorDriver )		 ( 
    
 /* [in] */ long CursorType ) PURE;
	STDMETHOD( get_hEnv )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *phEnv ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *ptype ) PURE;
	STDMETHOD( get_Connections )				 ( 
    
 /* [retval][out] */ DAOConnections __RPC_FAR *__RPC_FAR *ppcns ) PURE;
	};// end interface;

// Interface: DAOWorkspaces
#undef INTERFACE
#define INTERFACE DAOWorkspaces
DECLARE_INTERFACE_(DAOWorkspaces, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOWorkspace __RPC_FAR *__RPC_FAR *ppwrk ) PURE;
	};// end interface;

// Interface: DAOConnection
#undef INTERFACE
#define INTERFACE DAOConnection
DECLARE_INTERFACE_(DAOConnection, IDispatch)
{
	STDMETHOD( QueryInterface )					 ( REFIID riid, LPVOID FAR* ppvObj );
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Connect )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Database )					 ( 
    
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppDb ) PURE;
	STDMETHOD( get_hDbc )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *phDbc ) PURE;
	STDMETHOD( get_QueryTimeout )				 ( 
    
 /* [retval][out] */ SHORT __RPC_FAR *pSeconds ) PURE;
	STDMETHOD( put_QueryTimeout )				 ( 
    
 /* [in] */ SHORT Seconds ) PURE;
	STDMETHOD( get_Transactions )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_RecordsAffected )			 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *pRecords ) PURE;
	STDMETHOD( get_StillExecuting )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStillExec ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStillExec ) PURE;
	STDMETHOD( get_QueryDefs )					 ( 
    
 /* [retval][out] */ DAOQueryDefs __RPC_FAR *__RPC_FAR *ppqdfs ) PURE;
	STDMETHOD( get_Recordsets )					 ( 
    
 /* [retval][out] */ DAORecordsets __RPC_FAR *__RPC_FAR *pprsts ) PURE;
	STDMETHOD( Cancel )							 ( 
   			VOID ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( CreateQueryDef )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT SQLText,
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( Execute )						 ( 
    
 /* [in] */ BSTR Query,
 /* [optional][in] */ VARIANT Options ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT LockEdit,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	};// end interface;

// Interface: DAOConnections
#undef INTERFACE
#define INTERFACE DAOConnections
DECLARE_INTERFACE_(DAOConnections, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppconn ) PURE;
	};// end interface;

// Interface: DAODatabase
#undef INTERFACE
#define INTERFACE DAODatabase
DECLARE_INTERFACE_(DAODatabase, _DAO)
{
	STDMETHOD( get_CollatingOrder )				 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Connect )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_QueryTimeout )				 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_QueryTimeout )				 ( 
    
 /* [in] */ short Timeout ) PURE;
	STDMETHOD( get_Transactions )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Version )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_RecordsAffected )			 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_TableDefs )					 ( 
    
 /* [retval][out] */ DAOTableDefs __RPC_FAR *__RPC_FAR *pptdfs ) PURE;
	STDMETHOD( get_QueryDefs )					 ( 
    
 /* [retval][out] */ DAOQueryDefs __RPC_FAR *__RPC_FAR *ppqdfs ) PURE;
	STDMETHOD( get_Relations )					 ( 
    
 /* [retval][out] */ DAORelations __RPC_FAR *__RPC_FAR *pprls ) PURE;
	STDMETHOD( get_Containers )					 ( 
    
 /* [retval][out] */ DAOContainers __RPC_FAR *__RPC_FAR *ppctns ) PURE;
	STDMETHOD( get_Recordsets )					 ( 
    
 /* [retval][out] */ DAORecordsets __RPC_FAR *__RPC_FAR *pprsts ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( Execute )						 ( 
    
 /* [in] */ BSTR Query,
 /* [optional][in] */ VARIANT Options ) PURE;
	STDMETHOD( _30_OpenRecordset )				 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	STDMETHOD( CreateRelation )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Table,
 /* [optional][in] */ VARIANT ForeignTable,
 /* [optional][in] */ VARIANT Attributes,
 /* [retval][out] */ DAORelation __RPC_FAR *__RPC_FAR *pprel ) PURE;
	STDMETHOD( CreateTableDef )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Attributes,
 /* [optional][in] */ VARIANT SourceTablename,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAOTableDef __RPC_FAR *__RPC_FAR *pptdf ) PURE;
	STDMETHOD( BeginTrans )						 ( 
   			VOID ) PURE;
	STDMETHOD( CommitTrans )					 ( 
    
 /* [defaultvalue][in] */ long Options ) PURE;
	STDMETHOD( Rollback )						 ( 
   			VOID ) PURE;
	STDMETHOD( CreateDynaset )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT Inconsistent,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateQueryDef )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT SQLText,
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( CreateSnapshot )					 ( 
    
 /* [in] */ BSTR Source,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( DeleteQueryDef )					 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( ExecuteSQL )						 ( 
    
 /* [in] */ BSTR SQL,
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( ListFields )						 ( 
    
 /* [in] */ BSTR Name,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( ListTables )						 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( OpenQueryDef )					 ( 
    
 /* [in] */ BSTR Name,
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( OpenTable )						 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( get_ReplicaID )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_DesignMasterID )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_DesignMasterID )				 ( 
    
 /* [in] */ BSTR MasterID ) PURE;
	STDMETHOD( Synchronize )					 ( 
    
 /* [in] */ BSTR DbPathName,
 /* [optional][in] */ VARIANT ExchangeType ) PURE;
	STDMETHOD( MakeReplica )					 ( 
    
 /* [in] */ BSTR PathName,
 /* [in] */ BSTR Description,
 /* [optional][in] */ VARIANT Options ) PURE;
	STDMETHOD( put_Connect )					 ( 
    
 /* [in] */ BSTR ODBCConnnect ) PURE;
	STDMETHOD( NewPassword )					 ( 
    
 /* [in] */ BSTR bstrOld,
 /* [in] */ BSTR bstrNew ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT LockEdit,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( get_Connection )					 ( 
    
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppCn ) PURE;
	STDMETHOD( PopulatePartial )				 ( 
    
 /* [in] */ BSTR DbPathName ) PURE;
	};// end interface;

// Interface: DAODatabases
#undef INTERFACE
#define INTERFACE DAODatabases
DECLARE_INTERFACE_(DAODatabases, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	};// end interface;

// Interface: _DAOTableDef
#undef INTERFACE
#define INTERFACE _DAOTableDef
DECLARE_INTERFACE_(_DAOTableDef, _DAO)
{
	STDMETHOD( get_Attributes )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Attributes )					 ( 
    
 /* [in] */ long Attributes ) PURE;
	STDMETHOD( get_Connect )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Connect )					 ( 
    
 /* [in] */ BSTR Connection ) PURE;
	STDMETHOD( get_DateCreated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_LastUpdated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( get_SourceTableName )			 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_SourceTableName )			 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_ValidationText )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ValidationText )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ValidationRule )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ValidationRule )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_RecordCount )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ DAOFields __RPC_FAR *__RPC_FAR *ppflds ) PURE;
	STDMETHOD( get_Indexes )					 ( 
    
 /* [retval][out] */ DAOIndexes __RPC_FAR *__RPC_FAR *ppidxs ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( RefreshLink )					 ( 
   			VOID ) PURE;
	STDMETHOD( CreateField )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Size,
 /* [retval][out] */ DAOField __RPC_FAR *__RPC_FAR *ppfld ) PURE;
	STDMETHOD( CreateIndex )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [retval][out] */ DAOIndex __RPC_FAR *__RPC_FAR *ppidx ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	STDMETHOD( get_ConflictTable )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_ReplicaFilter )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pFilter ) PURE;
	STDMETHOD( put_ReplicaFilter )				 ( 
    
 /* [in] */ VARIANT Filter ) PURE;
	};// end interface;

// Interface: DAOTableDefs
#undef INTERFACE
#define INTERFACE DAOTableDefs
DECLARE_INTERFACE_(DAOTableDefs, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOTableDef __RPC_FAR *__RPC_FAR *pptdf ) PURE;
	};// end interface;

// Interface: _DAOQueryDef
#undef INTERFACE
#define INTERFACE _DAOQueryDef
DECLARE_INTERFACE_(_DAOQueryDef, _DAO)
{
	STDMETHOD( get_DateCreated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_LastUpdated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ODBCTimeout )				 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_ODBCTimeout )				 ( 
    
 /* [in] */ short timeout ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *pi ) PURE;
	STDMETHOD( get_SQL )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_SQL )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Connect )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Connect )					 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ReturnsRecords )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_ReturnsRecords )				 ( 
    
 /* [in] */ VARIANT_BOOL f ) PURE;
	STDMETHOD( get_RecordsAffected )			 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ DAOFields __RPC_FAR *__RPC_FAR *ppflds ) PURE;
	STDMETHOD( get_Parameters )					 ( 
    
 /* [retval][out] */ DAOParameters __RPC_FAR *__RPC_FAR *ppprms ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( _30_OpenRecordset )				 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( _30__OpenRecordset )				 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( _Copy )							 ( 
    
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( Execute )						 ( 
    
 /* [optional][in] */ VARIANT Options ) PURE;
	STDMETHOD( Compare )						 ( 
    
 /* [in] */ DAOQueryDef __RPC_FAR *pQdef,
 /* [in] */ SHORT __RPC_FAR *lps ) PURE;
	STDMETHOD( CreateDynaset )					 ( 
    
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT Inconsistent,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateSnapshot )					 ( 
    
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( ListParameters )					 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT LockEdit,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( _OpenRecordset )					 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT LockEdit,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( Cancel )							 ( 
   			VOID ) PURE;
	STDMETHOD( get_hStmt )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *phStmt ) PURE;
	STDMETHOD( get_MaxRecords )					 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *pMxRecs ) PURE;
	STDMETHOD( put_MaxRecords )					 ( 
    
 /* [in] */ LONG MxRecs ) PURE;
	STDMETHOD( get_StillExecuting )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStillExec ) PURE;
	STDMETHOD( get_CacheSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *lCacheSize ) PURE;
	STDMETHOD( put_CacheSize )					 ( 
    
 /* [in] */ long lCacheSize ) PURE;
	STDMETHOD( get_Prepare )					 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Prepare )					 ( 
    
 /* [in] */ VARIANT f ) PURE;
	};// end interface;

// Interface: DAOQueryDefs
#undef INTERFACE
#define INTERFACE DAOQueryDefs
DECLARE_INTERFACE_(DAOQueryDefs, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdef ) PURE;
	};// end interface;

// Interface: DAORecordset
#undef INTERFACE
#define INTERFACE DAORecordset
DECLARE_INTERFACE_(DAORecordset, _DAO)
{
	STDMETHOD( GetIDsOfNames )					 (      REFIID riid,      OLECHAR FAR* FAR* rgszNames,      UINT cNames,      LCID lcid,      DISPID FAR* rgdispid );
	STDMETHOD( Invoke )							 (      DISPID dispidMember,      REFIID riid,      LCID lcid,      WORD wFlags,      DISPPARAMS FAR* pdispparams,      VARIANT FAR* pvarResult,      EXCEPINFO FAR* pexcepinfo,      UINT FAR* puArgErr );
	STDMETHOD( get_BOF )						 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Bookmark )					 ( 
    
 /* [retval][out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ppsach ) PURE;
	STDMETHOD( put_Bookmark )					 ( 
    
 /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *psach ) PURE;
	STDMETHOD( get_Bookmarkable )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_DateCreated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_EOF )						 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Filter )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Filter )						 ( 
    
 /* [in] */ BSTR Filter ) PURE;
	STDMETHOD( get_Index )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Index )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_LastModified )				 ( 
    
 /* [retval][out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ppsa ) PURE;
	STDMETHOD( get_LastUpdated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_LockEdits )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_LockEdits )					 ( 
    
 /* [in] */ VARIANT_BOOL Lock ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_NoMatch )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Sort )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Sort )						 ( 
    
 /* [in] */ BSTR Sort ) PURE;
	STDMETHOD( get_Transactions )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( get_RecordCount )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Restartable )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_ValidationText )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_ValidationRule )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_CacheStart )					 ( 
    
 /* [retval][out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ppsa ) PURE;
	STDMETHOD( put_CacheStart )					 ( 
    
 /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *psa ) PURE;
	STDMETHOD( get_CacheSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_CacheSize )					 ( 
    
 /* [in] */ long CacheSize ) PURE;
	STDMETHOD( get_PercentPosition )			 ( 
    
 /* [retval][out] */ float __RPC_FAR *pd ) PURE;
	STDMETHOD( put_PercentPosition )			 ( 
    
 /* [in] */ float Position ) PURE;
	STDMETHOD( get_AbsolutePosition )			 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_AbsolutePosition )			 ( 
    
 /* [in] */ long Position ) PURE;
	STDMETHOD( get_EditMode )					 ( 
    
 /* [retval][out] */ short __RPC_FAR *pi ) PURE;
	STDMETHOD( get_ODBCFetchCount )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_ODBCFetchDelay )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Parent )						 ( 
    
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *pdb ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ DAOFields __RPC_FAR *__RPC_FAR *ppflds ) PURE;
	STDMETHOD( get_Indexes )					 ( 
    
 /* [retval][out] */ DAOIndexes __RPC_FAR *__RPC_FAR *ppidxs ) PURE;
	STDMETHOD( _30_CancelUpdate )				 ( 
   			VOID ) PURE;
	STDMETHOD( AddNew )							 ( 
   			VOID ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( Delete )							 ( 
   			VOID ) PURE;
	STDMETHOD( Edit )							 ( 
   			VOID ) PURE;
	STDMETHOD( FindFirst )						 ( 
    
 /* [in] */ BSTR Criteria ) PURE;
	STDMETHOD( FindLast )						 ( 
    
 /* [in] */ BSTR Criteria ) PURE;
	STDMETHOD( FindNext )						 ( 
    
 /* [in] */ BSTR Criteria ) PURE;
	STDMETHOD( FindPrevious )					 ( 
    
 /* [in] */ BSTR Criteria ) PURE;
	STDMETHOD( MoveFirst )						 ( 
   			VOID ) PURE;
	STDMETHOD( _30_MoveLast )					 ( 
   			VOID ) PURE;
	STDMETHOD( MoveNext )						 ( 
   			VOID ) PURE;
	STDMETHOD( MovePrevious )					 ( 
   			VOID ) PURE;
	STDMETHOD( Seek )							 ( 
    
 /* [in] */ BSTR Comparison,
 /* [in] */ VARIANT Key1,
 /* [optional][in] */ VARIANT Key2,
 /* [optional][in] */ VARIANT Key3,
 /* [optional][in] */ VARIANT Key4,
 /* [optional][in] */ VARIANT Key5,
 /* [optional][in] */ VARIANT Key6,
 /* [optional][in] */ VARIANT Key7,
 /* [optional][in] */ VARIANT Key8,
 /* [optional][in] */ VARIANT Key9,
 /* [optional][in] */ VARIANT Key10,
 /* [optional][in] */ VARIANT Key11,
 /* [optional][in] */ VARIANT Key12,
 /* [optional][in] */ VARIANT Key13 ) PURE;
	STDMETHOD( _30_Update )						 ( 
   			VOID ) PURE;
	STDMETHOD( Clone )							 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( Requery )						 ( 
    
 /* [optional][in] */ VARIANT NewQueryDef ) PURE;
	STDMETHOD( Move )							 ( 
    
 /* [in] */ long Rows,
 /* [optional][in] */ VARIANT StartBookmark ) PURE;
	STDMETHOD( FillCache )						 ( 
    
 /* [optional][in] */ VARIANT Rows,
 /* [optional][in] */ VARIANT StartBookmark ) PURE;
	STDMETHOD( CreateDynaset )					 ( 
    
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT Inconsistent,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateSnapshot )					 ( 
    
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CopyQueryDef )					 ( 
    
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( ListFields )						 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( ListIndexes )					 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( GetRows )						 ( 
    
 /* [optional][in] */ VARIANT NumRows,
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_Collect )					 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( put_Collect )					 ( 
    
 /* [in] */ VARIANT Item,
 /* [in] */ VARIANT value ) PURE;
	STDMETHOD( Cancel )							 ( 
   			VOID ) PURE;
	STDMETHOD( NextRecordset )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_hStmt )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *phStmt ) PURE;
	STDMETHOD( get_StillExecuting )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStillExec ) PURE;
	STDMETHOD( get_BatchSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_BatchSize )					 ( 
    
 /* [in] */ long BatchSize ) PURE;
	STDMETHOD( get_BatchCollisionCount )		 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_BatchCollisions )			 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_Connection )					 ( 
    
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppCn ) PURE;
	STDMETHOD( putref_Connection )				 ( 
    
 /* [in] */ DAOConnection __RPC_FAR *pNewCn ) PURE;
	STDMETHOD( get_RecordStatus )				 ( 
    
 /* [retval][out] */ short __RPC_FAR *pi ) PURE;
	STDMETHOD( get_UpdateOptions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_UpdateOptions )				 ( 
    
 /* [in] */ long l ) PURE;
	STDMETHOD( CancelUpdate )					 ( 
    
 /* [defaultvalue][in] */ long UpdateType ) PURE;
	STDMETHOD( Update )							 ( 
    
 /* [defaultvalue][in] */ long UpdateType,
 /* [defaultvalue][in] */ VARIANT_BOOL Force ) PURE;
	STDMETHOD( MoveLast )						 ( 
    
 /* [defaultvalue][in] */ long Options ) PURE;
	};// end interface;

// Interface: DAORecordsets
#undef INTERFACE
#define INTERFACE DAORecordsets
DECLARE_INTERFACE_(DAORecordsets, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	};// end interface;

// Interface: _DAOField
#undef INTERFACE
#define INTERFACE _DAOField
DECLARE_INTERFACE_(_DAOField, _DAO)
{
	STDMETHOD( get_CollatingOrder )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_Type )						 ( 
    
 /* [in] */ short Type ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( get_Size )						 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Size )						 ( 
    
 /* [in] */ long Size ) PURE;
	STDMETHOD( get_SourceField )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_SourceTable )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Value )						 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( put_Value )						 ( 
    
 /* [in] */ VARIANT Val ) PURE;
	STDMETHOD( get_Attributes )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Attributes )					 ( 
    
 /* [in] */ long Attr ) PURE;
	STDMETHOD( get_OrdinalPosition )			 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_OrdinalPosition )			 ( 
    
 /* [in] */ short Pos ) PURE;
	STDMETHOD( get_ValidationText )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ValidationText )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ValidateOnSet )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_ValidateOnSet )				 ( 
    
 /* [in] */ VARIANT_BOOL Validate ) PURE;
	STDMETHOD( get_ValidationRule )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ValidationRule )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_DefaultValue )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( put_DefaultValue )				 ( 
    
 /* [in] */ VARIANT var ) PURE;
	STDMETHOD( get_Required )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Required )					 ( 
    
 /* [in] */ VARIANT_BOOL fReq ) PURE;
	STDMETHOD( get_AllowZeroLength )			 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_AllowZeroLength )			 ( 
    
 /* [in] */ VARIANT_BOOL fAllow ) PURE;
	STDMETHOD( get_DataUpdatable )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_ForeignName )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ForeignName )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( AppendChunk )					 ( 
    
 /* [in] */ VARIANT Val ) PURE;
	STDMETHOD( GetChunk )						 ( 
    
 /* [in] */ long Offset,
 /* [in] */ long Bytes,
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( _30_FieldSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	STDMETHOD( get_CollectionIndex )			 ( 
    
 /* [retval][out] */ short __RPC_FAR *i ) PURE;
	STDMETHOD( get_OriginalValue )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_VisibleValue )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_FieldSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	};// end interface;

// Interface: DAOFields
#undef INTERFACE
#define INTERFACE DAOFields
DECLARE_INTERFACE_(DAOFields, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOField __RPC_FAR *__RPC_FAR *ppfld ) PURE;
	};// end interface;

// Interface: _DAOIndex
#undef INTERFACE
#define INTERFACE _DAOIndex
DECLARE_INTERFACE_(_DAOIndex, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Foreign )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Unique )						 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Unique )						 ( 
    
 /* [in] */ VARIANT_BOOL fUnique ) PURE;
	STDMETHOD( get_Clustered )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Clustered )					 ( 
    
 /* [in] */ VARIANT_BOOL fClustered ) PURE;
	STDMETHOD( get_Required )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Required )					 ( 
    
 /* [in] */ VARIANT_BOOL fRequired ) PURE;
	STDMETHOD( get_IgnoreNulls )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_IgnoreNulls )				 ( 
    
 /* [in] */ VARIANT_BOOL fIgnoreNulls ) PURE;
	STDMETHOD( get_Primary )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Primary )					 ( 
    
 /* [in] */ VARIANT_BOOL fPrimary ) PURE;
	STDMETHOD( get_DistinctCount )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pv ) PURE;
	STDMETHOD( put_Fields )						 ( 
    
 /* [in] */ VARIANT v ) PURE;
	STDMETHOD( CreateField )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Size,
 /* [retval][out] */ DAOField __RPC_FAR *__RPC_FAR *ppfld ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	};// end interface;

// Interface: DAOIndexes
#undef INTERFACE
#define INTERFACE DAOIndexes
DECLARE_INTERFACE_(DAOIndexes, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOIndex __RPC_FAR *__RPC_FAR *ppidx ) PURE;
	};// end interface;

// Interface: DAOParameter
#undef INTERFACE
#define INTERFACE DAOParameter
DECLARE_INTERFACE_(DAOParameter, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Value )						 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( put_Value )						 ( 
    
 /* [in] */ VARIANT val ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_Type )						 ( 
    
 /* [in] */ short s ) PURE;
	STDMETHOD( get_Direction )					 ( 
    
 /* [retval][out] */ short __RPC_FAR *pOption ) PURE;
	STDMETHOD( put_Direction )					 ( 
    
 /* [in] */ short Option ) PURE;
	};// end interface;

// Interface: DAOParameters
#undef INTERFACE
#define INTERFACE DAOParameters
DECLARE_INTERFACE_(DAOParameters, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOParameter __RPC_FAR *__RPC_FAR *ppprm ) PURE;
	};// end interface;

// Interface: _DAOUser
#undef INTERFACE
#define INTERFACE _DAOUser
DECLARE_INTERFACE_(_DAOUser, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( put_PID )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( put_Password )					 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Groups )						 ( 
    
 /* [retval][out] */ DAOGroups __RPC_FAR *__RPC_FAR *ppgrps ) PURE;
	STDMETHOD( NewPassword )					 ( 
    
 /* [in] */ BSTR bstrOld,
 /* [in] */ BSTR bstrNew ) PURE;
	STDMETHOD( CreateGroup )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT PID,
 /* [retval][out] */ DAOGroup __RPC_FAR *__RPC_FAR *ppgrp ) PURE;
	};// end interface;

// Interface: DAOUsers
#undef INTERFACE
#define INTERFACE DAOUsers
DECLARE_INTERFACE_(DAOUsers, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOUser __RPC_FAR *__RPC_FAR *ppusr ) PURE;
	};// end interface;

// Interface: _DAOGroup
#undef INTERFACE
#define INTERFACE _DAOGroup
DECLARE_INTERFACE_(_DAOGroup, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( put_PID )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Users )						 ( 
    
 /* [retval][out] */ DAOUsers __RPC_FAR *__RPC_FAR *ppusrs ) PURE;
	STDMETHOD( CreateUser )						 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT PID,
 /* [optional][in] */ VARIANT Password,
 /* [retval][out] */ DAOUser __RPC_FAR *__RPC_FAR *ppusr ) PURE;
	};// end interface;

// Interface: DAOGroups
#undef INTERFACE
#define INTERFACE DAOGroups
DECLARE_INTERFACE_(DAOGroups, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOGroup __RPC_FAR *__RPC_FAR *ppgrp ) PURE;
	};// end interface;

// Interface: _DAORelation
#undef INTERFACE
#define INTERFACE _DAORelation
DECLARE_INTERFACE_(_DAORelation, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Table )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Table )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ForeignTable )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ForeignTable )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Attributes )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Attributes )					 ( 
    
 /* [in] */ long attr ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ DAOFields __RPC_FAR *__RPC_FAR *ppflds ) PURE;
	STDMETHOD( CreateField )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Size,
 /* [retval][out] */ DAOField __RPC_FAR *__RPC_FAR *ppfld ) PURE;
	STDMETHOD( get_PartialReplica )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPartialReplica ) PURE;
	STDMETHOD( put_PartialReplica )				 ( 
    
 /* [in] */ VARIANT_BOOL fPartialReplica ) PURE;
	};// end interface;

// Interface: DAORelations
#undef INTERFACE
#define INTERFACE DAORelations
DECLARE_INTERFACE_(DAORelations, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAORelation __RPC_FAR *__RPC_FAR *pprel ) PURE;
	};// end interface;

// Interface: DAOContainer
#undef INTERFACE
#define INTERFACE DAOContainer
DECLARE_INTERFACE_(DAOContainer, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Owner )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Owner )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_UserName )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_UserName )					 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Permissions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Permissions )				 ( 
    
 /* [in] */ long permissions ) PURE;
	STDMETHOD( get_Inherit )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Inherit )					 ( 
    
 /* [in] */ VARIANT_BOOL fInherit ) PURE;
	STDMETHOD( get_Documents )					 ( 
    
 /* [retval][out] */ DAODocuments __RPC_FAR *__RPC_FAR *ppdocs ) PURE;
	STDMETHOD( get_AllPermissions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	};// end interface;

// Interface: DAOContainers
#undef INTERFACE
#define INTERFACE DAOContainers
DECLARE_INTERFACE_(DAOContainers, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOContainer __RPC_FAR *__RPC_FAR *ppctn ) PURE;
	};// end interface;

// Interface: DAODocument
#undef INTERFACE
#define INTERFACE DAODocument
DECLARE_INTERFACE_(DAODocument, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Owner )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Owner )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Container )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_UserName )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_UserName )					 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Permissions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Permissions )				 ( 
    
 /* [in] */ long permissions ) PURE;
	STDMETHOD( get_DateCreated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_LastUpdated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_AllPermissions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	};// end interface;

// Interface: DAODocuments
#undef INTERFACE
#define INTERFACE DAODocuments
DECLARE_INTERFACE_(DAODocuments, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAODocument __RPC_FAR *__RPC_FAR *ppdoc ) PURE;
	};// end interface;

// Interface: DAOIndexFields
#undef INTERFACE
#define INTERFACE DAOIndexFields
DECLARE_INTERFACE_(DAOIndexFields, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [optional][in] */ VARIANT Item,
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	};// end interface;

#endif // _DBDAOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DbgHelp.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dbghelp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#ifndef _DBGHELP_
#define _DBGHELP_

#if _MSC_VER > 1020
#pragma once
#endif


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif

// for those without specstrings.h

#ifndef __specstrings
 #define __in
 #define __out
 #define __inout
 #define __in_opt
 #define __out_opt
 #define __inout_opt
 #define __in_ecount(x)
 #define __out_ecount(x)
 #define __inout_ecount(x)
 #define __in_bcount(x)
 #define __out_bcount(x)
 #define __inout_bcount(x)
 #define __out_xcount(x)
 #define __deref_opt_out
 #define __deref_out
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
 #define IMAGEAPI __stdcall
 #define DBHLP_DEPRECIATED
#else
 #define IMAGEAPI DECLSPEC_IMPORT __stdcall
 #if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
  #define DBHLP_DEPRECIATED   __declspec(deprecated)
 #else
  #define DBHLP_DEPRECIATED
 #endif
#endif

#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

// Observant readers may notice that 2 new fields,
// 'fReadOnly' and 'Version' have been added to
// the LOADED_IMAGE structure after 'fDOSImage'.
// This does not change the size of the structure 
// from previous headers.  That is because while 
// 'fDOSImage' is a byte, it is padded by the 
// compiler to 4 bytes.  So the 2 new fields are 
// slipped into the extra space.

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

#define MAX_SYM_NAME            2000


// Error codes set by dbghelp functions.  Call GetLastError
// to see them.
// Dbghelp also sets error codes found in winerror.h

#define ERROR_IMAGE_NOT_STRIPPED    0x8800  // the image is not stripped.  No dbg file available.
#define ERROR_NO_DBG_POINTER        0x8801  // image is stripped but there is no pointer to a dbg file
#define ERROR_NO_PDB_POINTER        0x8802  // image does not point to a pdb file

typedef BOOL
(CALLBACK *PFIND_DEBUG_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in PVOID CallerData
    );

HANDLE
IMAGEAPI
SymFindDebugInfoFile(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
    );

typedef BOOL
(CALLBACK *PFIND_DEBUG_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in PVOID  CallerData
    );

HANDLE
IMAGEAPI
SymFindDebugInfoFileW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
    );

HANDLE
IMAGEAPI
FindDebugInfoFile (
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath
    );

HANDLE
IMAGEAPI
FindDebugInfoFileEx (
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR  DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
    );

HANDLE
IMAGEAPI
FindDebugInfoFileExW (
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
    );

typedef BOOL
(CALLBACK *PFINDFILEINPATHCALLBACK)(
    PCSTR filename,
    PVOID context
    );

BOOL
IMAGEAPI
SymFindFileInPath(
    __in HANDLE hprocess,
    __in_opt PCSTR SearchPath,
    __in PCSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACK callback,
    __in_opt PVOID context
    );

typedef BOOL
(CALLBACK *PFINDFILEINPATHCALLBACKW)(
    __in PCWSTR filename,
    __in PVOID context
    );

BOOL
IMAGEAPI
SymFindFileInPathW(
    __in HANDLE hprocess,
    __in_opt PCWSTR SearchPath,
    __in PCWSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PWSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACKW callback,
    __in_opt PVOID context
    );

typedef BOOL
(CALLBACK *PFIND_EXE_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PVOID CallerData
    );

HANDLE
IMAGEAPI
SymFindExecutableImage(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACK Callback,
    __in PVOID CallerData
    );
    
typedef BOOL
(CALLBACK *PFIND_EXE_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in_opt PVOID CallerData
    );

HANDLE
IMAGEAPI
SymFindExecutableImageW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
    );

HANDLE
IMAGEAPI
FindExecutableImage(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath
    );

HANDLE
IMAGEAPI
FindExecutableImageEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
    );

HANDLE
IMAGEAPI
FindExecutableImageExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
    );

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader (
    __in PVOID Base
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx (
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size,
    __out_opt PIMAGE_SECTION_HEADER *FoundHeader
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToData (
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size
    );

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva
    );

PVOID
IMAGEAPI
ImageRvaToVa(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva,
    __in_opt OUT PIMAGE_SECTION_HEADER *LastRvaSection
    );

#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION {
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    __in_opt HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PCSTR SymbolPath,
    __in ULONG ImageBase
    );

BOOL
IMAGEAPI
UnmapDebugInformation(
    __out_xcount(unknown) PIMAGE_DEBUG_INFORMATION DebugInfo
    );

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PSTR OutputPathBuffer
    );

BOOL
IMAGEAPI
SearchTreeForFileW(
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PWSTR OutputPathBuffer
    );

typedef BOOL
(CALLBACK *PENUMDIRTREE_CALLBACK)(
    __in PCSTR FilePath,
    __in_opt PVOID CallerData
    );

BOOL
IMAGEAPI
EnumDirTree(
    __in HANDLE hProcess,
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACK cb,
    __in_opt PVOID data
    );

typedef BOOL
(CALLBACK *PENUMDIRTREE_CALLBACKW)(
    __in PCWSTR FilePath,
    __in_opt PVOID CallerData
    );

BOOL
IMAGEAPI
EnumDirTreeW(
    __in HANDLE hProcess,
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PWSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACKW cb,
    __in_opt PVOID data
    );

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    __in PCSTR DirPath
    );

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
                                                                                                   //  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    __in PCSTR name,
    __out_ecount(maxStringLength) PSTR outputString,    
    __in DWORD maxStringLength,
    __in DWORD flags
    );

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolNameW(
    __in PCWSTR name,
    __out_ecount(maxStringLength) PWSTR outputString,   
    __in DWORD maxStringLength,
    __in DWORD flags
    );

//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1

typedef struct _MODLOAD_DATA {
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

//
// StackWalking API
//

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    __in LPADDRESS a32,
    __out LPADDRESS64 a64
    )
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    __in LPADDRESS64 a64,
    __out LPADDRESS a32
    )
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64 {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD64   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD64   StackBase;
    DWORD64   StackLimit;

    DWORD64   Reserved[5];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD   StackBase;
    DWORD   StackLimit;

    DWORD   Reserved[5];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    __in PKDHELP p32,
    __out PKDHELP64 p64
    )
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
    p64->KiUserExceptionDispatcher = p32->KiUserExceptionDispatcher;
    p64->StackBase = p32->StackBase;
    p64->StackLimit = p32->StackLimit;
}
#endif

typedef struct _tagSTACKFRAME64 {
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 qwBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out LPDWORD lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    __in HANDLE ahProcess,
    __in DWORD64 AddrBase
    );

typedef
DWORD64
(__stdcall *PGET_MODULE_BASE_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 Address
    );

typedef
DWORD64
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE64)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __in LPADDRESS64 lpaddr
    );

BOOL
IMAGEAPI
StackWalk64(
    __in DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME64 StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD lpBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out PDWORD lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __out LPADDRESS lpaddr
    );

BOOL
IMAGEAPI
StackWalk(
    DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE TranslateAddress
    );

#endif


#define API_VERSION_NUMBER 11

typedef struct API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    );

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    __in LPAPI_VERSION AppVersion
    );

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    __in HMODULE Module
    );

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64)(
    __in PCSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64W)(
    __in PCWSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt ULONG64 CallbackData,
    __in_opt ULONG64 UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK)(
    __in HANDLE hProcess,
    __in DWORD AddrBase,
    __in_opt PVOID UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG64 AddrBase,
    __in ULONG64 UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG BaseOfDll,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK)(
    __in PCSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACKW)(
    __in PCWSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt PVOID CallbackData,
    __in_opt PVOID UserContext
    );

#endif


// values found in SYMBOL_INFO.Tag
//
// This was taken from cvconst.h and should
// not override any values found there.
//
// #define _NO_CVCONST_H_ if you don't
// have access to that file...

#ifdef _NO_CVCONST_H

// DIA enums

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

#endif

//
// flags found in SYMBOL_INFO.Flags
//

#define SYMFLAG_VALUEPRESENT     0x00000001
#define SYMFLAG_REGISTER         0x00000008
#define SYMFLAG_REGREL           0x00000010
#define SYMFLAG_FRAMEREL         0x00000020
#define SYMFLAG_PARAMETER        0x00000040
#define SYMFLAG_LOCAL            0x00000080
#define SYMFLAG_CONSTANT         0x00000100
#define SYMFLAG_EXPORT           0x00000200
#define SYMFLAG_FORWARDER        0x00000400
#define SYMFLAG_FUNCTION         0x00000800
#define SYMFLAG_VIRTUAL          0x00001000
#define SYMFLAG_THUNK            0x00002000
#define SYMFLAG_TLSREL           0x00004000
#define SYMFLAG_SLOT             0x00008000
#define SYMFLAG_ILREL            0x00010000
#define SYMFLAG_METADATA         0x00020000
#define SYMFLAG_CLR_TOKEN        0x00040000

// this resets SymNext/Prev to the beginning
// of the module passed in the address field

#define SYMFLAG_RESET            0x80000000  

//
// symbol type enumeration
//
typedef enum {
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    SymVirtual,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64 {
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR    Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

typedef struct _IMAGEHLP_SYMBOL64_PACKAGE {
    IMAGEHLP_SYMBOL64 sym;
    CHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL64_PACKAGE, *PIMAGEHLP_SYMBOL64_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW64 {
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR   Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW64, *PIMAGEHLP_SYMBOLW64;

typedef struct _IMAGEHLP_SYMBOLW64_PACKAGE {
    IMAGEHLP_SYMBOLW64 sym;
    WCHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW64_PACKAGE, *PIMAGEHLP_SYMBOLW64_PACKAGE;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

 #define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
 #define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
 #define IMAGEHLP_SYMBOL_PACKAGE IMAGEHLP_SYMBOL64_PACKAGE
 #define PIMAGEHLP_SYMBOL_PACKAGE PIMAGEHLP_SYMBOL64_PACKAGE
 #define IMAGEHLP_SYMBOLW IMAGEHLP_SYMBOLW64
 #define PIMAGEHLP_SYMBOLW PIMAGEHLP_SYMBOLW64
 #define IMAGEHLP_SYMBOLW_PACKAGE IMAGEHLP_SYMBOLW64_PACKAGE
 #define PIMAGEHLP_SYMBOLW_PACKAGE PIMAGEHLP_SYMBOLW64_PACKAGE

#else

 typedef struct _IMAGEHLP_SYMBOL {
     DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
     DWORD Address;                // virtual address including dll base address
     DWORD Size;                   // estimated size of symbol, can be zero
     DWORD Flags;                  // info about the symbols, see the SYMF defines
     DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
     CHAR                        Name[1];                // symbol name (null terminated string)
 } IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

 typedef struct _IMAGEHLP_SYMBOL_PACKAGE {
     IMAGEHLP_SYMBOL sym;
     CHAR            name[MAX_SYM_NAME + 1];
 } IMAGEHLP_SYMBOL_PACKAGE, *PIMAGEHLP_SYMBOL_PACKAGE;

 typedef struct _IMAGEHLP_SYMBOLW {
     DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW)
     DWORD Address;                // virtual address including dll base address
     DWORD Size;                   // estimated size of symbol, can be zero
     DWORD Flags;                  // info about the symbols, see the SYMF defines
     DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
     WCHAR                       Name[1];                // symbol name (null terminated string)
 } IMAGEHLP_SYMBOLW, *PIMAGEHLP_SYMBOLW;

 typedef struct _IMAGEHLP_SYMBOLW_PACKAGE {
     IMAGEHLP_SYMBOLW sym;
     WCHAR            name[MAX_SYM_NAME + 1];
 } IMAGEHLP_SYMBOLW_PACKAGE, *PIMAGEHLP_SYMBOLW_PACKAGE;

#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64 {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
    // new elements: 07-Jun-2002
    CHAR     LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    CHAR     CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULEW64 {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    // new elements: 07-Jun-2002
    WCHAR    LoadedImageName[256];   // symbol file name
    WCHAR    LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    WCHAR        CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    WCHAR    LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64 {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

typedef struct _IMAGEHLP_LINEW64 {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PWSTR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW64, *PIMAGEHLP_LINEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD    Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;

typedef struct _IMAGEHLP_LINEW {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW, *PIMAGEHLP_LINEW;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE {
    DWORD64  ModBase;                // base address of loaded module
    PCHAR    FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

typedef struct _SOURCEFILEW {
    DWORD64  ModBase;                // base address of loaded module
    PWSTR    FileName;               // full filename of source
} SOURCEFILEW, *PSOURCEFILEW;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEFERRED_SYMBOL_LOAD_PARTIAL        0x00000020
#define CBA_DEBUG_INFO                          0x10000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY {
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD    *bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum {
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

#define EVENT_SRCSPEW_START 100
#define EVENT_SRCSPEW       100
#define EVENT_SRCSPEW_END   199

typedef struct _IMAGEHLP_CBA_EVENT {
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_CBA_EVENTW {
    DWORD  severity;                                     // values from sevInfo to sevFatal
    DWORD  code;                                         // numerical code IDs the error
    PCWSTR desc;                                         // may contain a text description of the error
    PVOID  object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENTW, *PIMAGEHLP_CBA_EVENTW;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64 {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;                     //
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOADW64 {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOADW64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    WCHAR    FileName[MAX_PATH + 1]; // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;         //
} IMAGEHLP_DEFERRED_SYMBOL_LOADW64, *PIMAGEHLP_DEFERRED_SYMBOL_LOADW64;

#define DSLFLAG_MISMATCHED_PDB  0x1
#define DSLFLAG_MISMATCHED_DBG  0x2

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD {
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64 {
    DWORD              SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD              NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64 Symbol;                 // array of duplicate symbols
    DWORD              SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL {
    DWORD            SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD            NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL Symbol;                 // array of duplicate symbols
    DWORD            SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
IMAGEAPI
SymSetParentWindow(
    __in HWND hwnd
    );

PCHAR
IMAGEAPI
SymSetHomeDirectory(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR dir
    );

PWSTR
IMAGEAPI
SymSetHomeDirectoryW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR dir
    );

PCHAR
IMAGEAPI
SymGetHomeDirectory(
    __in DWORD type,
    __out_ecount(size) PSTR dir,
    __in size_t size
    );

PWSTR
IMAGEAPI
SymGetHomeDirectoryW(
    __in DWORD type,
    __out_ecount(size) PWSTR dir,
    __in size_t size
    );

typedef enum {
    hdBase = 0, // root directory for dbghelp
    hdSym,      // where symbols are stored
    hdSrc,      // where source is stored
    hdMax       // end marker
};

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE         0x00000001
#define SYMOPT_UNDNAME                  0x00000002
#define SYMOPT_DEFERRED_LOADS           0x00000004
#define SYMOPT_NO_CPP                   0x00000008
#define SYMOPT_LOAD_LINES               0x00000010
#define SYMOPT_OMAP_FIND_NEAREST        0x00000020
#define SYMOPT_LOAD_ANYTHING            0x00000040
#define SYMOPT_IGNORE_CVREC             0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS     0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS     0x00000200
#define SYMOPT_EXACT_SYMBOLS            0x00000400
#define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS   0x00000800
#define SYMOPT_IGNORE_NT_SYMPATH        0x00001000
#define SYMOPT_INCLUDE_32BIT_MODULES    0x00002000
#define SYMOPT_PUBLICS_ONLY             0x00004000
#define SYMOPT_NO_PUBLICS               0x00008000
#define SYMOPT_AUTO_PUBLICS             0x00010000
#define SYMOPT_NO_IMAGE_SEARCH          0x00020000
#define SYMOPT_SECURE                   0x00040000
#define SYMOPT_NO_PROMPTS               0x00080000
#define SYMOPT_OVERWRITE                0x00100000
#define SYMOPT_IGNORE_IMAGEDIR          0x00200000
#define SYMOPT_FLAT_DIRECTORY           0x00400000
#define SYMOPT_FAVOR_COMPRESSED         0x00800000
#define SYMOPT_ALLOW_ZERO_ADDRESS       0x01000000

#define SYMOPT_DEBUG                    0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    __in DWORD   SymOptions
    );

DWORD
IMAGEAPI
SymGetOptions(
    VOID
    );

BOOL
IMAGEAPI
SymCleanup(
    __in HANDLE hProcess
    );

BOOL
IMAGEAPI
SymMatchString(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
    );

BOOL
IMAGEAPI
SymMatchStringA(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
    );

BOOL
IMAGEAPI
SymMatchStringW(
    __in PCWSTR string,
    __in PCWSTR expression,
    __in BOOL fCase
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSOURCEFILES_CALLBACK)(
    __in PSOURCEFILE pSourceFile,
    __in_opt PVOID UserContext
    );

// for backwards compatibility - don't use this
#define PSYM_ENUMSOURCFILES_CALLBACK PSYM_ENUMSOURCEFILES_CALLBACK

BOOL
IMAGEAPI
SymEnumSourceFiles(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACK cbSrcFiles,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSOURCEFILES_CALLBACKW)(
    __in PSOURCEFILEW pSourceFile,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumSourceFilesW(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACKW cbSrcFiles,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumerateModules64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumerateModulesW64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACKW64 EnumModulesCallback,
    __in_opt PVOID UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    __in_opt PVOID UserContext
    );
#endif

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
    );
    
BOOL
IMAGEAPI
EnumerateLoadedModulesW64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in PVOID UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
    );
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    __in HANDLE hProcess,
    __in DWORD64 AddrBase
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    __in HANDLE hProcess,
    __in DWORD AddrBase
    );
#endif

BOOL
IMAGEAPI
SymGetModuleInfo64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULE64 ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULEW64 ModuleInfo
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULE ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULEW ModuleInfo
    );
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    __in HANDLE hProcess,
    __in DWORD dwAddr
    );
#endif

typedef struct _SRCCODEINFO {
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    CHAR    Obj[MAX_PATH + 1];      // the object file within the module
    CHAR    FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFO, *PSRCCODEINFO;

typedef struct _SRCCODEINFOW {
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    WCHAR   Obj[MAX_PATH + 1];      // the object file within the module
    WCHAR   FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFOW, *PSRCCODEINFOW;

typedef BOOL
(CALLBACK *PSYM_ENUMLINES_CALLBACK)(
    __in PSRCCODEINFO LineInfo,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMLINES_CALLBACKW)(
    __in PSRCCODEINFOW LineInfo,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE64 Line64
    );

BOOL
IMAGEAPI
SymEnumSourceLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumSourceLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
    );

// flags for SymEnumSourceLines

#define ESLFLAG_FULLPATH        0x1
#define ESLFLAG_NEAREST         0x2
#define ESLFLAG_PREV            0x4
#define ESLFLAG_NEXT            0x8

BOOL
IMAGEAPI
SymGetLineFromAddrW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINEW64       Line64
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#define SymGetLineFromAddrW SymGetLineFromAddrW64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE Line
    );

BOOL
IMAGEAPI
SymGetLineFromAddrW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE64 Line
    );

BOOL
IMAGEAPI
SymGetLineFromNameW64(
    __in HANDLE hProcess,
    __in_opt PCWSTR ModuleName,
    __in_opt PCWSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINEW64 Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
    );

BOOL
IMAGEAPI
SymGetLineNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
    );

BOOL
IMAGEAPI
SymGetLineNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
    );
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
    );

BOOL
IMAGEAPI
SymGetLinePrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
    );

BOOL
IMAGEAPI
SymGetLinePrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
    );
#endif

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in PCSTR FileName,
    __out_ecount(BufferLines) PDWORD64 Buffer,
    __in ULONG BufferLines
    );

BOOL
IMAGEAPI
SymMatchFileName(
    __in PCSTR FileName,
    __in PCSTR Match,
    __deref_opt_out PSTR *FileNameStop,
    __deref_opt_out PSTR *MatchStop
    );

BOOL
IMAGEAPI
SymMatchFileNameW(
    __in PCWSTR FileName,
    __in PCWSTR Match,
    __deref_opt_out PWSTR *FileNameStop,
    __deref_opt_out PWSTR *MatchStop
    );

BOOL
IMAGEAPI
SymGetSourceFile(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCSTR Params,
    __in PCSTR FileSpec,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
    );

BOOL
IMAGEAPI
SymGetSourceFileW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCWSTR Params,
    __in PCWSTR FileSpec,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
    );

BOOL
IMAGEAPI
SymGetSourceFileToken(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCSTR FileSpec,
    __deref_out PVOID *Token,
    __out DWORD *Size
    );

BOOL
IMAGEAPI
SymGetSourceFileTokenW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCWSTR FileSpec,
    __deref_out PVOID *Token,
    __out DWORD *Size
    );

BOOL
IMAGEAPI
SymGetSourceFileFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in PCSTR Params,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
    );

BOOL
IMAGEAPI
SymGetSourceFileFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in PCWSTR Params,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
    );

BOOL
IMAGEAPI
SymGetSourceVarFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __in PCSTR VarName,
    __out_ecount(Size) PSTR Value,
    __in DWORD Size
    );

BOOL
IMAGEAPI
SymGetSourceVarFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __in PCWSTR VarName,
    __out_ecount(Size) PWSTR Value,
    __in DWORD Size
    );

BOOL
IMAGEAPI
SymInitialize(
    __in HANDLE hProcess,
    __in_opt PCSTR UserSearchPath,
    __in BOOL fInvadeProcess
    );

BOOL
IMAGEAPI
SymInitializeW(
    __in HANDLE hProcess,
    __in_opt PCWSTR UserSearchPath,
    __in BOOL fInvadeProcess
    );

BOOL
IMAGEAPI
SymGetSearchPath(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PSTR SearchPath,
    __in DWORD SearchPathLength
    );

BOOL
IMAGEAPI
SymGetSearchPathW(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PWSTR SearchPath,
    __in DWORD SearchPathLength
    );

BOOL
IMAGEAPI
SymSetSearchPath(
    __in HANDLE hProcess,
    __in_opt PCSTR SearchPath
    );

BOOL
IMAGEAPI
SymSetSearchPathW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SearchPath
    );

#define SLMFLAG_VIRTUAL     0x1
#define SLMFLAG_ALT_INDEX   0x2
#define SLMFLAG_NO_SYMBOLS  0x4

DWORD64
IMAGEAPI
SymLoadModuleEx(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
    );

DWORD64
IMAGEAPI
SymLoadModuleExW(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCWSTR ImageName,
    __in_opt PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
    );

BOOL
IMAGEAPI
SymUnloadModule64(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    __in HANDLE hProcess,
    __in DWORD BaseOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnDName64(
    __in PIMAGEHLP_SYMBOL64 sym,            // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    __in PIMAGEHLP_SYMBOL sym,              // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
    );
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
    );

BOOL
IMAGEAPI
SymRegisterCallbackW64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
    );
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC {
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO { // AKA TYPTYP
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

typedef struct _SYMBOL_INFO {
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _SYMBOL_INFO_PACKAGE {
    SYMBOL_INFO si;
    CHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGE, *PSYMBOL_INFO_PACKAGE;

typedef struct _SYMBOL_INFOW {
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    WCHAR       Name[1];          // Name of symbol
} SYMBOL_INFOW, *PSYMBOL_INFOW;

typedef struct _SYMBOL_INFO_PACKAGEW {
    SYMBOL_INFOW si;
    WCHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGEW, *PSYMBOL_INFO_PACKAGEW;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


BOOL
IMAGEAPI
SymSetContext(
    __in HANDLE hProcess,
    __in PIMAGEHLP_STACK_FRAME StackFrame,
    __in_opt PIMAGEHLP_CONTEXT Context
    );

typedef BOOL
(CALLBACK *PSYM_ENUMPROCESSES_CALLBACK)(
    __in HANDLE hProcess,
    __in PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumProcesses(
    __in PSYM_ENUMPROCESSES_CALLBACK EnumProcessesCallback,
    __in PVOID UserContext
    );

BOOL
IMAGEAPI
SymFromAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFO Symbol
    );

BOOL
IMAGEAPI
SymFromAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFOW Symbol
    );

BOOL
IMAGEAPI
SymFromToken(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFO Symbol
    );

BOOL
IMAGEAPI
SymFromTokenW(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFOW Symbol
    );

BOOL
IMAGEAPI
SymNext(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
    );

BOOL
IMAGEAPI
SymNextW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
    );

BOOL
IMAGEAPI
SymPrev(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
    );

BOOL
IMAGEAPI
SymPrevW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
    );

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
    );

BOOL
IMAGEAPI
SymFromNameW(
    __in HANDLE hProcess,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
    );

typedef BOOL
(CALLBACK *PSYM_ENUMERATESYMBOLS_CALLBACK)(
    __in PSYMBOL_INFO pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbols(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMERATESYMBOLS_CALLBACKW)(
    __in PSYMBOL_INFOW pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbolsW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbolsForAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

#define SYMSEARCH_MASKOBJS      0x01    // used internally to implement other APIs
#define SYMSEARCH_RECURSE       0X02    // recurse scopes
#define SYMSEARCH_GLOBALSONLY   0X04    // search only for global symbols

BOOL
IMAGEAPI
SymSearch(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
    );

BOOL
IMAGEAPI
SymSearchW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCWSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
    );

BOOL
IMAGEAPI
SymGetScope(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
    );

BOOL
IMAGEAPI
SymGetScopeW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
    );

BOOL
IMAGEAPI
SymFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
    );

BOOL
IMAGEAPI
SymFromIndexW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
    );

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO {
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
    TI_GET_UDTKIND,
    TI_IS_EQUIV_TO,
    TI_GET_CALLING_CONVENTION,
    TI_IS_CLOSE_EQUIV_TO,
    TI_GTIEX_REQS_VALID,
    TI_GET_VIRTUALBASEOFFSET,
    TI_GET_VIRTUALBASEDISPINDEX,
    TI_GET_IS_REFERENCE,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS {
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __in ULONG TypeId,
    __in IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    __out PVOID pInfo
    );

#define IMAGEHLP_GET_TYPE_INFO_UNCACHED 0x00000001
#define IMAGEHLP_GET_TYPE_INFO_CHILDREN 0x00000002

typedef struct _IMAGEHLP_GET_TYPE_INFO_PARAMS {
    IN  ULONG    SizeOfStruct;
    IN  ULONG    Flags;
    IN  ULONG    NumIds;
    IN  PULONG   TypeIds;
    IN  ULONG64  TagFilter;
    IN  ULONG    NumReqs;
    IN  IMAGEHLP_SYMBOL_TYPE_INFO* ReqKinds;
    IN  PULONG_PTR ReqOffsets;
    IN  PULONG   ReqSizes;
    IN  ULONG_PTR ReqStride;
    IN  ULONG_PTR BufferSize;
    OUT PVOID    Buffer;
    OUT ULONG    EntriesMatched;
    OUT ULONG    EntriesFilled;
    OUT ULONG64  TagsFound;
    OUT ULONG64  AllReqsValid;
    IN  ULONG    NumReqsValid;
    OUT PULONG64 ReqsValid OPTIONAL;
} IMAGEHLP_GET_TYPE_INFO_PARAMS, *PIMAGEHLP_GET_TYPE_INFO_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfoEx(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __inout PIMAGEHLP_GET_TYPE_INFO_PARAMS Params
    );

BOOL
IMAGEAPI
SymEnumTypes(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymEnumTypesW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

BOOL
IMAGEAPI
SymGetTypeFromName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
    );

BOOL
IMAGEAPI
SymGetTypeFromNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
    );

BOOL
IMAGEAPI
SymAddSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
    );

BOOL
IMAGEAPI
SymAddSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
    );

BOOL
IMAGEAPI
SymDeleteSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
    );

BOOL
IMAGEAPI
SymDeleteSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
    );

BOOL
IMAGEAPI
SymRefreshModuleList(
    __in HANDLE hProcess
    );

BOOL
IMAGEAPI
SymSrvIsStoreW(
    __in HANDLE hProcess,
    __in PCWSTR path
    );

BOOL
IMAGEAPI
SymSrvIsStore(
    __in HANDLE hProcess,
    __in PCSTR path
    );

PCSTR
IMAGEAPI
SymSrvDeltaName(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Type,
    __in PCSTR File1,
    __in PCSTR File2
    );

PCWSTR
IMAGEAPI
SymSrvDeltaNameW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Type,
    __in PCWSTR File1,
    __in PCWSTR File2
    );

PCSTR
IMAGEAPI
SymSrvGetSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Node,
    __in PCSTR File
    );

PCWSTR
IMAGEAPI
SymSrvGetSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File
    );

BOOL
IMAGEAPI
SymSrvGetFileIndexes(
    __in PCSTR File,
    __out GUID *Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
    );

BOOL
IMAGEAPI
SymSrvGetFileIndexesW(
    __in PCWSTR File,
    __out GUID *Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
    );

BOOL
IMAGEAPI
SymSrvGetFileIndexStringW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __out_ecount(Size) PWSTR Index,
    __in size_t Size,                                                                        
    __in DWORD Flags
    );

BOOL
IMAGEAPI
SymSrvGetFileIndexString(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __out_ecount(Size) PSTR Index,
    __in size_t Size,
    __in DWORD Flags
    );

typedef struct {
    DWORD sizeofstruct;
    char file[MAX_PATH +1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    char dbgfile[MAX_PATH +1];
    char pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFO, *PSYMSRV_INDEX_INFO;

typedef struct {
    DWORD sizeofstruct;
    WCHAR file[MAX_PATH +1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    WCHAR dbgfile[MAX_PATH +1];
    WCHAR pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFOW, *PSYMSRV_INDEX_INFOW;

BOOL
IMAGEAPI
SymSrvGetFileIndexInfo(
    __in PCSTR File,
    __out PSYMSRV_INDEX_INFO Info,
    __in DWORD Flags
    );

BOOL
IMAGEAPI
SymSrvGetFileIndexInfoW(
    __in PCWSTR File,
    __out PSYMSRV_INDEX_INFOW Info,
    __in DWORD Flags
    );

PCSTR
IMAGEAPI
SymSrvStoreSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR Node,
    __in PCSTR File,
    __in DWORD Flags
    );

PCWSTR
IMAGEAPI
SymSrvStoreSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File,
    __in DWORD Flags
    );

PCSTR
IMAGEAPI
SymSrvStoreFile(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __in DWORD Flags
    );

PCWSTR
IMAGEAPI
SymSrvStoreFileW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __in DWORD Flags
    );

// used by SymGetSymbolFile's "Type" parameter

typedef enum {
    sfImage = 0,
    sfDbg,
    sfPdb,
    sfMpd,
    sfMax
};

BOOL
IMAGEAPI
SymGetSymbolFile(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PSTR DbgFile,
    __in size_t cDbgFile
    );

BOOL
IMAGEAPI
SymGetSymbolFileW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PWSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PWSTR DbgFile,
    __in size_t cDbgFile
    );

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI *PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    __in DWORD DataType,
    __in PVOID* Data,
    __out LPDWORD DataLength,
    __in_opt PVOID UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDump(
    __in_opt LPCSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    __in_opt LPCWSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
    );

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out_opt PDWORD64 pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL64  Symbol
    );


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out_opt PDWORD pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL Symbol
    );
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL64 Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL Symbol
    );
#endif


// Symbol server exports

typedef BOOL (WINAPI *PSYMBOLSERVERPROC)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERPROCA)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERPROCW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERBYINDEXPROC)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERBYINDEXPROCA)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERBYINDEXPROCW)(PCWSTR, PCWSTR, PCWSTR, PWSTR);
typedef BOOL (WINAPI *PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (WINAPI *PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (WINAPI *PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (WINAPI *PSYMBOLSERVERSETOPTIONSWPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK WINAPI *PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR (WINAPI *PSYMBOLSERVERGETOPTIONSPROC)();
typedef BOOL (WINAPI *PSYMBOLSERVERPINGPROC)(PCSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERPINGPROCA)(PCSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERPINGPROCW)(PCWSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERGETVERSION)(LPAPI_VERSION);
typedef BOOL (WINAPI *PSYMBOLSERVERDELTANAME)(PCSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI *PSYMBOLSERVERDELTANAMEW)(PCWSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI *PSYMBOLSERVERGETSUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t);
typedef BOOL (WINAPI *PSYMBOLSERVERGETSUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t);
typedef BOOL (WINAPI *PSYMBOLSERVERSTORESUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t, DWORD);
typedef BOOL (WINAPI *PSYMBOLSERVERSTORESUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI *PSYMBOLSERVERGETINDEXSTRING)(PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI *PSYMBOLSERVERGETINDEXSTRINGW)(PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI *PSYMBOLSERVERSTOREFILE)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR, size_t, DWORD);
typedef BOOL (WINAPI *PSYMBOLSERVERSTOREFILEW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI *PSYMBOLSERVERISSTORE)(PCSTR);
typedef BOOL (WINAPI *PSYMBOLSERVERISSTOREW)(PCWSTR);
typedef DWORD (WINAPI *PSYMBOLSERVERVERSION)();
typedef BOOL (CALLBACK WINAPI *PSYMBOLSERVERMESSAGEPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);

#define SYMSRV_VERSION              2

#define SSRVOPT_CALLBACK            0x000001
#define SSRVOPT_DWORD               0x000002
#define SSRVOPT_DWORDPTR            0x000004
#define SSRVOPT_GUIDPTR             0x000008
#define SSRVOPT_OLDGUIDPTR          0x000010
#define SSRVOPT_UNATTENDED          0x000020
#define SSRVOPT_NOCOPY              0x000040
#define SSRVOPT_GETPATH             0x000040
#define SSRVOPT_PARENTWIN           0x000080
#define SSRVOPT_PARAMTYPE           0x000100
#define SSRVOPT_SECURE              0x000200
#define SSRVOPT_TRACE               0x000400
#define SSRVOPT_SETCONTEXT          0x000800
#define SSRVOPT_PROXY               0x001000
#define SSRVOPT_DOWNSTREAM_STORE    0x002000
#define SSRVOPT_OVERWRITE           0x004000
#define SSRVOPT_RESETTOU            0x008000
#define SSRVOPT_CALLBACKW           0x010000
#define SSRVOPT_FLAT_DEFAULT_STORE  0x020000
#define SSRVOPT_PROXYW              0x040000
#define SSRVOPT_MESSAGE             0x080000
#define SSRVOPT_SERVICE             0x100000   // deprecated
#define SSRVOPT_FAVOR_COMPRESSED    0x200000  

#define SSRVOPT_MAX                 0x40000

#define SSRVOPT_RESET               ((ULONG_PTR)-1)


#define NUM_SSRVOPTS                30

#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4

#define SYMSTOREOPT_COMPRESS        0x01
#define SYMSTOREOPT_OVERWRITE       0x02
#define SYMSTOREOPT_RETURNINDEX     0x04
#define SYMSTOREOPT_POINTER         0x08
#define SYMSTOREOPT_ALT_INDEX       0x10
#define SYMSTOREOPT_UNICODE         0x20
#define SYMSTOREOPT_PASS_IF_EXISTS  0x40

#ifdef DBGHELP_TRANSLATE_TCHAR
 #define SymInitialize                     SymInitializeW
 #define SymAddSymbol                      SymAddSymbolW
 #define SymDeleteSymbol                   SymDeleteSymbolW
 #define SearchTreeForFile                 SearchTreeForFileW
 #define UnDecorateSymbolName              UnDecorateSymbolNameW
 #define SymGetLineFromName64              SymGetLineFromNameW64
 #define SymGetLineFromAddr64              SymGetLineFromAddrW64
 #define SymGetLineNext64                  SymGetLineNextW64
 #define SymGetLinePrev64                  SymGetLinePrevW64
 #define SymFromName                       SymFromNameW
 #define SymFindExecutableImage            SymFindExecutableImageW
 #define FindExecutableImageEx             FindExecutableImageExW
 #define SymSearch                         SymSearchW
 #define SymEnumLines                      SymEnumLinesW
 #define SymEnumSourceLines                SymEnumSourceLinesW
 #define SymGetTypeFromName                SymGetTypeFromNameW
 #define SymEnumSymbolsForAddr             SymEnumSymbolsForAddrW
 #define SymFromAddr                       SymFromAddrW
 #define SymMatchString                    SymMatchStringW
 #define SymEnumSourceFiles                SymEnumSourceFilesW
 #define SymEnumSymbols                    SymEnumSymbolsW
 #define SymLoadModuleEx                   SymLoadModuleExW
 #define SymSetSearchPath                  SymSetSearchPathW
 #define SymGetSearchPath                  SymGetSearchPathW
 #define EnumDirTree                       EnumDirTreeW
 #define SymFromToken                      SymFromTokenW
 #define SymFromIndex                      SymFromIndexW
 #define SymGetScope                       SymGetScopeW
 #define SymNext                           SymNextW
 #define SymPrev                           SymPrevW
 #define SymEnumTypes                      SymEnumTypesW
 #define SymRegisterCallback64             SymRegisterCallbackW64
 #define SymFindDebugInfoFile              SymFindDebugInfoFileW
 #define FindDebugInfoFileEx               FindDebugInfoFileExW
 #define SymFindFileInPath                 SymFindFileInPathW
 #define SymEnumerateModules64             SymEnumerateModulesW64
 #define SymSetHomeDirectory               SymSetHomeDirectoryW
 #define SymGetHomeDirectory               SymGetHomeDirectoryW
 #define SymGetSourceFile                  SymGetSourceFileW
 #define SymGetSourceFileToken             SymGetSourceFileTokenW
 #define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
 #define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
 #define SymGetSourceFileToken             SymGetSourceFileTokenW
 #define SymGetFileLineOffsets64           SymGetFileLineOffsetsW64
 #define SymFindFileInPath                 SymFindFileInPathW
 #define SymMatchFileName                  SymMatchFileNameW
 #define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
 #define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
 #define SymGetModuleInfo64                SymGetModuleInfoW64
 #define SymSrvIsStore                     SymSrvIsStoreW
 #define SymSrvDeltaName                   SymSrvDeltaNameW
 #define SymSrvGetSupplement               SymSrvGetSupplementW
 #define SymSrvStoreSupplement             SymSrvStoreSupplementW
 #define SymSrvGetFileIndexes              SymSrvGetFileIndexes
 #define SymSrvGetFileIndexString          SymSrvGetFileIndexStringW
 #define SymSrvStoreFile                   SymSrvStoreFileW
 #define SymGetSymbolFile                  SymGetSymbolFileW
 #define EnumerateLoadedModules64      EnumerateLoadedModulesW64
 #define SymSrvGetFileIndexInfo            SymSrvGetFileIndexInfoW
 
 #define IMAGEHLP_LINE64                   IMAGEHLP_LINEW64
 #define PIMAGEHLP_LINE64                  PIMAGEHLP_LINEW64
 #define SYMBOL_INFO                       SYMBOL_INFOW
 #define PSYMBOL_INFO                      PSYMBOL_INFOW
 #define SYMBOL_INFO_PACKAGE               SYMBOL_INFO_PACKAGEW
 #define PSYMBOL_INFO_PACKAGE              PSYMBOL_INFO_PACKAGEW
 #define FIND_EXE_FILE_CALLBACK            FIND_EXE_FILE_CALLBACKW
 #define PFIND_EXE_FILE_CALLBACK           PFIND_EXE_FILE_CALLBACKW
 #define SYM_ENUMERATESYMBOLS_CALLBACK     SYM_ENUMERATESYMBOLS_CALLBACKW
 #define PSYM_ENUMERATESYMBOLS_CALLBACK    PSYM_ENUMERATESYMBOLS_CALLBACKW
 #define SRCCODEINFO                       SRCCODEINFOW
 #define PSRCCODEINFO                      PSRCCODEINFOW
 #define SOURCEFILE                        SOURCEFILEW
 #define PSOURCEFILE                       PSOURCEFILEW
 #define SYM_ENUMSOURECFILES_CALLBACK      SYM_ENUMSOURCEFILES_CALLBACKW
 #define PSYM_ENUMSOURCEFILES_CALLBACK     PSYM_ENUMSOURECFILES_CALLBACKW
 #define IMAGEHLP_CBA_EVENT                IMAGEHLP_CBA_EVENTW
 #define PIMAGEHLP_CBA_EVENT               PIMAGEHLP_CBA_EVENTW
 #define PENUMDIRTREE_CALLBACK             PENUMDIRTREE_CALLBACKW
 #define IMAGEHLP_DEFERRED_SYMBOL_LOAD64   IMAGEHLP_DEFERRED_SYMBOL_LOADW64
 #define PIMAGEHLP_DEFERRED_SYMBOL_LOAD64  PIMAGEHLP_DEFERRED_SYMBOL_LOADW64
 #define PFIND_DEBUG_FILE_CALLBACK         PFIND_DEBUG_FILE_CALLBACKW
 #define PFINDFILEINPATHCALLBACK           PFINDFILEINPATHCALLBACKW
 #define IMAGEHLP_MODULE64                 IMAGEHLP_MODULEW64
 #define PIMAGEHLP_MODULE64                PIMAGEHLP_MODULEW64
 #define SYMSRV_INDEX_INFO         SYMSRV_INDEX_INFOw
 #define PSYMSRV_INDEX_INFO                PSYMSRV_INDEX_INFOW

 #define PSYMBOLSERVERPROC                 PSYMBOLSERVERPROCW
 #define PSYMBOLSERVERPINGPROC             PSYMBOLSERVERPINGPROCW
#endif

// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
    );

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in DWORD one,
    __in DWORD two,
    __in DWORD three,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );
#endif

// use SymLoadModuleEx

DWORD64
IMAGEAPI
SymLoadModule64(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD SizeOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD BaseOfDll,
    __in DWORD SizeOfDll
    );
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
    );

BOOL
IMAGEAPI
SymGetSymNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#define SymGetSymNextW SymGetSymNextW64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
    );

BOOL
IMAGEAPI
SymGetSymNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
    );

BOOL
IMAGEAPI
SymGetSymPrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#define SymGetSymPrevW SymGetSymPrevW64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
    );

BOOL
IMAGEAPI
SymGetSymPrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
    );
#endif


// These values should not be used.
// They have been replaced by SYMFLAG_ values.

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
#define SYMF_THUNK            0x00002000
#define SYMF_TLSREL           0x00004000

// These values should also not be used.
// They have been replaced by SYMFLAG_ values.

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000
#define IMAGEHLP_SYMBOL_THUNK                      SYMF_THUNK           // 0x2000
#define IMAGEHLP_SYMBOL_INFO_TLSRELATIVE           SYMF_TLSREL          // 0x4000


#include <pshpack4.h>

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)    /* Zero length array */
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif
#endif

#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64 {
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64 {
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,
    MemoryInfoListStream        = 16,
    ThreadInfoListStream        = 17,
    HandleOperationListStream   = 18,

    ceStreamNull                = 0x8000,
    ceStreamSystemInfo          = 0x8001,
    ceStreamException           = 0x8002,
    ceStreamModuleList          = 0x8003,
    ceStreamProcessList         = 0x8004,
    ceStreamThreadList          = 0x8005, 
    ceStreamThreadContextList   = 0x8006,
    ceStreamThreadCallStackList = 0x8007,
    ceStreamMemoryVirtualList   = 0x8008,
    ceStreamMemoryPhysicalList  = 0x8009,
    ceStreamBucketParameters    = 0x800A,     

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 

//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION {

    //
    // X86 platforms use CPUID function to obtain processor information.
    //
    
    struct {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //
        
        ULONG32 VendorId [ 3 ];
        
        //
        // CPUID Subfunction 1, register EAX
        //
        
        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //
        
        ULONG32 FeatureInformation;
        

        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //
        
        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //
    
    struct {

        ULONG64 ProcessorFeatures [ 2 ];
        
    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;
        
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    union {
        USHORT Reserved0;
        struct {
            UCHAR NumberOfProcessors;
            UCHAR ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    union {
        ULONG32 Reserved1;
        struct {
            USHORT SuiteMask;
            USHORT Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((PPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST {
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64 {
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

// Per-handle object information varies according to
// the OS, the OS version, the processor type and
// so on.  The minidump gives a minidump identifier
// to each possible data format for identification
// purposes but does not control nor describe the actual data.
typedef enum _MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE {
    MiniHandleObjectInformationNone,
    MiniThreadInformation1,
    MiniMutantInformation1,
    MiniMutantInformation2,
    MiniProcessInformation1,
    MiniProcessInformation2,
    MiniHandleObjectInformationTypeMax
} MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE;

typedef struct _MINIDUMP_HANDLE_OBJECT_INFORMATION {
    RVA NextInfoRva;
    ULONG32 InfoType;
    ULONG32 SizeOfInfo;
    // Raw information follows.
} MINIDUMP_HANDLE_OBJECT_INFORMATION;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR_2 {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
    RVA ObjectInfoRva;
    ULONG32 Reserved0;
} MINIDUMP_HANDLE_DESCRIPTOR_2, *PMINIDUMP_HANDLE_DESCRIPTOR_2;

// The latest MINIDUMP_HANDLE_DESCRIPTOR definition.
typedef MINIDUMP_HANDLE_DESCRIPTOR_2 MINIDUMP_HANDLE_DESCRIPTOR_N;
typedef MINIDUMP_HANDLE_DESCRIPTOR_N *PMINIDUMP_HANDLE_DESCRIPTOR_N;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;

// Some operating systems can track the last operations
// performed on a handle.  For example, Application Verifier
// can enable this for some versions of Windows.  The
// handle operation list collects handle operations
// known for the dump target.
// Each entry is an AVRF_HANDLE_OPERATION.
typedef struct _MINIDUMP_HANDLE_OPERATION_LIST {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_OPERATION_LIST, *PMINIDUMP_HANDLE_OPERATION_LIST;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR {
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID           0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES        0x00000002
#define MINIDUMP_MISC1_PROCESSOR_POWER_INFO 0x00000004

typedef struct _MINIDUMP_MISC_INFO {
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;

typedef struct _MINIDUMP_MISC_INFO_2 {
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
} MINIDUMP_MISC_INFO_2, *PMINIDUMP_MISC_INFO_2;

// The latest MINIDUMP_MISC_INFO definition.
typedef MINIDUMP_MISC_INFO_2 MINIDUMP_MISC_INFO_N;
typedef MINIDUMP_MISC_INFO_N* PMINIDUMP_MISC_INFO_N;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

typedef struct _MINIDUMP_MEMORY_INFO {
    ULONG64 BaseAddress;
    ULONG64 AllocationBase;
    ULONG32 AllocationProtect;
    ULONG32 __alignment1;
    ULONG64 RegionSize;
    ULONG32 State;
    ULONG32 Protect;
    ULONG32 Type;
    ULONG32 __alignment2;
} MINIDUMP_MEMORY_INFO, *PMINIDUMP_MEMORY_INFO;

typedef struct _MINIDUMP_MEMORY_INFO_LIST {
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG64 NumberOfEntries;
} MINIDUMP_MEMORY_INFO_LIST, *PMINIDUMP_MEMORY_INFO_LIST;

    
//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

// Thread dump writer status flags.
#define MINIDUMP_THREAD_INFO_ERROR_THREAD    0x00000001
#define MINIDUMP_THREAD_INFO_WRITING_THREAD  0x00000002
#define MINIDUMP_THREAD_INFO_EXITED_THREAD   0x00000004
#define MINIDUMP_THREAD_INFO_INVALID_INFO    0x00000008
#define MINIDUMP_THREAD_INFO_INVALID_CONTEXT 0x00000010
#define MINIDUMP_THREAD_INFO_INVALID_TEB     0x00000020

typedef struct _MINIDUMP_THREAD_INFO {
    ULONG32 ThreadId;
    ULONG32 DumpFlags;
    ULONG32 DumpError;
    ULONG32 ExitStatus;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartAddress;
    ULONG64 Affinity;
} MINIDUMP_THREAD_INFO, *PMINIDUMP_THREAD_INFO;

typedef struct _MINIDUMP_THREAD_INFO_LIST {
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG NumberOfEntries;
} MINIDUMP_THREAD_INFO_LIST, *PMINIDUMP_THREAD_INFO_LIST;


//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
    MemoryCallback,
    CancelCallback,
    WriteKernelMinidumpCallback,
    KernelMinidumpStatusCallback,
    RemoveMemoryCallback,
    IncludeVmRegionCallback,
    IoStartCallback,
    IoWriteAllCallback,
    IoFinishCallback,
    ReadMemoryFailureCallback,
    SecondaryFlagsCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK {
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
    ThreadWriteThreadInfo        = 0x0040,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK {
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010,
    ModuleWriteTlsData       = 0x0020,
    ModuleWriteCodeSegs      = 0x0040,
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_IO_CALLBACK {
    HANDLE Handle;
    ULONG64 Offset;
    PVOID Buffer;
    ULONG BufferBytes;
} MINIDUMP_IO_CALLBACK, *PMINIDUMP_IO_CALLBACK;


typedef struct _MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
{
    ULONG64 Offset;
    ULONG Bytes;
    HRESULT FailureStatus;
} MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
  *PMINIDUMP_READ_MEMORY_FAILURE_CALLBACK;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        HRESULT Status;
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
        MINIDUMP_IO_CALLBACK Io;
        MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
        ULONG SecondaryFlags;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
        ULONG SecondaryFlags;
        struct {
            ULONG64 MemoryBase;
            ULONG MemorySize;
        };
        struct {
            BOOL CheckCancel;
            BOOL Cancel;
        };
        HANDLE Handle;
        struct {
            MINIDUMP_MEMORY_INFO VmRegion;
            BOOL Continue;
        };
        HRESULT Status;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        
//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//
// When doing a full memory dump it's possible to store all
// of the enumerated memory region descriptive information
// in a memory information stream.
//
// Additional thread information beyond the basic thread
// structure can be collected if desired.
//
// A minidump with code segments includes all of the code
// and code-related sections from loaded modules in order
// to capture executable content.
//
// MiniDumpWithoutAuxiliaryState turns off any secondary,
// auxiliary-supported memory gathering.
//
// MiniDumpWithFullAuxiliaryState asks any present auxiliary
// data providers to include all of their state in the dump.
// The exact set of what is provided depends on the auxiliary.
// This can be quite large.
//

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal                         = 0x00000000,
    MiniDumpWithDataSegs                   = 0x00000001,
    MiniDumpWithFullMemory                 = 0x00000002,
    MiniDumpWithHandleData                 = 0x00000004,
    MiniDumpFilterMemory                   = 0x00000008,
    MiniDumpScanMemory                     = 0x00000010,
    MiniDumpWithUnloadedModules            = 0x00000020,
    MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
    MiniDumpFilterModulePaths              = 0x00000080,
    MiniDumpWithProcessThreadData          = 0x00000100,
    MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
    MiniDumpWithoutOptionalData            = 0x00000400,
    MiniDumpWithFullMemoryInfo             = 0x00000800,
    MiniDumpWithThreadInfo                 = 0x00001000,
    MiniDumpWithCodeSegs                   = 0x00002000,
    MiniDumpWithoutAuxiliaryState          = 0x00004000,
    MiniDumpWithFullAuxiliaryState         = 0x00008000,
    
    MiniDumpValidTypeFlags                 = 0x0000ffff,
} MINIDUMP_TYPE;

//
// In addition to the primary flags provided to
// MiniDumpWriteDump there are additional, less
// frequently used options queried via the secondary
// flags callback.
//
// MiniSecondaryWithoutPowerInfo suppresses the minidump
// query that retrieves processor power information for
// MINIDUMP_MISC_INFO.
//
    
typedef enum _MINIDUMP_SECONDARY_FLAGS {
    MiniSecondaryWithoutPowerInfo = 0x00000001,

    MiniSecondaryValidFlags       = 0x00000001,
} MINIDUMP_SECONDARY_FLAGS;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID BaseOfDump,
    IN ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * StreamPointer, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)    /* Zero length array */
#pragma warning(default:4201)    /* Nameless struct/union */
#endif
#endif
#endif

#include <poppack.h>

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DbgEng.h ===
//----------------------------------------------------------------------------
//
// Debugger engine interfaces.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//----------------------------------------------------------------------------

#ifndef __DBGENG_H__
#define __DBGENG_H__

#include <stdarg.h>
#include <objbase.h>

#ifndef _WDBGEXTS_
typedef struct _WINDBG_EXTENSION_APIS32* PWINDBG_EXTENSION_APIS32;
typedef struct _WINDBG_EXTENSION_APIS64* PWINDBG_EXTENSION_APIS64;
#endif

#ifndef _CRASHLIB_
typedef struct _MEMORY_BASIC_INFORMATION64* PMEMORY_BASIC_INFORMATION64;
#endif

#ifndef __specstrings
// Should include SpecStrings.h to get proper definitions.
#define __in
#define __in_opt
#define __in_bcount(x)
#define __in_bcount_opt(x)
#define __in_ecount(x)
#define __in_ecount_opt(x)
#define __out
#define __out_opt
#define __out_bcount(x)
#define __out_bcount_opt(x)
#define __out_ecount(x)
#define __out_ecount_opt(x)
#define __out_xcount(x)
#define __inout
#define __inout_opt
#define __reserved
#endif

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//
// GUIDs and interface forward declarations.
//
//----------------------------------------------------------------------------

/* f2df5f53-071f-47bd-9de6-5734c3fed689 */
DEFINE_GUID(IID_IDebugAdvanced, 0xf2df5f53, 0x071f, 0x47bd,
            0x9d, 0xe6, 0x57, 0x34, 0xc3, 0xfe, 0xd6, 0x89);
/* 716d14c9-119b-4ba5-af1f-0890e672416a */
DEFINE_GUID(IID_IDebugAdvanced2, 0x716d14c9, 0x119b, 0x4ba5,
            0xaf, 0x1f, 0x08, 0x90, 0xe6, 0x72, 0x41, 0x6a);
/* cba4abb4-84c4-444d-87ca-a04e13286739 */
DEFINE_GUID(IID_IDebugAdvanced3, 0xcba4abb4, 0x84c4, 0x444d,
            0x87, 0xca, 0xa0, 0x4e, 0x13, 0x28, 0x67, 0x39);
/* 5bd9d474-5975-423a-b88b-65a8e7110e65 */
DEFINE_GUID(IID_IDebugBreakpoint, 0x5bd9d474, 0x5975, 0x423a,
            0xb8, 0x8b, 0x65, 0xa8, 0xe7, 0x11, 0x0e, 0x65);
/* 1b278d20-79f2-426e-a3f9-c1ddf375d48e */
DEFINE_GUID(IID_IDebugBreakpoint2, 0x1b278d20, 0x79f2, 0x426e,
            0xa3, 0xf9, 0xc1, 0xdd, 0xf3, 0x75, 0xd4, 0x8e);
/* 27fe5639-8407-4f47-8364-ee118fb08ac8 */
DEFINE_GUID(IID_IDebugClient, 0x27fe5639, 0x8407, 0x4f47,
            0x83, 0x64, 0xee, 0x11, 0x8f, 0xb0, 0x8a, 0xc8);
/* edbed635-372e-4dab-bbfe-ed0d2f63be81 */
DEFINE_GUID(IID_IDebugClient2, 0xedbed635, 0x372e, 0x4dab,
        0xbb, 0xfe, 0xed, 0x0d, 0x2f, 0x63, 0xbe, 0x81);
/* dd492d7f-71b8-4ad6-a8dc-1c887479ff91 */
DEFINE_GUID(IID_IDebugClient3, 0xdd492d7f, 0x71b8, 0x4ad6,
            0xa8, 0xdc, 0x1c, 0x88, 0x74, 0x79, 0xff, 0x91);
/* ca83c3de-5089-4cf8-93c8-d892387f2a5e */
DEFINE_GUID(IID_IDebugClient4, 0xca83c3de, 0x5089, 0x4cf8,
            0x93, 0xc8, 0xd8, 0x92, 0x38, 0x7f, 0x2a, 0x5e);
/* e3acb9d7-7ec2-4f0c-a0da-e81e0cbbe628 */
DEFINE_GUID(IID_IDebugClient5, 0xe3acb9d7, 0x7ec2, 0x4f0c,
            0xa0, 0xda, 0xe8, 0x1e, 0x0c, 0xbb, 0xe6, 0x28);
/* 5182e668-105e-416e-ad92-24ef800424ba */
DEFINE_GUID(IID_IDebugControl, 0x5182e668, 0x105e, 0x416e,
            0xad, 0x92, 0x24, 0xef, 0x80, 0x04, 0x24, 0xba);
/* d4366723-44df-4bed-8c7e-4c05424f4588 */
DEFINE_GUID(IID_IDebugControl2, 0xd4366723, 0x44df, 0x4bed,
            0x8c, 0x7e, 0x4c, 0x05, 0x42, 0x4f, 0x45, 0x88);
/* 7df74a86-b03f-407f-90ab-a20dadcead08 */
DEFINE_GUID(IID_IDebugControl3, 0x7df74a86, 0xb03f, 0x407f,
            0x90, 0xab, 0xa2, 0x0d, 0xad, 0xce, 0xad, 0x08);
/* 94e60ce9-9b41-4b19-9fc0-6d9eb35272b3 */
DEFINE_GUID(IID_IDebugControl4, 0x94e60ce9, 0x9b41, 0x4b19,
            0x9f, 0xc0, 0x6d, 0x9e, 0xb3, 0x52, 0x72, 0xb3);
/* 88f7dfab-3ea7-4c3a-aefb-c4e8106173aa */
DEFINE_GUID(IID_IDebugDataSpaces, 0x88f7dfab, 0x3ea7, 0x4c3a,
            0xae, 0xfb, 0xc4, 0xe8, 0x10, 0x61, 0x73, 0xaa);
/* 7a5e852f-96e9-468f-ac1b-0b3addc4a049 */
DEFINE_GUID(IID_IDebugDataSpaces2, 0x7a5e852f, 0x96e9, 0x468f,
            0xac, 0x1b, 0x0b, 0x3a, 0xdd, 0xc4, 0xa0, 0x49);
/* 23f79d6c-8aaf-4f7c-a607-9995f5407e63 */
DEFINE_GUID(IID_IDebugDataSpaces3, 0x23f79d6c, 0x8aaf, 0x4f7c,
            0xa6, 0x07, 0x99, 0x95, 0xf5, 0x40, 0x7e, 0x63);
/* d98ada1f-29e9-4ef5-a6c0-e53349883212 */
DEFINE_GUID(IID_IDebugDataSpaces4, 0xd98ada1f, 0x29e9, 0x4ef5,
            0xa6, 0xc0, 0xe5, 0x33, 0x49, 0x88, 0x32, 0x12);
/* 337be28b-5036-4d72-b6bf-c45fbb9f2eaa */
DEFINE_GUID(IID_IDebugEventCallbacks, 0x337be28b, 0x5036, 0x4d72,
            0xb6, 0xbf, 0xc4, 0x5f, 0xbb, 0x9f, 0x2e, 0xaa);
/* 0690e046-9c23-45ac-a04f-987ac29ad0d3 */
DEFINE_GUID(IID_IDebugEventCallbacksWide, 0x0690e046, 0x9c23, 0x45ac,
            0xa0, 0x4f, 0x98, 0x7a, 0xc2, 0x9a, 0xd0, 0xd3);
/* 9f50e42c-f136-499e-9a97-73036c94ed2d */
DEFINE_GUID(IID_IDebugInputCallbacks, 0x9f50e42c, 0xf136, 0x499e,
            0x9a, 0x97, 0x73, 0x03, 0x6c, 0x94, 0xed, 0x2d);
/* 4bf58045-d654-4c40-b0af-683090f356dc */
DEFINE_GUID(IID_IDebugOutputCallbacks, 0x4bf58045, 0xd654, 0x4c40,
            0xb0, 0xaf, 0x68, 0x30, 0x90, 0xf3, 0x56, 0xdc);
/* 4c7fd663-c394-4e26-8ef1-34ad5ed3764c */
DEFINE_GUID(IID_IDebugOutputCallbacksWide, 0x4c7fd663, 0xc394, 0x4e26,
            0x8e, 0xf1, 0x34, 0xad, 0x5e, 0xd3, 0x76, 0x4c);
/* ce289126-9e84-45a7-937e-67bb18691493 */
DEFINE_GUID(IID_IDebugRegisters, 0xce289126, 0x9e84, 0x45a7,
            0x93, 0x7e, 0x67, 0xbb, 0x18, 0x69, 0x14, 0x93);
/* 1656afa9-19c6-4e3a-97e7-5dc9160cf9c4 */
DEFINE_GUID(IID_IDebugRegisters2, 0x1656afa9, 0x19c6, 0x4e3a,
            0x97, 0xe7, 0x5d, 0xc9, 0x16, 0x0c, 0xf9, 0xc4);
/* f2528316-0f1a-4431-aeed-11d096e1e2ab */
DEFINE_GUID(IID_IDebugSymbolGroup, 0xf2528316, 0x0f1a, 0x4431,
            0xae, 0xed, 0x11, 0xd0, 0x96, 0xe1, 0xe2, 0xab);
/* 6a7ccc5f-fb5e-4dcc-b41c-6c20307bccc7 */
DEFINE_GUID(IID_IDebugSymbolGroup2, 0x6a7ccc5f, 0xfb5e, 0x4dcc,
            0xb4, 0x1c, 0x6c, 0x20, 0x30, 0x7b, 0xcc, 0xc7);
/* 8c31e98c-983a-48a5-9016-6fe5d667a950 */
DEFINE_GUID(IID_IDebugSymbols, 0x8c31e98c, 0x983a, 0x48a5,
            0x90, 0x16, 0x6f, 0xe5, 0xd6, 0x67, 0xa9, 0x50);
/* 3a707211-afdd-4495-ad4f-56fecdf8163f */
DEFINE_GUID(IID_IDebugSymbols2, 0x3a707211, 0xafdd, 0x4495,
            0xad, 0x4f, 0x56, 0xfe, 0xcd, 0xf8, 0x16, 0x3f);
/* f02fbecc-50ac-4f36-9ad9-c975e8f32ff8 */
DEFINE_GUID(IID_IDebugSymbols3, 0xf02fbecc, 0x50ac, 0x4f36,
            0x9a, 0xd9, 0xc9, 0x75, 0xe8, 0xf3, 0x2f, 0xf8);
/* 6b86fe2c-2c4f-4f0c-9da2-174311acc327 */
DEFINE_GUID(IID_IDebugSystemObjects, 0x6b86fe2c, 0x2c4f, 0x4f0c,
            0x9d, 0xa2, 0x17, 0x43, 0x11, 0xac, 0xc3, 0x27);
/* 0ae9f5ff-1852-4679-b055-494bee6407ee */
DEFINE_GUID(IID_IDebugSystemObjects2, 0x0ae9f5ff, 0x1852, 0x4679,
            0xb0, 0x55, 0x49, 0x4b, 0xee, 0x64, 0x07, 0xee);
/* e9676e2f-e286-4ea3-b0f9-dfe5d9fc330e */
DEFINE_GUID(IID_IDebugSystemObjects3, 0xe9676e2f, 0xe286, 0x4ea3,
            0xb0, 0xf9, 0xdf, 0xe5, 0xd9, 0xfc, 0x33, 0x0e);
/* 489468e6-7d0f-4af5-87ab-25207454d553 */
DEFINE_GUID(IID_IDebugSystemObjects4, 0x489468e6, 0x7d0f, 0x4af5,
            0x87, 0xab, 0x25, 0x20, 0x74, 0x54, 0xd5, 0x53);

typedef interface DECLSPEC_UUID("f2df5f53-071f-47bd-9de6-5734c3fed689")
    IDebugAdvanced* PDEBUG_ADVANCED;
typedef interface DECLSPEC_UUID("716d14c9-119b-4ba5-af1f-0890e672416a")
    IDebugAdvanced2* PDEBUG_ADVANCED2;
typedef interface DECLSPEC_UUID("cba4abb4-84c4-444d-87ca-a04e13286739")
    IDebugAdvanced3* PDEBUG_ADVANCED3;
typedef interface DECLSPEC_UUID("5bd9d474-5975-423a-b88b-65a8e7110e65")
    IDebugBreakpoint* PDEBUG_BREAKPOINT;
typedef interface DECLSPEC_UUID("1b278d20-79f2-426e-a3f9-c1ddf375d48e")
    IDebugBreakpoint2* PDEBUG_BREAKPOINT2;
typedef interface DECLSPEC_UUID("27fe5639-8407-4f47-8364-ee118fb08ac8")
    IDebugClient* PDEBUG_CLIENT;
typedef interface DECLSPEC_UUID("edbed635-372e-4dab-bbfe-ed0d2f63be81")
    IDebugClient2* PDEBUG_CLIENT2;
typedef interface DECLSPEC_UUID("dd492d7f-71b8-4ad6-a8dc-1c887479ff91")
    IDebugClient3* PDEBUG_CLIENT3;
typedef interface DECLSPEC_UUID("ca83c3de-5089-4cf8-93c8-d892387f2a5e")
    IDebugClient4* PDEBUG_CLIENT4;
typedef interface DECLSPEC_UUID("e3acb9d7-7ec2-4f0c-a0da-e81e0cbbe628")
    IDebugClient5* PDEBUG_CLIENT5;
typedef interface DECLSPEC_UUID("5182e668-105e-416e-ad92-24ef800424ba")
    IDebugControl* PDEBUG_CONTROL;
typedef interface DECLSPEC_UUID("d4366723-44df-4bed-8c7e-4c05424f4588")
    IDebugControl2* PDEBUG_CONTROL2;
typedef interface DECLSPEC_UUID("7df74a86-b03f-407f-90ab-a20dadcead08")
    IDebugControl3* PDEBUG_CONTROL3;
typedef interface DECLSPEC_UUID("94e60ce9-9b41-4b19-9fc0-6d9eb35272b3")
    IDebugControl4* PDEBUG_CONTROL4;
typedef interface DECLSPEC_UUID("88f7dfab-3ea7-4c3a-aefb-c4e8106173aa")
    IDebugDataSpaces* PDEBUG_DATA_SPACES;
typedef interface DECLSPEC_UUID("7a5e852f-96e9-468f-ac1b-0b3addc4a049")
    IDebugDataSpaces2* PDEBUG_DATA_SPACES2;
typedef interface DECLSPEC_UUID("23f79d6c-8aaf-4f7c-a607-9995f5407e63")
    IDebugDataSpaces3* PDEBUG_DATA_SPACES3;
typedef interface DECLSPEC_UUID("d98ada1f-29e9-4ef5-a6c0-e53349883212")
    IDebugDataSpaces4* PDEBUG_DATA_SPACES4;
typedef interface DECLSPEC_UUID("337be28b-5036-4d72-b6bf-c45fbb9f2eaa")
    IDebugEventCallbacks* PDEBUG_EVENT_CALLBACKS;
typedef interface DECLSPEC_UUID("0690e046-9c23-45ac-a04f-987ac29ad0d3")
    IDebugEventCallbacksWide* PDEBUG_EVENT_CALLBACKS_WIDE;
typedef interface DECLSPEC_UUID("9f50e42c-f136-499e-9a97-73036c94ed2d")
    IDebugInputCallbacks* PDEBUG_INPUT_CALLBACKS;
typedef interface DECLSPEC_UUID("4bf58045-d654-4c40-b0af-683090f356dc")
    IDebugOutputCallbacks* PDEBUG_OUTPUT_CALLBACKS;
typedef interface DECLSPEC_UUID("4c7fd663-c394-4e26-8ef1-34ad5ed3764c")
    IDebugOutputCallbacksWide* PDEBUG_OUTPUT_CALLBACKS_WIDE;
typedef interface DECLSPEC_UUID("ce289126-9e84-45a7-937e-67bb18691493")
    IDebugRegisters* PDEBUG_REGISTERS;
typedef interface DECLSPEC_UUID("1656afa9-19c6-4e3a-97e7-5dc9160cf9c4")
    IDebugRegisters2* PDEBUG_REGISTERS2;
typedef interface DECLSPEC_UUID("f2528316-0f1a-4431-aeed-11d096e1e2ab")
    IDebugSymbolGroup* PDEBUG_SYMBOL_GROUP;
typedef interface DECLSPEC_UUID("6a7ccc5f-fb5e-4dcc-b41c-6c20307bccc7")
    IDebugSymbolGroup2* PDEBUG_SYMBOL_GROUP2;
typedef interface DECLSPEC_UUID("8c31e98c-983a-48a5-9016-6fe5d667a950")
    IDebugSymbols* PDEBUG_SYMBOLS;
typedef interface DECLSPEC_UUID("3a707211-afdd-4495-ad4f-56fecdf8163f")
    IDebugSymbols2* PDEBUG_SYMBOLS2;
typedef interface DECLSPEC_UUID("f02fbecc-50ac-4f36-9ad9-c975e8f32ff8")
    IDebugSymbols3* PDEBUG_SYMBOLS3;
typedef interface DECLSPEC_UUID("6b86fe2c-2c4f-4f0c-9da2-174311acc327")
    IDebugSystemObjects* PDEBUG_SYSTEM_OBJECTS;
typedef interface DECLSPEC_UUID("0ae9f5ff-1852-4679-b055-494bee6407ee")
    IDebugSystemObjects2* PDEBUG_SYSTEM_OBJECTS2;
typedef interface DECLSPEC_UUID("e9676e2f-e286-4ea3-b0f9-dfe5d9fc330e")
    IDebugSystemObjects3* PDEBUG_SYSTEM_OBJECTS3;
typedef interface DECLSPEC_UUID("489468e6-7d0f-4af5-87ab-25207454d553")
    IDebugSystemObjects4* PDEBUG_SYSTEM_OBJECTS4;

//----------------------------------------------------------------------------
//
// Macros.
//
//----------------------------------------------------------------------------

// Extends a 32-bit address into a 64-bit address.
#define DEBUG_EXTEND64(Addr) ((ULONG64)(LONG64)(LONG)(Addr))

//----------------------------------------------------------------------------
//
// Client creation functions.
//
//----------------------------------------------------------------------------

// RemoteOptions specifies connection types and
// their parameters.  Supported strings are:
//    npipe:Server=<Machine>,Pipe=<Pipe name>
//    tcp:Server=<Machine>,Port=<IP port>
STDAPI
DebugConnect(
    __in PCSTR RemoteOptions,
    __in REFIID InterfaceId,
    __out PVOID* Interface
    );

STDAPI
DebugConnectWide(
    __in PCWSTR RemoteOptions,
    __in REFIID InterfaceId,
    __out PVOID* Interface
    );

STDAPI
DebugCreate(
    __in REFIID InterfaceId,
    __out PVOID* Interface
    );

//----------------------------------------------------------------------------
//
// IDebugAdvanced.
//
//----------------------------------------------------------------------------

typedef struct _DEBUG_OFFSET_REGION
{
    ULONG64 Base;
    ULONG64 Size;
} DEBUG_OFFSET_REGION, *PDEBUG_OFFSET_REGION;

#undef INTERFACE
#define INTERFACE IDebugAdvanced
DECLARE_INTERFACE_(IDebugAdvanced, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugAdvanced.

    // Get/SetThreadContext offer control over
    // the full processor context for a thread.
    // Higher-level functions, such as the
    // IDebugRegisters interface, allow similar
    // access in simpler and more generic ways.
    // Get/SetThreadContext are useful when
    // large amounts of thread context must
    // be changed and processor-specific code
    // is not a problem.
    STDMETHOD(GetThreadContext)(
        THIS_
        __out_bcount(ContextSize) /* align_is(16) */ PVOID Context,
        __in ULONG ContextSize
        ) PURE;
    STDMETHOD(SetThreadContext)(
        THIS_
        __in_bcount(ContextSize) /* align_is(16) */ PVOID Context,
        __in ULONG ContextSize
        ) PURE;
};

typedef struct _DEBUG_READ_USER_MINIDUMP_STREAM
{
    IN ULONG StreamType;
    IN ULONG Flags;
    IN ULONG64 Offset;
    OUT PVOID Buffer;
    IN ULONG BufferSize;
    OUT ULONG BufferUsed;
} DEBUG_READ_USER_MINIDUMP_STREAM, *PDEBUG_READ_USER_MINIDUMP_STREAM;

//
// Request requests.
//

// InBuffer - Unused.
// OutBuffer - Unused.
#define DEBUG_REQUEST_SOURCE_PATH_HAS_SOURCE_SERVER 0

// InBuffer - Unused.
// OutBuffer - Machine-specific CONTEXT.
#define DEBUG_REQUEST_TARGET_EXCEPTION_CONTEXT 1

// InBuffer - Unused.
// OutBuffer - ULONG system ID of thread.
#define DEBUG_REQUEST_TARGET_EXCEPTION_THREAD 2

// InBuffer - Unused.
// OutBuffer - EXCEPTION_RECORD64.
#define DEBUG_REQUEST_TARGET_EXCEPTION_RECORD 3

// InBuffer - Unused.
// OutBuffer - DEBUG_CREATE_PROCESS_OPTIONS.
#define DEBUG_REQUEST_GET_ADDITIONAL_CREATE_OPTIONS 4

// InBuffer - DEBUG_CREATE_PROCESS_OPTIONS.
// OutBuffer - Unused.
#define DEBUG_REQUEST_SET_ADDITIONAL_CREATE_OPTIONS 5

// InBuffer - Unused.
// OutBuffer - ULONG[2] major/minor.
#define DEBUG_REQUEST_GET_WIN32_MAJOR_MINOR_VERSIONS 6

// InBuffer - DEBUG_READ_USER_MINIDUMP_STREAM.
// OutBuffer - Unused.
#define DEBUG_REQUEST_READ_USER_MINIDUMP_STREAM 7

// InBuffer - Unused.
// OutBuffer - Unused.
#define DEBUG_REQUEST_TARGET_CAN_DETACH 8

// InBuffer - PTSTR.
// OutBuffer - Unused.
#define DEBUG_REQUEST_SET_LOCAL_IMPLICIT_COMMAND_LINE 9

// InBuffer - Unused.
// OutBuffer - Event code stream offset.
#define DEBUG_REQUEST_GET_CAPTURED_EVENT_CODE_OFFSET 10

// InBuffer - Unused.
// OutBuffer - Event code stream information.
#define DEBUG_REQUEST_READ_CAPTURED_EVENT_CODE_STREAM 11

// InBuffer - Input data block.
// OutBuffer - Processed data block.
#define DEBUG_REQUEST_EXT_TYPED_DATA_ANSI 12

// InBuffer - Unused.
// OutBuffer - Returned path.
#define DEBUG_REQUEST_GET_EXTENSION_SEARCH_PATH_WIDE 13

//
// GetSourceFileInformation requests.
//

// Arg64 - Module base.
// Arg32 - Unused.
#define DEBUG_SRCFILE_SYMBOL_TOKEN 0

// Arg64 - Module base.
// Arg32 - Unused.
#define DEBUG_SRCFILE_SYMBOL_TOKEN_SOURCE_COMMAND_WIDE 1

//
// GetSymbolInformation requests.
//

// Arg64 - Unused.
// Arg32 - Breakpoint ID.
// Buffer - ULONG line number.
// String - File name.
#define DEBUG_SYMINFO_BREAKPOINT_SOURCE_LINE 0

// Arg64 - Module base.
// Arg32 - Unused.
// Buffer - IMAGEHLP_MODULEW64.
// String - Unused.
#define DEBUG_SYMINFO_IMAGEHLP_MODULEW64 1

// Arg64 - Offset.
// Arg32 - Symbol tag.
// Buffer - Unicode symbol name strings.  Could have multiple strings.
// String - Unused, strings are returned in Buffer as there
//          may be more than one.
#define DEBUG_SYMINFO_GET_SYMBOL_NAME_BY_OFFSET_AND_TAG_WIDE 2

// Arg64 - Module base.
// Arg32 - Symbol tag.
// Buffer - Array of symbol addresses.
// String - Concatenated symbol strings.  Individual symbol
//          strings are zero-terminated and the final string in
//          a symbol is double-zero-terminated.
#define DEBUG_SYMINFO_GET_MODULE_SYMBOL_NAMES_AND_OFFSETS 3

//
// GetSystemObjectInformation requests.
//

// Arg64 - Unused.
// Arg32 - Debugger thread ID.
#define DEBUG_SYSOBJINFO_THREAD_BASIC_INFORMATION 0

#define DEBUG_TBINFO_EXIT_STATUS    0x00000001
#define DEBUG_TBINFO_PRIORITY_CLASS 0x00000002
#define DEBUG_TBINFO_PRIORITY       0x00000004
#define DEBUG_TBINFO_TIMES          0x00000008
#define DEBUG_TBINFO_START_OFFSET   0x00000010
#define DEBUG_TBINFO_AFFINITY       0x00000020
#define DEBUG_TBINFO_ALL            0x0000003f

typedef struct _DEBUG_THREAD_BASIC_INFORMATION
{
    // Valid members have a DEBUG_TBINFO bit set in Valid.
    ULONG Valid;
    ULONG ExitStatus;
    ULONG PriorityClass;
    ULONG Priority;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartOffset;
    ULONG64 Affinity;
} DEBUG_THREAD_BASIC_INFORMATION, *PDEBUG_THREAD_BASIC_INFORMATION;

#undef INTERFACE
#define INTERFACE IDebugAdvanced2
DECLARE_INTERFACE_(IDebugAdvanced2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugAdvanced.

    // Get/SetThreadContext offer control over
    // the full processor context for a thread.
    // Higher-level functions, such as the
    // IDebugRegisters interface, allow similar
    // access in simpler and more generic ways.
    // Get/SetThreadContext are useful when
    // large amounts of thread context must
    // be changed and processor-specific code
    // is not a problem.
    STDMETHOD(GetThreadContext)(
        THIS_
        __out_bcount(ContextSize) /* align_is(16) */ PVOID Context,
        __in ULONG ContextSize
        ) PURE;
    STDMETHOD(SetThreadContext)(
        THIS_
        __in_bcount(ContextSize) /* align_is(16) */ PVOID Context,
        __in ULONG ContextSize
        ) PURE;

    // IDebugAdvanced2.

    //
    // Generalized open-ended methods for querying
    // and manipulation.  The open-ended nature of
    // these methods makes it easy to add new requests,
    // although at a cost in convenience of calling.
    // Sufficiently common requests may have more specific,
    // simpler methods elsewhere.
    //

    STDMETHOD(Request)(
        THIS_
        __in ULONG Request,
        __in_bcount_opt(InBufferSize) PVOID InBuffer,
        __in ULONG InBufferSize,
        __out_bcount_opt(OutBufferSize) PVOID OutBuffer,
        __in ULONG OutBufferSize,
        __out_opt PULONG OutSize
        ) PURE;

    STDMETHOD(GetSourceFileInformation)(
        THIS_
        __in ULONG Which,
        __in PSTR SourceFile,
        __in ULONG64 Arg64,
        __in ULONG Arg32,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize
        ) PURE;
    STDMETHOD(FindSourceFileAndToken)(
        THIS_
        __in ULONG StartElement,
        __in ULONG64 ModAddr,
        __in PCSTR File,
        __in ULONG Flags,
        __in_bcount_opt(FileTokenSize) PVOID FileToken,
        __in ULONG FileTokenSize,
        __out_opt PULONG FoundElement,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FoundSize
        ) PURE;

    STDMETHOD(GetSymbolInformation)(
        THIS_
        __in ULONG Which,
        __in ULONG64 Arg64,
        __in ULONG Arg32,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize,
        __out_ecount_opt(StringBufferSize) PSTR StringBuffer,
        __in ULONG StringBufferSize,
        __out_opt PULONG StringSize
        ) PURE;

    STDMETHOD(GetSystemObjectInformation)(
        THIS_
        __in ULONG Which,
        __in ULONG64 Arg64,
        __in ULONG Arg32,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugAdvanced3
DECLARE_INTERFACE_(IDebugAdvanced3, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugAdvanced.

    // Get/SetThreadContext offer control over
    // the full processor context for a thread.
    // Higher-level functions, such as the
    // IDebugRegisters interface, allow similar
    // access in simpler and more generic ways.
    // Get/SetThreadContext are useful when
    // large amounts of thread context must
    // be changed and processor-specific code
    // is not a problem.
    STDMETHOD(GetThreadContext)(
        THIS_
        __out_bcount(ContextSize) /* align_is(16) */ PVOID Context,
        __in ULONG ContextSize
        ) PURE;
    STDMETHOD(SetThreadContext)(
        THIS_
        __in_bcount(ContextSize) /* align_is(16) */ PVOID Context,
        __in ULONG ContextSize
        ) PURE;

    // IDebugAdvanced2.

    //
    // Generalized open-ended methods for querying
    // and manipulation.  The open-ended nature of
    // these methods makes it easy to add new requests,
    // although at a cost in convenience of calling.
    // Sufficiently common requests may have more specific,
    // simpler methods elsewhere.
    //

    STDMETHOD(Request)(
        THIS_
        __in ULONG Request,
        __in_bcount_opt(InBufferSize) PVOID InBuffer,
        __in ULONG InBufferSize,
        __out_bcount_opt(OutBufferSize) PVOID OutBuffer,
        __in ULONG OutBufferSize,
        __out_opt PULONG OutSize
        ) PURE;

    STDMETHOD(GetSourceFileInformation)(
        THIS_
        __in ULONG Which,
        __in PSTR SourceFile,
        __in ULONG64 Arg64,
        __in ULONG Arg32,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize
        ) PURE;
    STDMETHOD(FindSourceFileAndToken)(
        THIS_
        __in ULONG StartElement,
        __in ULONG64 ModAddr,
        __in PCSTR File,
        __in ULONG Flags,
        __in_bcount_opt(FileTokenSize) PVOID FileToken,
        __in ULONG FileTokenSize,
        __out_opt PULONG FoundElement,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FoundSize
        ) PURE;

    STDMETHOD(GetSymbolInformation)(
        THIS_
        __in ULONG Which,
        __in ULONG64 Arg64,
        __in ULONG Arg32,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize,
        __out_ecount_opt(StringBufferSize) PSTR StringBuffer,
        __in ULONG StringBufferSize,
        __out_opt PULONG StringSize
        ) PURE;

    STDMETHOD(GetSystemObjectInformation)(
        THIS_
        __in ULONG Which,
        __in ULONG64 Arg64,
        __in ULONG Arg32,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize
        ) PURE;

    // IDebugAdvanced3.

    STDMETHOD(GetSourceFileInformationWide)(
        THIS_
        __in ULONG Which,
        __in PWSTR SourceFile,
        __in ULONG64 Arg64,
        __in ULONG Arg32,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize
        ) PURE;
    STDMETHOD(FindSourceFileAndTokenWide)(
        THIS_
        __in ULONG StartElement,
        __in ULONG64 ModAddr,
        __in PCWSTR File,
        __in ULONG Flags,
        __in_bcount_opt(FileTokenSize) PVOID FileToken,
        __in ULONG FileTokenSize,
        __out_opt PULONG FoundElement,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FoundSize
        ) PURE;

    STDMETHOD(GetSymbolInformationWide)(
        THIS_
        __in ULONG Which,
        __in ULONG64 Arg64,
        __in ULONG Arg32,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize,
        __out_ecount_opt(StringBufferSize) PWSTR StringBuffer,
        __in ULONG StringBufferSize,
        __out_opt PULONG StringSize
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugBreakpoint.
//
//----------------------------------------------------------------------------

// Types of breakpoints.
#define DEBUG_BREAKPOINT_CODE 0
#define DEBUG_BREAKPOINT_DATA 1
#define DEBUG_BREAKPOINT_TIME 2

// Breakpoint flags.
// Go-only breakpoints are only active when
// the engine is in unrestricted execution
// mode.  They do not fire when the engine
// is stepping.
#define DEBUG_BREAKPOINT_GO_ONLY    0x00000001
// A breakpoint is flagged as deferred as long as
// its offset expression cannot be evaluated.
// A deferred breakpoint is not active.
#define DEBUG_BREAKPOINT_DEFERRED   0x00000002
#define DEBUG_BREAKPOINT_ENABLED    0x00000004
// The adder-only flag does not affect breakpoint
// operation.  It is just a marker to restrict
// output and notifications for the breakpoint to
// the client that added the breakpoint.  Breakpoint
// callbacks for adder-only breaks will only be delivered
// to the adding client.  The breakpoint can not
// be enumerated and accessed by other clients.
#define DEBUG_BREAKPOINT_ADDER_ONLY 0x00000008
// One-shot breakpoints automatically clear themselves
// the first time they are hit.
#define DEBUG_BREAKPOINT_ONE_SHOT   0x00000010

// Data breakpoint access types.
// Different architectures support different
// sets of these bits.
#define DEBUG_BREAK_READ    0x00000001
#define DEBUG_BREAK_WRITE   0x00000002
#define DEBUG_BREAK_EXECUTE 0x00000004
#define DEBUG_BREAK_IO      0x00000008

// Structure for querying breakpoint information
// all at once.
typedef struct _DEBUG_BREAKPOINT_PARAMETERS
{
    ULONG64 Offset;
    ULONG Id;
    ULONG BreakType;
    ULONG ProcType;
    ULONG Flags;
    ULONG DataSize;
    ULONG DataAccessType;
    ULONG PassCount;
    ULONG CurrentPassCount;
    ULONG MatchThread;
    ULONG CommandSize;
    ULONG OffsetExpressionSize;
} DEBUG_BREAKPOINT_PARAMETERS, *PDEBUG_BREAKPOINT_PARAMETERS;

#undef INTERFACE
#define INTERFACE IDebugBreakpoint
DECLARE_INTERFACE_(IDebugBreakpoint, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugBreakpoint.

    // Retrieves debugger engine unique ID
    // for the breakpoint.  This ID is
    // fixed as long as the breakpoint exists
    // but after that may be reused.
    STDMETHOD(GetId)(
        THIS_
        __out PULONG Id
        ) PURE;
    // Retrieves the type of break and
    // processor type for the breakpoint.
    STDMETHOD(GetType)(
        THIS_
        __out PULONG BreakType,
        __out PULONG ProcType
        ) PURE;
    // Returns the client that called AddBreakpoint.
    STDMETHOD(GetAdder)(
        THIS_
        __out PDEBUG_CLIENT* Adder
        ) PURE;

    STDMETHOD(GetFlags)(
        THIS_
        __out PULONG Flags
        ) PURE;
    // Only certain flags can be changed.  Flags
    // are: GO_ONLY, ENABLE.
    // Sets the given flags.
    STDMETHOD(AddFlags)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Clears the given flags.
    STDMETHOD(RemoveFlags)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Sets the flags.
    STDMETHOD(SetFlags)(
        THIS_
        __in ULONG Flags
        ) PURE;

    // Controls the offset of the breakpoint.  The
    // interpretation of the offset value depends on
    // the type of breakpoint and its settings.  It
    // may be a code address, a data address, an
    // I/O port, etc.
    STDMETHOD(GetOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(SetOffset)(
        THIS_
        __in ULONG64 Offset
        ) PURE;

    // Data breakpoint methods will fail if the
    // target platform does not support the
    // parameters used.
    // These methods only function for breakpoints
    // created as data breakpoints.
    STDMETHOD(GetDataParameters)(
        THIS_
        __out PULONG Size,
        __out PULONG AccessType
        ) PURE;
    STDMETHOD(SetDataParameters)(
        THIS_
        __in ULONG Size,
        __in ULONG AccessType
        ) PURE;

    // Pass count defaults to one.
    STDMETHOD(GetPassCount)(
        THIS_
        __out PULONG Count
        ) PURE;
    STDMETHOD(SetPassCount)(
        THIS_
        __in ULONG Count
        ) PURE;
    // Gets the current number of times
    // the breakpoint has been hit since
    // it was last triggered.
    STDMETHOD(GetCurrentPassCount)(
        THIS_
        __out PULONG Count
        ) PURE;

    // If a match thread is set this breakpoint will
    // only trigger if it occurs on the match thread.
    // Otherwise it triggers for all threads.
    // Thread restrictions are not currently supported
    // in kernel mode.
    STDMETHOD(GetMatchThreadId)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(SetMatchThreadId)(
        THIS_
        __in ULONG Thread
        ) PURE;

    // The command for a breakpoint is automatically
    // executed by the engine before the event
    // is propagated.  If the breakpoint continues
    // execution the event will begin with a continue
    // status.  If the breakpoint does not continue
    // the event will begin with a break status.
    // This allows breakpoint commands to participate
    // in the normal event status voting.
    // Breakpoint commands are only executed until
    // the first command that alters the execution
    // status, such as g, p and t.
    STDMETHOD(GetCommand)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetCommand)(
        THIS_
        __in PCSTR Command
        ) PURE;

    // Offset expressions are evaluated immediately
    // and at module load and unload events.  If the
    // evaluation is successful the breakpoints
    // offset is updated and the breakpoint is
    // handled normally.  If the expression cannot
    // be evaluated the breakpoint is deferred.
    // Currently the only offset expression
    // supported is a module-relative symbol
    // of the form <Module>!<Symbol>.
    STDMETHOD(GetOffsetExpression)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ExpressionSize
        ) PURE;
    STDMETHOD(SetOffsetExpression)(
        THIS_
        __in PCSTR Expression
        ) PURE;

    STDMETHOD(GetParameters)(
        THIS_
        __out PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugBreakpoint2
DECLARE_INTERFACE_(IDebugBreakpoint2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugBreakpoint.

    // Retrieves debugger engine unique ID
    // for the breakpoint.  This ID is
    // fixed as long as the breakpoint exists
    // but after that may be reused.
    STDMETHOD(GetId)(
        THIS_
        __out PULONG Id
        ) PURE;
    // Retrieves the type of break and
    // processor type for the breakpoint.
    STDMETHOD(GetType)(
        THIS_
        __out PULONG BreakType,
        __out PULONG ProcType
        ) PURE;
    // Returns the client that called AddBreakpoint.
    STDMETHOD(GetAdder)(
        THIS_
        __out PDEBUG_CLIENT* Adder
        ) PURE;

    STDMETHOD(GetFlags)(
        THIS_
        __out PULONG Flags
        ) PURE;
    // Only certain flags can be changed.  Flags
    // are: GO_ONLY, ENABLE.
    // Sets the given flags.
    STDMETHOD(AddFlags)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Clears the given flags.
    STDMETHOD(RemoveFlags)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Sets the flags.
    STDMETHOD(SetFlags)(
        THIS_
        __in ULONG Flags
        ) PURE;

    // Controls the offset of the breakpoint.  The
    // interpretation of the offset value depends on
    // the type of breakpoint and its settings.  It
    // may be a code address, a data address, an
    // I/O port, etc.
    STDMETHOD(GetOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(SetOffset)(
        THIS_
        __in ULONG64 Offset
        ) PURE;

    // Data breakpoint methods will fail if the
    // target platform does not support the
    // parameters used.
    // These methods only function for breakpoints
    // created as data breakpoints.
    STDMETHOD(GetDataParameters)(
        THIS_
        __out PULONG Size,
        __out PULONG AccessType
        ) PURE;
    STDMETHOD(SetDataParameters)(
        THIS_
        __in ULONG Size,
        __in ULONG AccessType
        ) PURE;

    // Pass count defaults to one.
    STDMETHOD(GetPassCount)(
        THIS_
        __out PULONG Count
        ) PURE;
    STDMETHOD(SetPassCount)(
        THIS_
        __in ULONG Count
        ) PURE;
    // Gets the current number of times
    // the breakpoint has been hit since
    // it was last triggered.
    STDMETHOD(GetCurrentPassCount)(
        THIS_
        __out PULONG Count
        ) PURE;

    // If a match thread is set this breakpoint will
    // only trigger if it occurs on the match thread.
    // Otherwise it triggers for all threads.
    // Thread restrictions are not currently supported
    // in kernel mode.
    STDMETHOD(GetMatchThreadId)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(SetMatchThreadId)(
        THIS_
        __in ULONG Thread
        ) PURE;

    // The command for a breakpoint is automatically
    // executed by the engine before the event
    // is propagated.  If the breakpoint continues
    // execution the event will begin with a continue
    // status.  If the breakpoint does not continue
    // the event will begin with a break status.
    // This allows breakpoint commands to participate
    // in the normal event status voting.
    // Breakpoint commands are only executed until
    // the first command that alters the execution
    // status, such as g, p and t.
    STDMETHOD(GetCommand)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetCommand)(
        THIS_
        __in PCSTR Command
        ) PURE;

    // Offset expressions are evaluated immediately
    // and at module load and unload events.  If the
    // evaluation is successful the breakpoints
    // offset is updated and the breakpoint is
    // handled normally.  If the expression cannot
    // be evaluated the breakpoint is deferred.
    // Currently the only offset expression
    // supported is a module-relative symbol
    // of the form <Module>!<Symbol>.
    STDMETHOD(GetOffsetExpression)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ExpressionSize
        ) PURE;
    STDMETHOD(SetOffsetExpression)(
        THIS_
        __in PCSTR Expression
        ) PURE;

    STDMETHOD(GetParameters)(
        THIS_
        __out PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;

    // IDebugBreakpoint2.

    STDMETHOD(GetCommandWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetCommandWide)(
        THIS_
        __in PCWSTR Command
        ) PURE;

    STDMETHOD(GetOffsetExpressionWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ExpressionSize
        ) PURE;
    STDMETHOD(SetOffsetExpressionWide)(
        THIS_
        __in PCWSTR Expression
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugClient.
//
//----------------------------------------------------------------------------

// Kernel attach flags.
#define DEBUG_ATTACH_KERNEL_CONNECTION 0x00000000
// Attach to the local machine.  If this flag is not set
// a connection is made to a separate target machine using
// the given connection options.
#define DEBUG_ATTACH_LOCAL_KERNEL      0x00000001
// Attach to an eXDI driver.
#define DEBUG_ATTACH_EXDI_DRIVER       0x00000002

// GetRunningProcessSystemIdByExecutableName flags.
// By default the match allows a tail match on
// just the filename.  The match returns the first hit
// even if multiple matches exist.
#define DEBUG_GET_PROC_DEFAULT      0x00000000
// The name must match fully.
#define DEBUG_GET_PROC_FULL_MATCH   0x00000001
// The match must be the only match.
#define DEBUG_GET_PROC_ONLY_MATCH   0x00000002
// The name is a service name instead of an executable name.
#define DEBUG_GET_PROC_SERVICE_NAME 0x00000004

// GetRunningProcessDescription flags.
#define DEBUG_PROC_DESC_DEFAULT         0x00000000
// Return only filenames, not full paths.
#define DEBUG_PROC_DESC_NO_PATHS        0x00000001
// Dont look up service names.
#define DEBUG_PROC_DESC_NO_SERVICES     0x00000002
// Dont look up MTS package names.
#define DEBUG_PROC_DESC_NO_MTS_PACKAGES 0x00000004
// Dont retrieve the command line.
#define DEBUG_PROC_DESC_NO_COMMAND_LINE 0x00000008
// Dont retrieve the session ID.
#define DEBUG_PROC_DESC_NO_SESSION_ID   0x00000010
// Dont retrieve the process's user name.
#define DEBUG_PROC_DESC_NO_USER_NAME    0x00000020

//
// Attach flags.
//

// Call DebugActiveProcess when attaching.
#define DEBUG_ATTACH_DEFAULT                   0x00000000
// When attaching to a process just examine
// the process state and suspend the threads.
// DebugActiveProcess is not called so the process
// is not actually being debugged.  This is useful
// for debugging processes holding locks which
// interfere with the operation of DebugActiveProcess
// or in situations where it is not desirable to
// actually set up as a debugger.
#define DEBUG_ATTACH_NONINVASIVE               0x00000001
// Attempt to attach to a process that was abandoned
// when being debugged.  This is only supported in
// some system versions.
// This flag also allows multiple debuggers to
// attach to the same process, which can result
// in numerous problems unless very carefully
// managed.
#define DEBUG_ATTACH_EXISTING                  0x00000002
// When attaching non-invasively, do not suspend
// threads.  It is the callers responsibility
// to either suspend the threads itself or be
// aware that the attach state may not reflect
// the current state of the process if threads
// are still running.
#define DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND    0x00000004
// When doing an invasive attach do not inject
// a break-in thread to generate the initial break-in
// event.  This can be useful to save resources when
// an initial break is not necessary or when injecting
// a thread might affect the debuggee's state.  This
// option is only supported on Windows XP and above.
#define DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK 0x00000008
// When doing an invasive attach resume all threads at the
// time of attach.  This makes it possible to attach
// to a process created suspended and cause it to start running.
#define DEBUG_ATTACH_INVASIVE_RESUME_PROCESS   0x00000010
// When doing a non-invasive attach the engine must
// recover information for all debuggee elements.  The
// engine may not have permissions for all elements,
// for example it may not be able to open all threads,
// and that would ordinarily block the attach.  This
// flag allows unusable elements to be ignored.
#define DEBUG_ATTACH_NONINVASIVE_ALLOW_PARTIAL 0x00000020


//
// Process creation flags to merge with Win32 flags.
//

// On Windows XP this flag prevents the debug
// heap from being used in the new process.
#define DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP CREATE_UNICODE_ENVIRONMENT
// Indicates that the native NT RTL process creation
// routines should be used instead of Win32.  This
// is only meaningful for special processes that run
// as NT native processes.
#define DEBUG_CREATE_PROCESS_THROUGH_RTL   STACK_SIZE_PARAM_IS_A_RESERVATION

//
// Process creation flags specific to the debugger engine.
//

#define DEBUG_ECREATE_PROCESS_DEFAULT                   0x00000000
#define DEBUG_ECREATE_PROCESS_INHERIT_HANDLES           0x00000001
#define DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS        0x00000002
#define DEBUG_ECREATE_PROCESS_USE_IMPLICIT_COMMAND_LINE 0x00000004

typedef struct _DEBUG_CREATE_PROCESS_OPTIONS
{
    // Win32 create flags.
    ULONG CreateFlags;
    // DEBUG_ECREATE_PROCESS_* flags.
    ULONG EngCreateFlags;
    // Application Verifier flags,
    // if DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS is set.
    ULONG VerifierFlags;
    // Must be zero.
    ULONG Reserved;
} DEBUG_CREATE_PROCESS_OPTIONS, *PDEBUG_CREATE_PROCESS_OPTIONS;

//
// Process options.
//

// Indicates that the debuggee process should be
// automatically detached when the debugger exits.
// A debugger can explicitly detach on exit or this
// flag can be set so that detach occurs regardless
// of how the debugger exits.
// This is only supported on some system versions.
#define DEBUG_PROCESS_DETACH_ON_EXIT    0x00000001
// Indicates that processes created by the current
// process should not be debugged.
// Modifying this flag is only supported on some
// system versions.
#define DEBUG_PROCESS_ONLY_THIS_PROCESS 0x00000002

// ConnectSession flags.
// Default connect.
#define DEBUG_CONNECT_SESSION_DEFAULT     0x00000000
// Do not output the debugger version.
#define DEBUG_CONNECT_SESSION_NO_VERSION  0x00000001
// Do not announce the connection.
#define DEBUG_CONNECT_SESSION_NO_ANNOUNCE 0x00000002

// OutputServers flags.
// Debugger servers from StartSever.
#define DEBUG_SERVERS_DEBUGGER 0x00000001
// Process servers from StartProcessServer.
#define DEBUG_SERVERS_PROCESS  0x00000002
#define DEBUG_SERVERS_ALL      0x00000003

// EndSession flags.
// Perform cleanup for the session.
#define DEBUG_END_PASSIVE          0x00000000
// Actively terminate the session and then perform cleanup.
#define DEBUG_END_ACTIVE_TERMINATE 0x00000001
// If possible, detach from all processes and then perform cleanup.
#define DEBUG_END_ACTIVE_DETACH    0x00000002
// Perform whatever cleanup is possible that doesn't require
// acquiring any locks.  This is useful for situations where
// a thread is currently using the engine but the application
// needs to exit and still wants to give the engine
// the opportunity to clean up as much as possible.
// This may leave the engine in an indeterminate state so
// further engine calls should not be made.
// When making a reentrant EndSession call from a remote
// client it is the callers responsibility to ensure
// that the server can process the request.  It is best
// to avoid making such calls.
#define DEBUG_END_REENTRANT        0x00000003
// Notify a server that a remote client is disconnecting.
// This isnt required but if it isnt called then
// no disconnect messages will be generated by the server.
#define DEBUG_END_DISCONNECT       0x00000004

// Output mask bits.
// Normal output.
#define DEBUG_OUTPUT_NORMAL            0x00000001
// Error output.
#define DEBUG_OUTPUT_ERROR             0x00000002
// Warnings.
#define DEBUG_OUTPUT_WARNING           0x00000004
// Additional output.
#define DEBUG_OUTPUT_VERBOSE           0x00000008
// Prompt output.
#define DEBUG_OUTPUT_PROMPT            0x00000010
// Register dump before prompt.
#define DEBUG_OUTPUT_PROMPT_REGISTERS  0x00000020
// Warnings specific to extension operation.
#define DEBUG_OUTPUT_EXTENSION_WARNING 0x00000040
// Debuggee debug output, such as from OutputDebugString.
#define DEBUG_OUTPUT_DEBUGGEE          0x00000080
// Debuggee-generated prompt, such as from DbgPrompt.
#define DEBUG_OUTPUT_DEBUGGEE_PROMPT   0x00000100
// Symbol messages, such as for !sym noisy.
#define DEBUG_OUTPUT_SYMBOLS           0x00000200

// Internal debugger output, used mainly
// for debugging the debugger.  Output
// may only occur in debug builds.
// KD protocol output.
#define DEBUG_IOUTPUT_KD_PROTOCOL      0x80000000
// Remoting output.
#define DEBUG_IOUTPUT_REMOTING         0x40000000
// Breakpoint output.
#define DEBUG_IOUTPUT_BREAKPOINT       0x20000000
// Event output.
#define DEBUG_IOUTPUT_EVENT            0x10000000

// OutputIdentity flags.
#define DEBUG_OUTPUT_IDENTITY_DEFAULT 0x00000000

#undef INTERFACE
#define INTERFACE IDebugClient
DECLARE_INTERFACE_(IDebugClient, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.

    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        __in ULONG Flags,
        __in_opt PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        __in PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        __in ULONG Flags,
        __in PCSTR Options,
        __in_opt __reserved PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        __in PCSTR RemoteOptions,
        __out PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        __in ULONG64 Server,
        __out_ecount_opt(Count) PULONG Ids,
        __in ULONG Count,
        __out_opt PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        __in ULONG64 Server,
        __in PCSTR ExeName,
        __in ULONG Flags,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        __in ULONG64 Server,
        __in ULONG SystemId,
        __in ULONG Flags,
        __out_ecount_opt(ExeNameSize) PSTR ExeName,
        __in ULONG ExeNameSize,
        __out_opt PULONG ActualExeNameSize,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        __in ULONG64 Server,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 Server,
        __in PSTR CommandLine,
        __in ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        __in ULONG64 Server,
        __in_opt PSTR CommandLine,
        __in ULONG CreateFlags,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        __in PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        __in ULONG Flags,
        __in ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        __in PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Machine,
        __in ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        __out PULONG Code
        ) PURE;

    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        __in ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        __in PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        __out PDEBUG_CLIENT* Client
        ) PURE;

    STDMETHOD(GetInputCallbacks)(
        THIS_
        __out PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        __in_opt PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;

    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        __out PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        __in_opt PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        __in ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __in ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        __out PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        __in ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        __in_opt PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        __out PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        __in_opt PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;
};

// Per-dump-format control flags.
#define DEBUG_FORMAT_DEFAULT             0x00000000
// Write dump to a temporary file, then package it
// into a CAB file and delete the temporary file.
#define DEBUG_FORMAT_WRITE_CAB           0x20000000
// When creating a CAB add secondary files such as
// current symbols and mapped images.
#define DEBUG_FORMAT_CAB_SECONDARY_FILES 0x40000000
// Don't overwrite existing files.
#define DEBUG_FORMAT_NO_OVERWRITE        0x80000000

#define DEBUG_FORMAT_USER_SMALL_FULL_MEMORY               0x00000001
#define DEBUG_FORMAT_USER_SMALL_HANDLE_DATA               0x00000002
#define DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES          0x00000004
#define DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY           0x00000008
#define DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS             0x00000010
#define DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY             0x00000020
#define DEBUG_FORMAT_USER_SMALL_FILTER_PATHS              0x00000040
#define DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA       0x00000080
#define DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY 0x00000100
#define DEBUG_FORMAT_USER_SMALL_NO_OPTIONAL_DATA          0x00000200
#define DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO          0x00000400
#define DEBUG_FORMAT_USER_SMALL_THREAD_INFO               0x00000800
#define DEBUG_FORMAT_USER_SMALL_CODE_SEGMENTS             0x00001000
#define DEBUG_FORMAT_USER_SMALL_NO_AUXILIARY_STATE        0x00002000
#define DEBUG_FORMAT_USER_SMALL_FULL_AUXILIARY_STATE      0x00004000

//
// Dump information file types.
//

// Base dump file, returned when querying for dump files.
#define DEBUG_DUMP_FILE_BASE           0xffffffff
// Single file containing packed page file information.
#define DEBUG_DUMP_FILE_PAGE_FILE_DUMP 0x00000000

#undef INTERFACE
#define INTERFACE IDebugClient2
DECLARE_INTERFACE_(IDebugClient2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.

    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        __in ULONG Flags,
        __in_opt PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        __in PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        __in ULONG Flags,
        __in PCSTR Options,
        __in_opt __reserved PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        __in PCSTR RemoteOptions,
        __out PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        __in ULONG64 Server,
        __out_ecount_opt(Count) PULONG Ids,
        __in ULONG Count,
        __out_opt PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        __in ULONG64 Server,
        __in PCSTR ExeName,
        __in ULONG Flags,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        __in ULONG64 Server,
        __in ULONG SystemId,
        __in ULONG Flags,
        __out_ecount_opt(ExeNameSize) PSTR ExeName,
        __in ULONG ExeNameSize,
        __out_opt PULONG ActualExeNameSize,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        __in ULONG64 Server,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 Server,
        __in PSTR CommandLine,
        __in ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        __in ULONG64 Server,
        __in_opt PSTR CommandLine,
        __in ULONG CreateFlags,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        __in PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        __in ULONG Flags,
        __in ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        __in PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Machine,
        __in ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        __out PULONG Code
        ) PURE;

    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        __in ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        __in PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        __out PDEBUG_CLIENT* Client
        ) PURE;

    STDMETHOD(GetInputCallbacks)(
        THIS_
        __out PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        __in_opt PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;

    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        __out PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        __in_opt PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        __in ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __in ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        __out PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        __in ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        __in_opt PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        __out PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        __in_opt PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;

    // IDebugClient2.

    // Functions similarly to WriteDumpFile with
    // the addition of the ability to specify
    // per-dump-format write control flags.
    // Comment is not supported in all formats.
    STDMETHOD(WriteDumpFile2)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier,
        __in ULONG FormatFlags,
        __in_opt PCSTR Comment
        ) PURE;
    // Registers additional files of supporting information
    // for a dump file open.  This method must be called
    // before OpenDumpFile is called.
    // The files registered may be opened at the time
    // this method is called but generally will not
    // be used until OpenDumpFile is called.
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        __in PCSTR InfoFile,
        __in ULONG Type
        ) PURE;

    // Requests that the remote process server shut down.
    STDMETHOD(EndProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;
    // Waits for a started process server to
    // exit.  Allows an application running a
    // process server to monitor the process
    // server so that it can tell when a remote
    // client has asked for it to exit.
    // Returns S_OK if the process server has
    // shut down and S_FALSE for a timeout.
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        __in ULONG Timeout
        ) PURE;

    // Returns S_OK if the system is configured
    // to allow kernel debugging.
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        ) PURE;

    // Attempts to terminate the current process.
    // Exit process events for the process may be generated.
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        ) PURE;
    // Attempts to detach from the current process.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachCurrentProcess)(
        THIS
        ) PURE;
    // Removes the process from the debuggers process
    // list without making any other changes.  The process
    // will still be marked as being debugged and will
    // not run.  This allows a debugger to be shut down
    // and a new debugger attached without taking the
    // process out of the debugged state.
    // This is only supported on some system versions.
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugClient3
DECLARE_INTERFACE_(IDebugClient3, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.

    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        __in ULONG Flags,
        __in_opt PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        __in PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        __in ULONG Flags,
        __in PCSTR Options,
        __in_opt __reserved PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        __in PCSTR RemoteOptions,
        __out PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        __in ULONG64 Server,
        __out_ecount_opt(Count) PULONG Ids,
        __in ULONG Count,
        __out_opt PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        __in ULONG64 Server,
        __in PCSTR ExeName,
        __in ULONG Flags,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        __in ULONG64 Server,
        __in ULONG SystemId,
        __in ULONG Flags,
        __out_ecount_opt(ExeNameSize) PSTR ExeName,
        __in ULONG ExeNameSize,
        __out_opt PULONG ActualExeNameSize,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        __in ULONG64 Server,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 Server,
        __in PSTR CommandLine,
        __in ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        __in ULONG64 Server,
        __in_opt PSTR CommandLine,
        __in ULONG CreateFlags,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        __in PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        __in ULONG Flags,
        __in ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        __in PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Machine,
        __in ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        __out PULONG Code
        ) PURE;

    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        __in ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        __in PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        __out PDEBUG_CLIENT* Client
        ) PURE;

    STDMETHOD(GetInputCallbacks)(
        THIS_
        __out PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        __in_opt PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;

    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        __out PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        __in_opt PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        __in ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __in ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        __out PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        __in ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        __in_opt PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        __out PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        __in_opt PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;

    // IDebugClient2.

    // Functions similarly to WriteDumpFile with
    // the addition of the ability to specify
    // per-dump-format write control flags.
    // Comment is not supported in all formats.
    STDMETHOD(WriteDumpFile2)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier,
        __in ULONG FormatFlags,
        __in_opt PCSTR Comment
        ) PURE;
    // Registers additional files of supporting information
    // for a dump file open.  This method must be called
    // before OpenDumpFile is called.
    // The files registered may be opened at the time
    // this method is called but generally will not
    // be used until OpenDumpFile is called.
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        __in PCSTR InfoFile,
        __in ULONG Type
        ) PURE;

    // Requests that the remote process server shut down.
    STDMETHOD(EndProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;
    // Waits for a started process server to
    // exit.  Allows an application running a
    // process server to monitor the process
    // server so that it can tell when a remote
    // client has asked for it to exit.
    // Returns S_OK if the process server has
    // shut down and S_FALSE for a timeout.
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        __in ULONG Timeout
        ) PURE;

    // Returns S_OK if the system is configured
    // to allow kernel debugging.
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        ) PURE;

    // Attempts to terminate the current process.
    // Exit process events for the process may be generated.
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        ) PURE;
    // Attempts to detach from the current process.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachCurrentProcess)(
        THIS
        ) PURE;
    // Removes the process from the debuggers process
    // list without making any other changes.  The process
    // will still be marked as being debugged and will
    // not run.  This allows a debugger to be shut down
    // and a new debugger attached without taking the
    // process out of the debugged state.
    // This is only supported on some system versions.
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        ) PURE;

    // IDebugClient3.

    STDMETHOD(GetRunningProcessSystemIdByExecutableNameWide)(
        THIS_
        __in ULONG64 Server,
        __in PCWSTR ExeName,
        __in ULONG Flags,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescriptionWide)(
        THIS_
        __in ULONG64 Server,
        __in ULONG SystemId,
        __in ULONG Flags,
        __out_ecount_opt(ExeNameSize) PWSTR ExeName,
        __in ULONG ExeNameSize,
        __out_opt PULONG ActualExeNameSize,
        __out_ecount_opt(DescriptionSize) PWSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG ActualDescriptionSize
        ) PURE;

    STDMETHOD(CreateProcessWide)(
        THIS_
        __in ULONG64 Server,
        __in PWSTR CommandLine,
        __in ULONG CreateFlags
        ) PURE;
    STDMETHOD(CreateProcessAndAttachWide)(
        THIS_
        __in ULONG64 Server,
        __in_opt PWSTR CommandLine,
        __in ULONG CreateFlags,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
};

//
// Special indices for GetDumpFile to return
// alternate filenames.
//

// Special index that returns the name of the last .dmp file
// that failed to load (whether directly or from inside a
// .cab file).
#define DEBUG_DUMP_FILE_LOAD_FAILED_INDEX  0xffffffff
// Index that returns last cab file opened, this is needed to
// get the name of original CAB file since debugger returns the
// extracted dump file in the GetDumpFile method.
#define DEBUG_DUMP_FILE_ORIGINAL_CAB_INDEX 0xfffffffe

#undef INTERFACE
#define INTERFACE IDebugClient4
DECLARE_INTERFACE_(IDebugClient4, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.

    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        __in ULONG Flags,
        __in_opt PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        __in PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        __in ULONG Flags,
        __in PCSTR Options,
        __in_opt __reserved PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        __in PCSTR RemoteOptions,
        __out PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        __in ULONG64 Server,
        __out_ecount_opt(Count) PULONG Ids,
        __in ULONG Count,
        __out_opt PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        __in ULONG64 Server,
        __in PCSTR ExeName,
        __in ULONG Flags,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        __in ULONG64 Server,
        __in ULONG SystemId,
        __in ULONG Flags,
        __out_ecount_opt(ExeNameSize) PSTR ExeName,
        __in ULONG ExeNameSize,
        __out_opt PULONG ActualExeNameSize,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        __in ULONG64 Server,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 Server,
        __in PSTR CommandLine,
        __in ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        __in ULONG64 Server,
        __in_opt PSTR CommandLine,
        __in ULONG CreateFlags,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        __in PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        __in ULONG Flags,
        __in ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        __in PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Machine,
        __in ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        __out PULONG Code
        ) PURE;

    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        __in ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        __in PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        __out PDEBUG_CLIENT* Client
        ) PURE;

    STDMETHOD(GetInputCallbacks)(
        THIS_
        __out PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        __in_opt PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;

    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        __out PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        __in_opt PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        __in ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __in ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        __out PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        __in ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        __in_opt PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        __out PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        __in_opt PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;

    // IDebugClient2.

    // Functions similarly to WriteDumpFile with
    // the addition of the ability to specify
    // per-dump-format write control flags.
    // Comment is not supported in all formats.
    STDMETHOD(WriteDumpFile2)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier,
        __in ULONG FormatFlags,
        __in_opt PCSTR Comment
        ) PURE;
    // Registers additional files of supporting information
    // for a dump file open.  This method must be called
    // before OpenDumpFile is called.
    // The files registered may be opened at the time
    // this method is called but generally will not
    // be used until OpenDumpFile is called.
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        __in PCSTR InfoFile,
        __in ULONG Type
        ) PURE;

    // Requests that the remote process server shut down.
    STDMETHOD(EndProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;
    // Waits for a started process server to
    // exit.  Allows an application running a
    // process server to monitor the process
    // server so that it can tell when a remote
    // client has asked for it to exit.
    // Returns S_OK if the process server has
    // shut down and S_FALSE for a timeout.
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        __in ULONG Timeout
        ) PURE;

    // Returns S_OK if the system is configured
    // to allow kernel debugging.
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        ) PURE;

    // Attempts to terminate the current process.
    // Exit process events for the process may be generated.
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        ) PURE;
    // Attempts to detach from the current process.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachCurrentProcess)(
        THIS
        ) PURE;
    // Removes the process from the debuggers process
    // list without making any other changes.  The process
    // will still be marked as being debugged and will
    // not run.  This allows a debugger to be shut down
    // and a new debugger attached without taking the
    // process out of the debugged state.
    // This is only supported on some system versions.
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        ) PURE;

    // IDebugClient3.

    STDMETHOD(GetRunningProcessSystemIdByExecutableNameWide)(
        THIS_
        __in ULONG64 Server,
        __in PCWSTR ExeName,
        __in ULONG Flags,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescriptionWide)(
        THIS_
        __in ULONG64 Server,
        __in ULONG SystemId,
        __in ULONG Flags,
        __out_ecount_opt(ExeNameSize) PWSTR ExeName,
        __in ULONG ExeNameSize,
        __out_opt PULONG ActualExeNameSize,
        __out_ecount_opt(DescriptionSize) PWSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG ActualDescriptionSize
        ) PURE;

    STDMETHOD(CreateProcessWide)(
        THIS_
        __in ULONG64 Server,
        __in PWSTR CommandLine,
        __in ULONG CreateFlags
        ) PURE;
    STDMETHOD(CreateProcessAndAttachWide)(
        THIS_
        __in ULONG64 Server,
        __in_opt PWSTR CommandLine,
        __in ULONG CreateFlags,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;

    // IDebugClient4.

    // In the following methods both a filename and a file
    // handle can be passed in.  If a file handle is given
    // the filename may be omitted, although providing it
    // allows the debugger to properly report the name when
    // queried.
    // File handles cannot be used in remote calls.
    STDMETHOD(OpenDumpFileWide)(
        THIS_
        __in_opt PCWSTR FileName,
        __in ULONG64 FileHandle
        ) PURE;
    STDMETHOD(WriteDumpFileWide)(
        THIS_
        __in_opt PCWSTR FileName,
        __in ULONG64 FileHandle,
        __in ULONG Qualifier,
        __in ULONG FormatFlags,
        __in_opt PCWSTR Comment
        ) PURE;
    STDMETHOD(AddDumpInformationFileWide)(
        THIS_
        __in_opt PCWSTR FileName,
        __in ULONG64 FileHandle,
        __in ULONG Type
        ) PURE;
    // These methods can be used to retrieve
    // file information for all targets that
    // involve files.
    STDMETHOD(GetNumberDumpFiles)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetDumpFile)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Handle,
        __out PULONG Type
        ) PURE;
    STDMETHOD(GetDumpFileWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Handle,
        __out PULONG Type
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugClient5
DECLARE_INTERFACE_(IDebugClient5, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.

    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        __in ULONG Flags,
        __in_opt PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        __in PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        __in ULONG Flags,
        __in PCSTR Options,
        __in_opt __reserved PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        __in PCSTR RemoteOptions,
        __out PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        __in ULONG64 Server,
        __out_ecount_opt(Count) PULONG Ids,
        __in ULONG Count,
        __out_opt PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        __in ULONG64 Server,
        __in PCSTR ExeName,
        __in ULONG Flags,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        __in ULONG64 Server,
        __in ULONG SystemId,
        __in ULONG Flags,
        __out_ecount_opt(ExeNameSize) PSTR ExeName,
        __in ULONG ExeNameSize,
        __out_opt PULONG ActualExeNameSize,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        __in ULONG64 Server,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 Server,
        __in PSTR CommandLine,
        __in ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        __in ULONG64 Server,
        __in_opt PSTR CommandLine,
        __in ULONG CreateFlags,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        __in PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        __in ULONG Flags,
        __in ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        __in PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Machine,
        __in ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        __out PULONG Code
        ) PURE;

    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        __in ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        __in PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        __out PDEBUG_CLIENT* Client
        ) PURE;

    STDMETHOD(GetInputCallbacks)(
        THIS_
        __out PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        __in_opt PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;

    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        __out PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        __in_opt PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        __in ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        __in PDEBUG_CLIENT Client,
        __in ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        __out PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        __in ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        __in_opt PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        __out PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        __in_opt PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;

    // IDebugClient2.

    // Functions similarly to WriteDumpFile with
    // the addition of the ability to specify
    // per-dump-format write control flags.
    // Comment is not supported in all formats.
    STDMETHOD(WriteDumpFile2)(
        THIS_
        __in PCSTR DumpFile,
        __in ULONG Qualifier,
        __in ULONG FormatFlags,
        __in_opt PCSTR Comment
        ) PURE;
    // Registers additional files of supporting information
    // for a dump file open.  This method must be called
    // before OpenDumpFile is called.
    // The files registered may be opened at the time
    // this method is called but generally will not
    // be used until OpenDumpFile is called.
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        __in PCSTR InfoFile,
        __in ULONG Type
        ) PURE;

    // Requests that the remote process server shut down.
    STDMETHOD(EndProcessServer)(
        THIS_
        __in ULONG64 Server
        ) PURE;
    // Waits for a started process server to
    // exit.  Allows an application running a
    // process server to monitor the process
    // server so that it can tell when a remote
    // client has asked for it to exit.
    // Returns S_OK if the process server has
    // shut down and S_FALSE for a timeout.
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        __in ULONG Timeout
        ) PURE;

    // Returns S_OK if the system is configured
    // to allow kernel debugging.
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        ) PURE;

    // Attempts to terminate the current process.
    // Exit process events for the process may be generated.
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        ) PURE;
    // Attempts to detach from the current process.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachCurrentProcess)(
        THIS
        ) PURE;
    // Removes the process from the debuggers process
    // list without making any other changes.  The process
    // will still be marked as being debugged and will
    // not run.  This allows a debugger to be shut down
    // and a new debugger attached without taking the
    // process out of the debugged state.
    // This is only supported on some system versions.
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        ) PURE;

    // IDebugClient3.

    STDMETHOD(GetRunningProcessSystemIdByExecutableNameWide)(
        THIS_
        __in ULONG64 Server,
        __in PCWSTR ExeName,
        __in ULONG Flags,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescriptionWide)(
        THIS_
        __in ULONG64 Server,
        __in ULONG SystemId,
        __in ULONG Flags,
        __out_ecount_opt(ExeNameSize) PWSTR ExeName,
        __in ULONG ExeNameSize,
        __out_opt PULONG ActualExeNameSize,
        __out_ecount_opt(DescriptionSize) PWSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG ActualDescriptionSize
        ) PURE;

    STDMETHOD(CreateProcessWide)(
        THIS_
        __in ULONG64 Server,
        __in PWSTR CommandLine,
        __in ULONG CreateFlags
        ) PURE;
    STDMETHOD(CreateProcessAndAttachWide)(
        THIS_
        __in ULONG64 Server,
        __in_opt PWSTR CommandLine,
        __in ULONG CreateFlags,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;

    // IDebugClient4.

    // In the following methods both a filename and a file
    // handle can be passed in.  If a file handle is given
    // the filename may be omitted, although providing it
    // allows the debugger to properly report the name when
    // queried.
    // File handles cannot be used in remote calls.
    STDMETHOD(OpenDumpFileWide)(
        THIS_
        __in_opt PCWSTR FileName,
        __in ULONG64 FileHandle
        ) PURE;
    STDMETHOD(WriteDumpFileWide)(
        THIS_
        __in_opt PCWSTR FileName,
        __in ULONG64 FileHandle,
        __in ULONG Qualifier,
        __in ULONG FormatFlags,
        __in_opt PCWSTR Comment
        ) PURE;
    STDMETHOD(AddDumpInformationFileWide)(
        THIS_
        __in_opt PCWSTR FileName,
        __in ULONG64 FileHandle,
        __in ULONG Type
        ) PURE;
    // These methods can be used to retrieve
    // file information for all targets that
    // involve files.
    STDMETHOD(GetNumberDumpFiles)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetDumpFile)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Handle,
        __out PULONG Type
        ) PURE;
    STDMETHOD(GetDumpFileWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Handle,
        __out PULONG Type
        ) PURE;

    // IDebugClient5.

    STDMETHOD(AttachKernelWide)(
        THIS_
        __in ULONG Flags,
        __in_opt PCWSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptionsWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG OptionsSize
        ) PURE;
    STDMETHOD(SetKernelConnectionOptionsWide)(
        THIS_
        __in PCWSTR Options
        ) PURE;

    STDMETHOD(StartProcessServerWide)(
        THIS_
        __in ULONG Flags,
        __in PCWSTR Options,
        __in_opt __reserved PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServerWide)(
        THIS_
        __in PCWSTR RemoteOptions,
        __out PULONG64 Server
        ) PURE;

    STDMETHOD(StartServerWide)(
        THIS_
        __in PCWSTR Options
        ) PURE;
    STDMETHOD(OutputServersWide)(
        THIS_
        __in ULONG OutputControl,
        __in PCWSTR Machine,
        __in ULONG Flags
        ) PURE;

    STDMETHOD(GetOutputCallbacksWide)(
        THIS_
        __out PDEBUG_OUTPUT_CALLBACKS_WIDE* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacksWide)(
        THIS_
        __in PDEBUG_OUTPUT_CALLBACKS_WIDE Callbacks
        ) PURE;
    STDMETHOD(GetOutputLinePrefixWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefixWide)(
        THIS_
        __in_opt PCWSTR Prefix
        ) PURE;

    STDMETHOD(GetIdentityWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG IdentitySize
        ) PURE;
    STDMETHOD(OutputIdentityWide)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in PCWSTR Format
        ) PURE;

    STDMETHOD(GetEventCallbacksWide)(
        THIS_
        __out PDEBUG_EVENT_CALLBACKS_WIDE* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacksWide)(
        THIS_
        __in PDEBUG_EVENT_CALLBACKS_WIDE Callbacks
        ) PURE;

    STDMETHOD(CreateProcess2)(
        THIS_
        __in ULONG64 Server,
        __in PSTR CommandLine,
        __in_bcount(OptionsBufferSize) PVOID OptionsBuffer,
        __in ULONG OptionsBufferSize,
        __in_opt PCSTR InitialDirectory,
        __in_opt PCSTR Environment
        ) PURE;
    STDMETHOD(CreateProcess2Wide)(
        THIS_
        __in ULONG64 Server,
        __in PWSTR CommandLine,
        __in_bcount(OptionsBufferSize) PVOID OptionsBuffer,
        __in ULONG OptionsBufferSize,
        __in_opt PCWSTR InitialDirectory,
        __in_opt PCWSTR Environment
        ) PURE;
    STDMETHOD(CreateProcessAndAttach2)(
        THIS_
        __in ULONG64 Server,
        __in_opt PSTR CommandLine,
        __in_bcount(OptionsBufferSize) PVOID OptionsBuffer,
        __in ULONG OptionsBufferSize,
        __in_opt PCSTR InitialDirectory,
        __in_opt PCSTR Environment,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;
    STDMETHOD(CreateProcessAndAttach2Wide)(
        THIS_
        __in ULONG64 Server,
        __in_opt PWSTR CommandLine,
        __in_bcount(OptionsBufferSize) PVOID OptionsBuffer,
        __in ULONG OptionsBufferSize,
        __in_opt PCWSTR InitialDirectory,
        __in_opt PCWSTR Environment,
        __in ULONG ProcessId,
        __in ULONG AttachFlags
        ) PURE;

    // Helpers for saving and restoring the
    // current output line prefix.
    STDMETHOD(PushOutputLinePrefix)(
        THIS_
        __in_opt PCSTR NewPrefix,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(PushOutputLinePrefixWide)(
        THIS_
        __in_opt PCWSTR NewPrefix,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(PopOutputLinePrefix)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    // Queries to determine if any clients
    // could potentially respond to the given callback.
    STDMETHOD(GetNumberInputCallbacks)(
        THIS_
        __out PULONG Count
        ) PURE;
    STDMETHOD(GetNumberOutputCallbacks)(
        THIS_
        __out PULONG Count
        ) PURE;
    STDMETHOD(GetNumberEventCallbacks)(
        THIS_
        __in ULONG EventFlags,
        __out PULONG Count
        ) PURE;

    // Control over locking the session against
    // undesired quits.  The quit lock string
    // cannot be retrieved from a secure session.
    STDMETHOD(GetQuitLockString)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringSize
        ) PURE;
    STDMETHOD(SetQuitLockString)(
        THIS_
        __in PCSTR String
        ) PURE;
    STDMETHOD(GetQuitLockStringWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringSize
        ) PURE;
    STDMETHOD(SetQuitLockStringWide)(
        THIS_
        __in PCWSTR String
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugControl.
//
//----------------------------------------------------------------------------

// Execution status codes used for waiting,
// for returning current status and for
// event method return values.
#define DEBUG_STATUS_NO_CHANGE           0
#define DEBUG_STATUS_GO                  1
#define DEBUG_STATUS_GO_HANDLED          2
#define DEBUG_STATUS_GO_NOT_HANDLED      3
#define DEBUG_STATUS_STEP_OVER           4
#define DEBUG_STATUS_STEP_INTO           5
#define DEBUG_STATUS_BREAK               6
#define DEBUG_STATUS_NO_DEBUGGEE         7
#define DEBUG_STATUS_STEP_BRANCH         8
#define DEBUG_STATUS_IGNORE_EVENT        9
#define DEBUG_STATUS_RESTART_REQUESTED   10
#define DEBUG_STATUS_REVERSE_GO          11
#define DEBUG_STATUS_REVERSE_STEP_BRANCH 12
#define DEBUG_STATUS_REVERSE_STEP_OVER   13
#define DEBUG_STATUS_REVERSE_STEP_INTO   14

#define DEBUG_STATUS_MASK                0xf

// This bit is added in DEBUG_CES_EXECUTION_STATUS
// notifications when the engines execution status
// is changing due to operations performed during
// a wait, such as making synchronous callbacks.  If
// the bit is not set the execution status is changing
// due to a wait being satisfied.
#define DEBUG_STATUS_INSIDE_WAIT  0x100000000
// This bit is added in DEBUG_CES_EXECUTION_STATUS
// notifications when the engines execution status
// update is coming after a wait has timed-out.
// It indicates that the execution status change
// was not due to an actual event.
#define DEBUG_STATUS_WAIT_TIMEOUT 0x200000000

// Output control flags.
// Output generated by methods called by this
// client will be sent only to this clients
// output callbacks.
#define DEBUG_OUTCTL_THIS_CLIENT       0x00000000
// Output will be sent to all clients.
#define DEBUG_OUTCTL_ALL_CLIENTS       0x00000001
// Output will be sent to all clients except
// the client generating the output.
#define DEBUG_OUTCTL_ALL_OTHER_CLIENTS 0x00000002
// Output will be discarded immediately and will not
// be logged or sent to callbacks.
#define DEBUG_OUTCTL_IGNORE            0x00000003
// Output will be logged but not sent to callbacks.
#define DEBUG_OUTCTL_LOG_ONLY          0x00000004
// All send control bits.
#define DEBUG_OUTCTL_SEND_MASK         0x00000007
// Do not place output from this client in
// the global log file.
#define DEBUG_OUTCTL_NOT_LOGGED        0x00000008
// Send output to clients regardless of whether the
// mask allows it or not.
#define DEBUG_OUTCTL_OVERRIDE_MASK     0x00000010

// Special value which means leave the output settings
// unchanged.
#define DEBUG_OUTCTL_AMBIENT           0xffffffff

// Interrupt types.
// Force a break in if the debuggee is running.
#define DEBUG_INTERRUPT_ACTIVE  0
// Notify but do not force a break in.
#define DEBUG_INTERRUPT_PASSIVE 1
// Try and get the current engine operation to
// complete so that the engine will be available
// again.  If no wait is active this is the same
// as a passive interrupt.  If a wait is active
// this will try to cause the wait to fail without
// breaking in to the debuggee.  There is
// no guarantee that issuing an exit interrupt
// will cause the engine to become available
// as not all operations are arbitrarily
// interruptible.
#define DEBUG_INTERRUPT_EXIT    2

// OutputCurrentState flags.  These flags
// allow a particular type of information
// to be displayed but do not guarantee
// that it will be displayed.  Other global
// settings may override these flags or
// the particular state may not be available.
// For example, source line information may
// not be present so source line information
// may not be displayed.
#define DEBUG_CURRENT_DEFAULT     0x0000000f
#define DEBUG_CURRENT_SYMBOL      0x00000001
#define DEBUG_CURRENT_DISASM      0x00000002
#define DEBUG_CURRENT_REGISTERS   0x00000004
#define DEBUG_CURRENT_SOURCE_LINE 0x00000008

//
// Disassemble flags.
//

// Compute the effective address from current register
// information and display it.
#define DEBUG_DISASM_EFFECTIVE_ADDRESS  0x00000001
// If the current disassembly offset has an exact
// symbol match output the symbol.
#define DEBUG_DISASM_MATCHING_SYMBOLS   0x00000002
// Output the source line number for each disassembly offset.
#define DEBUG_DISASM_SOURCE_LINE_NUMBER 0x00000004
// Output the source file name (no path) for each disassembly offset.
#define DEBUG_DISASM_SOURCE_FILE_NAME   0x00000008

// Code interpretation levels for stepping
// and other operations.
#define DEBUG_LEVEL_SOURCE   0
#define DEBUG_LEVEL_ASSEMBLY 1

// Engine control flags.
#define DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION      0x00000001
#define DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS   0x00000002
// If neither allow nor disallow is specified
// the engine will pick one based on what kind
// of debugging is going on.
#define DEBUG_ENGOPT_ALLOW_NETWORK_PATHS         0x00000004
#define DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS      0x00000008
#define DEBUG_ENGOPT_NETWORK_PATHS               (0x00000004 | 0x00000008)
// Ignore loader-generated first-chance exceptions.
#define DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS    0x00000010
// Break in on a debuggees initial event.  In user-mode
// this will break at the initial system breakpoint
// for every created process.  In kernel-mode it
// will attempt break in on the target at the first
// WaitForEvent.
#define DEBUG_ENGOPT_INITIAL_BREAK               0x00000020
// Break in on the first module load for a debuggee.
#define DEBUG_ENGOPT_INITIAL_MODULE_BREAK        0x00000040
// Break in on a debuggees final event.  In user-mode
// this will break on process exit for every process.
// In kernel-mode it currently does nothing.
#define DEBUG_ENGOPT_FINAL_BREAK                 0x00000080
// By default Execute will repeat the last command
// if it is given an empty string.  The flags to
// Execute can override this behavior for a single
// command or this engine option can be used to
// change the default globally.
#define DEBUG_ENGOPT_NO_EXECUTE_REPEAT           0x00000100
// Disable places in the engine that have fallback
// code when presented with incomplete information.
//   1. Fails minidump module loads unless matching
//      executables can be mapped.
#define DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION 0x00000200
// Allow the debugger to manipulate page protections
// in order to insert code breakpoints on pages that
// do not have write access.  This option is not on
// by default as it allows breakpoints to be set
// in potentially hazardous memory areas.
#define DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS 0x00000400
// When using a software (bp/bu) breakpoint in code
// that will be executed by multiple threads it is
// possible for breakpoint management to cause the
// breakpoint to be missed or for spurious single-step
// exceptions to be generated.  This flag suspends
// all but the active thread when doing breakpoint
// management and thereby avoids multithreading
// problems.  Care must be taken when using it, though,
// as the suspension of threads can cause deadlocks
// if the suspended threads are holding resources that
// the active thread needs.  Additionally, there
// are still rare situations where problems may
// occur, but setting this flag corrects nearly
// all multithreading issues with software breakpoints.
// Thread-restricted stepping and execution supersedes
// this flags effect.
// This flag is ignored in kernel sessions as there
// is no way to restrict processor execution.
#define DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS     0x00000800
// Disallows executing shell commands through the
// engine with .shell (!!).
#define DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS     0x00001000
// Turns on "quiet mode", a somewhat less verbose mode
// of operation supported in the debuggers that were
// superseded by dbgeng.dll.  This equates to the KDQUIET
// environment variable.
#define DEBUG_ENGOPT_KD_QUIET_MODE               0x00002000
// Disables managed code debugging support in the engine.
// If managed support is already in use this flag has no effect.
#define DEBUG_ENGOPT_DISABLE_MANAGED_SUPPORT     0x00004000
// Disables symbol loading for all modules created
// after this flag is set.
#define DEBUG_ENGOPT_DISABLE_MODULE_SYMBOL_LOAD  0x00008000
// Disables execution commands.
#define DEBUG_ENGOPT_DISABLE_EXECUTION_COMMANDS  0x00010000
// Disallows mapping of image files from disk for any use.
// For example, this disallows image mapping for memory
// content when debugging minidumps.
// Does not affect existing mappings, only future attempts.
#define DEBUG_ENGOPT_DISALLOW_IMAGE_FILE_MAPPING 0x00020000
#define DEBUG_ENGOPT_ALL                         0x0003FFFF

// General unspecified ID constant.
#define DEBUG_ANY_ID 0xffffffff

typedef struct _DEBUG_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[6];
    BOOL    Virtual;
    ULONG   FrameNumber;
} DEBUG_STACK_FRAME, *PDEBUG_STACK_FRAME;

// OutputStackTrace flags.
// Display a small number of arguments for each call.
// These may or may not be the actual arguments depending
// on the architecture, particular function and
// point during the execution of the function.
// If the current code level is assembly arguments
// are dumped as hex values.  If the code level is
// source the engine attempts to provide symbolic
// argument information.
#define DEBUG_STACK_ARGUMENTS               0x00000001
// Displays information about the functions
// frame such as __stdcall arguments, FPO
// information and whatever else is available.
#define DEBUG_STACK_FUNCTION_INFO           0x00000002
// Displays source line information for each
// frame of the stack trace.
#define DEBUG_STACK_SOURCE_LINE             0x00000004
// Show return, previous frame and other relevant address
// values for each frame.
#define DEBUG_STACK_FRAME_ADDRESSES         0x00000008
// Show column names.
#define DEBUG_STACK_COLUMN_NAMES            0x00000010
// Show non-volatile register context for each
// frame.  This is only meaningful for some platforms.
#define DEBUG_STACK_NONVOLATILE_REGISTERS   0x00000020
// Show frame numbers
#define DEBUG_STACK_FRAME_NUMBERS           0x00000040
// Show typed source parameters.
#define DEBUG_STACK_PARAMETERS              0x00000080
// Show just return address in stack frame addresses.
#define DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY 0x00000100
// Show frame-to-frame memory usage.
#define DEBUG_STACK_FRAME_MEMORY_USAGE      0x00000200
// Show typed source parameters one to a line.
#define DEBUG_STACK_PARAMETERS_NEWLINE      0x00000400

// Classes of debuggee.  Each class
// has different qualifiers for specific
// kinds of debuggees.
#define DEBUG_CLASS_UNINITIALIZED 0
#define DEBUG_CLASS_KERNEL        1
#define DEBUG_CLASS_USER_WINDOWS  2
#define DEBUG_CLASS_IMAGE_FILE    3

// Generic dump types.  These can be used
// with either user or kernel sessions.
// Session-type-specific aliases are also
// provided.
#define DEBUG_DUMP_SMALL      1024
#define DEBUG_DUMP_DEFAULT    1025
#define DEBUG_DUMP_FULL       1026
#define DEBUG_DUMP_IMAGE_FILE 1027
#define DEBUG_DUMP_TRACE_LOG  1028
#define DEBUG_DUMP_WINDOWS_CE 1029

// Specific types of kernel debuggees.
#define DEBUG_KERNEL_CONNECTION  0
#define DEBUG_KERNEL_LOCAL       1
#define DEBUG_KERNEL_EXDI_DRIVER 2

#define DEBUG_KERNEL_SMALL_DUMP  DEBUG_DUMP_SMALL
#define DEBUG_KERNEL_DUMP        DEBUG_DUMP_DEFAULT
#define DEBUG_KERNEL_FULL_DUMP   DEBUG_DUMP_FULL

#define DEBUG_KERNEL_TRACE_LOG   DEBUG_DUMP_TRACE_LOG

// Specific types of Windows user debuggees.
#define DEBUG_USER_WINDOWS_PROCESS         0
#define DEBUG_USER_WINDOWS_PROCESS_SERVER  1
#define DEBUG_USER_WINDOWS_IDNA            2
#define DEBUG_USER_WINDOWS_SMALL_DUMP      DEBUG_DUMP_SMALL
#define DEBUG_USER_WINDOWS_DUMP            DEBUG_DUMP_DEFAULT
#define DEBUG_USER_WINDOWS_DUMP_WINDOWS_CE DEBUG_DUMP_WINDOWS_CE

// Extension flags.
#define DEBUG_EXTENSION_AT_ENGINE 0x00000000

// Execute and ExecuteCommandFile flags.
// These flags only apply to the command
// text itself; output from the executed
// command is controlled by the output
// control parameter.
// Default execution.  Command is logged
// but not output.
#define DEBUG_EXECUTE_DEFAULT    0x00000000
// Echo commands during execution.  In
// ExecuteCommandFile also echoes the prompt
// for each line of the file.
#define DEBUG_EXECUTE_ECHO       0x00000001
// Do not log or output commands during execution.
// Overridden by DEBUG_EXECUTE_ECHO.
#define DEBUG_EXECUTE_NOT_LOGGED 0x00000002
// If this flag is not set an empty string
// to Execute will repeat the last Execute
// string.
#define DEBUG_EXECUTE_NO_REPEAT  0x00000004

// Specific event filter types.  Some event
// filters have optional arguments to further
// qualify their operation.
#define DEBUG_FILTER_CREATE_THREAD       0x00000000
#define DEBUG_FILTER_EXIT_THREAD         0x00000001
#define DEBUG_FILTER_CREATE_PROCESS      0x00000002
#define DEBUG_FILTER_EXIT_PROCESS        0x00000003
// Argument is the name of a module to break on.
#define DEBUG_FILTER_LOAD_MODULE         0x00000004
// Argument is the base address of a specific module to break on.
#define DEBUG_FILTER_UNLOAD_MODULE       0x00000005
#define DEBUG_FILTER_SYSTEM_ERROR        0x00000006
// Initial breakpoint and initial module load are one-shot
// events that are triggered at the appropriate points in
// the beginning of a session.  Their commands are executed
// and then further processing is controlled by the normal
// exception and load module filters.
#define DEBUG_FILTER_INITIAL_BREAKPOINT  0x00000007
#define DEBUG_FILTER_INITIAL_MODULE_LOAD 0x00000008
// The debug output filter allows the debugger to stop
// when output is produced so that the code causing
// output can be tracked down or synchronized with.
// This filter is not supported for live dual-machine
// kernel debugging.
#define DEBUG_FILTER_DEBUGGEE_OUTPUT     0x00000009

// Event filter execution options.
// Break in always.
#define DEBUG_FILTER_BREAK               0x00000000
// Break in on second-chance exceptions.  For events
// that are not exceptions this is the same as BREAK.
#define DEBUG_FILTER_SECOND_CHANCE_BREAK 0x00000001
// Output a message about the event but continue.
#define DEBUG_FILTER_OUTPUT              0x00000002
// Continue the event.
#define DEBUG_FILTER_IGNORE              0x00000003
// Used to remove general exception filters.
#define DEBUG_FILTER_REMOVE              0x00000004

// Event filter continuation options.  These options are
// only used when DEBUG_STATUS_GO is used to continue
// execution.  If a specific go status such as
// DEBUG_STATUS_GO_NOT_HANDLED is used it controls
// the continuation.
#define DEBUG_FILTER_GO_HANDLED          0x00000000
#define DEBUG_FILTER_GO_NOT_HANDLED      0x00000001

// Specific event filter settings.
typedef struct _DEBUG_SPECIFIC_FILTER_PARAMETERS
{
    ULONG ExecutionOption;
    ULONG ContinueOption;
    ULONG TextSize;
    ULONG CommandSize;
    // If ArgumentSize is zero this filter does
    // not have an argument.  An empty argument for
    // a filter which does have an argument will take
    // one byte for the terminator.
    ULONG ArgumentSize;
} DEBUG_SPECIFIC_FILTER_PARAMETERS, *PDEBUG_SPECIFIC_FILTER_PARAMETERS;

// Exception event filter settings.
typedef struct _DEBUG_EXCEPTION_FILTER_PARAMETERS
{
    ULONG ExecutionOption;
    ULONG ContinueOption;
    ULONG TextSize;
    ULONG CommandSize;
    ULONG SecondCommandSize;
    ULONG ExceptionCode;
} DEBUG_EXCEPTION_FILTER_PARAMETERS, *PDEBUG_EXCEPTION_FILTER_PARAMETERS;

// Wait flags.
#define DEBUG_WAIT_DEFAULT 0x00000000

// Last event information structures.
typedef struct _DEBUG_LAST_EVENT_INFO_BREAKPOINT
{
    ULONG Id;
} DEBUG_LAST_EVENT_INFO_BREAKPOINT, *PDEBUG_LAST_EVENT_INFO_BREAKPOINT;

typedef struct _DEBUG_LAST_EVENT_INFO_EXCEPTION
{
    EXCEPTION_RECORD64 ExceptionRecord;
    ULONG FirstChance;
} DEBUG_LAST_EVENT_INFO_EXCEPTION, *PDEBUG_LAST_EVENT_INFO_EXCEPTION;

typedef struct _DEBUG_LAST_EVENT_INFO_EXIT_THREAD
{
    ULONG ExitCode;
} DEBUG_LAST_EVENT_INFO_EXIT_THREAD, *PDEBUG_LAST_EVENT_INFO_EXIT_THREAD;

typedef struct _DEBUG_LAST_EVENT_INFO_EXIT_PROCESS
{
    ULONG ExitCode;
} DEBUG_LAST_EVENT_INFO_EXIT_PROCESS, *PDEBUG_LAST_EVENT_INFO_EXIT_PROCESS;

typedef struct _DEBUG_LAST_EVENT_INFO_LOAD_MODULE
{
    ULONG64 Base;
} DEBUG_LAST_EVENT_INFO_LOAD_MODULE, *PDEBUG_LAST_EVENT_INFO_LOAD_MODULE;

typedef struct _DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE
{
    ULONG64 Base;
} DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE, *PDEBUG_LAST_EVENT_INFO_UNLOAD_MODULE;

typedef struct _DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR
{
    ULONG Error;
    ULONG Level;
} DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR, *PDEBUG_LAST_EVENT_INFO_SYSTEM_ERROR;

// DEBUG_VALUE types.
#define DEBUG_VALUE_INVALID      0
#define DEBUG_VALUE_INT8         1
#define DEBUG_VALUE_INT16        2
#define DEBUG_VALUE_INT32        3
#define DEBUG_VALUE_INT64        4
#define DEBUG_VALUE_FLOAT32      5
#define DEBUG_VALUE_FLOAT64      6
#define DEBUG_VALUE_FLOAT80      7
#define DEBUG_VALUE_FLOAT82      8
#define DEBUG_VALUE_FLOAT128     9
#define DEBUG_VALUE_VECTOR64     10
#define DEBUG_VALUE_VECTOR128    11
// Count of type indices.
#define DEBUG_VALUE_TYPES        12

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif
#endif

// We want the DEBUG_VALUE structure to have 8-byte alignment
// and be 32 bytes total.  This is tricky because the compiler
// wants to pad the union of values out to a even 8-byte multiple,
// pushing the type out too far.  We can't use 4-packing because
// then the 8-byte alignment requirement is lost, so instead
// we shrink the union to 24 bytes and have a reserved field
// before the type field.  The same amount of space is available
// and everybody's happy, but the structure is somewhat unusual.

typedef struct _DEBUG_VALUE
{
    union
    {
        UCHAR I8;
        USHORT I16;
        ULONG I32;
        struct
        {
            // Extra NAT indicator for IA64
            // integer registers.  NAT will
            // always be false for other CPUs.
            ULONG64 I64;
            BOOL Nat;
        };
        float F32;
        double F64;
        UCHAR F80Bytes[10];
        UCHAR F82Bytes[11];
        UCHAR F128Bytes[16];
        // Vector interpretations.  The actual number
        // of valid elements depends on the vector length.
        UCHAR VI8[16];
        USHORT VI16[8];
        ULONG VI32[4];
        ULONG64 VI64[2];
        float VF32[4];
        double VF64[2];
        struct
        {
            ULONG LowPart;
            ULONG HighPart;
        } I64Parts32;
        struct
        {
            ULONG64 LowPart;
            LONG64 HighPart;
        } F128Parts64;
        // Allows raw byte access to content.  Array
        // can be indexed for as much data as Type
        // describes.  This array also serves to pad
        // the structure out to 32 bytes and reserves
        // space for future members.
        UCHAR RawBytes[24];
    };
    ULONG TailOfRawBytes;
  ULONG Type;
} DEBUG_VALUE, *PDEBUG_VALUE;

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)    /* Nameless struct/union */
#endif
#endif
#endif

#undef INTERFACE
#define INTERFACE IDebugControl
DECLARE_INTERFACE_(IDebugControl, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugControl.

    // Checks for a user interrupt, such a Ctrl-C
    // or stop button.
    // This method is reentrant.
    STDMETHOD(GetInterrupt)(
        THIS
        ) PURE;
    // Registers a user interrupt.
    // This method is reentrant.
    STDMETHOD(SetInterrupt)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Interrupting a user-mode process requires
    // access to some system resources that the
    // process may hold itself, preventing the
    // interrupt from occurring.  The engine
    // will time-out pending interrupt requests
    // and simulate an interrupt if necessary.
    // These methods control the interrupt timeout.
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        __out PULONG Seconds
        ) PURE;
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        __in ULONG Seconds
        ) PURE;

    STDMETHOD(GetLogFile)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FileSize,
        __out PBOOL Append
        ) PURE;
    // Opens a log file which collects all
    // output.  Output from every client except
    // those that explicitly disable logging
    // goes into the log.
    // Opening a log file closes any log file
    // already open.
    STDMETHOD(OpenLogFile)(
        THIS_
        __in PCSTR File,
        __in BOOL Append
        ) PURE;
    STDMETHOD(CloseLogFile)(
        THIS
        ) PURE;
    // Controls what output is logged.
    STDMETHOD(GetLogMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetLogMask)(
        THIS_
        __in ULONG Mask
        ) PURE;

    // Input requests input from all clients.
    // The first input that is returned is used
    // to satisfy the call.  Other returned
    // input is discarded.
    STDMETHOD(Input)(
        THIS_
        __out_ecount(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InputSize
        ) PURE;
    // This method is used by clients to return
    // input when it is available.  It will
    // return S_OK if the input is used to
    // satisfy an Input call and S_FALSE if
    // the input is ignored.
    // This method is reentrant.
    STDMETHOD(ReturnInput)(
        THIS_
        __in PCSTR Buffer
        ) PURE;

    // Sends output through clients
    // output callbacks if the mask is allowed
    // by the current output control mask and
    // according to the output distribution
    // settings.
    STDMETHODV(Output)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaList)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Format,
        __in va_list Args
        ) PURE;
    // The following methods allow direct control
    // over the distribution of the given output
    // for situations where something other than
    // the default is desired.  These methods require
    // extra work in the engine so they should
    // only be used when necessary.
    STDMETHODV(ControlledOutput)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCSTR Format,
        __in va_list Args
        ) PURE;

    // Displays the standard command-line prompt
    // followed by the given output.  If Format
    // is NULL no additional output is produced.
    // Output is produced under the
    // DEBUG_OUTPUT_PROMPT mask.
    // This method only outputs the prompt; it
    // does not get input.
    STDMETHODV(OutputPrompt)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaList)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCSTR Format,
        __in va_list Args
        ) PURE;
    // Gets the text that would be displayed by OutputPrompt.
    STDMETHOD(GetPromptText)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    // Outputs information about the current
    // debuggee state such as a register
    // summary, disassembly at the current PC,
    // closest symbol and others.
    // Uses the line prefix.
    STDMETHOD(OutputCurrentState)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;

    // Outputs the debugger and extension version
    // information.  This method is reentrant.
    // Uses the line prefix.
    STDMETHOD(OutputVersionInformation)(
        THIS_
        __in ULONG OutputControl
        ) PURE;

    // In user-mode debugging sessions the
    // engine will set an event when
    // exceptions are continued.  This can
    // be used to synchronize other processes
    // with the debuggers handling of events.
    // For example, this is used to support
    // the e argument to ntsd.
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    STDMETHOD(Assemble)(
        THIS_
        __in ULONG64 Offset,
        __in PCSTR Instr,
        __out PULONG64 EndOffset
        ) PURE;
    STDMETHOD(Disassemble)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DisassemblySize,
        __out PULONG64 EndOffset
        ) PURE;
    // Returns the value of the effective address
    // computed for the last Disassemble, if there
    // was one.
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Uses the line prefix if necessary.
    STDMETHOD(OutputDisassembly)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out PULONG64 EndOffset
        ) PURE;
    // Produces multiple lines of disassembly output.
    // There will be PreviousLines of disassembly before
    // the given offset if a valid disassembly exists.
    // In all, there will be TotalLines of output produced.
    // The first and last line offsets are returned
    // specially and all lines offsets can be retrieved
    // through LineOffsets.  LineOffsets will contain
    // offsets for each line where disassembly started.
    // When disassembly of a single instruction takes
    // multiple lines the initial offset will be followed
    // by DEBUG_INVALID_OFFSET.
    // Uses the line prefix.
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG PreviousLines,
        __in ULONG TotalLines,
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_opt PULONG OffsetLine,
        __out_opt PULONG64 StartOffset,
        __out_opt PULONG64 EndOffset,
        __out_ecount_opt(TotalLines) PULONG64 LineOffsets
        ) PURE;
    // Returns the offset of the start of
    // the instruction thats the given
    // delta away from the instruction
    // at the initial offset.
    // This routine does not check for
    // validity of the instruction or
    // the memory containing it.
    STDMETHOD(GetNearInstruction)(
        THIS_
        __in ULONG64 Offset,
        __in LONG Delta,
        __out PULONG64 NearOffset
        ) PURE;

    // Offsets can be passed in as zero to use the current
    // thread state.
    STDMETHOD(GetStackTrace)(
        THIS_
        __in ULONG64 FrameOffset,
        __in ULONG64 StackOffset,
        __in ULONG64 InstructionOffset,
        __out_ecount(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __out_opt PULONG FramesFilled
        ) PURE;
    // Does a simple stack trace to determine
    // what the current return address is.
    STDMETHOD(GetReturnOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // If Frames is NULL OutputStackTrace will
    // use GetStackTrace to get FramesSize frames
    // and then output them.  The current register
    // values for frame, stack and instruction offsets
    // are used.
    // Uses the line prefix.
    STDMETHOD(OutputStackTrace)(
        THIS_
        __in ULONG OutputControl,
        __in_ecount_opt(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __in ULONG Flags
        ) PURE;

    // Returns information about the debuggee such
    // as user vs. kernel, dump vs. live, etc.
    STDMETHOD(GetDebuggeeType)(
        THIS_
        __out PULONG Class,
        __out PULONG Qualifier
        ) PURE;
    // Returns the type of physical processors in
    // the machine.
    // Returns one of the IMAGE_FILE_MACHINE values.
    STDMETHOD(GetActualProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    // Returns the type of processor used in the
    // current processor context.
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    // Query all the possible processor types that
    // may be encountered during this debug session.
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Types
        ) PURE;
    // Get the number of actual processors in
    // the machine.
    STDMETHOD(GetNumberProcessors)(
        THIS_
        __out PULONG Number
        ) PURE;
    // PlatformId is one of the VER_PLATFORM values.
    // Major and minor are as given in the NT
    // kernel debugger protocol.
    // ServicePackString and ServicePackNumber indicate the
    // system service pack level.  ServicePackNumber is not
    // available in some sessions where the service pack level
    // is only expressed as a string.  The service pack information
    // will be empty if the system does not have a service pack
    // applied.
    // The build string is string information identifying the
    // particular build of the system.  The build string is
    // empty if the system has no particular identifying
    // information.
    STDMETHOD(GetSystemVersion)(
        THIS_
        __out PULONG PlatformId,
        __out PULONG Major,
        __out PULONG Minor,
        __out_ecount_opt(ServicePackStringSize) PSTR ServicePackString,
        __in ULONG ServicePackStringSize,
        __out_opt PULONG ServicePackStringUsed,
        __out PULONG ServicePackNumber,
        __out_ecount_opt(BuildStringSize) PSTR BuildString,
        __in ULONG BuildStringSize,
        __out_opt PULONG BuildStringUsed
        ) PURE;
    // Returns the page size for the currently executing
    // processor context.  The page size may vary between
    // processor types.
    STDMETHOD(GetPageSize)(
        THIS_
        __out PULONG Size
        ) PURE;
    // Returns S_OK if the current processor context uses
    // 64-bit addresses, otherwise S_FALSE.
    STDMETHOD(IsPointer64Bit)(
        THIS
        ) PURE;
    // Reads the bugcheck data area and returns the
    // current contents.  This method only works
    // in kernel debugging sessions.
    STDMETHOD(ReadBugCheckData)(
        THIS_
        __out PULONG Code,
        __out PULONG64 Arg1,
        __out PULONG64 Arg2,
        __out PULONG64 Arg3,
        __out PULONG64 Arg4
        ) PURE;

    // Query all the processor types supported by
    // the engine.  This is a complete list and is
    // not related to the machine running the engine
    // or the debuggee.
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Types
        ) PURE;
    // Returns a full, descriptive name and an
    // abbreviated name for a processor type.
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        __in ULONG Type,
        __out_ecount_opt(FullNameBufferSize) PSTR FullNameBuffer,
        __in ULONG FullNameBufferSize,
        __out_opt PULONG FullNameSize,
        __out_ecount_opt(AbbrevNameBufferSize) PSTR AbbrevNameBuffer,
        __in ULONG AbbrevNameBufferSize,
        __out_opt PULONG AbbrevNameSize
        ) PURE;

    // Gets and sets the type of processor to
    // use when doing things like setting
    // breakpoints, accessing registers,
    // getting stack traces and so on.
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        __in ULONG Type
        ) PURE;

    // Returns information about whether and how
    // the debuggee is running.  Status will
    // be GO if the debuggee is running and
    // BREAK if it isnt.
    // If no debuggee exists the status is
    // NO_DEBUGGEE.
    // This method is reentrant.
    STDMETHOD(GetExecutionStatus)(
        THIS_
        __out PULONG Status
        ) PURE;
    // Changes the execution status of the
    // engine from stopped to running.
    // Status must be one of the go or step
    // status values.
    STDMETHOD(SetExecutionStatus)(
        THIS_
        __in ULONG Status
        ) PURE;

    // Controls what code interpretation level the debugger
    // runs at.  The debugger checks the code level when
    // deciding whether to step by a source line or
    // assembly instruction along with other related operations.
    STDMETHOD(GetCodeLevel)(
        THIS_
        __out PULONG Level
        ) PURE;
    STDMETHOD(SetCodeLevel)(
        THIS_
        __in ULONG Level
        ) PURE;

    // Gets and sets engine control flags.
    // These methods are reentrant.
    STDMETHOD(GetEngineOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Gets and sets control values for
    // handling system error events.
    // If the system error level is less
    // than or equal to the given levels
    // the error may be displayed and
    // the default break for the event
    // may be set.
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        __out PULONG OutputLevel,
        __out PULONG BreakLevel
        ) PURE;
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        __in ULONG OutputLevel,
        __in ULONG BreakLevel
        ) PURE;

    // The command processor supports simple
    // string replacement macros in Evaluate and
    // Execute.  There are currently ten macro
    // slots available.  Slots 0-9 map to
    // the command invocations $u0-$u9.
    STDMETHOD(GetTextMacro)(
        THIS_
        __in ULONG Slot,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacro)(
        THIS_
        __in ULONG Slot,
        __in PCSTR Macro
        ) PURE;

    // Controls the default number radix used
    // in expressions and commands.
    STDMETHOD(GetRadix)(
        THIS_
        __out PULONG Radix
        ) PURE;
    STDMETHOD(SetRadix)(
        THIS_
        __in ULONG Radix
        ) PURE;

    // Evaluates the given expression string and
    // returns the resulting value.
    // If DesiredType is DEBUG_VALUE_INVALID then
    // the natural type is used.
    // RemainderIndex, if provided, is set to the index
    // of the first character in the input string that was
    // not used when evaluating the expression.
    STDMETHOD(Evaluate)(
        THIS_
        __in PCSTR Expression,
        __in ULONG DesiredType,
        __out PDEBUG_VALUE Value,
        __out_opt PULONG RemainderIndex
        ) PURE;
    // Attempts to convert the input value to a value
    // of the requested type in the output value.
    // Conversions can fail if no conversion exists.
    // Successful conversions may be lossy.
    STDMETHOD(CoerceValue)(
        THIS_
        __in PDEBUG_VALUE In,
        __in ULONG OutType,
        __out PDEBUG_VALUE Out
        ) PURE;
    STDMETHOD(CoerceValues)(
        THIS_
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_VALUE In,
        __in_ecount(Count) PULONG OutTypes,
        __out_ecount(Count) PDEBUG_VALUE Out
        ) PURE;

    // Executes the given command string.
    // If the string has multiple commands
    // Execute will not return until all
    // of them have been executed.  If this
    // requires waiting for the debuggee to
    // execute an internal wait will be done
    // so Execute can take an arbitrary amount
    // of time.
    STDMETHOD(Execute)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Command,
        __in ULONG Flags
        ) PURE;
    // Executes the given command file by
    // reading a line at a time and processing
    // it with Execute.
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR CommandFile,
        __in ULONG Flags
        ) PURE;

    // Breakpoint interfaces are described
    // elsewhere in this section.
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        __out PULONG Number
        ) PURE;
    // It is possible for this retrieval function to
    // fail even with an index within the number of
    // existing breakpoints if the breakpoint is
    // a private breakpoint.
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        __in ULONG Index,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById)(
        THIS_
        __in ULONG Id,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // If Ids is non-NULL the Count breakpoints
    // referred to in the Ids array are returned,
    // otherwise breakpoints from index Start to
    // Start + Count  1 are returned.
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Ids,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
    // Breakpoints are created empty and disabled.
    // When their parameters have been set they
    // should be enabled by setting the ENABLE flag.
    // If DesiredId is DEBUG_ANY_ID then the
    // engine picks an unused ID.  If DesiredId
    // is any other number the engine attempts
    // to use the given ID for the breakpoint.
    // If another breakpoint exists with that ID
    // the call will fail.
    STDMETHOD(AddBreakpoint)(
        THIS_
        __in ULONG Type,
        __in ULONG DesiredId,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // Breakpoint interface is invalid after this call.
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        __in PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Control and use extension DLLs.
    STDMETHOD(AddExtension)(
        THIS_
        __in PCSTR Path,
        __in ULONG Flags,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(RemoveExtension)(
        THIS_
        __in ULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPath)(
        THIS_
        __in PCSTR Path,
        __out PULONG64 Handle
        ) PURE;
    // If Handle is zero the extension
    // chain is walked searching for the
    // function.
    STDMETHOD(CallExtension)(
        THIS_
        __in ULONG64 Handle,
        __in PCSTR Function,
        __in_opt PCSTR Arguments
        ) PURE;
    // GetExtensionFunction works like
    // GetProcAddress on extension DLLs
    // to allow raw function-call-level
    // interaction with extension DLLs.
    // Such functions do not need to
    // follow the standard extension prototype
    // if they are not going to be called
    // through the text extension interface.
    // _EFN_ is automatically prepended to
    // the name string given.
    // This function cannot be called remotely.
    STDMETHOD(GetExtensionFunction)(
        THIS_
        __in ULONG64 Handle,
        __in PCSTR FuncName,
        __out FARPROC* Function
        ) PURE;
    // These methods return alternate
    // extension interfaces in order to allow
    // interface-style extension DLLs to mix in
    // older extension calls.
    // Structure sizes must be initialized before
    // the call.
    // These methods cannot be called remotely.
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        __inout PWINDBG_EXTENSION_APIS32 Api
        ) PURE;
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        __inout PWINDBG_EXTENSION_APIS64 Api
        ) PURE;

    // The engine provides a simple mechanism
    // to filter common events.  Arbitrarily complicated
    // filtering can be done by registering event callbacks
    // but simple event filtering only requires
    // setting the options of one of the predefined
    // event filters.
    // Simple event filters are either for specific
    // events and therefore have an enumerant or
    // they are for an exception and are based on
    // the exceptions code.  Exception filters
    // are further divided into exceptions specially
    // handled by the engine, which is a fixed set,
    // and arbitrary exceptions.
    // All three groups of filters are indexed together
    // with the specific filters first, then the specific
    // exception filters and finally the arbitrary
    // exception filters.
    // The first specific exception is the default
    // exception.  If an exception event occurs for
    // an exception without settings the default
    // exception settings are used.
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        __out PULONG SpecificEvents,
        __out PULONG SpecificExceptions,
        __out PULONG ArbitraryExceptions
        ) PURE;
    // Some filters have descriptive text associated with them.
    STDMETHOD(GetEventFilterText)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    // All filters support executing a command when the
    // event occurs.
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        __in ULONG Index,
        __in PCSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    // Some specific filters have arguments to further
    // qualify their operation.
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        __in ULONG Index,
        __in PCSTR Argument
        ) PURE;
    // If Codes is non-NULL Start is ignored.
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Codes,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // The codes in the parameter data control the application
    // of the parameter data.  If a code is not already in
    // the set of filters it is added.  If the ExecutionOption
    // for a code is REMOVE then the filter is removed.
    // Specific exception filters cannot be removed.
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // Exception filters support an additional command for
    // second-chance events.
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        __in ULONG Index,
        __in PCSTR Command
        ) PURE;

    // Yields processing to the engine until
    // an event occurs.  This method may
    // only be called by the thread that started
    // the debug session.
    // When an event occurs the engine carries
    // out all event processing such as calling
    // callbacks.
    // If the callbacks indicate that execution should
    // break the wait will return, otherwise it
    // goes back to waiting for a new event.
    // If the timeout expires, S_FALSE is returned.
    // The timeout is not currently supported for
    // kernel debugging.
    STDMETHOD(WaitForEvent)(
        THIS_
        __in ULONG Flags,
        __in ULONG Timeout
        ) PURE;

    // Retrieves information about the last event that occurred.
    // EventType is one of the event callback mask bits.
    // ExtraInformation contains additional event-specific
    // information.  Not all events have additional information.
    STDMETHOD(GetLastEventInformation)(
        THIS_
        __out PULONG Type,
        __out PULONG ProcessId,
        __out PULONG ThreadId,
        __out_bcount_opt(ExtraInformationSize) PVOID ExtraInformation,
        __in ULONG ExtraInformationSize,
        __out_opt PULONG ExtraInformationUsed,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG DescriptionUsed
        ) PURE;
};

// OutputTextReplacements flags.
#define DEBUG_OUT_TEXT_REPL_DEFAULT 0x00000000

#undef INTERFACE
#define INTERFACE IDebugControl2
DECLARE_INTERFACE_(IDebugControl2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugControl.

    // Checks for a user interrupt, such a Ctrl-C
    // or stop button.
    // This method is reentrant.
    STDMETHOD(GetInterrupt)(
        THIS
        ) PURE;
    // Registers a user interrupt.
    // This method is reentrant.
    STDMETHOD(SetInterrupt)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Interrupting a user-mode process requires
    // access to some system resources that the
    // process may hold itself, preventing the
    // interrupt from occurring.  The engine
    // will time-out pending interrupt requests
    // and simulate an interrupt if necessary.
    // These methods control the interrupt timeout.
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        __out PULONG Seconds
        ) PURE;
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        __in ULONG Seconds
        ) PURE;

    STDMETHOD(GetLogFile)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FileSize,
        __out PBOOL Append
        ) PURE;
    // Opens a log file which collects all
    // output.  Output from every client except
    // those that explicitly disable logging
    // goes into the log.
    // Opening a log file closes any log file
    // already open.
    STDMETHOD(OpenLogFile)(
        THIS_
        __in PCSTR File,
        __in BOOL Append
        ) PURE;
    STDMETHOD(CloseLogFile)(
        THIS
        ) PURE;
    // Controls what output is logged.
    STDMETHOD(GetLogMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetLogMask)(
        THIS_
        __in ULONG Mask
        ) PURE;

    // Input requests input from all clients.
    // The first input that is returned is used
    // to satisfy the call.  Other returned
    // input is discarded.
    STDMETHOD(Input)(
        THIS_
        __out_ecount(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InputSize
        ) PURE;
    // This method is used by clients to return
    // input when it is available.  It will
    // return S_OK if the input is used to
    // satisfy an Input call and S_FALSE if
    // the input is ignored.
    // This method is reentrant.
    STDMETHOD(ReturnInput)(
        THIS_
        __in PCSTR Buffer
        ) PURE;

    // Sends output through clients
    // output callbacks if the mask is allowed
    // by the current output control mask and
    // according to the output distribution
    // settings.
    STDMETHODV(Output)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaList)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Format,
        __in va_list Args
        ) PURE;
    // The following methods allow direct control
    // over the distribution of the given output
    // for situations where something other than
    // the default is desired.  These methods require
    // extra work in the engine so they should
    // only be used when necessary.
    STDMETHODV(ControlledOutput)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCSTR Format,
        __in va_list Args
        ) PURE;

    // Displays the standard command-line prompt
    // followed by the given output.  If Format
    // is NULL no additional output is produced.
    // Output is produced under the
    // DEBUG_OUTPUT_PROMPT mask.
    // This method only outputs the prompt; it
    // does not get input.
    STDMETHODV(OutputPrompt)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaList)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCSTR Format,
        __in va_list Args
        ) PURE;
    // Gets the text that would be displayed by OutputPrompt.
    STDMETHOD(GetPromptText)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    // Outputs information about the current
    // debuggee state such as a register
    // summary, disassembly at the current PC,
    // closest symbol and others.
    // Uses the line prefix.
    STDMETHOD(OutputCurrentState)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;

    // Outputs the debugger and extension version
    // information.  This method is reentrant.
    // Uses the line prefix.
    STDMETHOD(OutputVersionInformation)(
        THIS_
        __in ULONG OutputControl
        ) PURE;

    // In user-mode debugging sessions the
    // engine will set an event when
    // exceptions are continued.  This can
    // be used to synchronize other processes
    // with the debuggers handling of events.
    // For example, this is used to support
    // the e argument to ntsd.
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    STDMETHOD(Assemble)(
        THIS_
        __in ULONG64 Offset,
        __in PCSTR Instr,
        __out PULONG64 EndOffset
        ) PURE;
    STDMETHOD(Disassemble)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DisassemblySize,
        __out PULONG64 EndOffset
        ) PURE;
    // Returns the value of the effective address
    // computed for the last Disassemble, if there
    // was one.
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Uses the line prefix if necessary.
    STDMETHOD(OutputDisassembly)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out PULONG64 EndOffset
        ) PURE;
    // Produces multiple lines of disassembly output.
    // There will be PreviousLines of disassembly before
    // the given offset if a valid disassembly exists.
    // In all, there will be TotalLines of output produced.
    // The first and last line offsets are returned
    // specially and all lines offsets can be retrieved
    // through LineOffsets.  LineOffsets will contain
    // offsets for each line where disassembly started.
    // When disassembly of a single instruction takes
    // multiple lines the initial offset will be followed
    // by DEBUG_INVALID_OFFSET.
    // Uses the line prefix.
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG PreviousLines,
        __in ULONG TotalLines,
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_opt PULONG OffsetLine,
        __out_opt PULONG64 StartOffset,
        __out_opt PULONG64 EndOffset,
        __out_ecount_opt(TotalLines) PULONG64 LineOffsets
        ) PURE;
    // Returns the offset of the start of
    // the instruction thats the given
    // delta away from the instruction
    // at the initial offset.
    // This routine does not check for
    // validity of the instruction or
    // the memory containing it.
    STDMETHOD(GetNearInstruction)(
        THIS_
        __in ULONG64 Offset,
        __in LONG Delta,
        __out PULONG64 NearOffset
        ) PURE;

    // Offsets can be passed in as zero to use the current
    // thread state.
    STDMETHOD(GetStackTrace)(
        THIS_
        __in ULONG64 FrameOffset,
        __in ULONG64 StackOffset,
        __in ULONG64 InstructionOffset,
        __out_ecount(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __out_opt PULONG FramesFilled
        ) PURE;
    // Does a simple stack trace to determine
    // what the current return address is.
    STDMETHOD(GetReturnOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // If Frames is NULL OutputStackTrace will
    // use GetStackTrace to get FramesSize frames
    // and then output them.  The current register
    // values for frame, stack and instruction offsets
    // are used.
    // Uses the line prefix.
    STDMETHOD(OutputStackTrace)(
        THIS_
        __in ULONG OutputControl,
        __in_ecount_opt(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __in ULONG Flags
        ) PURE;

    // Returns information about the debuggee such
    // as user vs. kernel, dump vs. live, etc.
    STDMETHOD(GetDebuggeeType)(
        THIS_
        __out PULONG Class,
        __out PULONG Qualifier
        ) PURE;
    // Returns the type of physical processors in
    // the machine.
    // Returns one of the IMAGE_FILE_MACHINE values.
    STDMETHOD(GetActualProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    // Returns the type of processor used in the
    // current processor context.
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    // Query all the possible processor types that
    // may be encountered during this debug session.
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Types
        ) PURE;
    // Get the number of actual processors in
    // the machine.
    STDMETHOD(GetNumberProcessors)(
        THIS_
        __out PULONG Number
        ) PURE;
    // PlatformId is one of the VER_PLATFORM values.
    // Major and minor are as given in the NT
    // kernel debugger protocol.
    // ServicePackString and ServicePackNumber indicate the
    // system service pack level.  ServicePackNumber is not
    // available in some sessions where the service pack level
    // is only expressed as a string.  The service pack information
    // will be empty if the system does not have a service pack
    // applied.
    // The build string is string information identifying the
    // particular build of the system.  The build string is
    // empty if the system has no particular identifying
    // information.
    STDMETHOD(GetSystemVersion)(
        THIS_
        __out PULONG PlatformId,
        __out PULONG Major,
        __out PULONG Minor,
        __out_ecount_opt(ServicePackStringSize) PSTR ServicePackString,
        __in ULONG ServicePackStringSize,
        __out_opt PULONG ServicePackStringUsed,
        __out PULONG ServicePackNumber,
        __out_ecount_opt(BuildStringSize) PSTR BuildString,
        __in ULONG BuildStringSize,
        __out_opt PULONG BuildStringUsed
        ) PURE;
    // Returns the page size for the currently executing
    // processor context.  The page size may vary between
    // processor types.
    STDMETHOD(GetPageSize)(
        THIS_
        __out PULONG Size
        ) PURE;
    // Returns S_OK if the current processor context uses
    // 64-bit addresses, otherwise S_FALSE.
    STDMETHOD(IsPointer64Bit)(
        THIS
        ) PURE;
    // Reads the bugcheck data area and returns the
    // current contents.  This method only works
    // in kernel debugging sessions.
    STDMETHOD(ReadBugCheckData)(
        THIS_
        __out PULONG Code,
        __out PULONG64 Arg1,
        __out PULONG64 Arg2,
        __out PULONG64 Arg3,
        __out PULONG64 Arg4
        ) PURE;

    // Query all the processor types supported by
    // the engine.  This is a complete list and is
    // not related to the machine running the engine
    // or the debuggee.
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Types
        ) PURE;
    // Returns a full, descriptive name and an
    // abbreviated name for a processor type.
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        __in ULONG Type,
        __out_ecount_opt(FullNameBufferSize) PSTR FullNameBuffer,
        __in ULONG FullNameBufferSize,
        __out_opt PULONG FullNameSize,
        __out_ecount_opt(AbbrevNameBufferSize) PSTR AbbrevNameBuffer,
        __in ULONG AbbrevNameBufferSize,
        __out_opt PULONG AbbrevNameSize
        ) PURE;

    // Gets and sets the type of processor to
    // use when doing things like setting
    // breakpoints, accessing registers,
    // getting stack traces and so on.
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        __in ULONG Type
        ) PURE;

    // Returns information about whether and how
    // the debuggee is running.  Status will
    // be GO if the debuggee is running and
    // BREAK if it isnt.
    // If no debuggee exists the status is
    // NO_DEBUGGEE.
    // This method is reentrant.
    STDMETHOD(GetExecutionStatus)(
        THIS_
        __out PULONG Status
        ) PURE;
    // Changes the execution status of the
    // engine from stopped to running.
    // Status must be one of the go or step
    // status values.
    STDMETHOD(SetExecutionStatus)(
        THIS_
        __in ULONG Status
        ) PURE;

    // Controls what code interpretation level the debugger
    // runs at.  The debugger checks the code level when
    // deciding whether to step by a source line or
    // assembly instruction along with other related operations.
    STDMETHOD(GetCodeLevel)(
        THIS_
        __out PULONG Level
        ) PURE;
    STDMETHOD(SetCodeLevel)(
        THIS_
        __in ULONG Level
        ) PURE;

    // Gets and sets engine control flags.
    // These methods are reentrant.
    STDMETHOD(GetEngineOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Gets and sets control values for
    // handling system error events.
    // If the system error level is less
    // than or equal to the given levels
    // the error may be displayed and
    // the default break for the event
    // may be set.
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        __out PULONG OutputLevel,
        __out PULONG BreakLevel
        ) PURE;
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        __in ULONG OutputLevel,
        __in ULONG BreakLevel
        ) PURE;

    // The command processor supports simple
    // string replacement macros in Evaluate and
    // Execute.  There are currently ten macro
    // slots available.  Slots 0-9 map to
    // the command invocations $u0-$u9.
    STDMETHOD(GetTextMacro)(
        THIS_
        __in ULONG Slot,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacro)(
        THIS_
        __in ULONG Slot,
        __in PCSTR Macro
        ) PURE;

    // Controls the default number radix used
    // in expressions and commands.
    STDMETHOD(GetRadix)(
        THIS_
        __out PULONG Radix
        ) PURE;
    STDMETHOD(SetRadix)(
        THIS_
        __in ULONG Radix
        ) PURE;

    // Evaluates the given expression string and
    // returns the resulting value.
    // If DesiredType is DEBUG_VALUE_INVALID then
    // the natural type is used.
    // RemainderIndex, if provided, is set to the index
    // of the first character in the input string that was
    // not used when evaluating the expression.
    STDMETHOD(Evaluate)(
        THIS_
        __in PCSTR Expression,
        __in ULONG DesiredType,
        __out PDEBUG_VALUE Value,
        __out_opt PULONG RemainderIndex
        ) PURE;
    // Attempts to convert the input value to a value
    // of the requested type in the output value.
    // Conversions can fail if no conversion exists.
    // Successful conversions may be lossy.
    STDMETHOD(CoerceValue)(
        THIS_
        __in PDEBUG_VALUE In,
        __in ULONG OutType,
        __out PDEBUG_VALUE Out
        ) PURE;
    STDMETHOD(CoerceValues)(
        THIS_
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_VALUE In,
        __in_ecount(Count) PULONG OutTypes,
        __out_ecount(Count) PDEBUG_VALUE Out
        ) PURE;

    // Executes the given command string.
    // If the string has multiple commands
    // Execute will not return until all
    // of them have been executed.  If this
    // requires waiting for the debuggee to
    // execute an internal wait will be done
    // so Execute can take an arbitrary amount
    // of time.
    STDMETHOD(Execute)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Command,
        __in ULONG Flags
        ) PURE;
    // Executes the given command file by
    // reading a line at a time and processing
    // it with Execute.
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR CommandFile,
        __in ULONG Flags
        ) PURE;

    // Breakpoint interfaces are described
    // elsewhere in this section.
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        __out PULONG Number
        ) PURE;
    // It is possible for this retrieval function to
    // fail even with an index within the number of
    // existing breakpoints if the breakpoint is
    // a private breakpoint.
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        __in ULONG Index,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById)(
        THIS_
        __in ULONG Id,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // If Ids is non-NULL the Count breakpoints
    // referred to in the Ids array are returned,
    // otherwise breakpoints from index Start to
    // Start + Count  1 are returned.
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Ids,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
    // Breakpoints are created empty and disabled.
    // When their parameters have been set they
    // should be enabled by setting the ENABLE flag.
    // If DesiredId is DEBUG_ANY_ID then the
    // engine picks an unused ID.  If DesiredId
    // is any other number the engine attempts
    // to use the given ID for the breakpoint.
    // If another breakpoint exists with that ID
    // the call will fail.
    STDMETHOD(AddBreakpoint)(
        THIS_
        __in ULONG Type,
        __in ULONG DesiredId,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // Breakpoint interface is invalid after this call.
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        __in PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Control and use extension DLLs.
    STDMETHOD(AddExtension)(
        THIS_
        __in PCSTR Path,
        __in ULONG Flags,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(RemoveExtension)(
        THIS_
        __in ULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPath)(
        THIS_
        __in PCSTR Path,
        __out PULONG64 Handle
        ) PURE;
    // If Handle is zero the extension
    // chain is walked searching for the
    // function.
    STDMETHOD(CallExtension)(
        THIS_
        __in ULONG64 Handle,
        __in PCSTR Function,
        __in_opt PCSTR Arguments
        ) PURE;
    // GetExtensionFunction works like
    // GetProcAddress on extension DLLs
    // to allow raw function-call-level
    // interaction with extension DLLs.
    // Such functions do not need to
    // follow the standard extension prototype
    // if they are not going to be called
    // through the text extension interface.
    // This function cannot be called remotely.
    STDMETHOD(GetExtensionFunction)(
        THIS_
        __in ULONG64 Handle,
        __in PCSTR FuncName,
        __out FARPROC* Function
        ) PURE;
    // These methods return alternate
    // extension interfaces in order to allow
    // interface-style extension DLLs to mix in
    // older extension calls.
    // Structure sizes must be initialized before
    // the call.
    // These methods cannot be called remotely.
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        __inout PWINDBG_EXTENSION_APIS32 Api
        ) PURE;
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        __inout PWINDBG_EXTENSION_APIS64 Api
        ) PURE;

    // The engine provides a simple mechanism
    // to filter common events.  Arbitrarily complicated
    // filtering can be done by registering event callbacks
    // but simple event filtering only requires
    // setting the options of one of the predefined
    // event filters.
    // Simple event filters are either for specific
    // events and therefore have an enumerant or
    // they are for an exception and are based on
    // the exceptions code.  Exception filters
    // are further divided into exceptions specially
    // handled by the engine, which is a fixed set,
    // and arbitrary exceptions.
    // All three groups of filters are indexed together
    // with the specific filters first, then the specific
    // exception filters and finally the arbitrary
    // exception filters.
    // The first specific exception is the default
    // exception.  If an exception event occurs for
    // an exception without settings the default
    // exception settings are used.
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        __out PULONG SpecificEvents,
        __out PULONG SpecificExceptions,
        __out PULONG ArbitraryExceptions
        ) PURE;
    // Some filters have descriptive text associated with them.
    STDMETHOD(GetEventFilterText)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    // All filters support executing a command when the
    // event occurs.
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        __in ULONG Index,
        __in PCSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    // Some specific filters have arguments to further
    // qualify their operation.
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        __in ULONG Index,
        __in PCSTR Argument
        ) PURE;
    // If Codes is non-NULL Start is ignored.
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Codes,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // The codes in the parameter data control the application
    // of the parameter data.  If a code is not already in
    // the set of filters it is added.  If the ExecutionOption
    // for a code is REMOVE then the filter is removed.
    // Specific exception filters cannot be removed.
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // Exception filters support an additional command for
    // second-chance events.
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        __in ULONG Index,
        __in PCSTR Command
        ) PURE;

    // Yields processing to the engine until
    // an event occurs.  This method may
    // only be called by the thread that started
    // the debug session.
    // When an event occurs the engine carries
    // out all event processing such as calling
    // callbacks.
    // If the callbacks indicate that execution should
    // break the wait will return, otherwise it
    // goes back to waiting for a new event.
    // If the timeout expires, S_FALSE is returned.
    // The timeout is not currently supported for
    // kernel debugging.
    STDMETHOD(WaitForEvent)(
        THIS_
        __in ULONG Flags,
        __in ULONG Timeout
        ) PURE;

    // Retrieves information about the last event that occurred.
    // EventType is one of the event callback mask bits.
    // ExtraInformation contains additional event-specific
    // information.  Not all events have additional information.
    STDMETHOD(GetLastEventInformation)(
        THIS_
        __out PULONG Type,
        __out PULONG ProcessId,
        __out PULONG ThreadId,
        __out_bcount_opt(ExtraInformationSize) PVOID ExtraInformation,
        __in ULONG ExtraInformationSize,
        __out_opt PULONG ExtraInformationUsed,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG DescriptionUsed
        ) PURE;

    // IDebugControl2.

    STDMETHOD(GetCurrentTimeDate)(
        THIS_
        __out PULONG TimeDate
        ) PURE;
    // Retrieves the number of seconds since the
    // machine started running.
    STDMETHOD(GetCurrentSystemUpTime)(
        THIS_
        __out PULONG UpTime
        ) PURE;

    // If the current session is a dump session,
    // retrieves any extended format information.
    STDMETHOD(GetDumpFormatFlags)(
        THIS_
        __out PULONG FormatFlags
        ) PURE;

    // The debugger has been enhanced to allow
    // arbitrary text replacements in addition
    // to the simple $u0-$u9 text macros.
    // Text replacement takes a given source
    // text in commands and converts it to the
    // given destination text.  Replacements
    // are named by their source text so that
    // only one replacement for a source text
    // string can exist.
    STDMETHOD(GetNumberTextReplacements)(
        THIS_
        __out PULONG NumRepl
        ) PURE;
    // If SrcText is non-NULL the replacement
    // is looked up by source text, otherwise
    // Index is used to get the Nth replacement.
    STDMETHOD(GetTextReplacement)(
        THIS_
        __in_opt PCSTR SrcText,
        __in ULONG Index,
        __out_ecount_opt(SrcBufferSize) PSTR SrcBuffer,
        __in ULONG SrcBufferSize,
        __out_opt PULONG SrcSize,
        __out_ecount_opt(DstBufferSize) PSTR DstBuffer,
        __in ULONG DstBufferSize,
        __out_opt PULONG DstSize
        ) PURE;
    // Setting the destination text to
    // NULL removes the alias.
    STDMETHOD(SetTextReplacement)(
        THIS_
        __in PCSTR SrcText,
        __in_opt PCSTR DstText
        ) PURE;
    STDMETHOD(RemoveTextReplacements)(
        THIS
        ) PURE;
    // Outputs the complete list of current
    // replacements.
    STDMETHOD(OutputTextReplacements)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;
};

//
// Assembly/disassembly options.
//
// The specific effects of these flags varies depending
// on the particular instruction set.
//

#define DEBUG_ASMOPT_DEFAULT             0x00000000
// Display additional information in disassembly.
#define DEBUG_ASMOPT_VERBOSE             0x00000001
// Do not display raw code bytes in disassembly.
#define DEBUG_ASMOPT_NO_CODE_BYTES       0x00000002
// Do not take the output width into account when
// formatting disassembly.
#define DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH 0x00000004
// Display source file line number before each line if available.
#define DEBUG_ASMOPT_SOURCE_LINE_NUMBER  0x00000008

//
// Expression syntax options.
//

// MASM-style expression evaluation.
#define DEBUG_EXPR_MASM      0x00000000
// C++-style expression evaluation.
#define DEBUG_EXPR_CPLUSPLUS 0x00000001

//
// Event index description information.
//

#define DEBUG_EINDEX_NAME 0x00000000

//
// SetNextEventIndex relation options.
//

// Value increases forward from the first index.
#define DEBUG_EINDEX_FROM_START   0x00000000
// Value increases backwards from the last index.
#define DEBUG_EINDEX_FROM_END     0x00000001
// Value is a signed delta from the current index.
#define DEBUG_EINDEX_FROM_CURRENT 0x00000002

#undef INTERFACE
#define INTERFACE IDebugControl3
DECLARE_INTERFACE_(IDebugControl3, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugControl.

    // Checks for a user interrupt, such a Ctrl-C
    // or stop button.
    // This method is reentrant.
    STDMETHOD(GetInterrupt)(
        THIS
        ) PURE;
    // Registers a user interrupt.
    // This method is reentrant.
    STDMETHOD(SetInterrupt)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Interrupting a user-mode process requires
    // access to some system resources that the
    // process may hold itself, preventing the
    // interrupt from occurring.  The engine
    // will time-out pending interrupt requests
    // and simulate an interrupt if necessary.
    // These methods control the interrupt timeout.
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        __out PULONG Seconds
        ) PURE;
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        __in ULONG Seconds
        ) PURE;

    STDMETHOD(GetLogFile)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FileSize,
        __out PBOOL Append
        ) PURE;
    // Opens a log file which collects all
    // output.  Output from every client except
    // those that explicitly disable logging
    // goes into the log.
    // Opening a log file closes any log file
    // already open.
    STDMETHOD(OpenLogFile)(
        THIS_
        __in PCSTR File,
        __in BOOL Append
        ) PURE;
    STDMETHOD(CloseLogFile)(
        THIS
        ) PURE;
    // Controls what output is logged.
    STDMETHOD(GetLogMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetLogMask)(
        THIS_
        __in ULONG Mask
        ) PURE;

    // Input requests input from all clients.
    // The first input that is returned is used
    // to satisfy the call.  Other returned
    // input is discarded.
    STDMETHOD(Input)(
        THIS_
        __out_ecount(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InputSize
        ) PURE;
    // This method is used by clients to return
    // input when it is available.  It will
    // return S_OK if the input is used to
    // satisfy an Input call and S_FALSE if
    // the input is ignored.
    // This method is reentrant.
    STDMETHOD(ReturnInput)(
        THIS_
        __in PCSTR Buffer
        ) PURE;

    // Sends output through clients
    // output callbacks if the mask is allowed
    // by the current output control mask and
    // according to the output distribution
    // settings.
    STDMETHODV(Output)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaList)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Format,
        __in va_list Args
        ) PURE;
    // The following methods allow direct control
    // over the distribution of the given output
    // for situations where something other than
    // the default is desired.  These methods require
    // extra work in the engine so they should
    // only be used when necessary.
    STDMETHODV(ControlledOutput)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCSTR Format,
        __in va_list Args
        ) PURE;

    // Displays the standard command-line prompt
    // followed by the given output.  If Format
    // is NULL no additional output is produced.
    // Output is produced under the
    // DEBUG_OUTPUT_PROMPT mask.
    // This method only outputs the prompt; it
    // does not get input.
    STDMETHODV(OutputPrompt)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaList)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCSTR Format,
        __in va_list Args
        ) PURE;
    // Gets the text that would be displayed by OutputPrompt.
    STDMETHOD(GetPromptText)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    // Outputs information about the current
    // debuggee state such as a register
    // summary, disassembly at the current PC,
    // closest symbol and others.
    // Uses the line prefix.
    STDMETHOD(OutputCurrentState)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;

    // Outputs the debugger and extension version
    // information.  This method is reentrant.
    // Uses the line prefix.
    STDMETHOD(OutputVersionInformation)(
        THIS_
        __in ULONG OutputControl
        ) PURE;

    // In user-mode debugging sessions the
    // engine will set an event when
    // exceptions are continued.  This can
    // be used to synchronize other processes
    // with the debuggers handling of events.
    // For example, this is used to support
    // the e argument to ntsd.
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    STDMETHOD(Assemble)(
        THIS_
        __in ULONG64 Offset,
        __in PCSTR Instr,
        __out PULONG64 EndOffset
        ) PURE;
    STDMETHOD(Disassemble)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DisassemblySize,
        __out PULONG64 EndOffset
        ) PURE;
    // Returns the value of the effective address
    // computed for the last Disassemble, if there
    // was one.
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Uses the line prefix if necessary.
    STDMETHOD(OutputDisassembly)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out PULONG64 EndOffset
        ) PURE;
    // Produces multiple lines of disassembly output.
    // There will be PreviousLines of disassembly before
    // the given offset if a valid disassembly exists.
    // In all, there will be TotalLines of output produced.
    // The first and last line offsets are returned
    // specially and all lines offsets can be retrieved
    // through LineOffsets.  LineOffsets will contain
    // offsets for each line where disassembly started.
    // When disassembly of a single instruction takes
    // multiple lines the initial offset will be followed
    // by DEBUG_INVALID_OFFSET.
    // Uses the line prefix.
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG PreviousLines,
        __in ULONG TotalLines,
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_opt PULONG OffsetLine,
        __out_opt PULONG64 StartOffset,
        __out_opt PULONG64 EndOffset,
        __out_ecount_opt(TotalLines) PULONG64 LineOffsets
        ) PURE;
    // Returns the offset of the start of
    // the instruction thats the given
    // delta away from the instruction
    // at the initial offset.
    // This routine does not check for
    // validity of the instruction or
    // the memory containing it.
    STDMETHOD(GetNearInstruction)(
        THIS_
        __in ULONG64 Offset,
        __in LONG Delta,
        __out PULONG64 NearOffset
        ) PURE;

    // Offsets can be passed in as zero to use the current
    // thread state.
    STDMETHOD(GetStackTrace)(
        THIS_
        __in ULONG64 FrameOffset,
        __in ULONG64 StackOffset,
        __in ULONG64 InstructionOffset,
        __out_ecount(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __out_opt PULONG FramesFilled
        ) PURE;
    // Does a simple stack trace to determine
    // what the current return address is.
    STDMETHOD(GetReturnOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // If Frames is NULL OutputStackTrace will
    // use GetStackTrace to get FramesSize frames
    // and then output them.  The current register
    // values for frame, stack and instruction offsets
    // are used.
    // Uses the line prefix.
    STDMETHOD(OutputStackTrace)(
        THIS_
        __in ULONG OutputControl,
        __in_ecount_opt(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __in ULONG Flags
        ) PURE;

    // Returns information about the debuggee such
    // as user vs. kernel, dump vs. live, etc.
    STDMETHOD(GetDebuggeeType)(
        THIS_
        __out PULONG Class,
        __out PULONG Qualifier
        ) PURE;
    // Returns the type of physical processors in
    // the machine.
    // Returns one of the IMAGE_FILE_MACHINE values.
    STDMETHOD(GetActualProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    // Returns the type of processor used in the
    // current processor context.
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    // Query all the possible processor types that
    // may be encountered during this debug session.
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Types
        ) PURE;
    // Get the number of actual processors in
    // the machine.
    STDMETHOD(GetNumberProcessors)(
        THIS_
        __out PULONG Number
        ) PURE;
    // PlatformId is one of the VER_PLATFORM values.
    // Major and minor are as given in the NT
    // kernel debugger protocol.
    // ServicePackString and ServicePackNumber indicate the
    // system service pack level.  ServicePackNumber is not
    // available in some sessions where the service pack level
    // is only expressed as a string.  The service pack information
    // will be empty if the system does not have a service pack
    // applied.
    // The build string is string information identifying the
    // particular build of the system.  The build string is
    // empty if the system has no particular identifying
    // information.
    STDMETHOD(GetSystemVersion)(
        THIS_
        __out PULONG PlatformId,
        __out PULONG Major,
        __out PULONG Minor,
        __out_ecount_opt(ServicePackStringSize) PSTR ServicePackString,
        __in ULONG ServicePackStringSize,
        __out_opt PULONG ServicePackStringUsed,
        __out PULONG ServicePackNumber,
        __out_ecount_opt(BuildStringSize) PSTR BuildString,
        __in ULONG BuildStringSize,
        __out_opt PULONG BuildStringUsed
        ) PURE;
    // Returns the page size for the currently executing
    // processor context.  The page size may vary between
    // processor types.
    STDMETHOD(GetPageSize)(
        THIS_
        __out PULONG Size
        ) PURE;
    // Returns S_OK if the current processor context uses
    // 64-bit addresses, otherwise S_FALSE.
    STDMETHOD(IsPointer64Bit)(
        THIS
        ) PURE;
    // Reads the bugcheck data area and returns the
    // current contents.  This method only works
    // in kernel debugging sessions.
    STDMETHOD(ReadBugCheckData)(
        THIS_
        __out PULONG Code,
        __out PULONG64 Arg1,
        __out PULONG64 Arg2,
        __out PULONG64 Arg3,
        __out PULONG64 Arg4
        ) PURE;

    // Query all the processor types supported by
    // the engine.  This is a complete list and is
    // not related to the machine running the engine
    // or the debuggee.
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Types
        ) PURE;
    // Returns a full, descriptive name and an
    // abbreviated name for a processor type.
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        __in ULONG Type,
        __out_ecount_opt(FullNameBufferSize) PSTR FullNameBuffer,
        __in ULONG FullNameBufferSize,
        __out_opt PULONG FullNameSize,
        __out_ecount_opt(AbbrevNameBufferSize) PSTR AbbrevNameBuffer,
        __in ULONG AbbrevNameBufferSize,
        __out_opt PULONG AbbrevNameSize
        ) PURE;

    // Gets and sets the type of processor to
    // use when doing things like setting
    // breakpoints, accessing registers,
    // getting stack traces and so on.
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        __in ULONG Type
        ) PURE;

    // Returns information about whether and how
    // the debuggee is running.  Status will
    // be GO if the debuggee is running and
    // BREAK if it isnt.
    // If no debuggee exists the status is
    // NO_DEBUGGEE.
    // This method is reentrant.
    STDMETHOD(GetExecutionStatus)(
        THIS_
        __out PULONG Status
        ) PURE;
    // Changes the execution status of the
    // engine from stopped to running.
    // Status must be one of the go or step
    // status values.
    STDMETHOD(SetExecutionStatus)(
        THIS_
        __in ULONG Status
        ) PURE;

    // Controls what code interpretation level the debugger
    // runs at.  The debugger checks the code level when
    // deciding whether to step by a source line or
    // assembly instruction along with other related operations.
    STDMETHOD(GetCodeLevel)(
        THIS_
        __out PULONG Level
        ) PURE;
    STDMETHOD(SetCodeLevel)(
        THIS_
        __in ULONG Level
        ) PURE;

    // Gets and sets engine control flags.
    // These methods are reentrant.
    STDMETHOD(GetEngineOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Gets and sets control values for
    // handling system error events.
    // If the system error level is less
    // than or equal to the given levels
    // the error may be displayed and
    // the default break for the event
    // may be set.
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        __out PULONG OutputLevel,
        __out PULONG BreakLevel
        ) PURE;
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        __in ULONG OutputLevel,
        __in ULONG BreakLevel
        ) PURE;

    // The command processor supports simple
    // string replacement macros in Evaluate and
    // Execute.  There are currently ten macro
    // slots available.  Slots 0-9 map to
    // the command invocations $u0-$u9.
    STDMETHOD(GetTextMacro)(
        THIS_
        __in ULONG Slot,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacro)(
        THIS_
        __in ULONG Slot,
        __in PCSTR Macro
        ) PURE;

    // Controls the default number radix used
    // in expressions and commands.
    STDMETHOD(GetRadix)(
        THIS_
        __out PULONG Radix
        ) PURE;
    STDMETHOD(SetRadix)(
        THIS_
        __in ULONG Radix
        ) PURE;

    // Evaluates the given expression string and
    // returns the resulting value.
    // If DesiredType is DEBUG_VALUE_INVALID then
    // the natural type is used.
    // RemainderIndex, if provided, is set to the index
    // of the first character in the input string that was
    // not used when evaluating the expression.
    STDMETHOD(Evaluate)(
        THIS_
        __in PCSTR Expression,
        __in ULONG DesiredType,
        __out PDEBUG_VALUE Value,
        __out_opt PULONG RemainderIndex
        ) PURE;
    // Attempts to convert the input value to a value
    // of the requested type in the output value.
    // Conversions can fail if no conversion exists.
    // Successful conversions may be lossy.
    STDMETHOD(CoerceValue)(
        THIS_
        __in PDEBUG_VALUE In,
        __in ULONG OutType,
        __out PDEBUG_VALUE Out
        ) PURE;
    STDMETHOD(CoerceValues)(
        THIS_
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_VALUE In,
        __in_ecount(Count) PULONG OutTypes,
        __out_ecount(Count) PDEBUG_VALUE Out
        ) PURE;

    // Executes the given command string.
    // If the string has multiple commands
    // Execute will not return until all
    // of them have been executed.  If this
    // requires waiting for the debuggee to
    // execute an internal wait will be done
    // so Execute can take an arbitrary amount
    // of time.
    STDMETHOD(Execute)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Command,
        __in ULONG Flags
        ) PURE;
    // Executes the given command file by
    // reading a line at a time and processing
    // it with Execute.
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR CommandFile,
        __in ULONG Flags
        ) PURE;

    // Breakpoint interfaces are described
    // elsewhere in this section.
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        __out PULONG Number
        ) PURE;
    // It is possible for this retrieval function to
    // fail even with an index within the number of
    // existing breakpoints if the breakpoint is
    // a private breakpoint.
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        __in ULONG Index,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById)(
        THIS_
        __in ULONG Id,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // If Ids is non-NULL the Count breakpoints
    // referred to in the Ids array are returned,
    // otherwise breakpoints from index Start to
    // Start + Count  1 are returned.
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Ids,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
    // Breakpoints are created empty and disabled.
    // When their parameters have been set they
    // should be enabled by setting the ENABLE flag.
    // If DesiredId is DEBUG_ANY_ID then the
    // engine picks an unused ID.  If DesiredId
    // is any other number the engine attempts
    // to use the given ID for the breakpoint.
    // If another breakpoint exists with that ID
    // the call will fail.
    STDMETHOD(AddBreakpoint)(
        THIS_
        __in ULONG Type,
        __in ULONG DesiredId,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // Breakpoint interface is invalid after this call.
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        __in PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Control and use extension DLLs.
    STDMETHOD(AddExtension)(
        THIS_
        __in PCSTR Path,
        __in ULONG Flags,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(RemoveExtension)(
        THIS_
        __in ULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPath)(
        THIS_
        __in PCSTR Path,
        __out PULONG64 Handle
        ) PURE;
    // If Handle is zero the extension
    // chain is walked searching for the
    // function.
    STDMETHOD(CallExtension)(
        THIS_
        __in ULONG64 Handle,
        __in PCSTR Function,
        __in_opt PCSTR Arguments
        ) PURE;
    // GetExtensionFunction works like
    // GetProcAddress on extension DLLs
    // to allow raw function-call-level
    // interaction with extension DLLs.
    // Such functions do not need to
    // follow the standard extension prototype
    // if they are not going to be called
    // through the text extension interface.
    // This function cannot be called remotely.
    STDMETHOD(GetExtensionFunction)(
        THIS_
        __in ULONG64 Handle,
        __in PCSTR FuncName,
        __out FARPROC* Function
        ) PURE;
    // These methods return alternate
    // extension interfaces in order to allow
    // interface-style extension DLLs to mix in
    // older extension calls.
    // Structure sizes must be initialized before
    // the call.
    // These methods cannot be called remotely.
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        __inout PWINDBG_EXTENSION_APIS32 Api
        ) PURE;
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        __inout PWINDBG_EXTENSION_APIS64 Api
        ) PURE;

    // The engine provides a simple mechanism
    // to filter common events.  Arbitrarily complicated
    // filtering can be done by registering event callbacks
    // but simple event filtering only requires
    // setting the options of one of the predefined
    // event filters.
    // Simple event filters are either for specific
    // events and therefore have an enumerant or
    // they are for an exception and are based on
    // the exceptions code.  Exception filters
    // are further divided into exceptions specially
    // handled by the engine, which is a fixed set,
    // and arbitrary exceptions.
    // All three groups of filters are indexed together
    // with the specific filters first, then the specific
    // exception filters and finally the arbitrary
    // exception filters.
    // The first specific exception is the default
    // exception.  If an exception event occurs for
    // an exception without settings the default
    // exception settings are used.
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        __out PULONG SpecificEvents,
        __out PULONG SpecificExceptions,
        __out PULONG ArbitraryExceptions
        ) PURE;
    // Some filters have descriptive text associated with them.
    STDMETHOD(GetEventFilterText)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    // All filters support executing a command when the
    // event occurs.
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        __in ULONG Index,
        __in PCSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    // Some specific filters have arguments to further
    // qualify their operation.
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        __in ULONG Index,
        __in PCSTR Argument
        ) PURE;
    // If Codes is non-NULL Start is ignored.
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Codes,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // The codes in the parameter data control the application
    // of the parameter data.  If a code is not already in
    // the set of filters it is added.  If the ExecutionOption
    // for a code is REMOVE then the filter is removed.
    // Specific exception filters cannot be removed.
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // Exception filters support an additional command for
    // second-chance events.
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        __in ULONG Index,
        __in PCSTR Command
        ) PURE;

    // Yields processing to the engine until
    // an event occurs.  This method may
    // only be called by the thread that started
    // the debug session.
    // When an event occurs the engine carries
    // out all event processing such as calling
    // callbacks.
    // If the callbacks indicate that execution should
    // break the wait will return, otherwise it
    // goes back to waiting for a new event.
    // If the timeout expires, S_FALSE is returned.
    // The timeout is not currently supported for
    // kernel debugging.
    STDMETHOD(WaitForEvent)(
        THIS_
        __in ULONG Flags,
        __in ULONG Timeout
        ) PURE;

    // Retrieves information about the last event that occurred.
    // EventType is one of the event callback mask bits.
    // ExtraInformation contains additional event-specific
    // information.  Not all events have additional information.
    STDMETHOD(GetLastEventInformation)(
        THIS_
        __out PULONG Type,
        __out PULONG ProcessId,
        __out PULONG ThreadId,
        __out_bcount_opt(ExtraInformationSize) PVOID ExtraInformation,
        __in ULONG ExtraInformationSize,
        __out_opt PULONG ExtraInformationUsed,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG DescriptionUsed
        ) PURE;

    // IDebugControl2.

    STDMETHOD(GetCurrentTimeDate)(
        THIS_
        __out PULONG TimeDate
        ) PURE;
    // Retrieves the number of seconds since the
    // machine started running.
    STDMETHOD(GetCurrentSystemUpTime)(
        THIS_
        __out PULONG UpTime
        ) PURE;

    // If the current session is a dump session,
    // retrieves any extended format information.
    STDMETHOD(GetDumpFormatFlags)(
        THIS_
        __out PULONG FormatFlags
        ) PURE;

    // The debugger has been enhanced to allow
    // arbitrary text replacements in addition
    // to the simple $u0-$u9 text macros.
    // Text replacement takes a given source
    // text in commands and converts it to the
    // given destination text.  Replacements
    // are named by their source text so that
    // only one replacement for a source text
    // string can exist.
    STDMETHOD(GetNumberTextReplacements)(
        THIS_
        __out PULONG NumRepl
        ) PURE;
    // If SrcText is non-NULL the replacement
    // is looked up by source text, otherwise
    // Index is used to get the Nth replacement.
    STDMETHOD(GetTextReplacement)(
        THIS_
        __in_opt PCSTR SrcText,
        __in ULONG Index,
        __out_ecount_opt(SrcBufferSize) PSTR SrcBuffer,
        __in ULONG SrcBufferSize,
        __out_opt PULONG SrcSize,
        __out_ecount_opt(DstBufferSize) PSTR DstBuffer,
        __in ULONG DstBufferSize,
        __out_opt PULONG DstSize
        ) PURE;
    // Setting the destination text to
    // NULL removes the alias.
    STDMETHOD(SetTextReplacement)(
        THIS_
        __in PCSTR SrcText,
        __in_opt PCSTR DstText
        ) PURE;
    STDMETHOD(RemoveTextReplacements)(
        THIS
        ) PURE;
    // Outputs the complete list of current
    // replacements.
    STDMETHOD(OutputTextReplacements)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;

    // IDebugControl3.

    // Control options for assembly and disassembly.
    STDMETHOD(GetAssemblyOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddAssemblyOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveAssemblyOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetAssemblyOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Control the expression syntax.
    STDMETHOD(GetExpressionSyntax)(
        THIS_
        __out PULONG Flags
        ) PURE;
    STDMETHOD(SetExpressionSyntax)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Look up a syntax by its abbreviated
    // name and set it.
    STDMETHOD(SetExpressionSyntaxByName)(
        THIS_
        __in PCSTR AbbrevName
        ) PURE;
    STDMETHOD(GetNumberExpressionSyntaxes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetExpressionSyntaxNames)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(FullNameBufferSize) PSTR FullNameBuffer,
        __in ULONG FullNameBufferSize,
        __out_opt PULONG FullNameSize,
        __out_ecount_opt(AbbrevNameBufferSize) PSTR AbbrevNameBuffer,
        __in ULONG AbbrevNameBufferSize,
        __out_opt PULONG AbbrevNameSize
        ) PURE;

    //
    // Some debug sessions have only a single
    // possible event, such as a snapshot dump
    // file; some have dynamic events, such as
    // a live debug session; and others may have
    // multiple events, such as a dump file that
    // contains snapshots from different points
    // in time.  The following methods allow
    // discovery and selection of the available
    // events for a session.
    // Sessions with one or more static events
    // will be able to report all of the events
    // when queried.  Sessions with dynamic events
    // will only report a single event representing
    // the current event.
    // Switching events constitutes execution and
    // changing the current event will alter the
    // execution status to a running state, after
    // which WaitForEvent must be used to process
    // the selected event.
    //

    // GetNumberEvents returns S_OK if this is the
    // complete set of events possible, such as for
    // a static session; or S_FALSE if other events
    // may be possible, such as for a dynamic session.
    STDMETHOD(GetNumberEvents)(
        THIS_
        __out PULONG Events
        ) PURE;
    // Sessions may have descriptive information for
    // the various events available.  The amount of
    // information varies according to the specific
    // session and data.
    STDMETHOD(GetEventIndexDescription)(
        THIS_
        __in ULONG Index,
        __in ULONG Which,
        __in_opt PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DescSize
        ) PURE;
    STDMETHOD(GetCurrentEventIndex)(
        THIS_
        __out PULONG Index
        ) PURE;
    // SetNextEventIndex works like seek in that
    // it can set an absolute or relative index.
    // SetNextEventIndex works similarly to SetExecutionStatus
    // by putting the session into a running state, after
    // which the caller must call WaitForEvent.  The
    // current event index only changes when WaitForEvent
    // is called.
    STDMETHOD(SetNextEventIndex)(
        THIS_
        __in ULONG Relation,
        __in ULONG Value,
        __out PULONG NextIndex
        ) PURE;
};

//
// Log file flags.
//

#define DEBUG_LOG_DEFAULT 0x00000000
#define DEBUG_LOG_APPEND  0x00000001
#define DEBUG_LOG_UNICODE 0x00000002

//
// System version strings.
//

#define DEBUG_SYSVERSTR_SERVICE_PACK 0x00000000
#define DEBUG_SYSVERSTR_BUILD        0x00000001

//
// GetManagedStatus flags and strings.
//

#define DEBUG_MANAGED_DISABLED   0x00000000
#define DEBUG_MANAGED_ALLOWED    0x00000001
#define DEBUG_MANAGED_DLL_LOADED 0x00000002

#define DEBUG_MANSTR_NONE               0x00000000
#define DEBUG_MANSTR_LOADED_SUPPORT_DLL 0x00000001
#define DEBUG_MANSTR_LOAD_STATUS        0x00000002

//
// ResetManagedStatus flags.
//

// Reset state to default engine startup state with
// no support loaded.
#define DEBUG_MANRESET_DEFAULT  0x00000000
// Force managed support DLL load attempt.
#define DEBUG_MANRESET_LOAD_DLL 0x00000001

#undef INTERFACE
#define INTERFACE IDebugControl4
DECLARE_INTERFACE_(IDebugControl4, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugControl.

    // Checks for a user interrupt, such a Ctrl-C
    // or stop button.
    // This method is reentrant.
    STDMETHOD(GetInterrupt)(
        THIS
        ) PURE;
    // Registers a user interrupt.
    // This method is reentrant.
    STDMETHOD(SetInterrupt)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Interrupting a user-mode process requires
    // access to some system resources that the
    // process may hold itself, preventing the
    // interrupt from occurring.  The engine
    // will time-out pending interrupt requests
    // and simulate an interrupt if necessary.
    // These methods control the interrupt timeout.
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        __out PULONG Seconds
        ) PURE;
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        __in ULONG Seconds
        ) PURE;

    STDMETHOD(GetLogFile)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FileSize,
        __out PBOOL Append
        ) PURE;
    // Opens a log file which collects all
    // output.  Output from every client except
    // those that explicitly disable logging
    // goes into the log.
    // Opening a log file closes any log file
    // already open.
    STDMETHOD(OpenLogFile)(
        THIS_
        __in PCSTR File,
        __in BOOL Append
        ) PURE;
    STDMETHOD(CloseLogFile)(
        THIS
        ) PURE;
    // Controls what output is logged.
    STDMETHOD(GetLogMask)(
        THIS_
        __out PULONG Mask
        ) PURE;
    STDMETHOD(SetLogMask)(
        THIS_
        __in ULONG Mask
        ) PURE;

    // Input requests input from all clients.
    // The first input that is returned is used
    // to satisfy the call.  Other returned
    // input is discarded.
    STDMETHOD(Input)(
        THIS_
        __out_ecount(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InputSize
        ) PURE;
    // This method is used by clients to return
    // input when it is available.  It will
    // return S_OK if the input is used to
    // satisfy an Input call and S_FALSE if
    // the input is ignored.
    // This method is reentrant.
    STDMETHOD(ReturnInput)(
        THIS_
        __in PCSTR Buffer
        ) PURE;

    // Sends output through clients
    // output callbacks if the mask is allowed
    // by the current output control mask and
    // according to the output distribution
    // settings.
    STDMETHODV(Output)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaList)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Format,
        __in va_list Args
        ) PURE;
    // The following methods allow direct control
    // over the distribution of the given output
    // for situations where something other than
    // the default is desired.  These methods require
    // extra work in the engine so they should
    // only be used when necessary.
    STDMETHODV(ControlledOutput)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCSTR Format,
        __in va_list Args
        ) PURE;

    // Displays the standard command-line prompt
    // followed by the given output.  If Format
    // is NULL no additional output is produced.
    // Output is produced under the
    // DEBUG_OUTPUT_PROMPT mask.
    // This method only outputs the prompt; it
    // does not get input.
    STDMETHODV(OutputPrompt)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaList)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCSTR Format,
        __in va_list Args
        ) PURE;
    // Gets the text that would be displayed by OutputPrompt.
    STDMETHOD(GetPromptText)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    // Outputs information about the current
    // debuggee state such as a register
    // summary, disassembly at the current PC,
    // closest symbol and others.
    // Uses the line prefix.
    STDMETHOD(OutputCurrentState)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;

    // Outputs the debugger and extension version
    // information.  This method is reentrant.
    // Uses the line prefix.
    STDMETHOD(OutputVersionInformation)(
        THIS_
        __in ULONG OutputControl
        ) PURE;

    // In user-mode debugging sessions the
    // engine will set an event when
    // exceptions are continued.  This can
    // be used to synchronize other processes
    // with the debuggers handling of events.
    // For example, this is used to support
    // the e argument to ntsd.
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    STDMETHOD(Assemble)(
        THIS_
        __in ULONG64 Offset,
        __in PCSTR Instr,
        __out PULONG64 EndOffset
        ) PURE;
    STDMETHOD(Disassemble)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DisassemblySize,
        __out PULONG64 EndOffset
        ) PURE;
    // Returns the value of the effective address
    // computed for the last Disassemble, if there
    // was one.
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Uses the line prefix if necessary.
    STDMETHOD(OutputDisassembly)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out PULONG64 EndOffset
        ) PURE;
    // Produces multiple lines of disassembly output.
    // There will be PreviousLines of disassembly before
    // the given offset if a valid disassembly exists.
    // In all, there will be TotalLines of output produced.
    // The first and last line offsets are returned
    // specially and all lines offsets can be retrieved
    // through LineOffsets.  LineOffsets will contain
    // offsets for each line where disassembly started.
    // When disassembly of a single instruction takes
    // multiple lines the initial offset will be followed
    // by DEBUG_INVALID_OFFSET.
    // Uses the line prefix.
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG PreviousLines,
        __in ULONG TotalLines,
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_opt PULONG OffsetLine,
        __out_opt PULONG64 StartOffset,
        __out_opt PULONG64 EndOffset,
        __out_ecount_opt(TotalLines) PULONG64 LineOffsets
        ) PURE;
    // Returns the offset of the start of
    // the instruction thats the given
    // delta away from the instruction
    // at the initial offset.
    // This routine does not check for
    // validity of the instruction or
    // the memory containing it.
    STDMETHOD(GetNearInstruction)(
        THIS_
        __in ULONG64 Offset,
        __in LONG Delta,
        __out PULONG64 NearOffset
        ) PURE;

    // Offsets can be passed in as zero to use the current
    // thread state.
    STDMETHOD(GetStackTrace)(
        THIS_
        __in ULONG64 FrameOffset,
        __in ULONG64 StackOffset,
        __in ULONG64 InstructionOffset,
        __out_ecount(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __out_opt PULONG FramesFilled
        ) PURE;
    // Does a simple stack trace to determine
    // what the current return address is.
    STDMETHOD(GetReturnOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // If Frames is NULL OutputStackTrace will
    // use GetStackTrace to get FramesSize frames
    // and then output them.  The current register
    // values for frame, stack and instruction offsets
    // are used.
    // Uses the line prefix.
    STDMETHOD(OutputStackTrace)(
        THIS_
        __in ULONG OutputControl,
        __in_ecount_opt(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __in ULONG Flags
        ) PURE;

    // Returns information about the debuggee such
    // as user vs. kernel, dump vs. live, etc.
    STDMETHOD(GetDebuggeeType)(
        THIS_
        __out PULONG Class,
        __out PULONG Qualifier
        ) PURE;
    // Returns the type of physical processors in
    // the machine.
    // Returns one of the IMAGE_FILE_MACHINE values.
    STDMETHOD(GetActualProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    // Returns the type of processor used in the
    // current processor context.
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    // Query all the possible processor types that
    // may be encountered during this debug session.
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Types
        ) PURE;
    // Get the number of actual processors in
    // the machine.
    STDMETHOD(GetNumberProcessors)(
        THIS_
        __out PULONG Number
        ) PURE;
    // PlatformId is one of the VER_PLATFORM values.
    // Major and minor are as given in the NT
    // kernel debugger protocol.
    // ServicePackString and ServicePackNumber indicate the
    // system service pack level.  ServicePackNumber is not
    // available in some sessions where the service pack level
    // is only expressed as a string.  The service pack information
    // will be empty if the system does not have a service pack
    // applied.
    // The build string is string information identifying the
    // particular build of the system.  The build string is
    // empty if the system has no particular identifying
    // information.
    STDMETHOD(GetSystemVersion)(
        THIS_
        __out PULONG PlatformId,
        __out PULONG Major,
        __out PULONG Minor,
        __out_ecount_opt(ServicePackStringSize) PSTR ServicePackString,
        __in ULONG ServicePackStringSize,
        __out_opt PULONG ServicePackStringUsed,
        __out PULONG ServicePackNumber,
        __out_ecount_opt(BuildStringSize) PSTR BuildString,
        __in ULONG BuildStringSize,
        __out_opt PULONG BuildStringUsed
        ) PURE;
    // Returns the page size for the currently executing
    // processor context.  The page size may vary between
    // processor types.
    STDMETHOD(GetPageSize)(
        THIS_
        __out PULONG Size
        ) PURE;
    // Returns S_OK if the current processor context uses
    // 64-bit addresses, otherwise S_FALSE.
    STDMETHOD(IsPointer64Bit)(
        THIS
        ) PURE;
    // Reads the bugcheck data area and returns the
    // current contents.  This method only works
    // in kernel debugging sessions.
    STDMETHOD(ReadBugCheckData)(
        THIS_
        __out PULONG Code,
        __out PULONG64 Arg1,
        __out PULONG64 Arg2,
        __out PULONG64 Arg3,
        __out PULONG64 Arg4
        ) PURE;

    // Query all the processor types supported by
    // the engine.  This is a complete list and is
    // not related to the machine running the engine
    // or the debuggee.
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Types
        ) PURE;
    // Returns a full, descriptive name and an
    // abbreviated name for a processor type.
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        __in ULONG Type,
        __out_ecount_opt(FullNameBufferSize) PSTR FullNameBuffer,
        __in ULONG FullNameBufferSize,
        __out_opt PULONG FullNameSize,
        __out_ecount_opt(AbbrevNameBufferSize) PSTR AbbrevNameBuffer,
        __in ULONG AbbrevNameBufferSize,
        __out_opt PULONG AbbrevNameSize
        ) PURE;

    // Gets and sets the type of processor to
    // use when doing things like setting
    // breakpoints, accessing registers,
    // getting stack traces and so on.
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        __out PULONG Type
        ) PURE;
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        __in ULONG Type
        ) PURE;

    // Returns information about whether and how
    // the debuggee is running.  Status will
    // be GO if the debuggee is running and
    // BREAK if it isnt.
    // If no debuggee exists the status is
    // NO_DEBUGGEE.
    // This method is reentrant.
    STDMETHOD(GetExecutionStatus)(
        THIS_
        __out PULONG Status
        ) PURE;
    // Changes the execution status of the
    // engine from stopped to running.
    // Status must be one of the go or step
    // status values.
    STDMETHOD(SetExecutionStatus)(
        THIS_
        __in ULONG Status
        ) PURE;

    // Controls what code interpretation level the debugger
    // runs at.  The debugger checks the code level when
    // deciding whether to step by a source line or
    // assembly instruction along with other related operations.
    STDMETHOD(GetCodeLevel)(
        THIS_
        __out PULONG Level
        ) PURE;
    STDMETHOD(SetCodeLevel)(
        THIS_
        __in ULONG Level
        ) PURE;

    // Gets and sets engine control flags.
    // These methods are reentrant.
    STDMETHOD(GetEngineOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetEngineOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Gets and sets control values for
    // handling system error events.
    // If the system error level is less
    // than or equal to the given levels
    // the error may be displayed and
    // the default break for the event
    // may be set.
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        __out PULONG OutputLevel,
        __out PULONG BreakLevel
        ) PURE;
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        __in ULONG OutputLevel,
        __in ULONG BreakLevel
        ) PURE;

    // The command processor supports simple
    // string replacement macros in Evaluate and
    // Execute.  There are currently ten macro
    // slots available.  Slots 0-9 map to
    // the command invocations $u0-$u9.
    STDMETHOD(GetTextMacro)(
        THIS_
        __in ULONG Slot,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacro)(
        THIS_
        __in ULONG Slot,
        __in PCSTR Macro
        ) PURE;

    // Controls the default number radix used
    // in expressions and commands.
    STDMETHOD(GetRadix)(
        THIS_
        __out PULONG Radix
        ) PURE;
    STDMETHOD(SetRadix)(
        THIS_
        __in ULONG Radix
        ) PURE;

    // Evaluates the given expression string and
    // returns the resulting value.
    // If DesiredType is DEBUG_VALUE_INVALID then
    // the natural type is used.
    // RemainderIndex, if provided, is set to the index
    // of the first character in the input string that was
    // not used when evaluating the expression.
    STDMETHOD(Evaluate)(
        THIS_
        __in PCSTR Expression,
        __in ULONG DesiredType,
        __out PDEBUG_VALUE Value,
        __out_opt PULONG RemainderIndex
        ) PURE;
    // Attempts to convert the input value to a value
    // of the requested type in the output value.
    // Conversions can fail if no conversion exists.
    // Successful conversions may be lossy.
    STDMETHOD(CoerceValue)(
        THIS_
        __in PDEBUG_VALUE In,
        __in ULONG OutType,
        __out PDEBUG_VALUE Out
        ) PURE;
    STDMETHOD(CoerceValues)(
        THIS_
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_VALUE In,
        __in_ecount(Count) PULONG OutTypes,
        __out_ecount(Count) PDEBUG_VALUE Out
        ) PURE;

    // Executes the given command string.
    // If the string has multiple commands
    // Execute will not return until all
    // of them have been executed.  If this
    // requires waiting for the debuggee to
    // execute an internal wait will be done
    // so Execute can take an arbitrary amount
    // of time.
    STDMETHOD(Execute)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR Command,
        __in ULONG Flags
        ) PURE;
    // Executes the given command file by
    // reading a line at a time and processing
    // it with Execute.
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        __in ULONG OutputControl,
        __in PCSTR CommandFile,
        __in ULONG Flags
        ) PURE;

    // Breakpoint interfaces are described
    // elsewhere in this section.
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        __out PULONG Number
        ) PURE;
    // It is possible for this retrieval function to
    // fail even with an index within the number of
    // existing breakpoints if the breakpoint is
    // a private breakpoint.
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        __in ULONG Index,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById)(
        THIS_
        __in ULONG Id,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // If Ids is non-NULL the Count breakpoints
    // referred to in the Ids array are returned,
    // otherwise breakpoints from index Start to
    // Start + Count  1 are returned.
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Ids,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
    // Breakpoints are created empty and disabled.
    // When their parameters have been set they
    // should be enabled by setting the ENABLE flag.
    // If DesiredId is DEBUG_ANY_ID then the
    // engine picks an unused ID.  If DesiredId
    // is any other number the engine attempts
    // to use the given ID for the breakpoint.
    // If another breakpoint exists with that ID
    // the call will fail.
    STDMETHOD(AddBreakpoint)(
        THIS_
        __in ULONG Type,
        __in ULONG DesiredId,
        __out PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // Breakpoint interface is invalid after this call.
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        __in PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Control and use extension DLLs.
    STDMETHOD(AddExtension)(
        THIS_
        __in PCSTR Path,
        __in ULONG Flags,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(RemoveExtension)(
        THIS_
        __in ULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPath)(
        THIS_
        __in PCSTR Path,
        __out PULONG64 Handle
        ) PURE;
    // If Handle is zero the extension
    // chain is walked searching for the
    // function.
    STDMETHOD(CallExtension)(
        THIS_
        __in ULONG64 Handle,
        __in PCSTR Function,
        __in_opt PCSTR Arguments
        ) PURE;
    // GetExtensionFunction works like
    // GetProcAddress on extension DLLs
    // to allow raw function-call-level
    // interaction with extension DLLs.
    // Such functions do not need to
    // follow the standard extension prototype
    // if they are not going to be called
    // through the text extension interface.
    // This function cannot be called remotely.
    STDMETHOD(GetExtensionFunction)(
        THIS_
        __in ULONG64 Handle,
        __in PCSTR FuncName,
        __out FARPROC* Function
        ) PURE;
    // These methods return alternate
    // extension interfaces in order to allow
    // interface-style extension DLLs to mix in
    // older extension calls.
    // Structure sizes must be initialized before
    // the call.
    // These methods cannot be called remotely.
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        __inout PWINDBG_EXTENSION_APIS32 Api
        ) PURE;
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        __inout PWINDBG_EXTENSION_APIS64 Api
        ) PURE;

    // The engine provides a simple mechanism
    // to filter common events.  Arbitrarily complicated
    // filtering can be done by registering event callbacks
    // but simple event filtering only requires
    // setting the options of one of the predefined
    // event filters.
    // Simple event filters are either for specific
    // events and therefore have an enumerant or
    // they are for an exception and are based on
    // the exceptions code.  Exception filters
    // are further divided into exceptions specially
    // handled by the engine, which is a fixed set,
    // and arbitrary exceptions.
    // All three groups of filters are indexed together
    // with the specific filters first, then the specific
    // exception filters and finally the arbitrary
    // exception filters.
    // The first specific exception is the default
    // exception.  If an exception event occurs for
    // an exception without settings the default
    // exception settings are used.
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        __out PULONG SpecificEvents,
        __out PULONG SpecificExceptions,
        __out PULONG ArbitraryExceptions
        ) PURE;
    // Some filters have descriptive text associated with them.
    STDMETHOD(GetEventFilterText)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    // All filters support executing a command when the
    // event occurs.
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        __in ULONG Index,
        __in PCSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    // Some specific filters have arguments to further
    // qualify their operation.
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        __in ULONG Index,
        __in PCSTR Argument
        ) PURE;
    // If Codes is non-NULL Start is ignored.
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Codes,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // The codes in the parameter data control the application
    // of the parameter data.  If a code is not already in
    // the set of filters it is added.  If the ExecutionOption
    // for a code is REMOVE then the filter is removed.
    // Specific exception filters cannot be removed.
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount(Count) PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // Exception filters support an additional command for
    // second-chance events.
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        __in ULONG Index,
        __in PCSTR Command
        ) PURE;

    // Yields processing to the engine until
    // an event occurs.  This method may
    // only be called by the thread that started
    // the debug session.
    // When an event occurs the engine carries
    // out all event processing such as calling
    // callbacks.
    // If the callbacks indicate that execution should
    // break the wait will return, otherwise it
    // goes back to waiting for a new event.
    // If the timeout expires, S_FALSE is returned.
    // The timeout is not currently supported for
    // kernel debugging.
    STDMETHOD(WaitForEvent)(
        THIS_
        __in ULONG Flags,
        __in ULONG Timeout
        ) PURE;

    // Retrieves information about the last event that occurred.
    // EventType is one of the event callback mask bits.
    // ExtraInformation contains additional event-specific
    // information.  Not all events have additional information.
    STDMETHOD(GetLastEventInformation)(
        THIS_
        __out PULONG Type,
        __out PULONG ProcessId,
        __out PULONG ThreadId,
        __out_bcount_opt(ExtraInformationSize) PVOID ExtraInformation,
        __in ULONG ExtraInformationSize,
        __out_opt PULONG ExtraInformationUsed,
        __out_ecount_opt(DescriptionSize) PSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG DescriptionUsed
        ) PURE;

    // IDebugControl2.

    STDMETHOD(GetCurrentTimeDate)(
        THIS_
        __out PULONG TimeDate
        ) PURE;
    // Retrieves the number of seconds since the
    // machine started running.
    STDMETHOD(GetCurrentSystemUpTime)(
        THIS_
        __out PULONG UpTime
        ) PURE;

    // If the current session is a dump session,
    // retrieves any extended format information.
    STDMETHOD(GetDumpFormatFlags)(
        THIS_
        __out PULONG FormatFlags
        ) PURE;

    // The debugger has been enhanced to allow
    // arbitrary text replacements in addition
    // to the simple $u0-$u9 text macros.
    // Text replacement takes a given source
    // text in commands and converts it to the
    // given destination text.  Replacements
    // are named by their source text so that
    // only one replacement for a source text
    // string can exist.
    STDMETHOD(GetNumberTextReplacements)(
        THIS_
        __out PULONG NumRepl
        ) PURE;
    // If SrcText is non-NULL the replacement
    // is looked up by source text, otherwise
    // Index is used to get the Nth replacement.
    STDMETHOD(GetTextReplacement)(
        THIS_
        __in_opt PCSTR SrcText,
        __in ULONG Index,
        __out_ecount_opt(SrcBufferSize) PSTR SrcBuffer,
        __in ULONG SrcBufferSize,
        __out_opt PULONG SrcSize,
        __out_ecount_opt(DstBufferSize) PSTR DstBuffer,
        __in ULONG DstBufferSize,
        __out_opt PULONG DstSize
        ) PURE;
    // Setting the destination text to
    // NULL removes the alias.
    STDMETHOD(SetTextReplacement)(
        THIS_
        __in PCSTR SrcText,
        __in_opt PCSTR DstText
        ) PURE;
    STDMETHOD(RemoveTextReplacements)(
        THIS
        ) PURE;
    // Outputs the complete list of current
    // replacements.
    STDMETHOD(OutputTextReplacements)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;

    // IDebugControl3.

    // Control options for assembly and disassembly.
    STDMETHOD(GetAssemblyOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddAssemblyOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveAssemblyOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetAssemblyOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // Control the expression syntax.
    STDMETHOD(GetExpressionSyntax)(
        THIS_
        __out PULONG Flags
        ) PURE;
    STDMETHOD(SetExpressionSyntax)(
        THIS_
        __in ULONG Flags
        ) PURE;
    // Look up a syntax by its abbreviated
    // name and set it.
    STDMETHOD(SetExpressionSyntaxByName)(
        THIS_
        __in PCSTR AbbrevName
        ) PURE;
    STDMETHOD(GetNumberExpressionSyntaxes)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetExpressionSyntaxNames)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(FullNameBufferSize) PSTR FullNameBuffer,
        __in ULONG FullNameBufferSize,
        __out_opt PULONG FullNameSize,
        __out_ecount_opt(AbbrevNameBufferSize) PSTR AbbrevNameBuffer,
        __in ULONG AbbrevNameBufferSize,
        __out_opt PULONG AbbrevNameSize
        ) PURE;

    //
    // Some debug sessions have only a single
    // possible event, such as a snapshot dump
    // file; some have dynamic events, such as
    // a live debug session; and others may have
    // multiple events, such as a dump file that
    // contains snapshots from different points
    // in time.  The following methods allow
    // discovery and selection of the available
    // events for a session.
    // Sessions with one or more static events
    // will be able to report all of the events
    // when queried.  Sessions with dynamic events
    // will only report a single event representing
    // the current event.
    // Switching events constitutes execution and
    // changing the current event will alter the
    // execution status to a running state, after
    // which WaitForEvent must be used to process
    // the selected event.
    //

    // GetNumberEvents returns S_OK if this is the
    // complete set of events possible, such as for
    // a static session; or S_FALSE if other events
    // may be possible, such as for a dynamic session.
    STDMETHOD(GetNumberEvents)(
        THIS_
        __out PULONG Events
        ) PURE;
    // Sessions may have descriptive information for
    // the various events available.  The amount of
    // information varies according to the specific
    // session and data.
    STDMETHOD(GetEventIndexDescription)(
        THIS_
        __in ULONG Index,
        __in ULONG Which,
        __in_opt PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DescSize
        ) PURE;
    STDMETHOD(GetCurrentEventIndex)(
        THIS_
        __out PULONG Index
        ) PURE;
    // SetNextEventIndex works like seek in that
    // it can set an absolute or relative index.
    // SetNextEventIndex works similarly to SetExecutionStatus
    // by putting the session into a running state, after
    // which the caller must call WaitForEvent.  The
    // current event index only changes when WaitForEvent
    // is called.
    STDMETHOD(SetNextEventIndex)(
        THIS_
        __in ULONG Relation,
        __in ULONG Value,
        __out PULONG NextIndex
        ) PURE;

    // IDebugControl4.

    STDMETHOD(GetLogFileWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FileSize,
        __out PBOOL Append
        ) PURE;
    STDMETHOD(OpenLogFileWide)(
        THIS_
        __in PCWSTR File,
        __in BOOL Append
        ) PURE;

    STDMETHOD(InputWide)(
        THIS_
        __out PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InputSize
        ) PURE;
    STDMETHOD(ReturnInputWide)(
        THIS_
        __in PCWSTR Buffer
        ) PURE;

    STDMETHODV(OutputWide)(
        THIS_
        __in ULONG Mask,
        __in PCWSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaListWide)(
        THIS_
        __in ULONG Mask,
        __in PCWSTR Format,
        __in va_list Args
        ) PURE;
    STDMETHODV(ControlledOutputWide)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCWSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaListWide)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Mask,
        __in PCWSTR Format,
        __in va_list Args
        ) PURE;

    STDMETHODV(OutputPromptWide)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCWSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaListWide)(
        THIS_
        __in ULONG OutputControl,
        __in_opt PCWSTR Format,
        __in va_list Args
        ) PURE;
    STDMETHOD(GetPromptTextWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;

    STDMETHOD(AssembleWide)(
        THIS_
        __in ULONG64 Offset,
        __in PCWSTR Instr,
        __out PULONG64 EndOffset
        ) PURE;
    STDMETHOD(DisassembleWide)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DisassemblySize,
        __out PULONG64 EndOffset
        ) PURE;

    STDMETHOD(GetProcessorTypeNamesWide)(
        THIS_
        __in ULONG Type,
        __out_ecount_opt(FullNameBufferSize) PWSTR FullNameBuffer,
        __in ULONG FullNameBufferSize,
        __out_opt PULONG FullNameSize,
        __out_ecount_opt(AbbrevNameBufferSize) PWSTR AbbrevNameBuffer,
        __in ULONG AbbrevNameBufferSize,
        __out_opt PULONG AbbrevNameSize
        ) PURE;

    STDMETHOD(GetTextMacroWide)(
        THIS_
        __in ULONG Slot,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacroWide)(
        THIS_
        __in ULONG Slot,
        __in PCWSTR Macro
        ) PURE;

    STDMETHOD(EvaluateWide)(
        THIS_
        __in PCWSTR Expression,
        __in ULONG DesiredType,
        __out PDEBUG_VALUE Value,
        __out_opt PULONG RemainderIndex
        ) PURE;

    STDMETHOD(ExecuteWide)(
        THIS_
        __in ULONG OutputControl,
        __in PCWSTR Command,
        __in ULONG Flags
        ) PURE;
    STDMETHOD(ExecuteCommandFileWide)(
        THIS_
        __in ULONG OutputControl,
        __in PCWSTR CommandFile,
        __in ULONG Flags
        ) PURE;

    STDMETHOD(GetBreakpointByIndex2)(
        THIS_
        __in ULONG Index,
        __out PDEBUG_BREAKPOINT2* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById2)(
        THIS_
        __in ULONG Id,
        __out PDEBUG_BREAKPOINT2* Bp
        ) PURE;
    STDMETHOD(AddBreakpoint2)(
        THIS_
        __in ULONG Type,
        __in ULONG DesiredId,
        __out PDEBUG_BREAKPOINT2* Bp
        ) PURE;
    STDMETHOD(RemoveBreakpoint2)(
        THIS_
        __in PDEBUG_BREAKPOINT2 Bp
        ) PURE;

    STDMETHOD(AddExtensionWide)(
        THIS_
        __in PCWSTR Path,
        __in ULONG Flags,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPathWide)(
        THIS_
        __in PCWSTR Path,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(CallExtensionWide)(
        THIS_
        __in ULONG64 Handle,
        __in PCWSTR Function,
        __in_opt PCWSTR Arguments
        ) PURE;
    STDMETHOD(GetExtensionFunctionWide)(
        THIS_
        __in ULONG64 Handle,
        __in PCWSTR FuncName,
        __out FARPROC* Function
        ) PURE;

    STDMETHOD(GetEventFilterTextWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TextSize
        ) PURE;
    STDMETHOD(GetEventFilterCommandWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommandWide)(
        THIS_
        __in ULONG Index,
        __in PCWSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterArgumentWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgumentWide)(
        THIS_
        __in ULONG Index,
        __in PCWSTR Argument
        ) PURE;
    STDMETHOD(GetExceptionFilterSecondCommandWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommandWide)(
        THIS_
        __in ULONG Index,
        __in PCWSTR Command
        ) PURE;

    STDMETHOD(GetLastEventInformationWide)(
        THIS_
        __out PULONG Type,
        __out PULONG ProcessId,
        __out PULONG ThreadId,
        __out_bcount_opt(ExtraInformationSize) PVOID ExtraInformation,
        __in ULONG ExtraInformationSize,
        __out_opt PULONG ExtraInformationUsed,
        __out_ecount_opt(DescriptionSize) PWSTR Description,
        __in ULONG DescriptionSize,
        __out_opt PULONG DescriptionUsed
        ) PURE;

    STDMETHOD(GetTextReplacementWide)(
        THIS_
        __in_opt PCWSTR SrcText,
        __in ULONG Index,
        __out_ecount_opt(SrcBufferSize) PWSTR SrcBuffer,
        __in ULONG SrcBufferSize,
        __out_opt PULONG SrcSize,
        __out_ecount_opt(DstBufferSize) PWSTR DstBuffer,
        __in ULONG DstBufferSize,
        __out_opt PULONG DstSize
        ) PURE;
    STDMETHOD(SetTextReplacementWide)(
        THIS_
        __in PCWSTR SrcText,
        __in_opt PCWSTR DstText
        ) PURE;

    STDMETHOD(SetExpressionSyntaxByNameWide)(
        THIS_
        __in PCWSTR AbbrevName
        ) PURE;
    STDMETHOD(GetExpressionSyntaxNamesWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(FullNameBufferSize) PWSTR FullNameBuffer,
        __in ULONG FullNameBufferSize,
        __out_opt PULONG FullNameSize,
        __out_ecount_opt(AbbrevNameBufferSize) PWSTR AbbrevNameBuffer,
        __in ULONG AbbrevNameBufferSize,
        __out_opt PULONG AbbrevNameSize
        ) PURE;

    STDMETHOD(GetEventIndexDescriptionWide)(
        THIS_
        __in ULONG Index,
        __in ULONG Which,
        __in_opt PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DescSize
        ) PURE;

    STDMETHOD(GetLogFile2)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FileSize,
        __out PULONG Flags
        ) PURE;
    STDMETHOD(OpenLogFile2)(
        THIS_
        __in PCSTR File,
        __in ULONG Flags
        ) PURE;
    STDMETHOD(GetLogFile2Wide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FileSize,
        __out PULONG Flags
        ) PURE;
    STDMETHOD(OpenLogFile2Wide)(
        THIS_
        __in PCWSTR File,
        __in ULONG Flags
        ) PURE;

    // GetSystemVersion always returns the kd
    // major/minor version numbers, which are
    // different than the Win32 version numbers.
    // GetSystemVersionValues can be used
    // to determine the Win32 version values.
    STDMETHOD(GetSystemVersionValues)(
        THIS_
        __out PULONG PlatformId,
        __out PULONG Win32Major,
        __out PULONG Win32Minor,
        __out_opt PULONG KdMajor,
        __out_opt PULONG KdMinor
        ) PURE;
    // Strings are selected with DEBUG_SYSVERSTR_*.
    STDMETHOD(GetSystemVersionString)(
        THIS_
        __in ULONG Which,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringSize
        ) PURE;
    STDMETHOD(GetSystemVersionStringWide)(
        THIS_
        __in ULONG Which,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringSize
        ) PURE;

    // Stack tracing with a full initial context
    // and full context return for each frame.
    // The FrameContextsSize parameter is the total
    // byte size of FrameContexts.  FrameContextsEntrySize
    // gives the byte size of each entry in
    // FrameContexts.
    STDMETHOD(GetContextStackTrace)(
        THIS_
        __in_bcount_opt(StartContextSize) PVOID StartContext,
        __in ULONG StartContextSize,
        __out_ecount_opt(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __out_bcount_opt(FrameContextsSize) PVOID FrameContexts,
        __in ULONG FrameContextsSize,
        __in ULONG FrameContextsEntrySize,
        __out_opt PULONG FramesFilled
        ) PURE;
    STDMETHOD(OutputContextStackTrace)(
        THIS_
        __in ULONG OutputControl,
        __in_ecount(FramesSize) PDEBUG_STACK_FRAME Frames,
        __in ULONG FramesSize,
        __in_bcount(FrameContextsSize) PVOID FrameContexts,
        __in ULONG FrameContextsSize,
        __in ULONG FrameContextsEntrySize,
        __in ULONG Flags
        ) PURE;

    // Some targets, such as user-mode minidump files,
    // have separate "event of interest" information
    // stored within them.  This method allows
    // access to that information.
    STDMETHOD(GetStoredEventInformation)(
        THIS_
        __out PULONG Type,
        __out PULONG ProcessId,
        __out PULONG ThreadId,
        __out_bcount_opt(ContextSize) PVOID Context,
        __in ULONG ContextSize,
        __out_opt PULONG ContextUsed,
        __out_bcount_opt(ExtraInformationSize) PVOID ExtraInformation,
        __in ULONG ExtraInformationSize,
        __out_opt PULONG ExtraInformationUsed
        ) PURE;

    // Managed debugging support relies on debugging
    // functionality provided by the Common Language Runtime.
    // This method provides feedback on the engine's
    // use of the runtime debugging APIs.
    STDMETHOD(GetManagedStatus)(
        THIS_
        __out_opt PULONG Flags,
        __in ULONG WhichString,
        __out_ecount_opt(StringSize) PSTR String,
        __in ULONG StringSize,
        __out_opt PULONG StringNeeded
        ) PURE;
    STDMETHOD(GetManagedStatusWide)(
        THIS_
        __out_opt PULONG Flags,
        __in ULONG WhichString,
        __out_ecount_opt(StringSize) PWSTR String,
        __in ULONG StringSize,
        __out_opt PULONG StringNeeded
        ) PURE;
    // Clears and reinitializes the engine's
    // managed code debugging support.
    STDMETHOD(ResetManagedStatus)(
        THIS_
        __in ULONG Flags
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugDataSpaces.
//
//----------------------------------------------------------------------------

// Data space indices for callbacks and other methods.
#define DEBUG_DATA_SPACE_VIRTUAL       0
#define DEBUG_DATA_SPACE_PHYSICAL      1
#define DEBUG_DATA_SPACE_CONTROL       2
#define DEBUG_DATA_SPACE_IO            3
#define DEBUG_DATA_SPACE_MSR           4
#define DEBUG_DATA_SPACE_BUS_DATA      5
#define DEBUG_DATA_SPACE_DEBUGGER_DATA 6
// Count of data spaces.
#define DEBUG_DATA_SPACE_COUNT         7

// Indices for ReadDebuggerData interface
#define DEBUG_DATA_KernBase                              24
#define DEBUG_DATA_BreakpointWithStatusAddr              32
#define DEBUG_DATA_SavedContextAddr                      40
#define DEBUG_DATA_KiCallUserModeAddr                    56
#define DEBUG_DATA_KeUserCallbackDispatcherAddr          64
#define DEBUG_DATA_PsLoadedModuleListAddr                72
#define DEBUG_DATA_PsActiveProcessHeadAddr               80
#define DEBUG_DATA_PspCidTableAddr                       88
#define DEBUG_DATA_ExpSystemResourcesListAddr            96
#define DEBUG_DATA_ExpPagedPoolDescriptorAddr           104
#define DEBUG_DATA_ExpNumberOfPagedPoolsAddr            112
#define DEBUG_DATA_KeTimeIncrementAddr                  120
#define DEBUG_DATA_KeBugCheckCallbackListHeadAddr       128
#define DEBUG_DATA_KiBugcheckDataAddr                   136
#define DEBUG_DATA_IopErrorLogListHeadAddr              144
#define DEBUG_DATA_ObpRootDirectoryObjectAddr           152
#define DEBUG_DATA_ObpTypeObjectTypeAddr                160
#define DEBUG_DATA_MmSystemCacheStartAddr               168
#define DEBUG_DATA_MmSystemCacheEndAddr                 176
#define DEBUG_DATA_MmSystemCacheWsAddr                  184
#define DEBUG_DATA_MmPfnDatabaseAddr                    192
#define DEBUG_DATA_MmSystemPtesStartAddr                200
#define DEBUG_DATA_MmSystemPtesEndAddr                  208
#define DEBUG_DATA_MmSubsectionBaseAddr                 216
#define DEBUG_DATA_MmNumberOfPagingFilesAddr            224
#define DEBUG_DATA_MmLowestPhysicalPageAddr             232
#define DEBUG_DATA_MmHighestPhysicalPageAddr            240
#define DEBUG_DATA_MmNumberOfPhysicalPagesAddr          248
#define DEBUG_DATA_MmMaximumNonPagedPoolInBytesAddr     256
#define DEBUG_DATA_MmNonPagedSystemStartAddr            264
#define DEBUG_DATA_MmNonPagedPoolStartAddr              272
#define DEBUG_DATA_MmNonPagedPoolEndAddr                280
#define DEBUG_DATA_MmPagedPoolStartAddr                 288
#define DEBUG_DATA_MmPagedPoolEndAddr                   296
#define DEBUG_DATA_MmPagedPoolInformationAddr           304
#define DEBUG_DATA_MmPageSize                           312
#define DEBUG_DATA_MmSizeOfPagedPoolInBytesAddr         320
#define DEBUG_DATA_MmTotalCommitLimitAddr               328
#define DEBUG_DATA_MmTotalCommittedPagesAddr            336
#define DEBUG_DATA_MmSharedCommitAddr                   344
#define DEBUG_DATA_MmDriverCommitAddr                   352
#define DEBUG_DATA_MmProcessCommitAddr                  360
#define DEBUG_DATA_MmPagedPoolCommitAddr                368
#define DEBUG_DATA_MmExtendedCommitAddr                 376
#define DEBUG_DATA_MmZeroedPageListHeadAddr             384
#define DEBUG_DATA_MmFreePageListHeadAddr               392
#define DEBUG_DATA_MmStandbyPageListHeadAddr            400
#define DEBUG_DATA_MmModifiedPageListHeadAddr           408
#define DEBUG_DATA_MmModifiedNoWritePageListHeadAddr    416
#define DEBUG_DATA_MmAvailablePagesAddr                 424
#define DEBUG_DATA_MmResidentAvailablePagesAddr         432
#define DEBUG_DATA_PoolTrackTableAddr                   440
#define DEBUG_DATA_NonPagedPoolDescriptorAddr           448
#define DEBUG_DATA_MmHighestUserAddressAddr             456
#define DEBUG_DATA_MmSystemRangeStartAddr               464
#define DEBUG_DATA_MmUserProbeAddressAddr               472
#define DEBUG_DATA_KdPrintCircularBufferAddr            480
#define DEBUG_DATA_KdPrintCircularBufferEndAddr         488
#define DEBUG_DATA_KdPrintWritePointerAddr              496
#define DEBUG_DATA_KdPrintRolloverCountAddr             504
#define DEBUG_DATA_MmLoadedUserImageListAddr            512
#define DEBUG_DATA_NtBuildLabAddr                       520
#define DEBUG_DATA_KiNormalSystemCall                   528
#define DEBUG_DATA_KiProcessorBlockAddr                 536
#define DEBUG_DATA_MmUnloadedDriversAddr                544
#define DEBUG_DATA_MmLastUnloadedDriverAddr             552
#define DEBUG_DATA_MmTriageActionTakenAddr              560
#define DEBUG_DATA_MmSpecialPoolTagAddr                 568
#define DEBUG_DATA_KernelVerifierAddr                   576
#define DEBUG_DATA_MmVerifierDataAddr                   584
#define DEBUG_DATA_MmAllocatedNonPagedPoolAddr          592
#define DEBUG_DATA_MmPeakCommitmentAddr                 600
#define DEBUG_DATA_MmTotalCommitLimitMaximumAddr        608
#define DEBUG_DATA_CmNtCSDVersionAddr                   616
#define DEBUG_DATA_MmPhysicalMemoryBlockAddr            624
#define DEBUG_DATA_MmSessionBase                        632
#define DEBUG_DATA_MmSessionSize                        640
#define DEBUG_DATA_MmSystemParentTablePage              648
#define DEBUG_DATA_MmVirtualTranslationBase             656
#define DEBUG_DATA_OffsetKThreadNextProcessor           664
#define DEBUG_DATA_OffsetKThreadTeb                     666
#define DEBUG_DATA_OffsetKThreadKernelStack             668
#define DEBUG_DATA_OffsetKThreadInitialStack            670
#define DEBUG_DATA_OffsetKThreadApcProcess              672
#define DEBUG_DATA_OffsetKThreadState                   674
#define DEBUG_DATA_OffsetKThreadBStore                  676
#define DEBUG_DATA_OffsetKThreadBStoreLimit             678
#define DEBUG_DATA_SizeEProcess                         680
#define DEBUG_DATA_OffsetEprocessPeb                    682
#define DEBUG_DATA_OffsetEprocessParentCID              684
#define DEBUG_DATA_OffsetEprocessDirectoryTableBase     686
#define DEBUG_DATA_SizePrcb                             688
#define DEBUG_DATA_OffsetPrcbDpcRoutine                 690
#define DEBUG_DATA_OffsetPrcbCurrentThread              692
#define DEBUG_DATA_OffsetPrcbMhz                        694
#define DEBUG_DATA_OffsetPrcbCpuType                    696
#define DEBUG_DATA_OffsetPrcbVendorString               698
#define DEBUG_DATA_OffsetPrcbProcessorState             700
#define DEBUG_DATA_OffsetPrcbNumber                     702
#define DEBUG_DATA_SizeEThread                          704
#define DEBUG_DATA_KdPrintCircularBufferPtrAddr         712
#define DEBUG_DATA_KdPrintBufferSizeAddr             720
#define DEBUG_DATA_MmBadPagesDetected             800

#define DEBUG_DATA_PaeEnabled                        100000
#define DEBUG_DATA_SharedUserData                    100008
#define DEBUG_DATA_ProductType                       100016
#define DEBUG_DATA_SuiteMask                         100024
#define DEBUG_DATA_DumpWriterStatus                  100032
#define DEBUG_DATA_DumpFormatVersion                 100040
#define DEBUG_DATA_DumpWriterVersion                 100048
#define DEBUG_DATA_DumpPowerState                    100056
#define DEBUG_DATA_DumpMmStorage                     100064

//
// Processor information structures.
//

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_ALPHA
{
    ULONG Type;
    ULONG Revision;
} DEBUG_PROCESSOR_IDENTIFICATION_ALPHA, *PDEBUG_PROCESSOR_IDENTIFICATION_ALPHA;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_AMD64
{
    ULONG Family;
    ULONG Model;
    ULONG Stepping;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_AMD64, *PDEBUG_PROCESSOR_IDENTIFICATION_AMD64;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_IA64
{
    ULONG Model;
    ULONG Revision;
    ULONG Family;
    ULONG ArchRev;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_IA64, *PDEBUG_PROCESSOR_IDENTIFICATION_IA64;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_X86
{
    ULONG Family;
    ULONG Model;
    ULONG Stepping;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_X86, *PDEBUG_PROCESSOR_IDENTIFICATION_X86;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_ARM
{
    ULONG Type;
    ULONG Revision;
} DEBUG_PROCESSOR_IDENTIFICATION_ARM, *PDEBUG_PROCESSOR_IDENTIFICATION_ARM;

typedef union _DEBUG_PROCESSOR_IDENTIFICATION_ALL
{
    DEBUG_PROCESSOR_IDENTIFICATION_ALPHA Alpha;
    DEBUG_PROCESSOR_IDENTIFICATION_AMD64 Amd64;
    DEBUG_PROCESSOR_IDENTIFICATION_IA64  Ia64;
    DEBUG_PROCESSOR_IDENTIFICATION_X86   X86;
    DEBUG_PROCESSOR_IDENTIFICATION_ARM   Arm;
} DEBUG_PROCESSOR_IDENTIFICATION_ALL, *PDEBUG_PROCESSOR_IDENTIFICATION_ALL;

// Indices for ReadProcessorSystemData.
#define DEBUG_DATA_KPCR_OFFSET                          0
#define DEBUG_DATA_KPRCB_OFFSET                         1
#define DEBUG_DATA_KTHREAD_OFFSET                       2
#define DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET      3
#define DEBUG_DATA_PROCESSOR_IDENTIFICATION             4
#define DEBUG_DATA_PROCESSOR_SPEED                      5

#undef INTERFACE
#define INTERFACE IDebugDataSpaces
DECLARE_INTERFACE_(IDebugDataSpaces, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugDataSpaces.
    STDMETHOD(ReadVirtual)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    // SearchVirtual searches the given virtual
    // address range for the given pattern.  PatternSize
    // gives the byte length of the pattern and PatternGranularity
    // controls the granularity of comparisons during
    // the search.
    // For example, a DWORD-granular search would
    // use a pattern granularity of four to search by DWORD
    // increments.
    STDMETHOD(SearchVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Length,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __in ULONG PatternGranularity,
        __out PULONG64 MatchOffset
        ) PURE;
    // These methods are identical to Read/WriteVirtual
    // except that they avoid the kernel virtual memory
    // cache entirely and are therefore useful for reading
    // virtual memory which is inherently volatile, such
    // as memory-mapped device areas, without contaminating
    // or invalidating the cache.
    // In user-mode they are the same as Read/WriteVirtual.
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    // The following two methods are convenience
    // methods for accessing pointer values.
    // They automatically convert between native pointers
    // and canonical 64-bit values as necessary.
    // These routines stop at the first failure.
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        __in ULONG Count,
        __in ULONG64 Offset,
        __out_ecount(Count) PULONG64 Ptrs
        ) PURE;
    STDMETHOD(WritePointersVirtual)(
        THIS_
        __in ULONG Count,
        __in ULONG64 Offset,
        __in_ecount(Count) PULONG64 Ptrs
        ) PURE;
    // All non-virtual data spaces are only
    // available when kernel debugging.
    STDMETHOD(ReadPhysical)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadControl)(
        THIS_
        __in ULONG Processor,
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteControl)(
        THIS_
        __in ULONG Processor,
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadIo)(
        THIS_
        __in ULONG InterfaceType,
        __in ULONG BusNumber,
        __in ULONG AddressSpace,
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteIo)(
        THIS_
        __in ULONG InterfaceType,
        __in ULONG BusNumber,
        __in ULONG AddressSpace,
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadMsr)(
        THIS_
        __in ULONG Msr,
        __out PULONG64 Value
        ) PURE;
    STDMETHOD(WriteMsr)(
        THIS_
        __in ULONG Msr,
        __in ULONG64 Value
        ) PURE;
    STDMETHOD(ReadBusData)(
        THIS_
        __in ULONG BusDataType,
        __in ULONG BusNumber,
        __in ULONG SlotNumber,
        __in ULONG Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteBusData)(
        THIS_
        __in ULONG BusDataType,
        __in ULONG BusNumber,
        __in ULONG SlotNumber,
        __in ULONG Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(CheckLowMemory)(
        THIS
        ) PURE;
    STDMETHOD(ReadDebuggerData)(
        THIS_
        __in ULONG Index,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        __in ULONG Processor,
        __in ULONG Index,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;
};

//
// Handle data types and structures.
//

#define DEBUG_HANDLE_DATA_TYPE_BASIC                 0
#define DEBUG_HANDLE_DATA_TYPE_TYPE_NAME             1
#define DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME           2
#define DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT          3
#define DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE        4
#define DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE      5
#define DEBUG_HANDLE_DATA_TYPE_MINI_THREAD_1         6
#define DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_1         7
#define DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_2         8
#define DEBUG_HANDLE_DATA_TYPE_PER_HANDLE_OPERATIONS 9
#define DEBUG_HANDLE_DATA_TYPE_ALL_HANDLE_OPERATIONS 10
#define DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_1        11
#define DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_2        12

typedef struct _DEBUG_HANDLE_DATA_BASIC
{
    ULONG TypeNameSize;
    ULONG ObjectNameSize;
    ULONG Attributes;
    ULONG GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
} DEBUG_HANDLE_DATA_BASIC, *PDEBUG_HANDLE_DATA_BASIC;

#undef INTERFACE
#define INTERFACE IDebugDataSpaces2
DECLARE_INTERFACE_(IDebugDataSpaces2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugDataSpaces.
    STDMETHOD(ReadVirtual)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    // SearchVirtual searches the given virtual
    // address range for the given pattern.  PatternSize
    // gives the byte length of the pattern and PatternGranularity
    // controls the granularity of comparisons during
    // the search.
    // For example, a DWORD-granular search would
    // use a pattern granularity of four to search by DWORD
    // increments.
    STDMETHOD(SearchVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Length,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __in ULONG PatternGranularity,
        __out PULONG64 MatchOffset
        ) PURE;
    // These methods are identical to Read/WriteVirtual
    // except that they avoid the kernel virtual memory
    // cache entirely and are therefore useful for reading
    // virtual memory which is inherently volatile, such
    // as memory-mapped device areas, without contaminating
    // or invalidating the cache.
    // In user-mode they are the same as Read/WriteVirtual.
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    // The following two methods are convenience
    // methods for accessing pointer values.
    // They automatically convert between native pointers
    // and canonical 64-bit values as necessary.
    // These routines stop at the first failure.
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        __in ULONG Count,
        __in ULONG64 Offset,
        __out_ecount(Count) PULONG64 Ptrs
        ) PURE;
    STDMETHOD(WritePointersVirtual)(
        THIS_
        __in ULONG Count,
        __in ULONG64 Offset,
        __in_ecount(Count) PULONG64 Ptrs
        ) PURE;
    // All non-virtual data spaces are only
    // available when kernel debugging.
    STDMETHOD(ReadPhysical)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadControl)(
        THIS_
        __in ULONG Processor,
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteControl)(
        THIS_
        __in ULONG Processor,
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadIo)(
        THIS_
        __in ULONG InterfaceType,
        __in ULONG BusNumber,
        __in ULONG AddressSpace,
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteIo)(
        THIS_
        __in ULONG InterfaceType,
        __in ULONG BusNumber,
        __in ULONG AddressSpace,
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadMsr)(
        THIS_
        __in ULONG Msr,
        __out PULONG64 Value
        ) PURE;
    STDMETHOD(WriteMsr)(
        THIS_
        __in ULONG Msr,
        __in ULONG64 Value
        ) PURE;
    STDMETHOD(ReadBusData)(
        THIS_
        __in ULONG BusDataType,
        __in ULONG BusNumber,
        __in ULONG SlotNumber,
        __in ULONG Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteBusData)(
        THIS_
        __in ULONG BusDataType,
        __in ULONG BusNumber,
        __in ULONG SlotNumber,
        __in ULONG Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(CheckLowMemory)(
        THIS
        ) PURE;
    STDMETHOD(ReadDebuggerData)(
        THIS_
        __in ULONG Index,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        __in ULONG Processor,
        __in ULONG Index,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;

    // IDebugDataSpaces2.

    STDMETHOD(VirtualToPhysical)(
        THIS_
        __in ULONG64 Virtual,
        __out PULONG64 Physical
        ) PURE;
    // Returns the physical addresses for the
    // N levels of the systems paging structures.
    // Level zero is the starting base physical
    // address for virtual translations.
    // Levels one-(N-1) will point to the appropriate
    // paging descriptor for the virtual address at
    // the given level of the paging hierarchy.  The
    // exact number of levels depends on many factors.
    // The last level will be the fully translated
    // physical address, matching what VirtualToPhysical
    // returns.  If the address can only be partially
    // translated S_FALSE is returned.
    STDMETHOD(GetVirtualTranslationPhysicalOffsets)(
        THIS_
        __in ULONG64 Virtual,
        __out_ecount_opt(OffsetsSize) PULONG64 Offsets,
        __in ULONG OffsetsSize,
        __out_opt PULONG Levels
        ) PURE;

    // System handle data is accessible in certain
    // debug sessions.  The particular data available
    // varies from session to session and platform
    // to platform.
    STDMETHOD(ReadHandleData)(
        THIS_
        __in ULONG64 Handle,
        __in ULONG DataType,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;

    // Fills memory with the given pattern.
    // The fill stops at the first non-writable byte.
    STDMETHOD(FillVirtual)(
        THIS_
        __in ULONG64 Start,
        __in ULONG Size,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __out_opt PULONG Filled
        ) PURE;
    STDMETHOD(FillPhysical)(
        THIS_
        __in ULONG64 Start,
        __in ULONG Size,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __out_opt PULONG Filled
        ) PURE;

    // Queries virtual memory mapping information given
    // an address similarly to the Win32 API VirtualQuery.
    // MEMORY_BASIC_INFORMATION64 is defined in crash.h.
    // This method currently only works for user-mode sessions.
    STDMETHOD(QueryVirtual)(
        THIS_
        __in ULONG64 Offset,
        __out PMEMORY_BASIC_INFORMATION64 Info
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugDataSpaces3
DECLARE_INTERFACE_(IDebugDataSpaces3, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugDataSpaces.
    STDMETHOD(ReadVirtual)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    // SearchVirtual searches the given virtual
    // address range for the given pattern.  PatternSize
    // gives the byte length of the pattern and PatternGranularity
    // controls the granularity of comparisons during
    // the search.
    // For example, a DWORD-granular search would
    // use a pattern granularity of four to search by DWORD
    // increments.
    STDMETHOD(SearchVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Length,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __in ULONG PatternGranularity,
        __out PULONG64 MatchOffset
        ) PURE;
    // These methods are identical to Read/WriteVirtual
    // except that they avoid the kernel virtual memory
    // cache entirely and are therefore useful for reading
    // virtual memory which is inherently volatile, such
    // as memory-mapped device areas, without contaminating
    // or invalidating the cache.
    // In user-mode they are the same as Read/WriteVirtual.
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    // The following two methods are convenience
    // methods for accessing pointer values.
    // They automatically convert between native pointers
    // and canonical 64-bit values as necessary.
    // These routines stop at the first failure.
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        __in ULONG Count,
        __in ULONG64 Offset,
        __out_ecount(Count) PULONG64 Ptrs
        ) PURE;
    STDMETHOD(WritePointersVirtual)(
        THIS_
        __in ULONG Count,
        __in ULONG64 Offset,
        __in_ecount(Count) PULONG64 Ptrs
        ) PURE;
    // All non-virtual data spaces are only
    // available when kernel debugging.
    STDMETHOD(ReadPhysical)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadControl)(
        THIS_
        __in ULONG Processor,
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteControl)(
        THIS_
        __in ULONG Processor,
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadIo)(
        THIS_
        __in ULONG InterfaceType,
        __in ULONG BusNumber,
        __in ULONG AddressSpace,
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteIo)(
        THIS_
        __in ULONG InterfaceType,
        __in ULONG BusNumber,
        __in ULONG AddressSpace,
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadMsr)(
        THIS_
        __in ULONG Msr,
        __out PULONG64 Value
        ) PURE;
    STDMETHOD(WriteMsr)(
        THIS_
        __in ULONG Msr,
        __in ULONG64 Value
        ) PURE;
    STDMETHOD(ReadBusData)(
        THIS_
        __in ULONG BusDataType,
        __in ULONG BusNumber,
        __in ULONG SlotNumber,
        __in ULONG Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteBusData)(
        THIS_
        __in ULONG BusDataType,
        __in ULONG BusNumber,
        __in ULONG SlotNumber,
        __in ULONG Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(CheckLowMemory)(
        THIS
        ) PURE;
    STDMETHOD(ReadDebuggerData)(
        THIS_
        __in ULONG Index,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        __in ULONG Processor,
        __in ULONG Index,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;

    // IDebugDataSpaces2.

    STDMETHOD(VirtualToPhysical)(
        THIS_
        __in ULONG64 Virtual,
        __out PULONG64 Physical
        ) PURE;
    // Returns the physical addresses for the
    // N levels of the systems paging structures.
    // Level zero is the starting base physical
    // address for virtual translations.
    // Levels one-(N-1) will point to the appropriate
    // paging descriptor for the virtual address at
    // the given level of the paging hierarchy.  The
    // exact number of levels depends on many factors.
    // The last level will be the fully translated
    // physical address, matching what VirtualToPhysical
    // returns.  If the address can only be partially
    // translated S_FALSE is returned.
    STDMETHOD(GetVirtualTranslationPhysicalOffsets)(
        THIS_
        __in ULONG64 Virtual,
        __out_ecount_opt(OffsetsSize) PULONG64 Offsets,
        __in ULONG OffsetsSize,
        __out_opt PULONG Levels
        ) PURE;

    // System handle data is accessible in certain
    // debug sessions.  The particular data available
    // varies from session to session and platform
    // to platform.
    STDMETHOD(ReadHandleData)(
        THIS_
        __in ULONG64 Handle,
        __in ULONG DataType,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;

    // Fills memory with the given pattern.
    // The fill stops at the first non-writable byte.
    STDMETHOD(FillVirtual)(
        THIS_
        __in ULONG64 Start,
        __in ULONG Size,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __out_opt PULONG Filled
        ) PURE;
    STDMETHOD(FillPhysical)(
        THIS_
        __in ULONG64 Start,
        __in ULONG Size,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __out_opt PULONG Filled
        ) PURE;

    // Queries virtual memory mapping information given
    // an address similarly to the Win32 API VirtualQuery.
    // MEMORY_BASIC_INFORMATION64 is defined in crash.h.
    // This method currently only works for user-mode sessions.
    STDMETHOD(QueryVirtual)(
        THIS_
        __in ULONG64 Offset,
        __out PMEMORY_BASIC_INFORMATION64 Info
        ) PURE;

    // IDebugDataSpaces3.

    // Convenience method for reading an image
    // header from virtual memory.  Given the
    // image base, this method determines where
    // the NT headers are, validates the necessary
    // markers and converts the headers into
    // 64-bit form for consistency.
    // A caller can check whether the headers were
    // originally 32-bit by checking the optional
    // header magic value.
    // This method will not read ROM headers.
    STDMETHOD(ReadImageNtHeaders)(
        THIS_
        __in ULONG64 ImageBase,
        __out PIMAGE_NT_HEADERS64 Headers
        ) PURE;

    // Some debug sessions have arbitrary additional
    // data available.  For example, additional dump
    // information files may contain extra information
    // gathered at the same time as the primary dump.
    // Such information is tagged with a unique identifier
    // and can only be retrieved via the tag.
    // Tagged data cannot be partially available; the
    // tagged block is either fully present or completely
    // absent.
    STDMETHOD(ReadTagged)(
        THIS_
        __in LPGUID Tag,
        __in ULONG Offset,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TotalSize
        ) PURE;
    STDMETHOD(StartEnumTagged)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(GetNextTagged)(
        THIS_
        __in ULONG64 Handle,
        __out LPGUID Tag,
        __out PULONG Size
        ) PURE;
    STDMETHOD(EndEnumTagged)(
        THIS_
        __in ULONG64 Handle
        ) PURE;
};

#define DEBUG_OFFSINFO_VIRTUAL_SOURCE 0x00000001

#define DEBUG_VSOURCE_INVALID      0x00000000
#define DEBUG_VSOURCE_DEBUGGEE     0x00000001
#define DEBUG_VSOURCE_MAPPED_IMAGE 0x00000002

#define DEBUG_VSEARCH_DEFAULT       0x00000000
#define DEBUG_VSEARCH_WRITABLE_ONLY 0x00000001

#define DEBUG_PHYSICAL_DEFAULT        0x00000000
#define DEBUG_PHYSICAL_CACHED         0x00000001
#define DEBUG_PHYSICAL_UNCACHED       0x00000002
#define DEBUG_PHYSICAL_WRITE_COMBINED 0x00000003

#undef INTERFACE
#define INTERFACE IDebugDataSpaces4
DECLARE_INTERFACE_(IDebugDataSpaces4, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugDataSpaces.

    STDMETHOD(ReadVirtual)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    // SearchVirtual searches the given virtual
    // address range for the given pattern.  PatternSize
    // gives the byte length of the pattern and PatternGranularity
    // controls the granularity of comparisons during
    // the search.
    // For example, a DWORD-granular search would
    // use a pattern granularity of four to search by DWORD
    // increments.
    STDMETHOD(SearchVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Length,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __in ULONG PatternGranularity,
        __out PULONG64 MatchOffset
        ) PURE;
    // These methods are identical to Read/WriteVirtual
    // except that they avoid the kernel virtual memory
    // cache entirely and are therefore useful for reading
    // virtual memory which is inherently volatile, such
    // as memory-mapped device areas, without contaminating
    // or invalidating the cache.
    // In user-mode they are the same as Read/WriteVirtual.
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    // The following two methods are convenience
    // methods for accessing pointer values.
    // They automatically convert between native pointers
    // and canonical 64-bit values as necessary.
    // These routines stop at the first failure.
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        __in ULONG Count,
        __in ULONG64 Offset,
        __out_ecount(Count) PULONG64 Ptrs
        ) PURE;
    STDMETHOD(WritePointersVirtual)(
        THIS_
        __in ULONG Count,
        __in ULONG64 Offset,
        __in_ecount(Count) PULONG64 Ptrs
        ) PURE;
    // All non-virtual data spaces are only
    // available when kernel debugging.
    STDMETHOD(ReadPhysical)(
        THIS_
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical)(
        THIS_
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadControl)(
        THIS_
        __in ULONG Processor,
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteControl)(
        THIS_
        __in ULONG Processor,
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadIo)(
        THIS_
        __in ULONG InterfaceType,
        __in ULONG BusNumber,
        __in ULONG AddressSpace,
        __in ULONG64 Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteIo)(
        THIS_
        __in ULONG InterfaceType,
        __in ULONG BusNumber,
        __in ULONG AddressSpace,
        __in ULONG64 Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadMsr)(
        THIS_
        __in ULONG Msr,
        __out PULONG64 Value
        ) PURE;
    STDMETHOD(WriteMsr)(
        THIS_
        __in ULONG Msr,
        __in ULONG64 Value
        ) PURE;
    STDMETHOD(ReadBusData)(
        THIS_
        __in ULONG BusDataType,
        __in ULONG BusNumber,
        __in ULONG SlotNumber,
        __in ULONG Offset,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteBusData)(
        THIS_
        __in ULONG BusDataType,
        __in ULONG BusNumber,
        __in ULONG SlotNumber,
        __in ULONG Offset,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(CheckLowMemory)(
        THIS
        ) PURE;
    STDMETHOD(ReadDebuggerData)(
        THIS_
        __in ULONG Index,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        __in ULONG Processor,
        __in ULONG Index,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;

    // IDebugDataSpaces2.

    STDMETHOD(VirtualToPhysical)(
        THIS_
        __in ULONG64 Virtual,
        __out PULONG64 Physical
        ) PURE;
    // Returns the physical addresses for the
    // N levels of the systems paging structures.
    // Level zero is the starting base physical
    // address for virtual translations.
    // Levels one-(N-1) will point to the appropriate
    // paging descriptor for the virtual address at
    // the given level of the paging hierarchy.  The
    // exact number of levels depends on many factors.
    // The last level will be the fully translated
    // physical address, matching what VirtualToPhysical
    // returns.  If the address can only be partially
    // translated S_FALSE is returned.
    STDMETHOD(GetVirtualTranslationPhysicalOffsets)(
        THIS_
        __in ULONG64 Virtual,
        __out_ecount_opt(OffsetsSize) PULONG64 Offsets,
        __in ULONG OffsetsSize,
        __out_opt PULONG Levels
        ) PURE;

    // System handle data is accessible in certain
    // debug sessions.  The particular data available
    // varies from session to session and platform
    // to platform.
    STDMETHOD(ReadHandleData)(
        THIS_
        __in ULONG64 Handle,
        __in ULONG DataType,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG DataSize
        ) PURE;

    // Fills memory with the given pattern.
    // The fill stops at the first non-writable byte.
    STDMETHOD(FillVirtual)(
        THIS_
        __in ULONG64 Start,
        __in ULONG Size,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __out_opt PULONG Filled
        ) PURE;
    STDMETHOD(FillPhysical)(
        THIS_
        __in ULONG64 Start,
        __in ULONG Size,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __out_opt PULONG Filled
        ) PURE;

    // Queries virtual memory mapping information given
    // an address similarly to the Win32 API VirtualQuery.
    // MEMORY_BASIC_INFORMATION64 is defined in crash.h.
    // This method currently only works for user-mode sessions.
    STDMETHOD(QueryVirtual)(
        THIS_
        __in ULONG64 Offset,
        __out PMEMORY_BASIC_INFORMATION64 Info
        ) PURE;

    // IDebugDataSpaces3.

    // Convenience method for reading an image
    // header from virtual memory.  Given the
    // image base, this method determines where
    // the NT headers are, validates the necessary
    // markers and converts the headers into
    // 64-bit form for consistency.
    // A caller can check whether the headers were
    // originally 32-bit by checking the optional
    // header magic value.
    // This method will not read ROM headers.
    STDMETHOD(ReadImageNtHeaders)(
        THIS_
        __in ULONG64 ImageBase,
        __out PIMAGE_NT_HEADERS64 Headers
        ) PURE;

    // Some debug sessions have arbitrary additional
    // data available.  For example, additional dump
    // information files may contain extra information
    // gathered at the same time as the primary dump.
    // Such information is tagged with a unique identifier
    // and can only be retrieved via the tag.
    // Tagged data cannot be partially available; the
    // tagged block is either fully present or completely
    // absent.
    STDMETHOD(ReadTagged)(
        THIS_
        __in LPGUID Tag,
        __in ULONG Offset,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG TotalSize
        ) PURE;
    STDMETHOD(StartEnumTagged)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(GetNextTagged)(
        THIS_
        __in ULONG64 Handle,
        __out LPGUID Tag,
        __out PULONG Size
        ) PURE;
    STDMETHOD(EndEnumTagged)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    // IDebugDataSpaces4.

    // General information about an address in the given data space.
    // Queries are from DEBUG_OFFSINFO_*.
    STDMETHOD(GetOffsetInformation)(
        THIS_
        __in ULONG Space,
        __in ULONG Which,
        __in ULONG64 Offset,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG InfoSize
        ) PURE;

    // Given a particular address, return the
    // next address which has a different validity.
    // For example, in debug sessions such as a live
    // user-mode session where virtual address validity
    // changes from page to page this will return the
    // page after the given page.  In sessions such as
    // a user-mode dump file where validity can change
    // from byte to byte this will return the start of
    // the next region that has different validity.
    STDMETHOD(GetNextDifferentlyValidOffsetVirtual)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG64 NextOffset
        ) PURE;

    // Given a particular range of virtual addresses,
    // find the first region which is valid memory.
    STDMETHOD(GetValidRegionVirtual)(
        THIS_
        __in ULONG64 Base,
        __in ULONG Size,
        __out PULONG64 ValidBase,
        __out PULONG ValidSize
        ) PURE;

    STDMETHOD(SearchVirtual2)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Length,
        __in ULONG Flags,
        __in_bcount(PatternSize) PVOID Pattern,
        __in ULONG PatternSize,
        __in ULONG PatternGranularity,
        __out PULONG64 MatchOffset
        ) PURE;

    // Attempts to read a multi-byte string
    // starting at the given virtual address.
    // The possible string length, including terminator,
    // is capped at the given max size.
    // If a return buffer is given it will always
    // be terminated.
    STDMETHOD(ReadMultiByteStringVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG MaxBytes,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringBytes
        ) PURE;
    // Reads a multi-byte string and converts
    // it to Unicode using the given code page.
    STDMETHOD(ReadMultiByteStringVirtualWide)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG MaxBytes,
        __in ULONG CodePage,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringBytes
        ) PURE;
    STDMETHOD(ReadUnicodeStringVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG MaxBytes,
        __in ULONG CodePage,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringBytes
        ) PURE;
    STDMETHOD(ReadUnicodeStringVirtualWide)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG MaxBytes,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringBytes
        ) PURE;

    STDMETHOD(ReadPhysical2)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical2)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugEventCallbacks.
//
//----------------------------------------------------------------------------

// Interest mask bits.
#define DEBUG_EVENT_BREAKPOINT              0x00000001
#define DEBUG_EVENT_EXCEPTION               0x00000002
#define DEBUG_EVENT_CREATE_THREAD           0x00000004
#define DEBUG_EVENT_EXIT_THREAD             0x00000008
#define DEBUG_EVENT_CREATE_PROCESS          0x00000010
#define DEBUG_EVENT_EXIT_PROCESS            0x00000020
#define DEBUG_EVENT_LOAD_MODULE             0x00000040
#define DEBUG_EVENT_UNLOAD_MODULE           0x00000080
#define DEBUG_EVENT_SYSTEM_ERROR            0x00000100
#define DEBUG_EVENT_SESSION_STATUS          0x00000200
#define DEBUG_EVENT_CHANGE_DEBUGGEE_STATE   0x00000400
#define DEBUG_EVENT_CHANGE_ENGINE_STATE     0x00000800
#define DEBUG_EVENT_CHANGE_SYMBOL_STATE     0x00001000

// SessionStatus flags.
// A debuggee has been discovered for the session.
#define DEBUG_SESSION_ACTIVE                       0x00000000
// The session has been ended by EndSession.
#define DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE 0x00000001
#define DEBUG_SESSION_END_SESSION_ACTIVE_DETACH    0x00000002
#define DEBUG_SESSION_END_SESSION_PASSIVE          0x00000003
// The debuggee has run to completion.  User-mode only.
#define DEBUG_SESSION_END                          0x00000004
// The target machine has rebooted.  Kernel-mode only.
#define DEBUG_SESSION_REBOOT                       0x00000005
// The target machine has hibernated.  Kernel-mode only.
#define DEBUG_SESSION_HIBERNATE                    0x00000006
// The engine was unable to continue the session.
#define DEBUG_SESSION_FAILURE                      0x00000007

// ChangeDebuggeeState flags.
// The debuggees state has changed generally, such
// as when the debuggee has been executing.
// Argument is zero.
#define DEBUG_CDS_ALL       0xffffffff
// Registers have changed.  If only a single register
// changed, argument is the index of the register.
// Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CDS_REGISTERS 0x00000001
// Data spaces have changed.  If only a single
// space was affected, argument is the data
// space.  Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CDS_DATA      0x00000002

// ChangeEngineState flags.
// The engine state has changed generally.
// Argument is zero.
#define DEBUG_CES_ALL                 0xffffffff
// Current thread changed.  This may imply a change
// of system and process also.  Argument is the ID of the new
// current thread or DEBUG_ANY_ID if no thread is current.
#define DEBUG_CES_CURRENT_THREAD      0x00000001
// Effective processor changed.  Argument is the
// new processor type.
#define DEBUG_CES_EFFECTIVE_PROCESSOR 0x00000002
// Breakpoints changed.  If only a single breakpoint
// changed, argument is the ID of the breakpoint.
// Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CES_BREAKPOINTS         0x00000004
// Code interpretation level changed.  Argument is
// the new level.
#define DEBUG_CES_CODE_LEVEL          0x00000008
// Execution status changed.  Argument is the new
// execution status.
#define DEBUG_CES_EXECUTION_STATUS    0x00000010
// Engine options have changed.  Argument is the new
// options value.
#define DEBUG_CES_ENGINE_OPTIONS      0x00000020
// Log file information has changed.  Argument
// is TRUE if a log file was opened and FALSE if
// a log file was closed.
#define DEBUG_CES_LOG_FILE            0x00000040
// Default number radix has changed.  Argument
// is the new radix.
#define DEBUG_CES_RADIX               0x00000080
// Event filters changed.  If only a single filter
// changed the argument is the filter's index,
// otherwise it is DEBUG_ANY_ID.
#define DEBUG_CES_EVENT_FILTERS       0x00000100
// Process options have changed.  Argument is the new
// options value.
#define DEBUG_CES_PROCESS_OPTIONS     0x00000200
// Extensions have been added or removed.
#define DEBUG_CES_EXTENSIONS          0x00000400
// Systems have been added or removed.  The argument
// is the system ID.  Systems, unlike processes and
// threads, may be created at any time and not
// just during WaitForEvent.
#define DEBUG_CES_SYSTEMS             0x00000800
// Assembly/disassembly options have changed.  Argument
// is the new options value.
#define DEBUG_CES_ASSEMBLY_OPTIONS    0x00001000
// Expression syntax has changed.  Argument
// is the new syntax value.
#define DEBUG_CES_EXPRESSION_SYNTAX   0x00002000
// Text replacements have changed.
#define DEBUG_CES_TEXT_REPLACEMENTS   0x00004000

// ChangeSymbolState flags.
// Symbol state has changed generally, such
// as after reload operations.  Argument is zero.
#define DEBUG_CSS_ALL            0xffffffff
// Modules have been loaded.  If only a
// single module changed, argument is the
// base address of the module.  Otherwise
// it is zero.
#define DEBUG_CSS_LOADS          0x00000001
// Modules have been unloaded.  If only a
// single module changed, argument is the
// base address of the module.  Otherwise
// it is zero.
#define DEBUG_CSS_UNLOADS        0x00000002
// Current symbol scope changed.
#define DEBUG_CSS_SCOPE          0x00000004
// Paths have changed.
#define DEBUG_CSS_PATHS          0x00000008
// Symbol options have changed.  Argument is the new
// options value.
#define DEBUG_CSS_SYMBOL_OPTIONS 0x00000010
// Type options have changed.  Argument is the new
// options value.
#define DEBUG_CSS_TYPE_OPTIONS   0x00000020

#undef INTERFACE
#define INTERFACE IDebugEventCallbacks
DECLARE_INTERFACE_(IDebugEventCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugEventCallbacks.

    // The engine calls GetInterestMask once when
    // the event callbacks are set for a client.
    STDMETHOD(GetInterestMask)(
        THIS_
        __out PULONG Mask
        ) PURE;

    // A breakpoint event is generated when
    // a breakpoint exception is received and
    // it can be mapped to an existing breakpoint.
    // The callback method is given a reference
    // to the breakpoint and should release it when
    // it is done with it.
    STDMETHOD(Breakpoint)(
        THIS_
        __in PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Exceptions include breaks which cannot
    // be mapped to an existing breakpoint
    // instance.
    STDMETHOD(Exception)(
        THIS_
        __in PEXCEPTION_RECORD64 Exception,
        __in ULONG FirstChance
        ) PURE;

    // Any of these values can be zero if they
    // cannot be provided by the engine.
    // Currently the kernel does not return thread
    // or process change events.
    STDMETHOD(CreateThread)(
        THIS_
        __in ULONG64 Handle,
        __in ULONG64 DataOffset,
        __in ULONG64 StartOffset
        ) PURE;
    STDMETHOD(ExitThread)(
        THIS_
        __in ULONG ExitCode
        ) PURE;

    // Any of these values can be zero if they
    // cannot be provided by the engine.
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 ImageFileHandle,
        __in ULONG64 Handle,
        __in ULONG64 BaseOffset,
        __in ULONG ModuleSize,
        __in_opt PCSTR ModuleName,
        __in_opt PCSTR ImageName,
        __in ULONG CheckSum,
        __in ULONG TimeDateStamp,
        __in ULONG64 InitialThreadHandle,
        __in ULONG64 ThreadDataOffset,
        __in ULONG64 StartOffset
        ) PURE;
    STDMETHOD(ExitProcess)(
        THIS_
        __in ULONG ExitCode
        ) PURE;

    // Any of these values may be zero.
    STDMETHOD(LoadModule)(
        THIS_
        __in ULONG64 ImageFileHandle,
        __in ULONG64 BaseOffset,
        __in ULONG ModuleSize,
        __in_opt PCSTR ModuleName,
        __in_opt PCSTR ImageName,
        __in ULONG CheckSum,
        __in ULONG TimeDateStamp
        ) PURE;
    STDMETHOD(UnloadModule)(
        THIS_
        __in_opt PCSTR ImageBaseName,
        __in ULONG64 BaseOffset
        ) PURE;

    STDMETHOD(SystemError)(
        THIS_
        __in ULONG Error,
        __in ULONG Level
        ) PURE;

    // Session status is synchronous like the other
    // wait callbacks but it is called as the state
    // of the session is changing rather than at
    // specific events so its return value does not
    // influence waiting.  Implementations should just
    // return DEBUG_STATUS_NO_CHANGE.
    // Also, because some of the status
    // notifications are very early or very
    // late in the session lifetime there may not be
    // current processes or threads when the notification
    // is generated.
    STDMETHOD(SessionStatus)(
        THIS_
        __in ULONG Status
        ) PURE;

    // The following callbacks are informational
    // callbacks notifying the provider about
    // changes in debug state.  The return value
    // of these callbacks is ignored.  Implementations
    // can not call back into the engine.

    // Debuggee state, such as registers or data spaces,
    // has changed.
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        ) PURE;
    // Engine state has changed.
    STDMETHOD(ChangeEngineState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        ) PURE;
    // Symbol state has changed.
    STDMETHOD(ChangeSymbolState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugEventCallbacksWide
DECLARE_INTERFACE_(IDebugEventCallbacksWide, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugEventCallbacksWide.

    // The engine calls GetInterestMask once when
    // the event callbacks are set for a client.
    STDMETHOD(GetInterestMask)(
        THIS_
        __out PULONG Mask
        ) PURE;

    // A breakpoint event is generated when
    // a breakpoint exception is received and
    // it can be mapped to an existing breakpoint.
    // The callback method is given a reference
    // to the breakpoint and should release it when
    // it is done with it.
    STDMETHOD(Breakpoint)(
        THIS_
        __in PDEBUG_BREAKPOINT2 Bp
        ) PURE;

    // Exceptions include breaks which cannot
    // be mapped to an existing breakpoint
    // instance.
    STDMETHOD(Exception)(
        THIS_
        __in PEXCEPTION_RECORD64 Exception,
        __in ULONG FirstChance
        ) PURE;

    // Any of these values can be zero if they
    // cannot be provided by the engine.
    // Currently the kernel does not return thread
    // or process change events.
    STDMETHOD(CreateThread)(
        THIS_
        __in ULONG64 Handle,
        __in ULONG64 DataOffset,
        __in ULONG64 StartOffset
        ) PURE;
    STDMETHOD(ExitThread)(
        THIS_
        __in ULONG ExitCode
        ) PURE;

    // Any of these values can be zero if they
    // cannot be provided by the engine.
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 ImageFileHandle,
        __in ULONG64 Handle,
        __in ULONG64 BaseOffset,
        __in ULONG ModuleSize,
        __in_opt PCWSTR ModuleName,
        __in_opt PCWSTR ImageName,
        __in ULONG CheckSum,
        __in ULONG TimeDateStamp,
        __in ULONG64 InitialThreadHandle,
        __in ULONG64 ThreadDataOffset,
        __in ULONG64 StartOffset
        ) PURE;
    STDMETHOD(ExitProcess)(
        THIS_
        __in ULONG ExitCode
        ) PURE;

    // Any of these values may be zero.
    STDMETHOD(LoadModule)(
        THIS_
        __in ULONG64 ImageFileHandle,
        __in ULONG64 BaseOffset,
        __in ULONG ModuleSize,
        __in_opt PCWSTR ModuleName,
        __in_opt PCWSTR ImageName,
        __in ULONG CheckSum,
        __in ULONG TimeDateStamp
        ) PURE;
    STDMETHOD(UnloadModule)(
        THIS_
        __in_opt PCWSTR ImageBaseName,
        __in ULONG64 BaseOffset
        ) PURE;

    STDMETHOD(SystemError)(
        THIS_
        __in ULONG Error,
        __in ULONG Level
        ) PURE;

    // Session status is synchronous like the other
    // wait callbacks but it is called as the state
    // of the session is changing rather than at
    // specific events so its return value does not
    // influence waiting.  Implementations should just
    // return DEBUG_STATUS_NO_CHANGE.
    // Also, because some of the status
    // notifications are very early or very
    // late in the session lifetime there may not be
    // current processes or threads when the notification
    // is generated.
    STDMETHOD(SessionStatus)(
        THIS_
        __in ULONG Status
        ) PURE;

    // The following callbacks are informational
    // callbacks notifying the provider about
    // changes in debug state.  The return value
    // of these callbacks is ignored.  Implementations
    // can not call back into the engine.

    // Debuggee state, such as registers or data spaces,
    // has changed.
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        ) PURE;
    // Engine state has changed.
    STDMETHOD(ChangeEngineState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        ) PURE;
    // Symbol state has changed.
    STDMETHOD(ChangeSymbolState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugInputCallbacks.
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugInputCallbacks
DECLARE_INTERFACE_(IDebugInputCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugInputCallbacks.

    // A call to the StartInput method is a request for
    // a line of input from any client.  The returned input
    // should always be zero-terminated.  The buffer size
    // provided is only a guideline.  A client can return
    // more if necessary and the engine will truncate it
    // before returning from IDebugControl::Input.
    // The return value is ignored.
    STDMETHOD(StartInput)(
        THIS_
        __in ULONG BufferSize
        ) PURE;
    // The return value is ignored.
    STDMETHOD(EndInput)(
        THIS
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugOutputCallbacks.
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugOutputCallbacks
DECLARE_INTERFACE_(IDebugOutputCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugOutputCallbacks.

    // This method is only called if the supplied mask
    // is allowed by the clients output control.
    // The return value is ignored.
    STDMETHOD(Output)(
        THIS_
        __in ULONG Mask,
        __in PCSTR Text
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugOutputCallbacksWide
DECLARE_INTERFACE_(IDebugOutputCallbacksWide, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugOutputCallbacksWide.

    // This method is only called if the supplied mask
    // is allowed by the clients output control.
    // The return value is ignored.
    STDMETHOD(Output)(
        THIS_
        __in ULONG Mask,
        __in PCWSTR Text
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugRegisters.
//
//----------------------------------------------------------------------------

#define DEBUG_REGISTERS_DEFAULT 0x00000000
#define DEBUG_REGISTERS_INT32   0x00000001
#define DEBUG_REGISTERS_INT64   0x00000002
#define DEBUG_REGISTERS_FLOAT   0x00000004
#define DEBUG_REGISTERS_ALL     0x00000007

#define DEBUG_REGISTER_SUB_REGISTER 0x00000001

typedef struct _DEBUG_REGISTER_DESCRIPTION
{
    // DEBUG_VALUE type.
    ULONG Type;
    ULONG Flags;

    // If this is a subregister the full
    // registers description index is
    // given in SubregMaster.  The length, mask
    // and shift describe how the subregisters
    // bits fit into the full register.
    ULONG SubregMaster;
    ULONG SubregLength;
    ULONG64 SubregMask;
    ULONG SubregShift;

    ULONG Reserved0;
} DEBUG_REGISTER_DESCRIPTION, *PDEBUG_REGISTER_DESCRIPTION;

#undef INTERFACE
#define INTERFACE IDebugRegisters
DECLARE_INTERFACE_(IDebugRegisters, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugRegisters.
    STDMETHOD(GetNumberRegisters)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetDescription)(
        THIS_
        __in ULONG Register,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PDEBUG_REGISTER_DESCRIPTION Desc
        ) PURE;
    STDMETHOD(GetIndexByName)(
        THIS_
        __in PCSTR Name,
        __out PULONG Index
        ) PURE;

    STDMETHOD(GetValue)(
        THIS_
        __in ULONG Register,
        __out PDEBUG_VALUE Value
        ) PURE;
    // SetValue makes a best effort at coercing
    // the given value into the given registers
    // value type.  If the given value is larger
    // than the register can hold the least
    // significant bits will be dropped.  Float
    // to int and int to float will be done
    // if necessary.  Subregister bits will be
    // inserted into the master register.
    STDMETHOD(SetValue)(
        THIS_
        __in ULONG Register,
        __in PDEBUG_VALUE Value
        ) PURE;
    // Gets Count register values.  If Indices is
    // non-NULL it must contain Count register
    // indices which control the registers affected.
    // If Indices is NULL the registers from Start
    // to Start + Count  1 are retrieved.
    STDMETHOD(GetValues)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Indices,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_VALUE Values
        ) PURE;
    STDMETHOD(SetValues)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Indices,
        __in ULONG Start,
        __in_ecount(Count) PDEBUG_VALUE Values
        ) PURE;

    // Outputs a group of registers in a well-formatted
    // way thats specific to the platforms register set.
    // Uses the line prefix.
    STDMETHOD(OutputRegisters)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;

    // Abstracted pieces of processor information.
    // The mapping of these values to architectural
    // registers is architecture-specific and their
    // interpretation and existence may vary.  They
    // are intended to be directly compatible with
    // calls which take this information, such as
    // stack walking.
    STDMETHOD(GetInstructionOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(GetStackOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(GetFrameOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
};

//
// The engine maintains several separate
// pieces of context information.  There is
// the current debuggee context, a possible
// override context, such as from .cxr,
// a context for the current scope frame and so on.
//

// Get register information from the debuggee.
#define DEBUG_REGSRC_DEBUGGEE 0x00000000
// Get register information from an explicit
// override context, such as one set by .cxr.
// If there is no override context the request will fail.
#define DEBUG_REGSRC_EXPLICIT 0x00000001
// Get register information from the current scope
// frame.  Note that stack unwinding does not guarantee
// accurate updating of the register context,
// so scope frame register context may not be accurate
// in all cases.
#define DEBUG_REGSRC_FRAME    0x00000002

#undef INTERFACE
#define INTERFACE IDebugRegisters2
DECLARE_INTERFACE_(IDebugRegisters2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugRegisters.

    STDMETHOD(GetNumberRegisters)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetDescription)(
        THIS_
        __in ULONG Register,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PDEBUG_REGISTER_DESCRIPTION Desc
        ) PURE;
    STDMETHOD(GetIndexByName)(
        THIS_
        __in PCSTR Name,
        __out PULONG Index
        ) PURE;

    STDMETHOD(GetValue)(
        THIS_
        __in ULONG Register,
        __out PDEBUG_VALUE Value
        ) PURE;
    // SetValue makes a best effort at coercing
    // the given value into the given registers
    // value type.  If the given value is larger
    // than the register can hold the least
    // significant bits will be dropped.  Float
    // to int and int to float will be done
    // if necessary.  Subregister bits will be
    // inserted into the master register.
    STDMETHOD(SetValue)(
        THIS_
        __in ULONG Register,
        __in PDEBUG_VALUE Value
        ) PURE;
    // Gets Count register values.  If Indices is
    // non-NULL it must contain Count register
    // indices which control the registers affected.
    // If Indices is NULL the registers from Start
    // to Start + Count  1 are retrieved.
    STDMETHOD(GetValues)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Indices,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_VALUE Values
        ) PURE;
    STDMETHOD(SetValues)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Indices,
        __in ULONG Start,
        __in_ecount(Count) PDEBUG_VALUE Values
        ) PURE;

    // Outputs a group of registers in a well-formatted
    // way thats specific to the platforms register set.
    // Uses the line prefix.
    STDMETHOD(OutputRegisters)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags
        ) PURE;

    // Abstracted pieces of processor information.
    // The mapping of these values to architectural
    // registers is architecture-specific and their
    // interpretation and existence may vary.  They
    // are intended to be directly compatible with
    // calls which take this information, such as
    // stack walking.
    STDMETHOD(GetInstructionOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(GetStackOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(GetFrameOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;

    // IDebugRegisters2.

    STDMETHOD(GetDescriptionWide)(
        THIS_
        __in ULONG Register,
        __out_ecount_opt(NameBufferSize) PWSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PDEBUG_REGISTER_DESCRIPTION Desc
        ) PURE;
    STDMETHOD(GetIndexByNameWide)(
        THIS_
        __in PCWSTR Name,
        __out PULONG Index
        ) PURE;

    // Pseudo-registers are synthetic values derived
    // by the engine that are presented in a manner
    // similar to regular registers.  They are simple
    // value holders, similar to actual registers.
    // Pseudo-registers are defined for concepts,
    // such as current-instruction-pointer or
    // current-thread-data.  As such they have
    // types appropriate for their data.
    STDMETHOD(GetNumberPseudoRegisters)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetPseudoDescription)(
        THIS_
        __in ULONG Register,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 TypeModule,
        __out_opt PULONG TypeId
        ) PURE;
    STDMETHOD(GetPseudoDescriptionWide)(
        THIS_
        __in ULONG Register,
        __out_ecount_opt(NameBufferSize) PWSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 TypeModule,
        __out_opt PULONG TypeId
        ) PURE;
    STDMETHOD(GetPseudoIndexByName)(
        THIS_
        __in PCSTR Name,
        __out PULONG Index
        ) PURE;
    STDMETHOD(GetPseudoIndexByNameWide)(
        THIS_
        __in PCWSTR Name,
        __out PULONG Index
        ) PURE;
    // Some pseudo-register values are affected
    // by the register source, others are not.
    STDMETHOD(GetPseudoValues)(
        THIS_
        __in ULONG Source,
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Indices,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_VALUE Values
        ) PURE;
    // Many pseudo-registers are read-only and cannot be set.
    STDMETHOD(SetPseudoValues)(
        THIS_
        __in ULONG Source,
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Indices,
        __in ULONG Start,
        __in_ecount(Count) PDEBUG_VALUE Values
        ) PURE;

    // These expanded methods allow selection
    // of the source of register information.
    STDMETHOD(GetValues2)(
        THIS_
        __in ULONG Source,
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Indices,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_VALUE Values
        ) PURE;
    STDMETHOD(SetValues2)(
        THIS_
        __in ULONG Source,
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG Indices,
        __in ULONG Start,
        __in_ecount(Count) PDEBUG_VALUE Values
        ) PURE;
    STDMETHOD(OutputRegisters2)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Source,
        __in ULONG Flags
        ) PURE;
    STDMETHOD(GetInstructionOffset2)(
        THIS_
        __in ULONG Source,
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(GetStackOffset2)(
        THIS_
        __in ULONG Source,
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(GetFrameOffset2)(
        THIS_
        __in ULONG Source,
        __out PULONG64 Offset
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSymbolGroup
//
//----------------------------------------------------------------------------

// OutputSymbols flags.
// Default output contains
//   <Name>**NAME**<Offset>**OFF**<Value>**VALUE**<Type>**TYPE**
// per symbol.
#define DEBUG_OUTPUT_SYMBOLS_DEFAULT    0x00000000
#define DEBUG_OUTPUT_SYMBOLS_NO_NAMES   0x00000001
#define DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS 0x00000002
#define DEBUG_OUTPUT_SYMBOLS_NO_VALUES  0x00000004
#define DEBUG_OUTPUT_SYMBOLS_NO_TYPES   0x00000010

#define DEBUG_OUTPUT_NAME_END           "**NAME**"
#define DEBUG_OUTPUT_OFFSET_END         "**OFF**"
#define DEBUG_OUTPUT_VALUE_END          "**VALUE**"
#define DEBUG_OUTPUT_TYPE_END           "**TYPE**"

#define DEBUG_OUTPUT_NAME_END_WIDE      L"**NAME**"
#define DEBUG_OUTPUT_OFFSET_END_WIDE    L"**OFF**"
#define DEBUG_OUTPUT_VALUE_END_WIDE     L"**VALUE**"
#define DEBUG_OUTPUT_TYPE_END_WIDE      L"**TYPE**"

#ifdef UNICODE
#define DEBUG_OUTPUT_NAME_END_T DEBUG_OUTPUT_NAME_END_WIDE
#define DEBUG_OUTPUT_OFFSET_END_T DEBUG_OUTPUT_OFFSET_END_WIDE
#define DEBUG_OUTPUT_VALUE_END_T DEBUG_OUTPUT_VALUE_END_WIDE
#define DEBUG_OUTPUT_TYPE_END_T DEBUG_OUTPUT_TYPE_END_WIDE
#else
#define DEBUG_OUTPUT_NAME_END_T DEBUG_OUTPUT_NAME_END
#define DEBUG_OUTPUT_OFFSET_END_T DEBUG_OUTPUT_OFFSET_END
#define DEBUG_OUTPUT_VALUE_END_T DEBUG_OUTPUT_VALUE_END
#define DEBUG_OUTPUT_TYPE_END_T DEBUG_OUTPUT_TYPE_END
#endif

// DEBUG_SYMBOL_PARAMETERS flags.
// Cumulative expansion level, takes four bits.
#define DEBUG_SYMBOL_EXPANSION_LEVEL_MASK 0x0000000f
// Symbols subelements follow.
#define DEBUG_SYMBOL_EXPANDED             0x00000010
// Symbols value is read-only.
#define DEBUG_SYMBOL_READ_ONLY            0x00000020
// Symbol subelements are array elements.
#define DEBUG_SYMBOL_IS_ARRAY             0x00000040
// Symbol is a float value.
#define DEBUG_SYMBOL_IS_FLOAT             0x00000080
// Symbol is a scope argument.
#define DEBUG_SYMBOL_IS_ARGUMENT          0x00000100
// Symbol is a scope argument.
#define DEBUG_SYMBOL_IS_LOCAL             0x00000200

typedef struct _DEBUG_SYMBOL_PARAMETERS
{
    ULONG64 Module;
    ULONG TypeId;
    // ParentSymbol may be DEBUG_ANY_ID when unknown.
    ULONG ParentSymbol;
    // A subelement of a symbol can be a field, such
    // as in structs, unions or classes; or an array
    // element count for arrays.
    ULONG SubElements;
    ULONG Flags;
    ULONG64 Reserved;
} DEBUG_SYMBOL_PARAMETERS, *PDEBUG_SYMBOL_PARAMETERS;

#undef INTERFACE
#define INTERFACE IDebugSymbolGroup
DECLARE_INTERFACE_(IDebugSymbolGroup, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbolGroup.
    STDMETHOD(GetNumberSymbols)(
        THIS_
        __out PULONG Number
        ) PURE;
    // On input Index indicates the desired insertion
    // index.  On output Index contains the actual index.
    // Use DEBUG_ANY_ID to append a symbol to the end.
    STDMETHOD(AddSymbol)(
        THIS_
        __in PCSTR Name,
        __inout PULONG Index
        ) PURE;
    STDMETHOD(RemoveSymbolByName)(
        THIS_
        __in PCSTR Name
        ) PURE;
    STDMETHOD(RemoveSymbolByIndex)(
        THIS_
        __in ULONG Index
        ) PURE;
    STDMETHOD(GetSymbolName)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    STDMETHOD(GetSymbolParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PDEBUG_SYMBOL_PARAMETERS Params
        ) PURE;
    STDMETHOD(ExpandSymbol)(
        THIS_
        __in ULONG Index,
        __in BOOL Expand
        ) PURE;
    // Uses the line prefix.
    STDMETHOD(OutputSymbols)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in ULONG Start,
        __in ULONG Count
        ) PURE;
    STDMETHOD(WriteSymbol)(
        THIS_
        __in ULONG Index,
        __in PCSTR Value
        ) PURE;
    STDMETHOD(OutputAsType)(
        THIS_
        __in ULONG Index,
        __in PCSTR Type
        ) PURE;
};

#define DEBUG_SYMENT_IS_CODE      0x00000001
#define DEBUG_SYMENT_IS_DATA      0x00000002
#define DEBUG_SYMENT_IS_PARAMETER 0x00000004
#define DEBUG_SYMENT_IS_LOCAL     0x00000008
#define DEBUG_SYMENT_IS_MANAGED   0x00000010
#define DEBUG_SYMENT_IS_SYNTHETIC 0x00000020

typedef struct _DEBUG_SYMBOL_ENTRY
{
    ULONG64 ModuleBase;
    ULONG64 Offset;
    ULONG64 Id;
    ULONG64 Arg64;
    ULONG Size;
    ULONG Flags;
    ULONG TypeId;
    ULONG NameSize;
    ULONG Token;
    ULONG Tag;
    ULONG Arg32;
    ULONG Reserved;
} DEBUG_SYMBOL_ENTRY, *PDEBUG_SYMBOL_ENTRY;

#undef INTERFACE
#define INTERFACE IDebugSymbolGroup2
DECLARE_INTERFACE_(IDebugSymbolGroup2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbolGroup.

    STDMETHOD(GetNumberSymbols)(
        THIS_
        __out PULONG Number
        ) PURE;
    // On input Index indicates the desired insertion
    // index.  On output Index contains the actual index.
    // Use DEBUG_ANY_ID to append a symbol to the end.
    STDMETHOD(AddSymbol)(
        THIS_
        __in PCSTR Name,
        __inout PULONG Index
        ) PURE;
    STDMETHOD(RemoveSymbolByName)(
        THIS_
        __in PCSTR Name
        ) PURE;
    STDMETHOD(RemoveSymbolByIndex)(
        THIS_
        __in ULONG Index
        ) PURE;
    STDMETHOD(GetSymbolName)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    STDMETHOD(GetSymbolParameters)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PDEBUG_SYMBOL_PARAMETERS Params
        ) PURE;
    STDMETHOD(ExpandSymbol)(
        THIS_
        __in ULONG Index,
        __in BOOL Expand
        ) PURE;
    // Uses the line prefix.
    STDMETHOD(OutputSymbols)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in ULONG Start,
        __in ULONG Count
        ) PURE;
    STDMETHOD(WriteSymbol)(
        THIS_
        __in ULONG Index,
        __in PCSTR Value
        ) PURE;
    STDMETHOD(OutputAsType)(
        THIS_
        __in ULONG Index,
        __in PCSTR Type
        ) PURE;

    // IDebugSymbolGroup2.

    STDMETHOD(AddSymbolWide)(
        THIS_
        __in PCWSTR Name,
        __inout PULONG Index
        ) PURE;
    STDMETHOD(RemoveSymbolByNameWide)(
        THIS_
        __in PCWSTR Name
        ) PURE;
    STDMETHOD(GetSymbolNameWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    STDMETHOD(WriteSymbolWide)(
        THIS_
        __in ULONG Index,
        __in PCWSTR Value
        ) PURE;
    STDMETHOD(OutputAsTypeWide)(
        THIS_
        __in ULONG Index,
        __in PCWSTR Type
        ) PURE;

    STDMETHOD(GetSymbolTypeName)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    STDMETHOD(GetSymbolTypeNameWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    STDMETHOD(GetSymbolSize)(
        THIS_
        __in ULONG Index,
        __out PULONG Size
        ) PURE;
    // If the symbol has an absolute address
    // this method will retrieve it.
    STDMETHOD(GetSymbolOffset)(
        THIS_
        __in ULONG Index,
        __out PULONG64 Offset
        ) PURE;
    // If the symbol is enregistered this
    // method will return the register index.
    STDMETHOD(GetSymbolRegister)(
        THIS_
        __in ULONG Index,
        __out PULONG Register
        ) PURE;
    STDMETHOD(GetSymbolValueText)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    STDMETHOD(GetSymbolValueTextWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    STDMETHOD(GetSymbolEntryInformation)(
        THIS_
        __in ULONG Index,
        __out PDEBUG_SYMBOL_ENTRY Entry
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSymbols.
//
//----------------------------------------------------------------------------

//
// Information about a module.
//

// Flags.
#define DEBUG_MODULE_LOADED            0x00000000
#define DEBUG_MODULE_UNLOADED          0x00000001
#define DEBUG_MODULE_USER_MODE         0x00000002
#define DEBUG_MODULE_EXPLICIT          0x00000008
#define DEBUG_MODULE_SECONDARY         0x00000010
#define DEBUG_MODULE_SYNTHETIC         0x00000020
#define DEBUG_MODULE_SYM_BAD_CHECKSUM  0x00010000

// Symbol types.
#define DEBUG_SYMTYPE_NONE     0
#define DEBUG_SYMTYPE_COFF     1
#define DEBUG_SYMTYPE_CODEVIEW 2
#define DEBUG_SYMTYPE_PDB      3
#define DEBUG_SYMTYPE_EXPORT   4
#define DEBUG_SYMTYPE_DEFERRED 5
#define DEBUG_SYMTYPE_SYM      6
#define DEBUG_SYMTYPE_DIA      7

typedef struct _DEBUG_MODULE_PARAMETERS
{
    ULONG64 Base;
    ULONG Size;
    ULONG TimeDateStamp;
    ULONG Checksum;
    ULONG Flags;
    ULONG SymbolType;
    ULONG ImageNameSize;
    ULONG ModuleNameSize;
    ULONG LoadedImageNameSize;
    ULONG SymbolFileNameSize;
    ULONG MappedImageNameSize;
    ULONG64 Reserved[2];
} DEBUG_MODULE_PARAMETERS, *PDEBUG_MODULE_PARAMETERS;

// Scope arguments are function arguments
// and thus only change when the scope
// crosses functions.
#define DEBUG_SCOPE_GROUP_ARGUMENTS 0x00000001
// Scope locals are locals declared in a particular
// scope and are only defined within that scope.
#define DEBUG_SCOPE_GROUP_LOCALS    0x00000002
// All symbols in the scope.
#define DEBUG_SCOPE_GROUP_ALL       0x00000003

// Typed data output control flags.
#define DEBUG_OUTTYPE_DEFAULT              0x00000000
#define DEBUG_OUTTYPE_NO_INDENT            0x00000001
#define DEBUG_OUTTYPE_NO_OFFSET            0x00000002
#define DEBUG_OUTTYPE_VERBOSE              0x00000004
#define DEBUG_OUTTYPE_COMPACT_OUTPUT       0x00000008
#define DEBUG_OUTTYPE_RECURSION_LEVEL(Max) (((Max) & 0xf) << 4)
#define DEBUG_OUTTYPE_ADDRESS_OF_FIELD     0x00010000
#define DEBUG_OUTTYPE_ADDRESS_AT_END       0x00020000
#define DEBUG_OUTTYPE_BLOCK_RECURSE        0x00200000

// FindSourceFile flags.
#define DEBUG_FIND_SOURCE_DEFAULT      0x00000000
// Returns fully-qualified paths only.  If this
// is not set the path returned may be relative.
#define DEBUG_FIND_SOURCE_FULL_PATH    0x00000001
// Scans all the path elements for a match and
// returns the one that has the most similarity
// between the given file and the matching element.
#define DEBUG_FIND_SOURCE_BEST_MATCH   0x00000002
// Do not search source server paths.
#define DEBUG_FIND_SOURCE_NO_SRCSRV    0x00000004
// Restrict FindSourceFileAndToken to token lookup only.
#define DEBUG_FIND_SOURCE_TOKEN_LOOKUP 0x00000008

// A special value marking an offset that should not
// be treated as a valid offset.  This is only used
// in special situations where it is unlikely that
// this value would be a valid offset.
#define DEBUG_INVALID_OFFSET ((ULONG64)-1)

#undef INTERFACE
#define INTERFACE IDebugSymbols
DECLARE_INTERFACE_(IDebugSymbols, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbols.

    // Controls the symbol options used during
    // symbol operations.
    // Uses the same flags as dbghelps SymSetOptions.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    STDMETHOD(GetNameByOffset)(
        THIS_
        __in ULONG64 Offset,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Displacement
        ) PURE;
    // A symbol name may not be unique, particularly
    // when overloaded functions exist which all
    // have the same name.  If GetOffsetByName
    // finds multiple matches for the name it
    // can return any one of them.  In that
    // case it will return S_FALSE to indicate
    // that ambiguity was arbitrarily resolved.
    // A caller can then use SearchSymbols to
    // find all of the matches if it wishes to
    // perform different disambiguation.
    STDMETHOD(GetOffsetByName)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG64 Offset
        ) PURE;
    // GetNearNameByOffset returns symbols
    // located near the symbol closest to
    // to the offset, such as the previous
    // or next symbol.  If Delta is zero it
    // operates identically to GetNameByOffset.
    // If Delta is nonzero and such a symbol
    // does not exist an error is returned.
    // The next symbol, if one exists, will
    // always have a higher offset than the
    // input offset so the displacement is
    // always negative.  The situation is
    // reversed for the previous symbol.
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in LONG Delta,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Displacement
        ) PURE;

    STDMETHOD(GetLineByOffset)(
        THIS_
        __in ULONG64 Offset,
        __out_opt PULONG Line,
        __out_ecount_opt(FileBufferSize) PSTR FileBuffer,
        __in ULONG FileBufferSize,
        __out_opt PULONG FileSize,
        __out_opt PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByLine)(
        THIS_
        __in ULONG Line,
        __in PCSTR File,
        __out PULONG64 Offset
        ) PURE;

    // Enumerates the engines list of modules
    // loaded for the current process.  This may
    // or may not match the system module list
    // for the process.  Reload can be used to
    // synchronize the engines list with the system
    // if necessary.
    // Some sessions also track recently unloaded
    // code modules for help in analyzing failures
    // where an attempt is made to call unloaded code.
    // These modules are indexed after the loaded
    // modules.
    STDMETHOD(GetNumberModules)(
        THIS_
        __out PULONG Loaded,
        __out PULONG Unloaded
        ) PURE;
    STDMETHOD(GetModuleByIndex)(
        THIS_
        __in ULONG Index,
        __out PULONG64 Base
        ) PURE;
    // The module name may not be unique.
    // This method returns the first match.
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        __in PCSTR Name,
        __in ULONG StartIndex,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    // Offset can be any offset within
    // the module extent.  Extents may
    // not be unique when including unloaded
    // drivers.  This method returns the
    // first match.
    STDMETHOD(GetModuleByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG StartIndex,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    STDMETHOD(GetModuleNames)(
        THIS_
        __in ULONG Index,
        __in ULONG64 Base,
        __out_ecount_opt(ImageNameBufferSize) PSTR ImageNameBuffer,
        __in ULONG ImageNameBufferSize,
        __out_opt PULONG ImageNameSize,
        __out_ecount_opt(ModuleNameBufferSize) PSTR ModuleNameBuffer,
        __in ULONG ModuleNameBufferSize,
        __out_opt PULONG ModuleNameSize,
        __out_ecount_opt(LoadedImageNameBufferSize) PSTR LoadedImageNameBuffer,
        __in ULONG LoadedImageNameBufferSize,
        __out_opt PULONG LoadedImageNameSize
        ) PURE;
    STDMETHOD(GetModuleParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG64 Bases,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_MODULE_PARAMETERS Params
        ) PURE;
    // Looks up the module from a <Module>!<Symbol>
    // string.
    STDMETHOD(GetSymbolModule)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG64 Base
        ) PURE;

    // Returns the string name of a type.
    STDMETHOD(GetTypeName)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    // Returns the ID for a type name.
    STDMETHOD(GetTypeId)(
        THIS_
        __in ULONG64 Module,
        __in PCSTR Name,
        __out PULONG TypeId
        ) PURE;
    STDMETHOD(GetTypeSize)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out PULONG Size
        ) PURE;
    // Given a type which can contain members
    // this method returns the offset of a
    // particular member within the type.
    // TypeId should give the container type ID
    // and Field gives the dot-separated path
    // to the field of interest.
    STDMETHOD(GetFieldOffset)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in PCSTR Field,
        __out PULONG Offset
        ) PURE;

    STDMETHOD(GetSymbolTypeId)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG TypeId,
        __out_opt PULONG64 Module
        ) PURE;
    // As with GetOffsetByName a symbol's
    // name may be ambiguous.  GetOffsetTypeId
    // returns the type for the symbol closest
    // to the given offset and can be used
    // to avoid ambiguity.
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG TypeId,
        __out_opt PULONG64 Module
        ) PURE;

    // Helpers for virtual and physical data
    // which combine creation of a location with
    // the actual operation.
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG Flags
        ) PURE;
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG Flags
        ) PURE;

    // Function arguments and scope block symbols
    // can be retrieved relative to currently
    // executing code.  A caller can provide just
    // a code offset for scoping purposes and look
    // up names or the caller can provide a full frame
    // and look up actual values.  The values for
    // scoped symbols are best-guess and may or may not
    // be accurate depending on program optimizations,
    // the machine architecture, the current point
    // in the programs execution and so on.
    // A caller can also provide a complete register
    // context for setting a scope to a previous
    // machine state such as a context saved for
    // an exception.  Usually this isnt necessary
    // and the current register context is used.
    STDMETHOD(GetScope)(
        THIS_
        __out_opt PULONG64 InstructionOffset,
        __out_opt PDEBUG_STACK_FRAME ScopeFrame,
        __out_bcount_opt(ScopeContextSize) PVOID ScopeContext,
        __in ULONG ScopeContextSize
        ) PURE;
    // If ScopeFrame or ScopeContext is non-NULL then
    // InstructionOffset is ignored.
    // If ScopeContext is NULL the current
    // register context is used.
    // If the scope identified by the given
    // information is the same as before
    // SetScope returns S_OK.  If the scope
    // information changes, such as when the
    // scope moves between functions or scope
    // blocks, SetScope returns S_FALSE.
    STDMETHOD(SetScope)(
        THIS_
        __in ULONG64 InstructionOffset,
        __in_opt PDEBUG_STACK_FRAME ScopeFrame,
        __in_bcount_opt(ScopeContextSize) PVOID ScopeContext,
        __in ULONG ScopeContextSize
        ) PURE;
    // ResetScope clears the scope information
    // for situations where scoped symbols
    // mask global symbols or when resetting
    // from explicit information to the current
    // information.
    STDMETHOD(ResetScope)(
        THIS
        ) PURE;
    // A scope symbol is tied to its particular
    // scope and only is meaningful within the scope.
    // The returned group can be updated by passing it back
    // into the method for lower-cost
    // incremental updates when stepping.
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        __in ULONG Flags,
        __in_opt PDEBUG_SYMBOL_GROUP Update,
        __out PDEBUG_SYMBOL_GROUP* Symbols
        ) PURE;

    // Create a new symbol group.
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        __out PDEBUG_SYMBOL_GROUP* Group
        ) PURE;

    // StartSymbolMatch matches symbol names
    // against the given pattern using simple
    // regular expressions.  The search results
    // are iterated through using GetNextSymbolMatch.
    // When the caller is done examining results
    // the match should be freed via EndSymbolMatch.
    // If the match pattern contains a module name
    // the search is restricted to a single module.
    // Pattern matching is only done on symbol names,
    // not module names.
    // All active symbol match handles are invalidated
    // when the set of loaded symbols changes.
    STDMETHOD(StartSymbolMatch)(
        THIS_
        __in PCSTR Pattern,
        __out PULONG64 Handle
        ) PURE;
    // If Buffer is NULL the match does not
    // advance.
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        __in ULONG64 Handle,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MatchSize,
        __out_opt PULONG64 Offset
        ) PURE;
    STDMETHOD(EndSymbolMatch)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    STDMETHOD(Reload)(
        THIS_
        __in PCSTR Module
        ) PURE;

    STDMETHOD(GetSymbolPath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(SetSymbolPath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendSymbolPath)(
        THIS_
        __in PCSTR Addition
        ) PURE;

    // Manipulate the path for executable images.
    // Some dump files need to load executable images
    // in order to resolve dump information.  This
    // path controls where the engine looks for
    // images.
    STDMETHOD(GetImagePath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(SetImagePath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendImagePath)(
        THIS_
        __in PCSTR Addition
        ) PURE;

    // Path routines for source file location
    // methods.
    STDMETHOD(GetSourcePath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    // Gets the nth part of the source path.
    STDMETHOD(GetSourcePathElement)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ElementSize
        ) PURE;
    STDMETHOD(SetSourcePath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendSourcePath)(
        THIS_
        __in PCSTR Addition
        ) PURE;
    // Uses the given file path and the source path
    // information to try and locate an existing file.
    // The given file path is merged with elements
    // of the source path and checked for existence.
    // If a match is found the element used is returned.
    // A starting element can be specified to restrict
    // the search to a subset of the path elements;
    // this can be useful when checking for multiple
    // matches along the source path.
    // The returned element can be 1, indicating
    // the file was found directly and not on the path.
    STDMETHOD(FindSourceFile)(
        THIS_
        __in ULONG StartElement,
        __in PCSTR File,
        __in ULONG Flags,
        __out_opt PULONG FoundElement,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FoundSize
        ) PURE;
    // Retrieves all the line offset information
    // for a particular source file.  Buffer is
    // first intialized to DEBUG_INVALID_OFFSET for
    // every entry.  Then for each piece of line
    // symbol information Buffer[Line] set to
    // Lines offset.  This produces a per-line
    // map of the offsets for the lines of the
    // given file.  Line numbers are decremented
    // for the map so Buffer[0] contains the offset
    // for line number 1.
    // If there is no line information at all for
    // the given file the method fails rather
    // than returning a map of invalid offsets.
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        __in PCSTR File,
        __out_ecount_opt(BufferLines) PULONG64 Buffer,
        __in ULONG BufferLines,
        __out_opt PULONG FileLines
        ) PURE;
};

//
// GetModuleNameString strings.
//

#define DEBUG_MODNAME_IMAGE        0x00000000
#define DEBUG_MODNAME_MODULE       0x00000001
#define DEBUG_MODNAME_LOADED_IMAGE 0x00000002
#define DEBUG_MODNAME_SYMBOL_FILE  0x00000003
#define DEBUG_MODNAME_MAPPED_IMAGE 0x00000004

//
// Type options, used with Get/SetTypeOptions.
//

// Display PUSHORT and USHORT arrays in Unicode.
#define DEBUG_TYPEOPTS_UNICODE_DISPLAY    0x00000001
// Display LONG types in default base instead of decimal.
#define DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY 0x00000002
// Display integer types in default base instead of decimal.
#define DEBUG_TYPEOPTS_FORCERADIX_OUTPUT  0x00000004
// Search for the type/symbol with largest size when
// multiple type/symbol match for a given name
#define DEBUG_TYPEOPTS_MATCH_MAXSIZE      0x00000008

#undef INTERFACE
#define INTERFACE IDebugSymbols2
DECLARE_INTERFACE_(IDebugSymbols2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbols.

    // Controls the symbol options used during
    // symbol operations.
    // Uses the same flags as dbghelps SymSetOptions.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    STDMETHOD(GetNameByOffset)(
        THIS_
        __in ULONG64 Offset,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Displacement
        ) PURE;
    // A symbol name may not be unique, particularly
    // when overloaded functions exist which all
    // have the same name.  If GetOffsetByName
    // finds multiple matches for the name it
    // can return any one of them.  In that
    // case it will return S_FALSE to indicate
    // that ambiguity was arbitrarily resolved.
    // A caller can then use SearchSymbols to
    // find all of the matches if it wishes to
    // perform different disambiguation.
    STDMETHOD(GetOffsetByName)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG64 Offset
        ) PURE;
    // GetNearNameByOffset returns symbols
    // located near the symbol closest to
    // to the offset, such as the previous
    // or next symbol.  If Delta is zero it
    // operates identically to GetNameByOffset.
    // If Delta is nonzero and such a symbol
    // does not exist an error is returned.
    // The next symbol, if one exists, will
    // always have a higher offset than the
    // input offset so the displacement is
    // always negative.  The situation is
    // reversed for the previous symbol.
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in LONG Delta,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Displacement
        ) PURE;

    STDMETHOD(GetLineByOffset)(
        THIS_
        __in ULONG64 Offset,
        __out_opt PULONG Line,
        __out_ecount_opt(FileBufferSize) PSTR FileBuffer,
        __in ULONG FileBufferSize,
        __out_opt PULONG FileSize,
        __out_opt PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByLine)(
        THIS_
        __in ULONG Line,
        __in PCSTR File,
        __out PULONG64 Offset
        ) PURE;

    // Enumerates the engines list of modules
    // loaded for the current process.  This may
    // or may not match the system module list
    // for the process.  Reload can be used to
    // synchronize the engines list with the system
    // if necessary.
    // Some sessions also track recently unloaded
    // code modules for help in analyzing failures
    // where an attempt is made to call unloaded code.
    // These modules are indexed after the loaded
    // modules.
    STDMETHOD(GetNumberModules)(
        THIS_
        __out PULONG Loaded,
        __out PULONG Unloaded
        ) PURE;
    STDMETHOD(GetModuleByIndex)(
        THIS_
        __in ULONG Index,
        __out PULONG64 Base
        ) PURE;
    // The module name may not be unique.
    // This method returns the first match.
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        __in PCSTR Name,
        __in ULONG StartIndex,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    // Offset can be any offset within
    // the module extent.  Extents may
    // not be unique when including unloaded
    // drivers.  This method returns the
    // first match.
    STDMETHOD(GetModuleByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG StartIndex,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    STDMETHOD(GetModuleNames)(
        THIS_
        __in ULONG Index,
        __in ULONG64 Base,
        __out_ecount_opt(ImageNameBufferSize) PSTR ImageNameBuffer,
        __in ULONG ImageNameBufferSize,
        __out_opt PULONG ImageNameSize,
        __out_ecount_opt(ModuleNameBufferSize) PSTR ModuleNameBuffer,
        __in ULONG ModuleNameBufferSize,
        __out_opt PULONG ModuleNameSize,
        __out_ecount_opt(LoadedImageNameBufferSize) PSTR LoadedImageNameBuffer,
        __in ULONG LoadedImageNameBufferSize,
        __out_opt PULONG LoadedImageNameSize
        ) PURE;
    STDMETHOD(GetModuleParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG64 Bases,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_MODULE_PARAMETERS Params
        ) PURE;
    // Looks up the module from a <Module>!<Symbol>
    // string.
    STDMETHOD(GetSymbolModule)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG64 Base
        ) PURE;

    // Returns the string name of a type.
    STDMETHOD(GetTypeName)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    // Returns the ID for a type name.
    STDMETHOD(GetTypeId)(
        THIS_
        __in ULONG64 Module,
        __in PCSTR Name,
        __out PULONG TypeId
        ) PURE;
    STDMETHOD(GetTypeSize)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out PULONG Size
        ) PURE;
    // Given a type which can contain members
    // this method returns the offset of a
    // particular member within the type.
    // TypeId should give the container type ID
    // and Field gives the dot-separated path
    // to the field of interest.
    STDMETHOD(GetFieldOffset)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in PCSTR Field,
        __out PULONG Offset
        ) PURE;

    STDMETHOD(GetSymbolTypeId)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG TypeId,
        __out_opt PULONG64 Module
        ) PURE;
    // As with GetOffsetByName a symbol's
    // name may be ambiguous.  GetOffsetTypeId
    // returns the type for the symbol closest
    // to the given offset and can be used
    // to avoid ambiguity.
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG TypeId,
        __out_opt PULONG64 Module
        ) PURE;

    // Helpers for virtual and physical data
    // which combine creation of a location with
    // the actual operation.
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG Flags
        ) PURE;
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG Flags
        ) PURE;

    // Function arguments and scope block symbols
    // can be retrieved relative to currently
    // executing code.  A caller can provide just
    // a code offset for scoping purposes and look
    // up names or the caller can provide a full frame
    // and look up actual values.  The values for
    // scoped symbols are best-guess and may or may not
    // be accurate depending on program optimizations,
    // the machine architecture, the current point
    // in the programs execution and so on.
    // A caller can also provide a complete register
    // context for setting a scope to a previous
    // machine state such as a context saved for
    // an exception.  Usually this isnt necessary
    // and the current register context is used.
    STDMETHOD(GetScope)(
        THIS_
        __out_opt PULONG64 InstructionOffset,
        __out_opt PDEBUG_STACK_FRAME ScopeFrame,
        __out_bcount_opt(ScopeContextSize) PVOID ScopeContext,
        __in ULONG ScopeContextSize
        ) PURE;
    // If ScopeFrame or ScopeContext is non-NULL then
    // InstructionOffset is ignored.
    // If ScopeContext is NULL the current
    // register context is used.
    // If the scope identified by the given
    // information is the same as before
    // SetScope returns S_OK.  If the scope
    // information changes, such as when the
    // scope moves between functions or scope
    // blocks, SetScope returns S_FALSE.
    STDMETHOD(SetScope)(
        THIS_
        __in ULONG64 InstructionOffset,
        __in_opt PDEBUG_STACK_FRAME ScopeFrame,
        __in_bcount_opt(ScopeContextSize) PVOID ScopeContext,
        __in ULONG ScopeContextSize
        ) PURE;
    // ResetScope clears the scope information
    // for situations where scoped symbols
    // mask global symbols or when resetting
    // from explicit information to the current
    // information.
    STDMETHOD(ResetScope)(
        THIS
        ) PURE;
    // A scope symbol is tied to its particular
    // scope and only is meaningful within the scope.
    // The returned group can be updated by passing it back
    // into the method for lower-cost
    // incremental updates when stepping.
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        __in ULONG Flags,
        __in_opt PDEBUG_SYMBOL_GROUP Update,
        __out PDEBUG_SYMBOL_GROUP* Symbols
        ) PURE;

    // Create a new symbol group.
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        __out PDEBUG_SYMBOL_GROUP* Group
        ) PURE;

    // StartSymbolMatch matches symbol names
    // against the given pattern using simple
    // regular expressions.  The search results
    // are iterated through using GetNextSymbolMatch.
    // When the caller is done examining results
    // the match should be freed via EndSymbolMatch.
    // If the match pattern contains a module name
    // the search is restricted to a single module.
    // Pattern matching is only done on symbol names,
    // not module names.
    // All active symbol match handles are invalidated
    // when the set of loaded symbols changes.
    STDMETHOD(StartSymbolMatch)(
        THIS_
        __in PCSTR Pattern,
        __out PULONG64 Handle
        ) PURE;
    // If Buffer is NULL the match does not
    // advance.
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        __in ULONG64 Handle,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MatchSize,
        __out_opt PULONG64 Offset
        ) PURE;
    STDMETHOD(EndSymbolMatch)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    STDMETHOD(Reload)(
        THIS_
        __in PCSTR Module
        ) PURE;

    STDMETHOD(GetSymbolPath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(SetSymbolPath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendSymbolPath)(
        THIS_
        __in PCSTR Addition
        ) PURE;

    // Manipulate the path for executable images.
    // Some dump files need to load executable images
    // in order to resolve dump information.  This
    // path controls where the engine looks for
    // images.
    STDMETHOD(GetImagePath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(SetImagePath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendImagePath)(
        THIS_
        __in PCSTR Addition
        ) PURE;

    // Path routines for source file location
    // methods.
    STDMETHOD(GetSourcePath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    // Gets the nth part of the source path.
    STDMETHOD(GetSourcePathElement)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ElementSize
        ) PURE;
    STDMETHOD(SetSourcePath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendSourcePath)(
        THIS_
        __in PCSTR Addition
        ) PURE;
    // Uses the given file path and the source path
    // information to try and locate an existing file.
    // The given file path is merged with elements
    // of the source path and checked for existence.
    // If a match is found the element used is returned.
    // A starting element can be specified to restrict
    // the search to a subset of the path elements;
    // this can be useful when checking for multiple
    // matches along the source path.
    // The returned element can be 1, indicating
    // the file was found directly and not on the path.
    STDMETHOD(FindSourceFile)(
        THIS_
        __in ULONG StartElement,
        __in PCSTR File,
        __in ULONG Flags,
        __out_opt PULONG FoundElement,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FoundSize
        ) PURE;
    // Retrieves all the line offset information
    // for a particular source file.  Buffer is
    // first intialized to DEBUG_INVALID_OFFSET for
    // every entry.  Then for each piece of line
    // symbol information Buffer[Line] set to
    // Lines offset.  This produces a per-line
    // map of the offsets for the lines of the
    // given file.  Line numbers are decremented
    // for the map so Buffer[0] contains the offset
    // for line number 1.
    // If there is no line information at all for
    // the given file the method fails rather
    // than returning a map of invalid offsets.
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        __in PCSTR File,
        __out_ecount_opt(BufferLines) PULONG64 Buffer,
        __in ULONG BufferLines,
        __out_opt PULONG FileLines
        ) PURE;

    // IDebugSymbols2.

    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    // Item is specified as in VerQueryValue.
    // Module version information is only
    // available for loaded modules and may
    // not be available in all debug sessions.
    STDMETHOD(GetModuleVersionInformation)(
        THIS_
        __in ULONG Index,
        __in ULONG64 Base,
        __in PCSTR Item,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG VerInfoSize
        ) PURE;
    // Retrieves any available module name string
    // such as module name or symbol file name.
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    // If symbols are deferred an error will
    // be returned.
    // E_NOINTERFACE may be returned, indicating
    // no information exists.
    STDMETHOD(GetModuleNameString)(
        THIS_
        __in ULONG Which,
        __in ULONG Index,
        __in ULONG64 Base,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    // Returns the string name of a constant type.
    STDMETHOD(GetConstantName)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG64 Value,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    // Gets name of a field in a struct
    // FieldNumber is 0 based index of field in a struct
    STDMETHOD(GetFieldName)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG FieldIndex,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    // Control options for typed values.
    STDMETHOD(GetTypeOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddTypeOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveTypeOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetTypeOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
};

//
// GetModuleBy* flags.
//

// Scan all modules, loaded and unloaded.
#define DEBUG_GETMOD_DEFAULT             0x00000000
// Do not scan loaded modules.
#define DEBUG_GETMOD_NO_LOADED_MODULES   0x00000001
// Do not scan unloaded modules.
#define DEBUG_GETMOD_NO_UNLOADED_MODULES 0x00000002

//
// AddSyntheticModule flags.
//

#define DEBUG_ADDSYNTHMOD_DEFAULT 0x00000000

//
// AddSyntheticSymbol flags.
//

#define DEBUG_ADDSYNTHSYM_DEFAULT 0x00000000

//
// OutputSymbolByOffset flags.
//

// Use the current debugger settings for symbol output.
#define DEBUG_OUTSYM_DEFAULT            0x00000000
// Always display the offset in addition to any symbol hit.
#define DEBUG_OUTSYM_FORCE_OFFSET       0x00000001
// Display source line information if found.
#define DEBUG_OUTSYM_SOURCE_LINE        0x00000002
// Output symbol hits that don't exactly match.
#define DEBUG_OUTSYM_ALLOW_DISPLACEMENT 0x00000004

//
// GetFunctionEntryByOffset flags.
//

#define DEBUG_GETFNENT_DEFAULT        0x00000000
// The engine provides artificial entries for well-known
// cases.  This flag limits the entry search to only
// the raw entries and disables artificial entry lookup.
#define DEBUG_GETFNENT_RAW_ENTRY_ONLY 0x00000001

typedef struct _DEBUG_MODULE_AND_ID
{
    ULONG64 ModuleBase;
    ULONG64 Id;
} DEBUG_MODULE_AND_ID, *PDEBUG_MODULE_AND_ID;

#define DEBUG_SOURCE_IS_STATEMENT 0x00000001

//
// GetSourceEntriesByLine flags.
//

#define DEBUG_GSEL_DEFAULT         0x00000000
// Do not allow any extra symbols to load during the search.
#define DEBUG_GSEL_NO_SYMBOL_LOADS 0x00000001
// Allow source hits with lower line numbers.
#define DEBUG_GSEL_ALLOW_LOWER     0x00000002
// Allow source hits with higher line numbers.
#define DEBUG_GSEL_ALLOW_HIGHER    0x00000004
// Only return the nearest hits.
#define DEBUG_GSEL_NEAREST_ONLY    0x00000008

typedef struct _DEBUG_SYMBOL_SOURCE_ENTRY
{
    ULONG64 ModuleBase;
    ULONG64 Offset;
    ULONG64 FileNameId;
    ULONG64 EngineInternal;
    ULONG Size;
    ULONG Flags;
    ULONG FileNameSize;
    // Line numbers are one-based.
    // May be DEBUG_ANY_ID if unknown.
    ULONG StartLine;
    ULONG EndLine;
    // Column numbers are one-based byte indices.
    // May be DEBUG_ANY_ID if unknown.
    ULONG StartColumn;
    ULONG EndColumn;
    ULONG Reserved;
} DEBUG_SYMBOL_SOURCE_ENTRY, *PDEBUG_SYMBOL_SOURCE_ENTRY;

#undef INTERFACE
#define INTERFACE IDebugSymbols3
DECLARE_INTERFACE_(IDebugSymbols3, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbols.

    // Controls the symbol options used during
    // symbol operations.
    // Uses the same flags as dbghelps SymSetOptions.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetSymbolOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    STDMETHOD(GetNameByOffset)(
        THIS_
        __in ULONG64 Offset,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Displacement
        ) PURE;
    // A symbol name may not be unique, particularly
    // when overloaded functions exist which all
    // have the same name.  If GetOffsetByName
    // finds multiple matches for the name it
    // can return any one of them.  In that
    // case it will return S_FALSE to indicate
    // that ambiguity was arbitrarily resolved.
    // A caller can then use SearchSymbols to
    // find all of the matches if it wishes to
    // perform different disambiguation.
    STDMETHOD(GetOffsetByName)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG64 Offset
        ) PURE;
    // GetNearNameByOffset returns symbols
    // located near the symbol closest to
    // to the offset, such as the previous
    // or next symbol.  If Delta is zero it
    // operates identically to GetNameByOffset.
    // If Delta is nonzero and such a symbol
    // does not exist an error is returned.
    // The next symbol, if one exists, will
    // always have a higher offset than the
    // input offset so the displacement is
    // always negative.  The situation is
    // reversed for the previous symbol.
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in LONG Delta,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Displacement
        ) PURE;

    STDMETHOD(GetLineByOffset)(
        THIS_
        __in ULONG64 Offset,
        __out_opt PULONG Line,
        __out_ecount_opt(FileBufferSize) PSTR FileBuffer,
        __in ULONG FileBufferSize,
        __out_opt PULONG FileSize,
        __out_opt PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByLine)(
        THIS_
        __in ULONG Line,
        __in PCSTR File,
        __out PULONG64 Offset
        ) PURE;

    // Enumerates the engines list of modules
    // loaded for the current process.  This may
    // or may not match the system module list
    // for the process.  Reload can be used to
    // synchronize the engines list with the system
    // if necessary.
    // Some sessions also track recently unloaded
    // code modules for help in analyzing failures
    // where an attempt is made to call unloaded code.
    // These modules are indexed after the loaded
    // modules.
    STDMETHOD(GetNumberModules)(
        THIS_
        __out PULONG Loaded,
        __out PULONG Unloaded
        ) PURE;
    STDMETHOD(GetModuleByIndex)(
        THIS_
        __in ULONG Index,
        __out PULONG64 Base
        ) PURE;
    // The module name may not be unique.
    // This method returns the first match.
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        __in PCSTR Name,
        __in ULONG StartIndex,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    // Offset can be any offset within
    // the module extent.  Extents may
    // not be unique when including unloaded
    // drivers.  This method returns the
    // first match.
    STDMETHOD(GetModuleByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG StartIndex,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    STDMETHOD(GetModuleNames)(
        THIS_
        __in ULONG Index,
        __in ULONG64 Base,
        __out_ecount_opt(ImageNameBufferSize) PSTR ImageNameBuffer,
        __in ULONG ImageNameBufferSize,
        __out_opt PULONG ImageNameSize,
        __out_ecount_opt(ModuleNameBufferSize) PSTR ModuleNameBuffer,
        __in ULONG ModuleNameBufferSize,
        __out_opt PULONG ModuleNameSize,
        __out_ecount_opt(LoadedImageNameBufferSize) PSTR LoadedImageNameBuffer,
        __in ULONG LoadedImageNameBufferSize,
        __out_opt PULONG LoadedImageNameSize
        ) PURE;
    STDMETHOD(GetModuleParameters)(
        THIS_
        __in ULONG Count,
        __in_ecount_opt(Count) PULONG64 Bases,
        __in ULONG Start,
        __out_ecount(Count) PDEBUG_MODULE_PARAMETERS Params
        ) PURE;
    // Looks up the module from a <Module>!<Symbol>
    // string.
    STDMETHOD(GetSymbolModule)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG64 Base
        ) PURE;

    // Returns the string name of a type.
    STDMETHOD(GetTypeName)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    // Returns the ID for a type name.
    STDMETHOD(GetTypeId)(
        THIS_
        __in ULONG64 Module,
        __in PCSTR Name,
        __out PULONG TypeId
        ) PURE;
    STDMETHOD(GetTypeSize)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out PULONG Size
        ) PURE;
    // Given a type which can contain members
    // this method returns the offset of a
    // particular member within the type.
    // TypeId should give the container type ID
    // and Field gives the dot-separated path
    // to the field of interest.
    STDMETHOD(GetFieldOffset)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in PCSTR Field,
        __out PULONG Offset
        ) PURE;

    STDMETHOD(GetSymbolTypeId)(
        THIS_
        __in PCSTR Symbol,
        __out PULONG TypeId,
        __out_opt PULONG64 Module
        ) PURE;
    // As with GetOffsetByName a symbol's
    // name may be ambiguous.  GetOffsetTypeId
    // returns the type for the symbol closest
    // to the given offset and can be used
    // to avoid ambiguity.
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG TypeId,
        __out_opt PULONG64 Module
        ) PURE;

    // Helpers for virtual and physical data
    // which combine creation of a location with
    // the actual operation.
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG Flags
        ) PURE;
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in_bcount(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 Offset,
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG Flags
        ) PURE;

    // Function arguments and scope block symbols
    // can be retrieved relative to currently
    // executing code.  A caller can provide just
    // a code offset for scoping purposes and look
    // up names or the caller can provide a full frame
    // and look up actual values.  The values for
    // scoped symbols are best-guess and may or may not
    // be accurate depending on program optimizations,
    // the machine architecture, the current point
    // in the programs execution and so on.
    // A caller can also provide a complete register
    // context for setting a scope to a previous
    // machine state such as a context saved for
    // an exception.  Usually this isnt necessary
    // and the current register context is used.
    STDMETHOD(GetScope)(
        THIS_
        __out_opt PULONG64 InstructionOffset,
        __out_opt PDEBUG_STACK_FRAME ScopeFrame,
        __out_bcount_opt(ScopeContextSize) PVOID ScopeContext,
        __in ULONG ScopeContextSize
        ) PURE;
    // If ScopeFrame or ScopeContext is non-NULL then
    // InstructionOffset is ignored.
    // If ScopeContext is NULL the current
    // register context is used.
    // If the scope identified by the given
    // information is the same as before
    // SetScope returns S_OK.  If the scope
    // information changes, such as when the
    // scope moves between functions or scope
    // blocks, SetScope returns S_FALSE.
    STDMETHOD(SetScope)(
        THIS_
        __in ULONG64 InstructionOffset,
        __in_opt PDEBUG_STACK_FRAME ScopeFrame,
        __in_bcount_opt(ScopeContextSize) PVOID ScopeContext,
        __in ULONG ScopeContextSize
        ) PURE;
    // ResetScope clears the scope information
    // for situations where scoped symbols
    // mask global symbols or when resetting
    // from explicit information to the current
    // information.
    STDMETHOD(ResetScope)(
        THIS
        ) PURE;
    // A scope symbol is tied to its particular
    // scope and only is meaningful within the scope.
    // The returned group can be updated by passing it back
    // into the method for lower-cost
    // incremental updates when stepping.
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        __in ULONG Flags,
        __in_opt PDEBUG_SYMBOL_GROUP Update,
        __out PDEBUG_SYMBOL_GROUP* Symbols
        ) PURE;

    // Create a new symbol group.
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        __out PDEBUG_SYMBOL_GROUP* Group
        ) PURE;

    // StartSymbolMatch matches symbol names
    // against the given pattern using simple
    // regular expressions.  The search results
    // are iterated through using GetNextSymbolMatch.
    // When the caller is done examining results
    // the match should be freed via EndSymbolMatch.
    // If the match pattern contains a module name
    // the search is restricted to a single module.
    // Pattern matching is only done on symbol names,
    // not module names.
    // All active symbol match handles are invalidated
    // when the set of loaded symbols changes.
    STDMETHOD(StartSymbolMatch)(
        THIS_
        __in PCSTR Pattern,
        __out PULONG64 Handle
        ) PURE;
    // If Buffer is NULL the match does not
    // advance.
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        __in ULONG64 Handle,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MatchSize,
        __out_opt PULONG64 Offset
        ) PURE;
    STDMETHOD(EndSymbolMatch)(
        THIS_
        __in ULONG64 Handle
        ) PURE;

    STDMETHOD(Reload)(
        THIS_
        __in PCSTR Module
        ) PURE;

    STDMETHOD(GetSymbolPath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(SetSymbolPath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendSymbolPath)(
        THIS_
        __in PCSTR Addition
        ) PURE;

    // Manipulate the path for executable images.
    // Some dump files need to load executable images
    // in order to resolve dump information.  This
    // path controls where the engine looks for
    // images.
    STDMETHOD(GetImagePath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(SetImagePath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendImagePath)(
        THIS_
        __in PCSTR Addition
        ) PURE;

    // Path routines for source file location
    // methods.
    STDMETHOD(GetSourcePath)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    // Gets the nth part of the source path.
    STDMETHOD(GetSourcePathElement)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ElementSize
        ) PURE;
    STDMETHOD(SetSourcePath)(
        THIS_
        __in PCSTR Path
        ) PURE;
    STDMETHOD(AppendSourcePath)(
        THIS_
        __in PCSTR Addition
        ) PURE;
    // Uses the given file path and the source path
    // information to try and locate an existing file.
    // The given file path is merged with elements
    // of the source path and checked for existence.
    // If a match is found the element used is returned.
    // A starting element can be specified to restrict
    // the search to a subset of the path elements;
    // this can be useful when checking for multiple
    // matches along the source path.
    // The returned element can be 1, indicating
    // the file was found directly and not on the path.
    STDMETHOD(FindSourceFile)(
        THIS_
        __in ULONG StartElement,
        __in PCSTR File,
        __in ULONG Flags,
        __out_opt PULONG FoundElement,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FoundSize
        ) PURE;
    // Retrieves all the line offset information
    // for a particular source file.  Buffer is
    // first intialized to DEBUG_INVALID_OFFSET for
    // every entry.  Then for each piece of line
    // symbol information Buffer[Line] set to
    // Lines offset.  This produces a per-line
    // map of the offsets for the lines of the
    // given file.  Line numbers are decremented
    // for the map so Buffer[0] contains the offset
    // for line number 1.
    // If there is no line information at all for
    // the given file the method fails rather
    // than returning a map of invalid offsets.
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        __in PCSTR File,
        __out_ecount_opt(BufferLines) PULONG64 Buffer,
        __in ULONG BufferLines,
        __out_opt PULONG FileLines
        ) PURE;

    // IDebugSymbols2.

    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    // Item is specified as in VerQueryValue.
    // Module version information is only
    // available for loaded modules and may
    // not be available in all debug sessions.
    STDMETHOD(GetModuleVersionInformation)(
        THIS_
        __in ULONG Index,
        __in ULONG64 Base,
        __in PCSTR Item,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG VerInfoSize
        ) PURE;
    // Retrieves any available module name string
    // such as module name or symbol file name.
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    // If symbols are deferred an error will
    // be returned.
    // E_NOINTERFACE may be returned, indicating
    // no information exists.
    STDMETHOD(GetModuleNameString)(
        THIS_
        __in ULONG Which,
        __in ULONG Index,
        __in ULONG64 Base,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    // Returns the string name of a constant type.
    STDMETHOD(GetConstantName)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG64 Value,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    // Gets name of a field in a struct
    // FieldNumber is 0 based index of field in a struct
    STDMETHOD(GetFieldName)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG FieldIndex,
        __out_ecount_opt(NameBufferSize) PSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    // Control options for typed values.
    STDMETHOD(GetTypeOptions)(
        THIS_
        __out PULONG Options
        ) PURE;
    STDMETHOD(AddTypeOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(RemoveTypeOptions)(
        THIS_
        __in ULONG Options
        ) PURE;
    STDMETHOD(SetTypeOptions)(
        THIS_
        __in ULONG Options
        ) PURE;

    // IDebugSymbols3.

    STDMETHOD(GetNameByOffsetWide)(
        THIS_
        __in ULONG64 Offset,
        __out_ecount_opt(NameBufferSize) PWSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByNameWide)(
        THIS_
        __in PCWSTR Symbol,
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(GetNearNameByOffsetWide)(
        THIS_
        __in ULONG64 Offset,
        __in LONG Delta,
        __out_ecount_opt(NameBufferSize) PWSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize,
        __out_opt PULONG64 Displacement
        ) PURE;

    STDMETHOD(GetLineByOffsetWide)(
        THIS_
        __in ULONG64 Offset,
        __out_opt PULONG Line,
        __out_ecount_opt(FileBufferSize) PWSTR FileBuffer,
        __in ULONG FileBufferSize,
        __out_opt PULONG FileSize,
        __out_opt PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByLineWide)(
        THIS_
        __in ULONG Line,
        __in PCWSTR File,
        __out PULONG64 Offset
        ) PURE;

    STDMETHOD(GetModuleByModuleNameWide)(
        THIS_
        __in PCWSTR Name,
        __in ULONG StartIndex,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    STDMETHOD(GetSymbolModuleWide)(
        THIS_
        __in PCWSTR Symbol,
        __out PULONG64 Base
        ) PURE;

    STDMETHOD(GetTypeNameWide)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __out_ecount_opt(NameBufferSize) PWSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;
    // Returns the ID for a type name.
    STDMETHOD(GetTypeIdWide)(
        THIS_
        __in ULONG64 Module,
        __in PCWSTR Name,
        __out PULONG TypeId
        ) PURE;
    STDMETHOD(GetFieldOffsetWide)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in PCWSTR Field,
        __out PULONG Offset
        ) PURE;

    STDMETHOD(GetSymbolTypeIdWide)(
        THIS_
        __in PCWSTR Symbol,
        __out PULONG TypeId,
        __out_opt PULONG64 Module
        ) PURE;

    STDMETHOD(GetScopeSymbolGroup2)(
        THIS_
        __in ULONG Flags,
        __in_opt PDEBUG_SYMBOL_GROUP2 Update,
        __out PDEBUG_SYMBOL_GROUP2* Symbols
        ) PURE;

    STDMETHOD(CreateSymbolGroup2)(
        THIS_
        __out PDEBUG_SYMBOL_GROUP2* Group
        ) PURE;

    STDMETHOD(StartSymbolMatchWide)(
        THIS_
        __in PCWSTR Pattern,
        __out PULONG64 Handle
        ) PURE;
    STDMETHOD(GetNextSymbolMatchWide)(
        THIS_
        __in ULONG64 Handle,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG MatchSize,
        __out_opt PULONG64 Offset
        ) PURE;

    STDMETHOD(ReloadWide)(
        THIS_
        __in PCWSTR Module
        ) PURE;

    STDMETHOD(GetSymbolPathWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(SetSymbolPathWide)(
        THIS_
        __in PCWSTR Path
        ) PURE;
    STDMETHOD(AppendSymbolPathWide)(
        THIS_
        __in PCWSTR Addition
        ) PURE;

    STDMETHOD(GetImagePathWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(SetImagePathWide)(
        THIS_
        __in PCWSTR Path
        ) PURE;
    STDMETHOD(AppendImagePathWide)(
        THIS_
        __in PCWSTR Addition
        ) PURE;

    STDMETHOD(GetSourcePathWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG PathSize
        ) PURE;
    STDMETHOD(GetSourcePathElementWide)(
        THIS_
        __in ULONG Index,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ElementSize
        ) PURE;
    STDMETHOD(SetSourcePathWide)(
        THIS_
        __in PCWSTR Path
        ) PURE;
    STDMETHOD(AppendSourcePathWide)(
        THIS_
        __in PCWSTR Addition
        ) PURE;
    STDMETHOD(FindSourceFileWide)(
        THIS_
        __in ULONG StartElement,
        __in PCWSTR File,
        __in ULONG Flags,
        __out_opt PULONG FoundElement,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG FoundSize
        ) PURE;
    STDMETHOD(GetSourceFileLineOffsetsWide)(
        THIS_
        __in PCWSTR File,
        __out_ecount_opt(BufferLines) PULONG64 Buffer,
        __in ULONG BufferLines,
        __out_opt PULONG FileLines
        ) PURE;

    STDMETHOD(GetModuleVersionInformationWide)(
        THIS_
        __in ULONG Index,
        __in ULONG64 Base,
        __in PCWSTR Item,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG VerInfoSize
        ) PURE;
    STDMETHOD(GetModuleNameStringWide)(
        THIS_
        __in ULONG Which,
        __in ULONG Index,
        __in ULONG64 Base,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    STDMETHOD(GetConstantNameWide)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG64 Value,
        __out_ecount_opt(NameBufferSize) PWSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    STDMETHOD(GetFieldNameWide)(
        THIS_
        __in ULONG64 Module,
        __in ULONG TypeId,
        __in ULONG FieldIndex,
        __out_ecount_opt(NameBufferSize) PWSTR NameBuffer,
        __in ULONG NameBufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    // Returns S_OK if the engine is using managed
    // debugging support when retriving information
    // for the given module.  This can be expensive
    // to check.
    STDMETHOD(IsManagedModule)(
        THIS_
        __in ULONG Index,
        __in ULONG64 Base
        ) PURE;

    // The module name may not be unique.
    // This method returns the first match.
    STDMETHOD(GetModuleByModuleName2)(
        THIS_
        __in PCSTR Name,
        __in ULONG StartIndex,
        __in ULONG Flags,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    STDMETHOD(GetModuleByModuleName2Wide)(
        THIS_
        __in PCWSTR Name,
        __in ULONG StartIndex,
        __in ULONG Flags,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;
    // Offset can be any offset within
    // the module extent.  Extents may
    // not be unique when including unloaded
    // drivers.  This method returns the
    // first match.
    STDMETHOD(GetModuleByOffset2)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG StartIndex,
        __in ULONG Flags,
        __out_opt PULONG Index,
        __out_opt PULONG64 Base
        ) PURE;

    // A caller can create artificial loaded modules in
    // the engine's module list if desired.
    // These modules only serve as names for
    // a region of addresses.  They cannot have
    // real symbols loaded for them; if that
    // is desired Reload can be used with explicit
    // parameters to create a true module entry.
    // The region must not be in use by any other
    // module.
    // A general reload will discard any synthetic modules.
    STDMETHOD(AddSyntheticModule)(
        THIS_
        __in ULONG64 Base,
        __in ULONG Size,
        __in PCSTR ImagePath,
        __in PCSTR ModuleName,
        __in ULONG Flags
        ) PURE;
    STDMETHOD(AddSyntheticModuleWide)(
        THIS_
        __in ULONG64 Base,
        __in ULONG Size,
        __in PCWSTR ImagePath,
        __in PCWSTR ModuleName,
        __in ULONG Flags
        ) PURE;
    STDMETHOD(RemoveSyntheticModule)(
        THIS_
        __in ULONG64 Base
        ) PURE;

    // Modify the current frame used for scoping.
    // This is equivalent to the '.frame' command.
    STDMETHOD(GetCurrentScopeFrameIndex)(
        THIS_
        __out PULONG Index
        ) PURE;
    STDMETHOD(SetScopeFrameByIndex)(
        THIS_
        __in ULONG Index
        ) PURE;

    // Recovers JIT_DEBUG_INFO information at the given
    // address from the debuggee and sets current
    // debugger scope context from it.
    // Equivalent to '.jdinfo' command.
    STDMETHOD(SetScopeFromJitDebugInfo)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG64 InfoOffset
        ) PURE;

    // Switches the current debugger scope to
    // the stored event information.
    // Equivalent to the '.ecxr' command.
    STDMETHOD(SetScopeFromStoredEvent)(
        THIS
        ) PURE;

    // Takes the first symbol hit and outputs it.
    // Controlled with DEBUG_OUTSYM_* flags.
    STDMETHOD(OutputSymbolByOffset)(
        THIS_
        __in ULONG OutputControl,
        __in ULONG Flags,
        __in ULONG64 Offset
        ) PURE;

    // Function entry information for a particular
    // piece of code can be retrieved by this method.
    // The actual data returned is system-dependent.
    STDMETHOD(GetFunctionEntryByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_bcount_opt(BufferSize) PVOID Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG BufferNeeded
        ) PURE;

    // Given a type which can contain members
    // this method returns the type ID and offset of a
    // particular member within the type.
    // Field gives the dot-separated path
    // to the field of interest.
    STDMETHOD(GetFieldTypeAndOffset)(
        THIS_
        __in ULONG64 Module,
        __in ULONG ContainerTypeId,
        __in PCSTR Field,
        __out_opt PULONG FieldTypeId,
        __out_opt PULONG Offset
        ) PURE;
    STDMETHOD(GetFieldTypeAndOffsetWide)(
        THIS_
        __in ULONG64 Module,
        __in ULONG ContainerTypeId,
        __in PCWSTR Field,
        __out_opt PULONG FieldTypeId,
        __out_opt PULONG Offset
        ) PURE;

    // Artificial symbols can be created in any
    // existing module as a way to name an address.
    // The address must not already have symbol
    // information.
    // A reload will discard synthetic symbols
    // for all address regions reloaded.
    STDMETHOD(AddSyntheticSymbol)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Size,
        __in PCSTR Name,
        __in ULONG Flags,
        __out_opt PDEBUG_MODULE_AND_ID Id
        ) PURE;
    STDMETHOD(AddSyntheticSymbolWide)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Size,
        __in PCWSTR Name,
        __in ULONG Flags,
        __out_opt PDEBUG_MODULE_AND_ID Id
        ) PURE;
    STDMETHOD(RemoveSyntheticSymbol)(
        THIS_
        __in PDEBUG_MODULE_AND_ID Id
        ) PURE;

    // The following methods can return multiple
    // hits for symbol lookups to allow for all
    // possible hits to be returned.
    STDMETHOD(GetSymbolEntriesByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_ecount_opt(IdsCount) PDEBUG_MODULE_AND_ID Ids,
        __out_ecount_opt(IdsCount) PULONG64 Displacements,
        __in ULONG IdsCount,
        __out_opt PULONG Entries
        ) PURE;
    STDMETHOD(GetSymbolEntriesByName)(
        THIS_
        __in PCSTR Symbol,
        __in ULONG Flags,
        __out_ecount_opt(IdsCount) PDEBUG_MODULE_AND_ID Ids,
        __in ULONG IdsCount,
        __out_opt PULONG Entries
        ) PURE;
    STDMETHOD(GetSymbolEntriesByNameWide)(
        THIS_
        __in PCWSTR Symbol,
        __in ULONG Flags,
        __out_ecount_opt(IdsCount) PDEBUG_MODULE_AND_ID Ids,
        __in ULONG IdsCount,
        __out_opt PULONG Entries
        ) PURE;
    // Symbol lookup by managed metadata token.
    STDMETHOD(GetSymbolEntryByToken)(
        THIS_
        __in ULONG64 ModuleBase,
        __in ULONG Token,
        __out PDEBUG_MODULE_AND_ID Id
        ) PURE;

    // Retrieves full symbol entry information from an ID.
    STDMETHOD(GetSymbolEntryInformation)(
        THIS_
        __in PDEBUG_MODULE_AND_ID Id,
        __out PDEBUG_SYMBOL_ENTRY Info
        ) PURE;
    STDMETHOD(GetSymbolEntryString)(
        THIS_
        __in PDEBUG_MODULE_AND_ID Id,
        __in ULONG Which,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringSize
        ) PURE;
    STDMETHOD(GetSymbolEntryStringWide)(
        THIS_
        __in PDEBUG_MODULE_AND_ID Id,
        __in ULONG Which,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringSize
        ) PURE;
    // Returns all known memory regions associated
    // with the given symbol.  Simple symbols will
    // have a single region starting from their base.
    // More complicated regions, such as functions
    // with multiple code areas, can have an arbitrarily
    // large number of regions.
    // The quality of information returned is highly
    // dependent on the symbolic information availble.
    STDMETHOD(GetSymbolEntryOffsetRegions)(
        THIS_
        __in PDEBUG_MODULE_AND_ID Id,
        __in ULONG Flags,
        __out_ecount_opt(RegionsCount) PDEBUG_OFFSET_REGION Regions,
        __in ULONG RegionsCount,
        __out_opt PULONG RegionsAvail
        ) PURE;

    // This method allows navigating within the
    // symbol entry hierarchy.
    STDMETHOD(GetSymbolEntryBySymbolEntry)(
        THIS_
        __in PDEBUG_MODULE_AND_ID FromId,
        __in ULONG Flags,
        __out PDEBUG_MODULE_AND_ID ToId
        ) PURE;

    // The following methods can return multiple
    // hits for source lookups to allow for all
    // possible hits to be returned.
    STDMETHOD(GetSourceEntriesByOffset)(
        THIS_
        __in ULONG64 Offset,
        __in ULONG Flags,
        __out_ecount_opt(EntriesCount) PDEBUG_SYMBOL_SOURCE_ENTRY Entries,
        __in ULONG EntriesCount,
        __out_opt PULONG EntriesAvail
        ) PURE;
    STDMETHOD(GetSourceEntriesByLine)(
        THIS_
        __in ULONG Line,
        __in PCSTR File,
        __in ULONG Flags,
        __out_ecount_opt(EntriesCount) PDEBUG_SYMBOL_SOURCE_ENTRY Entries,
        __in ULONG EntriesCount,
        __out_opt PULONG EntriesAvail
        ) PURE;
    STDMETHOD(GetSourceEntriesByLineWide)(
        THIS_
        __in ULONG Line,
        __in PCWSTR File,
        __in ULONG Flags,
        __out_ecount_opt(EntriesCount) PDEBUG_SYMBOL_SOURCE_ENTRY Entries,
        __in ULONG EntriesCount,
        __out_opt PULONG EntriesAvail
        ) PURE;

    STDMETHOD(GetSourceEntryString)(
        THIS_
        __in PDEBUG_SYMBOL_SOURCE_ENTRY Entry,
        __in ULONG Which,
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringSize
        ) PURE;
    STDMETHOD(GetSourceEntryStringWide)(
        THIS_
        __in PDEBUG_SYMBOL_SOURCE_ENTRY Entry,
        __in ULONG Which,
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG StringSize
        ) PURE;
    // Returns all known memory regions associated
    // with the given source entry.  As with
    // GetSymbolEntryOffsetRegions the regions available
    // are variable.
    STDMETHOD(GetSourceEntryOffsetRegions)(
        THIS_
        __in PDEBUG_SYMBOL_SOURCE_ENTRY Entry,
        __in ULONG Flags,
        __out_ecount_opt(RegionsCount) PDEBUG_OFFSET_REGION Regions,
        __in ULONG RegionsCount,
        __out_opt PULONG RegionsAvail
        ) PURE;

    // This method allows navigating within the
    // source entries.
    STDMETHOD(GetSourceEntryBySourceEntry)(
        THIS_
        __in PDEBUG_SYMBOL_SOURCE_ENTRY FromEntry,
        __in ULONG Flags,
        __out PDEBUG_SYMBOL_SOURCE_ENTRY ToEntry
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSystemObjects
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugSystemObjects
DECLARE_INTERFACE_(IDebugSystemObjects, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSystemObjects.

    // In user mode debugging the debugger
    // tracks all threads and processes and
    // enumerates them through the following
    // methods.  When enumerating threads
    // the threads are enumerated for the current
    // process.
    // Kernel mode debugging currently is
    // limited to enumerating only the threads
    // assigned to processors, not all of
    // the threads in the system.  Process
    // enumeration is limited to a single
    // virtual process representing kernel space.

    // Returns the ID of the thread on which
    // the last event occurred.
    STDMETHOD(GetEventThread)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetEventProcess)(
        THIS_
        __out PULONG Id
        ) PURE;

    // Controls implicit thread used by the
    // debug engine.  The debuggers current
    // thread is just a piece of data held
    // by the debugger for calls which use
    // thread-specific information.  In those
    // calls the debuggers current thread is used.
    // The debuggers current thread is not related
    // to any system thread attribute.
    // IDs for threads are small integer IDs
    // maintained by the engine.  They are not
    // related to system thread IDs.
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        __in ULONG Id
        ) PURE;
    // The current process is the process
    // that owns the current thread.
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        __out PULONG Id
        ) PURE;
    // Setting the current process automatically
    // sets the current thread to the thread that
    // was last current in that process.
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        __in ULONG Id
        ) PURE;

    // Gets the number of threads in the current process.
    STDMETHOD(GetNumberThreads)(
        THIS_
        __out PULONG Number
        ) PURE;
    // Gets thread count information for all processes
    // and the largest number of threads in a single process.
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        __out PULONG Total,
        __out PULONG LargestProcess
        ) PURE;
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount_opt(Count) PULONG Ids,
        __out_ecount_opt(Count) PULONG SysIds
        ) PURE;
    // Gets the debugger ID for the thread
    // currently running on the given
    // processor.  Only works in kernel
    // debugging.
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        __in ULONG Processor,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // system data structure.  When kernel debugging
    // this is the offset of the KTHREAD.
    // When user debugging it is the offset
    // of the current TEB.
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread data structure.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // TEB.  In user mode this is equivalent to
    // the threads data offset.
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given TEB.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the system unique ID for the current thread.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        __out PULONG SysId
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread ID.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        __in ULONG SysId,
        __out PULONG Id
        ) PURE;
    // Returns the handle of the current thread.
    // In kernel mode the value returned is the
    // index of the processor the thread is
    // executing on plus one.
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    // Looks up a debugger thread ID for the given handle.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        __in ULONG64 Handle,
        __out PULONG Id
        ) PURE;

    // Currently kernel mode sessions will only have
    // a single process representing kernel space.
    STDMETHOD(GetNumberProcesses)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount_opt(Count) PULONG Ids,
        __out_ecount_opt(Count) PULONG SysIds
        ) PURE;
    // Returns the offset of the current processs
    // system data structure.  When kernel debugging
    // this is the offset of the KPROCESS of
    // the process that owns the current thread.
    // When user debugging it is the offset
    // of the current PEB.
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process data structure.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current processs
    // PEB.  In user mode this is equivalent to
    // the processs data offset.
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given PEB.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the system unique ID for the current process.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        __out PULONG SysId
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process ID.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_
        __in ULONG SysId,
        __out PULONG Id
        ) PURE;
    // Returns the handle of the current process.
    // In kernel mode this is the kernel processs
    // artificial handle used for symbol operations
    // and so can only be used with dbghelp APIs.
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    // Looks up a debugger process ID for the given handle.
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        __in ULONG64 Handle,
        __out PULONG Id
        ) PURE;
    // Retrieve the name of the executable loaded
    // in the process.  This may fail if no executable
    // was identified.
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ExeSize
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugSystemObjects2
DECLARE_INTERFACE_(IDebugSystemObjects2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSystemObjects.

    // In user mode debugging the debugger
    // tracks all threads and processes and
    // enumerates them through the following
    // methods.  When enumerating threads
    // the threads are enumerated for the current
    // process.
    // Kernel mode debugging currently is
    // limited to enumerating only the threads
    // assigned to processors, not all of
    // the threads in the system.  Process
    // enumeration is limited to a single
    // virtual process representing kernel space.

    // Returns the ID of the thread on which
    // the last event occurred.
    STDMETHOD(GetEventThread)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetEventProcess)(
        THIS_
        __out PULONG Id
        ) PURE;

    // Controls implicit thread used by the
    // debug engine.  The debuggers current
    // thread is just a piece of data held
    // by the debugger for calls which use
    // thread-specific information.  In those
    // calls the debuggers current thread is used.
    // The debuggers current thread is not related
    // to any system thread attribute.
    // IDs for threads are small integer IDs
    // maintained by the engine.  They are not
    // related to system thread IDs.
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        __in ULONG Id
        ) PURE;
    // The current process is the process
    // that owns the current thread.
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        __out PULONG Id
        ) PURE;
    // Setting the current process automatically
    // sets the current thread to the thread that
    // was last current in that process.
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        __in ULONG Id
        ) PURE;

    // Gets the number of threads in the current process.
    STDMETHOD(GetNumberThreads)(
        THIS_
        __out PULONG Number
        ) PURE;
    // Gets thread count information for all processes
    // and the largest number of threads in a single process.
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        __out PULONG Total,
        __out PULONG LargestProcess
        ) PURE;
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount_opt(Count) PULONG Ids,
        __out_ecount_opt(Count) PULONG SysIds
        ) PURE;
    // Gets the debugger ID for the thread
    // currently running on the given
    // processor.  Only works in kernel
    // debugging.
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        __in ULONG Processor,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // system data structure.  When kernel debugging
    // this is the offset of the KTHREAD.
    // When user debugging it is the offset
    // of the current TEB.
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread data structure.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // TEB.  In user mode this is equivalent to
    // the threads data offset.
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given TEB.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the system unique ID for the current thread.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        __out PULONG SysId
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread ID.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        __in ULONG SysId,
        __out PULONG Id
        ) PURE;
    // Returns the handle of the current thread.
    // In kernel mode the value returned is the
    // index of the processor the thread is
    // executing on plus one.
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    // Looks up a debugger thread ID for the given handle.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        __in ULONG64 Handle,
        __out PULONG Id
        ) PURE;

    // Currently kernel mode sessions will only have
    // a single process representing kernel space.
    STDMETHOD(GetNumberProcesses)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount_opt(Count) PULONG Ids,
        __out_ecount_opt(Count) PULONG SysIds
        ) PURE;
    // Returns the offset of the current processs
    // system data structure.  When kernel debugging
    // this is the offset of the KPROCESS of
    // the process that owns the current thread.
    // When user debugging it is the offset
    // of the current PEB.
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process data structure.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current processs
    // PEB.  In user mode this is equivalent to
    // the processs data offset.
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given PEB.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the system unique ID for the current process.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        __out PULONG SysId
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process ID.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_
        __in ULONG SysId,
        __out PULONG Id
        ) PURE;
    // Returns the handle of the current process.
    // In kernel mode this is the kernel processs
    // artificial handle used for symbol operations
    // and so can only be used with dbghelp APIs.
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    // Looks up a debugger process ID for the given handle.
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        __in ULONG64 Handle,
        __out PULONG Id
        ) PURE;
    // Retrieve the name of the executable loaded
    // in the process.  This may fail if no executable
    // was identified.
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ExeSize
        ) PURE;

    // IDebugSystemObjects2.

    // Return the number of seconds that the current
    // process has been running.
    STDMETHOD(GetCurrentProcessUpTime)(
        THIS_
        __out PULONG UpTime
        ) PURE;

    // During kernel sessions the debugger retrieves
    // some information from the system thread and process
    // running on the current processor.  For example,
    // the debugger will retrieve virtual memory translation
    // information for when the debugger needs to
    // carry out its own virtual to physical translations.
    // Occasionally it can be interesting to perform
    // similar operations but on a process which isnt
    // currently running.  The follow methods allow a caller
    // to override the data offsets used by the debugger
    // so that other system threads and processes can
    // be used instead.  These values are defaulted to
    // the thread and process running on the current
    // processor each time the debuggee executes or
    // the current processor changes.
    // The thread and process settings are independent so
    // it is possible to refer to a thread in a process
    // other than the current process and vice versa.
    // Setting an offset of zero will reload the
    // default value.
    STDMETHOD(GetImplicitThreadDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitThreadDataOffset)(
        THIS_
        __in ULONG64 Offset
        ) PURE;
    STDMETHOD(GetImplicitProcessDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitProcessDataOffset)(
        THIS_
        __in ULONG64 Offset
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugSystemObjects3
DECLARE_INTERFACE_(IDebugSystemObjects3, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSystemObjects.

    // In user mode debugging the debugger
    // tracks all threads and processes and
    // enumerates them through the following
    // methods.  When enumerating threads
    // the threads are enumerated for the current
    // process.
    // Kernel mode debugging currently is
    // limited to enumerating only the threads
    // assigned to processors, not all of
    // the threads in the system.  Process
    // enumeration is limited to a single
    // virtual process representing kernel space.

    // Returns the ID of the thread on which
    // the last event occurred.
    STDMETHOD(GetEventThread)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetEventProcess)(
        THIS_
        __out PULONG Id
        ) PURE;

    // Controls implicit thread used by the
    // debug engine.  The debuggers current
    // thread is just a piece of data held
    // by the debugger for calls which use
    // thread-specific information.  In those
    // calls the debuggers current thread is used.
    // The debuggers current thread is not related
    // to any system thread attribute.
    // IDs for threads are small integer IDs
    // maintained by the engine.  They are not
    // related to system thread IDs.
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        __in ULONG Id
        ) PURE;
    // The current process is the process
    // that owns the current thread.
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        __out PULONG Id
        ) PURE;
    // Setting the current process automatically
    // sets the current thread to the thread that
    // was last current in that process.
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        __in ULONG Id
        ) PURE;

    // Gets the number of threads in the current process.
    STDMETHOD(GetNumberThreads)(
        THIS_
        __out PULONG Number
        ) PURE;
    // Gets thread count information for all processes
    // and the largest number of threads in a single process.
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        __out PULONG Total,
        __out PULONG LargestProcess
        ) PURE;
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount_opt(Count) PULONG Ids,
        __out_ecount_opt(Count) PULONG SysIds
        ) PURE;
    // Gets the debugger ID for the thread
    // currently running on the given
    // processor.  Only works in kernel
    // debugging.
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        __in ULONG Processor,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // system data structure.  When kernel debugging
    // this is the offset of the KTHREAD.
    // When user debugging it is the offset
    // of the current TEB.
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread data structure.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // TEB.  In user mode this is equivalent to
    // the threads data offset.
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given TEB.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the system unique ID for the current thread.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        __out PULONG SysId
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread ID.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        __in ULONG SysId,
        __out PULONG Id
        ) PURE;
    // Returns the handle of the current thread.
    // In kernel mode the value returned is the
    // index of the processor the thread is
    // executing on plus one.
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    // Looks up a debugger thread ID for the given handle.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        __in ULONG64 Handle,
        __out PULONG Id
        ) PURE;

    // Currently kernel mode sessions will only have
    // a single process representing kernel space.
    STDMETHOD(GetNumberProcesses)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount_opt(Count) PULONG Ids,
        __out_ecount_opt(Count) PULONG SysIds
        ) PURE;
    // Returns the offset of the current processs
    // system data structure.  When kernel debugging
    // this is the offset of the KPROCESS of
    // the process that owns the current thread.
    // When user debugging it is the offset
    // of the current PEB.
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process data structure.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current processs
    // PEB.  In user mode this is equivalent to
    // the processs data offset.
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given PEB.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the system unique ID for the current process.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        __out PULONG SysId
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process ID.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_
        __in ULONG SysId,
        __out PULONG Id
        ) PURE;
    // Returns the handle of the current process.
    // In kernel mode this is the kernel processs
    // artificial handle used for symbol operations
    // and so can only be used with dbghelp APIs.
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    // Looks up a debugger process ID for the given handle.
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        __in ULONG64 Handle,
        __out PULONG Id
        ) PURE;
    // Retrieve the name of the executable loaded
    // in the process.  This may fail if no executable
    // was identified.
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ExeSize
        ) PURE;

    // IDebugSystemObjects2.

    // Return the number of seconds that the current
    // process has been running.
    STDMETHOD(GetCurrentProcessUpTime)(
        THIS_
        __out PULONG UpTime
        ) PURE;

    // During kernel sessions the debugger retrieves
    // some information from the system thread and process
    // running on the current processor.  For example,
    // the debugger will retrieve virtual memory translation
    // information for when the debugger needs to
    // carry out its own virtual to physical translations.
    // Occasionally it can be interesting to perform
    // similar operations but on a process which isnt
    // currently running.  The follow methods allow a caller
    // to override the data offsets used by the debugger
    // so that other system threads and processes can
    // be used instead.  These values are defaulted to
    // the thread and process running on the current
    // processor each time the debuggee executes or
    // the current processor changes.
    // The thread and process settings are independent so
    // it is possible to refer to a thread in a process
    // other than the current process and vice versa.
    // Setting an offset of zero will reload the
    // default value.
    STDMETHOD(GetImplicitThreadDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitThreadDataOffset)(
        THIS_
        __in ULONG64 Offset
        ) PURE;
    STDMETHOD(GetImplicitProcessDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitProcessDataOffset)(
        THIS_
        __in ULONG64 Offset
        ) PURE;

    // IDebugSystemObjects3.

    STDMETHOD(GetEventSystem)(
        THIS_
        __out PULONG Id
        ) PURE;

    STDMETHOD(GetCurrentSystemId)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentSystemId)(
        THIS_
        __in ULONG Id
        ) PURE;

    STDMETHOD(GetNumberSystems)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetSystemIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Ids
        ) PURE;
    STDMETHOD(GetTotalNumberThreadsAndProcesses)(
        THIS_
        __out PULONG TotalThreads,
        __out PULONG TotalProcesses,
        __out PULONG LargestProcessThreads,
        __out PULONG LargestSystemThreads,
        __out PULONG LargestSystemProcesses
        ) PURE;
    STDMETHOD(GetCurrentSystemServer)(
        THIS_
        __out PULONG64 Server
        ) PURE;
    STDMETHOD(GetSystemByServer)(
        THIS_
        __in ULONG64 Server,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetCurrentSystemServerName)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugSystemObjects4
DECLARE_INTERFACE_(IDebugSystemObjects4, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSystemObjects.

    // In user mode debugging the debugger
    // tracks all threads and processes and
    // enumerates them through the following
    // methods.  When enumerating threads
    // the threads are enumerated for the current
    // process.
    // Kernel mode debugging currently is
    // limited to enumerating only the threads
    // assigned to processors, not all of
    // the threads in the system.  Process
    // enumeration is limited to a single
    // virtual process representing kernel space.

    // Returns the ID of the thread on which
    // the last event occurred.
    STDMETHOD(GetEventThread)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetEventProcess)(
        THIS_
        __out PULONG Id
        ) PURE;

    // Controls implicit thread used by the
    // debug engine.  The debuggers current
    // thread is just a piece of data held
    // by the debugger for calls which use
    // thread-specific information.  In those
    // calls the debuggers current thread is used.
    // The debuggers current thread is not related
    // to any system thread attribute.
    // IDs for threads are small integer IDs
    // maintained by the engine.  They are not
    // related to system thread IDs.
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        __in ULONG Id
        ) PURE;
    // The current process is the process
    // that owns the current thread.
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        __out PULONG Id
        ) PURE;
    // Setting the current process automatically
    // sets the current thread to the thread that
    // was last current in that process.
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        __in ULONG Id
        ) PURE;

    // Gets the number of threads in the current process.
    STDMETHOD(GetNumberThreads)(
        THIS_
        __out PULONG Number
        ) PURE;
    // Gets thread count information for all processes
    // and the largest number of threads in a single process.
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        __out PULONG Total,
        __out PULONG LargestProcess
        ) PURE;
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount_opt(Count) PULONG Ids,
        __out_ecount_opt(Count) PULONG SysIds
        ) PURE;
    // Gets the debugger ID for the thread
    // currently running on the given
    // processor.  Only works in kernel
    // debugging.
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        __in ULONG Processor,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // system data structure.  When kernel debugging
    // this is the offset of the KTHREAD.
    // When user debugging it is the offset
    // of the current TEB.
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread data structure.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // TEB.  In user mode this is equivalent to
    // the threads data offset.
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given TEB.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the system unique ID for the current thread.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        __out PULONG SysId
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread ID.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        __in ULONG SysId,
        __out PULONG Id
        ) PURE;
    // Returns the handle of the current thread.
    // In kernel mode the value returned is the
    // index of the processor the thread is
    // executing on plus one.
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    // Looks up a debugger thread ID for the given handle.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        __in ULONG64 Handle,
        __out PULONG Id
        ) PURE;

    // Currently kernel mode sessions will only have
    // a single process representing kernel space.
    STDMETHOD(GetNumberProcesses)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount_opt(Count) PULONG Ids,
        __out_ecount_opt(Count) PULONG SysIds
        ) PURE;
    // Returns the offset of the current processs
    // system data structure.  When kernel debugging
    // this is the offset of the KPROCESS of
    // the process that owns the current thread.
    // When user debugging it is the offset
    // of the current PEB.
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process data structure.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the offset of the current processs
    // PEB.  In user mode this is equivalent to
    // the processs data offset.
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given PEB.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        __in ULONG64 Offset,
        __out PULONG Id
        ) PURE;
    // Returns the system unique ID for the current process.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        __out PULONG SysId
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process ID.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_
        __in ULONG SysId,
        __out PULONG Id
        ) PURE;
    // Returns the handle of the current process.
    // In kernel mode this is the kernel processs
    // artificial handle used for symbol operations
    // and so can only be used with dbghelp APIs.
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        __out PULONG64 Handle
        ) PURE;
    // Looks up a debugger process ID for the given handle.
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        __in ULONG64 Handle,
        __out PULONG Id
        ) PURE;
    // Retrieve the name of the executable loaded
    // in the process.  This may fail if no executable
    // was identified.
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ExeSize
        ) PURE;

    // IDebugSystemObjects2.

    // Return the number of seconds that the current
    // process has been running.
    STDMETHOD(GetCurrentProcessUpTime)(
        THIS_
        __out PULONG UpTime
        ) PURE;

    // During kernel sessions the debugger retrieves
    // some information from the system thread and process
    // running on the current processor.  For example,
    // the debugger will retrieve virtual memory translation
    // information for when the debugger needs to
    // carry out its own virtual to physical translations.
    // Occasionally it can be interesting to perform
    // similar operations but on a process which isnt
    // currently running.  The follow methods allow a caller
    // to override the data offsets used by the debugger
    // so that other system threads and processes can
    // be used instead.  These values are defaulted to
    // the thread and process running on the current
    // processor each time the debuggee executes or
    // the current processor changes.
    // The thread and process settings are independent so
    // it is possible to refer to a thread in a process
    // other than the current process and vice versa.
    // Setting an offset of zero will reload the
    // default value.
    STDMETHOD(GetImplicitThreadDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitThreadDataOffset)(
        THIS_
        __in ULONG64 Offset
        ) PURE;
    STDMETHOD(GetImplicitProcessDataOffset)(
        THIS_
        __out PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitProcessDataOffset)(
        THIS_
        __in ULONG64 Offset
        ) PURE;

    // IDebugSystemObjects3.

    STDMETHOD(GetEventSystem)(
        THIS_
        __out PULONG Id
        ) PURE;

    STDMETHOD(GetCurrentSystemId)(
        THIS_
        __out PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentSystemId)(
        THIS_
        __in ULONG Id
        ) PURE;

    STDMETHOD(GetNumberSystems)(
        THIS_
        __out PULONG Number
        ) PURE;
    STDMETHOD(GetSystemIdsByIndex)(
        THIS_
        __in ULONG Start,
        __in ULONG Count,
        __out_ecount(Count) PULONG Ids
        ) PURE;
    STDMETHOD(GetTotalNumberThreadsAndProcesses)(
        THIS_
        __out PULONG TotalThreads,
        __out PULONG TotalProcesses,
        __out PULONG LargestProcessThreads,
        __out PULONG LargestSystemThreads,
        __out PULONG LargestSystemProcesses
        ) PURE;
    STDMETHOD(GetCurrentSystemServer)(
        THIS_
        __out PULONG64 Server
        ) PURE;
    STDMETHOD(GetSystemByServer)(
        THIS_
        __in ULONG64 Server,
        __out PULONG Id
        ) PURE;
    STDMETHOD(GetCurrentSystemServerName)(
        THIS_
        __out_ecount_opt(BufferSize) PSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;

    // IDebugSystemObjects4.

    STDMETHOD(GetCurrentProcessExecutableNameWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG ExeSize
        ) PURE;

    STDMETHOD(GetCurrentSystemServerNameWide)(
        THIS_
        __out_ecount_opt(BufferSize) PWSTR Buffer,
        __in ULONG BufferSize,
        __out_opt PULONG NameSize
        ) PURE;
};

//----------------------------------------------------------------------------
//
// Debugger/debuggee communication.
//
// A distinguished exception, DBG_COMMAND_EXCEPTION (0x40010009),
// can be used by a debuggee to communicate with the debugger.
// The arguments of the exception must be:
// 1. Exception ID.
// 2. Command code.
// 3. Size of argument.
// 4. Pointer to argument.
//
// The arguments depend on the command code.
//
//----------------------------------------------------------------------------

#define DEBUG_COMMAND_EXCEPTION_ID 0xdbe00dbe

// Invalid command code.
#define DEBUG_CMDEX_INVALID             0x00000000

//
// The debugger can collect strings for display at the
// next event.  A debuggee can use this to register information
// about a program situation before places where an event
// may occur, such as a risky operation or assertion.
// The strings are automatically flushed on the next
// event continuation.  Strings are kept on a per-thread basis.
//
// When adding, the argument is the string to add.
// Reset has no arguments and clears all strings.
//
#define DEBUG_CMDEX_ADD_EVENT_STRING    0x00000001
#define DEBUG_CMDEX_RESET_EVENT_STRINGS 0x00000002

#ifndef DEBUG_NO_IMPLEMENTATION

FORCEINLINE void
DebugCommandException(ULONG Command, ULONG ArgSize, PVOID Arg)
{
    ULONG_PTR ExArgs[4];

    ExArgs[0] = DEBUG_COMMAND_EXCEPTION_ID;
    ExArgs[1] = Command;
    ExArgs[2] = ArgSize;
    ExArgs[3] = (ULONG_PTR)Arg;
    RaiseException(DBG_COMMAND_EXCEPTION, 0, 4, ExArgs);
}

#endif // #ifndef DEBUG_NO_IMPLEMENTATION

//----------------------------------------------------------------------------
//
// Extension callbacks.
//
//----------------------------------------------------------------------------

// Returns a version with the major version in
// the high word and the minor version in the low word.
#define DEBUG_EXTENSION_VERSION(Major, Minor) \
    ((((Major) & 0xffff) << 16) | ((Minor) & 0xffff))

// Initialization routine.  Called once when the extension DLL
// is loaded.  Returns a version and returns flags detailing
// overall qualities of the extension DLL.
// A session may or may not be active at the time the DLL
// is loaded so initialization routines should not expect
// to be able to query session information.
typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_INITIALIZE)
    (__out PULONG Version, __out PULONG Flags);
// Exit routine.  Called once just before the extension DLL is
// unloaded.  As with initialization, a session may or
// may not be active at the time of the call.
typedef void (CALLBACK* PDEBUG_EXTENSION_UNINITIALIZE)
    (void);

// A debuggee has been discovered for the session.  It
// is not necessarily halted.
#define DEBUG_NOTIFY_SESSION_ACTIVE       0x00000000
// The session no longer has a debuggee.
#define DEBUG_NOTIFY_SESSION_INACTIVE     0x00000001
// The debuggee is halted and accessible.
#define DEBUG_NOTIFY_SESSION_ACCESSIBLE   0x00000002
// The debuggee is running or inaccessible.
#define DEBUG_NOTIFY_SESSION_INACCESSIBLE 0x00000003

typedef void (CALLBACK* PDEBUG_EXTENSION_NOTIFY)
    (__in ULONG Notify, __in ULONG64 Argument);

// A PDEBUG_EXTENSION_CALL function can return this code
// to indicate that it was unable to handle the request
// and that the search for an extension function should
// continue down the extension DLL chain.
// Taken from STATUS_VALIDATE_CONTINUE

#define DEBUG_EXTENSION_CONTINUE_SEARCH \
    HRESULT_FROM_NT(0xC0000271L)

// Every routine in an extension DLL has the following prototype.
// The extension may be called from multiple clients so it
// should not cache the client value between calls.
typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_CALL)
    (__in PDEBUG_CLIENT Client, __in_opt PCSTR Args);

// Extensions may export this callback in order to dump structs that
// are well known to them.  The engine calls this to inject extension
// output into dt's struct dump.
typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_KNOWN_STRUCT)
    (__in ULONG Flags,
     __in ULONG64 Offset,
     __in_opt PSTR TypeName,
     __out_ecount_opt(*BufferChars) PSTR Buffer,
     __inout_opt PULONG BufferChars);
typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_KNOWN_STRUCT_EX)
    (__in PDEBUG_CLIENT Client,
     __in ULONG Flags,
     __in ULONG64 Offset,
     __in_opt PCSTR TypeName,
     __out_ecount_opt(*BufferChars) PSTR Buffer,
     __inout_opt PULONG BufferChars);

// Backwards compatibility with old, incorrect name.
typedef PDEBUG_EXTENSION_KNOWN_STRUCT PDEBUG_ENTENSION_KNOWNSTRUCT;

//
// KnownStructOutput[Ex] flags
//

// Return names of supported structs.
#define DEBUG_KNOWN_STRUCT_GET_NAMES              1
// Return value output for type.
#define DEBUG_KNOWN_STRUCT_GET_SINGLE_LINE_OUTPUT 2
// Return S_OK if suppressing type name.
#define DEBUG_KNOWN_STRUCT_SUPPRESS_TYPE_NAME     3

//----------------------------------------------------------------------------
//
// Extension functions.
//
// Extension functions differ from extension callbacks in that
// they are arbitrary functions exported from an extension DLL
// for other code callers instead of for human invocation from
// debugger commands.  Extension function pointers are retrieved
// for an extension DLL with IDebugControl::GetExtensionFunction.
//
// Extension function names must begin with _EFN_.  Other than that
// they can have any name and prototype.  Extension functions
// must be public exports of their extension DLL.  They should
// have a typedef for their function pointer prototype in an
// extension header so that callers have a header file to include
// with a type that allows a correctly-formed invocation of the
// extension function.
//
// The engine does not perform any validation of calls to
// extension functions.  Once the extension function pointer
// is retrieved with GetExtensionFunction all calls go
// directly between the caller and the extension function and
// are not mediated by the engine.
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
};

//----------------------------------------------------------------------------
//
// C++ implementation helper classes.
//
//----------------------------------------------------------------------------

#if !defined(DEBUG_NO_IMPLEMENTATION) && !defined(_M_CEE_PURE)

//
// DebugBaseEventCallbacks provides a do-nothing base implementation
// of IDebugEventCallbacks.  A program can derive their own
// event callbacks class from DebugBaseEventCallbacks and implement
// only the methods they are interested in.  Programs must be
// careful to implement GetInterestMask appropriately.
//
class DebugBaseEventCallbacks : public IDebugEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        )
    {
        *Interface = NULL;

#if _MSC_VER >= 1100
        if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
            IsEqualIID(InterfaceId, __uuidof(IDebugEventCallbacks)))
#else
        if (IsEqualIID(InterfaceId, IID_IUnknown) ||
            IsEqualIID(InterfaceId, IID_IDebugEventCallbacks))
#endif
        {
            *Interface = (IDebugEventCallbacks *)this;
            AddRef();
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    // IDebugEventCallbacks.

    STDMETHOD(Breakpoint)(
        THIS_
        __in PDEBUG_BREAKPOINT Bp
        )
    {
        UNREFERENCED_PARAMETER(Bp);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(Exception)(
        THIS_
        __in PEXCEPTION_RECORD64 Exception,
        __in ULONG FirstChance
        )
    {
        UNREFERENCED_PARAMETER(Exception);
        UNREFERENCED_PARAMETER(FirstChance);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(CreateThread)(
        THIS_
        __in ULONG64 Handle,
        __in ULONG64 DataOffset,
        __in ULONG64 StartOffset
        )
    {
        UNREFERENCED_PARAMETER(Handle);
        UNREFERENCED_PARAMETER(DataOffset);
        UNREFERENCED_PARAMETER(StartOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ExitThread)(
        THIS_
        __in ULONG ExitCode
        )
    {
        UNREFERENCED_PARAMETER(ExitCode);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 ImageFileHandle,
        __in ULONG64 Handle,
        __in ULONG64 BaseOffset,
        __in ULONG ModuleSize,
        __in PCSTR ModuleName,
        __in PCSTR ImageName,
        __in ULONG CheckSum,
        __in ULONG TimeDateStamp,
        __in ULONG64 InitialThreadHandle,
        __in ULONG64 ThreadDataOffset,
        __in ULONG64 StartOffset
        )
    {
        UNREFERENCED_PARAMETER(ImageFileHandle);
        UNREFERENCED_PARAMETER(Handle);
        UNREFERENCED_PARAMETER(BaseOffset);
        UNREFERENCED_PARAMETER(ModuleSize);
        UNREFERENCED_PARAMETER(ModuleName);
        UNREFERENCED_PARAMETER(ImageName);
        UNREFERENCED_PARAMETER(CheckSum);
        UNREFERENCED_PARAMETER(TimeDateStamp);
        UNREFERENCED_PARAMETER(InitialThreadHandle);
        UNREFERENCED_PARAMETER(ThreadDataOffset);
        UNREFERENCED_PARAMETER(StartOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ExitProcess)(
        THIS_
        __in ULONG ExitCode
        )
    {
        UNREFERENCED_PARAMETER(ExitCode);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(LoadModule)(
        THIS_
        __in ULONG64 ImageFileHandle,
        __in ULONG64 BaseOffset,
        __in ULONG ModuleSize,
        __in PCSTR ModuleName,
        __in PCSTR ImageName,
        __in ULONG CheckSum,
        __in ULONG TimeDateStamp
        )
    {
        UNREFERENCED_PARAMETER(ImageFileHandle);
        UNREFERENCED_PARAMETER(BaseOffset);
        UNREFERENCED_PARAMETER(ModuleSize);
        UNREFERENCED_PARAMETER(ModuleName);
        UNREFERENCED_PARAMETER(ImageName);
        UNREFERENCED_PARAMETER(CheckSum);
        UNREFERENCED_PARAMETER(TimeDateStamp);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(UnloadModule)(
        THIS_
        __in PCSTR ImageBaseName,
        __in ULONG64 BaseOffset
        )
    {
        UNREFERENCED_PARAMETER(ImageBaseName);
        UNREFERENCED_PARAMETER(BaseOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(SystemError)(
        THIS_
        __in ULONG Error,
        __in ULONG Level
        )
    {
        UNREFERENCED_PARAMETER(Error);
        UNREFERENCED_PARAMETER(Level);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(SessionStatus)(
        THIS_
        __in ULONG Status
        )
    {
        UNREFERENCED_PARAMETER(Status);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
    STDMETHOD(ChangeEngineState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
    STDMETHOD(ChangeSymbolState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
};

class DebugBaseEventCallbacksWide : public IDebugEventCallbacksWide
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        __in REFIID InterfaceId,
        __out PVOID* Interface
        )
    {
        *Interface = NULL;

#if _MSC_VER >= 1100
        if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
            IsEqualIID(InterfaceId, __uuidof(IDebugEventCallbacksWide)))
#else
        if (IsEqualIID(InterfaceId, IID_IUnknown) ||
            IsEqualIID(InterfaceId, IID_IDebugEventCallbacksWide))
#endif
        {
            *Interface = (IDebugEventCallbacksWide *)this;
            AddRef();
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    // IDebugEventCallbacksWide.

    STDMETHOD(Breakpoint)(
        THIS_
        __in PDEBUG_BREAKPOINT2 Bp
        )
    {
        UNREFERENCED_PARAMETER(Bp);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(Exception)(
        THIS_
        __in PEXCEPTION_RECORD64 Exception,
        __in ULONG FirstChance
        )
    {
        UNREFERENCED_PARAMETER(Exception);
        UNREFERENCED_PARAMETER(FirstChance);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(CreateThread)(
        THIS_
        __in ULONG64 Handle,
        __in ULONG64 DataOffset,
        __in ULONG64 StartOffset
        )
    {
        UNREFERENCED_PARAMETER(Handle);
        UNREFERENCED_PARAMETER(DataOffset);
        UNREFERENCED_PARAMETER(StartOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ExitThread)(
        THIS_
        __in ULONG ExitCode
        )
    {
        UNREFERENCED_PARAMETER(ExitCode);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(CreateProcess)(
        THIS_
        __in ULONG64 ImageFileHandle,
        __in ULONG64 Handle,
        __in ULONG64 BaseOffset,
        __in ULONG ModuleSize,
        __in PCWSTR ModuleName,
        __in PCWSTR ImageName,
        __in ULONG CheckSum,
        __in ULONG TimeDateStamp,
        __in ULONG64 InitialThreadHandle,
        __in ULONG64 ThreadDataOffset,
        __in ULONG64 StartOffset
        )
    {
        UNREFERENCED_PARAMETER(ImageFileHandle);
        UNREFERENCED_PARAMETER(Handle);
        UNREFERENCED_PARAMETER(BaseOffset);
        UNREFERENCED_PARAMETER(ModuleSize);
        UNREFERENCED_PARAMETER(ModuleName);
        UNREFERENCED_PARAMETER(ImageName);
        UNREFERENCED_PARAMETER(CheckSum);
        UNREFERENCED_PARAMETER(TimeDateStamp);
        UNREFERENCED_PARAMETER(InitialThreadHandle);
        UNREFERENCED_PARAMETER(ThreadDataOffset);
        UNREFERENCED_PARAMETER(StartOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ExitProcess)(
        THIS_
        __in ULONG ExitCode
        )
    {
        UNREFERENCED_PARAMETER(ExitCode);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(LoadModule)(
        THIS_
        __in ULONG64 ImageFileHandle,
        __in ULONG64 BaseOffset,
        __in ULONG ModuleSize,
        __in PCWSTR ModuleName,
        __in PCWSTR ImageName,
        __in ULONG CheckSum,
        __in ULONG TimeDateStamp
        )
    {
        UNREFERENCED_PARAMETER(ImageFileHandle);
        UNREFERENCED_PARAMETER(BaseOffset);
        UNREFERENCED_PARAMETER(ModuleSize);
        UNREFERENCED_PARAMETER(ModuleName);
        UNREFERENCED_PARAMETER(ImageName);
        UNREFERENCED_PARAMETER(CheckSum);
        UNREFERENCED_PARAMETER(TimeDateStamp);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(UnloadModule)(
        THIS_
        __in PCWSTR ImageBaseName,
        __in ULONG64 BaseOffset
        )
    {
        UNREFERENCED_PARAMETER(ImageBaseName);
        UNREFERENCED_PARAMETER(BaseOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(SystemError)(
        THIS_
        __in ULONG Error,
        __in ULONG Level
        )
    {
        UNREFERENCED_PARAMETER(Error);
        UNREFERENCED_PARAMETER(Level);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(SessionStatus)(
        THIS_
        __in ULONG Status
        )
    {
        UNREFERENCED_PARAMETER(Status);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
    STDMETHOD(ChangeEngineState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
    STDMETHOD(ChangeSymbolState)(
        THIS_
        __in ULONG Flags,
        __in ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
};

#endif // #ifndef DEBUG_NO_IMPLEMENTATION

#ifdef DEBUG_UNICODE_MACROS

#ifdef UNICODE

#define IDebugEventCallbacksT IDebugEventCallbacksWide
#define IID_IDebugEventCallbacksT IID_IDebugEventCallbacksWide
#define IDebugOutputCallbacksT IDebugOutputCallbacksWide
#define IID_IDebugOutputCallbacksT IID_IDebugOutputCallbacksWide
#define DebugBaseEventCallbacksT DebugBaseEventCallbacksWide

#define DebugConnectT DebugConnectWide
#define GetSourceFileInformationT GetSourceFileInformationWide
#define FindSourceFileAndTokenT FindSourceFileAndTokenWide
#define GetSymbolInformationT GetSymbolInformationWide
#define GetCommandT GetCommandWide
#define SetCommandT SetCommandWide
#define GetOffsetExpressionT GetOffsetExpressionWide
#define SetOffsetExpressionT SetOffsetExpressionWide
#define GetRunningProcessSystemIdByExecutableNameT GetRunningProcessSystemIdByExecutableNameWide
#define GetRunningProcessDescriptionT GetRunningProcessDescriptionWide
#define CreateProcessT CreateProcessWide
#define CreateProcessAndAttachT CreateProcessAndAttachWide
#define AddDumpInformationFileT AddDumpInformationFileWide
#define GetDumpFileT GetDumpFileWide
#define AttachKernelT AttachKernelWide
#define GetKernelConnectionOptionsT GetKernelConnectionOptionsWide
#define SetKernelConnectionOptionsT SetKernelConnectionOptionsWide
#define StartProcessServerT StartProcessServerWide
#define ConnectProcessServerT ConnectProcessServerWide
#define StartServerT StartServerWide
#define OutputServersT OutputServersWide
#define GetOutputCallbacksT GetOutputCallbacksWide
#define SetOutputCallbacksT SetOutputCallbacksWide
#define GetOutputLinePrefixT GetOutputLinePrefixWide
#define SetOutputLinePrefixT SetOutputLinePrefixWide
#define GetIdentityT GetIdentityWide
#define OutputIdentityT OutputIdentityWide
#define GetEventCallbacksT GetEventCallbacksWide
#define SetEventCallbacksT SetEventCallbacksWide
#define CreateProcess2T CreateProcess2Wide
#define CreateProcessAndAttach2T CreateProcessAndAttach2Wide
#define PushOutputLinePrefixT PushOutputLinePrefixWide
#define GetQuitLockStringT GetQuitLockStringWide
#define SetQuitLockStringT SetQuitLockStringWide
#define GetLogFileT GetLogFileWide
#define OpenLogFileT OpenLogFileWide
#define InputT InputWide
#define ReturnInputT ReturnInputWide
#define OutputT OutputWide
#define OutputVaListT OutputVaListWide
#define ControlledOutputT ControlledOutputWide
#define ControlledOutputVaListT ControlledOutputVaListWide
#define OutputPromptT OutputPromptWide
#define OutputPromptVaListT OutputPromptVaListWide
#define GetPromptTextT GetPromptTextWide
#define AssembleT AssembleWide
#define DisassembleT DisassembleWide
#define GetProcessorTypeNamesT GetProcessorTypeNamesWide
#define GetTextMacroT GetTextMacroWide
#define SetTextMacroT SetTextMacroWide
#define EvaluateT EvaluateWide
#define ExecuteT ExecuteWide
#define ExecuteCommandFileT ExecuteCommandFileWide
#define AddExtensionT AddExtensionWide
#define GetExtensionByPathT GetExtensionByPathWide
#define CallExtensionT CallExtensionWide
#define GetExtensionFunctionT GetExtensionFunctionWide
#define GetEventFilterTextT GetEventFilterTextWide
#define GetEventFilterCommandT GetEventFilterCommandWide
#define SetEventFilterCommandT SetEventFilterCommandWide
#define GetSpecificFilterArgumentT GetSpecificFilterArgumentWide
#define SetSpecificFilterArgumentT SetSpecificFilterArgumentWide
#define GetExceptionFilterSecondCommandT GetExceptionFilterSecondCommandWide
#define SetExceptionFilterSecondCommandT SetExceptionFilterSecondCommandWide
#define GetLastEventInformationT GetLastEventInformationWide
#define GetTextReplacementT GetTextReplacementWide
#define SetTextReplacementT SetTextReplacementWide
#define SetExpressionSyntaxByNameT SetExpressionSyntaxByNameWide
#define GetExpressionSyntaxNamesT GetExpressionSyntaxNamesWide
#define GetEventIndexDescriptionT GetEventIndexDescriptionWide
#define GetLogFile2T GetLogFileWide
#define OpenLogFile2T OpenLogFileWide
#define GetSystemVersionStringT GetSystemVersionStringWide
#define ReadMultiByteStringVirtualT ReadMultiByteStringVirtualWide
#define ReadUnicodeStringVirtualT ReadUnicodeStringVirtualWide
#define GetDescriptionT GetDescriptionWide
#define GetIndexByNameT GetIndexByNameWide
#define GetPseudoDescriptionT GetPseudoDescriptionWide
#define GetPseudoIndexByNameT GetPseudoIndexByNameWide
#define AddSymbolT AddSymbolWide
#define RemoveSymbolByNameT RemoveSymbolByNameWide
#define GetSymbolNameT GetSymbolNameWide
#define WriteSymbolT WriteSymbolWide
#define OutputAsTypeT OutputAsTypeWide
#define GetSymbolTypeNameT GetSymbolTypeNameWide
#define GetSymbolValueTextT GetSymbolValueTextWide
#define GetNameByOffsetT GetNameByOffsetWide
#define GetOffsetByNameT GetOffsetByNameWide
#define GetNearNameByOffsetT GetNearNameByOffsetWide
#define GetLineByOffsetT GetLineByOffsetWide
#define GetOffsetByLineT GetOffsetByLineWide
#define GetModuleByModuleNameT GetModuleByModuleNameWide
#define GetModuleByModuleName2T GetModuleByModuleName2Wide
#define GetSymbolModuleT GetSymbolModuleWide
#define GetTypeNameT GetTypeNameWide
#define GetTypeIdT GetTypeIdWide
#define GetFieldOffsetT GetFieldOffsetWide
#define GetSymbolTypeIdT GetSymbolTypeIdWide
#define StartSymbolMatchT StartSymbolMatchWide
#define GetNextSymbolMatchT GetNextSymbolMatchWide
#define ReloadT ReloadWide
#define GetSymbolPathT GetSymbolPathWide
#define SetSymbolPathT SetSymbolPathWide
#define AppendSymbolPathT AppendSymbolPathWide
#define GetImagePathT GetImagePathWide
#define SetImagePathT SetImagePathWide
#define AppendImagePathT AppendImagePathWide
#define GetSourcePathT GetSourcePathWide
#define GetSourcePathElementT GetSourcePathElementWide
#define SetSourcePathT SetSourcePathWide
#define AppendSourcePathT AppendSourcePathWide
#define FindSourceFileT FindSourceFileWide
#define GetSourceFileLineOffsetsT GetSourceFileLineOffsetsWide
#define GetModuleVersionInformationT GetModuleVersionInformationWide
#define GetModuleNameStringT GetModuleNameStringWide
#define GetConstantNameT GetConstantNameWide
#define GetFieldNameT GetFieldNameWide
#define GetFieldTypeAndOffsetT GetFieldTypeAndOffsetWide
#define GetSymbolEntriesByNameT GetSymbolEntriesByNameWide
#define GetSymbolEntryStringT GetSymbolEntryStringWide
#define GetSourceEntriesByLineT GetSourceEntriesByLineWide
#define GetSourceEntryStringT GetSourceEntryStringWide
#define GetCurrentProcessExecutableNameT GetCurrentProcessExecutableNameWide
#define GetCurrentSystemServerNameT GetCurrentSystemServerNameWide

#else // #ifdef UNICODE

#define IDebugEventCallbacksT IDebugEventCallbacks
#define IID_IDebugEventCallbacksT IID_IDebugEventCallbacks
#define IDebugOutputCallbacksT IDebugOutputCallbacks
#define IID_IDebugOutputCallbacksT IID_IDebugOutputCallbacks
#define DebugBaseEventCallbacksT DebugBaseEventCallbacks

#define DebugConnectT DebugConnect
#define GetSourceFileInformationT GetSourceFileInformation
#define FindSourceFileAndTokenT FindSourceFileAndToken
#define GetSymbolInformationT GetSymbolInformation
#define GetCommandT GetCommand
#define SetCommandT SetCommand
#define GetOffsetExpressionT GetOffsetExpression
#define SetOffsetExpressionT SetOffsetExpression
#define GetRunningProcessSystemIdByExecutableNameT GetRunningProcessSystemIdByExecutableName
#define GetRunningProcessDescriptionT GetRunningProcessDescription
#define CreateProcessT CreateProcess
#define CreateProcessAndAttachT CreateProcessAndAttach
#define AddDumpInformationFileT AddDumpInformationFile
#define GetDumpFileT GetDumpFile
#define AttachKernelT AttachKernel
#define GetKernelConnectionOptionsT GetKernelConnectionOptions
#define SetKernelConnectionOptionsT SetKernelConnectionOptions
#define StartProcessServerT StartProcessServer
#define ConnectProcessServerT ConnectProcessServer
#define StartServerT StartServer
#define OutputServersT OutputServers
#define GetOutputCallbacksT GetOutputCallbacks
#define SetOutputCallbacksT SetOutputCallbacks
#define GetOutputLinePrefixT GetOutputLinePrefix
#define SetOutputLinePrefixT SetOutputLinePrefix
#define GetIdentityT GetIdentity
#define OutputIdentityT OutputIdentity
#define GetEventCallbacksT GetEventCallbacks
#define SetEventCallbacksT SetEventCallbacks
#define CreateProcess2T CreateProcess2
#define CreateProcessAndAttach2T CreateProcessAndAttach2
#define PushOutputLinePrefixT PushOutputLinePrefix
#define GetQuitLockStringT GetQuitLockString
#define SetQuitLockStringT SetQuitLockString
#define GetLogFileT GetLogFile
#define OpenLogFileT OpenLogFile
#define InputT Input
#define ReturnInputT ReturnInput
#define OutputT Output
#define OutputVaListT OutputVaList
#define ControlledOutputT ControlledOutput
#define ControlledOutputVaListT ControlledOutputVaList
#define OutputPromptT OutputPrompt
#define OutputPromptVaListT OutputPromptVaList
#define GetPromptTextT GetPromptText
#define AssembleT Assemble
#define DisassembleT Disassemble
#define GetProcessorTypeNamesT GetProcessorTypeNames
#define GetTextMacroT GetTextMacro
#define SetTextMacroT SetTextMacro
#define EvaluateT Evaluate
#define ExecuteT Execute
#define ExecuteCommandFileT ExecuteCommandFile
#define AddExtensionT AddExtension
#define GetExtensionByPathT GetExtensionByPath
#define CallExtensionT CallExtension
#define GetExtensionFunctionT GetExtensionFunction
#define GetEventFilterTextT GetEventFilterText
#define GetEventFilterCommandT GetEventFilterCommand
#define SetEventFilterCommandT SetEventFilterCommand
#define GetSpecificFilterArgumentT GetSpecificFilterArgument
#define SetSpecificFilterArgumentT SetSpecificFilterArgument
#define GetExceptionFilterSecondCommandT GetExceptionFilterSecondCommand
#define SetExceptionFilterSecondCommandT SetExceptionFilterSecondCommand
#define GetLastEventInformationT GetLastEventInformation
#define GetTextReplacementT GetTextReplacement
#define SetTextReplacementT SetTextReplacement
#define SetExpressionSyntaxByNameT SetExpressionSyntaxByName
#define GetExpressionSyntaxNamesT GetExpressionSyntaxNames
#define GetEventIndexDescriptionT GetEventIndexDescription
#define GetLogFile2T GetLogFile
#define OpenLogFile2T OpenLogFile
#define GetSystemVersionStringT GetSystemVersionString
#define ReadMultiByteStringVirtualT ReadMultiByteStringVirtual
#define ReadUnicodeStringVirtualT ReadUnicodeStringVirtual
#define GetDescriptionT GetDescription
#define GetIndexByNameT GetIndexByName
#define GetPseudoDescriptionT GetPseudoDescription
#define GetPseudoIndexByNameT GetPseudoIndexByName
#define AddSymbolT AddSymbol
#define RemoveSymbolByNameT RemoveSymbolByName
#define GetSymbolNameT GetSymbolName
#define WriteSymbolT WriteSymbol
#define OutputAsTypeT OutputAsType
#define GetSymbolTypeNameT GetSymbolTypeName
#define GetSymbolValueTextT GetSymbolValueText
#define GetNameByOffsetT GetNameByOffset
#define GetOffsetByNameT GetOffsetByName
#define GetNearNameByOffsetT GetNearNameByOffset
#define GetLineByOffsetT GetLineByOffset
#define GetOffsetByLineT GetOffsetByLine
#define GetModuleByModuleNameT GetModuleByModuleName
#define GetModuleByModuleName2T GetModuleByModuleName2
#define GetSymbolModuleT GetSymbolModule
#define GetTypeNameT GetTypeName
#define GetTypeIdT GetTypeId
#define GetFieldOffsetT GetFieldOffset
#define GetSymbolTypeIdT GetSymbolTypeId
#define StartSymbolMatchT StartSymbolMatch
#define GetNextSymbolMatchT GetNextSymbolMatch
#define ReloadT Reload
#define GetSymbolPathT GetSymbolPath
#define SetSymbolPathT SetSymbolPath
#define AppendSymbolPathT AppendSymbolPath
#define GetImagePathT GetImagePath
#define SetImagePathT SetImagePath
#define AppendImagePathT AppendImagePath
#define GetSourcePathT GetSourcePath
#define GetSourcePathElementT GetSourcePathElement
#define SetSourcePathT SetSourcePath
#define AppendSourcePathT AppendSourcePath
#define FindSourceFileT FindSourceFile
#define GetSourceFileLineOffsetsT GetSourceFileLineOffsets
#define GetModuleVersionInformationT GetModuleVersionInformation
#define GetModuleNameStringT GetModuleNameString
#define GetConstantNameT GetConstantName
#define GetFieldNameT GetFieldName
#define GetFieldTypeAndOffsetT GetFieldTypeAndOffset
#define GetSymbolEntriesByNameT GetSymbolEntriesByName
#define GetSymbolEntryStringT GetSymbolEntryString
#define GetSourceEntriesByLineT GetSourceEntriesByLine
#define GetSourceEntryStringT GetSourceEntryString
#define GetCurrentProcessExecutableNameT GetCurrentProcessExecutableName
#define GetCurrentSystemServerNameT GetCurrentSystemServerName

#endif // #ifdef UNICODE

#endif // #ifdef DEBUG_UNICODE_MACROS

#endif // #ifdef __cplusplus

#endif // #ifndef __DBGENG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dciddi.h ===
/*******************************************************************
 *
 *      FILE:           dciddi.h
 *
 *      DESCRIPTION:    definitions for MS/Intel-defined DCI interface
 *
 *      Copyright (C) 1994-1999 Intel/Microsoft Corporation.  All Rights Reserved.
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */
#define DCICOMMAND                      3075
#define DCI_VERSION                     0x0100

#define DCICREATEPRIMARYSURFACE         1
#define DCICREATEOFFSCREENSURFACE       2
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                                  0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN                      -17
#define DCI_ERR_YALIGN                      -18
#define DCI_ERR_XYALIGN                     -19
#define DCI_ERR_WIDTHALIGN                  -20
#define DCI_ERR_HEIGHTALIGN                 -21

/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16
#define DCI_STATUS_WASSTILLDRAWING         32

#define DCI_SUCCESS(error)  (((DCIRVAL)error) >= 0)

/* DCI Capability Flags */
#define DCI_SURFACE_TYPE                        0x0000000F
#define DCI_PRIMARY                             0x00000000
#define DCI_OFFSCREEN                           0x00000001
#define DCI_OVERLAY                             0x00000002

#define DCI_VISIBLE                             0x00000010
#define DCI_CHROMAKEY                           0x00000020
#define DCI_1632_ACCESS                         0x00000040
#define DCI_DWORDSIZE                           0x00000080
#define DCI_DWORDALIGN                          0x00000100
#define DCI_WRITEONLY                           0x00000200
#define DCI_ASYNC                               0x00000400

#define DCI_CAN_STRETCHX                        0x00001000
#define DCI_CAN_STRETCHY                        0x00002000
#define DCI_CAN_STRETCHXY                       (DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN                       0x00004000
#define DCI_CAN_STRETCHYN                       0x00008000
#define DCI_CAN_STRETCHXYN                      (DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{
   LONG     left;
   LONG     top;
   LONG     right;
   LONG     bottom;
} RECTL;
typedef RECTL*       PRECTL;
typedef RECTL NEAR*  NPRECTL;
typedef RECTL FAR*   LPRECTL;
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  0

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

/**************************************************************************
 *      input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
        DWORD   dwCommand;
        DWORD   dwParam1;
        DWORD   dwParam2;
        DWORD   dwVersion;
        DWORD   dwReserved;
} DCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for
 * the DCICREATE... calls.  The fields that are actually relevant differ for
 * each of the three calls.  Details are in the DCI Spec chapter providing
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
        DCICMD  cmd;                                                    /* common header structure */
        DWORD   dwCompression;                          /* format of surface to be created                      */
        DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
        DWORD   dwWidth;                        /* height of the surface to be created          */
        DWORD   dwHeight;                       /* width of input surfaces                                      */
        DWORD   dwDCICaps;                                              /* capabilities of surface wanted */
        DWORD   dwBitCount;                                     /* bit depth of format to be created */
        LPVOID  lpSurface;                      /* pointer to an associated surface             */
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;


/**************************************************************************
 *      surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary
 * surface, and as a member of the larger structures returned by the
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
        DWORD   dwSize;                         /* size of structure                                            */
        DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
        DWORD   dwCompression;                  /* format of surface to be created                      */
        DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

        DWORD   dwWidth;                    /* width of surface                                             */
        DWORD   dwHeight;                   /* height of surface                                            */
        LONG    lStride;                    /* distance in bytes betw. one pixel            */
                                                                                /* and the pixel directly below it                      */
        DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
        ULONG_PTR dwOffSurface;             /* offset of surface pointer                            */
        WORD    wSelSurface;                /* selector of surface pointer                          */
        WORD    wReserved;

        DWORD   dwReserved1;                /* reserved for provider */
        DWORD   dwReserved2;                /* reserved for DCIMAN */
        DWORD   dwReserved3;                /* reserved for future */
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
        void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */
        void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;


/*
 * This structure is used by a DCI client to provide input parameters for the
 * DCIEnumSurface call.
 */

typedef
void
(*ENUM_CALLBACK) (
    LPDCISURFACEINFO lpSurfaceInfo,
    LPVOID lpContext
    );

typedef struct _DCIENUMINPUT {
        DCICMD  cmd;                                                    /* common header structure */
        RECT    rSrc;                           /* source rect. for stretch  */
        RECT    rDst;                           /* dest. rect. for stretch       */
        void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
        LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;


/*
 * This structure must be allocated and returned by the DCI provider in
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;

/*
 * This structure must be allocated and returned by the DCI provider in
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

        DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

        DCISURFACEINFO  dciInfo;                                                /* surface info                  */
        DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
        DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Dbt.h ===
/*****************************************************************************
 *
 *  (C) Copyright MICROSOFT Corp., 1993-1999
 *
 *  Title:      DBT.H - Equates for WM_DEVICECHANGE and BroadcastSystemMessage
 *
 *  Version:    4.00
 *
 *  Date:       24-May-1993
 *
 *----------------------------------------------------------------------------
 *
 *  Change log:
 *
 *     DATE     REV                 DESCRIPTION
 *  ----------- --- ----------------------------------------------------------
 *
 *****************************************************************************/

#ifndef _DBT_H
#define _DBT_H

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * BroadcastSpecialMessage constants.
 */
#define WM_DEVICECHANGE         0x0219

/* XLATOFF */
#ifdef  IS_32
#define DBTFAR
#else
#define DBTFAR  far
#endif
/* XLATON */

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif // !defined(GUID_DEFINED)

/*
 * Broadcast message and receipient flags.
 *
 * Note that there is a third "flag". If the wParam has:
 *
 * bit 15 on:   lparam is a pointer and bit 14 is meaningfull.
 * bit 15 off:  lparam is just a UNLONG data type.
 *
 * bit 14 on:   lparam is a pointer to an ASCIIZ string.
 * bit 14 off:  lparam is a pointer to a binary struture starting with
 *              a dword describing the length of the structure.
 */
#define BSF_QUERY               0x00000001
#define BSF_IGNORECURRENTTASK   0x00000002      /* Meaningless for VxDs */
#define BSF_FLUSHDISK           0x00000004      /* Shouldn't be used by VxDs */
#define BSF_NOHANG              0x00000008
#define BSF_POSTMESSAGE         0x00000010
#define BSF_FORCEIFHUNG         0x00000020
#define BSF_NOTIMEOUTIFNOTHUNG  0x00000040
#define BSF_MSGSRV32ISOK        0x80000000      /* Called synchronously from PM API */
#define BSF_MSGSRV32ISOK_BIT    31              /* Called synchronously from PM API */

#define BSM_ALLCOMPONENTS       0x00000000
#define BSM_VXDS                0x00000001
#define BSM_NETDRIVER           0x00000002
#define BSM_INSTALLABLEDRIVERS  0x00000004
#define BSM_APPLICATIONS        0x00000008

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_APPYBEGIN
 * lParam  = (not used)
 *
 *      'Appy-time is now available.  This message is itself sent
 *      at 'Appy-time.
 *
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_APPYEND
 * lParam  = (not used)
 *
 *      'Appy-time is no longer available.  This message is *NOT* sent
 *      at 'Appy-time.  (It cannot be, because 'Appy-time is gone.)
 *
 * NOTE!  It is possible for DBT_APPYBEGIN and DBT_APPYEND to be sent
 * multiple times during a single Windows session.  Each appearance of
 * 'Appy-time is bracketed by these two messages, but 'Appy-time may
 * momentarily become unavailable during otherwise normal Windows
 * processing.  The current status of 'Appy-time availability can always
 * be obtained from a call to _SHELL_QueryAppyTimeAvailable.
 */
#define DBT_APPYBEGIN                   0x0000
#define DBT_APPYEND                     0x0001

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_DEVNODES_CHANGED
 * lParam  = 0
 *
 *      send when configmg finished a process tree batch. Some devnodes
 *      may have been added or removed. This is used by ring3 people which
 *      need to be refreshed whenever any devnode changed occur (like
 *      device manager). People specific to certain devices should use
 *      DBT_DEVICE* instead.
 */

#define DBT_DEVNODES_CHANGED            0x0007

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_QUERYCHANGECONFIG
 * lParam  = 0
 *
 *      sent to ask if a config change is allowed
 */

#define DBT_QUERYCHANGECONFIG           0x0017

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGCHANGED
 * lParam  = 0
 *
 *      sent when a config has changed
 */

#define DBT_CONFIGCHANGED               0x0018

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGCHANGECANCELED
 * lParam  = 0
 *
 *      someone cancelled the config change
 */

#define DBT_CONFIGCHANGECANCELED        0x0019

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_MONITORCHANGE
 * lParam  = new resolution to use (LOWORD=x, HIWORD=y)
 *           if 0, use the default res for current config
 *
 *      this message is sent when the display monitor has changed
 *      and the system should change the display mode to match it.
 */

#define DBT_MONITORCHANGE               0x001B

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_SHELLLOGGEDON
 * lParam  = 0
 *
 *      The shell has finished login on: VxD can now do Shell_EXEC.
 */

#define DBT_SHELLLOGGEDON               0x0020

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGMGAPI
 * lParam  = CONFIGMG API Packet
 *
 *      CONFIGMG ring 3 call.
 */
#define DBT_CONFIGMGAPI32               0x0022

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_VXDINITCOMPLETE
 * lParam  = 0
 *
 *      CONFIGMG ring 3 call.
 */
#define DBT_VXDINITCOMPLETE             0x0023

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_VOLLOCK*
 * lParam  = pointer to VolLockBroadcast structure described below
 *
 *      Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE.
 *      All these messages pass a pointer to a struct which has no pointers.
 */

#define DBT_VOLLOCKQUERYLOCK    0x8041
#define DBT_VOLLOCKLOCKTAKEN    0x8042
#define DBT_VOLLOCKLOCKFAILED   0x8043
#define DBT_VOLLOCKQUERYUNLOCK  0x8044
#define DBT_VOLLOCKLOCKRELEASED 0x8045
#define DBT_VOLLOCKUNLOCKFAILED 0x8046

/*
 * Device broadcast header
 */

struct _DEV_BROADCAST_HDR {     /* */
    DWORD       dbch_size;
    DWORD       dbch_devicetype;
    DWORD       dbch_reserved;
};

typedef struct  _DEV_BROADCAST_HDR      DEV_BROADCAST_HDR;
typedef         DEV_BROADCAST_HDR       DBTFAR *PDEV_BROADCAST_HDR;

/*
 * Structure for volume lock broadcast
 */

typedef struct VolLockBroadcast VolLockBroadcast;
typedef VolLockBroadcast *pVolLockBroadcast;
struct VolLockBroadcast {
        struct  _DEV_BROADCAST_HDR vlb_dbh;
        DWORD   vlb_owner;              // thread on which lock request is being issued
        BYTE    vlb_perms;              // lock permission flags defined below
        BYTE    vlb_lockType;           // type of lock
        BYTE    vlb_drive;              // drive on which lock is issued
        BYTE    vlb_flags;              // miscellaneous flags
};

/*
 * Values for vlb_perms
 */
#define LOCKP_ALLOW_WRITES              0x01    // Bit 0 set - allow writes
#define LOCKP_FAIL_WRITES               0x00    // Bit 0 clear - fail writes
#define LOCKP_FAIL_MEM_MAPPING          0x02    // Bit 1 set - fail memory mappings
#define LOCKP_ALLOW_MEM_MAPPING         0x00    // Bit 1 clear - allow memory mappings
#define LOCKP_USER_MASK                 0x03    // Mask for user lock flags
#define LOCKP_LOCK_FOR_FORMAT           0x04    // Level 0 lock for format

/*
 * Values for vlb_flags
 */
#define LOCKF_LOGICAL_LOCK              0x00    // Bit 0 clear - logical lock
#define LOCKF_PHYSICAL_LOCK             0x01    // Bit 0 set - physical lock

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_NODISKSPACE
 * lParam  = drive number of drive that is out of disk space (1-based)
 *
 * Message issued by IFS manager when it detects that a drive is run out of
 * free space.
 */

#define DBT_NO_DISK_SPACE               0x0047

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_LOW_DISK_SPACE
 * lParam  = drive number of drive that is low on disk space (1-based)
 *
 * Message issued by VFAT when it detects that a drive it has mounted
 * has the remaning free space below a threshold specified by the
 * registry or by a disk space management application.
 * The broadcast is issued by VFAT ONLY when space is either allocated
 * or freed by VFAT.
 */

#define DBT_LOW_DISK_SPACE      0x0048

#define DBT_CONFIGMGPRIVATE             0x7FFF

/*
 * The following messages are for WM_DEVICECHANGE. The immediate list
 * is for the wParam. ALL THESE MESSAGES PASS A POINTER TO A STRUCT
 * STARTING WITH A DWORD SIZE AND HAVING NO POINTER IN THE STRUCT.
 *
 */
#define DBT_DEVICEARRIVAL               0x8000  // system detected a new device
#define DBT_DEVICEQUERYREMOVE           0x8001  // wants to remove, may fail
#define DBT_DEVICEQUERYREMOVEFAILED     0x8002  // removal aborted
#define DBT_DEVICEREMOVEPENDING         0x8003  // about to remove, still avail.
#define DBT_DEVICEREMOVECOMPLETE        0x8004  // device is gone
#define DBT_DEVICETYPESPECIFIC          0x8005  // type specific event
#if(WINVER >= 0x040A)
#define DBT_CUSTOMEVENT                 0x8006  // user-defined event
#endif /* WINVER >= 0x040A */

#define DBT_DEVTYP_OEM                  0x00000000  // oem-defined device type
#define DBT_DEVTYP_DEVNODE              0x00000001  // devnode number
#define DBT_DEVTYP_VOLUME               0x00000002  // logical volume
#define DBT_DEVTYP_PORT                 0x00000003  // serial, parallel
#define DBT_DEVTYP_NET                  0x00000004  // network resource

#if(WINVER >= 0x040A)
#define DBT_DEVTYP_DEVICEINTERFACE      0x00000005  // device interface class
#define DBT_DEVTYP_HANDLE               0x00000006  // file system handle
#endif /* WINVER >= 0x040A */

struct _DEV_BROADCAST_HEADER { /* */
    DWORD       dbcd_size;
    DWORD       dbcd_devicetype;
    DWORD       dbcd_reserved;
};

struct _DEV_BROADCAST_OEM {     /* */
    DWORD       dbco_size;
    DWORD       dbco_devicetype;
    DWORD       dbco_reserved;
    DWORD       dbco_identifier;
    DWORD       dbco_suppfunc;
};

typedef struct  _DEV_BROADCAST_OEM      DEV_BROADCAST_OEM;
typedef         DEV_BROADCAST_OEM       DBTFAR *PDEV_BROADCAST_OEM;

struct _DEV_BROADCAST_DEVNODE { /* */
    DWORD       dbcd_size;
    DWORD       dbcd_devicetype;
    DWORD       dbcd_reserved;
    DWORD       dbcd_devnode;
};

typedef struct  _DEV_BROADCAST_DEVNODE  DEV_BROADCAST_DEVNODE;
typedef         DEV_BROADCAST_DEVNODE   DBTFAR *PDEV_BROADCAST_DEVNODE;

struct _DEV_BROADCAST_VOLUME { /* */
    DWORD       dbcv_size;
    DWORD       dbcv_devicetype;
    DWORD       dbcv_reserved;
    DWORD       dbcv_unitmask;
    WORD        dbcv_flags;
};

typedef struct  _DEV_BROADCAST_VOLUME   DEV_BROADCAST_VOLUME;
typedef         DEV_BROADCAST_VOLUME    DBTFAR *PDEV_BROADCAST_VOLUME;

#define DBTF_MEDIA      0x0001          // media comings and goings
#define DBTF_NET        0x0002          // network volume

typedef struct _DEV_BROADCAST_PORT_A {
    DWORD       dbcp_size;
    DWORD       dbcp_devicetype;
    DWORD       dbcp_reserved;
    char        dbcp_name[1];
} DEV_BROADCAST_PORT_A, *PDEV_BROADCAST_PORT_A;

typedef struct _DEV_BROADCAST_PORT_W {
    DWORD       dbcp_size;
    DWORD       dbcp_devicetype;
    DWORD       dbcp_reserved;
    wchar_t     dbcp_name[1];
} DEV_BROADCAST_PORT_W, DBTFAR *PDEV_BROADCAST_PORT_W;

#ifdef UNICODE
typedef DEV_BROADCAST_PORT_W     DEV_BROADCAST_PORT;
typedef PDEV_BROADCAST_PORT_W    PDEV_BROADCAST_PORT;
#else
typedef DEV_BROADCAST_PORT_A     DEV_BROADCAST_PORT;
typedef PDEV_BROADCAST_PORT_A    PDEV_BROADCAST_PORT;
#endif

struct _DEV_BROADCAST_NET { /* */
    DWORD       dbcn_size;
    DWORD       dbcn_devicetype;
    DWORD       dbcn_reserved;
    DWORD       dbcn_resource;
    DWORD       dbcn_flags;
};

typedef struct  _DEV_BROADCAST_NET      DEV_BROADCAST_NET;
typedef         DEV_BROADCAST_NET       DBTFAR *PDEV_BROADCAST_NET;

#if(WINVER >= 0x040A)

typedef struct _DEV_BROADCAST_DEVICEINTERFACE_A {
    DWORD       dbcc_size;
    DWORD       dbcc_devicetype;
    DWORD       dbcc_reserved;
    GUID        dbcc_classguid;
    char        dbcc_name[1];
} DEV_BROADCAST_DEVICEINTERFACE_A, *PDEV_BROADCAST_DEVICEINTERFACE_A;

typedef struct _DEV_BROADCAST_DEVICEINTERFACE_W {
    DWORD       dbcc_size;
    DWORD       dbcc_devicetype;
    DWORD       dbcc_reserved;
    GUID        dbcc_classguid;
    wchar_t     dbcc_name[1];
} DEV_BROADCAST_DEVICEINTERFACE_W, *PDEV_BROADCAST_DEVICEINTERFACE_W;

#ifdef UNICODE
typedef DEV_BROADCAST_DEVICEINTERFACE_W   DEV_BROADCAST_DEVICEINTERFACE;
typedef PDEV_BROADCAST_DEVICEINTERFACE_W  PDEV_BROADCAST_DEVICEINTERFACE;
#else
typedef DEV_BROADCAST_DEVICEINTERFACE_A   DEV_BROADCAST_DEVICEINTERFACE;
typedef PDEV_BROADCAST_DEVICEINTERFACE_A  PDEV_BROADCAST_DEVICEINTERFACE;
#endif

typedef struct _DEV_BROADCAST_HANDLE {
    DWORD       dbch_size;
    DWORD       dbch_devicetype;
    DWORD       dbch_reserved;
    HANDLE      dbch_handle;     // file handle used in call to RegisterDeviceNotification
    HDEVNOTIFY  dbch_hdevnotify; // returned from RegisterDeviceNotification
    //
    // The following 3 fields are only valid if wParam is DBT_CUSTOMEVENT.
    //
    GUID        dbch_eventguid;
    LONG        dbch_nameoffset; // offset (bytes) of variable-length string buffer (-1 if none)
    BYTE        dbch_data[1];    // variable-sized buffer, potentially containing binary and/or text data
} DEV_BROADCAST_HANDLE, *PDEV_BROADCAST_HANDLE;

#if(WINVER >= 0x0501)

//
// Define 32-bit and 64-bit versions of the DEV_BROADCAST_HANDLE structure
// for WOW64.  These must be kept in sync with the above structure.
//

typedef struct _DEV_BROADCAST_HANDLE32 {
    DWORD       dbch_size;
    DWORD       dbch_devicetype;
    DWORD       dbch_reserved;
    ULONG32     dbch_handle;
    ULONG32     dbch_hdevnotify;
    GUID        dbch_eventguid;
    LONG        dbch_nameoffset;
    BYTE        dbch_data[1];
} DEV_BROADCAST_HANDLE32, *PDEV_BROADCAST_HANDLE32;

typedef struct _DEV_BROADCAST_HANDLE64 {
    DWORD       dbch_size;
    DWORD       dbch_devicetype;
    DWORD       dbch_reserved;
    ULONG64     dbch_handle;
    ULONG64     dbch_hdevnotify;
    GUID        dbch_eventguid;
    LONG        dbch_nameoffset;
    BYTE        dbch_data[1];
} DEV_BROADCAST_HANDLE64, *PDEV_BROADCAST_HANDLE64;

#endif /* WINVER >= 0x0501 */

#endif /* WINVER >= 0x040A */

#define DBTF_RESOURCE   0x00000001      // network resource
#define DBTF_XPORT      0x00000002      // new transport coming or going
#define DBTF_SLOWNET    0x00000004      // new incoming transport is slow
                                        // (dbcn_resource undefined for now)

#define DBT_VPOWERDAPI  0x8100          // VPOWERD API for Win95

/*
 *  User-defined message types all use wParam = 0xFFFF with the
 *  lParam a pointer to the structure below.
 *
 *  dbud_dbh - DEV_BROADCAST_HEADER must be filled in as usual.
 *
 *  dbud_szName contains a case-sensitive ASCIIZ name which names the
 *  message.  The message name consists of the vendor name, a backslash,
 *  then arbitrary user-defined ASCIIZ text.  For example:
 *
 *      "WidgetWare\QueryScannerShutdown"
 *      "WidgetWare\Video Q39S\AdapterReady"
 *
 *  After the ASCIIZ name, arbitrary information may be provided.
 *  Make sure that dbud_dbh.dbch_size is big enough to encompass
 *  all the data.  And remember that nothing in the structure may
 *  contain pointers.
 */

#define DBT_USERDEFINED 0xFFFF

struct _DEV_BROADCAST_USERDEFINED { /* */
    struct _DEV_BROADCAST_HDR dbud_dbh;
    char        dbud_szName[1];     /* ASCIIZ name */
/*  BYTE        dbud_rgbUserDefined[];*/ /* User-defined contents */
};


#endif  // _DBT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Dde.h ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
* Copyright (c) 1993-1999, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/
#ifndef _DDEHEADER_INCLUDED_
#define _DDEHEADER_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WINDEF_
#include <windef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

// begin_r_dde

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)

// end_r_dde

/*----------------------------------------------------------------------------
|       DDEACK structure
|
|	Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
|       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
|       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
|
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
        unsigned short bAppReturnCode:8,
                 reserved:6,
                 fBusy:1,
		 fAck:1;
#else
        unsigned short usFlags;
#endif
} DDEACK;


/*----------------------------------------------------------------------------
|       DDEADVISE structure
|
|	WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
|
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
        unsigned short reserved:14,
                 fDeferUpd:1,
		 fAckReq:1;
#else
        unsigned short usFlags;
#endif
	short     cfFormat;
} DDEADVISE;


/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
	unsigned short unused:12,
                 fResponse:1,
                 fRelease:1,
                 reserved:1,
                 fAckReq:1;
#else
	unsigned short usFlags;
#endif
	short	 cfFormat;
	BYTE	 Value[1];
} DDEDATA;


/*----------------------------------------------------------------------------
|	DDEPOKE structure
|
|	WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
	unsigned short unused:13,  /* Earlier versions of DDE.H incorrectly */
                             /* 12 unused bits.                       */
		 fRelease:1,
		 fReserved:2;
#else
	unsigned short usFlags;
#endif
	short    cfFormat;
	BYTE	 Value[1];  /* This member was named rgb[1] in previous */
                            /* versions of DDE.H                        */

} DDEPOKE;

/*----------------------------------------------------------------------------
The following typedef's were used in previous versions of the Windows SDK.
They are still valid.  The above typedef's define exactly the same structures
as those below.  The above typedef names are recommended, however, as they
are more meaningful.

Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
not correctly define the bit positions.
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
		 fAckReq:1;
#else
	unsigned short usFlags;
#endif
	short	 cfFormat;
} DDELN;

typedef struct {
#ifndef _MAC
	unsigned short unused:12,
                 fAck:1,
                 fRelease:1,
                 fReserved:1,
                 fAckReq:1;
#else
	unsigned short usFlags;
#endif
	short	 cfFormat;
	BYTE	 rgb[1];
} DDEUP;


/*
 * DDE SECURITY
 */

BOOL
WINAPI
DdeSetQualityOfService(
    HWND hwndClient,
    CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    PSECURITY_QUALITY_OF_SERVICE pqosPrev);

BOOL
WINAPI
ImpersonateDdeClientWindow(
    HWND hWndClient,
    HWND hWndServer);

/*
 * DDE message packing APIs
 */
LPARAM APIENTRY PackDDElParam(UINT msg, UINT_PTR uiLo, UINT_PTR uiHi);
BOOL   APIENTRY UnpackDDElParam(UINT msg, LPARAM lParam, PUINT_PTR puiLo, PUINT_PTR puiHi);
BOOL   APIENTRY FreeDDElParam(UINT msg, LPARAM lParam);
LPARAM APIENTRY ReuseDDElParam(LPARAM lParam, UINT msgIn, UINT msgOut, UINT_PTR uiLo, UINT_PTR uiHi);

#ifdef __cplusplus
}
#endif

#endif // _DDEHEADER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Ddeml.h ===
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/

/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) Microsoft Corporation.  All rights reserved.    *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEMLH
#define _INC_DDEMLH

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/******** public types ********/

DECLARE_HANDLE(HCONVLIST);
DECLARE_HANDLE(HCONV);
DECLARE_HANDLE(HSZ);
DECLARE_HANDLE(HDDEDATA);
#define EXPENTRY        CALLBACK

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR {
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR, FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT {
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country/region code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
    SECURITY_QUALITY_OF_SERVICE qos;  /* client side's quality of service */
} CONVCONTEXT, FAR *PCONVCONTEXT;


/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO {
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD_PTR hUser;       /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* window handle for this conversation */
    HWND    hwndPartner;   /* partner window handle for this conversation */
} CONVINFO, FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED            0x0001
#define     ST_ADVISE               0x0002
#define     ST_ISLOCAL              0x0004
#define     ST_BLOCKED              0x0008
#define     ST_CLIENT               0x0010
#define     ST_TERMINATED           0x0020
#define     ST_INLIST               0x0040
#define     ST_BLOCKNEXT            0x0080
#define     ST_ISSELF               0x0100

/* DDE constants for wStatus field */

#define DDE_FACK                0x8000
#define DDE_FBUSY               0x4000
#define DDE_FDEFERUPD           0x4000
#define DDE_FACKREQ             0x8000
#define DDE_FRELEASE            0x2000
#define DDE_FREQUESTED          0x1000
#define DDE_FAPPSTATUS          0x00ff
#define DDE_FNOTPROCESSED       0x0000

#define DDE_FACKRESERVED        (~(DDE_FACK | DDE_FBUSY | DDE_FAPPSTATUS))
#define DDE_FADVRESERVED        (~(DDE_FACKREQ | DDE_FDEFERUPD))
#define DDE_FDATRESERVED        (~(DDE_FACKREQ | DDE_FRELEASE | DDE_FREQUESTED))
#define DDE_FPOKRESERVED        (~(DDE_FRELEASE))

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */
#define CP_WINUNICODE   1200
#ifdef UNICODE
#define CP_WINNEUTRAL   CP_WINUNICODE
#else  // !UNICODE
#define CP_WINNEUTRAL   CP_WINANSI
#endif // !UNICODE

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           0xFFFFFFFF

/***** Transaction ID constants *****/

#define     QID_SYNC                0xFFFFFFFF

/****** public strings used in DDE ******/

#ifdef UNICODE
#define SZDDESYS_TOPIC         L"System"
#define SZDDESYS_ITEM_TOPICS   L"Topics"
#define SZDDESYS_ITEM_SYSITEMS L"SysItems"
#define SZDDESYS_ITEM_RTNMSG   L"ReturnMessage"
#define SZDDESYS_ITEM_STATUS   L"Status"
#define SZDDESYS_ITEM_FORMATS  L"Formats"
#define SZDDESYS_ITEM_HELP     L"Help"
#define SZDDE_ITEM_ITEMLIST    L"TopicItemList"
#else
#define SZDDESYS_TOPIC         "System"
#define SZDDESYS_ITEM_TOPICS   "Topics"
#define SZDDESYS_ITEM_SYSITEMS "SysItems"
#define SZDDESYS_ITEM_RTNMSG   "ReturnMessage"
#define SZDDESYS_ITEM_STATUS   "Status"
#define SZDDESYS_ITEM_FORMATS  "Formats"
#define SZDDESYS_ITEM_HELP     "Help"
#define SZDDE_ITEM_ITEMLIST    "TopicItemList"
#endif


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, ULONG_PTR dwData1, ULONG_PTR dwData2);
typedef HDDEDATA (CALLBACK *PFNCALLBACK)(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, ULONG_PTR dwData1, ULONG_PTR dwData2);

#define     CBR_BLOCK           ((HDDEDATA)-1)

/* DLL registration functions */

UINT
WINAPI
DdeInitializeA(
    __inout LPDWORD pidInst,
    __in PFNCALLBACK pfnCallback,
    __in DWORD afCmd,
    __reserved DWORD ulRes);
UINT
WINAPI
DdeInitializeW(
    __inout LPDWORD pidInst,
    __in PFNCALLBACK pfnCallback,
    __in DWORD afCmd,
    __reserved DWORD ulRes);
#ifdef UNICODE
#define DdeInitialize  DdeInitializeW
#else
#define DdeInitialize  DdeInitializeA
#endif // !UNICODE

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL

BOOL
WINAPI
DdeUninitialize(
    __in DWORD idInst);

/*
 * conversation enumeration functions
 */
HCONVLIST
WINAPI
DdeConnectList(
    __in DWORD idInst,
    __in HSZ hszService,
    __in HSZ hszTopic,
    __in HCONVLIST hConvList,
    __in_opt PCONVCONTEXT pCC);

HCONV
WINAPI
DdeQueryNextServer(
    __in HCONVLIST hConvList,
    __in HCONV hConvPrev);
BOOL
WINAPI
DdeDisconnectList(
    __in HCONVLIST hConvList);

/*
 * conversation control functions
 */
HCONV
WINAPI
DdeConnect(
    __in DWORD idInst,
    __in HSZ hszService,
    __in HSZ hszTopic,
    __in_opt PCONVCONTEXT pCC);

BOOL
WINAPI
DdeDisconnect(
    __in HCONV hConv);

HCONV
WINAPI
DdeReconnect(
    __in HCONV hConv);

UINT
WINAPI
DdeQueryConvInfo(
    __in HCONV hConv,
    __in DWORD idTransaction,
    __inout PCONVINFO pConvInfo);

BOOL
WINAPI
DdeSetUserHandle(
    __in HCONV hConv,
    __in DWORD id,
    __in DWORD_PTR hUser);

BOOL
WINAPI
DdeAbandonTransaction(
    __in DWORD idInst,
    __in HCONV hConv,
    __in DWORD idTransaction);


/*
 * app server interface functions
 */
BOOL
WINAPI
DdePostAdvise(
    __in DWORD idInst,
    __in HSZ hszTopic,
    __in HSZ hszItem);

BOOL
WINAPI
DdeEnableCallback(
    __in DWORD idInst,
    __in HCONV hConv,
    __in UINT wCmd);

BOOL
WINAPI
DdeImpersonateClient(
    __in HCONV hConv);


#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2

HDDEDATA
WINAPI
DdeNameService(
    __in DWORD idInst,
    __in_opt HSZ hsz1,
    __in_opt HSZ hsz2,
    __in UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/*
 * app client interface functions
 */
HDDEDATA
WINAPI
DdeClientTransaction(
    __in_opt LPBYTE pData,
    __in DWORD cbData,
    __in HCONV hConv,
    __in_opt HSZ hszItem,
    __in UINT wFmt,
    __in UINT wType,
    __in DWORD dwTimeout,
    __out_opt LPDWORD pdwResult);


/*
 *data transfer functions
 */

HDDEDATA
WINAPI
DdeCreateDataHandle(
    __in DWORD idInst,
    __in_bcount_opt(cb) LPBYTE pSrc,
    __in DWORD cb,
    __in DWORD cbOff,
    __in_opt HSZ hszItem,
    __in UINT wFmt,
    __in UINT afCmd);

HDDEDATA
WINAPI
DdeAddData(
    __in HDDEDATA hData,
    __in_bcount(cb) LPBYTE pSrc,
    __in DWORD cb,
    __in DWORD cbOff);

DWORD
WINAPI
DdeGetData(
    __in HDDEDATA hData,
    __out_bcount_opt(cbMax) LPBYTE pDst,
    __in DWORD cbMax,
    __in DWORD cbOff);

LPBYTE
WINAPI
DdeAccessData(
    __in HDDEDATA hData,
    __out_opt LPDWORD pcbDataSize);

BOOL
WINAPI
DdeUnaccessData(
    __in HDDEDATA hData);

BOOL
WINAPI
DdeFreeDataHandle(
    __in HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001


UINT
WINAPI
DdeGetLastError(
    __in DWORD idInst);


#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ
WINAPI
DdeCreateStringHandleA(
    __in DWORD idInst,
    __in LPCSTR psz,
    __in int iCodePage);
HSZ
WINAPI
DdeCreateStringHandleW(
    __in DWORD idInst,
    __in LPCWSTR psz,
    __in int iCodePage);
#ifdef UNICODE
#define DdeCreateStringHandle  DdeCreateStringHandleW
#else
#define DdeCreateStringHandle  DdeCreateStringHandleA
#endif // !UNICODE

DWORD
WINAPI
DdeQueryStringA(
    __in DWORD idInst,
    __in HSZ hsz,
    __out_ecount_opt(cchMax) LPSTR psz,
    __in DWORD cchMax,
    __in int iCodePage);
DWORD
WINAPI
DdeQueryStringW(
    __in DWORD idInst,
    __in HSZ hsz,
    __out_ecount_opt(cchMax) LPWSTR psz,
    __in DWORD cchMax,
    __in int iCodePage);
#ifdef UNICODE
#define DdeQueryString  DdeQueryStringW
#else
#define DdeQueryString  DdeQueryStringA
#endif // !UNICODE

BOOL
WINAPI
DdeFreeStringHandle(
    __in DWORD idInst,
    __in HSZ hsz);

BOOL
WINAPI
DdeKeepStringHandle(
    __in DWORD idInst,
    __in HSZ hsz);

int
WINAPI
DdeCmpStringHandles(
    __in HSZ hsz1,
    __in HSZ hsz2);

#ifndef NODDEMLSPY
/*
 * DDEML public debugging header file info
 */

typedef struct tagDDEML_MSG_HOOK_DATA {    // new for NT
    UINT_PTR uiLo;  // unpacked lo and hi parts of lParam
    UINT_PTR uiHi;
    DWORD cbData;   // amount of data in message, if any. May be > than 32 bytes.
    DWORD Data[8];  // data peeking by DDESPY is limited to 32 bytes.
} DDEML_MSG_HOOK_DATA, *PDDEML_MSG_HOOK_DATA;


typedef struct tagMONMSGSTRUCT {
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
    DDEML_MSG_HOOK_DATA dmhd;       // new for NT
} MONMSGSTRUCT, *PMONMSGSTRUCT;

typedef struct tagMONCBSTRUCT {
    UINT   cb;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    ULONG_PTR dwData1;
    ULONG_PTR dwData2;
    CONVCONTEXT cc;                 // new for NT for XTYP_CONNECT callbacks
    DWORD  cbData;                  // new for NT for data peeking
    DWORD  Data[8];                 // new for NT for data peeking
} MONCBSTRUCT, *PMONCBSTRUCT;

typedef struct tagMONHSZSTRUCTA {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    CHAR    str[1];
} MONHSZSTRUCTA, *PMONHSZSTRUCTA;
typedef struct tagMONHSZSTRUCTW {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WCHAR   str[1];
} MONHSZSTRUCTW, *PMONHSZSTRUCTW;
#ifdef UNICODE
typedef MONHSZSTRUCTW MONHSZSTRUCT;
typedef PMONHSZSTRUCTW PMONHSZSTRUCT;
#else
typedef MONHSZSTRUCTA MONHSZSTRUCT;
typedef PMONHSZSTRUCTA PMONHSZSTRUCT;
#endif // UNICODE

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4

typedef struct tagMONERRSTRUCT {
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT, *PMONERRSTRUCT;

typedef struct tagMONLINKSTRUCT {
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT, *PMONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT {
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;        // Globally unique value != apps local hConv
    HCONV   hConvServer;        // Globally unique value != apps local hConv
} MONCONVSTRUCT, *PMONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _INC_DDEMLH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DbgProp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dbgprop.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dbgprop_h__
#define __dbgprop_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDebugProperty_FWD_DEFINED__
#define __IDebugProperty_FWD_DEFINED__
typedef interface IDebugProperty IDebugProperty;
#endif 	/* __IDebugProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_FWD_DEFINED__
#define __IEnumDebugPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugPropertyInfo IEnumDebugPropertyInfo;
#endif 	/* __IEnumDebugPropertyInfo_FWD_DEFINED__ */


#ifndef __IDebugExtendedProperty_FWD_DEFINED__
#define __IDebugExtendedProperty_FWD_DEFINED__
typedef interface IDebugExtendedProperty IDebugExtendedProperty;
#endif 	/* __IDebugExtendedProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugExtendedPropertyInfo IEnumDebugExtendedPropertyInfo;
#endif 	/* __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_FWD_DEFINED__
#define __IPerPropertyBrowsing2_FWD_DEFINED__
typedef interface IPerPropertyBrowsing2 IPerPropertyBrowsing2;
#endif 	/* __IPerPropertyBrowsing2_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_FWD_DEFINED__
#define __IDebugPropertyEnumType_All_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_All IDebugPropertyEnumType_All;
#endif 	/* __IDebugPropertyEnumType_All_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_FWD_DEFINED__
#define __IDebugPropertyEnumType_Locals_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Locals IDebugPropertyEnumType_Locals;
#endif 	/* __IDebugPropertyEnumType_Locals_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
#define __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Arguments IDebugPropertyEnumType_Arguments;
#endif 	/* __IDebugPropertyEnumType_Arguments_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_LocalsPlusArgs IDebugPropertyEnumType_LocalsPlusArgs;
#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_FWD_DEFINED__
#define __IDebugPropertyEnumType_Registers_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Registers IDebugPropertyEnumType_Registers;
#endif 	/* __IDebugPropertyEnumType_Registers_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dbgprop_0000_0000 */
/* [local] */ 






typedef 
enum tagOBJECT_ATTRIB_FLAG
    {	OBJECT_ATTRIB_NO_ATTRIB	= 0,
	OBJECT_ATTRIB_NO_NAME	= 0x1,
	OBJECT_ATTRIB_NO_TYPE	= 0x2,
	OBJECT_ATTRIB_NO_VALUE	= 0x4,
	OBJECT_ATTRIB_VALUE_IS_INVALID	= 0x8,
	OBJECT_ATTRIB_VALUE_IS_OBJECT	= 0x10,
	OBJECT_ATTRIB_VALUE_IS_ENUM	= 0x20,
	OBJECT_ATTRIB_VALUE_IS_CUSTOM	= 0x40,
	OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE	= 0x70,
	OBJECT_ATTRIB_VALUE_HAS_CODE	= 0x80,
	OBJECT_ATTRIB_TYPE_IS_OBJECT	= 0x100,
	OBJECT_ATTRIB_TYPE_HAS_CODE	= 0x200,
	OBJECT_ATTRIB_TYPE_IS_EXPANDABLE	= 0x100,
	OBJECT_ATTRIB_SLOT_IS_CATEGORY	= 0x400,
	OBJECT_ATTRIB_VALUE_READONLY	= 0x800,
	OBJECT_ATTRIB_ACCESS_PUBLIC	= 0x1000,
	OBJECT_ATTRIB_ACCESS_PRIVATE	= 0x2000,
	OBJECT_ATTRIB_ACCESS_PROTECTED	= 0x4000,
	OBJECT_ATTRIB_ACCESS_FINAL	= 0x8000,
	OBJECT_ATTRIB_STORAGE_GLOBAL	= 0x10000,
	OBJECT_ATTRIB_STORAGE_STATIC	= 0x20000,
	OBJECT_ATTRIB_STORAGE_FIELD	= 0x40000,
	OBJECT_ATTRIB_STORAGE_VIRTUAL	= 0x80000,
	OBJECT_ATTRIB_TYPE_IS_CONSTANT	= 0x100000,
	OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED	= 0x200000,
	OBJECT_ATTRIB_TYPE_IS_VOLATILE	= 0x400000,
	OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS	= 0x800000,
	OBJECT_ATTRIB_IS_CLASS	= 0x1000000,
	OBJECT_ATTRIB_IS_FUNCTION	= 0x2000000,
	OBJECT_ATTRIB_IS_VARIABLE	= 0x4000000,
	OBJECT_ATTRIB_IS_PROPERTY	= 0x8000000,
	OBJECT_ATTRIB_IS_MACRO	= 0x10000000,
	OBJECT_ATTRIB_IS_TYPE	= 0x20000000,
	OBJECT_ATTRIB_IS_INHERITED	= 0x40000000,
	OBJECT_ATTRIB_IS_INTERFACE	= 0x80000000
    } 	OBJECT_ATTRIB_FLAGS;

typedef 
enum tagPROP_INFO_FLAGS
    {	PROP_INFO_NAME	= 0x1,
	PROP_INFO_TYPE	= 0x2,
	PROP_INFO_VALUE	= 0x4,
	PROP_INFO_FULLNAME	= 0x20,
	PROP_INFO_ATTRIBUTES	= 0x8,
	PROP_INFO_DEBUGPROP	= 0x10,
	PROP_INFO_AUTOEXPAND	= 0x8000000
    } 	PROP_INFO_FLAGS;

#define	PROP_INFO_STANDARD	( ( ( ( PROP_INFO_NAME | PROP_INFO_TYPE )  | PROP_INFO_VALUE )  | PROP_INFO_ATTRIBUTES )  )

#define	PROP_INFO_ALL	( ( ( ( ( ( PROP_INFO_NAME | PROP_INFO_TYPE )  | PROP_INFO_VALUE )  | PROP_INFO_FULLNAME )  | PROP_INFO_ATTRIBUTES )  | PROP_INFO_DEBUGPROP )  )

typedef struct tagDebugPropertyInfo
    {
    DWORD m_dwValidFields;
    BSTR m_bstrName;
    BSTR m_bstrType;
    BSTR m_bstrValue;
    BSTR m_bstrFullName;
    DWORD m_dwAttrib;
    IDebugProperty *m_pDebugProp;
    } 	DebugPropertyInfo;

typedef 
enum tagEX_PROP_INFO_FLAGS
    {	EX_PROP_INFO_ID	= 0x100,
	EX_PROP_INFO_NTYPE	= 0x200,
	EX_PROP_INFO_NVALUE	= 0x400,
	EX_PROP_INFO_LOCKBYTES	= 0x800,
	EX_PROP_INFO_DEBUGEXTPROP	= 0x1000
    } 	EX_PROP_INFO_FLAGS;

typedef struct tagExtendedDebugPropertyInfo
    {
    DWORD dwValidFields;
    LPOLESTR pszName;
    LPOLESTR pszType;
    LPOLESTR pszValue;
    LPOLESTR pszFullName;
    DWORD dwAttrib;
    IDebugProperty *pDebugProp;
    DWORD nDISPID;
    DWORD nType;
    VARIANT varValue;
    ILockBytes *plbValue;
    IDebugExtendedProperty *pDebugExtProp;
    } 	ExtendedDebugPropertyInfo;



extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_0000_v0_0_s_ifspec;

#ifndef __IDebugProperty_INTERFACE_DEFINED__
#define __IDebugProperty_INTERFACE_DEFINED__

/* interface IDebugProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C50-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugProperty : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo *pPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedInfo( 
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ __RPC__in_ecount_full(cInfos) GUID *rgguidExtendedInfo,
            /* [size_is][out] */ __RPC__out_ecount_full(cInfos) VARIANT *rgvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString( 
            /* [in] */ __RPC__in LPCOLESTR pszValue,
            /* [in] */ UINT nRadix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ __RPC__in REFIID refiid,
            /* [out] */ __RPC__deref_out_opt IEnumDebugPropertyInfo **ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ __RPC__deref_out_opt IDebugProperty **ppDebugProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProperty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProperty * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyInfo )( 
            IDebugProperty * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedInfo )( 
            IDebugProperty * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ __RPC__in_ecount_full(cInfos) GUID *rgguidExtendedInfo,
            /* [size_is][out] */ __RPC__out_ecount_full(cInfos) VARIANT *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAsString )( 
            IDebugProperty * This,
            /* [in] */ __RPC__in LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMembers )( 
            IDebugProperty * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ __RPC__in REFIID refiid,
            /* [out] */ __RPC__deref_out_opt IEnumDebugPropertyInfo **ppepi);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDebugProperty * This,
            /* [out] */ __RPC__deref_out_opt IDebugProperty **ppDebugProp);
        
        END_INTERFACE
    } IDebugPropertyVtbl;

    interface IDebugProperty
    {
        CONST_VTBL struct IDebugPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    ( (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo) ) 

#define IDebugProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    ( (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar) ) 

#define IDebugProperty_SetValueAsString(This,pszValue,nRadix)	\
    ( (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix) ) 

#define IDebugProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    ( (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi) ) 

#define IDebugProperty_GetParent(This,ppDebugProp)	\
    ( (This)->lpVtbl -> GetParent(This,ppDebugProp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_RemoteGetPropertyInfo_Proxy( 
    IDebugProperty * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ __RPC__out DWORD *dwValidFields,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrName,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrType,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrValue,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrFullName,
    /* [out] */ __RPC__out DWORD *pdwAttrib,
    /* [unique][out][in] */ __RPC__deref_opt_inout_opt IDebugProperty **ppDebugProperty);


void __RPC_STUB IDebugProperty_RemoteGetPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugPropertyInfo_INTERFACE_DEFINED__

/* interface IEnumDebugPropertyInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C51-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugPropertyInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo *pi,
            /* [out] */ ULONG *pcEltsfetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugPropertyInfo **ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugPropertyInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugPropertyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugPropertyInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugPropertyInfo * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo *pi,
            /* [out] */ ULONG *pcEltsfetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugPropertyInfo * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugPropertyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugPropertyInfo * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugPropertyInfo **ppepi);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugPropertyInfo * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugPropertyInfoVtbl;

    interface IEnumDebugPropertyInfo
    {
        CONST_VTBL struct IEnumDebugPropertyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDebugPropertyInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDebugPropertyInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDebugPropertyInfo_Next(This,celt,pi,pcEltsfetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pi,pcEltsfetched) ) 

#define IEnumDebugPropertyInfo_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDebugPropertyInfo_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDebugPropertyInfo_Clone(This,ppepi)	\
    ( (This)->lpVtbl -> Clone(This,ppepi) ) 

#define IEnumDebugPropertyInfo_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugPropertyInfo_RemoteNext_Proxy( 
    IEnumDebugPropertyInfo * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][unique][out][in] */ __RPC__inout_ecount_part_opt(celt, *pcEltsfetched) DebugPropertyInfo *pinfo,
    /* [out] */ __RPC__out ULONG *pcEltsfetched);


void __RPC_STUB IEnumDebugPropertyInfo_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IDebugExtendedProperty_INTERFACE_DEFINED__
#define __IDebugExtendedProperty_INTERFACE_DEFINED__

/* interface IDebugExtendedProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugExtendedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C52-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExtendedProperty : public IDebugProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtendedPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ __RPC__out ExtendedDebugPropertyInfo *pExtendedPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtendedMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ __RPC__deref_out_opt IEnumDebugExtendedPropertyInfo **ppeepi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExtendedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugExtendedProperty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugExtendedProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugExtendedProperty * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyInfo )( 
            IDebugExtendedProperty * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedInfo )( 
            IDebugExtendedProperty * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ __RPC__in_ecount_full(cInfos) GUID *rgguidExtendedInfo,
            /* [size_is][out] */ __RPC__out_ecount_full(cInfos) VARIANT *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAsString )( 
            IDebugExtendedProperty * This,
            /* [in] */ __RPC__in LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMembers )( 
            IDebugExtendedProperty * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ __RPC__in REFIID refiid,
            /* [out] */ __RPC__deref_out_opt IEnumDebugPropertyInfo **ppepi);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDebugExtendedProperty * This,
            /* [out] */ __RPC__deref_out_opt IDebugProperty **ppDebugProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedPropertyInfo )( 
            IDebugExtendedProperty * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ __RPC__out ExtendedDebugPropertyInfo *pExtendedPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE *EnumExtendedMembers )( 
            IDebugExtendedProperty * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ __RPC__deref_out_opt IEnumDebugExtendedPropertyInfo **ppeepi);
        
        END_INTERFACE
    } IDebugExtendedPropertyVtbl;

    interface IDebugExtendedProperty
    {
        CONST_VTBL struct IDebugExtendedPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExtendedProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugExtendedProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugExtendedProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugExtendedProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    ( (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo) ) 

#define IDebugExtendedProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    ( (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar) ) 

#define IDebugExtendedProperty_SetValueAsString(This,pszValue,nRadix)	\
    ( (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix) ) 

#define IDebugExtendedProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    ( (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi) ) 

#define IDebugExtendedProperty_GetParent(This,ppDebugProp)	\
    ( (This)->lpVtbl -> GetParent(This,ppDebugProp) ) 


#define IDebugExtendedProperty_GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)	\
    ( (This)->lpVtbl -> GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo) ) 

#define IDebugExtendedProperty_EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)	\
    ( (This)->lpVtbl -> EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugExtendedProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__

/* interface IEnumDebugExtendedPropertyInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugExtendedPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C53-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugExtendedPropertyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ExtendedDebugPropertyInfo *rgExtendedPropertyInfo,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDebugExtendedPropertyInfo **pedpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugExtendedPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugExtendedPropertyInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugExtendedPropertyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugExtendedPropertyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugExtendedPropertyInfo * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ExtendedDebugPropertyInfo *rgExtendedPropertyInfo,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugExtendedPropertyInfo * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugExtendedPropertyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugExtendedPropertyInfo * This,
            /* [out] */ __RPC__deref_out_opt IEnumDebugExtendedPropertyInfo **pedpe);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugExtendedPropertyInfo * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugExtendedPropertyInfoVtbl;

    interface IEnumDebugExtendedPropertyInfo
    {
        CONST_VTBL struct IEnumDebugExtendedPropertyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExtendedPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDebugExtendedPropertyInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDebugExtendedPropertyInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDebugExtendedPropertyInfo_Next(This,celt,rgExtendedPropertyInfo,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgExtendedPropertyInfo,pceltFetched) ) 

#define IEnumDebugExtendedPropertyInfo_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDebugExtendedPropertyInfo_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDebugExtendedPropertyInfo_Clone(This,pedpe)	\
    ( (This)->lpVtbl -> Clone(This,pedpe) ) 

#define IEnumDebugExtendedPropertyInfo_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_INTERFACE_DEFINED__
#define __IPerPropertyBrowsing2_INTERFACE_DEFINED__

/* interface IPerPropertyBrowsing2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPerPropertyBrowsing2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C54-CB0C-11d0-B5C9-00A0244A0E7A")
    IPerPropertyBrowsing2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayString( 
            /* [in] */ DISPID dispid,
            /* [out] */ __RPC__deref_out_opt BSTR *pBstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapPropertyToPage( 
            /* [in] */ DISPID dispid,
            /* [out] */ __RPC__out CLSID *pClsidPropPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPredefinedStrings( 
            /* [in] */ DISPID dispid,
            /* [out] */ __RPC__out CALPOLESTR *pCaStrings,
            /* [out] */ __RPC__out CADWORD *pCaCookies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPredefinedValue( 
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerPropertyBrowsing2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPerPropertyBrowsing2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPerPropertyBrowsing2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPerPropertyBrowsing2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayString )( 
            IPerPropertyBrowsing2 * This,
            /* [in] */ DISPID dispid,
            /* [out] */ __RPC__deref_out_opt BSTR *pBstr);
        
        HRESULT ( STDMETHODCALLTYPE *MapPropertyToPage )( 
            IPerPropertyBrowsing2 * This,
            /* [in] */ DISPID dispid,
            /* [out] */ __RPC__out CLSID *pClsidPropPage);
        
        HRESULT ( STDMETHODCALLTYPE *GetPredefinedStrings )( 
            IPerPropertyBrowsing2 * This,
            /* [in] */ DISPID dispid,
            /* [out] */ __RPC__out CALPOLESTR *pCaStrings,
            /* [out] */ __RPC__out CADWORD *pCaCookies);
        
        HRESULT ( STDMETHODCALLTYPE *SetPredefinedValue )( 
            IPerPropertyBrowsing2 * This,
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IPerPropertyBrowsing2Vtbl;

    interface IPerPropertyBrowsing2
    {
        CONST_VTBL struct IPerPropertyBrowsing2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerPropertyBrowsing2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPerPropertyBrowsing2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPerPropertyBrowsing2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPerPropertyBrowsing2_GetDisplayString(This,dispid,pBstr)	\
    ( (This)->lpVtbl -> GetDisplayString(This,dispid,pBstr) ) 

#define IPerPropertyBrowsing2_MapPropertyToPage(This,dispid,pClsidPropPage)	\
    ( (This)->lpVtbl -> MapPropertyToPage(This,dispid,pClsidPropPage) ) 

#define IPerPropertyBrowsing2_GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)	\
    ( (This)->lpVtbl -> GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies) ) 

#define IPerPropertyBrowsing2_SetPredefinedValue(This,dispid,dwCookie)	\
    ( (This)->lpVtbl -> SetPredefinedValue(This,dispid,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPerPropertyBrowsing2_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_All_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_All */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_All;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C55-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_All : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IDebugPropertyEnumType_All0000) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_AllVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPropertyEnumType_All * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPropertyEnumType_All * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPropertyEnumType_All * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugPropertyEnumType_All * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IDebugPropertyEnumType_All0000);
        
        END_INTERFACE
    } IDebugPropertyEnumType_AllVtbl;

    interface IDebugPropertyEnumType_All
    {
        CONST_VTBL struct IDebugPropertyEnumType_AllVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_All_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugPropertyEnumType_All_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugPropertyEnumType_All_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugPropertyEnumType_All_GetName(This,__MIDL__IDebugPropertyEnumType_All0000)	\
    ( (This)->lpVtbl -> GetName(This,__MIDL__IDebugPropertyEnumType_All0000) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_All_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_Locals */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_Locals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C56-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Locals : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPropertyEnumType_Locals * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPropertyEnumType_Locals * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPropertyEnumType_Locals * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugPropertyEnumType_Locals * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IDebugPropertyEnumType_All0000);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsVtbl;

    interface IDebugPropertyEnumType_Locals
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Locals_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugPropertyEnumType_Locals_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugPropertyEnumType_Locals_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugPropertyEnumType_Locals_GetName(This,__MIDL__IDebugPropertyEnumType_All0000)	\
    ( (This)->lpVtbl -> GetName(This,__MIDL__IDebugPropertyEnumType_All0000) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_Arguments */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_Arguments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C57-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Arguments : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_ArgumentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPropertyEnumType_Arguments * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPropertyEnumType_Arguments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPropertyEnumType_Arguments * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugPropertyEnumType_Arguments * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IDebugPropertyEnumType_All0000);
        
        END_INTERFACE
    } IDebugPropertyEnumType_ArgumentsVtbl;

    interface IDebugPropertyEnumType_Arguments
    {
        CONST_VTBL struct IDebugPropertyEnumType_ArgumentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Arguments_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugPropertyEnumType_Arguments_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugPropertyEnumType_Arguments_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugPropertyEnumType_Arguments_GetName(This,__MIDL__IDebugPropertyEnumType_All0000)	\
    ( (This)->lpVtbl -> GetName(This,__MIDL__IDebugPropertyEnumType_All0000) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_LocalsPlusArgs */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_LocalsPlusArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C58-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_LocalsPlusArgs : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsPlusArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPropertyEnumType_LocalsPlusArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPropertyEnumType_LocalsPlusArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPropertyEnumType_LocalsPlusArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugPropertyEnumType_LocalsPlusArgs * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IDebugPropertyEnumType_All0000);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsPlusArgsVtbl;

    interface IDebugPropertyEnumType_LocalsPlusArgs
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsPlusArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_LocalsPlusArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugPropertyEnumType_LocalsPlusArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugPropertyEnumType_LocalsPlusArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugPropertyEnumType_LocalsPlusArgs_GetName(This,__MIDL__IDebugPropertyEnumType_All0000)	\
    ( (This)->lpVtbl -> GetName(This,__MIDL__IDebugPropertyEnumType_All0000) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_Registers */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_Registers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C59-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Registers : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_RegistersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPropertyEnumType_Registers * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPropertyEnumType_Registers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPropertyEnumType_Registers * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugPropertyEnumType_Registers * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IDebugPropertyEnumType_All0000);
        
        END_INTERFACE
    } IDebugPropertyEnumType_RegistersVtbl;

    interface IDebugPropertyEnumType_Registers
    {
        CONST_VTBL struct IDebugPropertyEnumType_RegistersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Registers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugPropertyEnumType_Registers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugPropertyEnumType_Registers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugPropertyEnumType_Registers_GetName(This,__MIDL__IDebugPropertyEnumType_All0000)	\
    ( (This)->lpVtbl -> GetName(This,__MIDL__IDebugPropertyEnumType_All0000) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Proxy( 
    IDebugProperty * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DebugPropertyInfo *pPropertyInfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Stub( 
    IDebugProperty * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ __RPC__out DWORD *dwValidFields,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrName,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrType,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrValue,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrFullName,
    /* [out] */ __RPC__out DWORD *pdwAttrib,
    /* [unique][out][in] */ __RPC__deref_opt_inout_opt IDebugProperty **ppDebugProperty);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Proxy( 
    IEnumDebugPropertyInfo * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugPropertyInfo *pi,
    /* [out] */ ULONG *pcEltsfetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugPropertyInfo_Next_Stub( 
    IEnumDebugPropertyInfo * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][unique][out][in] */ __RPC__inout_ecount_part_opt(celt, *pcEltsfetched) DebugPropertyInfo *pinfo,
    /* [out] */ __RPC__out ULONG *pcEltsfetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ddrawgdi.h ===
/******************************Module*Header*******************************\
* Module Name: ddrawgdi.h
*
* Structures and defines for the private entry points in GDI to support
* DirectDraw.
*
* Copyright (c) Microsoft Corporation. All rights reserved.
\**************************************************************************/

#ifdef  COMBOX_SANDBOX
#define DX_LONGHORN_PRESERVEDC
#endif

// We rename the actual entry points for added protection against anyone
// trying to call our private entry points directly:

#ifndef NODDRAWGDI
#define DdCreateDirectDrawObject            GdiEntry1
#define DdQueryDirectDrawObject             GdiEntry2
#define DdDeleteDirectDrawObject            GdiEntry3
#define DdCreateSurfaceObject               GdiEntry4
#define DdDeleteSurfaceObject               GdiEntry5
#define DdResetVisrgn                       GdiEntry6
#define DdGetDC                             GdiEntry7
#define DdReleaseDC                         GdiEntry8
#define DdCreateDIBSection                  GdiEntry9
#define DdReenableDirectDrawObject          GdiEntry10
#define DdAttachSurface                     GdiEntry11
#define DdUnattachSurface                   GdiEntry12
#define DdQueryDisplaySettingsUniqueness    GdiEntry13
#define DdGetDxHandle                       GdiEntry14
#define DdSetGammaRamp                      GdiEntry15
#define DdSwapTextureHandles                GdiEntry16

#ifdef DX_LONGHORN_PRESERVEDC
#define DdChangeSurfacePointer              GdiEntry17
#endif // DX_LONGHORN_PRESERVEDC

#endif

BOOL
APIENTRY
DdCreateDirectDrawObject(
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal,
    HDC                     hdc
    );

typedef struct _D3DHAL_CALLBACKS FAR *LPD3DHAL_CALLBACKS;
typedef struct _D3DHAL_GLOBALDRIVERDATA FAR *LPD3DHAL_GLOBALDRIVERDATA;

BOOL
APIENTRY
DdQueryDirectDrawObject(
    LPDDRAWI_DIRECTDRAW_GBL     pDirectDrawGlobal,
    LPDDHALINFO                 pHalInfo,
    LPDDHAL_DDCALLBACKS         pDDCallbacks,
    LPDDHAL_DDSURFACECALLBACKS  pDDSurfaceCallbacks,
    LPDDHAL_DDPALETTECALLBACKS  pDDPaletteCallbacks,
    LPD3DHAL_CALLBACKS          pD3dCallbacks,
    LPD3DHAL_GLOBALDRIVERDATA   pD3dDriverData,
    LPDDHAL_DDEXEBUFCALLBACKS   pD3dBufferCallbacks,
    LPDDSURFACEDESC             pD3dTextureFormats,
    LPDWORD                     pdwFourCC,         // Can be NULL
    LPVIDMEM                    pvmList            // Can be NULL
    );

BOOL
APIENTRY
DdDeleteDirectDrawObject(
    LPDDRAWI_DIRECTDRAW_GBL   pDirectDrawGlobal
    );

BOOL
APIENTRY
DdCreateSurfaceObject(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    BOOL                      bPrimarySurface
    );

BOOL
APIENTRY
DdDeleteSurfaceObject(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal
    );

BOOL
APIENTRY
DdResetVisrgn(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    HWND                      hWnd
    );

HDC
APIENTRY
DdGetDC(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    LPPALETTEENTRY            pColorTable
    );

BOOL
APIENTRY
DdReleaseDC(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal
    );

HBITMAP
APIENTRY
DdCreateDIBSection(
    HDC               hdc,
    CONST BITMAPINFO* pbmi,
    UINT              iUsage,
    VOID**            ppvBits,
    HANDLE            hSectionApp,
    DWORD             dwOffset
    );

BOOL
APIENTRY
DdReenableDirectDrawObject(
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal,
    BOOL*                   pbNewMode
    );

BOOL
APIENTRY
DdAttachSurface(
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceFrom,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceTo
    );

VOID
APIENTRY
DdUnattachSurface(
    LPDDRAWI_DDRAWSURFACE_LCL   pSurface,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceAttached
    );

ULONG
APIENTRY
DdQueryDisplaySettingsUniqueness(
    VOID
    );

HANDLE
APIENTRY
DdGetDxHandle(
    LPDDRAWI_DIRECTDRAW_LCL	pDDraw,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurface,
    BOOL			bRelease
    );

BOOL
APIENTRY
DdSetGammaRamp(
    LPDDRAWI_DIRECTDRAW_LCL	pDDraw,
    HDC                         hdc,
    LPVOID                      lpGammaRamp
    );



DWORD 
APIENTRY
DdSwapTextureHandles(
    LPDDRAWI_DIRECTDRAW_LCL	pDDraw,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl1,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl2
    );

#ifdef DX_LONGHORN_PRESERVEDC

DWORD
APIENTRY
DdChangeSurfacePointer(
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal,
    LPDDRAWI_DIRECTDRAW_GBL     pDirectDrawGlobal,
    LPVOID                      pSurfacePointer
    );

#endif // DX_LONGHORN_PRESERVEDC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ddkernel.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkernel.h
 *  Content:	APIs for accessing kernel mode support.
 *
 ***************************************************************************/

#ifndef __DDKM_INCLUDED__
#define __DDKM_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by to get kernel interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDirectDrawKernel,             0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawSurfaceKernel,      0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke the kernel API functions.
 *
 *==========================================================================*/

typedef struct IDirectDrawKernel		FAR *LPDIRECTDRAWKERNEL;
typedef struct IDirectDrawSurfaceKernel		FAR *LPDIRECTDRAWSURFACEKERNEL;
typedef struct _DDKERNELCAPS			FAR *LPDDKERNELCAPS;


/*
 * INTERACES FOLLOW:
 *	IDirectDrawKernel
 *	IVideoPort
 */

/*
 * IDirectDrawKernel
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawKernel
DECLARE_INTERFACE_( IDirectDrawKernel, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDDKERNELCAPS) PURE;
    STDMETHOD(GetKernelHandle)(THIS_ PULONG_PTR) PURE;
    STDMETHOD(ReleaseKernelHandle)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawKernel_GetCaps(p, a)             (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawKernel_GetKernelHandle(p, a)     (p)->lpVtbl->GetKernelHandle(p, a)
#define IDirectDrawKernel_ReleaseKernelHandle(p)    (p)->lpVtbl->ReleaseKernelHandle(p)
#endif

#endif

/*
 * IDirectDrawSurfaceKernel
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceKernel
DECLARE_INTERFACE_( IDirectDrawSurfaceKernel, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(GetKernelHandle)(THIS_ PULONG_PTR) PURE;
    STDMETHOD(ReleaseKernelHandle)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurfaceKernel_GetKernelHandle(p, a)     (p)->lpVtbl->GetKernelHandle(p, a)
#define IDirectDrawSurfaceKernel_ReleaseKernelHandle(p)    (p)->lpVtbl->ReleaseKernelHandle(p)
#endif

#endif


/*
 * DDKERNELCAPS
 */
typedef struct _DDKERNELCAPS
{
    DWORD dwSize;			// size of the DDKERNELCAPS structure
    DWORD dwCaps;                       // Contains the DDKERNELCAPS_XXX flags
    DWORD dwIRQCaps;                    // Contains the DDIRQ_XXX flags
} DDKERNELCAPS, FAR *LPDDKERNELCAPS;



/****************************************************************************
 *
 * DDKERNELCAPS CAPS
 *
 ****************************************************************************/

/*
 * Indicates that the device supports field skipping.
 */
#define DDKERNELCAPS_SKIPFIELDS			0x00000001l

/*
 * Indicates that the device can support software autoflipping.
 */
#define DDKERNELCAPS_AUTOFLIP			0x00000002l

/*
 * Indicates that the device can switch between bob and weave.
 */
#define DDKERNELCAPS_SETSTATE			0x00000004l

/*
 * Indicates that a client can gain direct access to the frame buffer.
 */
#define DDKERNELCAPS_LOCK			0x00000008l

/*
 * Indicates that a client can manually flip the video port.
 */
#define DDKERNELCAPS_FLIPVIDEOPORT		0x00000010l

/*
 * Indicates that a client can manually flip the overlay.
 */
#define DDKERNELCAPS_FLIPOVERLAY		0x00000020l

/*
 * Indicates that the device supports a video port capture interface
 * capable of transfering data to system memory.
 */
#define DDKERNELCAPS_CAPTURE_SYSMEM		0x00000040l

/*
 * Indicates that the device supports a video port capture interface
 * capable of transfering data to non-local video memory.
 */
#define DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM	0x00000080l

/*
 * Indicates that the device can report the polarity (even/odd) of
 * the curent video field.
 */
#define DDKERNELCAPS_FIELDPOLARITY		0x00000100l

/*
 * Indicates that the device supports inverting the DIBs while capturing
 * the data.
 */
#define DDKERNELCAPS_CAPTURE_INVERTED		0x00000200l

/****************************************************************************
 *
 * DDKERNELCAPS IRQ CAPS
 *
 ****************************************************************************/

/*
 * The device can generate display VSYNC IRQs
 */
#define DDIRQ_DISPLAY_VSYNC			0x00000001l

/*
 * Reserved
 */
#define DDIRQ_RESERVED1				0x00000002l

/*
 * The device can generate video ports VSYNC IRQs using video port 0
 */
#define DDIRQ_VPORT0_VSYNC			0x00000004l

/*
 * The device can generate video ports line IRQs using video port 0
 */
#define DDIRQ_VPORT0_LINE			0x00000008l

/*
 * The device can generate video ports VSYNC IRQs using video port 1
 */
#define DDIRQ_VPORT1_VSYNC			0x00000010l

/*
 * The device can generate video ports line IRQs using video port 1
 */
#define DDIRQ_VPORT1_LINE			0x00000020l

/*
 * The device can generate video ports VSYNC IRQs using video port 2
 */
#define DDIRQ_VPORT2_VSYNC			0x00000040l

/*
 * The device can generate video ports line IRQs using video port 2
 */
#define DDIRQ_VPORT2_LINE			0x00000080l

/*
 * The device can generate video ports VSYNC IRQs using video port 3
 */
#define DDIRQ_VPORT3_VSYNC			0x00000100l

/*
 * The device can generate video ports line IRQs using video port 3
 */
#define DDIRQ_VPORT3_LINE			0x00000200l

/*
 * The device can generate video ports VSYNC IRQs using video port 4
 */
#define DDIRQ_VPORT4_VSYNC			0x00000400l

/*
 * The device can generate video ports line IRQs using video port 4
 */
#define DDIRQ_VPORT4_LINE			0x00000800l

/*
 * The device can generate video ports VSYNC IRQs using video port 5
 */
#define DDIRQ_VPORT5_VSYNC			0x00001000l

/*
 * The device can generate video ports line IRQs using video port 5
 */
#define DDIRQ_VPORT5_LINE			0x00002000l

/*
 * The device can generate video ports VSYNC IRQs using video port 6
 */
#define DDIRQ_VPORT6_VSYNC			0x00004000l

/*
 * The device can generate video ports line IRQs using video port 6
 */
#define DDIRQ_VPORT6_LINE			0x00008000l

/*
 * The device can generate video ports VSYNC IRQs using video port 7
 */
#define DDIRQ_VPORT7_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 7
 */
#define DDIRQ_VPORT7_LINE			0x00020000l

/*
 * The device can generate video ports VSYNC IRQs using video port 8
 */
#define DDIRQ_VPORT8_VSYNC			0x00040000l

/*
 * The device can generate video ports line IRQs using video port 8
 */
#define DDIRQ_VPORT8_LINE			0x00080000l

/*
 * The device can generate video ports VSYNC IRQs using video port 9
 */
#define DDIRQ_VPORT9_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 9
 */
#define DDIRQ_VPORT9_LINE			0x00020000l



#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmapi.h
 *  Content:	Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD  dwFunctionNum,
    LPVOID lpvInBuffer,
    DWORD  cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD  cbOutBuffer
);

typedef
DWORD
(FAR PASCAL *LPDXAPI)(
    DWORD   dwFunctionNum,
    LPVOID  lpvInBuffer,
    DWORD   cbInBuffer,
    LPVOID  lpvOutBuffer,
    DWORD   cbOutBuffer
);

#define DXAPI_MAJORVERSION		1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI					0x500

typedef ULONG (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        ULONG_PTR            dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
	HANDLE	            hDirectDraw;
        ULONG_PTR            dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
	HANDLE		    hDirectDraw;
        ULONG               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
	DWORD	ddRVal;
        DWORD	dwCaps;
	DWORD	dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
	DWORD	ddRVal;
	DWORD	dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD			(DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE			(DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
	DWORD	ddRVal;
	DWORD	dwStateCaps;
	DWORD	dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE			(DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
	DWORD	dwState;
	DWORD	dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK					(DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
	DWORD	ddRVal;
	DWORD	dwSurfHeight;
	DWORD	dwSurfWidth;
	LONG	lSurfPitch;
	PVOID	lpSurface;
	DWORD	SurfaceCaps;
	DWORD	dwFormatFlags;
	DWORD	dwFormatFourCC;
	DWORD	dwFormatBitCount;
	union
	{
	    DWORD	dwRBitMask;
	    DWORD	dwYBitMask;
    	};
    	union
    	{
	    DWORD	dwGBitMask;
	    DWORD	dwUBitMask;
	};
	union
	{
	    DWORD	dwBBitMask;
	    DWORD	dwVBitMask;
	};
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY				(DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
	HANDLE	hDirectDraw;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP				(DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE	(DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
	DWORD	ddRVal;
	HANDLE	hVideoSurface;
	HANDLE	hVBISurface;
	BOOL	bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE		(DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK			(DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
	HANDLE 	            hDirectDraw;
	ULONG	            dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
	ULONG_PTR            dwParam1;
	ULONG_PTR            dwParam2;
	PVOID	            pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK			(DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY				(DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
	HANDLE 	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
	DWORD 	ddRVal;
	BOOL	bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE			(DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
	HANDLE  hDirectDraw;
	HANDLE  hVideoPort;
	DWORD   dwStartLine;
	DWORD   dwEndLine;
	DWORD   dwCaptureEveryNFields;
	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	PVOID   pContext;
	DWORD	dwFlags;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
	DWORD	ddRVal;
	HANDLE	hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

    #define DDOPENCAPTURE_VIDEO	0x0001	// Capture from the video stream
    #define DDOPENCAPTURE_VBI	0x0002	// Capture from the VBI stream

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER			(DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
	DWORD   	dwFieldNumber;
	DWORD   	bPolarity;
	LARGE_INTEGER	liTimeStamp;
	DWORD   	ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
	HANDLE  hCapture;
	DWORD   dwFlags;
	PMDL    pMDL;
	PKEVENT pKEvent;
	LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY	0x0001	// lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM	0x0002	// lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT		0x0004	// invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS			(DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB				0x0001
#define DDSTATE_WEAVE				0x0002
#define DDSTATE_EXPLICITLY_SET			0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP		0x0008
#define DDSTATE_SKIPEVENFIELDS			0x0010

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC			0x0001
#define DDEVENT_VP_VSYNC			0x0002
#define DDEVENT_VP_LINE				0x0004
#define DDEVENT_PRERESCHANGE			0x0008
#define DDEVENT_POSTRESCHANGE			0x0010
#define DDEVENT_PREDOSBOX			0x0020
#define DDEVENT_POSTDOSBOX			0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC			0x0001	// dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC			0x0002	// dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE	  		0x0004	// dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE			0x0008	// dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE			0x0010	// dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX			0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX			0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW		0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE			0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT			0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE			0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ddrawint.h ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    ddrawint.h

Abstract:

    Private entry points, defines and types for Windows NT DirectDraw
    driver interface.  Corresponds to Windows' 'ddrawi.h' file.

    The structure names for NT are different from that of Win95.  Use
    dx95type.h to aid in porting DirectX code from Win95 to NT.

--*/

#ifndef __DD_INCLUDED__
#define __DD_INCLUDED__

/*
 * These GUIDs are used to identify driver info structures, not interfaces,
 * so the prefix GUID_ is used instead of IID_.
 */

DEFINE_GUID( GUID_MiscellaneousCallbacks,       0xefd60cc0, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_Miscellaneous2Callbacks,      0x406B2F00, 0x3E5A, 0x11D1, 0xB6, 0x40, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x6A);
DEFINE_GUID( GUID_VideoPortCallbacks,           0xefd60cc1, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_ColorControlCallbacks,        0xefd60cc2, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_MotionCompCallbacks,          0xb1122b40, 0x5dA5, 0x11d1, 0x8f, 0xcF, 0x00, 0xc0, 0x4f, 0xc2, 0x9b, 0x4e);
DEFINE_GUID( GUID_VideoPortCaps,                0xefd60cc3, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCaps,                      0x7bf06991, 0x8794, 0x11d0, 0x91, 0x39, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);
DEFINE_GUID( GUID_D3DExtendedCaps, 		0x7de41f80, 0x9d93, 0x11d0, 0x89, 0xab, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID( GUID_D3DCallbacks,                 0x7bf06990, 0x8794, 0x11d0, 0x91, 0x39, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);
DEFINE_GUID( GUID_D3DCallbacks2,                0xba584e1, 0x70b6, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks3,                0xddf41230, 0xec0a, 0x11d0, 0xa9, 0xb6, 0x00, 0xaa, 0x00, 0xc0, 0x99, 0x3e);
DEFINE_GUID( GUID_NonLocalVidMemCaps,           0x86c4fa80, 0x8d84, 0x11d0, 0x94, 0xe8, 0x00, 0xc0, 0x4f, 0xc3, 0x41, 0x37);
DEFINE_GUID( GUID_KernelCallbacks,              0x80863800, 0x6B06, 0x11D0, 0x9B, 0x06, 0x0, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_KernelCaps,                   0xFFAA7540, 0x7AA8, 0x11D0, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_ZPixelFormats,                0x93869880, 0x36cf, 0x11d1, 0x9b, 0x1b, 0x0, 0xaa, 0x0, 0xbb, 0xb8, 0xae);
DEFINE_GUID( GUID_DDMoreCaps,                   0x880baf30, 0xb030, 0x11d0, 0x8e, 0xa7, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b);
DEFINE_GUID( GUID_D3DParseUnknownCommandCallback, 0x2e04ffa0, 0x98e4, 0x11d1, 0x8c, 0xe1, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_NTCallbacks,                  0x6fe9ecde, 0xdf89, 0x11d1, 0x9d, 0xb0, 0x00, 0x60, 0x08, 0x27, 0x71, 0xba);
DEFINE_GUID( GUID_DDMoreSurfaceCaps,            0x3b8a0466, 0xf269, 0x11d1, 0x88, 0x0b, 0x0, 0xc0, 0x4f, 0xd9, 0x30, 0xc5);
DEFINE_GUID( GUID_GetHeapAlignment,             0x42e02f16, 0x7b41, 0x11d2, 0x8b, 0xff, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_UpdateNonLocalHeap,           0x42e02f17, 0x7b41, 0x11d2, 0x8b, 0xff, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_NTPrivateDriverCaps,          0xfad16a23, 0x7b66, 0x11d2, 0x83, 0xd7, 0x0, 0xc0, 0x4f, 0x7c, 0xe5, 0x8c);
DEFINE_GUID( GUID_DDStereoMode,                 0xf828169c, 0xa8e8, 0x11d2, 0xa1, 0xf2, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_VPE2Callbacks,                0x52882147, 0x2d47, 0x469a, 0xa0, 0xd1, 0x3, 0x45, 0x58, 0x90, 0xf6, 0xc8);

#ifndef GUID_DEFS_ONLY

#ifndef _NO_DDRAWINT_NO_COM
#ifndef _NO_COM
#define _NO_COM
#include "ddraw.h"
#include "dvp.h"
#undef _NO_COM
#else
#include "ddraw.h"
#include "dvp.h"
#endif
#else
#include "ddraw.h"
#include "dvp.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/*
 * offset into video meory
 */
typedef ULONG_PTR FLATPTR;

/*
 * maximum number of surfaces that can be autoflipped between
 */
#define MAX_AUTOFLIP_BUFFERS    10

/*
 * Indicates the surface is D3D buffer, i.e., a linear chunk of
 * memory that holds a Direct3D structure. A driver reports this
 * cap to indicate that it can create buffers in video memory and
 * Direct3D uses this bit to request buffers. However, it is not
 * visible to the API.
 */
#define DDSCAPS_EXECUTEBUFFER DDSCAPS_RESERVED2
#define DDSCAPS_COMMANDBUFFER DDSCAPS_RESERVED3
#define DDSCAPS_VERTEXBUFFER DDSCAPS_RESERVED4


/*
 * This DDPF flag is used to indicate a DX8+ format capability entry in
 * the texture format list. It is not visible to applications.
 */
#define DDPF_D3DFORMAT                                          0x00200000l

/*
 * List of operations supported on formats in DX8+ texture list.
 * See the DX8 DDK for a complete description of these flags.
 */
#define D3DFORMAT_OP_TEXTURE                    0x00000001L
#define D3DFORMAT_OP_VOLUMETEXTURE              0x00000002L
#define D3DFORMAT_OP_CUBETEXTURE                0x00000004L
#define D3DFORMAT_OP_OFFSCREEN_RENDERTARGET     0x00000008L
#define D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET   0x00000010L
#define D3DFORMAT_OP_ZSTENCIL                   0x00000040L
#define D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L

// This format can be used as a render target if the current display mode
// is the same depth if the alpha channel is ignored. e.g. if the device 
// can render to A8R8G8B8 when the display mode is X8R8G8B8, then the
// format op list entry for A8R8G8B8 should have this cap. 
#define D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET 0x00000100L

// This format contains DirectDraw support (including Flip).  This flag
// should not to be set on alpha formats.
#define D3DFORMAT_OP_DISPLAYMODE                0x00000400L

// The rasterizer can support some level of Direct3D support in this format
// and implies that the driver can create a Context in this mode (for some 
// render target format).  When this flag is set, the D3DFORMAT_OP_DISPLAYMODE
// flag must also be set.
#define D3DFORMAT_OP_3DACCELERATION             0x00000800L

// If the driver needs a private format to be D3D or driver manageable,
// then it needs to tell D3D the pixelsize in bits per pixel by setting
// dwPrivateFormatBitCount in DDPIXELFORMAT and by setting the below
// format op. If the below format op is not set, then D3D or the driver
// will NOT be allowed to manage the format.
#define D3DFORMAT_OP_PIXELSIZE                  0x00001000L

// Indicates that this format can be converted to any RGB format for which
// D3DFORMAT_MEMBEROFGROUP_ARGB is specified
#define D3DFORMAT_OP_CONVERT_TO_ARGB            0x00002000L

// Indicates that this format can be used to create offscreen plain surfaces.
#define D3DFORMAT_OP_OFFSCREENPLAIN             0x00004000L

// Indicated that this format can be read as an SRGB texture (meaning that the
// sampler will linearize the looked up data)
#define D3DFORMAT_OP_SRGBREAD                   0x00008000L

// Indicates that this format can be used in the bumpmap instructions
#define D3DFORMAT_OP_BUMPMAP                    0x00010000L

// Indicates that this format can be sampled by the displacement map sampler
#define D3DFORMAT_OP_DMAP                       0x00020000L

// Indicates that this format cannot be used with texture filtering
#define D3DFORMAT_OP_NOFILTER                   0x00040000L

// Indicates that format conversions are supported to this RGB format if
// D3DFORMAT_OP_CONVERT_TO_ARGB is specified in the source format.
#define D3DFORMAT_MEMBEROFGROUP_ARGB            0x00080000L

// Indicated that this format can be written as an SRGB target (meaning that the
// pixel pipe will DE-linearize data on output to format)
#define D3DFORMAT_OP_SRGBWRITE                  0x00100000L

// Indicates that this format cannot be used with alpha blending
#define D3DFORMAT_OP_NOALPHABLEND               0x00200000L

//Indicates that the device can auto-generated sublevels for resources
//of this format
#define D3DFORMAT_OP_AUTOGENMIPMAP              0x00400000L

// Indicates that this format cannot be used by vertex texture sampler
#define D3DFORMAT_OP_VERTEXTEXTURE              0x00800000L 

// Indicates that this format supports neither texture coordinate wrap modes, nor mipmapping
#define D3DFORMAT_OP_NOTEXCOORDWRAPNORMIP		0x01000000L

/*
 * pre-declare pointers to structs containing data for DDHAL driver fns
 */
typedef struct _DD_CREATEPALETTEDATA *PDD_CREATEPALETTEDATA;
typedef struct _DD_CREATESURFACEDATA *PDD_CREATESURFACEDATA;
typedef struct _DD_CANCREATESURFACEDATA *PDD_CANCREATESURFACEDATA;
typedef struct _DD_WAITFORVERTICALBLANKDATA *PDD_WAITFORVERTICALBLANKDATA;
typedef struct _DD_DESTROYDRIVERDATA *PDD_DESTROYDRIVERDATA;
typedef struct _DD_SETMODEDATA *PDD_SETMODEDATA;
typedef struct _DD_DRVSETCOLORKEYDATA *PDD_DRVSETCOLORKEYDATA;
typedef struct _DD_GETSCANLINEDATA *PDD_GETSCANLINEDATA;
typedef struct _DD_MAPMEMORYDATA *PDD_MAPMEMORYDATA;

typedef struct _DD_DESTROYPALETTEDATA *PDD_DESTROYPALETTEDATA;
typedef struct _DD_SETENTRIESDATA *PDD_SETENTRIESDATA;

typedef struct _DD_BLTDATA *PDD_BLTDATA;
typedef struct _DD_LOCKDATA *PDD_LOCKDATA;
typedef struct _DD_UNLOCKDATA *PDD_UNLOCKDATA;
typedef struct _DD_UPDATEOVERLAYDATA *PDD_UPDATEOVERLAYDATA;
typedef struct _DD_SETOVERLAYPOSITIONDATA *PDD_SETOVERLAYPOSITIONDATA;
typedef struct _DD_SETPALETTEDATA *PDD_SETPALETTEDATA;
typedef struct _DD_FLIPDATA *PDD_FLIPDATA;
typedef struct _DD_DESTROYSURFACEDATA *PDD_DESTROYSURFACEDATA;
typedef struct _DD_SETCLIPLISTDATA *PDD_SETCLIPLISTDATA;
typedef struct _DD_ADDATTACHEDSURFACEDATA *PDD_ADDATTACHEDSURFACEDATA;
typedef struct _DD_SETCOLORKEYDATA *PDD_SETCOLORKEYDATA;
typedef struct _DD_GETBLTSTATUSDATA *PDD_GETBLTSTATUSDATA;
typedef struct _DD_GETFLIPSTATUSDATA *PDD_GETFLIPSTATUSDATA;

typedef struct _DD_CANCREATEVPORTDATA *PDD_CANCREATEVPORTDATA;
typedef struct _DD_CREATEVPORTDATA *PDD_CREATEVPORTDATA;
typedef struct _DD_FLIPVPORTDATA *PDD_FLIPVPORTDATA;
typedef struct _DD_GETVPORTCONNECTDATA *PDD_GETVPORTCONNECTDATA;
typedef struct _DD_GETVPORTBANDWIDTHDATA *PDD_GETVPORTBANDWIDTHDATA;
typedef struct _DD_GETVPORTINPUTFORMATDATA *PDD_GETVPORTINPUTFORMATDATA;
typedef struct _DD_GETVPORTOUTPUTFORMATDATA *PDD_GETVPORTOUTPUTFORMATDATA;
typedef struct _DD_GETVPORTAUTOFLIPSURFACEDATA *PDD_GETVPORTAUTOFLIPSURFACEDATA;
typedef struct _DD_GETVPORTFIELDDATA *PDD_GETVPORTFIELDDATA;
typedef struct _DD_GETVPORTLINEDATA *PDD_GETVPORTLINEDATA;
typedef struct _DD_DESTROYVPORTDATA *PDD_DESTROYVPORTDATA;
typedef struct _DD_GETVPORTFLIPSTATUSDATA *PDD_GETVPORTFLIPSTATUSDATA;
typedef struct _DD_UPDATEVPORTDATA *PDD_UPDATEVPORTDATA;
typedef struct _DD_WAITFORVPORTSYNCDATA *PDD_WAITFORVPORTSYNCDATA;
typedef struct _DD_GETVPORTSIGNALDATA *PDD_GETVPORTSIGNALDATA;
typedef struct _DD_VPORTCOLORDATA *PDD_VPORTCOLORDATA;

typedef struct _DD_COLORCONTROLDATA *PDD_COLORCONTROLDATA;

typedef struct _DD_GETAVAILDRIVERMEMORYDATA *PDD_GETAVAILDRIVERMEMORYDATA;

typedef struct _DD_FREEDRIVERMEMORYDATA *PDD_FREEDRIVERMEMORYDATA;
typedef struct _DD_SETEXCLUSIVEMODEDATA *PDD_SETEXCLUSIVEMODEDATA;
typedef struct _DD_FLIPTOGDISURFACEDATA *PDD_FLIPTOGDISURFACEDATA;

typedef struct _DD_GETDRIVERINFODATA *PDD_GETDRIVERINFODATA;

typedef struct _DD_SYNCSURFACEDATA *PDD_SYNCSURFACEDATA;
typedef struct _DD_SYNCVIDEOPORTDATA *PDD_SYNCVIDEOPORTDATA;

typedef struct _DD_GETMOCOMPGUIDSDATA *PDD_GETMOCOMPGUIDSDATA;
typedef struct _DD_GETMOCOMPFORMATSDATA *PDD_GETMOCOMPFORMATSDATA;
typedef struct _DD_CREATEMOCOMPDATA *PDD_CREATEMOCOMPDATA;
typedef struct _DD_GETMOCOMPCOMPBUFFDATA *PDD_GETMOCOMPCOMPBUFFDATA;
typedef struct _DD_GETINTERNALMOCOMPDATA *PDD_GETINTERNALMOCOMPDATA;
typedef struct _DD_BEGINMOCOMPFRAMEDATA *PDD_BEGINMOCOMPFRAMEDATA;
typedef struct _DD_ENDMOCOMPFRAMEDATA *PDD_ENDMOCOMPFRAMEDATA;
typedef struct _DD_RENDERMOCOMPDATA *PDD_RENDERMOCOMPDATA;
typedef struct _DD_QUERYMOCOMPSTATUSDATA *PDD_QUERYMOCOMPSTATUSDATA;
typedef struct _DD_DESTROYMOCOMPDATA *PDD_DESTROYMOCOMPDATA;

// Miscelleneous2 callbacks
typedef struct _DD_CREATESURFACEEXDATA *PDD_CREATESURFACEEXDATA;
typedef struct _DD_GETDRIVERSTATEDATA *PDD_GETDRIVERSTATEDATA;
typedef struct _DD_DESTROYDDLOCALDATA *PDD_DESTROYDDLOCALDATA;
typedef struct _DD_MORESURFACECAPS *PDD_MORESURFACECAPS;
typedef struct _DD_STEREOMODE *PDD_STEREOMODE;
typedef struct _DD_UPDATENONLOCALHEAPDATA *PDD_UPDATENONLOCALHEAPDATA;



/*
 * The following structure is defined in dmemmgr.h
 */
struct _DD_GETHEAPALIGNMENTDATA;
typedef struct _DD_GETHEAPALIGNMENTDATA *PDD_GETHEAPALIGNMENTDATA;

/*
 * value in the fpVidMem; indicates dwBlockSize is valid (surface object)
 */
#define DDHAL_PLEASEALLOC_BLOCKSIZE     0x00000002l
#define DDHAL_PLEASEALLOC_USERMEM       0x00000004l

/*
 * video memory data structures (passed in DD_HALINFO)
 */
typedef struct _VIDEOMEMORY
{
    DWORD               dwFlags;        // flags
    FLATPTR             fpStart;        // start of memory chunk
    union
    {
        FLATPTR         fpEnd;          // end of memory chunk
        DWORD           dwWidth;        // width of chunk (rectanglar memory)
    };
    DDSCAPS             ddsCaps;        // what this memory CANNOT be used for
    DDSCAPS             ddsCapsAlt;     // what this memory CANNOT be used for if it must
    union
    {
        struct _VMEMHEAP *lpHeap;       // heap pointer, used by DDRAW
        DWORD           dwHeight;       // height of chunk (rectanguler memory)
    };
} VIDEOMEMORY;
typedef VIDEOMEMORY *LPVIDEOMEMORY;

/*
 * flags for vidmem struct
 */
#define VIDMEM_ISLINEAR         0x00000001l     // heap is linear
#define VIDMEM_ISRECTANGULAR    0x00000002l     // heap is rectangular
#define VIDMEM_ISHEAP           0x00000004l     // heap is preallocated by driver
#define VIDMEM_ISNONLOCAL       0x00000008l     // heap populated with non-local video memory
#define VIDMEM_ISWC             0x00000010l     // heap populated with write combining memory
#define VIDMEM_HEAPDISABLED     0x00000020l     // heap disabled

typedef struct _VIDEOMEMORYINFO
{
    FLATPTR             fpPrimary;              // offset to primary surface
    DWORD               dwFlags;                // flags
    DWORD               dwDisplayWidth;         // current display width
    DWORD               dwDisplayHeight;        // current display height
    LONG                lDisplayPitch;          // current display pitch
    DDPIXELFORMAT       ddpfDisplay;            // pixel format of display
    DWORD               dwOffscreenAlign;       // byte alignment for offscreen surfaces
    DWORD               dwOverlayAlign;         // byte alignment for overlays
    DWORD               dwTextureAlign;         // byte alignment for textures
    DWORD               dwZBufferAlign;         // byte alignment for z buffers
    DWORD               dwAlphaAlign;           // byte alignment for alpha
    PVOID               pvPrimary;              // kernel-mode pointer to primary surface
} VIDEOMEMORYINFO;
typedef VIDEOMEMORYINFO *LPVIDEOMEMORYINFO;

/*
 * These structures contain the entry points in the display driver that
 * DDRAW will call.   Entries that the display driver does not care about
 * should be NULL.   Passed to DDRAW in DD_HALINFO.
 */
typedef struct _DD_DIRECTDRAW_GLOBAL *PDD_DIRECTDRAW_GLOBAL;
typedef struct _DD_SURFACE_GLOBAL *PDD_SURFACE_GLOBAL;
typedef struct _DD_PALETTE_GLOBAL *PDD_PALETTE_GLOBAL;
typedef struct _DD_CLIPPER_GLOBAL *PDD_CLIPPER_GLOBAL;
typedef struct _DD_DIRECTDRAW_LOCAL *PDD_DIRECTDRAW_LOCAL;
typedef struct _DD_SURFACE_LOCAL *PDD_SURFACE_LOCAL;
typedef struct _DD_SURFACE_MORE *PDD_SURFACE_MORE;
typedef struct _DD_SURFACE_INT *PDD_SURFACE_INT;
typedef struct _DD_VIDEOPORT_LOCAL *PDD_VIDEOPORT_LOCAL;
typedef struct _DD_PALETTE_LOCAL *PDD_PALETTE_LOCAL;
typedef struct _DD_CLIPPER_LOCAL *PDD_CLIPPER_LOCAL;
typedef struct _DD_MOTIONCOMP_LOCAL *PDD_MOTIONCOMP_LOCAL;

/*
 * DIRECTDRAW object callbacks
 */
typedef DWORD   (APIENTRY *PDD_SETCOLORKEY)(PDD_DRVSETCOLORKEYDATA );
typedef DWORD   (APIENTRY *PDD_CANCREATESURFACE)(PDD_CANCREATESURFACEDATA );
typedef DWORD   (APIENTRY *PDD_WAITFORVERTICALBLANK)(PDD_WAITFORVERTICALBLANKDATA );
typedef DWORD   (APIENTRY *PDD_CREATESURFACE)(PDD_CREATESURFACEDATA);
typedef DWORD   (APIENTRY *PDD_DESTROYDRIVER)(PDD_DESTROYDRIVERDATA);
typedef DWORD   (APIENTRY *PDD_SETMODE)(PDD_SETMODEDATA);
typedef DWORD   (APIENTRY *PDD_CREATEPALETTE)(PDD_CREATEPALETTEDATA);
typedef DWORD   (APIENTRY *PDD_GETSCANLINE)(PDD_GETSCANLINEDATA);
typedef DWORD   (APIENTRY *PDD_MAPMEMORY)(PDD_MAPMEMORYDATA);

typedef DWORD   (APIENTRY *PDD_GETDRIVERINFO)(PDD_GETDRIVERINFODATA);

typedef struct DD_CALLBACKS
{
    DWORD                       dwSize;
    DWORD                       dwFlags;
    PDD_DESTROYDRIVER           DestroyDriver;
    PDD_CREATESURFACE           CreateSurface;
    PDD_SETCOLORKEY             SetColorKey;
    PDD_SETMODE                 SetMode;
    PDD_WAITFORVERTICALBLANK    WaitForVerticalBlank;
    PDD_CANCREATESURFACE        CanCreateSurface;
    PDD_CREATEPALETTE           CreatePalette;
    PDD_GETSCANLINE             GetScanLine;
    PDD_MAPMEMORY               MapMemory;
} DD_CALLBACKS;

typedef DD_CALLBACKS *PDD_CALLBACKS;

#define DDHAL_CB32_DESTROYDRIVER        0x00000001l
#define DDHAL_CB32_CREATESURFACE        0x00000002l
#define DDHAL_CB32_SETCOLORKEY          0x00000004l
#define DDHAL_CB32_SETMODE              0x00000008l
#define DDHAL_CB32_WAITFORVERTICALBLANK 0x00000010l
#define DDHAL_CB32_CANCREATESURFACE     0x00000020l
#define DDHAL_CB32_CREATEPALETTE        0x00000040l
#define DDHAL_CB32_GETSCANLINE          0x00000080l
#define DDHAL_CB32_MAPMEMORY            0x80000000l

// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_MiscellaneousCallbacks

typedef DWORD   (APIENTRY *PDD_GETAVAILDRIVERMEMORY)(PDD_GETAVAILDRIVERMEMORYDATA);

typedef struct _DD_MISCELLANEOUSCALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_GETAVAILDRIVERMEMORY            GetAvailDriverMemory;
} DD_MISCELLANEOUSCALLBACKS, *PDD_MISCELLANEOUSCALLBACKS;

#define DDHAL_MISCCB32_GETAVAILDRIVERMEMORY    0x00000001l

// DDHAL_DDMISCELLANEOUS2CALLBACKS:
//   This structure can be queried from the driver from DX7 onward
//   using GetDriverInfo with GUID_Miscellaneous2Callbacks

typedef DWORD   (APIENTRY *PDD_ALPHABLT)(PDD_BLTDATA);
typedef DWORD   (APIENTRY *PDD_CREATESURFACEEX)(PDD_CREATESURFACEEXDATA);
typedef DWORD   (APIENTRY *PDD_GETDRIVERSTATE)(PDD_GETDRIVERSTATEDATA);
typedef DWORD   (APIENTRY *PDD_DESTROYDDLOCAL)(PDD_DESTROYDDLOCALDATA);

typedef struct _DD_MISCELLANEOUS2CALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_ALPHABLT                        AlphaBlt;
    PDD_CREATESURFACEEX                 CreateSurfaceEx;
    PDD_GETDRIVERSTATE                  GetDriverState;
    PDD_DESTROYDDLOCAL                  DestroyDDLocal;
} DD_MISCELLANEOUS2CALLBACKS, *PDD_MISCELLANEOUS2CALLBACKS;

#define DDHAL_MISC2CB32_ALPHABLT                 0x00000001l
#define DDHAL_MISC2CB32_CREATESURFACEEX          0x00000002l
#define DDHAL_MISC2CB32_GETDRIVERSTATE           0x00000004l
#define DDHAL_MISC2CB32_DESTROYDDLOCAL           0x00000008l

// This is used in the CreateSurfaceEx callback to indicate that the
// SwapHandle emulation is being done
#define DDHAL_CREATESURFACEEX_SWAPHANDLES      0x00000001l

// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_NTCallbacks

typedef DWORD   (APIENTRY *PDD_FREEDRIVERMEMORY)(PDD_FREEDRIVERMEMORYDATA);
typedef DWORD   (APIENTRY *PDD_SETEXCLUSIVEMODE)(PDD_SETEXCLUSIVEMODEDATA);
typedef DWORD   (APIENTRY *PDD_FLIPTOGDISURFACE)(PDD_FLIPTOGDISURFACEDATA);

typedef struct _DD_NTCALLBACKS {
    DWORD                   dwSize;
    DWORD                   dwFlags;
    PDD_FREEDRIVERMEMORY    FreeDriverMemory;
    PDD_SETEXCLUSIVEMODE    SetExclusiveMode;
    PDD_FLIPTOGDISURFACE    FlipToGDISurface;
} DD_NTCALLBACKS, *PDD_NTCALLBACKS;

#define DDHAL_NTCB32_FREEDRIVERMEMORY   0x00000001l
#define DDHAL_NTCB32_SETEXCLUSIVEMODE   0x00000002l
#define DDHAL_NTCB32_FLIPTOGDISURFACE   0x00000004l

/*
 * DIRECTDRAWPALETTE object callbacks
 */
typedef DWORD   (APIENTRY *PDD_PALCB_DESTROYPALETTE)(PDD_DESTROYPALETTEDATA );
typedef DWORD   (APIENTRY *PDD_PALCB_SETENTRIES)(PDD_SETENTRIESDATA );

typedef struct DD_PALETTECALLBACKS
{
    DWORD                       dwSize;
    DWORD                       dwFlags;
    PDD_PALCB_DESTROYPALETTE    DestroyPalette;
    PDD_PALCB_SETENTRIES        SetEntries;
} DD_PALETTECALLBACKS;

typedef DD_PALETTECALLBACKS *PDD_PALETTECALLBACKS;

#define DDHAL_PALCB32_DESTROYPALETTE    0x00000001l
#define DDHAL_PALCB32_SETENTRIES        0x00000002l

/*
 * DIRECTDRAWSURFACE object callbacks
 */
typedef DWORD   (APIENTRY *PDD_SURFCB_LOCK)(PDD_LOCKDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_UNLOCK)(PDD_UNLOCKDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_BLT)(PDD_BLTDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_UPDATEOVERLAY)(PDD_UPDATEOVERLAYDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETOVERLAYPOSITION)(PDD_SETOVERLAYPOSITIONDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETPALETTE)(PDD_SETPALETTEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_FLIP)(PDD_FLIPDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_DESTROYSURFACE)(PDD_DESTROYSURFACEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETCLIPLIST)(PDD_SETCLIPLISTDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_ADDATTACHEDSURFACE)(PDD_ADDATTACHEDSURFACEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETCOLORKEY)(PDD_SETCOLORKEYDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_GETBLTSTATUS)(PDD_GETBLTSTATUSDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_GETFLIPSTATUS)(PDD_GETFLIPSTATUSDATA);


typedef struct DD_SURFACECALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_SURFCB_DESTROYSURFACE           DestroySurface;
    PDD_SURFCB_FLIP                     Flip;
    PDD_SURFCB_SETCLIPLIST              SetClipList;
    PDD_SURFCB_LOCK                     Lock;
    PDD_SURFCB_UNLOCK                   Unlock;
    PDD_SURFCB_BLT                      Blt;
    PDD_SURFCB_SETCOLORKEY              SetColorKey;
    PDD_SURFCB_ADDATTACHEDSURFACE       AddAttachedSurface;
    PDD_SURFCB_GETBLTSTATUS             GetBltStatus;
    PDD_SURFCB_GETFLIPSTATUS            GetFlipStatus;
    PDD_SURFCB_UPDATEOVERLAY            UpdateOverlay;
    PDD_SURFCB_SETOVERLAYPOSITION       SetOverlayPosition;
    LPVOID                              reserved4;
    PDD_SURFCB_SETPALETTE               SetPalette;
} DD_SURFACECALLBACKS;
typedef DD_SURFACECALLBACKS *PDD_SURFACECALLBACKS;

#define DDHAL_SURFCB32_DESTROYSURFACE           0x00000001l
#define DDHAL_SURFCB32_FLIP                     0x00000002l
#define DDHAL_SURFCB32_SETCLIPLIST              0x00000004l
#define DDHAL_SURFCB32_LOCK                     0x00000008l
#define DDHAL_SURFCB32_UNLOCK                   0x00000010l
#define DDHAL_SURFCB32_BLT                      0x00000020l
#define DDHAL_SURFCB32_SETCOLORKEY              0x00000040l
#define DDHAL_SURFCB32_ADDATTACHEDSURFACE       0x00000080l
#define DDHAL_SURFCB32_GETBLTSTATUS             0x00000100l
#define DDHAL_SURFCB32_GETFLIPSTATUS            0x00000200l
#define DDHAL_SURFCB32_UPDATEOVERLAY            0x00000400l
#define DDHAL_SURFCB32_SETOVERLAYPOSITION       0x00000800l
#define DDHAL_SURFCB32_RESERVED4                0x00001000l
#define DDHAL_SURFCB32_SETPALETTE               0x00002000l

/*
 * DIRECTVIDEOPORT object callbacks
 */
typedef DWORD (APIENTRY *PDD_VPORTCB_CANCREATEVIDEOPORT)(PDD_CANCREATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_CREATEVIDEOPORT)(PDD_CREATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_FLIP)(PDD_FLIPVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETBANDWIDTH)(PDD_GETVPORTBANDWIDTHDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETINPUTFORMATS)(PDD_GETVPORTINPUTFORMATDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETOUTPUTFORMATS)(PDD_GETVPORTOUTPUTFORMATDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETAUTOFLIPSURF)(PDD_GETVPORTAUTOFLIPSURFACEDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETFIELD)(PDD_GETVPORTFIELDDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETLINE)(PDD_GETVPORTLINEDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETVPORTCONNECT)(PDD_GETVPORTCONNECTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_DESTROYVPORT)(PDD_DESTROYVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETFLIPSTATUS)(PDD_GETVPORTFLIPSTATUSDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_UPDATE)(PDD_UPDATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_WAITFORSYNC)(PDD_WAITFORVPORTSYNCDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETSIGNALSTATUS)(PDD_GETVPORTSIGNALDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_COLORCONTROL)(PDD_VPORTCOLORDATA);

typedef struct DD_VIDEOPORTCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_VPORTCB_CANCREATEVIDEOPORT      CanCreateVideoPort;
    PDD_VPORTCB_CREATEVIDEOPORT         CreateVideoPort;
    PDD_VPORTCB_FLIP                    FlipVideoPort;
    PDD_VPORTCB_GETBANDWIDTH            GetVideoPortBandwidth;
    PDD_VPORTCB_GETINPUTFORMATS         GetVideoPortInputFormats;
    PDD_VPORTCB_GETOUTPUTFORMATS        GetVideoPortOutputFormats;
    LPVOID                              lpReserved1;
    PDD_VPORTCB_GETFIELD                GetVideoPortField;
    PDD_VPORTCB_GETLINE                 GetVideoPortLine;
    PDD_VPORTCB_GETVPORTCONNECT         GetVideoPortConnectInfo;
    PDD_VPORTCB_DESTROYVPORT            DestroyVideoPort;
    PDD_VPORTCB_GETFLIPSTATUS           GetVideoPortFlipStatus;
    PDD_VPORTCB_UPDATE                  UpdateVideoPort;
    PDD_VPORTCB_WAITFORSYNC             WaitForVideoPortSync;
    PDD_VPORTCB_GETSIGNALSTATUS         GetVideoSignalStatus;
    PDD_VPORTCB_COLORCONTROL            ColorControl;
} DD_VIDEOPORTCALLBACKS;

typedef DD_VIDEOPORTCALLBACKS *PDD_VIDEOPORTCALLBACKS;

#define DDHAL_VPORT32_CANCREATEVIDEOPORT        0x00000001l
#define DDHAL_VPORT32_CREATEVIDEOPORT           0x00000002l
#define DDHAL_VPORT32_FLIP                      0x00000004l
#define DDHAL_VPORT32_GETBANDWIDTH              0x00000008l
#define DDHAL_VPORT32_GETINPUTFORMATS           0x00000010l
#define DDHAL_VPORT32_GETOUTPUTFORMATS          0x00000020l
#define DDHAL_VPORT32_GETAUTOFLIPSURF           0x00000040l
#define DDHAL_VPORT32_GETFIELD                  0x00000080l
#define DDHAL_VPORT32_GETLINE                   0x00000100l
#define DDHAL_VPORT32_GETCONNECT                0x00000200l
#define DDHAL_VPORT32_DESTROY                   0x00000400l
#define DDHAL_VPORT32_GETFLIPSTATUS             0x00000800l
#define DDHAL_VPORT32_UPDATE                    0x00001000l
#define DDHAL_VPORT32_WAITFORSYNC               0x00002000l
#define DDHAL_VPORT32_GETSIGNALSTATUS           0x00004000l
#define DDHAL_VPORT32_COLORCONTROL              0x00008000l

/*
 * DIRECTDRAWCOLORCONTROL object callbacks
 */
typedef DWORD (APIENTRY *PDD_COLORCB_COLORCONTROL)(PDD_COLORCONTROLDATA);

typedef struct _DD_COLORCONTROLCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_COLORCB_COLORCONTROL            ColorControl;
} DD_COLORCONTROLCALLBACKS;

typedef DD_COLORCONTROLCALLBACKS *PDD_COLORCONTROLCALLBACKS;

#define DDHAL_COLOR_COLORCONTROL                0x00000001l

/*
 * DIRECTDRAWSURFACEKERNEL object callbacks
 * This structure can be queried from the driver from DX5 onward
 * using GetDriverInfo with GUID_KernelCallbacks
 */
typedef DWORD (APIENTRY *PDD_KERNELCB_SYNCSURFACE)(PDD_SYNCSURFACEDATA);
typedef DWORD (APIENTRY *PDD_KERNELCB_SYNCVIDEOPORT)(PDD_SYNCVIDEOPORTDATA);

typedef struct DD_KERNELCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_KERNELCB_SYNCSURFACE            SyncSurfaceData;
    PDD_KERNELCB_SYNCVIDEOPORT          SyncVideoPortData;
} DD_KERNELCALLBACKS, *PDD_KERNELCALLBACKS;

#define DDHAL_KERNEL_SYNCSURFACEDATA            0x00000001l
#define DDHAL_KERNEL_SYNCVIDEOPORTDATA          0x00000002l

/*
 * DIRECTDRAWVIDEO object callbacks
 */
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETGUIDS)( PDD_GETMOCOMPGUIDSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETFORMATS)( PDD_GETMOCOMPFORMATSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_CREATE)( PDD_CREATEMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETCOMPBUFFINFO)( PDD_GETMOCOMPCOMPBUFFDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETINTERNALINFO)( PDD_GETINTERNALMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_BEGINFRAME)( PDD_BEGINMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_ENDFRAME)( PDD_ENDMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_RENDER)( PDD_RENDERMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_QUERYSTATUS)( PDD_QUERYMOCOMPSTATUSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_DESTROY)( PDD_DESTROYMOCOMPDATA);

typedef struct DD_MOTIONCOMPCALLBACKS
{
    DWORD                           dwSize;
    DWORD                           dwFlags;
    PDD_MOCOMPCB_GETGUIDS           GetMoCompGuids;
    PDD_MOCOMPCB_GETFORMATS         GetMoCompFormats;
    PDD_MOCOMPCB_CREATE             CreateMoComp;
    PDD_MOCOMPCB_GETCOMPBUFFINFO    GetMoCompBuffInfo;
    PDD_MOCOMPCB_GETINTERNALINFO    GetInternalMoCompInfo;
    PDD_MOCOMPCB_BEGINFRAME         BeginMoCompFrame;
    PDD_MOCOMPCB_ENDFRAME           EndMoCompFrame;
    PDD_MOCOMPCB_RENDER             RenderMoComp;
    PDD_MOCOMPCB_QUERYSTATUS        QueryMoCompStatus;
    PDD_MOCOMPCB_DESTROY            DestroyMoComp;
} DD_MOTIONCOMPCALLBACKS;
typedef DD_MOTIONCOMPCALLBACKS *PDD_MOTIONCOMPCALLBACKS;

#define DDHAL_MOCOMP32_GETGUIDS                 0x00000001
#define DDHAL_MOCOMP32_GETFORMATS               0x00000002
#define DDHAL_MOCOMP32_CREATE                   0x00000004
#define DDHAL_MOCOMP32_GETCOMPBUFFINFO          0x00000008
#define DDHAL_MOCOMP32_GETINTERNALINFO          0x00000010
#define DDHAL_MOCOMP32_BEGINFRAME               0x00000020
#define DDHAL_MOCOMP32_ENDFRAME                 0x00000040
#define DDHAL_MOCOMP32_RENDER                   0x00000080
#define DDHAL_MOCOMP32_QUERYSTATUS              0x00000100
#define DDHAL_MOCOMP32_DESTROY                  0x00000200

/*
 * CALLBACK RETURN VALUES
 *
 * these are values returned by the driver from the above callback routines
 */
/*
 * indicates that the display driver didn't do anything with the call
 */
#define DDHAL_DRIVER_NOTHANDLED         0x00000000l

/*
 * indicates that the display driver handled the call; HRESULT value is valid
 */
#define DDHAL_DRIVER_HANDLED            0x00000001l

/*
 * indicates that the display driver couldn't handle the call because it
 * ran out of color key hardware resources
 */
#define DDHAL_DRIVER_NOCKEYHW           0x00000002l

/*
 * Capabilities structure for non-local video memory
 */
typedef struct _DD_NONLOCALVIDMEMCAPS
{
    DWORD   dwSize;
    DWORD   dwNLVBCaps;           // driver specific capabilities for non-local->local vidmem blts
    DWORD   dwNLVBCaps2;          // more driver specific capabilities non-local->local vidmem blts
    DWORD   dwNLVBCKeyCaps;       // driver color key capabilities for non-local->local vidmem blts
    DWORD   dwNLVBFXCaps;         // driver FX capabilities for non-local->local blts
    DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DD_NONLOCALVIDMEMCAPS;
typedef struct _DD_NONLOCALVIDMEMCAPS *PDD_NONLOCALVIDMEMCAPS;

/*
 * DDRAW internal version of DIRECTDRAWPALETTE object; it has data after the vtable
 */
typedef struct _DD_PALETTE_GLOBAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_PALETTE_GLOBAL;

typedef struct _DD_PALETTE_LOCAL
{
    ULONG                       dwReserved0;    // reserved for future expansion
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_PALETTE_LOCAL;

/*
 * DDRAW internal version of DIRECTDRAWCLIPPER object; it has data after the vtable
 */
typedef struct _DD_CLIPPER_GLOBAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_CLIPPER_GLOBAL;

typedef struct _DD_CLIPPER_LOCAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_CLIPPER_LOCAL;

typedef struct _DD_ATTACHLIST *PDD_ATTACHLIST;
typedef struct _DD_ATTACHLIST
{
    PDD_ATTACHLIST              lpLink;         // link to next attached surface
    PDD_SURFACE_LOCAL           lpAttached;     // attached surface local object
} DD_ATTACHLIST;

/*
 * DDRAW surface interface struct
 */
typedef struct _DD_SURFACE_INT
{
    PDD_SURFACE_LOCAL           lpLcl;          // pointer to interface data
} DD_SURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DD_SURFACE_GLOBAL
{
    union 
    {
        DWORD                   dwBlockSizeY;   // block size that display driver requested (return)
        LONG                    lSlicePitch;    // slice pitch for volume textures
    };

    union 
    {
        LPVIDEOMEMORY           lpVidMemHeap;   // heap vidmem was alloc'ed from
        DWORD                   dwBlockSizeX;   // block size that display driver requested (return)
        DWORD                   dwUserMemSize;  // user-mode memory size that display driver requested (return)
    };

    FLATPTR                     fpVidMem;       // pointer to video memory
    union
    {
        LONG                    lPitch;         // pitch of surface
        DWORD                   dwLinearSize;   // linear size of non-rectangular surface
    };
    LONG                        yHint;          // y-coordinate of surface
    LONG                        xHint;          // x-coordinate of surface
    DWORD                       wHeight;        // height of surface
    DWORD                       wWidth;         // width of surface
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    DDPIXELFORMAT               ddpfSurface;    // pixel format of surface
    FLATPTR                     fpHeapOffset;   // raw offset in source heap
    HANDLE                      hCreatorProcess;// opaque identifier for creating process
} DD_SURFACE_GLOBAL;

/*
 * a structure holding additional LCL surface information (to maintain some
 * compatibility with Win95).
 */
typedef struct _DD_SURFACE_MORE
{
    DWORD                       dwMipMapCount;      // number of mip-map levels
    PDD_VIDEOPORT_LOCAL         lpVideoPort;        // video port currently writing data to this surface
    DWORD                       dwOverlayFlags;     // current overlay flags
    DDSCAPSEX                   ddsCapsEx;          // more surface capabilities
    DWORD                       dwSurfaceHandle;    // cookie for use with CreateSurfaceEx DDI
} DD_SURFACE_MORE, *PDD_SURFACE_MORE;

/*
 * the LCL structure is local data for each individual surface object
 */
typedef struct _DD_SURFACE_LOCAL
{
    PDD_SURFACE_GLOBAL          lpGbl;            // pointer to surface shared data
    DWORD                       dwFlags;          // flags
    DDSCAPS                     ddsCaps;          // capabilities of surface
    ULONG_PTR                   dwReserved1;      // reserved for use by display driver
    union
    {
        DDCOLORKEY              ddckCKSrcOverlay; // color key for source overlay use
        DDCOLORKEY              ddckCKSrcBlt;     // color key for source blt and texture use
    };
    union
    {
        DDCOLORKEY              ddckCKDestOverlay;// color key for destination overlay use
        DDCOLORKEY              ddckCKDestBlt;    // color key for destination blt
    };
    PDD_SURFACE_MORE            lpSurfMore;       // pointer to additional local data
    PDD_ATTACHLIST              lpAttachList;     // link to surfaces we attached to
    PDD_ATTACHLIST              lpAttachListFrom; // link to surfaces that attached to us
    RECT                        rcOverlaySrc;     // Overlay source rectangle relative to surface
} DD_SURFACE_LOCAL;

#define DDRAWISURF_HASCKEYSRCBLT        0x00000800L     // surface has CKSrcBlt
#define DDRAWISURF_HASPIXELFORMAT       0x00002000L     // surface structure has pixel format data
#define DDRAWISURF_HASOVERLAYDATA       0x00004000L     // surface structure has overlay data
#define DDRAWISURF_FRONTBUFFER          0x04000000L     // surface was originally a front buffer
#define DDRAWISURF_BACKBUFFER           0x08000000L     // surface was originally backbuffer
#define DDRAWISURF_INVALID              0x10000000L     // surface has been invalidated by mode set
#define DDRAWISURF_DRIVERMANAGED        0x40000000L     // surface is a driver managed texture (D3D)

/*
 * More driver capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS structure in DX6.
 */
typedef struct _DD_MORECAPS
{
    DWORD   dwSize; 		    // size of DDMORECAPS structure
    DWORD   dwAlphaCaps;	    // driver-specific alpha caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBAlphaCaps;	    // driver-specific alpha capabilities for System->Vmem blts
    DWORD   dwVSBAlphaCaps;	    // driver-specific alpha capabilities for Vmem->System blts
    DWORD   dwSSBAlphaCaps;	    // driver-specific alpha capabilities for System->System blts
    DWORD   dwFilterCaps;           // driver-specific filter caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBFilterCaps;        // driver-specific filter capabilities for System->Vmem blts
    DWORD   dwVSBFilterCaps;        // driver-specific filter capabilities for Vmem->System blts
    DWORD   dwSSBFilterCaps;        // driver-specific filter capabilities for System->System blts
} DD_MORECAPS;

typedef DD_MORECAPS *PDD_MORECAPS;

/*
 * rop stuff
 */
#define ROP_HAS_SOURCE          0x00000001l
#define ROP_HAS_PATTERN         0x00000002l
#define ROP_HAS_SOURCEPATTERN   ROP_HAS_SOURCE | ROP_HAS_PATTERN

/*
 * This structure mirrors the first entries of the DDCAPS but is of a fixed
 * size and will not grow as DDCAPS grows. This is the structure your driver
 * returns in DDCOREINFO. Additional caps will be requested via a GetDriverInfo
 * call.
 */
typedef struct _DDNTCORECAPS
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwMaxVideoPorts;        // maximum number of usable video ports
    DWORD       dwCurrVideoPorts;       // current number of video ports used
    DWORD       dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
} DDNTCORECAPS, *PDDNTCORECAPS;

/*
 * structure for D3D buffer callbacks
 */
typedef struct _DD_D3DBUFCALLBACKS
{
    DWORD dwSize;
    DWORD dwFlags;
    PDD_CANCREATESURFACE        CanCreateD3DBuffer;
    PDD_CREATESURFACE           CreateD3DBuffer;
    PDD_SURFCB_DESTROYSURFACE   DestroyD3DBuffer;
    PDD_SURFCB_LOCK             LockD3DBuffer;
    PDD_SURFCB_UNLOCK           UnlockD3DBuffer;
} DD_D3DBUFCALLBACKS, *PDD_D3DBUFCALLBACKS;

#define DDHAL_EXEBUFCB32_CANCREATEEXEBUF    0x00000001l
#define DDHAL_EXEBUFCB32_CREATEEXEBUF       0x00000002l
#define DDHAL_EXEBUFCB32_DESTROYEXEBUF      0x00000004l
#define DDHAL_EXEBUFCB32_LOCKEXEBUF         0x00000008l
#define DDHAL_EXEBUFCB32_UNLOCKEXEBUF       0x00000010l

/*
 * NT friendly names
 */
#define DDHAL_D3DBUFCB32_CANCREATED3DBUF    DDHAL_EXEBUFCB32_CANCREATEEXEBUF    
#define DDHAL_D3DBUFCB32_CREATED3DBUF       DDHAL_EXEBUFCB32_CREATEEXEBUF       
#define DDHAL_D3DBUFCB32_DESTROYD3DBUF      DDHAL_EXEBUFCB32_DESTROYEXEBUF      
#define DDHAL_D3DBUFCB32_LOCKD3DBUF         DDHAL_EXEBUFCB32_LOCKEXEBUF         
#define DDHAL_D3DBUFCB32_UNLOCKD3DBUF       DDHAL_EXEBUFCB32_UNLOCKEXEBUF       


/*
 * structure for display driver to call DDHAL_Create with
 * the _V4 version was used by NT4 drivers
 */
typedef struct _DD_HALINFO_V4
{
    DWORD                       dwSize;
    VIDEOMEMORYINFO             vmiData;                // video memory info
    DDNTCORECAPS                ddCaps;                 // hw specific caps
    PDD_GETDRIVERINFO           GetDriverInfo;          // callback for querying driver data
    DWORD                       dwFlags;                // create flags
} DD_HALINFO_V4, *PDD_HALINFO_V4;

typedef struct _DD_HALINFO
{
    DWORD                       dwSize;
    VIDEOMEMORYINFO             vmiData;                // video memory info
    DDNTCORECAPS                ddCaps;                 // hw specific caps
    PDD_GETDRIVERINFO           GetDriverInfo;          // callback for querying driver data
    DWORD                       dwFlags;                // create flags
    LPVOID                      lpD3DGlobalDriverData;  // D3D global Data
    LPVOID                      lpD3DHALCallbacks;      // D3D callbacks
    PDD_D3DBUFCALLBACKS         lpD3DBufCallbacks;      // Buffer callbacks
} DD_HALINFO, *PDD_HALINFO;

#define DDHALINFO_GETDRIVERINFOSET      0x00000004l     // indicates that GetDriverInfo is set
#define DDHALINFO_GETDRIVERINFO2        0x00000008l     // indicates driver support GetDriverInfo2 variant
                                                        // of GetDriverInfo. New for DX 8.0


/*
 * DDRAW version of DirectDraw object;
 *
 */
typedef struct _DD_DIRECTDRAW_GLOBAL
{
    VOID*                       dhpdev;         // driver's private PDEV pointer
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    ULONG_PTR                   dwReserved2;    // reserved for use by display driver
    LPDDVIDEOPORTCAPS           lpDDVideoPortCaps;// Info returned by the HAL (an array if more than one video port)
} DD_DIRECTDRAW_GLOBAL;

typedef struct _DD_DIRECTDRAW_LOCAL
{
    PDD_DIRECTDRAW_GLOBAL       lpGbl;            // pointer to data
} DD_DIRECTDRAW_LOCAL;

typedef struct _DD_VIDEOPORT_LOCAL
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // pointer to DIRECTDRAW_LCL
    DDVIDEOPORTDESC             ddvpDesc;         // description used at create time
    DDVIDEOPORTINFO             ddvpInfo;         // most recent video port info
    PDD_SURFACE_INT             lpSurface;        // surface receiving the data
    PDD_SURFACE_INT             lpVBISurface;     // surface receiving the VBI data
    DWORD                       dwNumAutoflip;    // Number of current autoflip surfaces
    DWORD                       dwNumVBIAutoflip; // Number of VBI surfaces currently being autoflipped
    ULONG_PTR                   dwReserved1;      // Reserved for display driver
    ULONG_PTR                   dwReserved2;      // Reserved for display driver
    ULONG_PTR                   dwReserved3;      // Reserved for display driver
} DD_VIDEOPORT_LOCAL;

#define DDRAWIVPORT_ON                  0x00000001      // Video port is pumping data
#define DDRAWIVPORT_SOFTWARE_AUTOFLIP   0x00000002      // Video port cannot use hardware autoflip
#define DDRAWIVPORT_COLORKEYANDINTERP   0x00000004      // Overlay cannot bob and colorkey at same time

typedef struct _DD_MOTIONCOMP_LOCAL
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // pointer to DIRECTDRAW_LCL
    GUID                            guid;
    DWORD                           dwUncompWidth;
    DWORD                           dwUncompHeight;
    DDPIXELFORMAT                   ddUncompPixelFormat;
    DWORD                           dwDriverReserved1;
    DWORD                           dwDriverReserved2;
    DWORD                           dwDriverReserved3;
    LPVOID                          lpDriverReserved1;
    LPVOID                          lpDriverReserved2;
    LPVOID                          lpDriverReserved3;
} DD_MOTIONCOMP_LOCAL;


/*
 * More driver surface capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS.ddsCaps structure in DX6.
 */
typedef struct _DD_MORESURFACECAPS
{
    DWORD       dwSize;             // size of DDMORESURFACECAPS structure
    DDSCAPSEX   ddsCapsMore;
    /*
     * The DDMORESURFACECAPS struct is of variable size. The following list may be
     * filled in by DX6-aware drivers (see DDVERSIONINFO) to restrict their
     * video memory heaps (those which are exposed to DirectDraw) to
     * certain sets of DDSCAPS_ bits. Thse entries are exactly analogous to
     * the ddsCaps and ddsCapsAlt members of the VIDMEM structures listed in
     * the VIDMEMINFO.pvmList member of DDHALINFO.vmiData. There should be
     * exactly DDHALINFO.vmiData.dwNumHeaps copies of tagExtendedHeapRestrictions
     * in this struct. The size of this struct is thus:
     *  DDMORESURFACECAPS.dwSize = sizeof(DDMORESURFACECAPS) +
     *          (DDHALINFO.vmiData.dwNumHeaps-1) * sizeof(DDSCAPSEX)*2;
     * Note the -1 accounts for the fact that DDMORESURFACECAPS is declared to have 1
     * tagExtendedHeapRestrictions member.
     */
    struct tagNTExtendedHeapRestrictions
    {
        DDSCAPSEX   ddsCapsEx;
        DDSCAPSEX   ddsCapsExAlt;
    } ddsExtendedHeapRestrictions[1];
} DD_MORESURFACECAPS;

// for DX7, we check each mode in the driver if it supports 
// Stereo, driver returns DD_OK if mode is ok for stereo
typedef struct _DD_STEREOMODE
{
    DWORD       dwSize;             // size of DDSTEREOMODECAPS structure

    DWORD       dwHeight;
    DWORD       dwWidth;
    DWORD       dwBpp;
    DWORD       dwRefreshRate;

    BOOL        bSupported;

} DD_STEREOMODE;

typedef struct _DD_UPDATENONLOCALHEAPDATA
{
    PDD_DIRECTDRAW_GLOBAL      lpDD;                // driver struct
    DWORD                      dwHeap;              // heap index
    FLATPTR                    fpGARTLin;           // linear GART address of start of heap
    FLATPTR                    fpGARTDev;           // high physical GART address of start of heap
    ULONG_PTR                  ulPolicyMaxBytes;    // maximum amount of AGP memory to use
    HRESULT                    ddRVal;              // return value
    VOID*                      UpdateNonLocalHeap;  // Unused: Win95 compatibility
} DD_UPDATENONLOCALHEAPDATA;

/*
 * Private caps that the driver passes to change DirectDraw behavior.
 * These caps are not exposed to the application
 */

typedef struct DD_NTPRIVATEDRIVERCAPS
{
    DWORD                               dwSize;
    DWORD                               dwPrivateCaps;
} DD_NTPRIVATEDRIVERCAPS;

// Driver wants DD_CREATESURFACEDATA.lplpSList to contain a list of
// surfaces to create rather than always a single surface.
#define DDHAL_PRIVATECAP_ATOMICSURFACECREATION 0x00000001l

// Driver wants to be notified when creating a primary surface.
#define DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION  0x00000002l

#define DDHAL_PRIVATECAP_RESERVED1              0x00000004l

/////////////////////////////////////////////////////////////////////////////
// NT Note:
//
// The following structures must match, field for field, the corresponding
// structures as declared in 'ddrawi.h.'  We cannot simply use the same
// structures because the sub-structures such as DD_DIRECTDRAW_GLOBAL are
// different, and have to be properly typed for the drivers.
//
/////////////////////////////////////////////////////////////////////////////

/****************************************************************************
 *
 * DDHAL structures for Surface Object callbacks
 *
 ***************************************************************************/

/*
 * This special flag is seen only by drivers.  The DD runtime sets this
 * bit in DDHAL_BLTDATA.dwFlags if the dwAFlags and ddrgbaScaleFactors
 * members at the end of the DDHAL_BLTDATA structure are valid.
 * The flag is always set if the DDHAL_BLTDATA structure is passed to
 * the driver via the AlphaBlt HAL callback; otherwise, the flag is zero.
 */
#define DDBLT_AFLAGS 		0x80000000L

/*
 * This flag will be set in DDHAL_BLTDATA.dwAFlags if the call was originated
 * by the AlphaBlt API method. If the call was originated by the Blt API,
 * this flag will not be set.
 * Drivers which have a unified Blt/AlphaBlt DDI can use this flag to distinguish
 * between the two API calls.
 */
#define DDABLT_SRCOVERDEST      0x00000001L

/*
 * structure for passing information to DDHAL Blt fn
 */
typedef struct _DD_BLTDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    RECTL                       rDest;          // dest rect
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    RECTL                       rSrc;           // src rect
    DWORD                       dwFlags;        // blt flags
    DWORD                       dwROPFlags;     // ROP flags (valid for ROPS only)
    DDBLTFX                     bltFX;          // blt FX
    HRESULT                     ddRVal;         // return value
    VOID*                       Blt;            // Unused: Win95 compatibility
    BOOL                        IsClipped;      // clipped blt?
    RECTL                       rOrigDest;      // unclipped dest rect
                                                // (only valid if IsClipped)
    RECTL                       rOrigSrc;       // unclipped src rect
                                                // (only valid if IsClipped)
    DWORD                       dwRectCnt;      // count of dest rects
                                                // (only valid if IsClipped)
    LPRECT                      prDestRects;    // array of dest rects
                                                // (only valid if IsClipped)
    DWORD                       dwAFlags;       // DDABLT_ flags (for AlphaBlt DDI)
    DDARGB                      ddargbScaleFactors;  // ARGB scaling factors (AlphaBlt)
} DD_BLTDATA;

/*
 * structure for passing information to DDHAL Lock fn
 */
typedef struct _DD_LOCKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       bHasRect;       // rArea is valid
    RECTL                       rArea;          // area being locked
    LPVOID                      lpSurfData;     // pointer to screen memory (return value)
    HRESULT                     ddRVal;         // return value
    VOID*                       Lock;           // Unused: Win95 compatibility
    DWORD                       dwFlags;        // DDLOCK flags
    FLATPTR                     fpProcess;      // process start address
} DD_LOCKDATA;

/*
 * structure for passing information to DDHAL Unlock fn
 */
typedef struct _DD_UNLOCKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       Unlock;         // Unused: Win95 compatibility
} DD_UNLOCKDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DD_UPDATEOVERLAYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    RECTL                       rDest;          // dest rect
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    RECTL                       rSrc;           // src rect
    DWORD                       dwFlags;        // flags
    DDOVERLAYFX                 overlayFX;      // overlay FX
    HRESULT                     ddRVal;         // return value
    VOID*                       UpdateOverlay;  // Unused: Win95 compatibility
} DD_UPDATEOVERLAYDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DD_SETOVERLAYPOSITIONDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    LONG                        lXPos;          // x position
    LONG                        lYPos;          // y position
    HRESULT                     ddRVal;         // return value
    VOID*                       SetOverlayPosition; // Unused: Win95 compatibility
} DD_SETOVERLAYPOSITIONDATA;
/*
 * structure for passing information to DDHAL SetPalette fn
 */
typedef struct _DD_SETPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette to set to surface
    HRESULT                     ddRVal;         // return value
    VOID*                       SetPalette;     // Unused: Win95 compatibility
    BOOL                        Attach;         // attach this palette?
} DD_SETPALETTEDATA;

/*
 * structure for passing information to DDHAL Flip fn
 */
typedef struct _DD_FLIPDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpSurfCurr;     // current surface
    PDD_SURFACE_LOCAL           lpSurfTarg;     // target surface (to flip to)
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       Flip;           // Unused: Win95 compatibility
    PDD_SURFACE_LOCAL           lpSurfCurrLeft;     // left target surface (to flip to)
    PDD_SURFACE_LOCAL           lpSurfTargLeft;     // left target surface (to flip to)
} DD_FLIPDATA;

/*
 * structure for passing information to DDHAL DestroySurface fn
 */
typedef struct _DD_DESTROYSURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       DestroySurface;// Unused: Win95 compatibility
} DD_DESTROYSURFACEDATA;

/*
 * structure for passing information to DDHAL SetClipList fn
 */
typedef struct _DD_SETCLIPLISTDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       SetClipList;    // Unused: Win95 compatibility
} DD_SETCLIPLISTDATA;

/*
 * structure for passing information to DDHAL AddAttachedSurface fn
 */
typedef struct _DD_ADDATTACHEDSURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    PDD_SURFACE_LOCAL           lpSurfAttached; // surface to attach
    HRESULT                     ddRVal;         // return value
    VOID*                       AddAttachedSurface; // Unused: Win95 compatibility
} DD_ADDATTACHEDSURFACEDATA;

/*
 * structure for passing information to DDHAL SetColorKey fn
 */
typedef struct _DD_SETCOLORKEYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    DDCOLORKEY                  ckNew;          // new color key
    HRESULT                     ddRVal;         // return value
    VOID*                       SetColorKey;    // Unused: Win95 compatibility
} DD_SETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetBltStatus fn
 */
typedef struct _DD_GETBLTSTATUSDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       GetBltStatus;   // Unused: Win95 compatibility
} DD_GETBLTSTATUSDATA;

/*
 * structure for passing information to DDHAL GetFlipStatus fn
 */
typedef struct _DD_GETFLIPSTATUSDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       GetFlipStatus;  // Unused: Win95 compatibility
} DD_GETFLIPSTATUSDATA;

/****************************************************************************
 *
 * DDHAL structures for Palette Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL DestroyPalette fn
 */
typedef struct _DD_DESTROYPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette struct
    HRESULT                     ddRVal;         // return value
    VOID*                       DestroyPalette; // Unused: Win95 compatibility
} DD_DESTROYPALETTEDATA;

/*
 * structure for passing information to DDHAL SetEntries fn
 */
typedef struct _DD_SETENTRIESDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette struct
    DWORD                       dwBase;         // base palette index
    DWORD                       dwNumEntries;   // number of palette entries
    LPPALETTEENTRY              lpEntries;      // color table
    HRESULT                     ddRVal;         // return value
    VOID*                       SetEntries;     // Unused: Win95 compatibility
} DD_SETENTRIESDATA;

/****************************************************************************
 *
 * DDHAL structures for Driver Object callbacks
 *
 ***************************************************************************/

typedef DDSURFACEDESC* PDD_SURFACEDESC;

/*
 * structure for passing information to DDHAL CreateSurface fn
 */
typedef struct _DD_CREATESURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACEDESC             lpDDSurfaceDesc;// description of surface being created
    PDD_SURFACE_LOCAL           *lplpSList;     // list of created surface objects
    DWORD                       dwSCnt;         // number of surfaces in SList
    HRESULT                     ddRVal;         // return value
    VOID*                       CreateSurface;  // Unused: Win95 compatibility
} DD_CREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CanCreateSurface fn
 */
typedef struct _DD_CANCREATESURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;                   // driver struct
    PDD_SURFACEDESC             lpDDSurfaceDesc;        // description of surface being created
    DWORD                       bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT                     ddRVal;                 // return value
    VOID*                       CanCreateSurface;       // Unused: Win95 compatibility
} DD_CANCREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CreatePalette fn
 */
typedef struct _DD_CREATEPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // ddraw palette struct
    LPPALETTEENTRY              lpColorTable;   // colors to go in palette
    HRESULT                     ddRVal;         // return value
    VOID*                       CreatePalette;  // Unused: Win95 compatibility
    BOOL                        is_excl;        // process has exclusive mode
} DD_CREATEPALETTEDATA;

/*
 * Return if the vertical blank is in progress
 */
#define DDWAITVB_I_TESTVB                       0x80000006l

/*
 * structure for passing information to DDHAL WaitForVerticalBlank fn
 */
typedef struct _DD_WAITFORVERTICALBLANKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwFlags;        // flags
    DWORD                       bIsInVB;        // is in vertical blank
    ULONG_PTR                   hEvent;         // event
    HRESULT                     ddRVal;         // return value
    VOID*                       WaitForVerticalBlank; // Unused: Win95 compatibility
} DD_WAITFORVERTICALBLANKDATA;

/*
 * structure for passing information to DDHAL driver SetColorKey fn
 */
typedef struct _DD_DRVSETCOLORKEYDATA
{
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    DDCOLORKEY                  ckNew;          // new color key
    HRESULT                     ddRVal;         // return value
    VOID*                       SetColorKey;    // Unused: Win95 compatibility
} DD_DRVSETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetScanLine fn
 */
typedef struct _DD_GETSCANLINEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwScanLine;     // returned scan line
    HRESULT                     ddRVal;         // return value
    VOID*                       GetScanLine;    // Unused: Win95 compatibility
} DD_GETSCANLINEDATA;

/*
 * structure for passing information to DDHAL MapMemory fn
 */
typedef struct _DD_MAPMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    BOOL                        bMap;           // TRUE if map; FALSe if un-map
    HANDLE                      hProcess;       // process handle
    FLATPTR                     fpProcess;      // returned address in process' address space
    HRESULT                     ddRVal;         // return value
} DD_MAPMEMORYDATA;

/****************************************************************************
 *
 * DDHAL structures for VideoPort callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CanCreateVideoPort fn
 */
typedef struct _DD_CANCREATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;               // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    HRESULT                     ddRVal;             // return value
    VOID*                       CanCreateVideoPort; // Unused: Win95 compatibility
} DD_CANCREATEVPORTDATA;

/*
 * structure for passing information to DDHAL CreateVideoPort fn
 */
typedef struct _DD_CREATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;              // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    PDD_VIDEOPORT_LOCAL         lpVideoPort;       // Video port created
    HRESULT                     ddRVal;            // return value
    VOID*                       CreateVideoPort;   // Unused: Win95 compatibility
} DD_CREATEVPORTDATA;

/*
 * structure for passing information to DDHAL FlipVideoPort fn
 */
typedef struct _DD_FLIPVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;          // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;   // Video port object
    PDD_SURFACE_LOCAL           lpSurfCurr;    // current surface
    PDD_SURFACE_LOCAL           lpSurfTarg;    // target surface
    HRESULT                     ddRVal;        // return value
    VOID*                       FlipVideoPort; // Unused: Win95 compatibility
} DD_FLIPVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortBandwidth fn
 */
typedef struct _DD_GETVPORTBANDWIDTHDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                  // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;           // Video port object
    LPDDPIXELFORMAT             lpddpfFormat;          // Format for bandwidth
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwFlags;               // Prescale factor for bandwidth
    LPDDVIDEOPORTBANDWIDTH      lpBandwidth;           // Returned bandwidth parameters
    HRESULT                     ddRVal;                // return value
    VOID*                       GetVideoPortBandwidth; // Unused: Win95 compatibility
} DD_GETVPORTBANDWIDTHDATA;

/*
 * structure for passing information to DDHAL GetVideoPortInputFormats fn
 */
typedef struct _DD_GETVPORTINPUTFORMATDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                     // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;              // Video port object
    DWORD                       dwFlags;                  // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfFormat;             // Array of formats
    DWORD                       dwNumFormats;             // # of formats in array
    HRESULT                     ddRVal;                   // return value
    VOID*                       GetVideoPortInputFormats; // Unused: Win95 compatibility
} DD_GETVPORTINPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortOutputFormats fn
 */
typedef struct _DD_GETVPORTOUTPUTFORMATDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                     // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;              // Video port object
    DWORD                       dwFlags;                  // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfInputFormat;        // Input format
    LPDDPIXELFORMAT             lpddpfOutputFormats;      // Array of output formats
    DWORD                       dwNumFormats;             // # of formats in array
    HRESULT                     ddRVal;                   // return value
    VOID*                       GetVideoPortInputFormats; // Unused: Win95 compatibility
} DD_GETVPORTOUTPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortField fn
 */
typedef struct _DD_GETVPORTFIELDDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;              // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;       // Video port object
    BOOL                        bField;            // TRUE if even
    HRESULT                     ddRVal;            // return value
    VOID*                       GetVideoPortField; // Unused: Win95 compatibility
} DD_GETVPORTFIELDDATA;

/*
 * structure for passing information to DDHAL GetVideoPortLine fn
 */
typedef struct _DD_GETVPORTLINEDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    DWORD                       dwLine;           // Current line counter
    HRESULT                     ddRVal;           // return value
    VOID*                       GetVideoPortLine; // Unused: Win95 compatibility
} DD_GETVPORTLINEDATA;

/*
 * structure for passing information to DDHAL GetVideoPortConnectInfo fn
 */
typedef struct _DD_GETVPORTCONNECTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                    // driver struct
    DWORD                       dwPortId;                // ID of desired video port
    LPDDVIDEOPORTCONNECT        lpConnect;               // Array of DDVIDEOPORTCONNECT structures
    DWORD                       dwNumEntries;            // # of structures in array
    HRESULT                     ddRVal;                  // return value
    VOID*                       GetVideoPortConnectInfo; // Unused: Win95 compatibility
} DD_GETVPORTCONNECTDATA;

/*
 * structure for passing information to DDHAL DestroyVideoPort fn
 */
typedef struct _DD_DESTROYVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    HRESULT                     ddRVal;           // return value
    VOID*                       DestroyVideoPort; // Unused: Win95 compatibility
} DD_DESTROYVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortFlipStatus fn
 */
typedef struct _DD_GETVPORTFLIPSTATUSDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                   // driver struct
    FLATPTR                     fpSurface;              // surface struct
    HRESULT                     ddRVal;                 // return value
    VOID*                       GetVideoPortFlipStatus; // Unused: Win95 compatibility
} DD_GETVPORTFLIPSTATUSDATA;

typedef DDVIDEOPORTINFO*   PDD_VIDEOPORTINFO;
/*
 * structure for passing information to DDHAL UpdateVideoPort fn
 */
typedef struct _DD_UPDATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    PDD_SURFACE_INT            *lplpDDSurface;    // surface struct
    PDD_SURFACE_INT            *lplpDDVBISurface; // VBI surface structure
    PDD_VIDEOPORTINFO           lpVideoInfo;      // Video information
    DWORD                       dwFlags;          // DDRAWI_VPORTSTART, DDRAWI_VPORTSTOP, DDRAWI_VPORTUPDATE
    DWORD                       dwNumAutoflip;    // # of autoflip surfaces. If > 1, lpDDSurface is an array.
    DWORD                       dwNumVBIAutoflip; // # of autoflip surfaces. If > 1, lpDDVBISurface is an array.
    HRESULT                     ddRVal;           // return value
    VOID*                       UpdateVideoPort;  // Unused: Win95 compatibility
} DD_UPDATEVPORTDATA;

#define DDRAWI_VPORTSTART       0x0001
#define DDRAWI_VPORTSTOP        0x0002
#define DDRAWI_VPORTUPDATE      0x0003

/*
 * structure for passing information to DDHAL WaitForVideoPortSync fn
 */
typedef struct _DD_WAITFORVPORTSYNCDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;            // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;     // Video port object
    DWORD                       dwFlags;         // DDVPEVENT_XXXX
    DWORD                       dwLine;
    DWORD                       dwTimeOut;       // Max time to wait before returning
    HRESULT                     ddRVal;          // return value
    VOID*                       UpdateVideoPort; // Unused: Win95 compatibility
} DD_WAITFORVPORTSYNCDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DD_GETVPORTSIGNALDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                 // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;          // Video port object
    DWORD                       dwStatus;             // Video signal status
    HRESULT                     ddRVal;               // return value
    VOID*                       GetVideoSignalStatus; // Unused: Win95 compatibility
} DD_GETVPORTSIGNALDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DD_VPORTCOLORDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;         // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;  // Video port object
    DWORD                       dwFlags;      // Video signal status
    LPDDCOLORCONTROL            lpColorData;
    HRESULT                     ddRVal;       // return value
    VOID*                       ColorControl; // Unused: Win95 compatibility
} DD_VPORTCOLORDATA;

#define DDRAWI_VPORTGETCOLOR    0x0001
#define DDRAWI_VPORTSETCOLOR    0x0002

/****************************************************************************
 *
 * DDHAL structures for Color Control callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL ColorControl fn
 */
typedef struct _DD_COLORCONTROLDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface
    LPDDCOLORCONTROL            lpColorData;    // color control information
    DWORD                       dwFlags;        // DDRAWI_GETCOLOR/DDRAWI_SETCOLOR
    HRESULT                     ddRVal;         // return value
    VOID*                       ColorControl;   // Unused: Win95 compatibility
} DD_COLORCONTROLDATA;

#define DDRAWI_GETCOLOR         0x0001
#define DDRAWI_SETCOLOR         0x0002

/****************************************************************************
 *
 * DDHAL structure for GetDriverData callback
 *
 ***************************************************************************/

typedef struct _DD_GETDRIVERINFODATA {

    // Input fields filled in by DirectDraw

    VOID*                       dhpdev;         // Driver context
    DWORD                       dwSize;         // Size of this structure
    DWORD                       dwFlags;        // Flags
    GUID                        guidInfo;       // GUID that DirectX is querying for
    DWORD                       dwExpectedSize; // Size of callbacks structure expected by DirectDraw.
    PVOID                       lpvData;        // Buffer that will receive the requested data

    // Output fields filled in by driver

    DWORD                       dwActualSize;   // Size of callbacks structure expected by driver
    HRESULT                     ddRVal;         // Return value from driver

} DD_GETDRIVERINFODATA;

/****************************************************************************
 *
 * DDHAL structure for misc. driver callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetAvailDriverMemory fn
 */
typedef struct _DD_GETAVAILDRIVERMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;            // driver struct
    DDSCAPS                     DDSCaps;         // caps for type of surface memory
    DWORD                       dwTotal;         // total memory for this kind of surface
    DWORD                       dwFree;          // free memory for this kind of surface
    HRESULT                     ddRVal;          // return value
    VOID*                       GetAvailDriverMemory; // Unused: Win95 compatibility
} DD_GETAVAILDRIVERMEMORYDATA;


/****************************************************************************
 *
 * DDHAL structures for NT callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL FreeDriverMemory fn
 */
typedef struct _DD_FREEDRIVERMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;            // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;     // surface object trying to be created
    HRESULT                     ddRVal;          // return value
    VOID*                       FreeDriverMemory;// Unused: Win95 compatibility
} DD_FREEDRIVERMEMORYDATA;

/*
 * structure for passing information to DDHAL SetExclusiveMode fn
 */
typedef struct _DD_SETEXCLUSIVEMODEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwEnterExcl;    // TRUE if entering exclusive mode, FALSE is leaving
    DWORD                       dwReserved;     // reserved for future use
    HRESULT                     ddRVal;         // return value
    VOID*                       SetExclusiveMode; // Unused: Win95 compatibility
} DD_SETEXCLUSIVEMODEDATA;

/*
 * structure for passing information to DDHAL FlipToGDISurface fn
 */
typedef struct _DD_FLIPTOGDISURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwToGDI;        // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD                       dwReserved;     // reserved for future use
    HRESULT                     ddRVal;         // return value
    VOID*                       FlipToGDISurface; // Unused: Win95 compatibility
} DD_FLIPTOGDISURFACEDATA;

/****************************************************************************
 *
 * DDHAL structure for kernel callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL SyncSurfaceData fn
 */
typedef struct _DD_SYNCSURFACEDATA
{
    PDD_DIRECTDRAW_LOCAL   lpDD;        // driver struct
    PDD_SURFACE_LOCAL      lpDDSurface; // Surface to sync with
    DWORD       dwSurfaceOffset;        // Offset in frame buffer of surface
    ULONG_PTR    fpLockPtr;              // Surface lock ptr
    LONG        lPitch;                 // Surface pitch
    DWORD       dwOverlayOffset;        // Added to dwSurfaceOffset for origin, clipping, etc.
    ULONG       dwDriverReserved1;      // Reserved for the HAL
    ULONG       dwDriverReserved2;      // Reserved for the HAL
    ULONG       dwDriverReserved3;      // Reserved for the HAL
    ULONG       dwDriverReserved4;      // Reserved for the HAL
    HRESULT     ddRVal;
} DD_SYNCSURFACEDATA;

/*
 * structure for passing information to DDHAL SyncVideoPortData fn
 */
typedef struct _DD_SYNCVIDEOPORTDATA
{
    PDD_DIRECTDRAW_LOCAL    lpDD;       // driver struct
    PDD_VIDEOPORT_LOCAL     lpVideoPort;// Video port object
    DWORD       dwOriginOffset;         // Start address relative to surface
    DWORD       dwHeight;               // Height of total video region (per field)
    DWORD       dwVBIHeight;            // Height of VBI region (per field)
    ULONG       dwDriverReserved1;      // Reserved for the HAL
    ULONG       dwDriverReserved2;      // Reserved for the HAL
    ULONG       dwDriverReserved3;      // Reserved for the HAL
    HRESULT     ddRVal;
} DD_SYNCVIDEOPORTDATA;

/****************************************************************************
 *
 * DDHAL structure for motion comp callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetMoCompGuids
 */
typedef struct _DD_GETMOCOMPGUIDSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    DWORD                     dwNumGuids;
    GUID*                     lpGuids;
    HRESULT                   ddRVal;
} DD_GETMOCOMPGUIDSDATA;

/*
 * structure for passing information to DDHAL GetMoCompFormats
 */
typedef struct _DD_GETMOCOMPFORMATSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwNumFormats;
    LPDDPIXELFORMAT           lpFormats;
    HRESULT                   ddRVal;
} DD_GETMOCOMPFORMATSDATA;

/*
 * structure for passing information to DDHAL CreateMoComp
 */
typedef struct _DD_CREATEMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    GUID*                     lpGuid;
    DWORD                     dwUncompWidth;
    DWORD                     dwUncompHeight;
    DDPIXELFORMAT             ddUncompPixelFormat;
    LPVOID                    lpData;
    DWORD                     dwDataSize;
    HRESULT                   ddRVal;
} DD_CREATEMOCOMPDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DDCOMPBUFFERINFO
{
    DWORD                     dwSize;             // [in]   size of the struct
    DWORD                     dwNumCompBuffers;   // [out]  number of buffers required for compressed data
    DWORD                     dwWidthToCreate;    // [out]    Width of surface to create
    DWORD                     dwHeightToCreate;   // [out]    Height of surface to create
    DWORD                     dwBytesToAllocate;  // [out]    Total number of bytes used by each surface
    DDSCAPS2                  ddCompCaps;         // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT             ddPixelFormat;      // [out]  format to create surfaces to store compressed data
} DDCOMPBUFFERINFO, *LPDDCOMPBUFFERINFO;

typedef struct _DD_GETMOCOMPCOMPBUFFDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwWidth;            // [in]   width of uncompressed data
    DWORD                     dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT             ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                     dwNumTypesCompBuffs;// [in/out] number of memory types required for comp buffers
    LPDDCOMPBUFFERINFO        lpCompBuffInfo;     // [in]   driver supplied info regarding comp buffers (allocated by client)
    HRESULT                   ddRVal;             // [out]
} DD_GETMOCOMPCOMPBUFFDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DD_GETINTERNALMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwWidth;            // [in]   width of uncompressed data
    DWORD                     dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT             ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                     dwScratchMemAlloc;  // [out]  amount of scratch memory will the hal allocate for its private use
    HRESULT                   ddRVal;             // [out]
} DD_GETINTERNALMOCOMPDATA;

/*
 * structure for passing information to DDHAL BeginMoCompFrame
 */
typedef struct _DD_BEGINMOCOMPFRAMEDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    PDD_SURFACE_LOCAL         lpDestSurface;        // [in]  destination buffer in which to decoding this frame
    DWORD                     dwInputDataSize;      // [in]  size of other misc input data to begin frame
    LPVOID                    lpInputData;          // [in]  pointer to misc input data
    DWORD                     dwOutputDataSize;     // [in]  size of other misc output data to begin frame
    LPVOID                    lpOutputData;         // [in]  pointer to output misc data (allocated by client)
    HRESULT                   ddRVal;               // [out]
} DD_BEGINMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL EndMoCompFrame
 */
typedef struct _DD_ENDMOCOMPFRAMEDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    LPVOID                    lpInputData;
    DWORD                     dwInputDataSize;
    HRESULT                   ddRVal;
} DD_ENDMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL RenderMoComp
 */
typedef struct _DDMOCOMPBUFFERINFO
{
    DWORD                     dwSize;         // [in]    size of the struct
    PDD_SURFACE_LOCAL         lpCompSurface;  // [in]    pointer to buffer containing compressed data
    DWORD                     dwDataOffset;   // [in]    offset of relevant data from the beginning of buffer
    DWORD                     dwDataSize;     // [in]    size of relevant data
    LPVOID                    lpPrivate;      // Reserved by DirectDraw
} DDMOCOMPBUFFERINFO, *LPDDMOCOMPBUFFERINFO;

typedef struct _DD_RENDERMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    DWORD                     dwNumBuffers;     // [in]  Number of entries in the lpMacroBlockInfo array
    LPDDMOCOMPBUFFERINFO      lpBufferInfo;     // [in]  Surfaces containing macro block info
    DWORD                     dwFunction;       // [in]  Function
    LPVOID                    lpInputData;
    DWORD                     dwInputDataSize;
    LPVOID                    lpOutputData;
    DWORD                     dwOutputDataSize;
    HRESULT                   ddRVal;           // [out]
} DD_RENDERMOCOMPDATA;

/*
 * structure for passing information to DDHAL QueryMoCompStatus
 */
typedef struct _DD_QUERYMOCOMPSTATUSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    PDD_SURFACE_LOCAL         lpSurface;        // [in]  Surface being queried
    DWORD                     dwFlags;          // [in]  DDMCQUERY_XXX flags
    HRESULT                   ddRVal;            // [out]
} DD_QUERYMOCOMPSTATUSDATA;

#define DDMCQUERY_READ          0x00000001

/*
 * structure for passing information to DDHAL DestroyVideo
 */
typedef struct _DD_DESTROYMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    HRESULT                   ddRVal;
} DD_DESTROYMOCOMPDATA;


/****************************************************************************
 *
 * DDHAL structures for Miscellaneous2 callbacks
 *
 ***************************************************************************/
// This DDI is called by the kernel only.
typedef struct _DD_CREATESURFACEEXDATA
{
    DWORD                       dwFlags;
    PDD_DIRECTDRAW_LOCAL        lpDDLcl;        // driver struct
    PDD_SURFACE_LOCAL           lpDDSLcl;       // created surface
                                                // objects
    HRESULT                     ddRVal;         // return value
} DD_CREATESURFACEEXDATA;

// This DDI is used by both ddraw and d3d to obtain information from
// the driver.
typedef struct _DD_GETDRIVERSTATEDATA
{
    DWORD                       dwFlags;        // Flags to indicate the data
                                                // required
    union
    {
        PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
        DWORD_PTR                   dwhContext;     // d3d context
    };
    LPDWORD                     lpdwStates;     // ptr to the state data
                                                // to be filled in by the
                                                // driver
    DWORD                       dwLength;
    HRESULT                     ddRVal;         // return value
} DD_GETDRIVERSTATEDATA;

typedef struct _DD_DESTROYDDLOCALDATA
{
    DWORD dwFlags;
    PDD_DIRECTDRAW_LOCAL pDDLcl;
    HRESULT  ddRVal;
} DD_DESTROYDDLOCALDATA;


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ddstream.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for ddstream.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ddstream_h__
#define __ddstream_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirectDrawMediaStream_FWD_DEFINED__
#define __IDirectDrawMediaStream_FWD_DEFINED__
typedef interface IDirectDrawMediaStream IDirectDrawMediaStream;
#endif 	/* __IDirectDrawMediaStream_FWD_DEFINED__ */


#ifndef __IDirectDrawStreamSample_FWD_DEFINED__
#define __IDirectDrawStreamSample_FWD_DEFINED__
typedef interface IDirectDrawStreamSample IDirectDrawStreamSample;
#endif 	/* __IDirectDrawStreamSample_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mmstream.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ddstream_0000_0000 */
/* [local] */ 

//
//   The following declarations within the 'if 0' block are dummy typedefs used to make
//   the ddstream.idl file build.  The actual definitions are contained in DDRAW.H
//
#if 0
typedef void *LPDDSURFACEDESC;

typedef struct tDDSURFACEDESC DDSURFACEDESC;

#endif
#include <ddraw.h>

enum __MIDL___MIDL_itf_ddstream_0000_0000_0001
    {	DDSFF_PROGRESSIVERENDER	= 0x1
    } ;







extern RPC_IF_HANDLE __MIDL_itf_ddstream_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ddstream_0000_0000_v0_0_s_ifspec;

#ifndef __IDirectDrawMediaStream_INTERFACE_DEFINED__
#define __IDirectDrawMediaStream_INTERFACE_DEFINED__

/* interface IDirectDrawMediaStream */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4104FCE-9A70-11d0-8FDE-00C04FD9189D")
    IDirectDrawMediaStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [out] */ DDSURFACEDESC *pDDSDCurrent,
            /* [out] */ IDirectDrawPalette **ppDirectDrawPalette,
            /* [out] */ DDSURFACEDESC *pDDSDDesired,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ IDirectDrawPalette *pDirectDrawPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDraw( 
            /* [out] */ IDirectDraw **ppDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirectDraw( 
            /* [in] */ IDirectDraw *pDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSample( 
            /* [in] */ IDirectDrawSurface *pSurface,
            /* [in] */ const RECT *pRect,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDirectDrawStreamSample **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimePerFrame( 
            /* [out] */ STREAM_TIME *pFrameTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IDirectDrawMediaStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IDirectDrawMediaStream * This,
            /* [out] */ MSPID *pPurposeId,
            /* [out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IDirectDrawMediaStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IDirectDrawMediaStream * This,
            /* [out] */ DDSURFACEDESC *pDDSDCurrent,
            /* [out] */ IDirectDrawPalette **ppDirectDrawPalette,
            /* [out] */ DDSURFACEDESC *pDDSDDesired,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IDirectDrawMediaStream * This,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ IDirectDrawPalette *pDirectDrawPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDraw )( 
            IDirectDrawMediaStream * This,
            /* [out] */ IDirectDraw **ppDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectDraw )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IDirectDraw *pDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IDirectDrawSurface *pSurface,
            /* [in] */ const RECT *pRect,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDirectDrawStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimePerFrame )( 
            IDirectDrawMediaStream * This,
            /* [out] */ STREAM_TIME *pFrameTime);
        
        END_INTERFACE
    } IDirectDrawMediaStreamVtbl;

    interface IDirectDrawMediaStream
    {
        CONST_VTBL struct IDirectDrawMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawMediaStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectDrawMediaStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectDrawMediaStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectDrawMediaStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    ( (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream) ) 

#define IDirectDrawMediaStream_GetInformation(This,pPurposeId,pType)	\
    ( (This)->lpVtbl -> GetInformation(This,pPurposeId,pType) ) 

#define IDirectDrawMediaStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    ( (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags) ) 

#define IDirectDrawMediaStream_AllocateSample(This,dwFlags,ppSample)	\
    ( (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample) ) 

#define IDirectDrawMediaStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    ( (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample) ) 

#define IDirectDrawMediaStream_SendEndOfStream(This,dwFlags)	\
    ( (This)->lpVtbl -> SendEndOfStream(This,dwFlags) ) 


#define IDirectDrawMediaStream_GetFormat(This,pDDSDCurrent,ppDirectDrawPalette,pDDSDDesired,pdwFlags)	\
    ( (This)->lpVtbl -> GetFormat(This,pDDSDCurrent,ppDirectDrawPalette,pDDSDDesired,pdwFlags) ) 

#define IDirectDrawMediaStream_SetFormat(This,pDDSurfaceDesc,pDirectDrawPalette)	\
    ( (This)->lpVtbl -> SetFormat(This,pDDSurfaceDesc,pDirectDrawPalette) ) 

#define IDirectDrawMediaStream_GetDirectDraw(This,ppDirectDraw)	\
    ( (This)->lpVtbl -> GetDirectDraw(This,ppDirectDraw) ) 

#define IDirectDrawMediaStream_SetDirectDraw(This,pDirectDraw)	\
    ( (This)->lpVtbl -> SetDirectDraw(This,pDirectDraw) ) 

#define IDirectDrawMediaStream_CreateSample(This,pSurface,pRect,dwFlags,ppSample)	\
    ( (This)->lpVtbl -> CreateSample(This,pSurface,pRect,dwFlags,ppSample) ) 

#define IDirectDrawMediaStream_GetTimePerFrame(This,pFrameTime)	\
    ( (This)->lpVtbl -> GetTimePerFrame(This,pFrameTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectDrawMediaStream_INTERFACE_DEFINED__ */


#ifndef __IDirectDrawStreamSample_INTERFACE_DEFINED__
#define __IDirectDrawStreamSample_INTERFACE_DEFINED__

/* interface IDirectDrawStreamSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawStreamSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4104FCF-9A70-11d0-8FDE-00C04FD9189D")
    IDirectDrawStreamSample : public IStreamSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [out] */ RECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ const RECT *pRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawStreamSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawStreamSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawStreamSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawStreamSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IDirectDrawStreamSample * This,
            /* [in] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleTimes )( 
            IDirectDrawStreamSample * This,
            /* [out] */ STREAM_TIME *pStartTime,
            /* [out] */ STREAM_TIME *pEndTime,
            /* [out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleTimes )( 
            IDirectDrawStreamSample * This,
            /* [in] */ const STREAM_TIME *pStartTime,
            /* [in] */ const STREAM_TIME *pEndTime);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IDirectDrawStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HANDLE hEvent,
            /* [in] */ PAPCFUNC pfnAPC,
            /* [in] */ DWORD_PTR dwAPCData);
        
        HRESULT ( STDMETHODCALLTYPE *CompletionStatus )( 
            IDirectDrawStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDirectDrawStreamSample * This,
            /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [out] */ RECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            IDirectDrawStreamSample * This,
            /* [in] */ const RECT *pRect);
        
        END_INTERFACE
    } IDirectDrawStreamSampleVtbl;

    interface IDirectDrawStreamSample
    {
        CONST_VTBL struct IDirectDrawStreamSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawStreamSample_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectDrawStreamSample_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectDrawStreamSample_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectDrawStreamSample_GetMediaStream(This,ppMediaStream)	\
    ( (This)->lpVtbl -> GetMediaStream(This,ppMediaStream) ) 

#define IDirectDrawStreamSample_GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)	\
    ( (This)->lpVtbl -> GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime) ) 

#define IDirectDrawStreamSample_SetSampleTimes(This,pStartTime,pEndTime)	\
    ( (This)->lpVtbl -> SetSampleTimes(This,pStartTime,pEndTime) ) 

#define IDirectDrawStreamSample_Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)	\
    ( (This)->lpVtbl -> Update(This,dwFlags,hEvent,pfnAPC,dwAPCData) ) 

#define IDirectDrawStreamSample_CompletionStatus(This,dwFlags,dwMilliseconds)	\
    ( (This)->lpVtbl -> CompletionStatus(This,dwFlags,dwMilliseconds) ) 


#define IDirectDrawStreamSample_GetSurface(This,ppDirectDrawSurface,pRect)	\
    ( (This)->lpVtbl -> GetSurface(This,ppDirectDrawSurface,pRect) ) 

#define IDirectDrawStreamSample_SetRect(This,pRect)	\
    ( (This)->lpVtbl -> SetRect(This,pRect) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectDrawStreamSample_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\devioctl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    devioctl.h

Abstract:

    This module contains


Revision History:


--*/

// begin_winioctl

#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Macro to extract buffering method out of the device io control code
//
#define METHOD_FROM_CTL_CODE(ctrlCode)          ((ULONG)(ctrlCode & 3))

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define some easier to comprehend aliases:
//   METHOD_DIRECT_TO_HARDWARE (writes, aka METHOD_IN_DIRECT)
//   METHOD_DIRECT_FROM_HARDWARE (reads, aka METHOD_OUT_DIRECT)
//

#define METHOD_DIRECT_TO_HARDWARE       METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE     METHOD_OUT_DIRECT

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_wdm end_nthal end_ntifs

#endif // _DEVIOCTL_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\devpropdef.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devpropdef.h

Abstract:

    Defines property types and keys for the Plug and Play Device Property API.

Environment:

    User and Kernel modes.

--*/



#ifndef _DEVPROPDEF_H_
#define _DEVPROPDEF_H_

//
// Type definition for property data types.  Valid DEVPROPTYPE values are
// constructed from base DEVPROP_TYPE_ values, which may be modified by a
// logical OR with DEVPROP_TYPEMOD_ values, as appropriate.
//
typedef ULONG DEVPROPTYPE, *PDEVPROPTYPE;

//
// Property type modifiers.  Used to modify base DEVPROP_TYPE_ values, as
// appropriate.  Not valid as standalone DEVPROPTYPE values.
//
#define DEVPROP_TYPEMOD_ARRAY                   0x00001000  // array of fixed-sized data elements
#define DEVPROP_TYPEMOD_LIST                    0x00002000  // list of variable-sized data elements

//
// Property data types.
//
#define DEVPROP_TYPE_EMPTY                      0x00000000  // nothing, no property data
#define DEVPROP_TYPE_NULL                       0x00000001  // null property data
#define DEVPROP_TYPE_SBYTE                      0x00000002  // 8-bit signed int (SBYTE)
#define DEVPROP_TYPE_BYTE                       0x00000003  // 8-bit unsigned int (BYTE)
#define DEVPROP_TYPE_INT16                      0x00000004  // 16-bit signed int (SHORT)
#define DEVPROP_TYPE_UINT16                     0x00000005  // 16-bit unsigned int (USHORT)
#define DEVPROP_TYPE_INT32                      0x00000006  // 32-bit signed int (LONG)
#define DEVPROP_TYPE_UINT32                     0x00000007  // 32-bit unsigned int (ULONG)
#define DEVPROP_TYPE_INT64                      0x00000008  // 64-bit signed int (LONG64)
#define DEVPROP_TYPE_UINT64                     0x00000009  // 64-bit unsigned int (ULONG64)
#define DEVPROP_TYPE_FLOAT                      0x0000000A  // 32-bit floating-point (FLOAT)
#define DEVPROP_TYPE_DOUBLE                     0x0000000B  // 64-bit floating-point (DOUBLE)
#define DEVPROP_TYPE_DECIMAL                    0x0000000C  // 128-bit data (DECIMAL)
#define DEVPROP_TYPE_GUID                       0x0000000D  // 128-bit unique identifier (GUID)
#define DEVPROP_TYPE_CURRENCY                   0x0000000E  // 64 bit signed int currency value (CURRENCY)
#define DEVPROP_TYPE_DATE                       0x0000000F  // date (DATE)
#define DEVPROP_TYPE_FILETIME                   0x00000010  // file time (FILETIME)
#define DEVPROP_TYPE_BOOLEAN                    0x00000011  // 8-bit boolean (DEVPROP_BOOLEAN)
#define DEVPROP_TYPE_STRING                     0x00000012  // null-terminated string
#define DEVPROP_TYPE_STRING_LIST (DEVPROP_TYPE_STRING|DEVPROP_TYPEMOD_LIST) // multi-sz string list
#define DEVPROP_TYPE_SECURITY_DESCRIPTOR        0x00000013  // self-relative binary SECURITY_DESCRIPTOR
#define DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING 0x00000014  // security descriptor string (SDDL format)
#define DEVPROP_TYPE_DEVPROPKEY                 0x00000015  // device property key (DEVPROPKEY)
#define DEVPROP_TYPE_DEVPROPTYPE                0x00000016  // device property type (DEVPROPTYPE)
#define DEVPROP_TYPE_BINARY      (DEVPROP_TYPE_BYTE|DEVPROP_TYPEMOD_ARRAY)  // custom binary data
#define DEVPROP_TYPE_ERROR                      0x00000017  // 32-bit Win32 system error code
#define DEVPROP_TYPE_NTSTATUS                   0x00000018  // 32-bit NTSTATUS code
#define DEVPROP_TYPE_STRING_INDIRECT            0x00000019  // string resource (@[path\]<dllname>,-<strId>)

//
// Max base DEVPROP_TYPE_ and DEVPROP_TYPEMOD_ values.
//
#define MAX_DEVPROP_TYPE                        0x00000019  // max valid DEVPROP_TYPE_ value
#define MAX_DEVPROP_TYPEMOD                     0x00002000  // max valid DEVPROP_TYPEMOD_ value

//
// Bitmasks for extracting DEVPROP_TYPE_ and DEVPROP_TYPEMOD_ values.
//
#define DEVPROP_MASK_TYPE                       0x00000FFF  // range for base DEVPROP_TYPE_ values
#define DEVPROP_MASK_TYPEMOD                    0x0000F000  // mask for DEVPROP_TYPEMOD_ type modifiers


//
// Property type specific data types.
//

// 8-bit boolean type definition for DEVPROP_TYPE_BOOLEAN (True=-1, False=0)
typedef CHAR DEVPROP_BOOLEAN, *PDEVPROP_BOOLEAN;
#define DEVPROP_TRUE  ((DEVPROP_BOOLEAN)-1)
#define DEVPROP_FALSE ((DEVPROP_BOOLEAN) 0)


//
// DEVPROPKEY structure
//

#ifndef DEVPROPKEY_DEFINED
#define DEVPROPKEY_DEFINED

typedef GUID  DEVPROPGUID, *PDEVPROPGUID;
typedef ULONG DEVPROPID,   *PDEVPROPID;

typedef struct _DEVPROPKEY {
    DEVPROPGUID fmtid;
    DEVPROPID   pid;
} DEVPROPKEY, *PDEVPROPKEY;

#endif // DEVPROPKEY_DEFINED

//
// All valid DEVPROPKEY definitions must use a PROPID that is equal to or greater
// than DEVPROPID_FIRST_USABLE.
//
#define DEVPROPID_FIRST_USABLE 2

#endif // _DEVPROPDEF_H_


#ifdef DEFINE_DEVPROPKEY
#undef DEFINE_DEVPROPKEY
#endif
#ifdef INITGUID
#define DEFINE_DEVPROPKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const DEVPROPKEY DECLSPEC_SELECTANY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
#else
#define DEFINE_DEVPROPKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const DEVPROPKEY name
#endif // INITGUID


#ifndef IsEqualDevPropKey
#ifdef __cplusplus
#define IsEqualDevPropKey(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#else // !__cplusplus
#define IsEqualDevPropKey(a, b)   (((a).pid == (b).pid) && IsEqualIID(&(a).fmtid, &(b).fmtid) )
#endif // __cplusplus
#endif // !IsEqualDevPropKey
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\devicetopology.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for devicetopology.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __devicetopology_h__
#define __devicetopology_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IKsControl_FWD_DEFINED__
#define __IKsControl_FWD_DEFINED__
typedef interface IKsControl IKsControl;
#endif 	/* __IKsControl_FWD_DEFINED__ */


#ifndef __IPerChannelDbLevel_FWD_DEFINED__
#define __IPerChannelDbLevel_FWD_DEFINED__
typedef interface IPerChannelDbLevel IPerChannelDbLevel;
#endif 	/* __IPerChannelDbLevel_FWD_DEFINED__ */


#ifndef __IAudioVolumeLevel_FWD_DEFINED__
#define __IAudioVolumeLevel_FWD_DEFINED__
typedef interface IAudioVolumeLevel IAudioVolumeLevel;
#endif 	/* __IAudioVolumeLevel_FWD_DEFINED__ */


#ifndef __IAudioChannelConfig_FWD_DEFINED__
#define __IAudioChannelConfig_FWD_DEFINED__
typedef interface IAudioChannelConfig IAudioChannelConfig;
#endif 	/* __IAudioChannelConfig_FWD_DEFINED__ */


#ifndef __IAudioLoudness_FWD_DEFINED__
#define __IAudioLoudness_FWD_DEFINED__
typedef interface IAudioLoudness IAudioLoudness;
#endif 	/* __IAudioLoudness_FWD_DEFINED__ */


#ifndef __IAudioInputSelector_FWD_DEFINED__
#define __IAudioInputSelector_FWD_DEFINED__
typedef interface IAudioInputSelector IAudioInputSelector;
#endif 	/* __IAudioInputSelector_FWD_DEFINED__ */


#ifndef __IAudioOutputSelector_FWD_DEFINED__
#define __IAudioOutputSelector_FWD_DEFINED__
typedef interface IAudioOutputSelector IAudioOutputSelector;
#endif 	/* __IAudioOutputSelector_FWD_DEFINED__ */


#ifndef __IAudioMute_FWD_DEFINED__
#define __IAudioMute_FWD_DEFINED__
typedef interface IAudioMute IAudioMute;
#endif 	/* __IAudioMute_FWD_DEFINED__ */


#ifndef __IAudioBass_FWD_DEFINED__
#define __IAudioBass_FWD_DEFINED__
typedef interface IAudioBass IAudioBass;
#endif 	/* __IAudioBass_FWD_DEFINED__ */


#ifndef __IAudioMidrange_FWD_DEFINED__
#define __IAudioMidrange_FWD_DEFINED__
typedef interface IAudioMidrange IAudioMidrange;
#endif 	/* __IAudioMidrange_FWD_DEFINED__ */


#ifndef __IAudioTreble_FWD_DEFINED__
#define __IAudioTreble_FWD_DEFINED__
typedef interface IAudioTreble IAudioTreble;
#endif 	/* __IAudioTreble_FWD_DEFINED__ */


#ifndef __IAudioAutoGainControl_FWD_DEFINED__
#define __IAudioAutoGainControl_FWD_DEFINED__
typedef interface IAudioAutoGainControl IAudioAutoGainControl;
#endif 	/* __IAudioAutoGainControl_FWD_DEFINED__ */


#ifndef __IAudioPeakMeter_FWD_DEFINED__
#define __IAudioPeakMeter_FWD_DEFINED__
typedef interface IAudioPeakMeter IAudioPeakMeter;
#endif 	/* __IAudioPeakMeter_FWD_DEFINED__ */


#ifndef __IDeviceSpecificProperty_FWD_DEFINED__
#define __IDeviceSpecificProperty_FWD_DEFINED__
typedef interface IDeviceSpecificProperty IDeviceSpecificProperty;
#endif 	/* __IDeviceSpecificProperty_FWD_DEFINED__ */


#ifndef __IKsFormatSupport_FWD_DEFINED__
#define __IKsFormatSupport_FWD_DEFINED__
typedef interface IKsFormatSupport IKsFormatSupport;
#endif 	/* __IKsFormatSupport_FWD_DEFINED__ */


#ifndef __IKsJackDescription_FWD_DEFINED__
#define __IKsJackDescription_FWD_DEFINED__
typedef interface IKsJackDescription IKsJackDescription;
#endif 	/* __IKsJackDescription_FWD_DEFINED__ */


#ifndef __IPartsList_FWD_DEFINED__
#define __IPartsList_FWD_DEFINED__
typedef interface IPartsList IPartsList;
#endif 	/* __IPartsList_FWD_DEFINED__ */


#ifndef __IPart_FWD_DEFINED__
#define __IPart_FWD_DEFINED__
typedef interface IPart IPart;
#endif 	/* __IPart_FWD_DEFINED__ */


#ifndef __IConnector_FWD_DEFINED__
#define __IConnector_FWD_DEFINED__
typedef interface IConnector IConnector;
#endif 	/* __IConnector_FWD_DEFINED__ */


#ifndef __ISubunit_FWD_DEFINED__
#define __ISubunit_FWD_DEFINED__
typedef interface ISubunit ISubunit;
#endif 	/* __ISubunit_FWD_DEFINED__ */


#ifndef __IControlInterface_FWD_DEFINED__
#define __IControlInterface_FWD_DEFINED__
typedef interface IControlInterface IControlInterface;
#endif 	/* __IControlInterface_FWD_DEFINED__ */


#ifndef __IControlChangeNotify_FWD_DEFINED__
#define __IControlChangeNotify_FWD_DEFINED__
typedef interface IControlChangeNotify IControlChangeNotify;
#endif 	/* __IControlChangeNotify_FWD_DEFINED__ */


#ifndef __IDeviceTopology_FWD_DEFINED__
#define __IDeviceTopology_FWD_DEFINED__
typedef interface IDeviceTopology IDeviceTopology;
#endif 	/* __IDeviceTopology_FWD_DEFINED__ */


#ifndef __DeviceTopology_FWD_DEFINED__
#define __DeviceTopology_FWD_DEFINED__

#ifdef __cplusplus
typedef class DeviceTopology DeviceTopology;
#else
typedef struct DeviceTopology DeviceTopology;
#endif /* __cplusplus */

#endif 	/* __DeviceTopology_FWD_DEFINED__ */


#ifndef __IPartsList_FWD_DEFINED__
#define __IPartsList_FWD_DEFINED__
typedef interface IPartsList IPartsList;
#endif 	/* __IPartsList_FWD_DEFINED__ */


#ifndef __IPerChannelDbLevel_FWD_DEFINED__
#define __IPerChannelDbLevel_FWD_DEFINED__
typedef interface IPerChannelDbLevel IPerChannelDbLevel;
#endif 	/* __IPerChannelDbLevel_FWD_DEFINED__ */


#ifndef __IAudioVolumeLevel_FWD_DEFINED__
#define __IAudioVolumeLevel_FWD_DEFINED__
typedef interface IAudioVolumeLevel IAudioVolumeLevel;
#endif 	/* __IAudioVolumeLevel_FWD_DEFINED__ */


#ifndef __IAudioLoudness_FWD_DEFINED__
#define __IAudioLoudness_FWD_DEFINED__
typedef interface IAudioLoudness IAudioLoudness;
#endif 	/* __IAudioLoudness_FWD_DEFINED__ */


#ifndef __IAudioInputSelector_FWD_DEFINED__
#define __IAudioInputSelector_FWD_DEFINED__
typedef interface IAudioInputSelector IAudioInputSelector;
#endif 	/* __IAudioInputSelector_FWD_DEFINED__ */


#ifndef __IAudioMute_FWD_DEFINED__
#define __IAudioMute_FWD_DEFINED__
typedef interface IAudioMute IAudioMute;
#endif 	/* __IAudioMute_FWD_DEFINED__ */


#ifndef __IAudioBass_FWD_DEFINED__
#define __IAudioBass_FWD_DEFINED__
typedef interface IAudioBass IAudioBass;
#endif 	/* __IAudioBass_FWD_DEFINED__ */


#ifndef __IAudioMidrange_FWD_DEFINED__
#define __IAudioMidrange_FWD_DEFINED__
typedef interface IAudioMidrange IAudioMidrange;
#endif 	/* __IAudioMidrange_FWD_DEFINED__ */


#ifndef __IAudioTreble_FWD_DEFINED__
#define __IAudioTreble_FWD_DEFINED__
typedef interface IAudioTreble IAudioTreble;
#endif 	/* __IAudioTreble_FWD_DEFINED__ */


#ifndef __IAudioAutoGainControl_FWD_DEFINED__
#define __IAudioAutoGainControl_FWD_DEFINED__
typedef interface IAudioAutoGainControl IAudioAutoGainControl;
#endif 	/* __IAudioAutoGainControl_FWD_DEFINED__ */


#ifndef __IAudioOutputSelector_FWD_DEFINED__
#define __IAudioOutputSelector_FWD_DEFINED__
typedef interface IAudioOutputSelector IAudioOutputSelector;
#endif 	/* __IAudioOutputSelector_FWD_DEFINED__ */


#ifndef __IAudioPeakMeter_FWD_DEFINED__
#define __IAudioPeakMeter_FWD_DEFINED__
typedef interface IAudioPeakMeter IAudioPeakMeter;
#endif 	/* __IAudioPeakMeter_FWD_DEFINED__ */


#ifndef __IDeviceSpecificProperty_FWD_DEFINED__
#define __IDeviceSpecificProperty_FWD_DEFINED__
typedef interface IDeviceSpecificProperty IDeviceSpecificProperty;
#endif 	/* __IDeviceSpecificProperty_FWD_DEFINED__ */


#ifndef __IKsFormatSupport_FWD_DEFINED__
#define __IKsFormatSupport_FWD_DEFINED__
typedef interface IKsFormatSupport IKsFormatSupport;
#endif 	/* __IKsFormatSupport_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_devicetopology_0000_0000 */
/* [local] */ 

#define E_NOTFOUND HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
//
//   Flag for clients of IControlChangeNotify::OnNotify to allow those clients to identify hardware initiated notifications
//
#define DEVTOPO_HARDWARE_INITIATED_EVENTCONTEXT 'draH'
/* E2C2E9DE-09B1-4B04-84E5-07931225EE04 */
DEFINE_GUID(EVENTCONTEXT_VOLUMESLIDER, 0xE2C2E9DE,0x09B1,0x4B04,0x84, 0xE5, 0x07, 0x93, 0x12, 0x25, 0xEE, 0x04);
#define _IKsControl_
#include "ks.h"
#include "ksmedia.h"
#ifndef _KS_
typedef /* [public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0001
    {
    ULONG FormatSize;
    ULONG Flags;
    ULONG SampleSize;
    ULONG Reserved;
    GUID MajorFormat;
    GUID SubFormat;
    GUID Specifier;
    } 	KSDATAFORMAT;

typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0001 *PKSDATAFORMAT;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0002
    {
    union 
        {
        struct 
            {
            GUID Set;
            ULONG Id;
            ULONG Flags;
            } 	;
        LONGLONG Alignment;
        } 	;
    } 	KSIDENTIFIER;

typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0002 *PKSIDENTIFIER;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0005
    {	ePcxChanMap_FL_FR	= 0,
	ePcxChanMap_FC_LFE	= ( ePcxChanMap_FL_FR + 1 ) ,
	ePcxChanMap_BL_BR	= ( ePcxChanMap_FC_LFE + 1 ) ,
	ePcxChanMap_FLC_FRC	= ( ePcxChanMap_BL_BR + 1 ) ,
	ePcxChanMap_SL_SR	= ( ePcxChanMap_FLC_FRC + 1 ) ,
	ePcxChanMap_Unknown	= ( ePcxChanMap_SL_SR + 1 ) 
    } 	EChannelMapping;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0006
    {	eConnTypeUnknown	= 0,
	eConnTypeEighth	= ( eConnTypeUnknown + 1 ) ,
	eConnTypeQuarter	= ( eConnTypeEighth + 1 ) ,
	eConnTypeAtapiInternal	= ( eConnTypeQuarter + 1 ) ,
	eConnTypeRCA	= ( eConnTypeAtapiInternal + 1 ) ,
	eConnTypeOptical	= ( eConnTypeRCA + 1 ) ,
	eConnTypeOtherDigital	= ( eConnTypeOptical + 1 ) ,
	eConnTypeOtherAnalog	= ( eConnTypeOtherDigital + 1 ) ,
	eConnTypeMultichannelAnalogDIN	= ( eConnTypeOtherAnalog + 1 ) ,
	eConnTypeXlrProfessional	= ( eConnTypeMultichannelAnalogDIN + 1 ) ,
	eConnTypeRJ11Modem	= ( eConnTypeXlrProfessional + 1 ) ,
	eConnTypeCombination	= ( eConnTypeRJ11Modem + 1 ) 
    } 	EPcxConnectionType;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0007
    {	eGeoLocRear	= 0x1,
	eGeoLocFront	= ( eGeoLocRear + 1 ) ,
	eGeoLocLeft	= ( eGeoLocFront + 1 ) ,
	eGeoLocRight	= ( eGeoLocLeft + 1 ) ,
	eGeoLocTop	= ( eGeoLocRight + 1 ) ,
	eGeoLocBottom	= ( eGeoLocTop + 1 ) ,
	eGeoLocRearOPanel	= ( eGeoLocBottom + 1 ) ,
	eGeoLocRiser	= ( eGeoLocRearOPanel + 1 ) ,
	eGeoLocInsideMobileLid	= ( eGeoLocRiser + 1 ) ,
	eGeoLocDrivebay	= ( eGeoLocInsideMobileLid + 1 ) ,
	eGeoLocHDMI	= ( eGeoLocDrivebay + 1 ) ,
	eGeoLocOutsideMobileLid	= ( eGeoLocHDMI + 1 ) ,
	eGeoLocATAPI	= ( eGeoLocOutsideMobileLid + 1 ) ,
	eGeoLocReserved5	= ( eGeoLocATAPI + 1 ) ,
	eGeoLocReserved6	= ( eGeoLocReserved5 + 1 ) 
    } 	EPcxGeoLocation;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0008
    {	eGenLocPrimaryBox	= 0,
	eGenLocInternal	= ( eGenLocPrimaryBox + 1 ) ,
	eGenLocSeperate	= ( eGenLocInternal + 1 ) ,
	eGenLocOther	= ( eGenLocSeperate + 1 ) 
    } 	EPcxGenLocation;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0009
    {	ePortConnJack	= 0,
	ePortConnIntegratedDevice	= ( ePortConnJack + 1 ) ,
	ePortConnBothIntegratedAndJack	= ( ePortConnIntegratedDevice + 1 ) ,
	ePortConnUnknown	= ( ePortConnBothIntegratedAndJack + 1 ) 
    } 	EPxcPortConnection;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0010
    {
    EChannelMapping ChannelMapping;
    COLORREF Color;
    EPcxConnectionType ConnectionType;
    EPcxGeoLocation GeoLocation;
    EPcxGenLocation GenLocation;
    EPxcPortConnection PortConnection;
    BOOL IsConnected;
    } 	KSJACK_DESCRIPTION;

typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0010 *PKSJACK_DESCRIPTION;

typedef KSIDENTIFIER KSPROPERTY;

typedef KSIDENTIFIER *PKSPROPERTY;

typedef KSIDENTIFIER KSMETHOD;

typedef KSIDENTIFIER *PKSMETHOD;

typedef KSIDENTIFIER KSEVENT;

typedef KSIDENTIFIER *PKSEVENT;

#endif








typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0011
    {	In	= 0,
	Out	= ( In + 1 ) 
    } 	DataFlow;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0012
    {	Connector	= 0,
	Subunit	= ( Connector + 1 ) 
    } 	PartType;

#define PARTTYPE_FLAG_CONNECTOR 0x00010000
#define PARTTYPE_FLAG_SUBUNIT   0x00020000
#define PARTTYPE_MASK           0x00030000
#define PARTID_MASK             0x0000ffff
typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_devicetopology_0000_0000_0013
    {	Unknown_Connector	= 0,
	Physical_Internal	= ( Unknown_Connector + 1 ) ,
	Physical_External	= ( Physical_Internal + 1 ) ,
	Software_IO	= ( Physical_External + 1 ) ,
	Software_Fixed	= ( Software_IO + 1 ) ,
	Network	= ( Software_Fixed + 1 ) 
    } 	ConnectorType;



extern RPC_IF_HANDLE __MIDL_itf_devicetopology_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_devicetopology_0000_0000_v0_0_s_ifspec;

#ifndef __IKsControl_INTERFACE_DEFINED__
#define __IKsControl_INTERFACE_DEFINED__

/* interface IKsControl */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IKsControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28F54685-06FD-11D2-B27A-00A0C9223196")
    IKsControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE KsProperty( 
            /* [in] */ PKSPROPERTY Property,
            /* [in] */ ULONG PropertyLength,
            /* [out][in] */ void *PropertyData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KsMethod( 
            /* [in] */ PKSMETHOD Method,
            /* [in] */ ULONG MethodLength,
            /* [out][in] */ void *MethodData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KsEvent( 
            /* [in] */ PKSEVENT Event,
            /* [in] */ ULONG EventLength,
            /* [out][in] */ void *EventData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *KsProperty )( 
            IKsControl * This,
            /* [in] */ PKSPROPERTY Property,
            /* [in] */ ULONG PropertyLength,
            /* [out][in] */ void *PropertyData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned);
        
        HRESULT ( STDMETHODCALLTYPE *KsMethod )( 
            IKsControl * This,
            /* [in] */ PKSMETHOD Method,
            /* [in] */ ULONG MethodLength,
            /* [out][in] */ void *MethodData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned);
        
        HRESULT ( STDMETHODCALLTYPE *KsEvent )( 
            IKsControl * This,
            /* [in] */ PKSEVENT Event,
            /* [in] */ ULONG EventLength,
            /* [out][in] */ void *EventData,
            /* [in] */ ULONG DataLength,
            /* [out] */ ULONG *BytesReturned);
        
        END_INTERFACE
    } IKsControlVtbl;

    interface IKsControl
    {
        CONST_VTBL struct IKsControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsControl_KsProperty(This,Property,PropertyLength,PropertyData,DataLength,BytesReturned)	\
    ( (This)->lpVtbl -> KsProperty(This,Property,PropertyLength,PropertyData,DataLength,BytesReturned) ) 

#define IKsControl_KsMethod(This,Method,MethodLength,MethodData,DataLength,BytesReturned)	\
    ( (This)->lpVtbl -> KsMethod(This,Method,MethodLength,MethodData,DataLength,BytesReturned) ) 

#define IKsControl_KsEvent(This,Event,EventLength,EventData,DataLength,BytesReturned)	\
    ( (This)->lpVtbl -> KsEvent(This,Event,EventLength,EventData,DataLength,BytesReturned) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsControl_INTERFACE_DEFINED__ */


#ifndef __IPerChannelDbLevel_INTERFACE_DEFINED__
#define __IPerChannelDbLevel_INTERFACE_DEFINED__

/* interface IPerChannelDbLevel */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IPerChannelDbLevel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C2F8E001-F205-4BC9-99BC-C13B1E048CCB")
    IPerChannelDbLevel : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ 
            __out  UINT *pcChannels) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevelRange( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevelUniform( 
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevelAllChannels( 
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerChannelDbLevelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPerChannelDbLevel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPerChannelDbLevel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPerChannelDbLevel * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IPerChannelDbLevel * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IPerChannelDbLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IPerChannelDbLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IPerChannelDbLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IPerChannelDbLevel * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IPerChannelDbLevel * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IPerChannelDbLevelVtbl;

    interface IPerChannelDbLevel
    {
        CONST_VTBL struct IPerChannelDbLevelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerChannelDbLevel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPerChannelDbLevel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPerChannelDbLevel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPerChannelDbLevel_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IPerChannelDbLevel_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IPerChannelDbLevel_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IPerChannelDbLevel_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IPerChannelDbLevel_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IPerChannelDbLevel_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPerChannelDbLevel_INTERFACE_DEFINED__ */


#ifndef __IAudioVolumeLevel_INTERFACE_DEFINED__
#define __IAudioVolumeLevel_INTERFACE_DEFINED__

/* interface IAudioVolumeLevel */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioVolumeLevel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FB7B48F-531D-44A2-BCB3-5AD5A134B3DC")
    IAudioVolumeLevel : public IPerChannelDbLevel
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAudioVolumeLevelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioVolumeLevel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioVolumeLevel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioVolumeLevel * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioVolumeLevel * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IAudioVolumeLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioVolumeLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IAudioVolumeLevel * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IAudioVolumeLevel * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IAudioVolumeLevel * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioVolumeLevelVtbl;

    interface IAudioVolumeLevel
    {
        CONST_VTBL struct IAudioVolumeLevelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioVolumeLevel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioVolumeLevel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioVolumeLevel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioVolumeLevel_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioVolumeLevel_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IAudioVolumeLevel_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IAudioVolumeLevel_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioVolumeLevel_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IAudioVolumeLevel_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioVolumeLevel_INTERFACE_DEFINED__ */


#ifndef __IAudioChannelConfig_INTERFACE_DEFINED__
#define __IAudioChannelConfig_INTERFACE_DEFINED__

/* interface IAudioChannelConfig */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioChannelConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB11C46F-EC28-493C-B88A-5DB88062CE98")
    IAudioChannelConfig : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetChannelConfig( 
            /* [in] */ DWORD dwConfig,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelConfig( 
            /* [retval][out] */ DWORD *pdwConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioChannelConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioChannelConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioChannelConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioChannelConfig * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetChannelConfig )( 
            IAudioChannelConfig * This,
            /* [in] */ DWORD dwConfig,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelConfig )( 
            IAudioChannelConfig * This,
            /* [retval][out] */ DWORD *pdwConfig);
        
        END_INTERFACE
    } IAudioChannelConfigVtbl;

    interface IAudioChannelConfig
    {
        CONST_VTBL struct IAudioChannelConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioChannelConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioChannelConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioChannelConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioChannelConfig_SetChannelConfig(This,dwConfig,pguidEventContext)	\
    ( (This)->lpVtbl -> SetChannelConfig(This,dwConfig,pguidEventContext) ) 

#define IAudioChannelConfig_GetChannelConfig(This,pdwConfig)	\
    ( (This)->lpVtbl -> GetChannelConfig(This,pdwConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioChannelConfig_INTERFACE_DEFINED__ */


#ifndef __IAudioLoudness_INTERFACE_DEFINED__
#define __IAudioLoudness_INTERFACE_DEFINED__

/* interface IAudioLoudness */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioLoudness;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7D8B1437-DD53-4350-9C1B-1EE2890BD938")
    IAudioLoudness : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEnabled( 
            /* [out] */ 
            __out  BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ 
            __in  BOOL bEnable,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioLoudnessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioLoudness * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioLoudness * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioLoudness * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
            IAudioLoudness * This,
            /* [out] */ 
            __out  BOOL *pbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IAudioLoudness * This,
            /* [in] */ 
            __in  BOOL bEnable,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioLoudnessVtbl;

    interface IAudioLoudness
    {
        CONST_VTBL struct IAudioLoudnessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioLoudness_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioLoudness_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioLoudness_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioLoudness_GetEnabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> GetEnabled(This,pbEnabled) ) 

#define IAudioLoudness_SetEnabled(This,bEnable,pguidEventContext)	\
    ( (This)->lpVtbl -> SetEnabled(This,bEnable,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioLoudness_INTERFACE_DEFINED__ */


#ifndef __IAudioInputSelector_INTERFACE_DEFINED__
#define __IAudioInputSelector_INTERFACE_DEFINED__

/* interface IAudioInputSelector */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioInputSelector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F03DC02-5E6E-4653-8F72-A030C123D598")
    IAudioInputSelector : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [out] */ 
            __out  UINT *pnIdSelected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ 
            __in  UINT nIdSelect,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioInputSelectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioInputSelector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioInputSelector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioInputSelector * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            IAudioInputSelector * This,
            /* [out] */ 
            __out  UINT *pnIdSelected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            IAudioInputSelector * This,
            /* [in] */ 
            __in  UINT nIdSelect,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioInputSelectorVtbl;

    interface IAudioInputSelector
    {
        CONST_VTBL struct IAudioInputSelectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioInputSelector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioInputSelector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioInputSelector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioInputSelector_GetSelection(This,pnIdSelected)	\
    ( (This)->lpVtbl -> GetSelection(This,pnIdSelected) ) 

#define IAudioInputSelector_SetSelection(This,nIdSelect,pguidEventContext)	\
    ( (This)->lpVtbl -> SetSelection(This,nIdSelect,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioInputSelector_INTERFACE_DEFINED__ */


#ifndef __IAudioOutputSelector_INTERFACE_DEFINED__
#define __IAudioOutputSelector_INTERFACE_DEFINED__

/* interface IAudioOutputSelector */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioOutputSelector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB515F69-94A7-429e-8B9C-271B3F11A3AB")
    IAudioOutputSelector : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [out] */ 
            __out  UINT *pnIdSelected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ 
            __in  UINT nIdSelect,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioOutputSelectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioOutputSelector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioOutputSelector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioOutputSelector * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            IAudioOutputSelector * This,
            /* [out] */ 
            __out  UINT *pnIdSelected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            IAudioOutputSelector * This,
            /* [in] */ 
            __in  UINT nIdSelect,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioOutputSelectorVtbl;

    interface IAudioOutputSelector
    {
        CONST_VTBL struct IAudioOutputSelectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioOutputSelector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioOutputSelector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioOutputSelector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioOutputSelector_GetSelection(This,pnIdSelected)	\
    ( (This)->lpVtbl -> GetSelection(This,pnIdSelected) ) 

#define IAudioOutputSelector_SetSelection(This,nIdSelect,pguidEventContext)	\
    ( (This)->lpVtbl -> SetSelection(This,nIdSelect,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioOutputSelector_INTERFACE_DEFINED__ */


#ifndef __IAudioMute_INTERFACE_DEFINED__
#define __IAudioMute_INTERFACE_DEFINED__

/* interface IAudioMute */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioMute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF45AEEA-B74A-4B6B-AFAD-2366B6AA012E")
    IAudioMute : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetMute( 
            /* [in] */ 
            __in  BOOL bMuted,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMute( 
            /* [out] */ 
            __out  BOOL *pbMuted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioMuteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioMute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioMute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioMute * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMute )( 
            IAudioMute * This,
            /* [in] */ 
            __in  BOOL bMuted,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMute )( 
            IAudioMute * This,
            /* [out] */ 
            __out  BOOL *pbMuted);
        
        END_INTERFACE
    } IAudioMuteVtbl;

    interface IAudioMute
    {
        CONST_VTBL struct IAudioMuteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioMute_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioMute_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioMute_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioMute_SetMute(This,bMuted,pguidEventContext)	\
    ( (This)->lpVtbl -> SetMute(This,bMuted,pguidEventContext) ) 

#define IAudioMute_GetMute(This,pbMuted)	\
    ( (This)->lpVtbl -> GetMute(This,pbMuted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioMute_INTERFACE_DEFINED__ */


#ifndef __IAudioBass_INTERFACE_DEFINED__
#define __IAudioBass_INTERFACE_DEFINED__

/* interface IAudioBass */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioBass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2B1A1D9-4DB3-425D-A2B2-BD335CB3E2E5")
    IAudioBass : public IPerChannelDbLevel
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAudioBassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioBass * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioBass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioBass * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioBass * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IAudioBass * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioBass * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IAudioBass * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IAudioBass * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IAudioBass * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioBassVtbl;

    interface IAudioBass
    {
        CONST_VTBL struct IAudioBassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioBass_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioBass_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioBass_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioBass_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioBass_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IAudioBass_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IAudioBass_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioBass_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IAudioBass_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioBass_INTERFACE_DEFINED__ */


#ifndef __IAudioMidrange_INTERFACE_DEFINED__
#define __IAudioMidrange_INTERFACE_DEFINED__

/* interface IAudioMidrange */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioMidrange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5E54B6D7-B44B-40D9-9A9E-E691D9CE6EDF")
    IAudioMidrange : public IPerChannelDbLevel
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAudioMidrangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioMidrange * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioMidrange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioMidrange * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioMidrange * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IAudioMidrange * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioMidrange * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IAudioMidrange * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IAudioMidrange * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IAudioMidrange * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioMidrangeVtbl;

    interface IAudioMidrange
    {
        CONST_VTBL struct IAudioMidrangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioMidrange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioMidrange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioMidrange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioMidrange_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioMidrange_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IAudioMidrange_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IAudioMidrange_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioMidrange_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IAudioMidrange_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioMidrange_INTERFACE_DEFINED__ */


#ifndef __IAudioTreble_INTERFACE_DEFINED__
#define __IAudioTreble_INTERFACE_DEFINED__

/* interface IAudioTreble */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioTreble;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A717812-694E-4907-B74B-BAFA5CFDCA7B")
    IAudioTreble : public IPerChannelDbLevel
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAudioTrebleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioTreble * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioTreble * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioTreble * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioTreble * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
            IAudioTreble * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfMinLevelDB,
            /* [out] */ 
            __out  float *pfMaxLevelDB,
            /* [out] */ 
            __out  float *pfStepping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioTreble * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IAudioTreble * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
            IAudioTreble * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
            IAudioTreble * This,
            /* [size_is][in] */ 
            __in_ecount(cChannels)  float aLevelsDB[  ],
            /* [in] */ 
            __in  ULONG cChannels,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioTrebleVtbl;

    interface IAudioTreble
    {
        CONST_VTBL struct IAudioTrebleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioTreble_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioTreble_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioTreble_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioTreble_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioTreble_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 

#define IAudioTreble_GetLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 

#define IAudioTreble_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioTreble_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 

#define IAudioTreble_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioTreble_INTERFACE_DEFINED__ */


#ifndef __IAudioAutoGainControl_INTERFACE_DEFINED__
#define __IAudioAutoGainControl_INTERFACE_DEFINED__

/* interface IAudioAutoGainControl */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioAutoGainControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85401FD4-6DE4-4b9d-9869-2D6753A82F3C")
    IAudioAutoGainControl : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEnabled( 
            /* [out] */ 
            __out  BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ 
            __in  BOOL bEnable,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioAutoGainControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioAutoGainControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioAutoGainControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioAutoGainControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
            IAudioAutoGainControl * This,
            /* [out] */ 
            __out  BOOL *pbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IAudioAutoGainControl * This,
            /* [in] */ 
            __in  BOOL bEnable,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IAudioAutoGainControlVtbl;

    interface IAudioAutoGainControl
    {
        CONST_VTBL struct IAudioAutoGainControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioAutoGainControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioAutoGainControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioAutoGainControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioAutoGainControl_GetEnabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> GetEnabled(This,pbEnabled) ) 

#define IAudioAutoGainControl_SetEnabled(This,bEnable,pguidEventContext)	\
    ( (This)->lpVtbl -> SetEnabled(This,bEnable,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioAutoGainControl_INTERFACE_DEFINED__ */


#ifndef __IAudioPeakMeter_INTERFACE_DEFINED__
#define __IAudioPeakMeter_INTERFACE_DEFINED__

/* interface IAudioPeakMeter */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioPeakMeter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD79923C-0599-45e0-B8B6-C8DF7DB6E796")
    IAudioPeakMeter : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ 
            __out  UINT *pcChannels) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioPeakMeterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioPeakMeter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioPeakMeter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioPeakMeter * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioPeakMeter * This,
            /* [out] */ 
            __out  UINT *pcChannels);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IAudioPeakMeter * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevel);
        
        END_INTERFACE
    } IAudioPeakMeterVtbl;

    interface IAudioPeakMeter
    {
        CONST_VTBL struct IAudioPeakMeterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioPeakMeter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioPeakMeter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioPeakMeter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioPeakMeter_GetChannelCount(This,pcChannels)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 

#define IAudioPeakMeter_GetLevel(This,nChannel,pfLevel)	\
    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioPeakMeter_INTERFACE_DEFINED__ */


#ifndef __IDeviceSpecificProperty_INTERFACE_DEFINED__
#define __IDeviceSpecificProperty_INTERFACE_DEFINED__

/* interface IDeviceSpecificProperty */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IDeviceSpecificProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B22BCBF-2586-4af0-8583-205D391B807C")
    IDeviceSpecificProperty : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ 
            __deref_out  VARTYPE *pVType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ 
            __out  void *pvValue,
            /* [out][in] */ 
            __inout  DWORD *pcbValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ 
            __in  void *pvValue,
            /* [in] */ DWORD cbValue,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Get4BRange( 
            /* [out] */ 
            __deref_out  LONG *plMin,
            /* [out] */ 
            __deref_out  LONG *plMax,
            /* [out] */ 
            __deref_out  LONG *plStepping) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeviceSpecificPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeviceSpecificProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeviceSpecificProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeviceSpecificProperty * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IDeviceSpecificProperty * This,
            /* [out] */ 
            __deref_out  VARTYPE *pVType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IDeviceSpecificProperty * This,
            /* [out] */ 
            __out  void *pvValue,
            /* [out][in] */ 
            __inout  DWORD *pcbValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IDeviceSpecificProperty * This,
            /* [in] */ 
            __in  void *pvValue,
            /* [in] */ DWORD cbValue,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Get4BRange )( 
            IDeviceSpecificProperty * This,
            /* [out] */ 
            __deref_out  LONG *plMin,
            /* [out] */ 
            __deref_out  LONG *plMax,
            /* [out] */ 
            __deref_out  LONG *plStepping);
        
        END_INTERFACE
    } IDeviceSpecificPropertyVtbl;

    interface IDeviceSpecificProperty
    {
        CONST_VTBL struct IDeviceSpecificPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeviceSpecificProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeviceSpecificProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeviceSpecificProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeviceSpecificProperty_GetType(This,pVType)	\
    ( (This)->lpVtbl -> GetType(This,pVType) ) 

#define IDeviceSpecificProperty_GetValue(This,pvValue,pcbValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue,pcbValue) ) 

#define IDeviceSpecificProperty_SetValue(This,pvValue,cbValue,pguidEventContext)	\
    ( (This)->lpVtbl -> SetValue(This,pvValue,cbValue,pguidEventContext) ) 

#define IDeviceSpecificProperty_Get4BRange(This,plMin,plMax,plStepping)	\
    ( (This)->lpVtbl -> Get4BRange(This,plMin,plMax,plStepping) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeviceSpecificProperty_INTERFACE_DEFINED__ */


#ifndef __IKsFormatSupport_INTERFACE_DEFINED__
#define __IKsFormatSupport_INTERFACE_DEFINED__

/* interface IKsFormatSupport */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IKsFormatSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3CB4A69D-BB6F-4D2B-95B7-452D2C155DB5")
    IKsFormatSupport : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsFormatSupported( 
            /* [size_is][in] */ PKSDATAFORMAT pKsFormat,
            /* [in] */ 
            __in  DWORD cbFormat,
            /* [out] */ 
            __out  BOOL *pbSupported) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevicePreferredFormat( 
            /* [out] */ PKSDATAFORMAT *ppKsFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsFormatSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsFormatSupport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsFormatSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsFormatSupport * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            IKsFormatSupport * This,
            /* [size_is][in] */ PKSDATAFORMAT pKsFormat,
            /* [in] */ 
            __in  DWORD cbFormat,
            /* [out] */ 
            __out  BOOL *pbSupported);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevicePreferredFormat )( 
            IKsFormatSupport * This,
            /* [out] */ PKSDATAFORMAT *ppKsFormat);
        
        END_INTERFACE
    } IKsFormatSupportVtbl;

    interface IKsFormatSupport
    {
        CONST_VTBL struct IKsFormatSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsFormatSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsFormatSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsFormatSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsFormatSupport_IsFormatSupported(This,pKsFormat,cbFormat,pbSupported)	\
    ( (This)->lpVtbl -> IsFormatSupported(This,pKsFormat,cbFormat,pbSupported) ) 

#define IKsFormatSupport_GetDevicePreferredFormat(This,ppKsFormat)	\
    ( (This)->lpVtbl -> GetDevicePreferredFormat(This,ppKsFormat) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsFormatSupport_INTERFACE_DEFINED__ */


#ifndef __IKsJackDescription_INTERFACE_DEFINED__
#define __IKsJackDescription_INTERFACE_DEFINED__

/* interface IKsJackDescription */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IKsJackDescription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4509F757-2D46-4637-8E62-CE7DB944F57B")
    IKsJackDescription : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJackCount( 
            /* [out] */ 
            __out  UINT *pcJacks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJackDescription( 
            /* [in] */ UINT nJack,
            /* [out] */ 
            __out  KSJACK_DESCRIPTION *pDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsJackDescriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsJackDescription * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsJackDescription * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsJackDescription * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJackCount )( 
            IKsJackDescription * This,
            /* [out] */ 
            __out  UINT *pcJacks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJackDescription )( 
            IKsJackDescription * This,
            /* [in] */ UINT nJack,
            /* [out] */ 
            __out  KSJACK_DESCRIPTION *pDescription);
        
        END_INTERFACE
    } IKsJackDescriptionVtbl;

    interface IKsJackDescription
    {
        CONST_VTBL struct IKsJackDescriptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsJackDescription_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsJackDescription_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsJackDescription_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsJackDescription_GetJackCount(This,pcJacks)	\
    ( (This)->lpVtbl -> GetJackCount(This,pcJacks) ) 

#define IKsJackDescription_GetJackDescription(This,nJack,pDescription)	\
    ( (This)->lpVtbl -> GetJackDescription(This,nJack,pDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsJackDescription_INTERFACE_DEFINED__ */


#ifndef __IPartsList_INTERFACE_DEFINED__
#define __IPartsList_INTERFACE_DEFINED__

/* interface IPartsList */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IPartsList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DAA848C-5EB0-45CC-AEA5-998A2CDA1FFB")
    IPartsList : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ 
            __out  UINT *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPart( 
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IPart **ppPart) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartsListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartsList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartsList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartsList * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPartsList * This,
            /* [out] */ 
            __out  UINT *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPart )( 
            IPartsList * This,
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IPart **ppPart);
        
        END_INTERFACE
    } IPartsListVtbl;

    interface IPartsList
    {
        CONST_VTBL struct IPartsListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartsList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartsList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartsList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartsList_GetCount(This,pCount)	\
    ( (This)->lpVtbl -> GetCount(This,pCount) ) 

#define IPartsList_GetPart(This,nIndex,ppPart)	\
    ( (This)->lpVtbl -> GetPart(This,nIndex,ppPart) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartsList_INTERFACE_DEFINED__ */


#ifndef __IPart_INTERFACE_DEFINED__
#define __IPart_INTERFACE_DEFINED__

/* interface IPart */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IPart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE2DE0E4-5BCA-4F2D-AA46-5D13F8FDB3A9")
    IPart : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLocalId( 
            /* [out] */ 
            __out  UINT *pnId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGlobalId( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrGlobalId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartType( 
            /* [out] */ 
            __out  PartType *pPartType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubType( 
            /* [out] */ GUID *pSubType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetControlInterfaceCount( 
            /* [out] */ 
            __out  UINT *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetControlInterface( 
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IControlInterface **ppInterfaceDesc) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumPartsIncoming( 
            /* [out] */ 
            __out  IPartsList **ppParts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumPartsOutgoing( 
            /* [out] */ 
            __out  IPartsList **ppParts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTopologyObject( 
            /* [out] */ 
            __out  IDeviceTopology **ppTopology) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ 
            __in  DWORD dwClsContext,
            /* [in] */ 
            __in  REFIID refiid,
            /* [iid_is][out] */ 
            __out_opt  void **ppvObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterControlChangeCallback( 
            /* [in] */ 
            __in  REFGUID riid,
            /* [in] */ 
            __in  IControlChangeNotify *pNotify) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterControlChangeCallback( 
            /* [in] */ 
            __in  IControlChangeNotify *pNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPart * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPart * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPart * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IPart * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLocalId )( 
            IPart * This,
            /* [out] */ 
            __out  UINT *pnId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGlobalId )( 
            IPart * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrGlobalId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartType )( 
            IPart * This,
            /* [out] */ 
            __out  PartType *pPartType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubType )( 
            IPart * This,
            /* [out] */ GUID *pSubType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetControlInterfaceCount )( 
            IPart * This,
            /* [out] */ 
            __out  UINT *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetControlInterface )( 
            IPart * This,
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IControlInterface **ppInterfaceDesc);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumPartsIncoming )( 
            IPart * This,
            /* [out] */ 
            __out  IPartsList **ppParts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumPartsOutgoing )( 
            IPart * This,
            /* [out] */ 
            __out  IPartsList **ppParts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTopologyObject )( 
            IPart * This,
            /* [out] */ 
            __out  IDeviceTopology **ppTopology);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IPart * This,
            /* [in] */ 
            __in  DWORD dwClsContext,
            /* [in] */ 
            __in  REFIID refiid,
            /* [iid_is][out] */ 
            __out_opt  void **ppvObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterControlChangeCallback )( 
            IPart * This,
            /* [in] */ 
            __in  REFGUID riid,
            /* [in] */ 
            __in  IControlChangeNotify *pNotify);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterControlChangeCallback )( 
            IPart * This,
            /* [in] */ 
            __in  IControlChangeNotify *pNotify);
        
        END_INTERFACE
    } IPartVtbl;

    interface IPart
    {
        CONST_VTBL struct IPartVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPart_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPart_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPart_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPart_GetName(This,ppwstrName)	\
    ( (This)->lpVtbl -> GetName(This,ppwstrName) ) 

#define IPart_GetLocalId(This,pnId)	\
    ( (This)->lpVtbl -> GetLocalId(This,pnId) ) 

#define IPart_GetGlobalId(This,ppwstrGlobalId)	\
    ( (This)->lpVtbl -> GetGlobalId(This,ppwstrGlobalId) ) 

#define IPart_GetPartType(This,pPartType)	\
    ( (This)->lpVtbl -> GetPartType(This,pPartType) ) 

#define IPart_GetSubType(This,pSubType)	\
    ( (This)->lpVtbl -> GetSubType(This,pSubType) ) 

#define IPart_GetControlInterfaceCount(This,pCount)	\
    ( (This)->lpVtbl -> GetControlInterfaceCount(This,pCount) ) 

#define IPart_GetControlInterface(This,nIndex,ppInterfaceDesc)	\
    ( (This)->lpVtbl -> GetControlInterface(This,nIndex,ppInterfaceDesc) ) 

#define IPart_EnumPartsIncoming(This,ppParts)	\
    ( (This)->lpVtbl -> EnumPartsIncoming(This,ppParts) ) 

#define IPart_EnumPartsOutgoing(This,ppParts)	\
    ( (This)->lpVtbl -> EnumPartsOutgoing(This,ppParts) ) 

#define IPart_GetTopologyObject(This,ppTopology)	\
    ( (This)->lpVtbl -> GetTopologyObject(This,ppTopology) ) 

#define IPart_Activate(This,dwClsContext,refiid,ppvObject)	\
    ( (This)->lpVtbl -> Activate(This,dwClsContext,refiid,ppvObject) ) 

#define IPart_RegisterControlChangeCallback(This,riid,pNotify)	\
    ( (This)->lpVtbl -> RegisterControlChangeCallback(This,riid,pNotify) ) 

#define IPart_UnregisterControlChangeCallback(This,pNotify)	\
    ( (This)->lpVtbl -> UnregisterControlChangeCallback(This,pNotify) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPart_INTERFACE_DEFINED__ */


#ifndef __IConnector_INTERFACE_DEFINED__
#define __IConnector_INTERFACE_DEFINED__

/* interface IConnector */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c2c4058-23f5-41de-877a-df3af236a09e")
    IConnector : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ 
            __out  ConnectorType *pType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataFlow( 
            /* [out] */ 
            __out  DataFlow *pFlow) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectTo( 
            /* [in] */ 
            __in  IConnector *pConnectTo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsConnected( 
            /* [out] */ 
            __out  BOOL *pbConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectedTo( 
            /* [out] */ 
            __out  IConnector **ppConTo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectorIdConnectedTo( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrConnectorId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceIdConnectedTo( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrDeviceId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConnector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConnector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConnector * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IConnector * This,
            /* [out] */ 
            __out  ConnectorType *pType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataFlow )( 
            IConnector * This,
            /* [out] */ 
            __out  DataFlow *pFlow);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectTo )( 
            IConnector * This,
            /* [in] */ 
            __in  IConnector *pConnectTo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IConnector * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsConnected )( 
            IConnector * This,
            /* [out] */ 
            __out  BOOL *pbConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectedTo )( 
            IConnector * This,
            /* [out] */ 
            __out  IConnector **ppConTo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectorIdConnectedTo )( 
            IConnector * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrConnectorId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceIdConnectedTo )( 
            IConnector * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrDeviceId);
        
        END_INTERFACE
    } IConnectorVtbl;

    interface IConnector
    {
        CONST_VTBL struct IConnectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConnector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConnector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConnector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConnector_GetType(This,pType)	\
    ( (This)->lpVtbl -> GetType(This,pType) ) 

#define IConnector_GetDataFlow(This,pFlow)	\
    ( (This)->lpVtbl -> GetDataFlow(This,pFlow) ) 

#define IConnector_ConnectTo(This,pConnectTo)	\
    ( (This)->lpVtbl -> ConnectTo(This,pConnectTo) ) 

#define IConnector_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IConnector_IsConnected(This,pbConnected)	\
    ( (This)->lpVtbl -> IsConnected(This,pbConnected) ) 

#define IConnector_GetConnectedTo(This,ppConTo)	\
    ( (This)->lpVtbl -> GetConnectedTo(This,ppConTo) ) 

#define IConnector_GetConnectorIdConnectedTo(This,ppwstrConnectorId)	\
    ( (This)->lpVtbl -> GetConnectorIdConnectedTo(This,ppwstrConnectorId) ) 

#define IConnector_GetDeviceIdConnectedTo(This,ppwstrDeviceId)	\
    ( (This)->lpVtbl -> GetDeviceIdConnectedTo(This,ppwstrDeviceId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConnector_INTERFACE_DEFINED__ */


#ifndef __ISubunit_INTERFACE_DEFINED__
#define __ISubunit_INTERFACE_DEFINED__

/* interface ISubunit */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_ISubunit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82149A85-DBA6-4487-86BB-EA8F7FEFCC71")
    ISubunit : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ISubunitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISubunit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISubunit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISubunit * This);
        
        END_INTERFACE
    } ISubunitVtbl;

    interface ISubunit
    {
        CONST_VTBL struct ISubunitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISubunit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISubunit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISubunit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISubunit_INTERFACE_DEFINED__ */


#ifndef __IControlInterface_INTERFACE_DEFINED__
#define __IControlInterface_INTERFACE_DEFINED__

/* interface IControlInterface */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IControlInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45d37c3f-5140-444a-ae24-400789f3cbf3")
    IControlInterface : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetIID( 
            /* [out] */ 
            __out  GUID *pIID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IControlInterface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IControlInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IControlInterface * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IControlInterface * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetIID )( 
            IControlInterface * This,
            /* [out] */ 
            __out  GUID *pIID);
        
        END_INTERFACE
    } IControlInterfaceVtbl;

    interface IControlInterface
    {
        CONST_VTBL struct IControlInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlInterface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IControlInterface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IControlInterface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IControlInterface_GetName(This,ppwstrName)	\
    ( (This)->lpVtbl -> GetName(This,ppwstrName) ) 

#define IControlInterface_GetIID(This,pIID)	\
    ( (This)->lpVtbl -> GetIID(This,pIID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IControlInterface_INTERFACE_DEFINED__ */


#ifndef __IControlChangeNotify_INTERFACE_DEFINED__
#define __IControlChangeNotify_INTERFACE_DEFINED__

/* interface IControlChangeNotify */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IControlChangeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A09513ED-C709-4d21-BD7B-5F34C47F3947")
    IControlChangeNotify : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnNotify( 
            /* [in] */ 
            __in  DWORD dwSenderProcessId,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlChangeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IControlChangeNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IControlChangeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IControlChangeNotify * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
            IControlChangeNotify * This,
            /* [in] */ 
            __in  DWORD dwSenderProcessId,
            /* [unique][in] */ 
            __in_opt  LPCGUID pguidEventContext);
        
        END_INTERFACE
    } IControlChangeNotifyVtbl;

    interface IControlChangeNotify
    {
        CONST_VTBL struct IControlChangeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlChangeNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IControlChangeNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IControlChangeNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IControlChangeNotify_OnNotify(This,dwSenderProcessId,pguidEventContext)	\
    ( (This)->lpVtbl -> OnNotify(This,dwSenderProcessId,pguidEventContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IControlChangeNotify_INTERFACE_DEFINED__ */


#ifndef __IDeviceTopology_INTERFACE_DEFINED__
#define __IDeviceTopology_INTERFACE_DEFINED__

/* interface IDeviceTopology */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IDeviceTopology;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A07407E-6497-4A18-9787-32F79BD0D98F")
    IDeviceTopology : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectorCount( 
            /* [out] */ 
            __out  UINT *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnector( 
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IConnector **ppConnector) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubunitCount( 
            /* [out] */ 
            __out  UINT *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubunit( 
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __deref_out  ISubunit **ppSubunit) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartById( 
            /* [in] */ 
            __in  UINT nId,
            /* [out] */ 
            __deref_out  IPart **ppPart) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceId( 
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrDeviceId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSignalPath( 
            /* [in] */ 
            __in  IPart *pIPartFrom,
            /* [in] */ 
            __in  IPart *pIPartTo,
            /* [in] */ 
            __in  BOOL bRejectMixedPaths,
            /* [out] */ 
            __deref_out  IPartsList **ppParts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeviceTopologyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeviceTopology * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeviceTopology * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeviceTopology * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectorCount )( 
            IDeviceTopology * This,
            /* [out] */ 
            __out  UINT *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnector )( 
            IDeviceTopology * This,
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __out  IConnector **ppConnector);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubunitCount )( 
            IDeviceTopology * This,
            /* [out] */ 
            __out  UINT *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubunit )( 
            IDeviceTopology * This,
            /* [in] */ 
            __in  UINT nIndex,
            /* [out] */ 
            __deref_out  ISubunit **ppSubunit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartById )( 
            IDeviceTopology * This,
            /* [in] */ 
            __in  UINT nId,
            /* [out] */ 
            __deref_out  IPart **ppPart);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceId )( 
            IDeviceTopology * This,
            /* [out] */ 
            __deref_out  LPWSTR *ppwstrDeviceId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSignalPath )( 
            IDeviceTopology * This,
            /* [in] */ 
            __in  IPart *pIPartFrom,
            /* [in] */ 
            __in  IPart *pIPartTo,
            /* [in] */ 
            __in  BOOL bRejectMixedPaths,
            /* [out] */ 
            __deref_out  IPartsList **ppParts);
        
        END_INTERFACE
    } IDeviceTopologyVtbl;

    interface IDeviceTopology
    {
        CONST_VTBL struct IDeviceTopologyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeviceTopology_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeviceTopology_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeviceTopology_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeviceTopology_GetConnectorCount(This,pCount)	\
    ( (This)->lpVtbl -> GetConnectorCount(This,pCount) ) 

#define IDeviceTopology_GetConnector(This,nIndex,ppConnector)	\
    ( (This)->lpVtbl -> GetConnector(This,nIndex,ppConnector) ) 

#define IDeviceTopology_GetSubunitCount(This,pCount)	\
    ( (This)->lpVtbl -> GetSubunitCount(This,pCount) ) 

#define IDeviceTopology_GetSubunit(This,nIndex,ppSubunit)	\
    ( (This)->lpVtbl -> GetSubunit(This,nIndex,ppSubunit) ) 

#define IDeviceTopology_GetPartById(This,nId,ppPart)	\
    ( (This)->lpVtbl -> GetPartById(This,nId,ppPart) ) 

#define IDeviceTopology_GetDeviceId(This,ppwstrDeviceId)	\
    ( (This)->lpVtbl -> GetDeviceId(This,ppwstrDeviceId) ) 

#define IDeviceTopology_GetSignalPath(This,pIPartFrom,pIPartTo,bRejectMixedPaths,ppParts)	\
    ( (This)->lpVtbl -> GetSignalPath(This,pIPartFrom,pIPartTo,bRejectMixedPaths,ppParts) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeviceTopology_INTERFACE_DEFINED__ */



#ifndef __DevTopologyLib_LIBRARY_DEFINED__
#define __DevTopologyLib_LIBRARY_DEFINED__

/* library DevTopologyLib */
/* [helpstring][version][uuid] */ 
















EXTERN_C const IID LIBID_DevTopologyLib;

EXTERN_C const CLSID CLSID_DeviceTopology;

#ifdef __cplusplus

class DECLSPEC_UUID("1DF639D0-5EC1-47AA-9379-828DC1AA8C59")
DeviceTopology;
#endif
#endif /* __DevTopologyLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ddraw.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw.h
 *  Content:    DirectDraw include file
 *
 ***************************************************************************/

#ifndef __DDRAW_INCLUDED__
#define __DDRAW_INCLUDED__

//Disable the nameless union warning when building internally
#undef ENABLE_NAMELESS_UNION_PRAGMA
#ifdef DIRECTX_REDIST
#define ENABLE_NAMELESS_UNION_PRAGMA
#endif

#ifdef ENABLE_NAMELESS_UNION_PRAGMA
#pragma warning(disable:4201)
#endif

/*
 * If you wish an application built against the newest version of DirectDraw
 * to run against an older DirectDraw run time then define DIRECTDRAW_VERSION
 * to be the earlies version of DirectDraw you wish to run against. For,
 * example if you wish an application to run against a DX 3 runtime define
 * DIRECTDRAW_VERSION to be 0x0300.
 */
#ifndef   DIRECTDRAW_VERSION
#define   DIRECTDRAW_VERSION 0x0700
#endif /* DIRECTDRAW_VERSION */

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown            void
#if !defined( NT_BUILD_ENVIRONMENT ) && !defined(WINNT)
        #define CO_E_NOTINITIALIZED 0x800401F0L
#endif
#endif

#define _FACDD  0x876
#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )

#ifdef __cplusplus
extern "C" {
#endif

//
// For compilers that don't support nameless unions, do a
//
// #define NONAMELESSUNION
//
// before #include <ddraw.h>
//
#ifndef DUMMYUNIONNAMEN
#if defined(__cplusplus) || !defined(NONAMELESSUNION)
#define DUMMYUNIONNAMEN(n)
#else
#define DUMMYUNIONNAMEN(n)      u##n
#endif
#endif

#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif //defined(MAKEFOURCC)

/*
 * FOURCC codes for DX compressed-texture pixel formats
 */
#define FOURCC_DXT1  (MAKEFOURCC('D','X','T','1'))
#define FOURCC_DXT2  (MAKEFOURCC('D','X','T','2'))
#define FOURCC_DXT3  (MAKEFOURCC('D','X','T','3'))
#define FOURCC_DXT4  (MAKEFOURCC('D','X','T','4'))
#define FOURCC_DXT5  (MAKEFOURCC('D','X','T','5'))

/*
 * GUIDS used by DirectDraw objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )

DEFINE_GUID( CLSID_DirectDraw,                  0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35 );
DEFINE_GUID( CLSID_DirectDraw7,                 0x3c305196,0x50db,0x11d3,0x9c,0xfe,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( CLSID_DirectDrawClipper,           0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw,                   0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDraw7,                  0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b );
DEFINE_GUID( IID_IDirectDrawSurface,            0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,           0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );
DEFINE_GUID( IID_IDirectDrawSurface7,           0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b );
DEFINE_GUID( IID_IDirectDrawPalette,            0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,            0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl,       0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDirectDraw              FAR *LPDIRECTDRAW;
typedef struct IDirectDraw2             FAR *LPDIRECTDRAW2;
typedef struct IDirectDraw4             FAR *LPDIRECTDRAW4;
typedef struct IDirectDraw7             FAR *LPDIRECTDRAW7;
typedef struct IDirectDrawSurface       FAR *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawSurface2      FAR *LPDIRECTDRAWSURFACE2;
typedef struct IDirectDrawSurface3      FAR *LPDIRECTDRAWSURFACE3;
typedef struct IDirectDrawSurface4      FAR *LPDIRECTDRAWSURFACE4;
typedef struct IDirectDrawSurface7      FAR *LPDIRECTDRAWSURFACE7;
typedef struct IDirectDrawPalette               FAR *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper               FAR *LPDIRECTDRAWCLIPPER;
typedef struct IDirectDrawColorControl          FAR *LPDIRECTDRAWCOLORCONTROL;
typedef struct IDirectDrawGammaControl          FAR *LPDIRECTDRAWGAMMACONTROL;

typedef struct _DDFXROP                 FAR *LPDDFXROP;
typedef struct _DDSURFACEDESC           FAR *LPDDSURFACEDESC;
typedef struct _DDSURFACEDESC2          FAR *LPDDSURFACEDESC2;
typedef struct _DDCOLORCONTROL          FAR *LPDDCOLORCONTROL;

/*
 * API's
 */
#if (defined (WIN32) || defined( _WIN32 ) ) && !defined( _NO_COM )
//#if defined( _WIN32 ) && !defined( _NO_ENUM )
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKA)(GUID FAR *, LPSTR, LPSTR, LPVOID);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID);
    extern HRESULT WINAPI DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
    extern HRESULT WINAPI DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
    /*
     * Protect against old SDKs
     */
    #if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
        #define HMONITOR_DECLARED
        DECLARE_HANDLE(HMONITOR);
    #endif
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXA)(GUID FAR *, LPSTR, LPSTR, LPVOID, HMONITOR);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID, HMONITOR);
    extern HRESULT WINAPI DirectDrawEnumerateExW( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);
    extern HRESULT WINAPI DirectDrawEnumerateExA( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXA)( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXW)( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);

    #ifdef UNICODE
        typedef LPDDENUMCALLBACKW           LPDDENUMCALLBACK;
        #define DirectDrawEnumerate         DirectDrawEnumerateW
        typedef LPDDENUMCALLBACKEXW         LPDDENUMCALLBACKEX;
        typedef LPDIRECTDRAWENUMERATEEXW        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx       DirectDrawEnumerateExW
    #else
        typedef LPDDENUMCALLBACKA           LPDDENUMCALLBACK;
        #define DirectDrawEnumerate         DirectDrawEnumerateA
        typedef LPDDENUMCALLBACKEXA         LPDDENUMCALLBACKEX;
        typedef LPDIRECTDRAWENUMERATEEXA        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx       DirectDrawEnumerateExA
    #endif
    extern HRESULT WINAPI DirectDrawCreate( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateEx( GUID FAR * lpGuid, LPVOID  *lplpDD, REFIID  iid,IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
#endif
/*
 * Flags for DirectDrawEnumerateEx
 * DirectDrawEnumerateEx supercedes DirectDrawEnumerate. You must use GetProcAddress to
 * obtain a function pointer (of type LPDIRECTDRAWENUMERATEEX) to DirectDrawEnumerateEx.
 * By default, only the primary display device is enumerated.
 * DirectDrawEnumerate is equivalent to DirectDrawEnumerate(,,DDENUM_NONDISPLAYDEVICES)
 */

/*
 * This flag causes enumeration of any GDI display devices which are part of
 * the Windows Desktop
 */
#define DDENUM_ATTACHEDSECONDARYDEVICES     0x00000001L

/*
 * This flag causes enumeration of any GDI display devices which are not
 * part of the Windows Desktop
 */
#define DDENUM_DETACHEDSECONDARYDEVICES     0x00000002L

/*
 * This flag causes enumeration of non-display devices
 */
#define DDENUM_NONDISPLAYDEVICES            0x00000004L


#define REGSTR_KEY_DDHW_DESCRIPTION     "Description"
#define REGSTR_KEY_DDHW_DRIVERNAME      "DriverName"
#define REGSTR_PATH_DDHW                "Hardware\\DirectDrawDrivers"

#define DDCREATE_HARDWAREONLY           0x00000001l
#define DDCREATE_EMULATIONONLY          0x00000002l

#if defined(WINNT) || !defined(WIN32)
#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef __success(return >= 0) long HRESULT;
#endif // !_HRESULT_DEFINED
#endif

//#ifndef WINNT
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK2)(LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK2)(LPDIRECTDRAWSURFACE4, LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK7)(LPDIRECTDRAWSURFACE7, LPDDSURFACEDESC2, LPVOID);
//#endif

/*
 * Generic pixel format with 8-bit RGB and alpha components
 */
typedef struct _DDARGB
{
    BYTE blue;
    BYTE green;
    BYTE red;
    BYTE alpha;
} DDARGB;

typedef DDARGB FAR *LPDDARGB;

/*
 * This version of the structure remains for backwards source compatibility.
 * The DDARGB structure is the one that should be used for all DirectDraw APIs.
 */
typedef struct _DDRGBA
{
    BYTE red;
    BYTE green;
    BYTE blue;
    BYTE alpha;
} DDRGBA;

typedef DDRGBA FAR *LPDDRGBA;


/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD       dwColorSpaceLowValue;   // low boundary of color space that is to
                                        // be treated as Color Key, inclusive
    DWORD       dwColorSpaceHighValue;  // high boundary of color space that is
                                        // to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY FAR* LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwDDFX;                         // FX operations
    DWORD       dwROP;                          // Win32 raster operations
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw
    DWORD       dwRotationAngle;                // Rotation angle for blt
    DWORD       dwZBufferOpCode;                // ZBuffer compares
    DWORD       dwZBufferLow;                   // Low limit of Z buffer
    DWORD       dwZBufferHigh;                  // High limit of Z buffer
    DWORD       dwZBufferBaseDest;              // Destination base value
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination
    union
    {
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
        LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source
    union
    {
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
        LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src
    } DUMMYUNIONNAMEN(2);
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(3);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwFillColor;                    // color in RGB or Palettized
        DWORD   dwFillDepth;                    // depth value for z-buffer
        DWORD   dwFillPixel;                    // pixel value for RGBA or RGBZ
        LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern
    } DUMMYUNIONNAMEN(5);
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override
} DDBLTFX;

typedef DDBLTFX FAR* LPDDBLTFX;



/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS FAR* LPDDSCAPS;


/*
 * DDOSCAPS
 */
typedef struct _DDOSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDOSCAPS;

typedef DDOSCAPS FAR* LPDDOSCAPS;

/*
 * This structure is used internally by DirectDraw.
 */
typedef struct _DDSCAPSEX
{
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    union
    {
        DWORD       dwCaps4;
        DWORD       dwVolumeDepth;
    } DUMMYUNIONNAMEN(1);
} DDSCAPSEX, FAR * LPDDSCAPSEX;

/*
 * DDSCAPS2
 */
typedef struct _DDSCAPS2
{
    DWORD       dwCaps;         // capabilities of surface wanted
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    union
    {
        DWORD       dwCaps4;
        DWORD       dwVolumeDepth;
    } DUMMYUNIONNAMEN(1);
} DDSCAPS2;

typedef DDSCAPS2 FAR* LPDDSCAPS2;

/*
 * DDCAPS
 */
#define DD_ROP_SPACE            (256/32)        // space required to store ROP array
/*
 * NOTE: Our choosen structure number scheme is to append a single digit to
 * the end of the structure giving the version that structure is associated
 * with.
 */

/*
 * This structure represents the DDCAPS structure released in DirectDraw 1.0.  It is used internally
 * by DirectDraw to interpret caps passed into ddraw by drivers written prior to the release of DirectDraw 2.0.
 * New applications should use the DDCAPS structure defined below.
 */
typedef struct _DDCAPS_DX1
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMinHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
} DDCAPS_DX1;

typedef DDCAPS_DX1 FAR* LPDDCAPS_DX1;

/*
 * This structure is the DDCAPS structure as it was in version 2 and 3 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX3
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwReserved4;            // reserved
    DWORD       dwReserved5;            // reserved
    DWORD       dwReserved6;            // reserved
} DDCAPS_DX3;
typedef DDCAPS_DX3 FAR* LPDDCAPS_DX3;

/*
 * This structure is the DDCAPS structure as it was in version 5 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX5
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsCaps;                // DDSCAPS structure has all the general capabilities
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
// Members added for DX5:
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DDCAPS_DX5;
typedef DDCAPS_DX5 FAR* LPDDCAPS_DX5;

typedef struct _DDCAPS_DX6
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha caps
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
} DDCAPS_DX6;
typedef DDCAPS_DX6 FAR* LPDDCAPS_DX6;

typedef struct _DDCAPS_DX7
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
} DDCAPS_DX7;
typedef DDCAPS_DX7 FAR* LPDDCAPS_DX7;


#if DIRECTDRAW_VERSION <= 0x300
    typedef DDCAPS_DX3 DDCAPS;
#elif DIRECTDRAW_VERSION <= 0x500
    typedef DDCAPS_DX5 DDCAPS;
#elif DIRECTDRAW_VERSION <= 0x600
    typedef DDCAPS_DX6 DDCAPS;
#else
    typedef DDCAPS_DX7 DDCAPS;
#endif

typedef DDCAPS FAR* LPDDCAPS;



/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
        DWORD   dwRGBBitCount;          // how many bits per pixel
        DWORD   dwYUVBitCount;          // how many bits per pixel
        DWORD   dwZBufferBitDepth;      // how many total bits/pixel in z buffer (including any stencil bits)
        DWORD   dwAlphaBitDepth;        // how many bits for alpha channels
        DWORD   dwLuminanceBitCount;    // how many bits per pixel
        DWORD   dwBumpBitCount;         // how many bits per "buxel", total
        DWORD   dwPrivateFormatBitCount;// Bits per pixel of private driver formats. Only valid in texture
                                        // format list and if DDPF_D3DFORMAT is set
    } DUMMYUNIONNAMEN(1);
    union
    {
        DWORD   dwRBitMask;             // mask for red bit
        DWORD   dwYBitMask;             // mask for Y bits
        DWORD   dwStencilBitDepth;      // how many stencil bits (note: dwZBufferBitDepth-dwStencilBitDepth is total Z-only bits)
        DWORD   dwLuminanceBitMask;     // mask for luminance bits
        DWORD   dwBumpDuBitMask;        // mask for bump map U delta bits
        DWORD   dwOperations;           // DDPF_D3DFORMAT Operations
    } DUMMYUNIONNAMEN(2);
    union
    {
        DWORD   dwGBitMask;             // mask for green bits
        DWORD   dwUBitMask;             // mask for U bits
        DWORD   dwZBitMask;             // mask for Z bits
        DWORD   dwBumpDvBitMask;        // mask for bump map V delta bits
        struct
        {
            WORD    wFlipMSTypes;       // Multisample methods supported via flip for this D3DFORMAT
            WORD    wBltMSTypes;        // Multisample methods supported via blt for this D3DFORMAT
        } MultiSampleCaps;

    } DUMMYUNIONNAMEN(3);
    union
    {
        DWORD   dwBBitMask;             // mask for blue bits
        DWORD   dwVBitMask;             // mask for V bits
        DWORD   dwStencilBitMask;       // mask for stencil bits
        DWORD   dwBumpLuminanceBitMask; // mask for luminance in bump map
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
        DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
        DWORD   dwLuminanceAlphaBitMask;// mask for alpha channel
        DWORD   dwRGBZBitMask;          // mask for Z channel
        DWORD   dwYUVZBitMask;          // mask for Z channel
    } DUMMYUNIONNAMEN(5);
} DDPIXELFORMAT;

typedef DDPIXELFORMAT FAR* LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Constant to use as alpha for edge blend
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as alpha channel for dest
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as alpha channel for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as alpha channel for src
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as alpha channel for src
    } DUMMYUNIONNAMEN(2);
    DDCOLORKEY  dckDestColorkey;                // DestColorkey override
    DDCOLORKEY  dckSrcColorkey;                 // DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD       dwFlags;                        // flags
} DDOVERLAYFX;

typedef DDOVERLAYFX FAR *LPDDOVERLAYFX;


/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT              lprDest;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPRECT              lprSrc;
    DWORD               dwFlags;
    LPDDBLTFX           lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH FAR * LPDDBLTBATCH;


/*
 * DDGAMMARAMP
 */
typedef struct _DDGAMMARAMP
{
    WORD                red[256];
    WORD                green[256];
    WORD                blue[256];
} DDGAMMARAMP;
typedef DDGAMMARAMP FAR * LPDDGAMMARAMP;

/*
 *  This is the structure within which DirectDraw returns data about the current graphics driver and chipset
 */

#define MAX_DDDEVICEID_STRING           512

typedef struct tagDDDEVICEIDENTIFIER
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[MAX_DDDEVICEID_STRING];
    char    szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
#ifdef _WIN32
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
#else
    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD   dwDriverVersionHighPart;
#endif


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;
} DDDEVICEIDENTIFIER, * LPDDDEVICEIDENTIFIER;

typedef struct tagDDDEVICEIDENTIFIER2
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[MAX_DDDEVICEID_STRING];
    char    szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
#ifdef _WIN32
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
#else
    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD   dwDriverVersionHighPart;
#endif


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;

    /*
     * This element is used to determine the Windows Hardware Quality Lab (WHQL)
     * certification level for this driver/device pair.
     */
    DWORD   dwWHQLLevel;

} DDDEVICEIDENTIFIER2, * LPDDDEVICEIDENTIFIER2;

/*
 * Flags for the IDirectDraw4::GetDeviceIdentifier method
 */

/*
 * This flag causes GetDeviceIdentifier to return information about the host (typically 2D) adapter in a system equipped
 * with a stacked secondary 3D adapter. Such an adapter appears to the application as if it were part of the
 * host adapter, but is typically physcially located on a separate card. The stacked secondary's information is
 * returned when GetDeviceIdentifier's dwFlags field is zero, since this most accurately reflects the qualities
 * of the DirectDraw object involved.
 */
#define DDGDI_GETHOSTIDENTIFIER         0x00000001L

/*
 * Macros for interpretting DDEVICEIDENTIFIER2.dwWHQLLevel
 */
#define GET_WHQL_YEAR( dwWHQLLevel ) \
    ( (dwWHQLLevel) / 0x10000 )
#define GET_WHQL_MONTH( dwWHQLLevel ) \
    ( ( (dwWHQLLevel) / 0x100 ) & 0x00ff )
#define GET_WHQL_DAY( dwWHQLLevel ) \
    ( (dwWHQLLevel) & 0xff )


/*
 * callbacks
 */
typedef DWORD   (FAR PASCAL *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
#ifdef STREAMING
typedef DWORD   (FAR PASCAL *LPSURFACESTREAMINGCALLBACK)(DWORD);
#endif


/*
 * INTERACES FOLLOW:
 *      IDirectDraw
 *      IDirectDrawClipper
 *      IDirectDrawPalette
 *      IDirectDrawSurface
 */

/*
 * IDirectDraw
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw
DECLARE_INTERFACE_( IDirectDraw, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->lpVtbl->SetDisplayMode(p, a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#else
#define IDirectDraw_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw_AddRef(p)                       (p)->AddRef()
#define IDirectDraw_Release(p)                      (p)->Release()
#define IDirectDraw_Compact(p)                      (p)->Compact()
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->SetDisplayMode(a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw2
DECLARE_INTERFACE_( IDirectDraw2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw2_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw2_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw2_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw2_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw2_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#else
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw2_AddRef(p)                       (p)->AddRef()
#define IDirectDraw2_Release(p)                      (p)->Release()
#define IDirectDraw2_Compact(p)                      (p)->Compact()
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw2_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw2_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw4
DECLARE_INTERFACE_( IDirectDraw4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE4 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK2 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER, DWORD ) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw4_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw4_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw4_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw4_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw4_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
#else
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw4_AddRef(p)                       (p)->AddRef()
#define IDirectDraw4_Release(p)                      (p)->Release()
#define IDirectDraw4_Compact(p)                      (p)->Compact()
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw4_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw4_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw7
DECLARE_INTERFACE_( IDirectDraw7, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE7 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE7, LPDIRECTDRAWSURFACE7 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK7 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE7 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER2, DWORD ) PURE;
    STDMETHOD(StartModeTest)(THIS_ LPSIZE, DWORD, DWORD ) PURE;
    STDMETHOD(EvaluateMode)(THIS_ DWORD, DWORD * ) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw7_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw7_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw7_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw7_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw7_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw7_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw7_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw7_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw7_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw7_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw7_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw7_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw7_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw7_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw7_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw7_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw7_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw7_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw7_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw7_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw7_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw7_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw7_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw7_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw7_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw7_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw7_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirectDraw7_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
#define IDirectDraw7_StartModeTest(p,a,b,c)        (p)->lpVtbl->StartModeTest(p,a,b,c)
#define IDirectDraw7_EvaluateMode(p,a,b)           (p)->lpVtbl->EvaluateMode(p,a,b)
#else
#define IDirectDraw7_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw7_AddRef(p)                       (p)->AddRef()
#define IDirectDraw7_Release(p)                      (p)->Release()
#define IDirectDraw7_Compact(p)                      (p)->Compact()
#define IDirectDraw7_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw7_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw7_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw7_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw7_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw7_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw7_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw7_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw7_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw7_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw7_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw7_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw7_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw7_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw7_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw7_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw7_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw7_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw7_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw7_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw7_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw7_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw7_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#define IDirectDraw7_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
#define IDirectDraw7_StartModeTest(p,a,b,c)        (p)->lpVtbl->StartModeTest(a,b,c)
#define IDirectDraw7_EvaluateMode(p,a,b)           (p)->lpVtbl->EvaluateMode(a,b)
#endif

#endif


/*
 * IDirectDrawPalette
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette
DECLARE_INTERFACE_( IDirectDrawPalette, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#else
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->QueryInterface(a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->AddRef()
#define IDirectDrawPalette_Release(p)                   (p)->Release()
#define IDirectDrawPalette_GetCaps(p, a)                (p)->GetCaps(a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->GetEntries(a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->Initialize(a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->SetEntries(a, b, c, d)
#endif

#endif


/*
 * IDirectDrawClipper
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawClipper
DECLARE_INTERFACE_( IDirectDrawClipper, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawClipper methods ***/
    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
    STDMETHOD(GetHWnd)(THIS_ HWND FAR *) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD) PURE;
    STDMETHOD(IsClipListChanged)(THIS_ BOOL FAR *) PURE;
    STDMETHOD(SetClipList)(THIS_ LPRGNDATA,DWORD) PURE;
    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawClipper_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->lpVtbl->GetClipList(p, a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->lpVtbl->GetHWnd(p, a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->lpVtbl->Initialize(p, a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->lpVtbl->IsClipListChanged(p, a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->lpVtbl->SetClipList(p, a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->lpVtbl->SetHWnd(p, a, b)
#else
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->AddRef()
#define IDirectDrawClipper_Release(p)               (p)->Release()
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->GetClipList(a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->GetHWnd(a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->Initialize(a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->IsClipListChanged(a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->SetClipList(a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->SetHWnd(a, b)
#endif

#endif

/*
 * IDirectDrawSurface and related interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurface
DECLARE_INTERFACE_( IDirectDrawSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#else
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface_Release(p)                   (p)->Release()
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#endif

/*
 * IDirectDrawSurface2 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface2
DECLARE_INTERFACE_( IDirectDrawSurface2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE2, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE2) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface2_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#else
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface2_Release(p)                   (p)->Release()
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface2_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->PageUnlock(a)
#endif

/*
 * IDirectDrawSurface3 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the V3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface3_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface3_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface3_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface3_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#else
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface3_Release(p)                   (p)->Release()
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface3_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface3_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface3_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#endif

/*
 * IDirectDrawSurface4 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface4
DECLARE_INTERFACE_( IDirectDrawSurface4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE4, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE4, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE4, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE4,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE4) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface4_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface4_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface4_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface4_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)         (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#else
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface4_Release(p)                   (p)->Release()
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface4_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface4_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface4_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)         (p)->FreePrivateData(a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#endif

/*
 * IDirectDrawSurface7 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface7
DECLARE_INTERFACE_( IDirectDrawSurface7, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE7, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE7, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK7) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK7) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE7, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE7 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE7,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE7) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
    /*** Moved Texture7 methods here ***/
    STDMETHOD(SetPriority)(THIS_ DWORD) PURE;
    STDMETHOD(GetPriority)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetLOD)(THIS_ DWORD) PURE;
    STDMETHOD(GetLOD)(THIS_ LPDWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface7_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface7_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface7_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface7_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface7_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface7_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface7_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface7_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface7_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface7_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface7_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface7_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface7_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface7_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface7_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface7_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface7_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface7_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface7_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface7_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface7_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface7_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface7_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface7_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface7_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface7_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface7_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface7_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface7_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface7_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface7_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface7_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface7_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface7_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface7_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface7_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface7_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface7_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface7_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface7_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface7_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface7_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface7_FreePrivateData(p,a)         (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface7_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface7_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#define IDirectDrawSurface7_SetPriority(p,a)             (p)->lpVtbl->SetPriority(p,a)
#define IDirectDrawSurface7_GetPriority(p,a)             (p)->lpVtbl->GetPriority(p,a)
#define IDirectDrawSurface7_SetLOD(p,a)                  (p)->lpVtbl->SetLOD(p,a)
#define IDirectDrawSurface7_GetLOD(p,a)                  (p)->lpVtbl->GetLOD(p,a)
#else
#define IDirectDrawSurface7_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface7_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface7_Release(p)                   (p)->Release()
#define IDirectDrawSurface7_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface7_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface7_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface7_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface7_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface7_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface7_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface7_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface7_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface7_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface7_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface7_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface7_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface7_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface7_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface7_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface7_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface7_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface7_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface7_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface7_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface7_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface7_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface7_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface7_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface7_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface7_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface7_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface7_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface7_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface7_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface7_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface7_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface7_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface7_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface7_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface7_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface7_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface7_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface7_FreePrivateData(p,a)         (p)->FreePrivateData(a)
#define IDirectDrawSurface7_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface7_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#define IDirectDrawSurface7_SetPriority(p,a)             (p)->SetPriority(a)
#define IDirectDrawSurface7_GetPriority(p,a)             (p)->GetPriority(a)
#define IDirectDrawSurface7_SetLOD(p,a)                  (p)->SetLOD(a)
#define IDirectDrawSurface7_GetLOD(p,a)                  (p)->GetLOD(a)
#endif


/*
 * IDirectDrawColorControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawColorControl
DECLARE_INTERFACE_( IDirectDrawColorControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawColorControl methods ***/
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawColorControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->lpVtbl->GetColorControls(p, a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->lpVtbl->SetColorControls(p, a)
#else
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawColorControl_Release(p)               (p)->Release()
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->GetColorControls(a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->SetColorControls(a)
#endif

#endif


/*
 * IDirectDrawGammaControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawGammaControl
DECLARE_INTERFACE_( IDirectDrawGammaControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawGammaControl methods ***/
    STDMETHOD(GetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
    STDMETHOD(SetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawGammaControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->lpVtbl->GetGammaRamp(p, a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->lpVtbl->SetGammaRamp(p, a, b)
#else
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawGammaControl_Release(p)               (p)->Release()
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->GetGammaRamp(a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->SetGammaRamp(a, b)
#endif

#endif



#endif


/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    union
    {
        LONG            lPitch;                 // distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    DWORD               dwBackBufferCount;      // number of back buffers requested
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requested
        DWORD           dwZBufferBitDepth;      // depth of Z buffer requested
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
    } DUMMYUNIONNAMEN(2);
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
    DWORD               dwReserved;             // reserved
    LPVOID              lpSurface;              // pointer to the associated surface memory
    DDCOLORKEY          ddckCKDestOverlay;      // color key for destination overlay use
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    DDPIXELFORMAT       ddpfPixelFormat;        // pixel format description of the surface
    DDSCAPS             ddsCaps;                // direct draw surface capabilities
} DDSURFACEDESC;

/*
 * DDSURFACEDESC2
 */
typedef struct _DDSURFACEDESC2
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    union
    {
        LONG            lPitch;                 // distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    union
    {
        DWORD           dwBackBufferCount;      // number of back buffers requested
        DWORD           dwDepth;                // the depth if this is a volume texture 
    } DUMMYUNIONNAMEN(5);
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requestde
                                                // dwZBufferBitDepth removed, use ddpfPixelFormat one instead
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
        DWORD           dwSrcVBHandle;          // The source used in VB::Optimize
    } DUMMYUNIONNAMEN(2);
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
    DWORD               dwReserved;             // reserved
    LPVOID              lpSurface;              // pointer to the associated surface memory
    union
    {
        DDCOLORKEY      ddckCKDestOverlay;      // color key for destination overlay use
        DWORD           dwEmptyFaceColor;       // Physical color for empty cubemap faces
    } DUMMYUNIONNAMEN(3);
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    union
    {
        DDPIXELFORMAT   ddpfPixelFormat;        // pixel format description of the surface
        DWORD           dwFVF;                  // vertex format description of vertex buffers
    } DUMMYUNIONNAMEN(4);
    DDSCAPS2            ddsCaps;                // direct draw surface capabilities
    DWORD               dwTextureStage;         // stage in multitexture cascade
} DDSURFACEDESC2;

/*
 * ddsCaps field is valid.
 */
#define DDSD_CAPS               0x00000001l     // default

/*
 * dwHeight field is valid.
 */
#define DDSD_HEIGHT             0x00000002l

/*
 * dwWidth field is valid.
 */
#define DDSD_WIDTH              0x00000004l

/*
 * lPitch is valid.
 */
#define DDSD_PITCH              0x00000008l

/*
 * dwBackBufferCount is valid.
 */
#define DDSD_BACKBUFFERCOUNT    0x00000020l

/*
 * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
 */
#define DDSD_ZBUFFERBITDEPTH    0x00000040l

/*
 * dwAlphaBitDepth is valid.
 */
#define DDSD_ALPHABITDEPTH      0x00000080l


/*
 * lpSurface is valid.
 */
#define DDSD_LPSURFACE          0x00000800l

/*
 * ddpfPixelFormat is valid.
 */
#define DDSD_PIXELFORMAT        0x00001000l

/*
 * ddckCKDestOverlay is valid.
 */
#define DDSD_CKDESTOVERLAY      0x00002000l

/*
 * ddckCKDestBlt is valid.
 */
#define DDSD_CKDESTBLT          0x00004000l

/*
 * ddckCKSrcOverlay is valid.
 */
#define DDSD_CKSRCOVERLAY       0x00008000l

/*
 * ddckCKSrcBlt is valid.
 */
#define DDSD_CKSRCBLT           0x00010000l

/*
 * dwMipMapCount is valid.
 */
#define DDSD_MIPMAPCOUNT        0x00020000l

 /*
  * dwRefreshRate is valid
  */
#define DDSD_REFRESHRATE        0x00040000l

/*
 * dwLinearSize is valid
 */
#define DDSD_LINEARSIZE         0x00080000l

/*
 * dwTextureStage is valid
 */
#define DDSD_TEXTURESTAGE       0x00100000l
/*
 * dwFVF is valid
 */
#define DDSD_FVF                0x00200000l
/*
 * dwSrcVBHandle is valid
 */
#define DDSD_SRCVBHANDLE        0x00400000l

/*
 * dwDepth is valid
 */
#define DDSD_DEPTH              0x00800000l

/*
 * All input fields are valid.
 */
#define DDSD_ALL                0x00fff9eel

/*
 * DDOPTSURFACEDESC
 */
typedef struct _DDOPTSURFACEDESC
{
    DWORD       dwSize;             // size of the DDOPTSURFACEDESC structure
    DWORD       dwFlags;            // determines what fields are valid
    DDSCAPS2    ddSCaps;            // Common caps like: Memory type
    DDOSCAPS    ddOSCaps;           // Common caps like: Memory type
    GUID        guid;               // Compression technique GUID
    DWORD       dwCompressionRatio; // Compression ratio
} DDOPTSURFACEDESC;

/*
 * guid field is valid.
 */
#define DDOSD_GUID                  0x00000001l

/*
 * dwCompressionRatio field is valid.
 */
#define DDOSD_COMPRESSION_RATIO     0x00000002l

/*
 * ddSCaps field is valid.
 */
#define DDOSD_SCAPS                 0x00000004l

/*
 * ddOSCaps field is valid.
 */
#define DDOSD_OSCAPS                0x00000008l

/*
 * All input fields are valid.
 */
#define DDOSD_ALL                   0x0000000fl

/*
 * The surface's optimized pixelformat is compressed
 */
#define DDOSDCAPS_OPTCOMPRESSED                 0x00000001l

/*
 * The surface's optimized pixelformat is reordered
 */
#define DDOSDCAPS_OPTREORDERED                  0x00000002l

/*
 * The opt surface is a monolithic mipmap
 */
#define DDOSDCAPS_MONOLITHICMIPMAP              0x00000004l

/*
 * The valid Surf caps:
 * #define DDSCAPS_SYSTEMMEMORY                 0x00000800l
 * #define DDSCAPS_VIDEOMEMORY          0x00004000l
 * #define DDSCAPS_LOCALVIDMEM          0x10000000l
 * #define DDSCAPS_NONLOCALVIDMEM       0x20000000l
 */
#define DDOSDCAPS_VALIDSCAPS            0x30004800l

/*
 * The valid OptSurf caps
 */
#define DDOSDCAPS_VALIDOSCAPS           0x00000007l


/*
 * DDCOLORCONTROL
 */
typedef struct _DDCOLORCONTROL
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LONG                lBrightness;
    LONG                lContrast;
    LONG                lHue;
    LONG                lSaturation;
    LONG                lSharpness;
    LONG                lGamma;
    LONG                lColorEnable;
    DWORD               dwReserved1;
} DDCOLORCONTROL;


/*
 * lBrightness field is valid.
 */
#define DDCOLOR_BRIGHTNESS              0x00000001l

/*
 * lContrast field is valid.
 */
#define DDCOLOR_CONTRAST                0x00000002l

/*
 * lHue field is valid.
 */
#define DDCOLOR_HUE                     0x00000004l

/*
 * lSaturation field is valid.
 */
#define DDCOLOR_SATURATION              0x00000008l

/*
 * lSharpness field is valid.
 */
#define DDCOLOR_SHARPNESS               0x00000010l

/*
 * lGamma field is valid.
 */
#define DDCOLOR_GAMMA                   0x00000020l

/*
 * lColorEnable field is valid.
 */
#define DDCOLOR_COLORENABLE             0x00000040l



/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * This bit is reserved. It should not be specified.
 */
#define DDSCAPS_RESERVED1                       0x00000001l

/*
 * Indicates that this surface contains alpha-only information.
 * (To determine if a surface is RGBA/YUVA, the pixel format must be
 * interrogated.)
 */
#define DDSCAPS_ALPHA                           0x00000002l

/*
 * Indicates that this surface is a backbuffer.  It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.  DirectDraw supports N surfaces in a
 * surface flipping structure.  Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */
#define DDSCAPS_BACKBUFFER                      0x00000004l

/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.  The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */
#define DDSCAPS_COMPLEX                         0x00000008l

/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.  They are set by CreateSurface
 * on the resulting creations.  The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */
#define DDSCAPS_FLIP                            0x00000010l

/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.  This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */
#define DDSCAPS_FRONTBUFFER                     0x00000020l

/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */
#define DDSCAPS_OFFSCREENPLAIN                  0x00000040l

/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
 * overlayed at the moment.
 */
#define DDSCAPS_OVERLAY                         0x00000080l

/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */
#define DDSCAPS_PALETTE                         0x00000100l

/*
 * Indicates that this surface is the primary surface.  The primary
 * surface represents what the user is seeing at the moment.
 */
#define DDSCAPS_PRIMARYSURFACE                  0x00000200l


/*
 * This flag used to be DDSCAPS_PRIMARYSURFACELEFT, which is now
 * obsolete.
 */
#define DDSCAPS_RESERVED3               0x00000400l
#define DDSCAPS_PRIMARYSURFACELEFT              0x00000000l

/*
 * Indicates that this surface memory was allocated in system memory
 */
#define DDSCAPS_SYSTEMMEMORY                    0x00000800l

/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */
#define DDSCAPS_TEXTURE                         0x00001000l

/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface
 * from this surface.
 */
#define DDSCAPS_3DDEVICE                        0x00002000l

/*
 * Indicates that this surface exists in video memory.
 */
#define DDSCAPS_VIDEOMEMORY                     0x00004000l

/*
 * Indicates that changes made to this surface are immediately visible.
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */
#define DDSCAPS_VISIBLE                         0x00008000l

/*
 * Indicates that only writes are permitted to the surface.  Read accesses
 * from the surface may or may not generate a protection fault, but the
 * results of a read from this surface will not be meaningful.  READ ONLY.
 */
#define DDSCAPS_WRITEONLY                       0x00010000l

/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured.
 */
#define DDSCAPS_ZBUFFER                         0x00020000l

/*
 * Indicates surface will have a DC associated long term
 */
#define DDSCAPS_OWNDC                           0x00040000l

/*
 * Indicates surface should be able to receive live video
 */
#define DDSCAPS_LIVEVIDEO                       0x00080000l

/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */
#define DDSCAPS_HWCODEC                         0x00100000l

/*
 * Surface is a ModeX surface.
 *
 */
#define DDSCAPS_MODEX                           0x00200000l

/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */
#define DDSCAPS_MIPMAP                          0x00400000l

/*
 * This bit is reserved. It should not be specified.
 */
#define DDSCAPS_RESERVED2                       0x00800000l


/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */
#define DDSCAPS_ALLOCONLOAD                     0x04000000l

/*
 * Indicates that the surface will recieve data from a video port.
 */
#define DDSCAPS_VIDEOPORT                       0x08000000l

/*
 * Indicates that a video memory surface is resident in true, local video
 * memory rather than non-local video memory. If this flag is specified then
 * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_NONLOCALVIDMEM.
 */
#define DDSCAPS_LOCALVIDMEM                     0x10000000l

/*
 * Indicates that a video memory surface is resident in non-local video
 * memory rather than true, local video memory. If this flag is specified
 * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_LOCALVIDMEM.
 */
#define DDSCAPS_NONLOCALVIDMEM                  0x20000000l

/*
 * Indicates that this surface is a standard VGA mode surface, and not a
 * ModeX surface. (This flag will never be set in combination with the
 * DDSCAPS_MODEX flag).
 */
#define DDSCAPS_STANDARDVGAMODE                 0x40000000l

/*
 * Indicates that this surface will be an optimized surface. This flag is
 * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
 * will be created without any underlying video memory until loaded.
 */
#define DDSCAPS_OPTIMIZED                       0x80000000l



/*
 * This bit is reserved
 */
#define DDSCAPS2_RESERVED4                      0x00000002L
#define DDSCAPS2_HARDWAREDEINTERLACE            0x00000000L

/*
 * Indicates to the driver that this surface will be locked very frequently
 * (for procedural textures, dynamic lightmaps, etc). Surfaces with this cap
 * set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTSTATIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTDYNAMIC                    0x00000004L

/*
 * Indicates to the driver that this surface can be re-ordered/retiled on
 * load. This operation will not change the size of the texture. It is
 * relatively fast and symmetrical, since the application may lock these
 * bits (although it will take a performance hit when doing so). Surfaces
 * with this cap set must also have DDSCAPS_TEXTURE. This cap cannot be
 * used with DDSCAPS2_HINTDYNAMIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTSTATIC                     0x00000008L

/*
 * Indicates that the client would like this texture surface to be managed by the
 * DirectDraw/Direct3D runtime. Surfaces with this cap set must also have
 * DDSCAPS_TEXTURE set.
 */
#define DDSCAPS2_TEXTUREMANAGE                  0x00000010L

/*
 * These bits are reserved for internal use */
#define DDSCAPS2_RESERVED1                      0x00000020L
#define DDSCAPS2_RESERVED2                      0x00000040L

/*
 * Indicates to the driver that this surface will never be locked again.
 * The driver is free to optimize this surface via retiling and actual compression.
 * All calls to Lock() or Blts from this surface will fail. Surfaces with this
 * cap set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTDYNAMIC and DDSCAPS2_HINTSTATIC.
 */
#define DDSCAPS2_OPAQUE                         0x00000080L

/*
 * Applications should set this bit at CreateSurface time to indicate that they
 * intend to use antialiasing. Only valid if DDSCAPS_3DDEVICE is also set.
 */
#define DDSCAPS2_HINTANTIALIASING               0x00000100L


/*
 * This flag is used at CreateSurface time to indicate that this set of
 * surfaces is a cubic environment map
 */
#define DDSCAPS2_CUBEMAP                        0x00000200L

/*
 * These flags preform two functions:
 * - At CreateSurface time, they define which of the six cube faces are
 *   required by the application.
 * - After creation, each face in the cubemap will have exactly one of these
 *   bits set.
 */
#define DDSCAPS2_CUBEMAP_POSITIVEX              0x00000400L
#define DDSCAPS2_CUBEMAP_NEGATIVEX              0x00000800L
#define DDSCAPS2_CUBEMAP_POSITIVEY              0x00001000L
#define DDSCAPS2_CUBEMAP_NEGATIVEY              0x00002000L
#define DDSCAPS2_CUBEMAP_POSITIVEZ              0x00004000L
#define DDSCAPS2_CUBEMAP_NEGATIVEZ              0x00008000L

/*
 * This macro may be used to specify all faces of a cube map at CreateSurface time
 */
#define DDSCAPS2_CUBEMAP_ALLFACES ( DDSCAPS2_CUBEMAP_POSITIVEX |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEX |\
                                    DDSCAPS2_CUBEMAP_POSITIVEY |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEY |\
                                    DDSCAPS2_CUBEMAP_POSITIVEZ |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEZ )


/*
 * This flag is an additional flag which is present on mipmap sublevels from DX7 onwards
 * It enables easier use of GetAttachedSurface rather than EnumAttachedSurfaces for surface
 * constructs such as Cube Maps, wherein there are more than one mipmap surface attached
 * to the root surface.
 * This caps bit is ignored by CreateSurface
 */
#define DDSCAPS2_MIPMAPSUBLEVEL                 0x00010000L

/* This flag indicates that the texture should be managed by D3D only */
#define DDSCAPS2_D3DTEXTUREMANAGE               0x00020000L

/* This flag indicates that the managed surface can be safely lost */
#define DDSCAPS2_DONOTPERSIST                   0x00040000L

/* indicates that this surface is part of a stereo flipping chain */
#define DDSCAPS2_STEREOSURFACELEFT              0x00080000L


/*
 * Indicates that the surface is a volume.
 * Can be combined with DDSCAPS_MIPMAP to indicate a multi-level volume
 */
#define DDSCAPS2_VOLUME                         0x00200000L

/*
 * Indicates that the surface may be locked multiple times by the application.
 * This cap cannot be used with DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_NOTUSERLOCKABLE                0x00400000L

/*
 * Indicates that the vertex buffer data can be used to render points and
 * point sprites.
 */
#define DDSCAPS2_POINTS                         0x00800000L

/*
 * Indicates that the vertex buffer data can be used to render rt pactches.
 */
#define DDSCAPS2_RTPATCHES                      0x01000000L

/*
 * Indicates that the vertex buffer data can be used to render n patches.
 */
#define DDSCAPS2_NPATCHES                       0x02000000L

/*
 * This bit is reserved for internal use 
 */
#define DDSCAPS2_RESERVED3                      0x04000000L


/*
 * Indicates that the contents of the backbuffer do not have to be preserved
 * the contents of the backbuffer after they are presented.
 */
#define DDSCAPS2_DISCARDBACKBUFFER              0x10000000L

/*
 * Indicates that all surfaces in this creation chain should be given an alpha channel.
 * This flag will be set on primary surface chains that may have no explicit pixel format
 * (and thus take on the format of the current display mode).
 * The driver should infer that all these surfaces have a format having an alpha channel.
 * (e.g. assume D3DFMT_A8R8G8B8 if the display mode is x888.)
 */
#define DDSCAPS2_ENABLEALPHACHANNEL             0x20000000L

/*
 * Indicates that all surfaces in this creation chain is extended primary surface format.
 * This flag will be set on extended primary surface chains that always have explicit pixel
 * format and the pixel format is typically GDI (Graphics Device Interface) couldn't handle,
 * thus only used with fullscreen application. (e.g. D3DFMT_A2R10G10B10 format)
 */
#define DDSCAPS2_EXTENDEDFORMATPRIMARY          0x40000000L

/*
 * Indicates that all surfaces in this creation chain is additional primary surface.
 * This flag will be set on primary surface chains which must present on the adapter
 * id provided on dwCaps4. Typically this will be used to create secondary primary surface
 * on DualView display adapter.
 */
#define DDSCAPS2_ADDITIONALPRIMARY              0x80000000L

/*
 * This is a mask that indicates the set of bits that may be set
 * at createsurface time to indicate number of samples per pixel
 * when multisampling
 */
#define DDSCAPS3_MULTISAMPLE_MASK               0x0000001FL

/*
 * This is a mask that indicates the set of bits that may be set
 * at createsurface time to indicate the quality level of rendering
 * for the current number of samples per pixel
 */
#define DDSCAPS3_MULTISAMPLE_QUALITY_MASK       0x000000E0L
#define DDSCAPS3_MULTISAMPLE_QUALITY_SHIFT      5

/*
 * This bit is reserved for internal use 
 */
#define DDSCAPS3_RESERVED1                      0x00000100L

/*
 * This bit is reserved for internal use 
 */
#define DDSCAPS3_RESERVED2                      0x00000200L

/*
 * This indicates whether this surface has light-weight miplevels
 */
#define DDSCAPS3_LIGHTWEIGHTMIPMAP              0x00000400L

/*
 * This indicates that the mipsublevels for this surface are auto-generated
 */
#define DDSCAPS3_AUTOGENMIPMAP                  0x00000800L

/*
 * This indicates that the mipsublevels for this surface are auto-generated
 */
#define DDSCAPS3_DMAP                           0x00001000L

/*
 * This indicates that this surface is to be shared by processes
 */
#define DDSCAPS3_CREATESHAREDRESOURCE           0x00002000L

/*
 * This indicates that this surface need to be initialized before being
 * shared, this bit implies that this surface is read only after initialization
 * absence of this bit implies that this surface allows both read and write
 */
#define DDSCAPS3_READONLYRESOURCE               0x00004000L

/*
 * This indicates that this surface is to share an existing video memory with 
 * another surface created with DDSCAPS3_CREATESHAREDRESOURCE, This bit is never
 * used with DDSCAPS3_CREATESHAREDRESOURCE
 */
#define DDSCAPS3_OPENSHAREDRESOURCE             0x00008000L


 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */
#define DDCAPS_3D                       0x00000001l

/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYDEST        0x00000002l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZEDEST            0x00000004l
/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYSRC         0x00000008l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZESRC             0x00000010l

/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */
#define DDCAPS_ALIGNSTRIDE              0x00000020l

/*
 * Display hardware is capable of blt operations.
 */
#define DDCAPS_BLT                      0x00000040l

/*
 * Display hardware is capable of asynchronous blt operations.
 */
#define DDCAPS_BLTQUEUE                 0x00000080l

/*
 * Display hardware is capable of color space conversions during the blt operation.
 */
#define DDCAPS_BLTFOURCC                0x00000100l

/*
 * Display hardware is capable of stretching during blt operations.
 */
#define DDCAPS_BLTSTRETCH               0x00000200l

/*
 * Display hardware is shared with GDI.
 */
#define DDCAPS_GDI                      0x00000400l

/*
 * Display hardware can overlay.
 */
#define DDCAPS_OVERLAY                  0x00000800l

/*
 * Set if display hardware supports overlays but can not clip them.
 */
#define DDCAPS_OVERLAYCANTCLIP          0x00001000l

/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */
#define DDCAPS_OVERLAYFOURCC            0x00002000l

/*
 * Indicates that stretching can be done by the overlay hardware.
 */
#define DDCAPS_OVERLAYSTRETCH           0x00004000l

/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */
#define DDCAPS_PALETTE                  0x00008000l

/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */
#define DDCAPS_PALETTEVSYNC             0x00010000l

/*
 * Display hardware can return the current scan line.
 */
#define DDCAPS_READSCANLINE             0x00020000l


/*
 * This flag used to bo DDCAPS_STEREOVIEW, which is now obsolete
 */
#define DDCAPS_RESERVED1                0x00040000l

/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */
#define DDCAPS_VBI                      0x00080000l

/*
 * Supports the use of z buffers with blt operations.
 */
#define DDCAPS_ZBLTS                    0x00100000l

/*
 * Supports Z Ordering of overlays.
 */
#define DDCAPS_ZOVERLAYS                0x00200000l

/*
 * Supports color key
 */
#define DDCAPS_COLORKEY                 0x00400000l

/*
 * Supports alpha surfaces
 */
#define DDCAPS_ALPHA                    0x00800000l

/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */
#define DDCAPS_COLORKEYHWASSIST         0x01000000l

/*
 * no hardware support at all
 */
#define DDCAPS_NOHARDWARE               0x02000000l

/*
 * Display hardware is capable of color fill with bltter
 */
#define DDCAPS_BLTCOLORFILL             0x04000000l

/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */
#define DDCAPS_BANKSWITCHED             0x08000000l

/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */
#define DDCAPS_BLTDEPTHFILL             0x10000000l

/*
 * Display hardware is capable of clipping while bltting.
 */
#define DDCAPS_CANCLIP                  0x20000000l

/*
 * Display hardware is capable of clipping while stretch bltting.
 */
#define DDCAPS_CANCLIPSTRETCHED         0x40000000l

/*
 * Display hardware is capable of bltting to or from system memory
 */
#define DDCAPS_CANBLTSYSMEM             0x80000000l


 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */
#define DDCAPS2_CERTIFIED              0x00000001l

/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */
#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l

/*
 * Display hardware contains a video port
 */
#define DDCAPS2_VIDEOPORT               0x00000004l

/*
 * The overlay can be automatically flipped according to the video port
 * VSYNCs, providing automatic doubled buffered display of video port
 * data using an overlay
 */
#define DDCAPS2_AUTOFLIPOVERLAY         0x00000008l

/*
 * Overlay can display each field of interlaced data individually while
 * it is interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBINTERLEAVED       0x00000010l

/*
 * Overlay can display each field of interlaced data individually while
 * it is not interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBNONINTERLEAVED    0x00000020l

/*
 * The overlay surface contains color controls (brightness, sharpness, etc.)
 */
#define DDCAPS2_COLORCONTROLOVERLAY     0x00000040l

/*
 * The primary surface contains color controls (gamma, etc.)
 */
#define DDCAPS2_COLORCONTROLPRIMARY     0x00000080l

/*
 * RGBZ -> RGB supported for 16:16 RGB:Z
 */
#define DDCAPS2_CANDROPZ16BIT           0x00000100l

/*
 * Driver supports non-local video memory.
 */
#define DDCAPS2_NONLOCALVIDMEM          0x00000200l

/*
 * Dirver supports non-local video memory but has different capabilities for
 * non-local video memory surfaces. If this bit is set then so must
 * DDCAPS2_NONLOCALVIDMEM.
 */
#define DDCAPS2_NONLOCALVIDMEMCAPS      0x00000400l

/*
 * Driver neither requires nor prefers surfaces to be pagelocked when performing
 * blts involving system memory surfaces
 */
#define DDCAPS2_NOPAGELOCKREQUIRED      0x00000800l

/*
 * Driver can create surfaces which are wider than the primary surface
 */
#define DDCAPS2_WIDESURFACES            0x00001000l

/*
 * Driver supports bob without using a video port by handling the
 * DDFLIP_ODD and DDFLIP_EVEN flags specified in Flip.
 */
#define DDCAPS2_CANFLIPODDEVEN          0x00002000l

/*
 * Driver supports bob using hardware
 */
#define DDCAPS2_CANBOBHARDWARE          0x00004000l

/*
 * Driver supports bltting any FOURCC surface to another surface of the same FOURCC
 */
#define DDCAPS2_COPYFOURCC              0x00008000l


/*
 * Driver supports loadable gamma ramps for the primary surface
 */
#define DDCAPS2_PRIMARYGAMMA            0x00020000l

/*
 * Driver can render in windowed mode.
 */
#define DDCAPS2_CANRENDERWINDOWED       0x00080000l

/*
 * A calibrator is available to adjust the gamma ramp according to the
 * physical display properties so that the result will be identical on
 * all calibrated systems.
 */
#define DDCAPS2_CANCALIBRATEGAMMA       0x00100000l

/*
 * Indicates that the driver will respond to DDFLIP_INTERVALn flags
 */
#define DDCAPS2_FLIPINTERVAL            0x00200000l

/*
 * Indicates that the driver will respond to DDFLIP_NOVSYNC
 */
#define DDCAPS2_FLIPNOVSYNC             0x00400000l

/*
 * Driver supports management of video memory, if this flag is ON,
 * driver manages the texture if requested with DDSCAPS2_TEXTUREMANAGE on
 * DirectX manages the texture if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
 */
#define DDCAPS2_CANMANAGETEXTURE        0x00800000l

/*
 * The Direct3D texture manager uses this cap to decide whether to put managed
 * surfaces in non-local video memory. If the cap is set, the texture manager will
 * put managed surfaces in non-local vidmem. Drivers that cannot texture from
 * local vidmem SHOULD NOT set this cap.
 */
#define DDCAPS2_TEXMANINNONLOCALVIDMEM  0x01000000l

/*
 * Indicates that the driver supports DX7 type of stereo in at least one mode (which may
 * not necessarily be the current mode). Applications should use IDirectDraw7 (or higher)
 * ::EnumDisplayModes and check the DDSURFACEDESC.ddsCaps.dwCaps2 field for the presence of
 * DDSCAPS2_STEREOSURFACELEFT to check if a particular mode supports stereo. The application
 * can also use IDirectDraw7(or higher)::GetDisplayMode to check the current mode.
 */
#define DDCAPS2_STEREO                  0x02000000L

/*
 * This caps bit is intended for internal DirectDraw use.
 * -It is only valid if DDCAPS2_NONLOCALVIDMEMCAPS is set.
 * -If this bit is set, then DDCAPS_CANBLTSYSMEM MUST be set by the driver (and
 *  all the assoicated system memory blt caps must be correct).
 * -It implies that the system->video blt caps in DDCAPS also apply to system to
 *  nonlocal blts. I.e. the dwSVBCaps, dwSVBCKeyCaps, dwSVBFXCaps and dwSVBRops
 *  members of DDCAPS (DDCORECAPS) are filled in correctly.
 * -Any blt from system to nonlocal memory that matches these caps bits will
 *  be passed to the driver.
 *
 * NOTE: This is intended to enable the driver itself to do efficient reordering
 * of textures. This is NOT meant to imply that hardware can write into AGP memory.
 * This operation is not currently supported.
 */
#define DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL   0x04000000L

/*
 * was DDCAPS2_PUREHAL
 */
#define DDCAPS2_RESERVED1                     0x08000000L

/*
 * Driver supports management of video memory, if this flag is ON,
 * driver manages the resource if requested with DDSCAPS2_TEXTUREMANAGE on
 * DirectX manages the resource if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
 */
#define DDCAPS2_CANMANAGERESOURCE             0x10000000L

/*
 * Driver supports dynamic textures. This will allow the application to set
 * D3DUSAGE_DYNAMIC (DDSCAPS2_HINTDYNAMIC for drivers) at texture create time.
 * Video memory dynamic textures WILL be lockable by applications. It is
 * expected that these locks will be very efficient (which implies that the
 * driver should always maintain a linear copy, a pointer to which can be
 * quickly handed out to the application).
 */
#define DDCAPS2_DYNAMICTEXTURES               0x20000000L

/*
 * Driver supports auto-generation of mipmaps.
 */
#define DDCAPS2_CANAUTOGENMIPMAP              0x40000000L

/*
 * Driver supports sharing of cross process resouces
 */
#define DDCAPS2_CANSHARERESOURCE              0x80000000L


/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAEDGEBLEND         0x00000001l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELS            0x00000002l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELSNEG         0x00000004l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACES          0x00000008l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACESNEG       0x00000010l

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND     0x00000020l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELS        0x00000040l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG     0x00000080l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACES      0x00000100l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG   0x00000200l

#if DIRECTDRAW_VERSION < 0x0600
#endif  //DIRECTDRAW_VERSION


/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */
#define DDFXCAPS_BLTARITHSTRETCHY       0x00000020l

/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */
#define DDFXCAPS_BLTARITHSTRETCHYN      0x00000010l

/*
 * Supports mirroring left to right in blt.
 */
#define DDFXCAPS_BLTMIRRORLEFTRIGHT     0x00000040l

/*
 * Supports mirroring top to bottom in blt.
 */
#define DDFXCAPS_BLTMIRRORUPDOWN        0x00000080l

/*
 * Supports arbitrary rotation for blts.
 */
#define DDFXCAPS_BLTROTATION            0x00000100l

/*
 * Supports 90 degree rotations for blts.
 */
#define DDFXCAPS_BLTROTATION90          0x00000200l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKX             0x00000400l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKXN            0x00000800l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKY             0x00001000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKYN            0x00002000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHX            0x00004000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHXN           0x00008000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHY            0x00010000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHYN           0x00020000l

/*
 * Uses arithmetic operations to stretch and shrink surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHY   0x00040000l

/*
 * Uses arithmetic operations to stretch surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays. Only works for x1, x2, etc.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHYN  0x00000008l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKX         0x00080000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKXN        0x00100000l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKY         0x00200000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKYN        0x00400000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHX        0x00800000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHXN       0x01000000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHY        0x02000000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHYN       0x04000000l

/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */
#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT 0x08000000l

/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */
#define DDFXCAPS_OVERLAYMIRRORUPDOWN    0x10000000l

/*
 * DirectDraw supports deinterlacing of overlay surfaces
 */
#define DDFXCAPS_OVERLAYDEINTERLACE		0x20000000l

/*
 * Driver can do alpha blending for blits.
 */
#define DDFXCAPS_BLTALPHA               0x00000001l


/*
 * Driver can do surface-reconstruction filtering for warped blits.
 */
#define DDFXCAPS_BLTFILTER              DDFXCAPS_BLTARITHSTRETCHY

/*
 * Driver can do alpha blending for overlays.
 */
#define DDFXCAPS_OVERLAYALPHA           0x00000004l


/*
 * Driver can do surface-reconstruction filtering for warped overlays.
 */
#define DDFXCAPS_OVERLAYFILTER          DDFXCAPS_OVERLAYARITHSTRETCHY

/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * This flag used to be DDSVCAPS_ENIGMA, which is now obsolete
 */

#define DDSVCAPS_RESERVED1              0x00000001l

/*
 * This flag used to be DDSVCAPS_FLICKER, which is now obsolete
 */
#define DDSVCAPS_RESERVED2              0x00000002l

/*
 * This flag used to be DDSVCAPS_REDBLUE, which is now obsolete
 */
#define DDSVCAPS_RESERVED3              0x00000004l

/*
 * This flag used to be DDSVCAPS_SPLIT, which is now obsolete
 */
#define DDSVCAPS_RESERVED4              0x00000008l

/*
 * The stereo view is accomplished with switching technology
 */

#define DDSVCAPS_STEREOSEQUENTIAL       0x00000010L



/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */
#define DDPCAPS_4BIT                    0x00000001l

/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */
#define DDPCAPS_8BITENTRIES             0x00000002l

/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */
#define DDPCAPS_8BIT                    0x00000004l

/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 * This flag is obsolete. DirectDraw always initializes the color array from
 * the lpDDColorArray parameter. The definition remains for source-level
 * compatibility.
 */
#define DDPCAPS_INITIALIZE              0x00000000l

/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */
#define DDPCAPS_PRIMARYSURFACE          0x00000010l

/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */
#define DDPCAPS_PRIMARYSURFACELEFT      0x00000020l

/*
 * This palette can have all 256 entries defined
 */
#define DDPCAPS_ALLOW256                0x00000040l

/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */
#define DDPCAPS_VSYNC                   0x00000080l

/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */
#define DDPCAPS_1BIT                    0x00000100l

/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */
#define DDPCAPS_2BIT                    0x00000200l

/*
 * The peFlags member of PALETTEENTRY denotes an 8 bit alpha value
 */
#define DDPCAPS_ALPHA                   0x00000400l


/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPRIVATEDATA CONSTANTS
 *
 ****************************************************************************/

/*
 * The passed pointer is an IUnknown ptr. The cbData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). DirectDraw will call AddRef through this
 * pointer and Release when the private data is destroyed. This includes when
 * the surface or palette is destroyed before such priovate data is destroyed.
 */
#define DDSPD_IUNKNOWNPOINTER           0x00000001L

/*
 * Private data is only valid for the current state of the object,
 * as determined by the uniqueness value.
 */
#define DDSPD_VOLATILE                  0x00000002L


/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */
#define DDBD_1                  0x00004000l

/*
 * 2 bits per pixel.
 */
#define DDBD_2                  0x00002000l

/*
 * 4 bits per pixel.
 */
#define DDBD_4                  0x00001000l

/*
 * 8 bits per pixel.
 */
#define DDBD_8                  0x00000800l

/*
 * 16 bits per pixel.
 */
#define DDBD_16                 0x00000400l

/*
 * 24 bits per pixel.
 */
#define DDBD_24                 0X00000200l

/*
 * 32 bits per pixel.
 */
#define DDBD_32                 0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.  Not set if the structure
 * contains a single color key.
 */
#define DDCKEY_COLORSPACE       0x00000001l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */
#define DDCKEY_DESTBLT          0x00000002l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */
#define DDCKEY_DESTOVERLAY      0x00000004l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */
#define DDCKEY_SRCBLT           0x00000008l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */
#define DDCKEY_SRCOVERLAY       0x00000010l


/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLT                      0x00000001l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACE              0x00000002l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV           0x00000004l

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTYUV                   0x00000008l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAY                  0x00000010l

/*
 * Supports a color space as the color key for the destination for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACE          0x00000020l

/*
 * Supports a color space as the color key for the destination for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV       0x00000040l

/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */
#define DDCKEYCAPS_DESTOVERLAYONEACTIVE         0x00000080l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the
 * surface being overlayed for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYYUV               0x00000100l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLT                       0x00000200l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACE               0x00000400l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV            0x00000800l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTYUV                    0x00001000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAY                   0x00002000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACE           0x00004000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV        0x00008000l

/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */
#define DDCKEYCAPS_SRCOVERLAYONEACTIVE          0x00010000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYYUV                0x00020000l

/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */
#define DDCKEYCAPS_NOCOSTOVERLAY                0x00040000l


/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */
#define DDPF_ALPHAPIXELS                        0x00000001l

/*
 * The pixel format contains alpha only information
 */
#define DDPF_ALPHA                              0x00000002l

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l

/*
 * The surface is 4-bit color indexed.
 */
#define DDPF_PALETTEINDEXED4                    0x00000008l

/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */
#define DDPF_PALETTEINDEXEDTO8                  0x00000010l

/*
 * The surface is 8-bit color indexed.
 */
#define DDPF_PALETTEINDEXED8                    0x00000020l

/*
 * The RGB data in the pixel format structure is valid.
 */
#define DDPF_RGB                                0x00000040l

/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */
#define DDPF_COMPRESSED                         0x00000080l

/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set.
 */
#define DDPF_RGBTOYUV                           0x00000100l

/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */
#define DDPF_YUV                                0x00000200l

/*
 * pixel format is a z buffer only surface
 */
#define DDPF_ZBUFFER                            0x00000400l

/*
 * The surface is 1-bit color indexed.
 */
#define DDPF_PALETTEINDEXED1                    0x00000800l

/*
 * The surface is 2-bit color indexed.
 */
#define DDPF_PALETTEINDEXED2                    0x00001000l

/*
 * The surface contains Z information in the pixels
 */
#define DDPF_ZPIXELS                            0x00002000l

/*
 * The surface contains stencil information along with Z
 */
#define DDPF_STENCILBUFFER                      0x00004000l

/*
 * Premultiplied alpha format -- the color components have been
 * premultiplied by the alpha component.
 */
#define DDPF_ALPHAPREMULT                       0x00008000l


/*
 * Luminance data in the pixel format is valid.
 * Use this flag for luminance-only or luminance+alpha surfaces,
 * the bit depth is then ddpf.dwLuminanceBitCount.
 */
#define DDPF_LUMINANCE                          0x00020000l

/*
 * Luminance data in the pixel format is valid.
 * Use this flag when hanging luminance off bumpmap surfaces,
 * the bit mask for the luminance portion of the pixel is then
 * ddpf.dwBumpLuminanceBitMask
 */
#define DDPF_BUMPLUMINANCE                      0x00040000l

/*
 * Bump map dUdV data in the pixel format is valid.
 */
#define DDPF_BUMPDUDV                           0x00080000l


/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */
#define DDENUMSURFACES_ALL                      0x00000001l

/*
 * A search hit is a surface that matches the surface description.
 */
#define DDENUMSURFACES_MATCH                    0x00000002l

/*
 * A search hit is a surface that does not match the surface description.
 */
#define DDENUMSURFACES_NOMATCH                  0x00000004l

/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */
#define DDENUMSURFACES_CANBECREATED             0x00000008l

/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */
#define DDENUMSURFACES_DOESEXIST                0x00000010l


/****************************************************************************
 *
 * DIRECTDRAW SETDISPLAYMODE FLAGS
 *
 ****************************************************************************/

/*
 * The desired mode is a standard VGA mode
 */
#define DDSDM_STANDARDVGAMODE                   0x00000001l


/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */
#define DDEDM_REFRESHRATES                      0x00000001l

/*
 * Enumerate VGA modes. Specify this flag if you wish to enumerate supported VGA
 * modes such as mode 0x13 in addition to the usual ModeX modes (which are always
 * enumerated if the application has previously called SetCooperativeLevel with the
 * DDSCL_ALLOWMODEX flag set).
 */
#define DDEDM_STANDARDVGAMODES                  0x00000002L


/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */
#define DDSCL_FULLSCREEN                        0x00000001l

/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
 */
#define DDSCL_ALLOWREBOOT                       0x00000002l

/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */
#define DDSCL_NOWINDOWCHANGES                   0x00000004l

/*
 * app wants to work as a regular Windows application
 */
#define DDSCL_NORMAL                            0x00000008l

/*
 * app wants exclusive access
 */
#define DDSCL_EXCLUSIVE                         0x00000010l


/*
 * app can deal with non-windows display modes
 */
#define DDSCL_ALLOWMODEX                        0x00000040l

/*
 * this window will receive the focus messages
 */
#define DDSCL_SETFOCUSWINDOW                    0x00000080l

/*
 * this window is associated with the DDRAW object and will
 * cover the screen in fullscreen mode
 */
#define DDSCL_SETDEVICEWINDOW                   0x00000100l

/*
 * app wants DDRAW to create a window to be associated with the
 * DDRAW object
 */
#define DDSCL_CREATEDEVICEWINDOW                0x00000200l

/*
 * App explicitly asks DDRAW/D3D to be multithread safe. This makes D3D
 * take the global crtisec more frequently.
 */
#define DDSCL_MULTITHREADED                     0x00000400l

/*
 * App specifies that it would like to keep the FPU set up for optimal Direct3D
 * performance (single precision and exceptions disabled) so Direct3D
 * does not need to explicitly set the FPU each time. This is assumed by
 * default in DirectX 7. See also DDSCL_FPUPRESERVE
 */
#define DDSCL_FPUSETUP                          0x00000800l

/*
 * App specifies that it needs either double precision FPU or FPU exceptions
 * enabled. This makes Direct3D explicitly set the FPU state eah time it is
 * called. Setting the flag will reduce Direct3D performance. The flag is
 * assumed by default in DirectX 6 and earlier. See also DDSCL_FPUSETUP
 */
#define DDSCL_FPUPRESERVE                          0x00001000l


/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHADEST                         0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDBLT_ALPHADESTCONSTOVERRIDE            0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHADESTNEG                      0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDBLT_ALPHADESTSURFACEOVERRIDE          0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDBLT_ALPHAEDGEBLEND                    0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHASRC                          0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCCONSTOVERRIDE             0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHASRCNEG                       0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCSURFACEOVERRIDE           0x00000100l

/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */
#define DDBLT_ASYNC                             0x00000200l

/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDBLT_COLORFILL                         0x00000400l

/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */
#define DDBLT_DDFX                              0x00000800l

/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDBLT_DDROPS                            0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDBLT_KEYDEST                           0x00002000l

/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */
#define DDBLT_KEYDESTOVERRIDE                   0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDBLT_KEYSRC                            0x00008000l

/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */
#define DDBLT_KEYSRCOVERRIDE                    0x00010000l

/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDBLT_ROP                               0x00020000l

/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDBLT_ROTATIONANGLE                     0x00040000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDBLT_ZBUFFER                           0x00080000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDBLT_ZBUFFERDESTCONSTOVERRIDE          0x00100000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDBLT_ZBUFFERDESTOVERRIDE               0x00200000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDBLT_ZBUFFERSRCCONSTOVERRIDE           0x00400000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_WAIT                              0x01000000l

/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */
#define DDBLT_DEPTHFILL                         0x02000000l


/*
 * Return immediately (with DDERR_WASSTILLDRAWING) if the device is not
 * ready to schedule the blt at the time Blt() is called.
 */
#define DDBLT_DONOTWAIT                         0x08000000l

/*
 * These flags indicate a presentation blt (i.e. a blt
 * that moves surface contents from an offscreen back buffer to the primary
 * surface). The driver is not allowed to "queue"  more than three such blts.
 * The "end" of the presentation blt is indicated, since the
 * blt may be clipped, in which case the runtime will call the driver with 
 * several blts. All blts (even if not clipped) are tagged with DDBLT_PRESENTATION
 * and the last (even if not clipped) additionally with DDBLT_LAST_PRESENTATION.
 * Thus the true rule is that the driver must not schedule a DDBLT_PRESENTATION
 * blt if there are 3 or more DDBLT_PRESENTLAST blts in the hardware pipe.
 * If there are such blts in the pipe, the driver should return DDERR_WASSTILLDRAWING
 * until the oldest queued DDBLT_LAST_PRESENTATION blts has been retired (i.e. the
 * pixels have been actually written to the primary surface). Once the oldest blt
 * has been retired, the driver is free to schedule the current blt.
 * The goal is to provide a mechanism whereby the device's hardware queue never
 * gets more than 3 frames ahead of the frames being generated by the application.
 * When excessive queueing occurs, applications become unusable because the application
 * visibly lags user input, and such problems make windowed interactive applications impossible.
 * Some drivers may not have sufficient knowledge of their hardware's FIFO to know
 * when a certain blt has been retired. Such drivers should code cautiously, and 
 * simply not allow any frames to be queued at all. DDBLT_LAST_PRESENTATION should cause
 * such drivers to return DDERR_WASSTILLDRAWING until the accelerator is completely
 * finished- exactly as if the application had called Lock on the source surface
 * before calling Blt. 
 * In other words, the driver is allowed and encouraged to 
 * generate as much latency as it can, but never more than 3 frames worth.
 * Implementation detail: Drivers should count blts against the SOURCE surface, not
 * against the primary surface. This enables multiple parallel windowed application
 * to function more optimally.
 * This flag is passed only to DX8 or higher drivers.
 *
 * APPLICATIONS DO NOT SET THESE FLAGS. THEY ARE SET BY THE DIRECTDRAW RUNTIME.
 * 
 */
#define DDBLT_PRESENTATION                      0x10000000l
#define DDBLT_LAST_PRESENTATION                 0x20000000l

/*
 * If DDBLT_EXTENDED_FLAGS is set, then the driver should re-interpret
 * other flags according to the definitions that follow.
 * For example, bit 0 (0x00000001L) means DDBLT_ALPHADEST, unless
 * DDBLT_EXTENDED_FLAGS is also set, in which case bit 0 means
 * DDBLT_EXTENDED_LINEAR_CONTENT.
 * Only DirectX9 and higher drivers will be given extended blt flags.
 * Only flags explicitly mentioned here should be re-interpreted.
 * All other flags retain their original meanings.
 *
 * List of re-interpreted flags:
 *
 * Bit Hex value   New meaning                                  old meaning
 * ---------------------------------------------------------------
 *  2  0x00000004  DDBLT_EXTENDED_LINEAR_CONTENT                DDBLT_ALPHADESTNEG
 *  4  0x00000010  DDBLT_EXTENDED_PRESENTATION_STRETCHFACTOR    DDBLT_ALPHAEDGEBLEND
 *
 *
 * NOTE: APPLICATIONS SHOULD NOT SET THIS FLAG. THIS FLAG IS INTENDED
 * FOR USE BY THE DIRECT3D RUNTIME.
 */
#define DDBLT_EXTENDED_FLAGS                    0x40000000l

/*
 * EXTENDED FLAG. SEE DEFINITION OF DDBLT_EXTENDED_FLAGS.
 * This flag indidcates that the source surface contains content in a
 * linear color space. The driver may perform gamma correction to the
 * desktop color space (i.e. sRGB, gamma 2.2) as part of this blt.
 * If the device can perform such a conversion as part of the copy,
 * the driver should also set D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION
 *
 * NOTE: APPLICATIONS SHOULD NOT SET THIS FLAG. THIS FLAG IS INTENDED
 * FOR USE BY THE DIRECT3D RUNTIME. Use IDirect3DSwapChain9::Present
 * and specify D3DPRESENT_LINEAR_CONTENT in order to use this functionality.
 */ 
#define DDBLT_EXTENDED_LINEAR_CONTENT           0x00000004l


/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/

#define DDBLTFAST_NOCOLORKEY                    0x00000000
#define DDBLTFAST_SRCCOLORKEY                   0x00000001
#define DDBLTFAST_DESTCOLORKEY                  0x00000002
#define DDBLTFAST_WAIT                          0x00000010
#define DDBLTFAST_DONOTWAIT                     0x00000020

/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/

#define DDFLIP_WAIT                          0x00000001L

/*
 * Indicates that the target surface contains the even field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_EVEN                          0x00000002L

/*
 * Indicates that the target surface contains the odd field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_ODD                           0x00000004L

/*
 * Causes DirectDraw to perform the physical flip immediately and return
 * to the application. Typically, what was the front buffer but is now the back
 * buffer will still be visible (depending on timing) until the next vertical
 * retrace. Subsequent operations involving the two flipped surfaces will
 * not check to see if the physical flip has finished (i.e. will not return
 * DDERR_WASSTILLDRAWING for that reason (but may for other reasons)).
 * This allows an application to perform Flips at a higher frequency than the
 * monitor refresh rate, but may introduce visible artifacts.
 * Only effective if DDCAPS2_FLIPNOVSYNC is set. If that bit is not set,
 * DDFLIP_NOVSYNC has no effect.
 */
#define DDFLIP_NOVSYNC                       0x00000008L


/*
 * Flip Interval Flags. These flags indicate how many vertical retraces to wait between
 * each flip. The default is one. DirectDraw will return DDERR_WASSTILLDRAWING for each
 * surface involved in the flip until the specified number of vertical retraces has
 * ocurred. Only effective if DDCAPS2_FLIPINTERVAL is set. If that bit is not set,
 * DDFLIP_INTERVALn has no effect.
 */

/*
 * DirectDraw will flip on every other vertical sync
 */
#define DDFLIP_INTERVAL2                     0x02000000L


/*
 * DirectDraw will flip on every third vertical sync
 */
#define DDFLIP_INTERVAL3                     0x03000000L


/*
 * DirectDraw will flip on every fourth vertical sync
 */
#define DDFLIP_INTERVAL4                     0x04000000L

/*
 * DirectDraw will flip and display a main stereo surface
 */
#define DDFLIP_STEREO                        0x00000010L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDFLIP_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDFLIP_DONOTWAIT.
 */
#define DDFLIP_DONOTWAIT                     0x00000020L


/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */
#define DDOVER_ALPHADEST                        0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */
#define DDOVER_ALPHADESTCONSTOVERRIDE           0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases.
 */
#define DDOVER_ALPHADESTNEG                     0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */
#define DDOVER_ALPHADESTSURFACEOVERRIDE         0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */
#define DDOVER_ALPHAEDGEBLEND                   0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */
#define DDOVER_ALPHASRC                         0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */
#define DDOVER_ALPHASRCCONSTOVERRIDE            0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */
#define DDOVER_ALPHASRCNEG                      0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */
#define DDOVER_ALPHASRCSURFACEOVERRIDE          0x00000100l

/*
 * Turn this overlay off.
 */
#define DDOVER_HIDE                             0x00000200l

/*
 * Use the color key associated with the destination surface.
 */
#define DDOVER_KEYDEST                          0x00000400l

/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */
#define DDOVER_KEYDESTOVERRIDE                  0x00000800l

/*
 * Use the color key associated with the source surface.
 */
#define DDOVER_KEYSRC                           0x00001000l

/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */
#define DDOVER_KEYSRCOVERRIDE                   0x00002000l

/*
 * Turn this overlay on.
 */
#define DDOVER_SHOW                             0x00004000l

/*
 * Add a dirty rect to an emulated overlayed surface.
 */
#define DDOVER_ADDDIRTYRECT                     0x00008000l

/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */
#define DDOVER_REFRESHDIRTYRECTS                0x00010000l

/*
 * Redraw the entire surface on an emulated overlayed surface.
 */
#define DDOVER_REFRESHALL                      0x00020000l


/*
 * Use the overlay FX flags to define special overlay FX
 */
#define DDOVER_DDFX                             0x00080000l

/*
 * Autoflip the overlay when ever the video port autoflips
 */
#define DDOVER_AUTOFLIP                         0x00100000l

/*
 * Display each field of video port data individually without
 * causing any jittery artifacts
 */
#define DDOVER_BOB                              0x00200000l

/*
 * Indicates that bob/weave decisions should not be overridden by other
 * interfaces.
 */
#define DDOVER_OVERRIDEBOBWEAVE                 0x00400000l

/*
 * Indicates that the surface memory is composed of interleaved fields.
 */
#define DDOVER_INTERLEAVED                      0x00800000l

/*
 * Indicates that bob will be performed using hardware rather than
 * software or emulated.
 */
#define DDOVER_BOBHARDWARE                      0x01000000l

/*
 * Indicates that overlay FX structure contains valid ARGB scaling factors.
 */
#define DDOVER_ARGBSCALEFACTORS                 0x02000000l

/*
 * Indicates that ARGB scaling factors can be degraded to fit driver capabilities.
 */
#define DDOVER_DEGRADEARGBSCALING               0x04000000l


#ifdef  COMBOX_SANDBOX
#define DX_LONGHORN_PRESERVEDC
#endif

#ifdef DX_LONGHORN_PRESERVEDC

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETSURFACEDESC FLAGS
 *
 ****************************************************************************/

/*
 * The default.  The GDI DC will be tore down.
 */
#define DDSETSURFACEDESC_RECREATEDC             0x00000000L     // default

/*
 * The default.  The GDI DC will be kept.
 */
#define DDSETSURFACEDESC_PRESERVEDC             0x00000001L


#endif // DX_LONGHORN_PRESERVEDC

/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.  Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
#define DDLOCK_SURFACEMEMORYPTR                 0x00000000L     // default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return
 * DDERR_WASSTILLDRAWING.
 */
#define DDLOCK_WAIT                             0x00000001L

/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */
#define DDLOCK_EVENT                            0x00000002L

/*
 * Indicates that the surface being locked will only be read from.
 */
#define DDLOCK_READONLY                         0x00000010L

/*
 * Indicates that the surface being locked will only be written to
 */
#define DDLOCK_WRITEONLY                        0x00000020L


/*
 * Indicates that a system wide lock should not be taken when this surface
 * is locked. This has several advantages (cursor responsiveness, ability
 * to call more Windows functions, easier debugging) when locking video
 * memory surfaces. However, an application specifying this flag must
 * comply with a number of conditions documented in the help file.
 * Furthermore, this flag cannot be specified when locking the primary.
 */
#define DDLOCK_NOSYSLOCK                        0x00000800L

/*
 * Used only with Direct3D Vertex Buffer Locks. Indicates that no vertices
 * that were referred to in Draw*PrimtiveVB calls since the start of the
 * frame (or the last lock without this flag) will be modified during the
 * lock. This can be useful when one is only appending data to the vertex
 * buffer
 */
#define DDLOCK_NOOVERWRITE                      0x00001000L

/*
 * Indicates that no assumptions will be made about the contents of the
 * surface or vertex buffer during this lock.
 * This enables two things:
 * -    Direct3D or the driver may provide an alternative memory
 *      area as the vertex buffer. This is useful when one plans to clear the
 *      contents of the vertex buffer and fill in new data.
 * -    Drivers sometimes store surface data in a re-ordered format.
 *      When the application locks the surface, the driver is forced to un-re-order
 *      the surface data before allowing the application to see the surface contents.
 *      This flag is a hint to the driver that it can skip the un-re-ordering process
 *      since the application plans to overwrite every single pixel in the surface
 *      or locked rectangle (and so erase any un-re-ordered pixels anyway).
 *      Applications should always set this flag when they intend to overwrite the entire
 *      surface or locked rectangle.
 */
#define DDLOCK_DISCARDCONTENTS                  0x00002000L
 /*
  * DDLOCK_OKTOSWAP is an older, less informative name for DDLOCK_DISCARDCONTENTS
  */
#define DDLOCK_OKTOSWAP                         0x00002000L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDLOCK_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDLOCK_DONOTWAIT.
 */
#define DDLOCK_DONOTWAIT                        0x00004000L

/*
 * This indicates volume texture lock with front and back specified.
 */
#define DDLOCK_HASVOLUMETEXTUREBOXRECT          0x00008000L

/*
 * This indicates that the driver should not update dirty rect information for this lock.
 */
#define DDLOCK_NODIRTYUPDATE                    0x00010000L


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDBLTFX_ARITHSTRETCHY                   0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDBLTFX_MIRRORLEFTRIGHT                 0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDBLTFX_MIRRORUPDOWN                    0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDBLTFX_NOTEARING                       0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDBLTFX_ROTATE180                       0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDBLTFX_ROTATE270                       0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDBLTFX_ROTATE90                        0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDBLTFX_ZBUFFERRANGE                    0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDBLTFX_ZBUFFERBASEDEST                 0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */
#define DDOVERFX_ARITHSTRETCHY                  0x00000001l

/*
 * Mirror the overlay across the vertical axis
 */
#define DDOVERFX_MIRRORLEFTRIGHT                0x00000002l

/*
 * Mirror the overlay across the horizontal axis
 */
#define DDOVERFX_MIRRORUPDOWN                   0x00000004l

/*
 * Deinterlace the overlay, if possible
 */
#define DDOVERFX_DEINTERLACE                    0x00000008l


/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */
#define DDWAITVB_BLOCKBEGIN                     0x00000001l

/*
 * set up an event to trigger when the vertical blank begins
 */
#define DDWAITVB_BLOCKBEGINEVENT                0x00000002l

/*
 * return when the vertical blank interval ends and display begins
 */
#define DDWAITVB_BLOCKEND                       0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */
#define DDGFS_CANFLIP                   0x00000001l

/*
 * is the last flip finished?
 */
#define DDGFS_ISFLIPDONE                0x00000002l

/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */
#define DDGBS_CANBLT                    0x00000001l

/*
 * is the blt to the surface finished?
 */
#define DDGBS_ISBLTDONE                 0x00000002l


/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */
#define DDENUMOVERLAYZ_BACKTOFRONT      0x00000000l

/*
 * Enumerate overlays front to back
 */
#define DDENUMOVERLAYZ_FRONTTOBACK      0x00000001l

/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */
#define DDOVERZ_SENDTOFRONT             0x00000000l

/*
 * Send overlay to back
 */
#define DDOVERZ_SENDTOBACK              0x00000001l

/*
 * Move Overlay forward
 */
#define DDOVERZ_MOVEFORWARD             0x00000002l

/*
 * Move Overlay backward
 */
#define DDOVERZ_MOVEBACKWARD            0x00000003l

/*
 * Move Overlay in front of relative surface
 */
#define DDOVERZ_INSERTINFRONTOF         0x00000004l

/*
 * Move Overlay in back of relative surface
 */
#define DDOVERZ_INSERTINBACKOF          0x00000005l


/****************************************************************************
 *
 * DIRECTDRAW SETGAMMARAMP FLAGS
 *
 ****************************************************************************/

/*
 * Request calibrator to adjust the gamma ramp according to the physical
 * properties of the display so that the result should appear identical
 * on all systems.
 */
#define DDSGR_CALIBRATE                        0x00000001L


/****************************************************************************
 *
 * DIRECTDRAW STARTMODETEST FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDSMT_ISTESTREQUIRED                   0x00000001L


/****************************************************************************
 *
 * DIRECTDRAW EVALUATEMODE FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDEM_MODEPASSED                        0x00000001L

/*
 * Indicates that the mode being tested has failed
 */
#define DDEM_MODEFAILED                        0x00000002L


/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */
#define DD_OK                                   S_OK
#define DD_FALSE                                S_FALSE

/****************************************************************************
 *
 * DIRECTDRAW ENUMCALLBACK RETURN VALUES
 *
 * EnumCallback returns are used to control the flow of the DIRECTDRAW and
 * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
 * enumeration callback routines.
 *
 ****************************************************************************/

/*
 * stop the enumeration
 */
#define DDENUMRET_CANCEL                        0

/*
 * continue the enumeration
 */
#define DDENUMRET_OK                            1

/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

/*
 * This object is already initialized
 */
#define DDERR_ALREADYINITIALIZED                MAKE_DDHRESULT( 5 )

/*
 * This surface can not be attached to the requested surface.
 */
#define DDERR_CANNOTATTACHSURFACE               MAKE_DDHRESULT( 10 )

/*
 * This surface can not be detached from the requested surface.
 */
#define DDERR_CANNOTDETACHSURFACE               MAKE_DDHRESULT( 20 )

/*
 * Support is currently not available.
 */
#define DDERR_CURRENTLYNOTAVAIL                 MAKE_DDHRESULT( 40 )

/*
 * An exception was encountered while performing the requested operation
 */
#define DDERR_EXCEPTION                         MAKE_DDHRESULT( 55 )

/*
 * Generic failure.
 */
#define DDERR_GENERIC                           E_FAIL

/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */
#define DDERR_HEIGHTALIGN                       MAKE_DDHRESULT( 90 )

/*
 * Unable to match primary surface creation request with existing
 * primary surface.
 */
#define DDERR_INCOMPATIBLEPRIMARY               MAKE_DDHRESULT( 95 )

/*
 * One or more of the caps bits passed to the callback are incorrect.
 */
#define DDERR_INVALIDCAPS                       MAKE_DDHRESULT( 100 )

/*
 * DirectDraw does not support provided Cliplist.
 */
#define DDERR_INVALIDCLIPLIST                   MAKE_DDHRESULT( 110 )

/*
 * DirectDraw does not support the requested mode
 */
#define DDERR_INVALIDMODE                       MAKE_DDHRESULT( 120 )

/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */
#define DDERR_INVALIDOBJECT                     MAKE_DDHRESULT( 130 )

/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */
#define DDERR_INVALIDPARAMS                     E_INVALIDARG

/*
 * pixel format was invalid as specified
 */
#define DDERR_INVALIDPIXELFORMAT                MAKE_DDHRESULT( 145 )

/*
 * Rectangle provided was invalid.
 */
#define DDERR_INVALIDRECT                       MAKE_DDHRESULT( 150 )

/*
 * Operation could not be carried out because one or more surfaces are locked
 */
#define DDERR_LOCKEDSURFACES                    MAKE_DDHRESULT( 160 )

/*
 * There is no 3D present.
 */
#define DDERR_NO3D                              MAKE_DDHRESULT( 170 )

/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */
#define DDERR_NOALPHAHW                         MAKE_DDHRESULT( 180 )

/*
 * Operation could not be carried out because there is no stereo
 * hardware present or available.
 */
#define DDERR_NOSTEREOHARDWARE          MAKE_DDHRESULT( 181 )

/*
 * Operation could not be carried out because there is no hardware
 * present which supports stereo surfaces
 */
#define DDERR_NOSURFACELEFT                             MAKE_DDHRESULT( 182 )



/*
 * no clip list available
 */
#define DDERR_NOCLIPLIST                        MAKE_DDHRESULT( 205 )

/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */
#define DDERR_NOCOLORCONVHW                     MAKE_DDHRESULT( 210 )

/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */
#define DDERR_NOCOOPERATIVELEVELSET             MAKE_DDHRESULT( 212 )

/*
 * Surface doesn't currently have a color key
 */
#define DDERR_NOCOLORKEY                        MAKE_DDHRESULT( 215 )

/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */
#define DDERR_NOCOLORKEYHW                      MAKE_DDHRESULT( 220 )

/*
 * No DirectDraw support possible with current display driver
 */
#define DDERR_NODIRECTDRAWSUPPORT               MAKE_DDHRESULT( 222 )

/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */
#define DDERR_NOEXCLUSIVEMODE                   MAKE_DDHRESULT( 225 )

/*
 * Flipping visible surfaces is not supported.
 */
#define DDERR_NOFLIPHW                          MAKE_DDHRESULT( 230 )

/*
 * There is no GDI present.
 */
#define DDERR_NOGDI                             MAKE_DDHRESULT( 240 )

/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */
#define DDERR_NOMIRRORHW                        MAKE_DDHRESULT( 250 )

/*
 * Requested item was not found
 */
#define DDERR_NOTFOUND                          MAKE_DDHRESULT( 255 )

/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */
#define DDERR_NOOVERLAYHW                       MAKE_DDHRESULT( 260 )

/*
 * Operation could not be carried out because the source and destination
 * rectangles are on the same surface and overlap each other.
 */
#define DDERR_OVERLAPPINGRECTS                  MAKE_DDHRESULT( 270 )

/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */
#define DDERR_NORASTEROPHW                      MAKE_DDHRESULT( 280 )

/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */
#define DDERR_NOROTATIONHW                      MAKE_DDHRESULT( 290 )

/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */
#define DDERR_NOSTRETCHHW                       MAKE_DDHRESULT( 310 )

/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */
#define DDERR_NOT4BITCOLOR                      MAKE_DDHRESULT( 316 )

/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */
#define DDERR_NOT4BITCOLORINDEX                 MAKE_DDHRESULT( 317 )

/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */
#define DDERR_NOT8BITCOLOR                      MAKE_DDHRESULT( 320 )

/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */
#define DDERR_NOTEXTUREHW                       MAKE_DDHRESULT( 330 )

/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */
#define DDERR_NOVSYNCHW                         MAKE_DDHRESULT( 335 )

/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */
#define DDERR_NOZBUFFERHW                       MAKE_DDHRESULT( 340 )

/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */
#define DDERR_NOZOVERLAYHW                      MAKE_DDHRESULT( 350 )

/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */
#define DDERR_OUTOFCAPS                         MAKE_DDHRESULT( 360 )

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFMEMORY                       E_OUTOFMEMORY

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFVIDEOMEMORY                  MAKE_DDHRESULT( 380 )

/*
 * hardware does not support clipped overlays
 */
#define DDERR_OVERLAYCANTCLIP                   MAKE_DDHRESULT( 382 )

/*
 * Can only have ony color key active at one time for overlays
 */
#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE      MAKE_DDHRESULT( 384 )

/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */
#define DDERR_PALETTEBUSY                       MAKE_DDHRESULT( 387 )

/*
 * No src color key specified for this operation.
 */
#define DDERR_COLORKEYNOTSET                    MAKE_DDHRESULT( 400 )

/*
 * This surface is already attached to the surface it is being attached to.
 */
#define DDERR_SURFACEALREADYATTACHED            MAKE_DDHRESULT( 410 )

/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */
#define DDERR_SURFACEALREADYDEPENDENT           MAKE_DDHRESULT( 420 )

/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */
#define DDERR_SURFACEBUSY                       MAKE_DDHRESULT( 430 )

/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 * Will also happen on attempts to lock an optimized surface.
 */
#define DDERR_CANTLOCKSURFACE                   MAKE_DDHRESULT( 435 )

/*
 * Access to Surface refused because Surface is obscured.
 */
#define DDERR_SURFACEISOBSCURED                 MAKE_DDHRESULT( 440 )

/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should
 * have Restore called on it.
 */
#define DDERR_SURFACELOST                       MAKE_DDHRESULT( 450 )

/*
 * The requested surface is not attached.
 */
#define DDERR_SURFACENOTATTACHED                MAKE_DDHRESULT( 460 )

/*
 * Height requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGHEIGHT                      MAKE_DDHRESULT( 470 )

/*
 * Size requested by DirectDraw is too large --  The individual height and
 * width are OK.
 */
#define DDERR_TOOBIGSIZE                        MAKE_DDHRESULT( 480 )

/*
 * Width requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGWIDTH                       MAKE_DDHRESULT( 490 )

/*
 * Action not supported.
 */
#define DDERR_UNSUPPORTED                       E_NOTIMPL

/*
 * Pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDFORMAT                 MAKE_DDHRESULT( 510 )

/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDMASK                   MAKE_DDHRESULT( 520 )

/*
 * The specified stream contains invalid data
 */
#define DDERR_INVALIDSTREAM                     MAKE_DDHRESULT( 521 )

/*
 * vertical blank is in progress
 */
#define DDERR_VERTICALBLANKINPROGRESS           MAKE_DDHRESULT( 537 )

/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */
#define DDERR_WASSTILLDRAWING                   MAKE_DDHRESULT( 540 )


/*
 * The specified surface type requires specification of the COMPLEX flag
 */
#define DDERR_DDSCAPSCOMPLEXREQUIRED            MAKE_DDHRESULT( 542 )


/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */
#define DDERR_XALIGN                            MAKE_DDHRESULT( 560 )

/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */
#define DDERR_INVALIDDIRECTDRAWGUID             MAKE_DDHRESULT( 561 )

/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */
#define DDERR_DIRECTDRAWALREADYCREATED          MAKE_DDHRESULT( 562 )

/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */
#define DDERR_NODIRECTDRAWHW                    MAKE_DDHRESULT( 563 )

/*
 * this process already has created a primary surface
 */
#define DDERR_PRIMARYSURFACEALREADYEXISTS       MAKE_DDHRESULT( 564 )

/*
 * software emulation not available.
 */
#define DDERR_NOEMULATION                       MAKE_DDHRESULT( 565 )

/*
 * region passed to Clipper::GetClipList is too small.
 */
#define DDERR_REGIONTOOSMALL                    MAKE_DDHRESULT( 566 )

/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */
#define DDERR_CLIPPERISUSINGHWND                MAKE_DDHRESULT( 567 )

/*
 * No clipper object attached to surface object
 */
#define DDERR_NOCLIPPERATTACHED                 MAKE_DDHRESULT( 568 )

/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */
#define DDERR_NOHWND                            MAKE_DDHRESULT( 569 )

/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */
#define DDERR_HWNDSUBCLASSED                    MAKE_DDHRESULT( 570 )

/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */
#define DDERR_HWNDALREADYSET                    MAKE_DDHRESULT( 571 )

/*
 * No palette object attached to this surface.
 */
#define DDERR_NOPALETTEATTACHED                 MAKE_DDHRESULT( 572 )

/*
 * No hardware support for 16 or 256 color palettes.
 */
#define DDERR_NOPALETTEHW                       MAKE_DDHRESULT( 573 )

/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */
#define DDERR_BLTFASTCANTCLIP                   MAKE_DDHRESULT( 574 )

/*
 * No blter.
 */
#define DDERR_NOBLTHW                           MAKE_DDHRESULT( 575 )

/*
 * No DirectDraw ROP hardware.
 */
#define DDERR_NODDROPSHW                        MAKE_DDHRESULT( 576 )

/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */
#define DDERR_OVERLAYNOTVISIBLE                 MAKE_DDHRESULT( 577 )

/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */
#define DDERR_NOOVERLAYDEST                     MAKE_DDHRESULT( 578 )

/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */
#define DDERR_INVALIDPOSITION                   MAKE_DDHRESULT( 579 )

/*
 * returned when an overlay member is called for a non-overlay surface
 */
#define DDERR_NOTAOVERLAYSURFACE                MAKE_DDHRESULT( 580 )

/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */
#define DDERR_EXCLUSIVEMODEALREADYSET           MAKE_DDHRESULT( 581 )

/*
 * An attempt has been made to flip a surface that is not flippable.
 */
#define DDERR_NOTFLIPPABLE                      MAKE_DDHRESULT( 582 )

/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */
#define DDERR_CANTDUPLICATE                     MAKE_DDHRESULT( 583 )

/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */
#define DDERR_NOTLOCKED                         MAKE_DDHRESULT( 584 )

/*
 * Windows can not create any more DCs, or a DC was requested for a paltte-indexed
 * surface when the surface had no palette AND the display mode was not palette-indexed
 * (in this case DirectDraw cannot select a proper palette into the DC)
 */
#define DDERR_CANTCREATEDC                      MAKE_DDHRESULT( 585 )

/*
 * No DC was ever created for this surface.
 */
#define DDERR_NODC                              MAKE_DDHRESULT( 586 )

/*
 * This surface can not be restored because it was created in a different
 * mode.
 */
#define DDERR_WRONGMODE                         MAKE_DDHRESULT( 587 )

/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */
#define DDERR_IMPLICITLYCREATED                 MAKE_DDHRESULT( 588 )

/*
 * The surface being used is not a palette-based surface
 */
#define DDERR_NOTPALETTIZED                     MAKE_DDHRESULT( 589 )


/*
 * The display is currently in an unsupported mode
 */
#define DDERR_UNSUPPORTEDMODE                   MAKE_DDHRESULT( 590 )

/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */
#define DDERR_NOMIPMAPHW                        MAKE_DDHRESULT( 591 )

/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */
#define DDERR_INVALIDSURFACETYPE                MAKE_DDHRESULT( 592 )


/*
 * Device does not support optimized surfaces, therefore no video memory optimized surfaces
 */
#define DDERR_NOOPTIMIZEHW                      MAKE_DDHRESULT( 600 )

/*
 * Surface is an optimized surface, but has not yet been allocated any memory
 */
#define DDERR_NOTLOADED                         MAKE_DDHRESULT( 601 )

/*
 * Attempt was made to create or set a device window without first setting
 * the focus window
 */
#define DDERR_NOFOCUSWINDOW                     MAKE_DDHRESULT( 602 )

/*
 * Attempt was made to set a palette on a mipmap sublevel
 */
#define DDERR_NOTONMIPMAPSUBLEVEL               MAKE_DDHRESULT( 603 )

/*
 * A DC has already been returned for this surface. Only one DC can be
 * retrieved per surface.
 */
#define DDERR_DCALREADYCREATED                  MAKE_DDHRESULT( 620 )

/*
 * An attempt was made to allocate non-local video memory from a device
 * that does not support non-local video memory.
 */
#define DDERR_NONONLOCALVIDMEM                  MAKE_DDHRESULT( 630 )

/*
 * The attempt to page lock a surface failed.
 */
#define DDERR_CANTPAGELOCK                      MAKE_DDHRESULT( 640 )


/*
 * The attempt to page unlock a surface failed.
 */
#define DDERR_CANTPAGEUNLOCK                    MAKE_DDHRESULT( 660 )

/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */
#define DDERR_NOTPAGELOCKED                     MAKE_DDHRESULT( 680 )

/*
 * There is more data available than the specified buffer size could hold
 */
#define DDERR_MOREDATA                          MAKE_DDHRESULT( 690 )

/*
 * The data has expired and is therefore no longer valid.
 */
#define DDERR_EXPIRED                           MAKE_DDHRESULT( 691 )

/*
 * The mode test has finished executing.
 */
#define DDERR_TESTFINISHED                      MAKE_DDHRESULT( 692 )

/*
 * The mode test has switched to a new mode.
 */
#define DDERR_NEWMODE                           MAKE_DDHRESULT( 693 )

/*
 * D3D has not yet been initialized.
 */
#define DDERR_D3DNOTINITIALIZED                 MAKE_DDHRESULT( 694 )

/*
 * The video port is not active
 */
#define DDERR_VIDEONOTACTIVE                    MAKE_DDHRESULT( 695 )

/*
 * The monitor does not have EDID data.
 */
#define DDERR_NOMONITORINFORMATION              MAKE_DDHRESULT( 696 )

/*
 * The driver does not enumerate display mode refresh rates.
 */
#define DDERR_NODRIVERSUPPORT                   MAKE_DDHRESULT( 697 )

/*
 * Surfaces created by one direct draw device cannot be used directly by
 * another direct draw device.
 */
#define DDERR_DEVICEDOESNTOWNSURFACE            MAKE_DDHRESULT( 699 )



/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */
#define DDERR_NOTINITIALIZED                    CO_E_NOTINITIALIZED


/* Alpha bit depth constants */


#ifdef __cplusplus
};
#endif

#ifdef ENABLE_NAMELESS_UNION_PRAGMA
#pragma warning(default:4201)
#endif

#endif //__DDRAW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\devguid.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devguid.h

Abstract:

    Defines GUIDs for device classes used in Plug & Play.

--*/

DEFINE_GUID( GUID_DEVCLASS_1394,                0x6bdd1fc1L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_1394DEBUG,           0x66f250d6L, 0x7801, 0x4a64, 0xb1, 0x39, 0xee, 0xa8, 0x0a, 0x45, 0x0b, 0x24 );
DEFINE_GUID( GUID_DEVCLASS_61883,               0x7ebefbc0L, 0x3200, 0x11d2, 0xb4, 0xc2, 0x00, 0xa0, 0xc9, 0x69, 0x7d, 0x07 );
DEFINE_GUID( GUID_DEVCLASS_ADAPTER,             0x4d36e964L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_APMSUPPORT,          0xd45b1c18L, 0xc8fa, 0x11d1, 0x9f, 0x77, 0x00, 0x00, 0xf8, 0x05, 0xf5, 0x30 );
DEFINE_GUID( GUID_DEVCLASS_AVC,                 0xc06ff265L, 0xae09, 0x48f0, 0x81, 0x2c, 0x16, 0x75, 0x3d, 0x7c, 0xba, 0x83 );
DEFINE_GUID( GUID_DEVCLASS_BATTERY,             0x72631e54L, 0x78a4, 0x11d0, 0xbc, 0xf7, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_DEVCLASS_BIOMETRIC,           0x53d29ef7L, 0x377c, 0x4d14, 0x86, 0x4b, 0xeb, 0x3a, 0x85, 0x76, 0x93, 0x59 );
DEFINE_GUID( GUID_DEVCLASS_BLUETOOTH,           0xe0cbf06cL, 0xcd8b, 0x4647, 0xbb, 0x8a, 0x26, 0x3b, 0x43, 0xf0, 0xf9, 0x74 );
DEFINE_GUID( GUID_DEVCLASS_CDROM,               0x4d36e965L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_COMPUTER,            0x4d36e966L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_DECODER,             0x6bdd1fc2L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_DISKDRIVE,           0x4d36e967L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_DISPLAY,             0x4d36e968L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_DOT4,                0x48721b56L, 0x6795, 0x11d2, 0xb1, 0xa8, 0x00, 0x80, 0xc7, 0x2e, 0x74, 0xa2 );
DEFINE_GUID( GUID_DEVCLASS_DOT4PRINT,           0x49ce6ac8L, 0x6f86, 0x11d2, 0xb1, 0xe5, 0x00, 0x80, 0xc7, 0x2e, 0x74, 0xa2 );
DEFINE_GUID( GUID_DEVCLASS_ENUM1394,            0xc459df55L, 0xdb08, 0x11d1, 0xb0, 0x09, 0x00, 0xa0, 0xc9, 0x08, 0x1f, 0xf6 );
DEFINE_GUID( GUID_DEVCLASS_FDC,                 0x4d36e969L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_FLOPPYDISK,          0x4d36e980L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_GPS,                 0x6bdd1fc3L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_HDC,                 0x4d36e96aL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_HIDCLASS,            0x745a17a0L, 0x74d3, 0x11d0, 0xb6, 0xfe, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda );
DEFINE_GUID( GUID_DEVCLASS_IMAGE,               0x6bdd1fc6L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_INFINIBAND,          0x30ef7132L, 0xd858, 0x4a0c, 0xac, 0x24, 0xb9, 0x02, 0x8a, 0x5c, 0xca, 0x3f );
DEFINE_GUID( GUID_DEVCLASS_INFRARED,            0x6bdd1fc5L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_KEYBOARD,            0x4d36e96bL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_LEGACYDRIVER,        0x8ecc055dL, 0x047f, 0x11d1, 0xa5, 0x37, 0x00, 0x00, 0xf8, 0x75, 0x3e, 0xd1 );
DEFINE_GUID( GUID_DEVCLASS_MEDIA,               0x4d36e96cL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MEDIUM_CHANGER,      0xce5939aeL, 0xebde, 0x11d0, 0xb1, 0x81, 0x00, 0x00, 0xf8, 0x75, 0x3e, 0xc4 );
DEFINE_GUID( GUID_DEVCLASS_MODEM,               0x4d36e96dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MONITOR,             0x4d36e96eL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MOUSE,               0x4d36e96fL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MTD,                 0x4d36e970L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MULTIFUNCTION,       0x4d36e971L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MULTIPORTSERIAL,     0x50906cb8L, 0xba12, 0x11d1, 0xbf, 0x5d, 0x00, 0x00, 0xf8, 0x05, 0xf5, 0x30 );
DEFINE_GUID( GUID_DEVCLASS_NET,                 0x4d36e972L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NETCLIENT,           0x4d36e973L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NETSERVICE,          0x4d36e974L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NETTRANS,            0x4d36e975L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NODRIVER,            0x4d36e976L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PCMCIA,              0x4d36e977L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PNPPRINTERS,         0x4658ee7eL, 0xf050, 0x11d1, 0xb6, 0xbd, 0x00, 0xc0, 0x4f, 0xa3, 0x72, 0xa7 );
DEFINE_GUID( GUID_DEVCLASS_PORTS,               0x4d36e978L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PRINTER,             0x4d36e979L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PRINTERUPGRADE,      0x4d36e97aL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PROCESSOR,           0x50127dc3L, 0x0f36, 0x415e, 0xa6, 0xcc, 0x4c, 0xb3, 0xbe, 0x91, 0x0B, 0x65 );
DEFINE_GUID( GUID_DEVCLASS_SBP2,                0xd48179beL, 0xec20, 0x11d1, 0xb6, 0xb8, 0x00, 0xc0, 0x4f, 0xa3, 0x72, 0xa7 );
DEFINE_GUID( GUID_DEVCLASS_SCSIADAPTER,         0x4d36e97bL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_SECURITYACCELERATOR, 0x268c95a1L, 0xedfe, 0x11d3, 0x95, 0xc3, 0x00, 0x10, 0xdc, 0x40, 0x50, 0xa5 );
DEFINE_GUID( GUID_DEVCLASS_SIDESHOW,            0x997b5d8dL, 0xc442, 0x4f2e, 0xba, 0xf3, 0x9c, 0x8e, 0x67, 0x1e, 0x9e, 0x21 );
DEFINE_GUID( GUID_DEVCLASS_SMARTCARDREADER,     0x50dd5230L, 0xba8a, 0x11d1, 0xbf, 0x5d, 0x00, 0x00, 0xf8, 0x05, 0xf5, 0x30 );
DEFINE_GUID( GUID_DEVCLASS_SOUND,               0x4d36e97cL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_SYSTEM,              0x4d36e97dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_TAPEDRIVE,           0x6d807884L, 0x7d21, 0x11cf, 0x80, 0x1c, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_UNKNOWN,             0x4d36e97eL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_USB,                 0x36fc9e60L, 0xc465, 0x11cf, 0x80, 0x56, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 );
DEFINE_GUID( GUID_DEVCLASS_VOLUME,              0x71a27cddL, 0x812a, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_VOLUMESNAPSHOT,      0x533c5b84L, 0xec70, 0x11d2, 0x95, 0x05, 0x00, 0xc0, 0x4f, 0x79, 0xde, 0xaf );
DEFINE_GUID( GUID_DEVCLASS_WCEUSBS,             0x25dbce51L, 0x6c8f, 0x4a72, 0x8a, 0x6d, 0xb5, 0x4c, 0x2b, 0x4f, 0xc8, 0x35 );
DEFINE_GUID( GUID_DEVCLASS_WPD,                 0xeec5ad98L, 0x8080, 0x425f, 0x92, 0x2a, 0xda, 0xbf, 0x3d, 0xe3, 0xf6, 0x9a );

//
// Define filesystem filter classes used for classification and load ordering.
// Classes are listed below in order from "highest" (i.e., farthest from the
// filesystem) to "lowest" (i.e., closest to the filesystem).
//
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_ACTIVITYMONITOR,         0xb86dff51L, 0xa31e, 0x4bac, 0xb3, 0xcf, 0xe8, 0xcf, 0xe7, 0x5c, 0x9f, 0xc2 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_UNDELETE,                0xfe8f1572L, 0xc67a, 0x48c0, 0xbb, 0xac, 0x0b, 0x5c, 0x6d, 0x66, 0xca, 0xfb );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_ANTIVIRUS,               0xb1d1a169L, 0xc54f, 0x4379, 0x81, 0xdb, 0xbe, 0xe7, 0xd8, 0x8d, 0x74, 0x54 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_REPLICATION,             0x48d3ebc4L, 0x4cf8, 0x48ff, 0xb8, 0x69, 0x9c, 0x68, 0xad, 0x42, 0xeb, 0x9f );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_CONTINUOUSBACKUP,        0x71aa14f8L, 0x6fad, 0x4622, 0xad, 0x77, 0x92, 0xbb, 0x9d, 0x7e, 0x69, 0x47 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_CONTENTSCREENER,         0x3e3f0674L, 0xc83c, 0x4558, 0xbb, 0x26, 0x98, 0x20, 0xe1, 0xeb, 0xa5, 0xc5 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_QUOTAMANAGEMENT,         0x8503c911L, 0xa6c7, 0x4919, 0x8f, 0x79, 0x50, 0x28, 0xf5, 0x86, 0x6b, 0x0c );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_SYSTEMRECOVERY,          0x2db15374L, 0x706e, 0x4131, 0xa0, 0xc7, 0xd7, 0xc7, 0x8e, 0xb0, 0x28, 0x9a );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_CFSMETADATASERVER,       0xcdcf0939L, 0xb75b, 0x4630, 0xbf, 0x76, 0x80, 0xf7, 0xba, 0x65, 0x58, 0x84 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_HSM,                     0xd546500aL, 0x2aeb, 0x45f6, 0x94, 0x82, 0xf4, 0xb1, 0x79, 0x9c, 0x31, 0x77 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_COMPRESSION,             0xf3586bafL, 0xb5aa, 0x49b5, 0x8d, 0x6c, 0x05, 0x69, 0x28, 0x4c, 0x63, 0x9f );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_ENCRYPTION,              0xa0a701c0L, 0xa511, 0x42ff, 0xaa, 0x6c, 0x06, 0xdc, 0x03, 0x95, 0x57, 0x6f );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_PHYSICALQUOTAMANAGEMENT, 0x6a0a8e78L, 0xbba6, 0x4fc4, 0xa7, 0x09, 0x1e, 0x33, 0xcd, 0x09, 0xd6, 0x7e );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_OPENFILEBACKUP,          0xf8ecafa6L, 0x66d1, 0x41a5, 0x89, 0x9b, 0x66, 0x58, 0x5d, 0x72, 0x16, 0xb7 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_SECURITYENHANCER,        0xd02bc3daL, 0x0c8e, 0x4945, 0x9b, 0xd5, 0xf1, 0x88, 0x3c, 0x22, 0x6c, 0x8c );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_COPYPROTECTION,          0x89786ff1L, 0x9c12, 0x402f, 0x9c, 0x9e, 0x17, 0x75, 0x3c, 0x7f, 0x43, 0x75 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_SYSTEM,                  0x5d1b9aaaL, 0x01e2, 0x46af, 0x84, 0x9f, 0x27, 0x2b, 0x3f, 0x32, 0x4c, 0x46 );
DEFINE_GUID( GUID_DEVCLASS_FSFILTER_INFRASTRUCTURE,          0xe55fa6f9L, 0x128c, 0x4d04, 0xab, 0xab, 0x63, 0x0c, 0x74, 0xb1, 0x45, 0x3a );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DEVPKEY.H ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devpkey.h

Abstract:

    Defines property keys for the Plug and Play Device Property API.

Environment:

    User and Kernel modes.


--*/

#include <devpropdef.h>

//
// DEVPKEY_NAME
// Common DEVPKEY used to retrieve the display name for an object.
//
DEFINE_DEVPROPKEY(DEVPKEY_NAME,                          0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac, 10);    // DEVPROP_TYPE_STRING


//
// Device properties
// These DEVPKEYs correspond to the SetupAPI SPDRP_XXX device properties.
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_DeviceDesc,             0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 2);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_HardwareIds,            0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 3);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_CompatibleIds,          0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 4);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_Service,                0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 6);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_Class,                  0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 9);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_ClassGuid,              0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 10);    // DEVPROP_TYPE_GUID
DEFINE_DEVPROPKEY(DEVPKEY_Device_Driver,                 0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 11);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_ConfigFlags,            0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 12);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_Manufacturer,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 13);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_FriendlyName,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 14);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_LocationInfo,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 15);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_PDOName,                0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 16);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_Capabilities,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 17);    // DEVPROP_TYPE_UNINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_UINumber,               0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 18);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_UpperFilters,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 19);    // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_LowerFilters,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 20);    // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_BusTypeGuid,            0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 21);    // DEVPROP_TYPE_GUID
DEFINE_DEVPROPKEY(DEVPKEY_Device_LegacyBusType,          0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 22);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_BusNumber,              0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 23);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_EnumeratorName,         0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 24);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_Security,               0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 25);    // DEVPROP_TYPE_SECURITY_DESCRIPTOR
DEFINE_DEVPROPKEY(DEVPKEY_Device_SecuritySDS,            0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 26);    // DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DevType,                0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 27);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_Exclusive,              0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 28);    // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_Device_Characteristics,        0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 29);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_Address,                0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 30);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_UINumberDescFormat,     0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 31);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_PowerData,              0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 32);    // DEVPROP_TYPE_BINARY
DEFINE_DEVPROPKEY(DEVPKEY_Device_RemovalPolicy,          0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 33);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_RemovalPolicyDefault,   0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 34);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_RemovalPolicyOverride,  0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 35);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_InstallState,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 36);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_LocationPaths,          0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 37);    // DEVPROP_TYPE_STRING_LIST

//
// Device properties
// These DEVPKEYs correspond to a device's status and problem code.
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_DevNodeStatus,          0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 2);     // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_ProblemCode,            0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 3);     // DEVPROP_TYPE_UINT32

//
// Device properties
// These DEVPKEYs correspond to a device's relations.
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_EjectionRelations,      0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 4);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_RemovalRelations,       0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 5);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_PowerRelations,         0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 6);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_BusRelations,           0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 7);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_Parent,                 0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 8);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_Children,               0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 9);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_Siblings,               0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 10);    // DEVPROP_TYPE_STRING_LIST

//
// Other Device properties
// These DEVPKEYs are set for the corresponding types of root-enumerated devices.     ;comment
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_Reported,               0x80497100, 0x8c73, 0x48b9, 0xaa, 0xd9, 0xce, 0x38, 0x7e, 0x19, 0xc5, 0x6e, 2);     // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_Device_Legacy,                 0x80497100, 0x8c73, 0x48b9, 0xaa, 0xd9, 0xce, 0x38, 0x7e, 0x19, 0xc5, 0x6e, 3);     // DEVPROP_TYPE_BOOLEAN

//
// Device Instance Id
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_InstanceId,             0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 256);   // DEVPROP_TYPE_STRING

//
// Other Device properties
//
DEFINE_DEVPROPKEY(DEVPKEY_Numa_Proximity_Domain,         0x540b947e, 0x8b40, 0x45bc, 0xa8, 0xa2, 0x6a, 0x0b, 0x89, 0x4c, 0xbd, 0xa2, 1);     // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_DHP_Rebalance_Policy,   0x540b947e, 0x8b40, 0x45bc, 0xa8, 0xa2, 0x6a, 0x0b, 0x89, 0x4c, 0xbd, 0xa2, 2);     // DEVPROP_TYPE_UINT32

//
// Device Session Id
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_SessionId,              0x83da6326, 0x97a6, 0x4088, 0x94, 0x53, 0xa1, 0x92, 0x3f, 0x57, 0x3b, 0x29, 6);     // DEVPROP_TYPE_UINT32

//
// Device driver properties
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverDate,             0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 2);      // DEVPROP_TYPE_FILETIME
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverVersion,          0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 3);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverDesc,             0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 4);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverInfPath,          0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 5);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverInfSection,       0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 6);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverInfSectionExt,    0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 7);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_MatchingDeviceId,       0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 8);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverProvider,         0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 9);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverPropPageProvider, 0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 10);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverCoInstallers,     0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 11);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_ResourcePickerTags,     0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 12);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_ResourcePickerExceptions, 0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 13);   // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverRank,             0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 14);     // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverLogoLevel,        0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 15);     // DEVPROP_TYPE_UINT32

//
// Device properties
// These DEVPKEYs may be set by the driver package installed for a device.
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_NoConnectSound,         0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 17);     // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_Device_GenericDriverInstalled, 0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 18);     // DEVPROP_TYPE_BOOLEAN

//
// Device properties
// These DEVPKEYs may be set by the driver package installed for a device.
//
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_Model,                  0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 2);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_VendorWebSite,          0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 3);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_DetailedDescription,    0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 4);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_DocumentationLink,      0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 5);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_Icon,                   0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 6);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_BrandingIcon,           0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 7);     // DEVPROP_TYPE_STRING_LIST


//
// Device setup class properties
// These DEVPKEYs correspond to the SetupAPI SPCRP_XXX setup class properties.
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_UpperFilters,      0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 19);    // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_LowerFilters,      0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 20);    // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Security,          0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 25);    // DEVPROP_TYPE_SECURITY_DESCRIPTOR
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_SecuritySDS,       0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 26);    // DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_DevType,           0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 27);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Exclusive,         0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 28);    // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Characteristics,   0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 29);    // DEVPROP_TYPE_UINT32

//
// Device setup class properties
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Name,              0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 2);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_ClassName,         0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 3);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Icon,              0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 4);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_ClassInstaller,    0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 5);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_PropPageProvider,  0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 6);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_NoInstallClass,    0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 7);      // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_NoDisplayClass,    0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 8);      // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_SilentInstall,     0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 9);      // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_NoUseClass,        0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 10);     // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_DefaultService,    0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 11);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_IconPath,          0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 12);     // DEVPROP_TYPE_STRING_LIST

DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_DHPRebalanceOptOut, 0xd14d3ef3, 0x66cf, 0x4ba2, 0x9d, 0x38, 0x0d, 0xdb, 0x37, 0xab, 0x47, 0x01, 2);    // DEVPROP_TYPE_BOOLEAN

//
// Other Device setup class properties
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_ClassCoInstallers, 0x713d1703, 0xa2e2, 0x49f5, 0x92, 0x14, 0x56, 0x47, 0x2e, 0xf3, 0xda, 0x5c, 2);     // DEVPROP_TYPE_STRING_LIST


//
// Device interface properties
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceInterface_FriendlyName,  0x026e516e, 0xb814, 0x414b, 0x83, 0xcd, 0x85, 0x6d, 0x6f, 0xef, 0x48, 0x22, 2);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceInterface_Enabled,       0x026e516e, 0xb814, 0x414b, 0x83, 0xcd, 0x85, 0x6d, 0x6f, 0xef, 0x48, 0x22, 3);     // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceInterface_ClassGuid,     0x026e516e, 0xb814, 0x414b, 0x83, 0xcd, 0x85, 0x6d, 0x6f, 0xef, 0x48, 0x22, 4);     // DEVPROP_TYPE_GUID


//
// Device interface class properties
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceInterfaceClass_DefaultInterface,  0x14c83a99, 0x0b3f, 0x44b7, 0xbe, 0x4c, 0xa1, 0x78, 0xd3, 0x99, 0x05, 0x64, 2); // DEVPROP_TYPE_STRING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ddrawi.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawi.h
 *  Content:    DirectDraw internal header file
 *      Used by DirectDraw and by the display drivers.
 *
 ***************************************************************************/
#ifndef __DDRAWI_INCLUDED__
#define __DDRAWI_INCLUDED__

//
// This is a helper for external driver builds.
//
#if (!defined(WIN95)) && (!defined(WINNT))
#define WIN95
#endif

/*
 * METAQUESTION: Why are Windows handles stored as DWORDs instead of
 *       their proper types?
 * METAANSWER:   To make the thunk to the 16-bit side completely painless.
 */

#define OBJECT_ISROOT           0x80000000l // object is root object

/*
 * stuff for drivers
 */
#ifndef _WIN32
typedef long    HRESULT;
typedef LPVOID  REFIID;
#ifndef GUID_DEFINED
    #define GUID_DEFINED
    typedef struct _GUID {
        ULONG   Data1;
        unsigned short Data2;
        unsigned short Data3;
        unsigned char Data4[8];
    } GUID;
#endif // !defined(GUID_DEFINED)

typedef GUID FAR *LPGUID;
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#define PULONG_PTR   LPDWORD
#endif //MAXULONG_PTR

    #include "ddraw.h"
    #include "dvp.h"
    #include "ddkernel.h"
#include "dmemmgr.h"

#ifdef IS_16
// ddraw16 16-bit compiler cannot handle 32-bit d3d headers included by d3dhal.h
// so for ddraw16 build, explicitly list d3dhal ptr types here
#define LPD3DHAL_GLOBALDRIVERDATA   ULONG_PTR
#define LPD3DHAL_CALLBACKS          ULONG_PTR
#define LPD3DHAL_CALLBACKS2         ULONG_PTR
#define LPD3DHAL_CALLBACKS3         ULONG_PTR
#define LPD3DHAL_D3DEXTENDEDCAPS    ULONG_PTR
#define LPD3DHAL_COMMANDBUFFERCALLBACKS ULONG_PTR
#endif

#ifndef _WIN32
/*
 * these error codes are DIFFERENT in Win32 and Win16!!!!
 */
#undef  E_NOTIMPL
#undef  E_OUTOFMEMORY
#undef  E_INVALIDARG
#undef  E_FAIL
#define E_NOTIMPL                        0x80004001L
#define E_OUTOFMEMORY                    0x8007000EL
#define E_INVALIDARG                     0x80070057L
#define E_FAIL                           0x80004005L
#endif


#define DDUNSUPPORTEDMODE       ((DWORD) -1)


#define VALID_ALIGNMENT( align ) (!((align == 0) || (align % 2) != 0 ))

#ifdef _WIN32
/*
 * These GUIDs are used to identify driver info structures, not interfaces,
 * so the prefix GUID_ is used instead of IID_.
 *
 */

DEFINE_GUID( GUID_MiscellaneousCallbacks,       0xefd60cc0, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_VideoPortCallbacks,       0xefd60cc1, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_ColorControlCallbacks,    0xefd60cc2, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_VideoPortCaps,            0xefd60cc3, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks2,        0x0ba584e1, 0x70b6, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks3,                0xddf41230, 0xec0a, 0x11d0, 0xa9, 0xb6, 0x00, 0xaa, 0x00, 0xc0, 0x99, 0x3e);
DEFINE_GUID( GUID_NonLocalVidMemCaps,       0x86c4fa80, 0x8d84, 0x11d0, 0x94, 0xe8, 0x00, 0xc0, 0x4f, 0xc3, 0x41, 0x37);
DEFINE_GUID( GUID_KernelCallbacks,      0x80863800, 0x6B06, 0x11D0, 0x9B, 0x06, 0x0, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_KernelCaps,           0xFFAA7540, 0x7AA8, 0x11D0, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_D3DExtendedCaps,      0x7de41f80, 0x9d93, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( GUID_ZPixelFormats,        0x93869880, 0x36cf, 0x11d1, 0x9b, 0x1b, 0x0, 0xaa, 0x0, 0xbb, 0xb8, 0xae);
DEFINE_GUID( GUID_DDMoreSurfaceCaps,        0x3b8a0466, 0xf269, 0x11d1, 0x88, 0x0b, 0x0, 0xc0, 0x4f, 0xd9, 0x30, 0xc5);
DEFINE_GUID( GUID_DDStereoMode,          0xf828169c, 0xa8e8, 0x11d2, 0xa1, 0xf2, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_OptSurfaceKmodeInfo,      0xe05c8472, 0x51d4, 0x11d1, 0x8c, 0xce, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_OptSurfaceUmodeInfo,      0x9d792804, 0x5fa8, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_UserModeDriverInfo,       0xf0b0e8e2, 0x5f97, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_UserModeDriverPassword,   0x97f861b6, 0x60a1, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID(GUID_D3DParseUnknownCommandCallback, 0x2e04ffa0, 0x98e4, 0x11d1, 0x8c, 0xe1, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_MotionCompCallbacks,      0xb1122b40, 0x5dA5, 0x11d1, 0x8f, 0xcF, 0x00, 0xc0, 0x4f, 0xc2, 0x9b, 0x4e);
DEFINE_GUID( GUID_Miscellaneous2Callbacks,  0x406B2F00, 0x3E5A, 0x11D1, 0xB6, 0x40, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x6A);
#endif //_WIN32

// The Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
#ifdef __cplusplus
extern "C"
#endif
HRESULT CALLBACK D3DParseUnknownCommand (LPVOID lpvCommands,
                                         LPVOID *lplpvReturnedCommand);
/*
 * This DDPF flag is used by drivers to signify that this format is new and may be
 * a candidate for hiding from certain applications
 * KEEP THIS DEFINITION IN SYNC WITH THAT OF DDPF_RESERVED1 IN DDRAW.H
 */
#define DDPF_NOVEL_TEXTURE_FORMAT                               0x00100000l


/*
 * This DDPF flag is used to indicate a DX8+ format capability entry in
 * the texture format list. It is not visible to applications.
 */
#define DDPF_D3DFORMAT                                          0x00200000l

/*
 * List of operations supported on formats in DX8+ texture list.
 * See the DX8 DDK for a complete description of these flags.
 */
#define D3DFORMAT_OP_TEXTURE                    0x00000001L
#define D3DFORMAT_OP_VOLUMETEXTURE              0x00000002L
#define D3DFORMAT_OP_CUBETEXTURE                0x00000004L
#define D3DFORMAT_OP_OFFSCREEN_RENDERTARGET     0x00000008L
#define D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET   0x00000010L
#define D3DFORMAT_OP_ZSTENCIL                   0x00000040L
#define D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L

// This format can be used as a render target if the current display mode
// is the same depth if the alpha channel is ignored. e.g. if the device 
// can render to A8R8G8B8 when the display mode is X8R8G8B8, then the
// format op list entry for A8R8G8B8 should have this cap. 
#define D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET 0x00000100L

// This format contains DirectDraw support (including Flip).  This flag
// should not to be set on alpha formats.
#define D3DFORMAT_OP_DISPLAYMODE                0x00000400L

// The rasterizer can support some level of Direct3D support in this format
// and implies that the driver can create a Context in this mode (for some 
// render target format).  When this flag is set, the D3DFORMAT_OP_DISPLAYMODE
// flag must also be set.
#define D3DFORMAT_OP_3DACCELERATION             0x00000800L

// If the driver needs a private format to be D3D or driver manageable,
// then it needs to tell D3D the pixelsize in bits per pixel by setting
// dwPrivateFormatBitCount in DDPIXELFORMAT and by setting the below
// format op. If the below format op is not set, then D3D or the driver
// will NOT be allowed to manage the format.
#define D3DFORMAT_OP_PIXELSIZE                  0x00001000L

// Indicates that this format can be converted to any RGB format for which
// D3DFORMAT_MEMBEROFGROUP_ARGB is specified
#define D3DFORMAT_OP_CONVERT_TO_ARGB            0x00002000L

// Indicates that this format can be used to create offscreen plain surfaces.
#define D3DFORMAT_OP_OFFSCREENPLAIN             0x00004000L

// Indicated that this format can be read as an SRGB texture (meaning that the
// sampler will linearize the looked up data)
#define D3DFORMAT_OP_SRGBREAD                   0x00008000L

// Indicates that this format can be used in the bumpmap instructions
#define D3DFORMAT_OP_BUMPMAP                    0x00010000L

// Indicates that this format can be sampled by the displacement map sampler
#define D3DFORMAT_OP_DMAP                       0x00020000L

// Indicates that this format cannot be used with texture filtering
#define D3DFORMAT_OP_NOFILTER                   0x00040000L

// Indicates that format conversions are supported to this RGB format if
// D3DFORMAT_OP_CONVERT_TO_ARGB is specified in the source format.
#define D3DFORMAT_MEMBEROFGROUP_ARGB            0x00080000L

// Indicated that this format can be written as an SRGB target (meaning that the
// pixel pipe will DE-linearize data on output to format)
#define D3DFORMAT_OP_SRGBWRITE                  0x00100000L

// Indicates that this format cannot be used with alpha blending
#define D3DFORMAT_OP_NOALPHABLEND               0x00200000L

//Indicates that the device can auto-generated sublevels for resources
//of this format
#define D3DFORMAT_OP_AUTOGENMIPMAP              0x00400000L

// Indicates that this format cannot be used by vertex texture sampler
#define D3DFORMAT_OP_VERTEXTEXTURE              0x00800000L 

// Indicates that this format supports neither texture coordinate wrap modes, nor mipmapping
#define D3DFORMAT_OP_NOTEXCOORDWRAPNORMIP		0x01000000L


/*
 * List of processes attached to a DirectDraw object
 */
typedef struct _PROCESS_LIST
{
    struct _PROCESS_LIST    FAR *lpLink;
    DWORD           dwProcessId;
    DWORD           dwRefCnt;
    DWORD           dwAlphaDepth;
    DWORD           dwZDepth;
} PROCESS_LIST;
typedef PROCESS_LIST    FAR *LPPROCESS_LIST;

/*
 * Information about the refresh rates that monitor/display card can support
 */
typedef struct _DDMONITORINFO
{
    WORD    Manufacturer;       // Montor manufacturer
    WORD    Product;            // Monitor product ID
    DWORD   SerialNumber;       // Monitor serial number
    GUID    DeviceIdentifier;   // From DDDEVICEIDENTIFIER, describes card/driver
    int     Mode640x480;        // Highest refresh rate support, 0 if none, -1 if untested
    int     Mode800x600;
    int     Mode1024x768;
    int     Mode1280x1024;
    int     Mode1600x1200;
    int     ModeReserved1;
    int     ModeReserved2;
    int     ModeReserved3;
} DDMONITORINFO, FAR *LPDDMONITORINFO;


/*
 * DeleteFromActiveProcessList return codes
 */
#define DELETED_OK          0
#define DELETED_LASTONE         1
#define DELETED_NOTFOUND        2

#define DDBLT_ANYALPHA \
        (DDBLT_ALPHASRCSURFACEOVERRIDE | \
        DDBLT_ALPHASRCCONSTOVERRIDE | \
        DDBLT_ALPHASRC | \
        DDBLT_ALPHADESTSURFACEOVERRIDE | \
        DDBLT_ALPHADESTCONSTOVERRIDE | \
        DDBLT_ALPHADEST)

#define DDOVER_ANYALPHA \
        (DDOVER_ALPHASRCSURFACEOVERRIDE | \
        DDOVER_ALPHASRCCONSTOVERRIDE | \
        DDOVER_ALPHASRC | \
        DDOVER_ALPHADESTSURFACEOVERRIDE | \
        DDOVER_ALPHADESTCONSTOVERRIDE | \
        DDOVER_ALPHADEST)


typedef struct IDirectDrawClipperVtbl DIRECTDRAWCLIPPERCALLBACKS;
typedef struct IDirectDrawPaletteVtbl DIRECTDRAWPALETTECALLBACKS;
typedef struct IDirectDrawSurfaceVtbl DIRECTDRAWSURFACECALLBACKS;
typedef struct IDirectDrawSurface2Vtbl DIRECTDRAWSURFACE2CALLBACKS;
typedef struct IDirectDrawSurface3Vtbl DIRECTDRAWSURFACE3CALLBACKS;
typedef struct IDirectDrawSurface4Vtbl DIRECTDRAWSURFACE4CALLBACKS;
typedef struct IDirectDrawSurface7Vtbl DIRECTDRAWSURFACE7CALLBACKS;
typedef struct IDirectDrawColorControlVtbl DIRECTDRAWCOLORCONTROLCALLBACKS;
typedef struct IDirectDrawVtbl DIRECTDRAWCALLBACKS;
typedef struct IDirectDraw2Vtbl DIRECTDRAW2CALLBACKS;
typedef struct IDirectDraw4Vtbl DIRECTDRAW4CALLBACKS;
typedef struct IDirectDraw7Vtbl DIRECTDRAW7CALLBACKS;
typedef struct IDirectDrawKernelVtbl DIRECTDRAWKERNELCALLBACKS;
typedef struct IDirectDrawSurfaceKernelVtbl DIRECTDRAWSURFACEKERNELCALLBACKS;
typedef struct IDirectDrawGammaControlVtbl DIRECTDRAWGAMMACONTROLCALLBACKS;


typedef DIRECTDRAWCLIPPERCALLBACKS FAR *LPDIRECTDRAWCLIPPERCALLBACKS;
typedef DIRECTDRAWPALETTECALLBACKS FAR *LPDIRECTDRAWPALETTECALLBACKS;
typedef DIRECTDRAWSURFACECALLBACKS FAR *LPDIRECTDRAWSURFACECALLBACKS;
typedef DIRECTDRAWCALLBACKS FAR *LPDIRECTDRAWCALLBACKS;

#ifdef __cplusplus
extern "C" {
#endif

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #undef IS_32
    #define IS_32
    #define DDAPI       WINAPI
    #define EXTERN_DDAPI    WINAPI
#else
    #define DDAPI       __loadds WINAPI
    #define EXTERN_DDAPI    __export WINAPI
#endif


/*
 * DCI escape
 */
#ifndef DCICOMMAND
#define DCICOMMAND      3075        // escape value
#endif

/*
 * this is the DirectDraw version
 * passed to the driver in DCICMD.dwVersion
 *
 * Most older HALs will fail if DD_VERSION does not match what they
 * are expecting.  Therefore, DD_VERSION cannot change if we want DX5+ to
 * run on DX2/3 HALs.  For this reason, we added a new version call that
 * allows the HAL to know the real version of DirectDraw, which is equal
 * to DD_RUNTIME_VERSION.  This is for informational purposes only.  HALs
 * should not fail DirectDraw if they receive an unknown DirectDraw runtime
 * version.
 */
#define DD_VERSION              0x00000200l
#define DD_RUNTIME_VERSION      0x00000902l

/*
 * this is the HAL version.
 * the driver returns this number from QUERYESCSUPPORT/DCICOMMAND
 */
#define DD_HAL_VERSION          0x0100

#include "dciddi.h"

#define DDCREATEDRIVEROBJECT    10      // create an object
#define DDGET32BITDRIVERNAME    11      // get a 32-bit driver name
#define DDNEWCALLBACKFNS    12      // new callback fns coming
#define DDVERSIONINFO       13      // tells driver the ddraw version

typedef struct
{
    char    szName[260];            // 32-bit driver name
    char    szEntryPoint[64];       // entry point
    DWORD   dwContext;          // context to pass to entry point
} DD32BITDRIVERDATA, FAR *LPDD32BITDRIVERDATA;

typedef struct
{
    DWORD    dwHALVersion;           // Version of DirectDraw for which the HAL was created
    ULONG_PTR dwReserved1;            // Reserved for future use
    ULONG_PTR dwReserved2;            // Reserved for future use
} DDVERSIONDATA, FAR *LPDDVERSIONDATA;

typedef DWORD   (FAR PASCAL *LPDD32BITDRIVERINIT)(DWORD dwContext);

/*
 * pointer to video meory
 */
typedef ULONG_PTR FLATPTR;

/*
 * indicates that DDRAW.DLL has been unloaded...
 */
#define DDRAW_DLL_UNLOADED  (LPVOID) 1

/*
 * critical section types
 */
typedef LPVOID      CSECT_HANDLE;
#ifdef NOUSE_CRITSECTS
typedef xxx         CSECT;          // generate an error for now
#else
#if defined( IS_32 ) && !defined( _NOCSECT_TYPE )
typedef CRITICAL_SECTION    CSECT;
typedef CSECT           *LPCSECT;
#else
typedef struct
{
    DWORD   vals[6];
} CSECT;
typedef void            FAR *LPCSECT;
#endif
#endif

/*
 * DLL names
 */
#define DDHAL_DRIVER_DLLNAME    "DDRAW16.DLL"
#define DDHAL_APP_DLLNAME   "DDRAW.DLL"

/*
 * maximum size of a driver name
 */
#ifndef CCHDEVICENAME
#define CCHDEVICENAME 32
#endif
#define MAX_DRIVER_NAME     CCHDEVICENAME

/*
 * largest palette supported
 */
#define MAX_PALETTE_SIZE    256

/*
 * maximum number of surfaces that can be autoflipped between
 */
#define MAX_AUTOFLIP_BUFFERS    10

/*
 * Indicates the surface is an execute buffer, i.e., a linear chunk of system
 * or video memory that holds a Direct3D display list. A driver reports this
 * cap to indicate that it can create execute buffers in video memory and
 * Direct3D uses this bit to request execute buffers. However, it is not
 * visible to via the API.
 */
#define DDSCAPS_EXECUTEBUFFER                   DDSCAPS_RESERVED2
/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * a vertex buffer. Used by CreateVertexBuffer in D3D
 */
#define DDSCAPS2_VERTEXBUFFER                   DDSCAPS2_RESERVED1

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * a command buffer. Used by internally in D3D
 */
#define DDSCAPS2_COMMANDBUFFER                  DDSCAPS2_RESERVED2

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * an index buffer.
 */
#define DDSCAPS2_INDEXBUFFER                    DDSCAPS2_RESERVED3

/*
 * Indicates to the driver that the render target contains video data
 */
#define DDSCAPS3_VIDEO                          DDSCAPS3_RESERVED2


/*
 * Internal formats are not exposed to applications.
 */

#define D3DFMT_INTERNAL_D32                  71
#define D3DFMT_INTERNAL_S1D15                72
#define D3DFMT_INTERNAL_D15S1                73
#define D3DFMT_INTERNAL_S8D24                74
#define D3DFMT_INTERNAL_D24S8                75
#define D3DFMT_INTERNAL_X8D24                76
#define D3DFMT_INTERNAL_D24X8                77



/*
 * pre-declare pointers to structs containing data for DDHAL fns
 */
typedef struct _DDHAL_CREATEPALETTEDATA FAR *LPDDHAL_CREATEPALETTEDATA;
typedef struct _DDHAL_CREATESURFACEDATA FAR *LPDDHAL_CREATESURFACEDATA;
typedef struct _DDHAL_CANCREATESURFACEDATA FAR *LPDDHAL_CANCREATESURFACEDATA;
typedef struct _DDHAL_WAITFORVERTICALBLANKDATA FAR *LPDDHAL_WAITFORVERTICALBLANKDATA;
typedef struct _DDHAL_DESTROYDRIVERDATA FAR *LPDDHAL_DESTROYDRIVERDATA;
typedef struct _DDHAL_SETMODEDATA FAR *LPDDHAL_SETMODEDATA;
typedef struct _DDHAL_DRVSETCOLORKEYDATA FAR *LPDDHAL_DRVSETCOLORKEYDATA;
typedef struct _DDHAL_GETSCANLINEDATA FAR *LPDDHAL_GETSCANLINEDATA;

typedef struct _DDHAL_DESTROYPALETTEDATA FAR *LPDDHAL_DESTROYPALETTEDATA;
typedef struct _DDHAL_SETENTRIESDATA FAR *LPDDHAL_SETENTRIESDATA;

typedef struct _DDHAL_BLTDATA FAR *LPDDHAL_BLTDATA;
typedef struct _DDHAL_LOCKDATA FAR *LPDDHAL_LOCKDATA;
typedef struct _DDHAL_UNLOCKDATA FAR *LPDDHAL_UNLOCKDATA;
typedef struct _DDHAL_UPDATEOVERLAYDATA FAR *LPDDHAL_UPDATEOVERLAYDATA;
typedef struct _DDHAL_SETOVERLAYPOSITIONDATA FAR *LPDDHAL_SETOVERLAYPOSITIONDATA;
typedef struct _DDHAL_SETPALETTEDATA FAR *LPDDHAL_SETPALETTEDATA;
typedef struct _DDHAL_FLIPDATA FAR *LPDDHAL_FLIPDATA;
typedef struct _DDHAL_DESTROYSURFACEDATA FAR *LPDDHAL_DESTROYSURFACEDATA;
typedef struct _DDHAL_SETCLIPLISTDATA FAR *LPDDHAL_SETCLIPLISTDATA;
typedef struct _DDHAL_ADDATTACHEDSURFACEDATA FAR *LPDDHAL_ADDATTACHEDSURFACEDATA;
typedef struct _DDHAL_SETCOLORKEYDATA FAR *LPDDHAL_SETCOLORKEYDATA;
typedef struct _DDHAL_GETBLTSTATUSDATA FAR *LPDDHAL_GETBLTSTATUSDATA;
typedef struct _DDHAL_GETFLIPSTATUSDATA FAR *LPDDHAL_GETFLIPSTATUSDATA;
typedef struct _DDHAL_SETEXCLUSIVEMODEDATA FAR *LPDDHAL_SETEXCLUSIVEMODEDATA;
typedef struct _DDHAL_FLIPTOGDISURFACEDATA FAR *LPDDHAL_FLIPTOGDISURFACEDATA;

typedef struct _DDHAL_CANCREATEVPORTDATA FAR *LPDDHAL_CANCREATEVPORTDATA;
typedef struct _DDHAL_CREATEVPORTDATA FAR *LPDDHAL_CREATEVPORTDATA;
typedef struct _DDHAL_FLIPVPORTDATA FAR *LPDDHAL_FLIPVPORTDATA;
typedef struct _DDHAL_GETVPORTCONNECTDATA FAR *LPDDHAL_GETVPORTCONNECTDATA;
typedef struct _DDHAL_GETVPORTBANDWIDTHDATA FAR *LPDDHAL_GETVPORTBANDWIDTHDATA;
typedef struct _DDHAL_GETVPORTINPUTFORMATDATA FAR *LPDDHAL_GETVPORTINPUTFORMATDATA;
typedef struct _DDHAL_GETVPORTOUTPUTFORMATDATA FAR *LPDDHAL_GETVPORTOUTPUTFORMATDATA;
typedef struct _DDHAL_GETVPORTFIELDDATA FAR *LPDDHAL_GETVPORTFIELDDATA;
typedef struct _DDHAL_GETVPORTLINEDATA FAR *LPDDHAL_GETVPORTLINEDATA;
typedef struct _DDHAL_DESTROYVPORTDATA FAR *LPDDHAL_DESTROYVPORTDATA;
typedef struct _DDHAL_GETVPORTFLIPSTATUSDATA FAR *LPDDHAL_GETVPORTFLIPSTATUSDATA;
typedef struct _DDHAL_UPDATEVPORTDATA FAR *LPDDHAL_UPDATEVPORTDATA;
typedef struct _DDHAL_WAITFORVPORTSYNCDATA FAR *LPDDHAL_WAITFORVPORTSYNCDATA;
typedef struct _DDHAL_GETVPORTSIGNALDATA FAR *LPDDHAL_GETVPORTSIGNALDATA;
typedef struct _DDHAL_VPORTCOLORDATA FAR *LPDDHAL_VPORTCOLORDATA;

typedef struct _DDHAL_COLORCONTROLDATA FAR *LPDDHAL_COLORCONTROLDATA;

typedef struct _DDHAL_GETAVAILDRIVERMEMORYDATA FAR *LPDDHAL_GETAVAILDRIVERMEMORYDATA;
typedef struct _DDHAL_UPDATENONLOCALHEAPDATA FAR *LPDDHAL_UPDATENONLOCALHEAPDATA;
typedef struct _DDHAL_GETHEAPALIGNMENTDATA FAR *LPDDHAL_GETHEAPALIGNMENTDATA;

typedef struct _DDHAL_GETDRIVERINFODATA FAR *LPDDHAL_GETDRIVERINFODATA;

typedef struct _DDHAL_SYNCSURFACEDATA FAR *LPDDHAL_SYNCSURFACEDATA;
typedef struct _DDHAL_SYNCVIDEOPORTDATA FAR *LPDDHAL_SYNCVIDEOPORTDATA;

typedef struct _DDHAL_GETMOCOMPGUIDSDATA FAR *LPDDHAL_GETMOCOMPGUIDSDATA;
typedef struct _DDHAL_GETMOCOMPFORMATSDATA FAR *LPDDHAL_GETMOCOMPFORMATSDATA;
typedef struct _DDHAL_CREATEMOCOMPDATA FAR *LPDDHAL_CREATEMOCOMPDATA;
typedef struct _DDHAL_GETMOCOMPCOMPBUFFDATA FAR *LPDDHAL_GETMOCOMPCOMPBUFFDATA;
typedef struct _DDHAL_GETINTERNALMOCOMPDATA FAR *LPDDHAL_GETINTERNALMOCOMPDATA;
typedef struct _DDHAL_BEGINMOCOMPFRAMEDATA FAR *LPDDHAL_BEGINMOCOMPFRAMEDATA;
typedef struct _DDHAL_ENDMOCOMPFRAMEDATA FAR *LPDDHAL_ENDMOCOMPFRAMEDATA;
typedef struct _DDHAL_RENDERMOCOMPDATA FAR *LPDDHAL_RENDERMOCOMPDATA;
typedef struct _DDHAL_QUERYMOCOMPSTATUSDATA FAR *LPDDHAL_QUERYMOCOMPSTATUSDATA;
typedef struct _DDHAL_DESTROYMOCOMPDATA FAR *LPDDHAL_DESTROYMOCOMPDATA;

typedef struct _DDHAL_CREATESURFACEEXDATA FAR *LPDDHAL_CREATESURFACEEXDATA;
typedef struct _DDHAL_GETDRIVERSTATEDATA FAR *LPDDHAL_GETDRIVERSTATEDATA;
typedef struct _DDHAL_DESTROYDDLOCALDATA FAR *LPDDHAL_DESTROYDDLOCALDATA;

/*
 * value in the fpVidMem; indicates dwBlockSize is valid (surface object)
 */
#define DDHAL_PLEASEALLOC_BLOCKSIZE 0x00000002l


/*
 * Values in fpVidMem: Indicates dwLinearSizde is valid.
 * THIS VALUE CAN ONLY BE USED BY A D3D Optimize DRIVER FUNCTION
 * IT IS INVALID FOR A DRIVER TO RETURN THIS VALUE FROM CreateSurface32.
 */
#define DDHAL_PLEASEALLOC_LINEARSIZE    0x00000003l

/*
 * DRIVER SERVICES
 *
 * These services exported from ddraw.dll can be called by the HAL.
 * They are intended for use by the d3d Optimize HAL call.
 */
extern HRESULT DDAPI LateAllocateSurfaceMem(
    LPDIRECTDRAWSURFACE lpSurface,
    DWORD dwPleaseAllocType,
    DWORD dwWidthInBytesOrSize,
    DWORD dwHeight);

LPDIRECTDRAWSURFACE GetNextMipMap(
    LPDIRECTDRAWSURFACE lpLevel);
/*
 * video memory data structures (passed in DDHALINFO)
 */
typedef struct _VIDMEM
{
    DWORD       dwFlags;    // flags
    FLATPTR     fpStart;    // start of memory chunk
    union
    {
    FLATPTR     fpEnd;      // end of memory chunk
    DWORD       dwWidth;    // width of chunk (rectanglar memory)
    };
    DDSCAPS     ddsCaps;        // what this memory CANNOT be used for
    DDSCAPS     ddsCapsAlt; // what this memory CANNOT be used for if it must
    union
    {
    LPVMEMHEAP  lpHeap;     // heap pointer, used by DDRAW
    DWORD       dwHeight;   // height of chunk (rectanguler memory)
    };
} VIDMEM;
typedef VIDMEM FAR *LPVIDMEM;

/*
 * flags for vidmem struct
 */
#define VIDMEM_ISLINEAR         0x00000001l     // heap is linear
#define VIDMEM_ISRECTANGULAR    0x00000002l     // heap is rectangular
#define VIDMEM_ISHEAP           0x00000004l     // heap is preallocated by driver
#define VIDMEM_ISNONLOCAL       0x00000008l     // heap populated with non-local video memory
#define VIDMEM_ISWC             0x00000010l     // heap populated with write combining memory
#define VIDMEM_HEAPDISABLED     0x00000020l     // heap disabled

typedef struct _VIDMEMINFO
{
/* 0*/ FLATPTR      fpPrimary;      // pointer to primary surface
/* 4*/ DWORD        dwFlags;        // flags
/* 8*/ DWORD        dwDisplayWidth;     // current display width
/* c*/ DWORD        dwDisplayHeight;    // current display height
/*10*/ LONG     lDisplayPitch;      // current display pitch
/*14*/ DDPIXELFORMAT    ddpfDisplay;        // pixel format of display
/*34*/ DWORD        dwOffscreenAlign;   // byte alignment for offscreen surfaces
/*38*/ DWORD        dwOverlayAlign;     // byte alignment for overlays
/*3c*/ DWORD        dwTextureAlign;     // byte alignment for textures
/*40*/ DWORD        dwZBufferAlign;     // byte alignment for z buffers
/*44*/ DWORD        dwAlphaAlign;       // byte alignment for alpha
/*48*/ DWORD        dwNumHeaps;     // number of memory heaps in vmList
/*4c*/ LPVIDMEM     pvmList;        // array of heaps
} VIDMEMINFO;
typedef VIDMEMINFO FAR *LPVIDMEMINFO;

typedef struct _HEAPALIAS                  // PRIVATE
{
    FLATPTR  fpVidMem;                     // start of aliased vid mem
    LPVOID   lpAlias;                      // start of heap alias
    DWORD    dwAliasSize;                  // size of alias allocated
} HEAPALIAS;
typedef HEAPALIAS FAR *LPHEAPALIAS;

typedef struct _HEAPALIASINFO              // PRIVATE
{
    DWORD       dwRefCnt;                  // reference count of these aliases
    DWORD       dwFlags;                   // flags
    DWORD       dwNumHeaps;                // number of aliased heaps
    LPHEAPALIAS lpAliases;                 // array of heaps
} HEAPALIASINFO;
typedef HEAPALIASINFO FAR *LPHEAPALIASINFO;

#define HEAPALIASINFO_MAPPEDREAL   0x00000001l // PRIVATE: heap aliases mapped to real video memory
#define HEAPALIASINFO_MAPPEDDUMMY  0x00000002l // PRIVATE: heap aliased mapped to dummy memory

typedef struct _DDRAWI_DIRECTDRAW_INT FAR    *LPDDRAWI_DIRECTDRAW_INT;
typedef struct _DDRAWI_DIRECTDRAW_LCL FAR    *LPDDRAWI_DIRECTDRAW_LCL;
typedef struct _DDRAWI_DIRECTDRAW_GBL FAR    *LPDDRAWI_DIRECTDRAW_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_GBL FAR  *LPDDRAWI_DDRAWSURFACE_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_GBL_MORE FAR *LPDDRAWI_DDRAWSURFACE_GBL_MORE;
typedef struct _DDRAWI_DDRAWPALETTE_GBL FAR  *LPDDRAWI_DDRAWPALETTE_GBL;
typedef struct _DDRAWI_DDRAWPALETTE_INT FAR  *LPDDRAWI_DDRAWPALETTE_INT;
typedef struct _DDRAWI_DDRAWCLIPPER_INT FAR  *LPDDRAWI_DDRAWCLIPPER_INT;
typedef struct _DDRAWI_DDRAWCLIPPER_GBL FAR  *LPDDRAWI_DDRAWCLIPPER_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_MORE FAR *LPDDRAWI_DDRAWSURFACE_MORE;
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR  *LPDDRAWI_DDRAWSURFACE_LCL;
typedef struct _DDRAWI_DDRAWSURFACE_INT FAR  *LPDDRAWI_DDRAWSURFACE_INT;
typedef struct _DDRAWI_DDVIDEOPORT_INT FAR   *LPDDRAWI_DDVIDEOPORT_INT;
typedef struct _DDRAWI_DDVIDEOPORT_LCL FAR   *LPDDRAWI_DDVIDEOPORT_LCL;
typedef struct _DDRAWI_DDRAWPALETTE_LCL FAR  *LPDDRAWI_DDRAWPALETTE_LCL;
typedef struct _DDRAWI_DDRAWCLIPPER_LCL FAR  *LPDDRAWI_DDRAWCLIPPER_LCL;
typedef struct _DDRAWI_DDMOTIONCOMP_INT FAR  *LPDDRAWI_DDMOTIONCOMP_INT;
typedef struct _DDRAWI_DDMOTIONCOMP_LCL FAR  *LPDDRAWI_DDMOTIONCOMP_LCL;

/*
 * List of IUnknowns aggregated by a DirectDraw surface.
 */
typedef struct _IUNKNOWN_LIST
{
    struct _IUNKNOWN_LIST FAR *lpLink;
    GUID                  FAR *lpGuid;
    IUnknown              FAR *lpIUnknown;
} IUNKNOWN_LIST;
typedef IUNKNOWN_LIST FAR *LPIUNKNOWN_LIST;

/*
 * hardware emulation layer stuff
 */
typedef BOOL    (FAR PASCAL *LPDDHEL_INIT)(LPDDRAWI_DIRECTDRAW_GBL,BOOL);

/*
 * These structures contain the entry points in the display driver that
 * DDRAW will call.   Entries that the display driver does not care about
 * should be NULL.   Passed to DDRAW in DDHALINFO.
 */

/*
 * DIRECTDRAW object callbacks
 */
typedef DWORD   (FAR PASCAL *LPDDHAL_SETCOLORKEY)(LPDDHAL_DRVSETCOLORKEYDATA );
typedef DWORD   (FAR PASCAL *LPDDHAL_CANCREATESURFACE)(LPDDHAL_CANCREATESURFACEDATA );
typedef DWORD   (FAR PASCAL *LPDDHAL_WAITFORVERTICALBLANK)(LPDDHAL_WAITFORVERTICALBLANKDATA );
typedef DWORD   (FAR PASCAL *LPDDHAL_CREATESURFACE)(LPDDHAL_CREATESURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_DESTROYDRIVER)(LPDDHAL_DESTROYDRIVERDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_SETMODE)(LPDDHAL_SETMODEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_CREATEPALETTE)(LPDDHAL_CREATEPALETTEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_GETSCANLINE)(LPDDHAL_GETSCANLINEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_SETEXCLUSIVEMODE)(LPDDHAL_SETEXCLUSIVEMODEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_FLIPTOGDISURFACE)(LPDDHAL_FLIPTOGDISURFACEDATA);

typedef DWORD   (FAR PASCAL *LPDDHAL_GETDRIVERINFO)(LPDDHAL_GETDRIVERINFODATA);

typedef struct _DDHAL_DDCALLBACKS
{
    DWORD            dwSize;
    DWORD            dwFlags;
    LPDDHAL_DESTROYDRIVER    DestroyDriver;
    LPDDHAL_CREATESURFACE    CreateSurface;
    LPDDHAL_SETCOLORKEY      SetColorKey;
    LPDDHAL_SETMODE      SetMode;
    LPDDHAL_WAITFORVERTICALBLANK WaitForVerticalBlank;
    LPDDHAL_CANCREATESURFACE     CanCreateSurface;
    LPDDHAL_CREATEPALETTE    CreatePalette;
    LPDDHAL_GETSCANLINE      GetScanLine;
    // *** New fields for DX2 *** //
    LPDDHAL_SETEXCLUSIVEMODE     SetExclusiveMode;
    LPDDHAL_FLIPTOGDISURFACE     FlipToGDISurface;
} DDHAL_DDCALLBACKS;
typedef DDHAL_DDCALLBACKS FAR *LPDDHAL_DDCALLBACKS;

#define DDCALLBACKSSIZE_V1 ( offsetof( DDHAL_DDCALLBACKS, SetExclusiveMode ) )
#define DDCALLBACKSSIZE    sizeof( DDHAL_DDCALLBACKS )

#define DDHAL_CB32_DESTROYDRIVER    0x00000001l
#define DDHAL_CB32_CREATESURFACE    0x00000002l
#define DDHAL_CB32_SETCOLORKEY      0x00000004l
#define DDHAL_CB32_SETMODE      0x00000008l
#define DDHAL_CB32_WAITFORVERTICALBLANK 0x00000010l
#define DDHAL_CB32_CANCREATESURFACE 0x00000020l
#define DDHAL_CB32_CREATEPALETTE    0x00000040l
#define DDHAL_CB32_GETSCANLINE      0x00000080l
#define DDHAL_CB32_SETEXCLUSIVEMODE     0x00000100l
#define DDHAL_CB32_FLIPTOGDISURFACE     0x00000200l

/*
 * DIRECTDRAWPALETTE object callbacks
 */
typedef DWORD   (FAR PASCAL *LPDDHALPALCB_DESTROYPALETTE)(LPDDHAL_DESTROYPALETTEDATA );
typedef DWORD   (FAR PASCAL *LPDDHALPALCB_SETENTRIES)(LPDDHAL_SETENTRIESDATA );

typedef struct _DDHAL_DDPALETTECALLBACKS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    LPDDHALPALCB_DESTROYPALETTE DestroyPalette;
    LPDDHALPALCB_SETENTRIES SetEntries;
} DDHAL_DDPALETTECALLBACKS;
typedef DDHAL_DDPALETTECALLBACKS FAR *LPDDHAL_DDPALETTECALLBACKS;

#define DDPALETTECALLBACKSSIZE  sizeof( DDHAL_DDPALETTECALLBACKS )

#define DDHAL_PALCB32_DESTROYPALETTE    0x00000001l
#define DDHAL_PALCB32_SETENTRIES    0x00000002l

/*
 * DIRECTDRAWSURFACE object callbacks
 */
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_LOCK)(LPDDHAL_LOCKDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_UNLOCK)(LPDDHAL_UNLOCKDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_BLT)(LPDDHAL_BLTDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_UPDATEOVERLAY)(LPDDHAL_UPDATEOVERLAYDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETOVERLAYPOSITION)(LPDDHAL_SETOVERLAYPOSITIONDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETPALETTE)(LPDDHAL_SETPALETTEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_FLIP)(LPDDHAL_FLIPDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_DESTROYSURFACE)(LPDDHAL_DESTROYSURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETCLIPLIST)(LPDDHAL_SETCLIPLISTDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_ADDATTACHEDSURFACE)(LPDDHAL_ADDATTACHEDSURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETCOLORKEY)(LPDDHAL_SETCOLORKEYDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_GETBLTSTATUS)(LPDDHAL_GETBLTSTATUSDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_GETFLIPSTATUS)(LPDDHAL_GETFLIPSTATUSDATA);


typedef struct _DDHAL_DDSURFACECALLBACKS
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALSURFCB_DESTROYSURFACE    DestroySurface;
    LPDDHALSURFCB_FLIP          Flip;
    LPDDHALSURFCB_SETCLIPLIST       SetClipList;
    LPDDHALSURFCB_LOCK          Lock;
    LPDDHALSURFCB_UNLOCK        Unlock;
    LPDDHALSURFCB_BLT           Blt;
    LPDDHALSURFCB_SETCOLORKEY       SetColorKey;
    LPDDHALSURFCB_ADDATTACHEDSURFACE    AddAttachedSurface;
    LPDDHALSURFCB_GETBLTSTATUS      GetBltStatus;
    LPDDHALSURFCB_GETFLIPSTATUS     GetFlipStatus;
    LPDDHALSURFCB_UPDATEOVERLAY     UpdateOverlay;
    LPDDHALSURFCB_SETOVERLAYPOSITION    SetOverlayPosition;
    LPVOID              reserved4;
    LPDDHALSURFCB_SETPALETTE        SetPalette;
} DDHAL_DDSURFACECALLBACKS;
typedef DDHAL_DDSURFACECALLBACKS FAR *LPDDHAL_DDSURFACECALLBACKS;

#define DDSURFACECALLBACKSSIZE sizeof( DDHAL_DDSURFACECALLBACKS )

#define DDHAL_SURFCB32_DESTROYSURFACE       0x00000001l
#define DDHAL_SURFCB32_FLIP         0x00000002l
#define DDHAL_SURFCB32_SETCLIPLIST      0x00000004l
#define DDHAL_SURFCB32_LOCK         0x00000008l
#define DDHAL_SURFCB32_UNLOCK           0x00000010l
#define DDHAL_SURFCB32_BLT          0x00000020l
#define DDHAL_SURFCB32_SETCOLORKEY      0x00000040l
#define DDHAL_SURFCB32_ADDATTACHEDSURFACE   0x00000080l
#define DDHAL_SURFCB32_GETBLTSTATUS         0x00000100l
#define DDHAL_SURFCB32_GETFLIPSTATUS        0x00000200l
#define DDHAL_SURFCB32_UPDATEOVERLAY        0x00000400l
#define DDHAL_SURFCB32_SETOVERLAYPOSITION   0x00000800l
#define DDHAL_SURFCB32_RESERVED4        0x00001000l
#define DDHAL_SURFCB32_SETPALETTE       0x00002000l

// This structure can be queried from the driver from DX5 onward
// using GetDriverInfo with GUID_MiscellaneousCallbacks

typedef DWORD   (FAR PASCAL *LPDDHAL_GETAVAILDRIVERMEMORY)(LPDDHAL_GETAVAILDRIVERMEMORYDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_UPDATENONLOCALHEAP)(LPDDHAL_UPDATENONLOCALHEAPDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_GETHEAPALIGNMENT)(LPDDHAL_GETHEAPALIGNMENTDATA);
/*
 * This prototype is identical to that of GetBltStatus
 */

typedef struct _DDHAL_DDMISCELLANEOUSCALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    LPDDHAL_GETAVAILDRIVERMEMORY        GetAvailDriverMemory;
    LPDDHAL_UPDATENONLOCALHEAP          UpdateNonLocalHeap;
    LPDDHAL_GETHEAPALIGNMENT            GetHeapAlignment;
    /*
     * The GetSysmemBltStatus callback uses the same prototype as GetBltStatus.
     * It is legal to point both pointers to the same driver routine.
     */
    LPDDHALSURFCB_GETBLTSTATUS          GetSysmemBltStatus;
} DDHAL_DDMISCELLANEOUSCALLBACKS, *LPDDHAL_DDMISCELLANEOUSCALLBACKS;

#define DDHAL_MISCCB32_GETAVAILDRIVERMEMORY    0x00000001l
#define DDHAL_MISCCB32_UPDATENONLOCALHEAP      0x00000002l
#define DDHAL_MISCCB32_GETHEAPALIGNMENT        0x00000004l
#define DDHAL_MISCCB32_GETSYSMEMBLTSTATUS      0x00000008l

#define DDMISCELLANEOUSCALLBACKSSIZE sizeof(DDHAL_DDMISCELLANEOUSCALLBACKS)


// DDHAL_DDMISCELLANEOUS2CALLBACKS:
//   This structure can be queried from the driver from DX7 onward
//   using GetDriverInfo with GUID_Miscellaneous2Callbacks

typedef DWORD   (FAR PASCAL *LPDDHAL_CREATESURFACEEX)(LPDDHAL_CREATESURFACEEXDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_GETDRIVERSTATE)(LPDDHAL_GETDRIVERSTATEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_DESTROYDDLOCAL)(LPDDHAL_DESTROYDDLOCALDATA);

typedef struct _DDHAL_DDMISCELLANEOUS2CALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    LPVOID                              Reserved;
    LPDDHAL_CREATESURFACEEX             CreateSurfaceEx;
    LPDDHAL_GETDRIVERSTATE              GetDriverState;
    LPDDHAL_DESTROYDDLOCAL              DestroyDDLocal;
} DDHAL_DDMISCELLANEOUS2CALLBACKS, *LPDDHAL_DDMISCELLANEOUS2CALLBACKS;

#define DDHAL_MISC2CB32_CREATESURFACEEX        0x00000002l
#define DDHAL_MISC2CB32_GETDRIVERSTATE         0x00000004l
#define DDHAL_MISC2CB32_DESTROYDDLOCAL         0x00000008l


#define DDMISCELLANEOUS2CALLBACKSSIZE sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS)


/*
 * DIRECTDRAWEXEBUF pseudo object callbacks
 *
 * NOTE: Execute buffers are not a distinct object type, they piggy back off
 * the surface data structures and high level API. However, they have their
 * own HAL callbacks as they may have different driver semantics from "normal"
 * surfaces. They also piggy back off the HAL data structures.
 *
 * !!! NOTE: Need to resolve whether we export execute buffer copying as a
 * blit or some other from of copy instruction.
 */
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_CANCREATEEXEBUF)(LPDDHAL_CANCREATESURFACEDATA );
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_CREATEEXEBUF)(LPDDHAL_CREATESURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_DESTROYEXEBUF)(LPDDHAL_DESTROYSURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_LOCKEXEBUF)(LPDDHAL_LOCKDATA);
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_UNLOCKEXEBUF)(LPDDHAL_UNLOCKDATA);

typedef struct _DDHAL_DDEXEBUFCALLBACKS
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALEXEBUFCB_CANCREATEEXEBUF CanCreateExecuteBuffer;
    LPDDHALEXEBUFCB_CREATEEXEBUF    CreateExecuteBuffer;
    LPDDHALEXEBUFCB_DESTROYEXEBUF   DestroyExecuteBuffer;
    LPDDHALEXEBUFCB_LOCKEXEBUF      LockExecuteBuffer;
    LPDDHALEXEBUFCB_UNLOCKEXEBUF    UnlockExecuteBuffer;
} DDHAL_DDEXEBUFCALLBACKS;
typedef DDHAL_DDEXEBUFCALLBACKS FAR *LPDDHAL_DDEXEBUFCALLBACKS;

#define DDEXEBUFCALLBACKSSIZE sizeof( DDHAL_DDEXEBUFCALLBACKS )

#define DDHAL_EXEBUFCB32_CANCREATEEXEBUF    0x00000001l
#define DDHAL_EXEBUFCB32_CREATEEXEBUF       0x00000002l
#define DDHAL_EXEBUFCB32_DESTROYEXEBUF      0x00000004l
#define DDHAL_EXEBUFCB32_LOCKEXEBUF     0x00000008l
#define DDHAL_EXEBUFCB32_UNLOCKEXEBUF       0x00000010l

/*
 * DIRECTVIDEOPORT object callbacks
 */
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_CANCREATEVIDEOPORT)(LPDDHAL_CANCREATEVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_CREATEVIDEOPORT)(LPDDHAL_CREATEVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_FLIP)(LPDDHAL_FLIPVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETBANDWIDTH)(LPDDHAL_GETVPORTBANDWIDTHDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETINPUTFORMATS)(LPDDHAL_GETVPORTINPUTFORMATDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETOUTPUTFORMATS)(LPDDHAL_GETVPORTOUTPUTFORMATDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETFIELD)(LPDDHAL_GETVPORTFIELDDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETLINE)(LPDDHAL_GETVPORTLINEDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETVPORTCONNECT)(LPDDHAL_GETVPORTCONNECTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_DESTROYVPORT)(LPDDHAL_DESTROYVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETFLIPSTATUS)(LPDDHAL_GETVPORTFLIPSTATUSDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_UPDATE)(LPDDHAL_UPDATEVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_WAITFORSYNC)(LPDDHAL_WAITFORVPORTSYNCDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETSIGNALSTATUS)(LPDDHAL_GETVPORTSIGNALDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_COLORCONTROL)(LPDDHAL_VPORTCOLORDATA);

typedef struct _DDHAL_DDVIDEOPORTCALLBACKS
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALVPORTCB_CANCREATEVIDEOPORT   CanCreateVideoPort;
    LPDDHALVPORTCB_CREATEVIDEOPORT      CreateVideoPort;
    LPDDHALVPORTCB_FLIP                 FlipVideoPort;
    LPDDHALVPORTCB_GETBANDWIDTH         GetVideoPortBandwidth;
    LPDDHALVPORTCB_GETINPUTFORMATS      GetVideoPortInputFormats;
    LPDDHALVPORTCB_GETOUTPUTFORMATS     GetVideoPortOutputFormats;
    LPVOID              lpReserved1;
    LPDDHALVPORTCB_GETFIELD             GetVideoPortField;
    LPDDHALVPORTCB_GETLINE              GetVideoPortLine;
    LPDDHALVPORTCB_GETVPORTCONNECT      GetVideoPortConnectInfo;
    LPDDHALVPORTCB_DESTROYVPORT         DestroyVideoPort;
    LPDDHALVPORTCB_GETFLIPSTATUS        GetVideoPortFlipStatus;
    LPDDHALVPORTCB_UPDATE               UpdateVideoPort;
    LPDDHALVPORTCB_WAITFORSYNC          WaitForVideoPortSync;
    LPDDHALVPORTCB_GETSIGNALSTATUS      GetVideoSignalStatus;
    LPDDHALVPORTCB_COLORCONTROL         ColorControl;
} DDHAL_DDVIDEOPORTCALLBACKS;
typedef DDHAL_DDVIDEOPORTCALLBACKS FAR *LPDDHAL_DDVIDEOPORTCALLBACKS;

#define DDVIDEOPORTCALLBACKSSIZE sizeof( DDHAL_DDVIDEOPORTCALLBACKS )

#define DDHAL_VPORT32_CANCREATEVIDEOPORT    0x00000001l
#define DDHAL_VPORT32_CREATEVIDEOPORT           0x00000002l
#define DDHAL_VPORT32_FLIP                      0x00000004l
#define DDHAL_VPORT32_GETBANDWIDTH              0x00000008l
#define DDHAL_VPORT32_GETINPUTFORMATS           0x00000010l
#define DDHAL_VPORT32_GETOUTPUTFORMATS          0x00000020l
#define DDHAL_VPORT32_GETFIELD                  0x00000080l
#define DDHAL_VPORT32_GETLINE                   0x00000100l
#define DDHAL_VPORT32_GETCONNECT                0x00000200l
#define DDHAL_VPORT32_DESTROY                   0x00000400l
#define DDHAL_VPORT32_GETFLIPSTATUS             0x00000800l
#define DDHAL_VPORT32_UPDATE                    0x00001000l
#define DDHAL_VPORT32_WAITFORSYNC               0x00002000l
#define DDHAL_VPORT32_GETSIGNALSTATUS           0x00004000l
#define DDHAL_VPORT32_COLORCONTROL      0x00008000l

/*
 * DIRECTDRAWCOLORCONTROL object callbacks
 */
typedef DWORD (FAR PASCAL *LPDDHALCOLORCB_COLORCONTROL)(LPDDHAL_COLORCONTROLDATA);

typedef struct _DDHAL_DDCOLORCONTROLCALLBACKS
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALCOLORCB_COLORCONTROL         ColorControl;
} DDHAL_DDCOLORCONTROLCALLBACKS;
typedef DDHAL_DDCOLORCONTROLCALLBACKS FAR *LPDDHAL_DDCOLORCONTROLCALLBACKS;

#define DDCOLORCONTROLCALLBACKSSIZE sizeof( DDHAL_DDCOLORCONTROLCALLBACKS )

#define DDHAL_COLOR_COLORCONTROL        0x00000001l

/*
 * DIRECTDRAWSURFACEKERNEL object callbacks
 * This structure can be queried from the driver from DX5 onward
 * using GetDriverInfo with GUID_KernelCallbacks
 */
typedef DWORD (FAR PASCAL *LPDDHALKERNELCB_SYNCSURFACE)(LPDDHAL_SYNCSURFACEDATA);
typedef DWORD (FAR PASCAL *LPDDHALKERNELCB_SYNCVIDEOPORT)(LPDDHAL_SYNCVIDEOPORTDATA);

typedef struct _DDHAL_DDKERNELCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    LPDDHALKERNELCB_SYNCSURFACE     SyncSurfaceData;
    LPDDHALKERNELCB_SYNCVIDEOPORT   SyncVideoPortData;
} DDHAL_DDKERNELCALLBACKS, *LPDDHAL_DDKERNELCALLBACKS;

#define DDHAL_KERNEL_SYNCSURFACEDATA        0x00000001l
#define DDHAL_KERNEL_SYNCVIDEOPORTDATA      0x00000002l

#define DDKERNELCALLBACKSSIZE sizeof(DDHAL_DDKERNELCALLBACKS)

typedef HRESULT (WINAPI *LPDDGAMMACALIBRATORPROC)( LPDDGAMMARAMP, LPBYTE);

/*
 * DIRECTDRAWMOTIONCOMP object callbacks
 */
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_GETGUIDS)( LPDDHAL_GETMOCOMPGUIDSDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_GETFORMATS)( LPDDHAL_GETMOCOMPFORMATSDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_CREATE)( LPDDHAL_CREATEMOCOMPDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_GETCOMPBUFFINFO)( LPDDHAL_GETMOCOMPCOMPBUFFDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_GETINTERNALINFO)( LPDDHAL_GETINTERNALMOCOMPDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_BEGINFRAME)( LPDDHAL_BEGINMOCOMPFRAMEDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_ENDFRAME)( LPDDHAL_ENDMOCOMPFRAMEDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_RENDER)( LPDDHAL_RENDERMOCOMPDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_QUERYSTATUS)( LPDDHAL_QUERYMOCOMPSTATUSDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_DESTROY)( LPDDHAL_DESTROYMOCOMPDATA);

typedef struct _DDHAL_DDMOTIONCOMPCALLBACKS
{
    DWORD                           dwSize;
    DWORD                           dwFlags;
    LPDDHALMOCOMPCB_GETGUIDS        GetMoCompGuids;
    LPDDHALMOCOMPCB_GETFORMATS      GetMoCompFormats;
    LPDDHALMOCOMPCB_CREATE          CreateMoComp;
    LPDDHALMOCOMPCB_GETCOMPBUFFINFO GetMoCompBuffInfo;
    LPDDHALMOCOMPCB_GETINTERNALINFO GetInternalMoCompInfo;
    LPDDHALMOCOMPCB_BEGINFRAME      BeginMoCompFrame;
    LPDDHALMOCOMPCB_ENDFRAME        EndMoCompFrame;
    LPDDHALMOCOMPCB_RENDER          RenderMoComp;
    LPDDHALMOCOMPCB_QUERYSTATUS     QueryMoCompStatus;
    LPDDHALMOCOMPCB_DESTROY         DestroyMoComp;
} DDHAL_DDMOTIONCOMPCALLBACKS;
typedef DDHAL_DDMOTIONCOMPCALLBACKS FAR *LPDDHAL_DDMOTIONCOMPCALLBACKS;

#define DDMOTIONCOMPCALLBACKSSIZE sizeof( DDHAL_DDMOTIONCOMPCALLBACKS )

#define DDHAL_MOCOMP32_GETGUIDS         0x00000001
#define DDHAL_MOCOMP32_GETFORMATS       0x00000002
#define DDHAL_MOCOMP32_CREATE           0x00000004
#define DDHAL_MOCOMP32_GETCOMPBUFFINFO  0x00000008
#define DDHAL_MOCOMP32_GETINTERNALINFO  0x00000010
#define DDHAL_MOCOMP32_BEGINFRAME       0x00000020
#define DDHAL_MOCOMP32_ENDFRAME         0x00000040
#define DDHAL_MOCOMP32_RENDER           0x00000080
#define DDHAL_MOCOMP32_QUERYSTATUS      0x00000100
#define DDHAL_MOCOMP32_DESTROY          0x00000200


/*
 * CALLBACK RETURN VALUES
 *                      * these are values returned by the driver from the above callback routines
 */
/*
 * indicates that the display driver didn't do anything with the call
 */
#define DDHAL_DRIVER_NOTHANDLED     0x00000000l

/*
 * indicates that the display driver handled the call; HRESULT value is valid
 */
#define DDHAL_DRIVER_HANDLED        0x00000001l

/*
 * indicates that the display driver couldn't handle the call because it
 * ran out of color key hardware resources
 */
#define DDHAL_DRIVER_NOCKEYHW       0x00000002l

/*
 * Capabilities structure for non-local video memory
 */
typedef struct _DDNONLOCALVIDMEMCAPS
{
    DWORD   dwSize;
    DWORD   dwNLVBCaps;       // driver specific capabilities for non-local->local vidmem blts
    DWORD   dwNLVBCaps2;          // more driver specific capabilities non-local->local vidmem blts
    DWORD   dwNLVBCKeyCaps;       // driver color key capabilities for non-local->local vidmem blts
    DWORD   dwNLVBFXCaps;         // driver FX capabilities for non-local->local blts
    DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DDNONLOCALVIDMEMCAPS;
typedef struct _DDNONLOCALVIDMEMCAPS FAR *LPDDNONLOCALVIDMEMCAPS;


/*
 * More driver surface capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS.ddsCaps structure in DX6.
 */
typedef struct _DDMORESURFACECAPS
{
    DWORD       dwSize;             // size of DDMORESURFACECAPS structure
    DDSCAPSEX   ddsCapsMore;
    /*
     * The DDMORESURFACECAPS struct is of variable size. The following list may be
     * filled in by DX6-aware drivers (see DDVERSIONINFO) to restrict their
     * video memory heaps (those which are exposed to DirectDraw) to
     * certain sets of DDSCAPS_ bits. Thse entries are exactly analogous to
     * the ddsCaps and ddsCapsAlt members of the VIDMEM structures listed in
     * the VIDMEMINFO.pvmList member of DDHALINFO.vmiData. There should be
     * exactly DDHALINFO.vmiData.dwNumHeaps copies of tagExtendedHeapRestrictions
     * in this struct. The size of this struct is thus:
     *  DDMORESURFACECAPS.dwSize = sizeof(DDMORESURFACECAPS) +
     *          (DDHALINFO.vmiData.dwNumHeaps-1) * sizeof(DDSCAPSEX)*2;
     * Note the -1 accounts for the fact that DDMORESURFACECAPS is declared to have 1
     * tagExtendedHeapRestrictions member.
     */
    struct tagExtendedHeapRestrictions
    {
        DDSCAPSEX   ddsCapsEx;
        DDSCAPSEX   ddsCapsExAlt;
    } ddsExtendedHeapRestrictions[1];
} DDMORESURFACECAPS, FAR * LPDDMORESURFACECAPS;

// Stereo, driver returns DD_OK if mode is ok for stereo
typedef struct _DDSTEREOMODE
{
    DWORD       dwSize;             // size of DDSTEREOMODECAPS structure

    DWORD       dwHeight;
    DWORD       dwWidth;
    DWORD       dwBpp;
    DWORD       dwRefreshRate;

    BOOL        bSupported;         // driver supports this video mode...

} DDSTEREOMODE, FAR * LPDDSTEREOMODE;



/*
 * DDRAW palette interface struct
 */
typedef struct _DDRAWI_DDRAWPALETTE_INT
{
    LPVOID                      lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DDRAWPALETTE_LCL   lpLcl;      // pointer to interface data
    LPDDRAWI_DDRAWPALETTE_INT   lpLink;     // link to next interface
    DWORD                       dwIntRefCnt;    // interface reference count
} DDRAWI_DDRAWPALETTE_INT;

/*
 * DDRAW internal version of DIRECTDRAWPALETTE object; it has data after the vtable
 */
typedef struct _DDRAWI_DDRAWPALETTE_GBL
{
    DWORD                       dwRefCnt;   // reference count
    DWORD                       dwFlags;    // flags
    LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;   // PRIVATE: DIRECTDRAW object
    DWORD                       dwProcessId;    // owning process
    LPPALETTEENTRY              lpColorTable;   // array of palette entries
    union
    {
        ULONG_PTR               dwReserved1;    // reserved for use by display driver which created this object
        HPALETTE                hHELGDIPalette;
    };
    /*
     * Fields added in version 5.0. Check if the ddraw version >= 5 (passed during
     * driver initialization) to see if these fields will be present.
     */
    DWORD                       dwDriverReserved; // For use by HAL, regardless of who created object
    DWORD                       dwContentsStamp;  // Incremented when palette changes.
    /*
     * Fields added in version 6
     */
    DWORD                       dwSaveStamp;  // Incremented when palette changes.
    /*
     * And in version 7
     */
    DWORD                       dwHandle;       //Handle used in drawprim2 palette notification

} DDRAWI_DDRAWPALETTE_GBL;


/*
 * (CMcC) The palette no longer maintains a back pointer to the owning surface
 * (there may now be many owning surfaces). So the lpDDSurface is now dwReserved0
 * (this mod. assumes that sizeof(DWORD) == sizeof(LPDDRAWI_DDRAWSURFACE_LCL). A
 * fairly safe assumption I think.
 */
typedef struct _DDRAWI_DDRAWPALETTE_LCL
{
    DWORD                       lpPalMore;  // pointer to additional local data
    LPDDRAWI_DDRAWPALETTE_GBL   lpGbl;      // pointer to data
    ULONG_PTR                   dwUnused0;  // not currently used.
    DWORD                       dwLocalRefCnt;  // local ref cnt
    IUnknown                    FAR *pUnkOuter; // outer IUnknown
    LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;   // pointer to owning local driver object
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    /*
     * Added for DX6
     */
    ULONG_PTR                   dwDDRAWReserved1;
    ULONG_PTR                   dwDDRAWReserved2;
    ULONG_PTR                   dwDDRAWReserved3;

} DDRAWI_DDRAWPALETTE_LCL;

// bit definition for dwFlags in DDRAWI_DDRAWPALETTE_GBL and
// dwPaletteFlags in D3DHAL_DP2SETPALETTE
#define DDRAWIPAL_256       0x00000001l // 256 entry palette
#define DDRAWIPAL_16        0x00000002l // 16 entry palette
#define DDRAWIPAL_GDI       0x00000004l // palette allocated through GDI
#define DDRAWIPAL_STORED_8  0x00000008l // palette stored as 8bpp/entry
#define DDRAWIPAL_STORED_16 0x00000010l // palette stored as 16bpp/entry
#define DDRAWIPAL_STORED_24 0x00000020l // palette stored as 24bpp/entry
#define DDRAWIPAL_EXCLUSIVE 0x00000040l // palette being used in exclusive mode
#define DDRAWIPAL_INHEL     0x00000080l // palette is done in the hel
#define DDRAWIPAL_DIRTY         0x00000100l     // gdi palette out 'o sync
#define DDRAWIPAL_ALLOW256  0x00000200l // can fully update palette
#define DDRAWIPAL_4             0x00000400l     // 4 entry palette
#define DDRAWIPAL_2             0x00000800l     // 2 entry palette
#define DDRAWIPAL_STORED_8INDEX 0x00001000l     // palette stored as 8-bit index into dst palette
#define DDRAWIPAL_ALPHA     0x00002000l // palette entries contain alpha

/*
 * DDRAW clipper interface struct
 */
typedef struct _DDRAWI_DDRAWCLIPPER_INT
{
    LPVOID                          lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DDRAWCLIPPER_LCL       lpLcl;      // pointer to interface data
    LPDDRAWI_DDRAWCLIPPER_INT       lpLink;     // link to next interface
    DWORD                           dwIntRefCnt;    // interface reference count
} DDRAWI_DDRAWCLIPPER_INT;

/*
 * DDRAW internal version of DIRECTDRAWCLIPPER object; it has data after the vtable
 */
typedef struct _DDRAWI_DDRAWCLIPPER_GBL
{
    DWORD                   dwRefCnt;   // reference count
    DWORD                   dwFlags;    // flags
    LPDDRAWI_DIRECTDRAW_GBL lpDD;       // PRIVATE: DIRECTDRAW object
    DWORD                   dwProcessId;    // owning process
    ULONG_PTR               dwReserved1;    // reserved for use by display driver
    ULONG_PTR               hWnd;       // window
    LPRGNDATA               lpStaticClipList; // clip list set by app
} DDRAWI_DDRAWCLIPPER_GBL;

/*
 * (CMcC) As with palettes, the clipper no longer maintains a back pointer to the
 * owning surface (there may now be many owning surfaces). So the lpDDSurface
 * is now dwReserved0 (this mod. assumes that sizeof(DWORD) ==
 * sizeof(LPDDRAWI_DDRAWSURFACE_LCL). A fairly safe assumption I think.
 */
typedef struct _DDRAWI_DDRAWCLIPPER_LCL
{
    DWORD                       lpClipMore; // pointer to additional local data
    LPDDRAWI_DDRAWCLIPPER_GBL   lpGbl;      // pointer to data
    LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;   // pointer to owning local DD object
    DWORD                       dwLocalRefCnt;  // local ref cnt
    IUnknown                    FAR *pUnkOuter; // outer IUnknown
    LPDDRAWI_DIRECTDRAW_INT     lpDD_int;   // pointer to owning DD object interface
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    IUnknown *                  pAddrefedThisOwner; //This is the ddraw object that created this
                                                    //clipper, if nonzero. Must Release it when clipper
                                                    //is released.
} DDRAWI_DDRAWCLIPPER_LCL;

#define DDRAWICLIP_WATCHWINDOW          0x00000001l
#define DDRAWICLIP_ISINITIALIZED        0x00000002l
#define DDRAWICLIP_INMASTERSPRITELIST   0x00000004l   // clipper is referenced in master sprite list

/*
 * ATTACHLIST - internally used to maintain list of attached surfaces
 */
typedef struct _ATTACHLIST
{
    DWORD                               dwFlags;
    struct _ATTACHLIST                  FAR *lpLink;      // link to next attached surface
    struct _DDRAWI_DDRAWSURFACE_LCL FAR *lpAttached;  // attached surface local obj
    struct _DDRAWI_DDRAWSURFACE_INT FAR *lpIAttached; // attached surface interface
} ATTACHLIST;
typedef ATTACHLIST FAR *LPATTACHLIST;
#define DDAL_IMPLICIT       0x00000001l

/*
 * DBLNODE - a node in a doubly-linked list of surface interfaces
 */
typedef struct _DBLNODE
{
    struct  _DBLNODE                    FAR *next;  // link to next node
    struct  _DBLNODE                    FAR *prev;  // link to previous node
    LPDDRAWI_DDRAWSURFACE_LCL           object;     // link to object
    LPDDRAWI_DDRAWSURFACE_INT           object_int; // object interface
} DBLNODE;
typedef DBLNODE FAR *LPDBLNODE;

/*
 * ACCESSRECTLIST - internally used to all rectangles that are accessed on a surface
 */
typedef struct _ACCESSRECTLIST
{
    struct _ACCESSRECTLIST FAR  *lpLink;     // link to next attached surface
    RECT                        rDest;       // rectangle being used
    LPDDRAWI_DIRECTDRAW_LCL     lpOwner;     // owning local object
    LPVOID                      lpSurfaceData;   // associated screen ptr
    DWORD                       dwFlags;     // PRIVATE: flags
    LPHEAPALIASINFO             lpHeapAliasInfo; // PRIVATE: aliased heaps being used by this lock
} ACCESSRECTLIST;
typedef ACCESSRECTLIST FAR *LPACCESSRECTLIST;

#define ACCESSRECT_VRAMSTYLE           0x00000001L    // PRIVATE: this lock is vram style (vidmem or implict sysmem)
#define ACCESSRECT_NOTHOLDINGWIN16LOCK 0x00000002L    // PRIVATE: this lock is not holding the Win16 lock
#define ACCESSRECT_BROKEN              0x00000004L    // PRIVATE: this lock was broken by an invalidate - don't call HAL on unlock

#ifndef WIN95
/* 
 * Do not change the size of this struct. This will move various members of surface and ddraw
 * structs and will prevent binaries from running on old win2k systems (or mismatched later NT builds)
 */
typedef struct _DISPLAYMODEINFO
{
    WORD wWidth;
    WORD wHeight;
    BYTE wBPP;
    BYTE wMonitorsAttachedToDesktop;
    WORD wRefreshRate;
} DISPLAYMODEINFO;
typedef struct _DISPLAYMODEINFO *LPDISPLAYMODEINFO;

#define EQUAL_DISPLAYMODE(a, b) (0 == memcmp(&(a), &(b), sizeof (DISPLAYMODEINFO)))
#endif


/*
 * DDRAW surface interface struct
 */
typedef struct _DDRAWI_DDRAWSURFACE_INT
{
    LPVOID                      lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;      // pointer to interface data
    LPDDRAWI_DDRAWSURFACE_INT   lpLink;     // link to next interface
    DWORD                       dwIntRefCnt;    // interface reference count
} DDRAWI_DDRAWSURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DDRAWI_DDRAWSURFACE_GBL
{
    DWORD               dwRefCnt;   // reference count
    DWORD               dwGlobalFlags;  // global flags
    union
    {
        LPACCESSRECTLIST lpRectList; // list of accesses
        DWORD           dwBlockSizeY;   // block size that display driver requested (return)
        LONG            lSlicePitch;    // slice pitch for volume textures
    };
    union
    {
        LPVMEMHEAP      lpVidMemHeap;   // heap vidmem was alloc'ed from
        DWORD           dwBlockSizeX;   // block size that display driver requested (return)
    };
    union
    {
        LPDDRAWI_DIRECTDRAW_GBL lpDD;       // internal DIRECTDRAW object
        LPVOID          lpDDHandle;     // handle to internal DIRECTDRAW object
                        // for use by display driver
                        // when calling fns in DDRAW16.DLL
    };
    FLATPTR             fpVidMem;   // pointer to video memory
    union
    {
        LONG            lPitch;     // pitch of surface
        DWORD           dwLinearSize;   // linear size of non-rectangular surface
    };
    WORD                wHeight;    // height of surface
    WORD                wWidth;     // width of surface
    DWORD               dwUsageCount;   // number of access to this surface
    ULONG_PTR           dwReserved1;    // reserved for use by display driver
    //
    // NOTE: this part of the structure is ONLY allocated if the pixel
    //       format differs from that of the primary display
    //
    DDPIXELFORMAT       ddpfSurface;    // pixel format of surface
} DDRAWI_DDRAWSURFACE_GBL;

/*
 * This is an extender structure that is allocated off the end of the SURFACE_GBL
 * structure. DO NOT place any structures whose size can change in here.
 */
#define GET_LPDDRAWSURFACE_GBL_MORE(psurf_gbl)      \
    (*(LPDDRAWI_DDRAWSURFACE_GBL_MORE *)        \
    ((BYTE *)psurf_gbl - sizeof(DWORD_PTR)))

/*
 * Return the physical memory pointer for a given surface global object.
 *
 * NOTE: The physical memory pointer is ONLY valid for surfaces allocated from
 * non-local video memory. This field will not be valid for system memory or
 * local video memory surfaces.
 */
#define SURFACE_PHYSICALVIDMEM( psurf_gbl ) \
    ( GET_LPDDRAWSURFACE_GBL_MORE( psurf_gbl )->fpPhysicalVidMem )

/*
 * NOTE: This structure contains a set of fields for describing linear to physical
 * page mappings in the case of page locked system memory. It can also contain the
 * physical surface pointer of a surface in non-local memory. As there is no point
 * in having both a linear to physical page translation table and a physical memory
 * pointer for the same surface they are placed in a union.
 */
typedef struct _DDRAWI_DDRAWSURFACE_GBL_MORE
{
    DWORD           dwSize;
    union
    {
        DWORD       dwPhysicalPageTable;        // Physical address of page table (array of physical addresses/one per 4K page)
        FLATPTR     fpPhysicalVidMem;               // Physical address of surface (non-local video memory only)
    };
    LPDWORD         pPageTable;         // Linear address of page table
    DWORD           cPages;             // Number of Pages
    ULONG_PTR       dwSavedDCContext;               // PRIVATE: For use by DDSurface::GetDC
    FLATPTR         fpAliasedVidMem;                // PRIVATE: Alias for original fpVidMem
    ULONG_PTR       dwDriverReserved;               // Reserved for driver use (both system and video memory surfaces)
    ULONG_PTR       dwHELReserved;          // PRIVATE: For HEL use only
    DWORD           cPageUnlocks;           // Incremented whenever a surface is PageUnlocked
    ULONG_PTR       hKernelSurface;         // Kernel handle for this surface
    DWORD           dwKernelRefCnt;         // Ref count for kernel handle
    LPDDCOLORCONTROL lpColorInfo;       // PRIVATE: Initial color control settings
    FLATPTR         fpNTAlias;                      // PRIVATE: Used internally by NT DirectDraw
    DWORD           dwContentsStamp;                // Changes when surface data may have changed. 0 means no information
    LPVOID          lpvUnswappedDriverReserved;     // Reserved for use by display driver. Is not swapped when Flip is called on this surface
    LPVOID          lpDDRAWReserved2;
    DWORD           dwDDRAWReserved1;
    DWORD           dwDDRAWReserved2;
    FLATPTR         fpAliasOfVidMem;    // PRIVATE: The original VidMem pointer of which fpAliasedVidMem is an alias of
                                        // This is used to compare with a given fpVidMem to see if we can use the cached fpAliasedVidMem or
                                        // if we need to call GetAliasedVidMem.
} DDRAWI_DDRAWSURFACE_GBL_MORE;


/*
 * a structure holding additional LCL surface information (can't simply be appended
 * to the LCL structure as that structure is of variable size).
 */
typedef struct _DDRAWI_DDRAWSURFACE_MORE
{
    DWORD                       dwSize;
    IUNKNOWN_LIST               FAR *lpIUnknowns;   // IUnknowns aggregated by this surface
    LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;       // Pointer to the DirectDraw local object
    DWORD                       dwPageLockCount;    // count of pagelocks
    DWORD                       dwBytesAllocated;   // size of sys mem allocated
    LPDDRAWI_DIRECTDRAW_INT     lpDD_int;       // Pointer to the DirectDraw interface
    DWORD                       dwMipMapCount;      // Number of mip-map levels in the chain
    LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper;       // Interface to attached clipper object
    //------- Fields added in Version 5.0 -------
    LPHEAPALIASINFO             lpHeapAliasInfo;    // PRIVATE: Aliased heaps being referenced by this lock
    DWORD                       dwOverlayFlags;     // Current overlay flags
    VOID                        *rgjunc;        // Blitter function table for new blitter
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port currently writting data to this surface
    LPDDOVERLAYFX               lpddOverlayFX;      // current overlay fx
    DDSCAPSEX                   ddsCapsEx;
    DWORD                       dwTextureStage;     // stage in multitexture cascade
    LPVOID                      lpDDRAWReserved;
    LPVOID                      lpDDRAWReserved2;
    LPVOID                      lpDDrawReserved3;
    DWORD                       dwDDrawReserved4;
    LPVOID                      lpDDrawReserved5;
   LPDWORD                      lpGammaRamp;
   LPDWORD                      lpOriginalGammaRamp;
   LPVOID                       lpDDrawReserved6;
#ifndef WIN95
   DISPLAYMODEINFO              dmiDDrawReserved7;
#endif
   DWORD                        dwSurfaceHandle;    // cookie for use with CreateSurfaceEx DDI
   DWORD                        qwDDrawReserved8[2];
   LPVOID                       lpDDrawReserved9;
    DWORD                       cSurfaces;                  //PRIVATE
    LPDDSURFACEDESC2            pCreatedDDSurfaceDesc2;     //PRIVATE
    LPDDRAWI_DDRAWSURFACE_LCL   *slist;                     //PRIVATE
    DWORD                       dwFVF;              // saved FVF flags for exe bufs
   LPVOID                       lpVB;                       //PRIVATE
} DDRAWI_DDRAWSURFACE_MORE;

/*
 * Special values assigned to dwPFIndex member of DDRAWI_DDRAWSURFACE_MORE.
 */
#define PFINDEX_UNINITIALIZED  (0UL)    // pixel-format index is in uninitialized state
#define PFINDEX_UNSUPPORTED    (~0UL)   // surface's pixel format is not supported by HEL

/*
 * the LCL structure is local data for each individual surface object
 */
struct _DDRAWI_DDRAWSURFACE_LCL
{
    LPDDRAWI_DDRAWSURFACE_MORE      lpSurfMore; // pointer to additional local data
    LPDDRAWI_DDRAWSURFACE_GBL       lpGbl;      // pointer to surface shared data
    ULONG_PTR                        hDDSurface;     // NT Kernel-mode handle was dwUnused0
    LPATTACHLIST                    lpAttachList;   // link to surfaces we attached to
    LPATTACHLIST                    lpAttachListFrom;// link to surfaces that attached to this one
    DWORD                           dwLocalRefCnt;  // object refcnt
    DWORD                           dwProcessId;    // owning process
    DWORD                           dwFlags;    // flags
    DDSCAPS                         ddsCaps;    // capabilities of surface
    union
    {
        LPDDRAWI_DDRAWPALETTE_INT   lpDDPalette;    // associated palette
        LPDDRAWI_DDRAWPALETTE_INT   lp16DDPalette;  // 16-bit ptr to associated palette
    };
    union
    {
        LPDDRAWI_DDRAWCLIPPER_LCL   lpDDClipper;    // associated clipper
        LPDDRAWI_DDRAWCLIPPER_INT   lp16DDClipper;  // 16-bit ptr to associated clipper
    };
    DWORD                           dwModeCreatedIn;
    DWORD                           dwBackBufferCount; // number of back buffers created
    DDCOLORKEY                      ddckCKDestBlt;  // color key for destination blt use
    DDCOLORKEY                      ddckCKSrcBlt;   // color key for source blt use
//    IUnknown              FAR *pUnkOuter; // outer IUnknown
    ULONG_PTR                       hDC;        // owned dc
    ULONG_PTR                       dwReserved1;    // reserved for use by display driver

    /*
     * NOTE: this part of the structure is ONLY allocated if the surface
     *       can be used for overlays.  ddckCKSrcOverlay MUST NOT BE MOVED
     *       from the start of this area.
     */
    DDCOLORKEY                      ddckCKSrcOverlay;// color key for source overlay use
    DDCOLORKEY                      ddckCKDestOverlay;// color key for destination overlay use
    LPDDRAWI_DDRAWSURFACE_INT       lpSurfaceOverlaying; // surface we are overlaying
    DBLNODE                         dbnOverlayNode;
    /*
     * overlay rectangle, used by DDHEL
     */
    RECT                            rcOverlaySrc;
    RECT                            rcOverlayDest;
    /*
     * the below values are kept here for ddhel. they're set by UpdateOverlay,
     * they're used whenever the overlays are redrawn.
     */
    DWORD                           dwClrXparent;   // the *actual* color key (override, colorkey, or CLR_INVALID)
    DWORD                           dwAlpha;    // the per surface alpha
    /*
     * overlay position
     */
    LONG                            lOverlayX;  // current x position
    LONG                            lOverlayY;  // current y position
};
typedef struct _DDRAWI_DDRAWSURFACE_LCL DDRAWI_DDRAWSURFACE_LCL;

#define DDRAWISURFGBL_MEMFREE                   0x00000001L // video memory has been freed
#define DDRAWISURFGBL_SYSMEMREQUESTED           0x00000002L // surface is in system memory at request of user
#define DDRAWISURFGBL_ISGDISURFACE              0x00000004L // This surface represents what GDI thinks is front buffer
#define DDRAWISURFGBL_SOFTWAREAUTOFLIP          0x00000008L // This surface is autoflipped using software
#define DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK   0x00000010L // PRIVATE: a vram lock of the entire surface is not holding the Win16 lock
#define DDRAWISURFGBL_LOCKVRAMSTYLE             0x00000020L // PRIVATE: entire surface was locked with VRAM style lock
#define DDRAWISURFGBL_LOCKBROKEN                0x00000040L // PRIVATE: a lock of the entire surface was broken by an invalidate
#define DDRAWISURFGBL_IMPLICITHANDLE            0x00000080L // This dwKernelHandle was created implicitly
#define DDRAWISURFGBL_ISCLIENTMEM               0x00000100L // PRIVATE: the memory pointer to by fpVidMem was allocated by the client
#define DDRAWISURFGBL_HARDWAREOPSOURCE          0x00000200L // This surface was the source for an asynchronous hardware operation
#define DDRAWISURFGBL_HARDWAREOPDEST            0x00000400L // This surface was dest for an asynchronous hardware operation
#define DDRAWISURFGBL_HARDWAREOPSTARTED (DDRAWISURFGBL_HARDWAREOPSOURCE|DDRAWISURFGBL_HARDWAREOPDEST)
#define DDRAWISURFGBL_VPORTINTERLEAVED          0x00000800L // This surface contains interleaved video port data
#define DDRAWISURFGBL_VPORTDATA                 0x00001000L // This surface received data from the video port
#define DDRAWISURFGBL_LATEALLOCATELINEAR        0x00002000L // Optimized surface was allocated as a formless chunk. lPitch invalid, dwLinearSize valid.
#define DDRAWISURFGBL_SYSMEMEXECUTEBUFFER       0x00004000L // Driver sets this flag to tell ddraw that the surface was allocated in system memory
#define DDRAWISURFGBL_FASTLOCKHELD              0x00008000L // PRIVATE: indicates that InternLock took the fast path
#define DDRAWISURFGBL_READONLYLOCKHELD          0x00010000L // PRIVATE: indicates that the application indicated read-only lock
#define DDRAWISURFGBL_DX8SURFACE                0x00080000L // PRIVATE: indicates that the surace was created using DX8
#define DDRAWISURFGBL_DDHELDONTFREE             0x00100000L // PRIVATE: indicates that the surace memory should not be freed by the HEL
#define DDRAWISURFGBL_NOTIFYWHENUNLOCKED        0x00200000L // PRIVATE: indicates that the this surface help a NOSYSLOCK lock when a mode change occured


/*
 * NOTE: This flag was previously DDRAWISURFGBL_INVALID. This flags has been retired
 * and replaced by DDRAWISURF_INVALID in the local object.
 */
#define DDRAWISURFGBL_RESERVED0         0x80000000L // Reserved flag

#define DDRAWISURF_ATTACHED             0x00000001L // surface is attached to another
#define DDRAWISURF_IMPLICITCREATE       0x00000002L // surface implicitly created
#define DDRAWISURF_ISFREE               0x00000004L // surface already freed (temp flag)
#define DDRAWISURF_ATTACHED_FROM        0x00000008L // surface has others attached to it
#define DDRAWISURF_IMPLICITROOT         0x00000010L // surface root of implicit creation
#define DDRAWISURF_PARTOFPRIMARYCHAIN   0x00000020L // surface is part of primary chain
#define DDRAWISURF_DATAISALIASED        0x00000040L // used for thunking
#define DDRAWISURF_HASDC                0x00000080L // has a DC
#define DDRAWISURF_HASCKEYDESTOVERLAY   0x00000100L // surface has CKDestOverlay
#define DDRAWISURF_HASCKEYDESTBLT       0x00000200L // surface has CKDestBlt
#define DDRAWISURF_HASCKEYSRCOVERLAY    0x00000400L // surface has CKSrcOverlay
#define DDRAWISURF_HASCKEYSRCBLT        0x00000800L // surface has CKSrcBlt
#define DDRAWISURF_LOCKEXCLUDEDCURSOR   0x00001000L // surface was locked and excluded cursor
#define DDRAWISURF_HASPIXELFORMAT       0x00002000L // surface structure has pixel format data
#define DDRAWISURF_HASOVERLAYDATA       0x00004000L // surface structure has overlay data
#define DDRAWISURF_SETGAMMA             0x00008000L // gamma ramp for this surface is active
#define DDRAWISURF_SW_CKEYDESTOVERLAY   0x00010000L // surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYDESTBLT       0x00020000L // surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYSRCOVERLAY    0x00040000L // surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYSRCBLT        0x00080000L // surface expects to process colorkey in software
#define DDRAWISURF_HW_CKEYDESTOVERLAY   0x00100000L // surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYDESTBLT       0x00200000L // surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYSRCOVERLAY    0x00400000L // surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYSRCBLT        0x00800000L // surface expects to process colorkey in hardware
#define DDRAWISURF_INMASTERSPRITELIST   0x01000000l // surface is referenced in master sprite list
#define DDRAWISURF_HELCB                0x02000000L // surface is the ddhel cb. must call hel for lock/blt.
#define DDRAWISURF_FRONTBUFFER          0x04000000L // surface was originally a front buffer
#define DDRAWISURF_BACKBUFFER           0x08000000L // surface was originally backbuffer
#define DDRAWISURF_INVALID              0x10000000L     // surface has been invalidated by mode set
#define DDRAWISURF_DCIBUSY              0x20000000L     // HEL has turned off BUSY so DCI would work
#define DDRAWISURF_GETDCNULL            0x40000000L     // getdc could not lock and so returned GetDC(NULL)

//#define DDRAWISURF_CANTLOCK             0x20000000L     // surface cannot be locked (primary created by HEL)
#define DDRAWISURF_STEREOSURFACELEFT    0x20000000L     // surface is left of stereo pair
#define DDRAWISURF_DRIVERMANAGED        0x40000000L // Surface is a driver managed texture (D3D)
#define DDRAWISURF_DCILOCK              0x80000000L // Surface was locked using DCIBeginAccess

/*
 * rop stuff
 */
#define ROP_HAS_SOURCE      0x00000001l
#define ROP_HAS_PATTERN     0x00000002l
#define ROP_HAS_SOURCEPATTERN   ROP_HAS_SOURCE | ROP_HAS_PATTERN

/*
 * mode information
 */
typedef struct _DDHALMODEINFO
{
    DWORD   dwWidth;        // width (in pixels) of mode
    DWORD   dwHeight;       // height (in pixels) of mode
    LONG    lPitch;         // pitch (in bytes) of mode
    DWORD   dwBPP;          // bits per pixel
    WORD    wFlags;         // flags
    WORD    wRefreshRate;       // refresh rate
    DWORD   dwRBitMask;     // red bit mask
    DWORD   dwGBitMask;     // green bit mask
    DWORD   dwBBitMask;     // blue bit mask
    DWORD   dwAlphaBitMask;     // alpha bit mask
} DDHALMODEINFO;
typedef DDHALMODEINFO FAR *LPDDHALMODEINFO;

#define DDMODEINFO_PALETTIZED   0x0001  // mode is palettized
#define DDMODEINFO_MODEX        0x0002  // mode is a modex mode
#define DDMODEINFO_UNSUPPORTED  0x0004  // mode is not supported by driver

/*
 * Note internally, standard VGA modes are tagged as MODEX and STANDARDVGA
 */
#define DDMODEINFO_STANDARDVGA  0x0008  // mode is standard vga, e.g. mode 0x13

#define DDMODEINFO_MAXREFRESH   0x0010  // refresh rate specified is the max supported
#define DDMODEINFO_STEREO       0x0020  // mode can be switched to stereo


/*
 * DDRAW interface struct
 */
typedef struct _DDRAWI_DIRECTDRAW_INT
{
    LPVOID                      lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DIRECTDRAW_LCL     lpLcl;      // pointer to interface data
    LPDDRAWI_DIRECTDRAW_INT     lpLink;     // link to next interface
    DWORD                       dwIntRefCnt;    // interface reference count
} DDRAWI_DIRECTDRAW_INT;

/*
 * DDRAW version of DirectDraw object; it has data after the vtable
 *
 * all entries marked as PRIVATE are not for use by the display driver
 */
typedef struct _DDHAL_CALLBACKS
{
    DDHAL_DDCALLBACKS           cbDDCallbacks;  // addresses in display driver for DIRECTDRAW object HAL
    DDHAL_DDSURFACECALLBACKS    cbDDSurfaceCallbacks; // addresses in display driver for DIRECTDRAWSURFACE object HAL
    DDHAL_DDPALETTECALLBACKS    cbDDPaletteCallbacks; // addresses in display driver for DIRECTDRAWPALETTE object HAL
    DDHAL_DDCALLBACKS           HALDD;      // HAL for DIRECTDRAW object
    DDHAL_DDSURFACECALLBACKS    HALDDSurface;   // HAL for DIRECTDRAWSURFACE object
    DDHAL_DDPALETTECALLBACKS    HALDDPalette;   // HAL for DIRECTDRAWPALETTE object
    DDHAL_DDCALLBACKS           HELDD;      // HEL for DIRECTDRAW object
    DDHAL_DDSURFACECALLBACKS    HELDDSurface;   // HEL for DIRECTDRAWSURFACE object
    DDHAL_DDPALETTECALLBACKS    HELDDPalette;   // HEL for DIRECTDRAWPALETTE object
    DDHAL_DDEXEBUFCALLBACKS     cbDDExeBufCallbacks; // addresses in display driver for DIRECTDRAWEXEBUF pseudo object HAL
    DDHAL_DDEXEBUFCALLBACKS     HALDDExeBuf;    // HAL for DIRECTDRAWEXEBUF pseudo object
    DDHAL_DDEXEBUFCALLBACKS     HELDDExeBuf;    // HEL for DIRECTDRAWEXEBUF preudo object
    DDHAL_DDVIDEOPORTCALLBACKS  cbDDVideoPortCallbacks; // addresses in display driver for VideoPort object HAL
    DDHAL_DDVIDEOPORTCALLBACKS  HALDDVideoPort; // HAL for DIRECTDRAWVIDEOPORT psuedo object
    DDHAL_DDCOLORCONTROLCALLBACKS cbDDColorControlCallbacks; // addresses in display driver for color control object HAL
    DDHAL_DDCOLORCONTROLCALLBACKS HALDDColorControl; // HAL for DIRECTDRAWCOLORCONTROL psuedo object
    DDHAL_DDMISCELLANEOUSCALLBACKS cbDDMiscellaneousCallbacks;
    DDHAL_DDMISCELLANEOUSCALLBACKS HALDDMiscellaneous;
    DDHAL_DDKERNELCALLBACKS     cbDDKernelCallbacks;
    DDHAL_DDKERNELCALLBACKS HALDDKernel;
    DDHAL_DDMOTIONCOMPCALLBACKS cbDDMotionCompCallbacks;
    DDHAL_DDMOTIONCOMPCALLBACKS HALDDMotionComp;
 } DDHAL_CALLBACKS, far *LPDDHAL_CALLBACKS;


/*
 * This structure mirrors the first entries of the DDCAPS but is of a fixed
 * size and will not grow as DDCAPS grows. This is the structure your driver
 * returns in DDCOREINFO. Additional caps will be requested via a GetDriverInfo
 * call.
 */
typedef struct _DDCORECAPS
{
    DWORD   dwSize;         // size of the DDDRIVERCAPS structure
    DWORD   dwCaps;         // driver specific capabilities
    DWORD   dwCaps2;        // more driver specific capabilites
    DWORD   dwCKeyCaps;     // color key capabilities of the surface
    DWORD   dwFXCaps;       // driver specific stretching and effects capabilites
    DWORD   dwFXAlphaCaps;      // alpha driver specific capabilities
    DWORD   dwPalCaps;      // palette capabilities
    DWORD   dwSVCaps;       // stereo vision capabilities
    DWORD   dwAlphaBltConstBitDepths;   // DDBD_2,4,8
    DWORD   dwAlphaBltPixelBitDepths;   // DDBD_1,2,4,8
    DWORD   dwAlphaBltSurfaceBitDepths; // DDBD_1,2,4,8
    DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD   dwZBufferBitDepths;     // DDBD_8,16,24,32
    DWORD   dwVidMemTotal;      // total amount of video memory
    DWORD   dwVidMemFree;       // amount of free video memory
    DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD   dwNumFourCCCodes;   // number of four cc codes
    DWORD   dwAlignBoundarySrc; // source rectangle alignment
    DWORD   dwAlignSizeSrc;     // source rectangle byte size
    DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD   dwAlignSizeDest;    // dest rectangle byte size
    DWORD   dwAlignStrideAlign; // stride alignment
    DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS ddsCaps;        // DDSCAPS structure has all the general capabilities
    DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwReserved1;        // reserved
    DWORD   dwReserved2;        // reserved
    DWORD   dwReserved3;        // reserved
    DWORD   dwSVBCaps;      // driver specific capabilities for System->Vmem blts
    DWORD   dwSVBCKeyCaps;      // driver color key capabilities for System->Vmem blts
    DWORD   dwSVBFXCaps;        // driver FX capabilities for System->Vmem blts
    DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD   dwVSBCaps;      // driver specific capabilities for Vmem->System blts
    DWORD   dwVSBCKeyCaps;      // driver color key capabilities for Vmem->System blts
    DWORD   dwVSBFXCaps;        // driver FX capabilities for Vmem->System blts
    DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD   dwSSBCaps;      // driver specific capabilities for System->System blts
    DWORD   dwSSBCKeyCaps;      // driver color key capabilities for System->System blts
    DWORD   dwSSBFXCaps;        // driver FX capabilities for System->System blts
    DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD   dwMaxVideoPorts;    // maximum number of usable video ports
    DWORD   dwCurrVideoPorts;   // current number of video ports used
    DWORD   dwSVBCaps2;     // more driver specific capabilities for System->Vmem blts
} DDCORECAPS;

typedef DDCORECAPS FAR* LPDDCORECAPS;

typedef struct _DDRAWI_DIRECTDRAW_GBL
{
/*  0*/ DWORD                   dwRefCnt;    // reference count
/*  4*/ DWORD                   dwFlags;     // flags
/*  8*/ FLATPTR                 fpPrimaryOrig;   // primary surf vid mem. ptr
/*  c*/ DDCORECAPS              ddCaps;      // driver caps
/*148*/ DWORD                   dwInternal1;     // Private to ddraw.dll
/*16c*/ DWORD                   dwUnused1[9];    // not currently used
/*170*/ LPDDHAL_CALLBACKS       lpDDCBtmp;   // HAL callbacks
/*174*/ LPDDRAWI_DDRAWSURFACE_INT   dsList;      // PRIVATE: list of all surfaces
/*178*/ LPDDRAWI_DDRAWPALETTE_INT   palList;     // PRIVATE: list of all palettes
/*17c*/ LPDDRAWI_DDRAWCLIPPER_INT   clipperList;     // PRIVATE: list of all clippers
/*180*/ LPDDRAWI_DIRECTDRAW_GBL     lp16DD;      // PRIVATE: 16-bit ptr to this struct
/*184*/ DWORD                   dwMaxOverlays;   // maximum number of overlays
/*188*/ DWORD                   dwCurrOverlays;  // current number of visible overlays
/*18c*/ DWORD                   dwMonitorFrequency; // monitor frequency in current mode
/*190*/ DDCORECAPS              ddHELCaps;   // HEL capabilities
/*2cc*/ DWORD                   dwUnused2[50];   // not currently used
/*394*/ DDCOLORKEY              ddckCKDestOverlay; // color key for destination overlay use
/*39c*/ DDCOLORKEY              ddckCKSrcOverlay; // color key for source overlay use
/*3a4*/ VIDMEMINFO              vmiData;     // info about vid memory
/*3f4*/ LPVOID                  lpDriverHandle;  // handle for use by display driver
/*   */                          // to call fns in DDRAW16.DLL
/*3f8*/ LPDDRAWI_DIRECTDRAW_LCL         lpExclusiveOwner;   // PRIVATE: exclusive local object
/*3fc*/ DWORD                   dwModeIndex;     // current mode index
/*400*/ DWORD                   dwModeIndexOrig; // original mode index
/*404*/ DWORD                   dwNumFourCC;     // number of fourcc codes supported
/*408*/ DWORD                   FAR *lpdwFourCC; // PRIVATE: fourcc codes supported
/*40c*/ DWORD                   dwNumModes;  // number of modes supported
/*410*/ LPDDHALMODEINFO         lpModeInfo;  // PRIVATE: mode information
/*424*/ PROCESS_LIST            plProcessList;   // PRIVATE: list of processes using driver
/*428*/ DWORD                   dwSurfaceLockCount; // total number of outstanding locks
/*42c*/ DWORD                   dwAliasedLockCnt; // PRIVATE: number of outstanding aliased locks
/*430*/ ULONG_PTR                dwReserved3;     // reserved for use by display driver
/*434*/ ULONG_PTR                hDD;             // PRIVATE: NT Kernel-mode handle (was dwFree3).
/*438*/ char                    cObsolete[12];   // Obsolete field, do not use
/*444*/ DWORD                   dwReserved1;     // reserved for use by display driver
/*448*/ DWORD                   dwReserved2;     // reserved for use by display driver
/*44c*/ DBLNODE                 dbnOverlayRoot;  // The root node of the doubly-
/*   */                                                  // linked list of overlay z orders.
/*45c*/ volatile LPWORD         lpwPDeviceFlags; // driver physical device flags
/*460*/ DWORD                   dwPDevice;       // driver physical device (16:16 pointer)
/*464*/ DWORD                   dwWin16LockCnt;  // count on win16 holds
/*468*/ DWORD                   dwUnused3;       // was lpWin16LockOwner
/*46c*/ DWORD                   hInstance;       // instance handle of driver
/*470*/ DWORD                   dwEvent16;       // 16-bit event
/*474*/ DWORD                   dwSaveNumModes;  // saved number of modes supported
/*   */ //------- Fields added in Version 2.0 -------
/*478*/ ULONG_PTR                lpD3DGlobalDriverData;  // Global D3D Data
/*47c*/ ULONG_PTR                lpD3DHALCallbacks;  // D3D HAL Callbacks
/*480*/ DDCORECAPS              ddBothCaps;      // logical AND of driver and HEL caps
/*   */ //------- Fields added in Version 5.0 -------
/*5bc*/ LPDDVIDEOPORTCAPS       lpDDVideoPortCaps;// Info returned by the HAL (an array if more than one video port)
/*5c0*/ LPDDRAWI_DDVIDEOPORT_INT    dvpList;     // PRIVATE: list of all video ports
/*5c4*/ ULONG_PTR                lpD3DHALCallbacks2;     // Post-DX3 D3D HAL callbacks
/*5c8*/ RECT                    rectDevice;  // rectangle (in desktop coord) for device
/*5d8*/ DWORD                   cMonitors;   // number of monitors in the system
/*5dc*/ LPVOID                  gpbmiSrc;    // PRIVATE: used by HEL
/*5e0*/ LPVOID                  gpbmiDest;   // PRIVATE: used by HEL
/*5e4*/ LPHEAPALIASINFO         phaiHeapAliases; // PRIVATE: video memory heap aliases
/*5e8*/ ULONG_PTR               hKernelHandle;
/*5ec*/ ULONG_PTR               pfnNotifyProc;   // Notification proc registered w/ VDD
/*5f0*/ LPDDKERNELCAPS          lpDDKernelCaps;  // Capabilies of kernel mode interface
/*5f4*/ LPDDNONLOCALVIDMEMCAPS  lpddNLVCaps;     // hardware non-local to local vidmem caps
/*5f8*/ LPDDNONLOCALVIDMEMCAPS  lpddNLVHELCaps;  // emulation layer non-local to local vidmem caps
/*5fc*/ LPDDNONLOCALVIDMEMCAPS  lpddNLVBothCaps; // logical AND of hardware and emulation non-local to local vidmem caps
/*600*/ ULONG_PTR                lpD3DExtendedCaps; // extended caps for D3D
/*   */ //--------Fields added in Version 5.0A
/*604*/ DWORD                   dwDOSBoxEvent;      // Event set when returning from a DOS box
/*608*/ RECT                    rectDesktop;        // Desktop coordinates
/*618*/ char                    cDriverName[MAX_DRIVER_NAME]; // Display name
/*   */ //------- Fields added in Version 6.0 -------
/*638*/ ULONG_PTR                lpD3DHALCallbacks3;     // DX6 D3D callbacks
/*63c*/ DWORD                   dwNumZPixelFormats;     // Number of z-buffer+stencil pixel formats
/*640*/ LPDDPIXELFORMAT         lpZPixelFormats;        // Pointer to array of z-buffer pixel formats
/*644*/ LPDDRAWI_DDMOTIONCOMP_INT mcList;               // PRIVATE: list of all motion comp objects
/*648*/ DWORD                   hDDVxd;                 // handle to ddraw.vxd
/*64c*/ DDSCAPSEX               ddsCapsMore;            // as queried via GUID_DDMoreSurfaceCaps
} DDRAWI_DIRECTDRAW_GBL;


typedef struct _DDRAWI_DIRECTDRAW_LCL
{
    DWORD                       lpDDMore;           // pointer to additional local data
    LPDDRAWI_DIRECTDRAW_GBL     lpGbl;              // pointer to data
    DWORD                       dwUnused0;          // not currently used
    DWORD                       dwLocalFlags;       // local flags (DDRAWILCL_)
    DWORD                       dwLocalRefCnt;      // local ref cnt
    DWORD                       dwProcessId;        // owning process id
    IUnknown                    FAR *pUnkOuter;     // outer IUnknown
    DWORD                       dwObsolete1;
    ULONG_PTR                   hWnd;
    ULONG_PTR                   hDC;
    DWORD                       dwErrorMode;
    LPDDRAWI_DDRAWSURFACE_INT   lpPrimary;
    LPDDRAWI_DDRAWSURFACE_INT   lpCB;
    DWORD                       dwPreferredMode;
    //------- Fields added in Version 2.0 -------
    HINSTANCE                   hD3DInstance;       // Handle of Direct3D's DLL.
    IUnknown                    FAR *pD3DIUnknown;  // Direct3D's aggregated IUnknown.
    LPDDHAL_CALLBACKS           lpDDCB;             // HAL callbacks
    ULONG_PTR                   hDDVxd;             // handle to ddraw.vxd
    //------- Fields added in Version 5.0 -------
    DWORD                       dwAppHackFlags;     // app compatibilty flags
    //------- Fields added in Version 5.A -------
    ULONG_PTR                   hFocusWnd;          // Focus window set via SetCoopLevel
    DWORD                       dwHotTracking;      // Reactive menu etc setting cached while fullscreen
    DWORD                       dwIMEState;         // IME toolbar setting cached while fullscreen
    //------- Fields added in Version 6.0 -------
    ULONG_PTR                   hWndPopup;
    ULONG_PTR                   hDD;                // PRIVATE: NT Kernel-mode handle
    ULONG_PTR                   hGammaCalibrator;   // Private
    LPDDGAMMACALIBRATORPROC     lpGammaCalibrator;  // Private
} DDRAWI_DIRECTDRAW_LCL;

#define DDRAWILCL_HASEXCLUSIVEMODE          0x00000001l
#define DDRAWILCL_ISFULLSCREEN              0x00000002l
#define DDRAWILCL_SETCOOPCALLED             0x00000004l
#define DDRAWILCL_ACTIVEYES                 0x00000008l
#define DDRAWILCL_ACTIVENO                  0x00000010l
#define DDRAWILCL_HOOKEDHWND                0x00000020l
#define DDRAWILCL_ALLOWMODEX                0x00000040l
#define DDRAWILCL_V1SCLBEHAVIOUR            0x00000080l
#define DDRAWILCL_MODEHASBEENCHANGED        0x00000100l
#define DDRAWILCL_CREATEDWINDOW             0x00000200l
#define DDRAWILCL_DIRTYDC                   0x00000400l     // Set on ChangeDisplaySettings, cleared when device DC is reinited
#define DDRAWILCL_DISABLEINACTIVATE         0x00000800l
#define DDRAWILCL_CURSORCLIPPED             0x00001000l
#define DDRAWILCL_EXPLICITMONITOR           0x00002000l // device was chosen explicitly i.e. not DDrawCreate(NULL)
#define DDRAWILCL_MULTITHREADED             0x00004000l // App threaten to be multithreaded
#define DDRAWILCL_FPUSETUP                  0x00008000l // D3D does not need to switch to single prec/exceptions disabled each time
#define DDRAWILCL_POWEREDDOWN               0x00010000l // Private: indicates that screen saver is powered down
#define DDRAWILCL_DIRECTDRAW7               0x00020000l // PRIVATE: Marks if this is a IDirectDraw7 object
#define DDRAWILCL_ATTEMPTEDD3DCONTEXT       0x00040000l // PRIVATE: Marks if this ddraw local has attempted to create a d3d context
#define DDRAWILCL_FPUPRESERVE               0x00080000l // D3D needs to switch to single prec/exceptions disabled each time
#define DDRAWILCL_DX8DRIVER                 0x00100000l // PRIVATE: Set if this drvier can handle lightweight surfaces
#define DDRAWILCL_DIRECTDRAW8               0x00200000l // PRIVATE: Marks if this is a IDirectDraw8 object

#define DDRAWI_xxxxxxxxx1                   0x00000001l     // unused
#define DDRAWI_xxxxxxxxx2                   0x00000002l // unused
#define DDRAWI_VIRTUALDESKTOP               0x00000008l     // driver is really a multi-monitor virtual desktop
#define DDRAWI_MODEX                        0x00000010l // driver is using modex
#define DDRAWI_DISPLAYDRV                   0x00000020l // driver is display driver
#define DDRAWI_FULLSCREEN                   0x00000040l // driver in fullscreen mode
#define DDRAWI_MODECHANGED                  0x00000080l // display mode has been changed
#define DDRAWI_NOHARDWARE                   0x00000100l // no driver hardware at all
#define DDRAWI_PALETTEINIT                  0x00000200l // GDI palette stuff has been initalized
#define DDRAWI_NOEMULATION                  0x00000400l // no emulation at all
#define DDRAWI_HASCKEYDESTOVERLAY           0x00000800l // driver has CKDestOverlay
#define DDRAWI_HASCKEYSRCOVERLAY            0x00001000l // driver has CKSrcOverlay
#define DDRAWI_HASGDIPALETTE                0x00002000l // GDI palette exists on primary surface
#define DDRAWI_EMULATIONINITIALIZED         0x00004000l // emulation is initialized
#define DDRAWI_HASGDIPALETTE_EXCLUSIVE      0x00008000l     // exclusive mode palette
#define DDRAWI_MODEXILLEGAL                 0x00010000l // modex is not supported by this hardware
#define DDRAWI_FLIPPEDTOGDI                 0x00020000l     // driver has been flipped to show GDI surface
#define DDRAWI_NEEDSWIN16FORVRAMLOCK        0x00040000l     // PRIVATE: Win16 lock must be taken when locking a VRAM surface
#define DDRAWI_PDEVICEVRAMBITCLEARED        0x00080000l     // PRIVATE: the PDEVICE's VRAM bit was cleared by a lock
#define DDRAWI_STANDARDVGA                  0x00100000l     // Device is using standard VGA mode (DDRAWI_MODEX will be set)
#define DDRAWI_EXTENDEDALIGNMENT            0x00200000l     // At least one heap has extended alignment. Ignore alignment in VIDMEMINFO
#define DDRAWI_CHANGINGMODE                 0x00400000l     // Currently in the middle of a mode change
#define DDRAWI_GDIDRV                       0x00800000l     // Driver is a GDI driver
#define DDRAWI_ATTACHEDTODESKTOP            0x01000000l     // Device is attached to the desktop
#define DDRAWI_UMODELOADED                  0x02000000l     // User mode driver dll is loaded
#define DDRAWI_DDRAWDATANOTFETCHED          0x04000000l     // PRIVATE: Marks mode-change data fetched (NT)
#define DDRAWI_SECONDARYDRIVERLOADED        0x08000000l     // PRIVATE: Marks if a secndary PVR-style HAL was loaded
#define DDRAWI_TESTINGMODES                 0x10000000l     // PRIVATE: A mode test in is progress
#define DDRAWI_DRIVERINFO2                  0x20000000l     // PRIVATE: Driver supports GetDriverInfo2
#define DDRAWI_BADPDEV                      0x40000000l     // PRIVATE: Indiactes that we should not re-use this PDEV


/*
 * VideoPort object interface
 */
typedef struct _DDRAWI_DDVIDEOPORT_INT
{
    LPVOID                      lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DDVIDEOPORT_LCL    lpLcl;      // pointer to interface data
    LPDDRAWI_DDVIDEOPORT_INT    lpLink;     // link to next interface
    DWORD                       dwIntRefCnt;    // interface reference count
    DWORD                       dwFlags;    // Private
} DDRAWI_DDVIDEOPORT_INT;

typedef struct _DDRAWI_DDVIDEOPORT_LCL
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;       // pointer to DIRECTDRAW_LCL
    DDVIDEOPORTDESC             ddvpDesc;   // description used at create time
    DDVIDEOPORTINFO             ddvpInfo;   // most recent video port info
    LPDDRAWI_DDRAWSURFACE_INT   lpSurface;  // surface receiving the data
    LPDDRAWI_DDRAWSURFACE_INT   lpVBISurface;   // surface receiving the VBI data
    LPDDRAWI_DDRAWSURFACE_INT   *lpFlipInts;    // PRIVATE: surfaces currently being autoflipped
    DWORD                       dwNumAutoflip;  // Number of current autoflip surfaces
    DWORD                       dwProcessID;    // ID of process owning this video port
    DWORD                       dwStateFlags;
    DWORD                       dwFlags;
    DWORD                       dwRefCnt;
    FLATPTR                     fpLastFlip;     // Location from which we last flipped
    ULONG_PTR                   dwReserved1;    // Reserved for display driver
    ULONG_PTR                   dwReserved2;    // Reserved for display driver
    HANDLE                      hDDVideoPort;   // NT Kernel-mode handle
    DWORD                       dwNumVBIAutoflip;//Number of VBI surfaces currently being autoflipped
    LPDDVIDEOPORTDESC           lpVBIDesc;  // PRIVATE
    LPDDVIDEOPORTDESC           lpVideoDesc;    // PRIVATE
    LPDDVIDEOPORTINFO           lpVBIInfo;  // PRIVATE
    LPDDVIDEOPORTINFO           lpVideoInfo;    // PRIVATE
    DWORD                       dwVBIProcessID; // ID of process owning this video port
    LPDDRAWI_DDVIDEOPORT_INT    lpVPNotify;
} DDRAWI_DDVIDEOPORT_LCL;

#define DDRAWIVPORT_ON                  0x00000001  // Video port is pumping data
#define DDRAWIVPORT_SOFTWARE_AUTOFLIP   0x00000002  // Video port cannot use hardware autoflip
#define DDRAWIVPORT_COLORKEYANDINTERP   0x00000004      // Overlay cannot bob and colorkey at same time
#define DDRAWIVPORT_NOKERNELHANDLES     0x00000008      // Unable to allocate kernel resources
#define DDRAWIVPORT_SOFTWARE_BOB        0x00000010  // All bobbing must be performed in software
#define DDRAWIVPORT_VBION               0x00000020  // Video is on for the VBI region
#define DDRAWIVPORT_VIDEOON             0x00000040  // Video is on for the video region

/*
 * MotionComp object interface
 */
typedef struct _DDRAWI_DDMOTIONCOMP_INT
{
    LPVOID                      lpVtbl;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpLcl;
    LPDDRAWI_DDMOTIONCOMP_INT   lpLink;
    DWORD                       dwIntRefCnt;
} DDRAWI_DDMOTIONCOMP_INT;

typedef struct _DDRAWI_DDMOTIONCOMP_LCL
{
    LPDDRAWI_DIRECTDRAW_LCL lpDD;
    GUID                    guid;
    DWORD                   dwUncompWidth;
    DWORD                   dwUncompHeight;
    DDPIXELFORMAT           ddUncompPixelFormat;
    DWORD                   dwInternalFlags;
    DWORD                   dwRefCnt;
    DWORD                   dwProcessId;
    HANDLE                  hMoComp;
    DWORD                   dwDriverReserved1;
    DWORD                   dwDriverReserved2;
    DWORD                   dwDriverReserved3;
    LPVOID                  lpDriverReserved1;
    LPVOID                  lpDriverReserved2;
    LPVOID                  lpDriverReserved3;
} DDRAWI_DDMOTIONCOMP_LCL;


/*
 * structure for display driver to call DDHAL_Create with
 */
typedef struct _DDHALINFO
{
    DWORD                       dwSize;
    LPDDHAL_DDCALLBACKS         lpDDCallbacks;      // direct draw object callbacks
    LPDDHAL_DDSURFACECALLBACKS  lpDDSurfaceCallbacks;   // surface object callbacks
    LPDDHAL_DDPALETTECALLBACKS  lpDDPaletteCallbacks;   // palette object callbacks
    VIDMEMINFO                  vmiData;        // video memory info
    DDCORECAPS                  ddCaps;         // core hw specific caps
    DWORD                       dwMonitorFrequency; // monitor frequency in current mode
    LPDDHAL_GETDRIVERINFO       GetDriverInfo;          // callback to get arbitrary vtable from driver
    DWORD                       dwModeIndex;        // current mode: index into array
    LPDWORD                     lpdwFourCC;     // fourcc codes supported
    DWORD                       dwNumModes;     // number of modes supported
    LPDDHALMODEINFO             lpModeInfo;     // mode information
    DWORD                       dwFlags;        // create flags
    LPVOID                      lpPDevice;      // physical device ptr
    DWORD                       hInstance;      // instance handle of driver
    //------- Fields added in Version 2.0 -------
    ULONG_PTR                    lpD3DGlobalDriverData;  // D3D global Data
    ULONG_PTR                   lpD3DHALCallbacks;  // D3D callbacks
    LPDDHAL_DDEXEBUFCALLBACKS   lpDDExeBufCallbacks;    // Execute buffer pseudo object callbacks
} DDHALINFO;
typedef DDHALINFO FAR *LPDDHALINFO;

#define DDHALINFOSIZE_V2 sizeof( DDHALINFO )

#define DDHALINFO_ISPRIMARYDISPLAY  0x00000001l // indicates driver is primary display driver
#define DDHALINFO_MODEXILLEGAL      0x00000002l // indicates this hardware does not support modex modes
#define DDHALINFO_GETDRIVERINFOSET  0x00000004l // indicates that GetDriverInfo is set
#define DDHALINFO_GETDRIVERINFO2    0x00000008l // indicates driver support GetDriverInfo2 variant
                                                // of GetDriverInfo. New for DX 8.0

/*
 * DDRAW16.DLL entry points
 */
typedef BOOL (DDAPI *LPDDHAL_SETINFO)( LPDDHALINFO lpDDHalInfo, BOOL reset );
typedef FLATPTR (DDAPI *LPDDHAL_VIDMEMALLOC)( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, DWORD dwWidth, DWORD dwHeight );
typedef void (DDAPI *LPDDHAL_VIDMEMFREE)( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, FLATPTR fpMem );

extern BOOL DDAPI DDHAL_SetInfo( LPDDHALINFO lpDDHALInfo, BOOL reset );
extern FLATPTR DDAPI DDHAL_VidMemAlloc( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, DWORD dwWidth, DWORD dwHeight );
extern void DDAPI DDHAL_VidMemFree( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, FLATPTR fpMem );


typedef struct
{
    DWORD               dwSize;
    LPDDHAL_SETINFO     lpSetInfo;
    LPDDHAL_VIDMEMALLOC lpVidMemAlloc;
    LPDDHAL_VIDMEMFREE  lpVidMemFree;
} DDHALDDRAWFNS;
typedef DDHALDDRAWFNS FAR *LPDDHALDDRAWFNS;

/****************************************************************************
 *
 * DDHAL structures for Surface Object callbacks
 *
 ***************************************************************************/


/*
 * structure for passing information to DDHAL Blt and AlphaBlt fns
 */
typedef struct _DDHAL_BLTDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDDestSurface;// dest surface
    RECTL                       rDest;      // dest rect
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSrcSurface; // src surface
    RECTL                       rSrc;       // src rect
    DWORD                       dwFlags;    // blt flags
    DWORD                       dwROPFlags; // ROP flags (valid for ROPS only)
    DDBLTFX                     bltFX;      // blt FX
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_BLT           Blt;        // PRIVATE: ptr to callback
    BOOL                        IsClipped;      // clipped blt?
    RECTL                       rOrigDest;  // unclipped dest rect
                                            // (only valid if IsClipped)
    RECTL                       rOrigSrc;   // unclipped src rect
                                            // (only valid if IsClipped)
    DWORD                       dwRectCnt;  // count of dest rects
                                            // (only valid if IsClipped)
    LPRECT                      prDestRects;    // array of dest rects

} DDHAL_BLTDATA;

/*
 * structure for passing information to DDHAL Lock fn
 */
typedef struct _DDHAL_LOCKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       bHasRect;   // rArea is valid
    RECTL                       rArea;      // area being locked
    LPVOID                      lpSurfData; // pointer to screen memory (return value)
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_LOCK          Lock;           // PRIVATE: ptr to callback
    DWORD                       dwFlags;        // DDLOCK flags
} DDHAL_LOCKDATA;

/*
 * structure for passing information to DDHAL Unlock fn
 */
typedef struct _DDHAL_UNLOCKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    LPDDHALSURFCB_UNLOCK        Unlock;     // PRIVATE: ptr to callback
} DDHAL_UNLOCKDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DDHAL_UPDATEOVERLAYDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDDestSurface;// dest surface
    RECTL                       rDest;      // dest rect
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSrcSurface; // src surface
    RECTL                       rSrc;       // src rect
    DWORD                       dwFlags;    // flags
    DDOVERLAYFX                 overlayFX;  // overlay FX
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_UPDATEOVERLAY UpdateOverlay;  // PRIVATE: ptr to callback
} DDHAL_UPDATEOVERLAYDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DDHAL_SETOVERLAYPOSITIONDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSrcSurface; // src surface
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDDestSurface;// dest surface
    LONG                        lXPos;      // x position
    LONG                        lYPos;      // y position
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_SETOVERLAYPOSITION SetOverlayPosition; // PRIVATE: ptr to callback
} DDHAL_SETOVERLAYPOSITIONDATA;
/*
 * structure for passing information to DDHAL SetPalette fn
 */
typedef struct _DDHAL_SETPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    LPDDRAWI_DDRAWPALETTE_GBL   lpDDPalette;    // palette to set to surface
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_SETPALETTE    SetPalette; // PRIVATE: ptr to callback
    BOOL                        Attach;         // attach this palette?
} DDHAL_SETPALETTEDATA;

/*
 * structure for passing information to DDHAL Flip fn
 */
typedef struct _DDHAL_FLIPDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfCurr; // current surface
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfTarg; // target surface (to flip to)
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_FLIP          Flip;       // PRIVATE: ptr to callback
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfCurrLeft; // current surface
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfTargLeft; // target surface (to flip to)
} DDHAL_FLIPDATA;

/*
 * structure for passing information to DDHAL DestroySurface fn
 */
typedef struct _DDHAL_DESTROYSURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_DESTROYSURFACE DestroySurface;// PRIVATE: ptr to callback
} DDHAL_DESTROYSURFACEDATA;

/*
 * structure for passing information to DDHAL SetClipList fn
 */
typedef struct _DDHAL_SETCLIPLISTDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_SETCLIPLIST   SetClipList;    // PRIVATE: ptr to callback
} DDHAL_SETCLIPLISTDATA;

/*
 * structure for passing information to DDHAL AddAttachedSurface fn
 */
typedef struct _DDHAL_ADDATTACHEDSURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL         lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL       lpDDSurface;    // surface struct
    LPDDRAWI_DDRAWSURFACE_LCL       lpSurfAttached; // surface to attach
    HRESULT                         ddRVal;     // return value
    LPDDHALSURFCB_ADDATTACHEDSURFACE    AddAttachedSurface; // PRIVATE: ptr to callback
} DDHAL_ADDATTACHEDSURFACEDATA;

/*
 * structure for passing information to DDHAL SetColorKey fn
 */
typedef struct _DDHAL_SETCOLORKEYDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    DDCOLORKEY                  ckNew;      // new color key
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_SETCOLORKEY   SetColorKey;    // PRIVATE: ptr to callback
} DDHAL_SETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetBltStatus fn
 */
typedef struct _DDHAL_GETBLTSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_GETBLTSTATUS  GetBltStatus;   // PRIVATE: ptr to callback
} DDHAL_GETBLTSTATUSDATA;

/*
 * structure for passing information to DDHAL GetFlipStatus fn
 */
typedef struct _DDHAL_GETFLIPSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_GETFLIPSTATUS GetFlipStatus;  // PRIVATE: ptr to callback
} DDHAL_GETFLIPSTATUSDATA;

/****************************************************************************
 *
 * DDHAL structures for Palette Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL DestroyPalette fn
 */
typedef struct _DDHAL_DESTROYPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWPALETTE_GBL   lpDDPalette;    // palette struct
    HRESULT                     ddRVal;     // return value
    LPDDHALPALCB_DESTROYPALETTE DestroyPalette; // PRIVATE: ptr to callback
} DDHAL_DESTROYPALETTEDATA;

/*
 * structure for passing information to DDHAL SetEntries fn
 */
typedef struct _DDHAL_SETENTRIESDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWPALETTE_GBL   lpDDPalette;    // palette struct
    DWORD                       dwBase;     // base palette index
    DWORD                       dwNumEntries;   // number of palette entries
    LPPALETTEENTRY              lpEntries;  // color table
    HRESULT                     ddRVal;     // return value
    LPDDHALPALCB_SETENTRIES     SetEntries; // PRIVATE: ptr to callback
} DDHAL_SETENTRIESDATA;

/****************************************************************************
 *
 * DDHAL structures for Driver Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CreateSurface fn
 */
typedef struct _DDHAL_CREATESURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDSURFACEDESC             lpDDSurfaceDesc;// description of surface being created
    LPDDRAWI_DDRAWSURFACE_LCL   FAR *lplpSList; // list of created surface objects
    DWORD                       dwSCnt;     // number of surfaces in SList
    HRESULT                     ddRVal;     // return value
    LPDDHAL_CREATESURFACE       CreateSurface;  // PRIVATE: ptr to callback
} DDHAL_CREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CanCreateSurface fn
 */
typedef struct _DDHAL_CANCREATESURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;           // driver struct
    LPDDSURFACEDESC             lpDDSurfaceDesc;    // description of surface being created
    DWORD                       bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT                     ddRVal;         // return value
    LPDDHAL_CANCREATESURFACE    CanCreateSurface;   // PRIVATE: ptr to callback
} DDHAL_CANCREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CreatePalette fn
 */
typedef struct _DDHAL_CREATEPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWPALETTE_GBL   lpDDPalette;    // ddraw palette struct
    LPPALETTEENTRY              lpColorTable;   // colors to go in palette
    HRESULT                     ddRVal;     // return value
    LPDDHAL_CREATEPALETTE       CreatePalette;  // PRIVATE: ptr to callback
    BOOL                        is_excl;        // process has exclusive mode
} DDHAL_CREATEPALETTEDATA;

/*
 * Return if the vertical blank is in progress
 */
#define DDWAITVB_I_TESTVB           0x80000006l

/*
 * structure for passing information to DDHAL WaitForVerticalBlank fn
 */
typedef struct _DDHAL_WAITFORVERTICALBLANKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    DWORD                       dwFlags;    // flags
    DWORD                       bIsInVB;    // is in vertical blank
    ULONG_PTR                   hEvent;     // event
    HRESULT                     ddRVal;     // return value
    LPDDHAL_WAITFORVERTICALBLANK    WaitForVerticalBlank; // PRIVATE: ptr to callback
} DDHAL_WAITFORVERTICALBLANKDATA;

/*
 * structure for passing information to DDHAL DestroyDriver fn
 */
typedef struct _DDHAL_DESTROYDRIVERDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;   // driver struct
    HRESULT                     ddRVal; // return value
    LPDDHAL_DESTROYDRIVER       DestroyDriver;  // PRIVATE: ptr to callback
} DDHAL_DESTROYDRIVERDATA;

/*
 * structure for passing information to DDHAL SetMode fn
 */
typedef struct _DDHAL_SETMODEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    DWORD                       dwModeIndex;    // new mode
    HRESULT                     ddRVal;     // return value
    LPDDHAL_SETMODE             SetMode;    // PRIVATE: ptr to callback
    BOOL                        inexcl;         // in exclusive mode
    BOOL                        useRefreshRate; // use the refresh rate data in the mode info
} DDHAL_SETMODEDATA;

/*
 * structure for passing information to DDHAL driver SetColorKey fn
 */
typedef struct _DDHAL_DRVSETCOLORKEYDATA
{
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    DDCOLORKEY                  ckNew;      // new color key
    HRESULT                     ddRVal;     // return value
    LPDDHAL_SETCOLORKEY         SetColorKey;    // PRIVATE: ptr to callback
} DDHAL_DRVSETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetScanLine fn
 */
typedef struct _DDHAL_GETSCANLINEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    DWORD                       dwScanLine; // returned scan line
    HRESULT                     ddRVal;     // return value
    LPDDHAL_GETSCANLINE         GetScanLine;    // PRIVATE: ptr to callback
} DDHAL_GETSCANLINEDATA;

/*
 * structure for passing information to DDHAL SetExclusiveMode fn
 */
typedef struct _DDHAL_SETEXCLUSIVEMODEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;             // driver struct
    DWORD                       dwEnterExcl;      // TRUE if entering exclusive mode, FALSE is leaving
    DWORD                       dwReserved;       // reserved for future use
    HRESULT                     ddRVal;           // return value
    LPDDHAL_SETEXCLUSIVEMODE    SetExclusiveMode; // PRIVATE: ptr to callback
} DDHAL_SETEXCLUSIVEMODEDATA;

/*
 * structure for passing information to DDHAL FlipToGDISurface fn
 */
typedef struct _DDHAL_FLIPTOGDISURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;         // driver struct
    DWORD                       dwToGDI;          // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD                       dwReserved;       // reserved for future use
    HRESULT            ddRVal;       // return value
    LPDDHAL_FLIPTOGDISURFACE    FlipToGDISurface; // PRIVATE: ptr to callback
} DDHAL_FLIPTOGDISURFACEDATA;

/****************************************************************************
 *
 * DDHAL structures for VideoPort callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CanCreateVideoPort fn
 */
typedef struct _DDHAL_CANCREATEVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_CANCREATEVIDEOPORT CanCreateVideoPort; // PRIVATE: ptr to callback
} DDHAL_CANCREATEVPORTDATA;

/*
 * structure for passing information to DDHAL CreateVideoPort fn
 */
typedef struct _DDHAL_CREATEVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port created
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_CREATEVIDEOPORT CreateVideoPort; // PRIVATE: ptr to callback
} DDHAL_CREATEVPORTDATA;

/*
 * structure for passing information to DDHAL FlipVideoPort fn
 */
typedef struct _DDHAL_FLIPVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfCurr;     // current surface
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfTarg;     // target surface
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_FLIP         FlipVideoPort;  // PRIVATE: ptr to callback
} DDHAL_FLIPVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortBandwidth fn
 */
typedef struct _DDHAL_GETVPORTBANDWIDTHDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    LPDDPIXELFORMAT             lpddpfFormat;       // Format for bandwidth
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwFlags;        // Prescale factor for bandwidth
    LPDDVIDEOPORTBANDWIDTH      lpBandwidth;        // Returned bandwidth parameters
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_GETBANDWIDTH GetVideoPortBandwidth;  // PRIVATE: ptr to callback
} DDHAL_GETVPORTBANDWIDTHDATA;

/*
 * structure for passing information to DDHAL GetVideoPortInputFormats fn
 */
typedef struct _DDHAL_GETVPORTINPUTFORMATDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwFlags;        // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfFormat;       // Array of formats
    DWORD                       dwNumFormats;       // # of formats in array
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_GETINPUTFORMATS GetVideoPortInputFormats; // PRIVATE: ptr to callback
} DDHAL_GETVPORTINPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortOutputFormats fn
 */
typedef struct _DDHAL_GETVPORTOUTPUTFORMATDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwFlags;        // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfInputFormat;  // Input format
    LPDDPIXELFORMAT             lpddpfOutputFormats;    // Array of output formats
    DWORD                       dwNumFormats;       // # of formats in array
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_GETOUTPUTFORMATS GetVideoPortOutputFormats; // PRIVATE: ptr to callback
} DDHAL_GETVPORTOUTPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortField fn
 */
typedef struct _DDHAL_GETVPORTFIELDDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    BOOL                        bField;         // TRUE if even
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_GETFIELD     GetVideoPortField;  // PRIVATE: ptr to callback
} DDHAL_GETVPORTFIELDDATA;

/*
 * structure for passing information to DDHAL GetVideoPortLine fn
 */
typedef struct _DDHAL_GETVPORTLINEDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwLine;         // Current line counter
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_GETLINE      GetVideoPortLine;   // PRIVATE: ptr to callback
} DDHAL_GETVPORTLINEDATA;

/*
 * structure for passing information to DDHAL GetVideoPortConnectInfo fn
 */
typedef struct _DDHAL_GETVPORTCONNECTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    DWORD                       dwPortId;       // ID of desired video port
    LPDDVIDEOPORTCONNECT        lpConnect;      // Array of DDVIDEOPORTCONNECT structures
    DWORD                       dwNumEntries;       // # of structures in array
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_GETVPORTCONNECT GetVideoPortConnectInfo; // PRIVATE: ptr to callback
} DDHAL_GETVPORTCONNECTDATA;

/*
 * structure for passing information to DDHAL DestroyVideoPort fn
 */
typedef struct _DDHAL_DESTROYVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_DESTROYVPORT DestroyVideoPort;   // PRIVATE: ptr to callback
} DDHAL_DESTROYVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortFlipStatus fn
 */
typedef struct _DDHAL_GETVPORTFLIPSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    FLATPTR                     fpSurface;      // surface struct
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_GETFLIPSTATUS GetVideoPortFlipStatus; // PRIVATE: ptr to callback
} DDHAL_GETVPORTFLIPSTATUSDATA;

/*
 * structure for passing information to DDHAL UpdateVideoPort fn
 */
typedef struct _DDHAL_UPDATEVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    LPDDRAWI_DDRAWSURFACE_INT   *lplpDDSurface;     // surface struct
    LPDDRAWI_DDRAWSURFACE_INT   *lplpDDVBISurface;  // VBI surface structure
    LPDDVIDEOPORTINFO           lpVideoInfo;        // Video information
    DWORD                       dwFlags;        // DDRAWI_VPORTSTART, DDRAWI_VPORTSTOP, DDRAWI_VPORTUPDATE
    DWORD                       dwNumAutoflip;      // # of autoflip surfaces. If > 1, lpDDSurface and lpDDVBISurface are arrays.
    DWORD                       dwNumVBIAutoflip;   // # of autoflip surfaces. If > 1, lpDDSurface and lpDDVBISurface are arrays.
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_UPDATE       UpdateVideoPort;    // PRIVATE: ptr to callback
} DDHAL_UPDATEVPORTDATA;

#define DDRAWI_VPORTSTART   0x0001
#define DDRAWI_VPORTSTOP    0x0002
#define DDRAWI_VPORTUPDATE  0x0003

/*
 * structure for passing information to DDHAL WaitForVideoPortSync fn
 */
typedef struct _DDHAL_WAITFORVPORTSYNCDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwFlags;        // DDVPEVENT_XXXX
    DWORD                       dwLine;
    DWORD                       dwTimeOut;              // Max time to wait before returning
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_WAITFORSYNC  WaitForVideoPortSync;   // PRIVATE: ptr to callback
} DDHAL_WAITFORVPORTSYNCDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DDHAL_GETVPORTSIGNALDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwStatus;       // Video signal status
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_GETSIGNALSTATUS GetVideoSignalStatus;// PRIVATE: ptr to callback
} DDHAL_GETVPORTSIGNALDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DDHAL_VPORTCOLORDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwFlags;        // Video signal status
    LPDDCOLORCONTROL            lpColorData;
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_COLORCONTROL ColorControl;       // PRIVATE: ptr to callback
} DDHAL_VPORTCOLORDATA;

#define DDRAWI_VPORTGETCOLOR    0x0001
#define DDRAWI_VPORTSETCOLOR    0x0002

/****************************************************************************
 *
 * DDHAL structures for Color Control callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL ColorControl fn
 */
typedef struct _DDHAL_COLORCONTROLDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface
    LPDDCOLORCONTROL            lpColorData;    // color control information
    DWORD                       dwFlags;    // DDRAWI_GETCOLOR/DDRAWI_SETCOLOR
    HRESULT                     ddRVal;     // return value
    LPDDHALCOLORCB_COLORCONTROL ColorControl;   // PRIVATE: ptr to callback
} DDHAL_COLORCONTROLDATA;

#define DDRAWI_GETCOLOR     0x0001
#define DDRAWI_SETCOLOR     0x0002

/****************************************************************************
 *
 * DDHAL structure for GetDriverData callback
 *
 ***************************************************************************/

typedef struct _DDHAL_GETDRIVERINFODATA {

    // Input fields filled in by DirectDraw
    DWORD       dwSize;         // Size of this structure
    DWORD       dwFlags;        // Flags
    GUID        guidInfo;       // GUID that DirectX is querying for
    DWORD       dwExpectedSize; // Size of callbacks structure expected by DirectDraw.
    LPVOID      lpvData;        // Buffer that will receive the requested data

    // Output fields filled in by driver
    DWORD       dwActualSize;   // Size of callbacks structure expected by driver
    HRESULT     ddRVal;         // Return value from driver

    // Input field: Context information for driver
    // On Win95, this is the dwReserved3 field of the DIRECTDRAW_GBL
    // On NT, this is the hDD field of DIRECTDRAW_GBL
    ULONG_PTR   dwContext;  // Context Information

} DDHAL_GETDRIVERINFODATA;

/****************************************************************************
 *
 * DDHAL structure for misc. driver callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetAvailDriverMemory fn
 */
typedef struct _DDHAL_GETAVAILDRIVERMEMORYDATA
{
    LPDDRAWI_DIRECTDRAW_GBL lpDD;        // driver struct
    DDSCAPS                 DDSCaps;     // caps for type of surface memory
    DWORD                   dwTotal;     // total memory for this kind of surface
    DWORD                   dwFree;      // free memory for this kind of surface
    HRESULT                 ddRVal;      // return value
    LPDDHAL_GETAVAILDRIVERMEMORY   GetAvailDriverMemory; // PRIVATE: ptr to callback
    DDSCAPSEX               ddsCapsEx;       // Added in V6. Driver should check DDVERSION info
                                                 // to see if this field is present.
} DDHAL_GETAVAILDRIVERMEMORYDATA;

/*
 * structure for passing information to DDHEL UpdateNonLocalHeap
 */
typedef struct _DDHAL_UPDATENONLOCALHEAPDATA
{
    LPDDRAWI_DIRECTDRAW_GBL    lpDD;               // driver struct
    DWORD                      dwHeap;             // heap index
    FLATPTR                    fpGARTLin;          // linear GART address of start of heap
    FLATPTR                    fpGARTDev;          // high physical GART address of start of heap
    ULONG_PTR                  ulPolicyMaxBytes;   // maximum amount of AGP memory to use
    HRESULT                    ddRVal;             // return value
    LPDDHAL_UPDATENONLOCALHEAP UpdateNonLocalHeap; // PRIVATE: ptr to callback
} DDHAL_UPDATENONLOCALHEAPDATA;

/*
 * Heap Alignment Data Structures
 */
typedef struct _DDHAL_GETHEAPALIGNMENTDATA
{
    ULONG_PTR                  dwInstance;         // driver context as returned from 32-bit driver init routine
    DWORD                      dwHeap;             // heap index passed by DirectDraw
    HRESULT                    ddRVal;             // return value
    LPDDHAL_GETHEAPALIGNMENT   GetHeapAlignment;   // PRIVATE: ptr to callback.
    HEAPALIGNMENT              Alignment;          // Filled in by driver. Defined in dmemmgr.h
} DDHAL_GETHEAPALIGNMENTDATA;

/*
 * These are the only caps you can set in DDHAL_GETHEAPALIGNMENTDATA.Alignment.ddsCaps.
 * Any other caps will be rejected by DirectDraw.
 */

#define DDHAL_ALIGNVALIDCAPS   (DDSCAPS_OFFSCREENPLAIN | \
                                DDSCAPS_EXECUTEBUFFER | \
                                DDSCAPS_OVERLAY | \
                                DDSCAPS_TEXTURE | \
                                DDSCAPS_ZBUFFER | \
                                DDSCAPS_ALPHA | \
                                DDSCAPS_FLIP )

/*
 * Note that GetSysmemBltStatus uses the same parameter block as GetBltStatus,
 * namely DDHAL_GETBLTSTATUSDATA
 */


typedef struct _DDHAL_CREATESURFACEEXDATA {
    DWORD                       dwFlags;    // Currently always 0 and not used
    LPDDRAWI_DIRECTDRAW_LCL     lpDDLcl;    // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSLcl;   // list of created surface objects
    HRESULT                     ddRVal;     // return value
} DDHAL_CREATESURFACEEXDATA;

typedef struct _DDHAL_GETDRIVERSTATEDATA {
    DWORD                       dwFlags;        // Flags to indicate the data
                                                // required
    union
    {
        // LPDDRAWI_DIRECTDRAW_GBL     lpDD;           // driver struct
        ULONG_PTR               dwhContext;     // d3d context
    };
    LPDWORD                     lpdwStates;     // ptr to the state data
                                                // to be filled in by the
                                                // driver
    DWORD                       dwLength;
    HRESULT                     ddRVal;         // return value
} DDHAL_GETDRIVERSTATEDATA;

typedef struct _DDHAL_DESTROYDDLOCALDATA
{
    DWORD dwFlags;
    LPDDRAWI_DIRECTDRAW_LCL pDDLcl;
    HRESULT  ddRVal;
} DDHAL_DESTROYDDLOCALDATA;

/****************************************************************************
 *
 * DDHAL structure for kernel callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL SyncSurfaceData fn
 */
typedef struct _DDHAL_SYNCSURFACEDATA
{
    DWORD                       dwSize;         // Size of this structure
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;   // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // Surface to sync with
    DWORD                       dwSurfaceOffset;    // Offset in frame buffer of surface
    ULONG_PTR                   fpLockPtr;      // Surface lock ptr
    LONG                        lPitch;         // Surface pitch
    DWORD                       dwOverlayOffset;    // Added to dwSurfaceOffset for origin, clipping, etc.
    DWORD                       dwOverlaySrcWidth;  // Src width of overlay
    DWORD                       dwOverlaySrcHeight; // Src height of overlay
    DWORD                       dwOverlayDestWidth; // Dest width of overlay
    DWORD                       dwOverlayDestHeight;    // Dest height of overlay
    ULONG_PTR                           dwDriverReserved1;  // Reserved for the HAL
    ULONG_PTR                           dwDriverReserved2;  // Reserved for the HAL
    ULONG_PTR                           dwDriverReserved3;  // Reserved for the HAL
    HRESULT                     ddRVal;
} DDHAL_SYNCSURFACEDATA;

/*
 * structure for passing information to DDHAL SyncVideoPortData fn
 */
typedef struct _DDHAL_SYNCVIDEOPORTDATA
{
    DWORD                       dwSize;         // Size of this structure
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;       // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;    // Video port object
    DWORD                       dwOriginOffset;     // Start address relative to surface
    DWORD                       dwHeight;       // Height of total video region (per field)
    DWORD                       dwVBIHeight;        // Height of VBI region (per field)
    ULONG_PTR                   dwDriverReserved1;  // Reserved for the HAL
    ULONG_PTR                   dwDriverReserved2;  // Reserved for the HAL
    ULONG_PTR                   dwDriverReserved3;  // Reserved for the HAL
    HRESULT                     ddRVal;
} DDHAL_SYNCVIDEOPORTDATA;


/****************************************************************************
 *
 * DDHAL structure for motion comp callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetMoCompGuids
 */
typedef struct _DDHAL_GETMOCOMPGUIDSDATA
{
    LPDDRAWI_DIRECTDRAW_LCL lpDD;
    DWORD               dwNumGuids;
    LPGUID              lpGuids;
    HRESULT             ddRVal;
    LPDDHALMOCOMPCB_GETGUIDS GetMoCompGuids;
} DDHAL_GETMOCOMPGUIDSDATA;

/*
 * structure for passing information to DDHAL GetMoCompFormats
 */
typedef struct _DDHAL_GETMOCOMPFORMATSDATA
{
    LPDDRAWI_DIRECTDRAW_LCL lpDD;
    LPGUID              lpGuid;
    DWORD               dwNumFormats;
    LPDDPIXELFORMAT     lpFormats;
    HRESULT             ddRVal;
    LPDDHALMOCOMPCB_GETFORMATS   GetMoCompFormats;
} DDHAL_GETMOCOMPFORMATSDATA;

/*
 * structure for passing information to DDHAL CreateMoComp
 */
typedef struct _DDHAL_CREATEMOCOMPDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    LPGUID                      lpGuid;
    DWORD                       dwUncompWidth;
    DWORD                       dwUncompHeight;
    DDPIXELFORMAT               ddUncompPixelFormat;
    LPVOID                      lpData;
    DWORD                       dwDataSize;
    HRESULT                     ddRVal;
    LPDDHALMOCOMPCB_CREATE      CreateMoComp;
} DDHAL_CREATEMOCOMPDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DDMCCOMPBUFFERINFO
{
    DWORD                       dwSize;             // [in]   size of the struct
    DWORD                       dwNumCompBuffers;   // [out]  number of buffers required for compressed data
    DWORD                       dwWidthToCreate;    // [out]    Width of surface to create
    DWORD                       dwHeightToCreate;   // [out]    Height of surface to create
    DWORD                       dwBytesToAllocate;  // [out]    Total number of bytes used by each surface
    DDSCAPS2                    ddCompCaps;         // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT               ddPixelFormat;      // [out]  format to create surfaces to store compressed data
} DDMCCOMPBUFFERINFO, *LPDDMCCOMPBUFFERINFO;

typedef struct _DDHAL_GETMOCOMPCOMPBUFFDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPGUID                      lpGuid;
    DWORD                       dwWidth;            // [in]   width of uncompressed data
    DWORD                       dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT               ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                       dwNumTypesCompBuffs;// [in/out] number of memory types required for comp buffers
    LPDDMCCOMPBUFFERINFO        lpCompBuffInfo;     // [in]   driver supplied info regarding comp buffers (allocated by client)
    HRESULT                     ddRVal;             // [out]
    LPDDHALMOCOMPCB_GETCOMPBUFFINFO  GetMoCompBuffInfo;
} DDHAL_GETMOCOMPCOMPBUFFDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DDHAL_GETINTERNALMOCOMPDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPGUID                      lpGuid;
    DWORD                       dwWidth;            // [in]   width of uncompressed data
    DWORD                       dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT               ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                       dwScratchMemAlloc;  // [out]  amount of scratch memory will the hal allocate for its private use
    HRESULT                     ddRVal;             // [out]
    LPDDHALMOCOMPCB_GETINTERNALINFO  GetInternalMoCompInfo;
} DDHAL_GETINTERNALMOCOMPDATA;

/*
 * structure for passing information to DDHAL BeginMoCompFrame
 */
typedef struct _DDHAL_BEGINMOCOMPFRAMEDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    LPDDRAWI_DDRAWSURFACE_LCL   lpDestSurface;        // [in]  destination buffer in which to decoding this frame
    DWORD                       dwInputDataSize;      // [in]  size of other misc input data to begin frame
    LPVOID                      lpInputData;          // [in]  pointer to misc input data
    DWORD                       dwOutputDataSize;     // [in]  size of other misc output data to begin frame
    LPVOID                      lpOutputData;         // [in]  pointer to output misc data (allocated by client)
    HRESULT                     ddRVal;               // [out]
    LPDDHALMOCOMPCB_BEGINFRAME  BeginMoCompFrame;
} DDHAL_BEGINMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL EndMoCompFrame
 */
typedef struct _DDHAL_ENDMOCOMPFRAMEDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    LPVOID                      lpInputData;
    DWORD                       dwInputDataSize;
    HRESULT                     ddRVal;
    LPDDHALMOCOMPCB_ENDFRAME    EndMoCompFrame;
} DDHAL_ENDMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL RenderMoComp
 */
typedef struct _DDMCBUFFERINFO
{
    DWORD                       dwSize;         // [in]    size of the struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpCompSurface;  // [in]    pointer to buffer containing compressed data
    DWORD                       dwDataOffset;   // [in]    offset of relevant data from the beginning of buffer
    DWORD                       dwDataSize;     // [in]    size of relevant data
    LPVOID                      lpPrivate;      // Reserved for DirectDraw;
} DDMCBUFFERINFO, *LPDDMCBUFFERINFO;


typedef struct _DDHAL_RENDERMOCOMPDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    DWORD                       dwNumBuffers;   // [in]  Number of entries in the lpMacroBlockInfo array
    LPDDMCBUFFERINFO            lpBufferInfo;   // [in]  Surfaces containing macro block info
    DWORD                       dwFunction;     // [in]  Function
    LPVOID                      lpInputData;
    DWORD                       dwInputDataSize;
    LPVOID                      lpOutputData;
    DWORD                       dwOutputDataSize;
    HRESULT                     ddRVal;         // [out]
    LPDDHALMOCOMPCB_RENDER      RenderMoComp;
} DDHAL_RENDERMOCOMPDATA;

/*
 * structure for passing information to DDHAL QueryMoCompStatus
 */
typedef struct _DDHAL_QUERYMOCOMPSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurface;      // [in]  Surface being queried
    DWORD                       dwFlags;        // [in]  DDMCQUERY_XXX falgs
    HRESULT                     ddRVal;         // [out]
    LPDDHALMOCOMPCB_QUERYSTATUS QueryMoCompStatus;
} DDHAL_QUERYMOCOMPSTATUSDATA;

#define DDMCQUERY_READ          0x00000001

/*
 * structure for passing information to DDHAL DestroyVideo
 */
typedef struct _DDHAL_DESTROYMOCOMPDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    HRESULT                     ddRVal;
    LPDDHALMOCOMPCB_DESTROY     DestroyMoComp;
} DDHAL_DESTROYMOCOMPDATA;


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dhcpv6csdk.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dhcpv6csdk.h

Abstract:

    These are the exported dhcpv6 client api function definitions

Author:

    Achint Setia (asetia)  July-1-2005

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _DHCPV6CSDK_
#define _DHCPV6CSDK_
#ifdef __cplusplus
extern "C" {
#endif


#ifndef DHCPV6_OPTIONS_DEFINED
#define DHCPV6_OPTIONS_DEFINED

#if _MSC_VER > 1000
#pragma once
#endif

//
// DHCPv6 Standard Options(non-encapsulated).
//



#define    DHCPV6_OPTION_CLIENTID        1
#define    DHCPV6_OPTION_SERVERID       2
#define    DHCPV6_OPTION_IA_NA             3
#define    DHCPV6_OPTION_IA_TA             4
#define    DHCPV6_OPTION_ORO                6
#define    DHCPV6_OPTION_PREFERENCE  7
#define    DHCPV6_OPTION_UNICAST        12
#define    DHCPV6_OPTION_RAPID_COMMIT  14
#define    DHCPV6_OPTION_USER_CLASS  15
#define    DHCPV6_OPTION_VENDOR_CLASS  16
#define    DHCPV6_OPTION_VENDOR_OPTS  17
#define    DHCPV6_OPTION_RECONF_MSG  19

#define    DHCPV6_OPTION_SIP_SERVERS_NAMES 21
#define    DHCPV6_OPTION_SIP_SERVERS_ADDRS 22
#define    DHCPV6_OPTION_DNS_SERVERS 23
#define    DHCPV6_OPTION_DOMAIN_LIST 24
#define    DHCPV6_OPTION_IA_PD             25
#define    DHCPV6_OPTION_NIS_SERVERS 27
#define    DHCPV6_OPTION_NISP_SERVERS 28
#define    DHCPV6_OPTION_NIS_DOMAIN_NAME  29
#define    DHCPV6_OPTION_NISP_DOMAIN_NAME  30


#endif  DHCPV6_OPTIONS_DEFINED

#ifndef DHCPV6API_PARAMS_DEFINED
#define DHCPV6API_PARAMS_DEFINED

typedef struct _DHCPV6CAPI_PARAMS {                  // use this structure to request params
    ULONG                        Flags;         // for future use
    ULONG                        OptionId;      // what option is this?
    BOOL                         IsVendor;      // is this vendor specific?
    LPBYTE                       Data;          // the actual data
    DWORD                        nBytesData;    // how many bytes of data are there in Data?
} DHCPV6CAPI_PARAMS, *PDHCPV6CAPI_PARAMS, *LPDHCPV6CAPI_PARAMS;

#endif DHCPV6API_PARAMS_DEFINED

typedef struct _DHCPV6CAPI_PARAMS_ARRAY {          // array of params..
    ULONG                            nParams;       // size of array
    LPDHCPV6CAPI_PARAMS              Params;        // actual array
} DHCPV6CAPI_PARAMS_ARRAY, *PDHCPV6CAPI_PARAMS_ARRAY, *LPDHCPV6CAPI_PARAMS_ARRAY;

typedef struct _DHCPV6CAPI_CLASSID {                // defines a client class id.
    ULONG                          Flags;         // must be zero currently.
    __field_bcount(nBytesData) LPBYTE                         Data;          // classid binary data.
    ULONG                          nBytesData;    // how many bytes of data are there?
} DHCPV6CAPI_CLASSID, *PDHCPV6CAPI_CLASSID, *LPDHCPV6CAPI_CLASSID;

typedef
enum 
{
    STATUS_NO_ERROR,                         //Prefix successfully leased, renewed.
    STATUS_UNSPECIFIED_FAILURE,  //Some unspecified failure occurred  while trying to process the prefix.
    STATUS_NO_BINDING = 3,          //The server doesn't have binding for the prefix.
    STATUS_NOPREFIX_AVAIL = 6   //The server doesn't have prefix to offer to the requesting client.
}StatusCode;
    
typedef struct _DHCPV6Prefix{
    UCHAR  prefix[16];               //128 bit prefix
    DWORD prefixLength;		//(48-64 bits)
    DWORD preferredLifeTime; 	//The Preferred Lifetime of the Prefix returned or requested in seconds
    DWORD validLifeTime; 	//The Valid Lifetime of the Prefix returned or requested in seconds
    StatusCode status;              //The status code returned by the server for the prefix
}DHCPV6Prefix, *PDHCPV6Prefix, *LPDHCPV6Prefix;

typedef struct _DHCPV6PrefixLeaseInformation {
        DWORD nPrefixes;		// number of prefixes.
        __field_ecount(nPrefixes) LPDHCPV6Prefix prefixArray;  // Array of prefixes
	DWORD iaid;                     //The 32 bit Identity Association identifier for the prefix option.
	time_t T1;			//The absolute renewal time for the prefixes in seconds
	time_t T2; 			//The absolute rebind time for the prefixes in seconds
	time_t MaxLeaseExpirationTime; //The absolute maximum lease expiration time of all the prefix leases in this structure.
	time_t LastRenewalTime;        // The absolute time at which the last renewal for the prefixes happened.
	StatusCode status;              //The status code returned by the server for the IAPD
        __field_bcount(ServerIdLen) LPBYTE ServerId;		// The server DUID from which the prefix is received. This is used in subsequent Renews.	
	DWORD  ServerIdLen;		// The length of the above DUID data.
} DHCPV6PrefixLeaseInformation, *PDHCPV6PrefixLeaseInformation, *LPDHCPV6PrefixLeaseInformation;

VOID
APIENTRY
Dhcpv6CApiInitialize(
    OUT     LPDWORD                Version
);

VOID
APIENTRY
Dhcpv6CApiCleanup(
    VOID
);

DWORD                                             // win32 status
APIENTRY
Dhcpv6RequestParams(                                // request parameters of client
IN      BOOL		     		              forceNewInform,
IN      LPVOID                 		reserved,
__nullterminated IN      LPWSTR                 		adapterName,
IN      LPDHCPV6CAPI_CLASSID     	classId,
IN OUT  DHCPV6CAPI_PARAMS_ARRAY 	recdParams,
IN      LPBYTE                 		buffer,
IN OUT  LPDWORD                		pSize
);

DWORD
APIENTRY
DHCPv6RegisterPersistentRequestParams (
IN LPWSTR 					adapterName, 
IN LPDHCPV6CAPI_CLASSID       classId,
IN DHCPV6CAPI_PARAMS_ARRAY    requestedParams,
IN LPWSTR 		      registryNameString
);

DWORD
APIENTRY
DHCPv6DeRegisterPersistentRequestParams (
IN      LPWSTR    adapterName,   
IN      LPWSTR    registryNameString  
);

DWORD
APIENTRY
Dhcpv6RequestPrefix(
IN __nullterminated LPWSTR		adapterName, 
IN LPDHCPV6CAPI_CLASSID 		pclassId,
IN OUT LPDHCPV6PrefixLeaseInformation	prefixleaseInfo,
__deref_out OUT DWORD* 			pdwTimeToWait
);

DWORD
APIENTRY
Dhcpv6RenewPrefix(
IN __nullterminated LPWSTR		adapterName, 
IN LPDHCPV6CAPI_CLASSID 		pclassId,
IN OUT LPDHCPV6PrefixLeaseInformation	prefixleaseInfo,
__deref_out OUT DWORD* 			pdwTimeToWait,
IN DWORD 				bValidatePrefix
);

DWORD
APIENTRY
Dhcpv6ReleasePrefix(
__nullterminated IN LPWSTR				adapterName, 
IN LPDHCPV6CAPI_CLASSID     		classId,
IN LPDHCPV6PrefixLeaseInformation	leaseInfo
);


#define     DHCPV6CAPI_REGISTER_HANDLE_EVENT        0x01 // handle returned is to an event
DWORD                                             // win32 status
APIENTRY
Dhcpv6RegisterParamChange(                          
IN      DWORD                  			flags,         
IN      LPVOID                 			reserved,     
IN      LPWSTR                 			adapterName,  
IN      LPDHCPV6CAPI_CLASSID     	classId,       
IN      DHCPV6CAPI_PARAMS_ARRAY  params,        
IN      OUT  LPVOID                 		handle,
OUT   LPWSTR         			       eventName
);

#define     DHCPV6CAPI_DEREGISTER_HANDLE_EVENT      0x01 // de-register handle that is an event
DWORD
APIENTRY
Dhcpv6DeRegisterParamChange(                       
    IN      DWORD                  flags,         
    IN      LPVOID                 reserved,    
    IN      LPWSTR                eventName          
);

#ifdef __cplusplus
}
#endif

//================================================================================
// end of file
//================================================================================
#endif _DHCPV6CSDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DHtmldid.h ===
// DISPIDs for DHTMLEd.OCX
// Copyright 1998-1999 Microsoft Corporation.  All rights reserved.

#ifndef __DHTMLDID_H_
#define __DHTMLDID_H_


// methods and properties
#define DISPID_LOADDOCUMENT             1
#define DISPID_EXECCOMMAND              2
#define DISPID_QUERYSTATUS              3
#define DISPID_SAVEDOCUMENT             4
#define DISPID_SETCONTEXTMENU           5
#define DISPID_DOCUMENT                 6
#define DISPID_ACTIVATEAPPLETS          7
#define DISPID_ACTIVATEACTIVEXCONTROLS  8
#define DISPID_ACTIVATEDTCS             9	
#define DISPID_SHOWDETAILS              11
#define DISPID_SHOWBORDERS              12
#define DISPID_DHTMLEDITAPPEARANCE      13
#define DISPID_DHTMLEDITSCROLLBARS      14
#define DISPID_SCROLLBARAPPEARANCE      15
#define DISPID_SOURCECODEPRESERVATION   16
#define DISPID_DOCUMENTHTML             17
#define DISPID_ABSOLUTEDROPMODE         18
#define DISPID_SNAPTOGRIDX              19
#define DISPID_SNAPTOGRIDY              20
#define DISPID_SNAPTOGRID               21
#define DISPID_ISDIRTY                  22
#define DISPID_CURRENTDOCUMENTPATH      23
#define DISPID_BASEURL                  24
#define DISPID_DOCUMENTTITLE            25
#define DISPID_BROWSEMODE               26
#define DISPID_NEWDOCUMENT              27
#define DISPID_PRINT                    28
#define DISPID_LOADURL                  29
#define DISPID_USEDIVONCR               30
#define DISPID_FILTERSRCCODE            31
#define DISPID_REFRESHDOC               32
#define DISPID_BUSY                     33

// events
#define	DISPID_DOCUMENTCOMPLETE	        1
#define	DISPID_DISPLAYCHANGED           2
#define	DISPID_SHOWCONTEXTMENU          3
#define	DISPID_CONTEXTMENUACTION        4
#define DISPID_ONMOUSEDOWN              5
#define DISPID_ONMOUSEMOVE              6
#define DISPID_ONMOUSEUP                7
#define DISPID_ONMOUSEOUT               8
#define DISPID_ONMOUSEOVER              9
#define DISPID_ONCLICK                  10
#define DISPID_ONDBLCLICK               11
#define DISPID_ONKEYDOWN                12
#define DISPID_ONKEYPRESS               13
#define DISPID_ONKEYUP                  14
#define DISPID_ONBLUR                   15
#define DISPID_ONREADYSTATECHANGE       16


#define DISPID_TABLEPARAMS_NUMROWS      1
#define DISPID_TABLEPARAMS_NUMCOLS      2
#define DISPID_TABLEPARAMS_TABLEATTRS   3
#define DISPID_TABLEPARAMS_CELLATTRS    4
#define DISPID_TABLEPARAMS_CAPTION      5

#define DISPID_NAMESPARAM_NAMES         1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DHtmliid.h ===
// GUIDs for DHTMLEd.OCX
// Copyright 1998-1999 Microsoft Corporation.  All rights reserved.

#ifndef _dhtmliid_h_
#define _dhtmliid_h_

#ifdef __cplusplus
extern "C"{
#endif 

EXTERN_C const IID   LIBID_DHTMLEDLib;

EXTERN_C const CLSID CLSID_DHTMLEdit;
EXTERN_C const CLSID CLSID_DHTMLSafe;
EXTERN_C const CLSID CLSID_DEInsertTableParam;
EXTERN_C const CLSID CLSID_DEGetBlockFmtNamesParam;

EXTERN_C const IID   DIID__DHTMLSafeEvents;
EXTERN_C const IID   DIID__DHTMLEditEvents;

EXTERN_C const IID   IID_IDHTMLEdit;
EXTERN_C const IID   IID_IDHTMLSafe;
EXTERN_C const IID   IID_IDEInsertTableParam;
EXTERN_C const IID   IID_IDEGetBlockFmtNamesParam;


DEFINE_GUID(LIBID_DHTMLEDLib,              0x683364A1, 0xB37D, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);

DEFINE_GUID(CLSID_DHTMLEdit,               0x2D360200, 0xFFF5, 0x11d1, 0x8D, 0x03, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A);
DEFINE_GUID(CLSID_DHTMLSafe,               0x2D360201, 0xFFF5, 0x11d1, 0x8D, 0x03, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A);
DEFINE_GUID(CLSID_DEInsertTableParam,      0x47B0DFC7, 0xB7A3, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);
DEFINE_GUID(CLSID_DEGetBlockFmtNamesParam, 0x8D91090E, 0xB955, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);

DEFINE_GUID(DIID__DHTMLSafeEvents,         0xD1FC78E8, 0xB380, 0x11d1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);
DEFINE_GUID(DIID__DHTMLEditEvents,         0x588D5040, 0xCF28, 0x11d1, 0x8C, 0xD3, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A);

DEFINE_GUID(IID_IDHTMLEdit,                0xCE04B591, 0x2B1F, 0x11d2, 0x8D, 0x1E, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A);
DEFINE_GUID(IID_IDHTMLSafe,                0xCE04B590, 0x2B1F, 0x11d2, 0x8D, 0x1E, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A0);
DEFINE_GUID(IID_IDEInsertTableParam,       0x47B0DFC6, 0xB7A3, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);
DEFINE_GUID(IID_IDEGetBlockFmtNamesParam,  0x8D91090D, 0xB955, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);

#ifdef __cplusplus
}
#endif

#endif	// _dhtmliid_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DhcpCSdk.h ===
//================================================================================
//  Copyright (C) 1997-1999 Microsoft Corporation
//  Description: these are the exported dhcp client api function definitions
//================================================================================
#ifndef _DHCPCSDK_
#define _DHCPCSDK_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DHCP_OPTIONS_DEFINED
#define DHCP_OPTIONS_DEFINED

#if _MSC_VER > 1000
#pragma once
#endif

//
// DHCP Standard Options.
//

#define OPTION_PAD                      0
#define OPTION_SUBNET_MASK              1
#define OPTION_TIME_OFFSET              2
#define OPTION_ROUTER_ADDRESS           3
#define OPTION_TIME_SERVERS             4
#define OPTION_IEN116_NAME_SERVERS      5
#define OPTION_DOMAIN_NAME_SERVERS      6
#define OPTION_LOG_SERVERS              7
#define OPTION_COOKIE_SERVERS           8
#define OPTION_LPR_SERVERS              9
#define OPTION_IMPRESS_SERVERS          10
#define OPTION_RLP_SERVERS              11
#define OPTION_HOST_NAME                12
#define OPTION_BOOT_FILE_SIZE           13
#define OPTION_MERIT_DUMP_FILE          14
#define OPTION_DOMAIN_NAME              15
#define OPTION_SWAP_SERVER              16
#define OPTION_ROOT_DISK                17
#define OPTION_EXTENSIONS_PATH          18

//
// IP layer parameters - per host
//

#define OPTION_BE_A_ROUTER              19
#define OPTION_NON_LOCAL_SOURCE_ROUTING 20
#define OPTION_POLICY_FILTER_FOR_NLSR   21
#define OPTION_MAX_REASSEMBLY_SIZE      22
#define OPTION_DEFAULT_TTL              23
#define OPTION_PMTU_AGING_TIMEOUT       24
#define OPTION_PMTU_PLATEAU_TABLE       25

//
// Link layer parameters - per interface.
//

#define OPTION_MTU                      26
#define OPTION_ALL_SUBNETS_MTU          27
#define OPTION_BROADCAST_ADDRESS        28
#define OPTION_PERFORM_MASK_DISCOVERY   29
#define OPTION_BE_A_MASK_SUPPLIER       30
#define OPTION_PERFORM_ROUTER_DISCOVERY 31
#define OPTION_ROUTER_SOLICITATION_ADDR 32
#define OPTION_STATIC_ROUTES            33
#define OPTION_TRAILERS                 34
#define OPTION_ARP_CACHE_TIMEOUT        35
#define OPTION_ETHERNET_ENCAPSULATION   36

//
// TCP Paramters - per host
//

#define OPTION_TTL                      37
#define OPTION_KEEP_ALIVE_INTERVAL      38
#define OPTION_KEEP_ALIVE_DATA_SIZE     39

//
// Application Layer Parameters
//

#define OPTION_NETWORK_INFO_SERVICE_DOM 40
#define OPTION_NETWORK_INFO_SERVERS     41
#define OPTION_NETWORK_TIME_SERVERS     42

//
// Vender specific information option
//

#define OPTION_VENDOR_SPEC_INFO         43

//
// NetBIOS over TCP/IP Name server option
//

#define OPTION_NETBIOS_NAME_SERVER      44
#define OPTION_NETBIOS_DATAGRAM_SERVER  45
#define OPTION_NETBIOS_NODE_TYPE        46
#define OPTION_NETBIOS_SCOPE_OPTION     47

//
// X Window System Options.
//

#define OPTION_XWINDOW_FONT_SERVER      48
#define OPTION_XWINDOW_DISPLAY_MANAGER  49

//
// Other extensions
//

#define OPTION_REQUESTED_ADDRESS        50
#define OPTION_LEASE_TIME               51
#define OPTION_OK_TO_OVERLAY            52
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_MESSAGE                  56
#define OPTION_MESSAGE_LENGTH           57
#define OPTION_RENEWAL_TIME             58      // T1
#define OPTION_REBIND_TIME              59      // T2
#define OPTION_CLIENT_CLASS_INFO        60
#define OPTION_CLIENT_ID                61

#define OPTION_TFTP_SERVER_NAME         66
#define OPTION_BOOTFILE_NAME            67


#define OPTION_END                      255

#endif  DHCP_OPTIONS_DEFINED

#ifndef DHCPAPI_PARAMS_DEFINED
#define DHCPAPI_PARAMS_DEFINED
typedef struct _DHCPAPI_PARAMS {                  // use this structure to request params
    ULONG                          Flags;         // for future use
    ULONG                          OptionId;      // what option is this?
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         Data;          // the actual data
    DWORD                          nBytesData;    // how many bytes of data are there in Data?
} DHCPAPI_PARAMS, *PDHCPAPI_PARAMS, *LPDHCPAPI_PARAMS;
#endif DHCPAPI_PARAMS_DEFINED

typedef struct _DHCPAPI_PARAMS
DHCPCAPI_PARAMS, *PDHCPCAPI_PARAMS, *LPDHCPCAPI_PARAMS;

typedef struct _DHCPCAPI_PARAMS_ARARAY {          // array of params..
    ULONG                          nParams;       // size of array
    LPDHCPCAPI_PARAMS              Params;        // actual array
} DHCPCAPI_PARAMS_ARRAY, *PDHCPCAPI_PARAMS_ARRAY, *LPDHCPCAPI_PARAMS_ARRAY;

typedef struct _DHCPCAPI_CLASSID {                // defines a client class id.
    ULONG                          Flags;         // must be zero currently.
    LPBYTE                         Data;          // classid binary data.
    ULONG                          nBytesData;    // how many bytes of data are there?
} DHCPCAPI_CLASSID, *PDHCPCAPI_CLASSID, *LPDHCPCAPI_CLASSID;


#define     DHCPCAPI_REQUEST_PERSISTENT           0x01 // request this options "permanently"
#define     DHCPCAPI_REQUEST_SYNCHRONOUS          0x02 // request and block on it
#define     DHCPCAPI_REQUEST_ASYNCHRONOUS         0x04 // request and return, set event on completion
#define     DHCPCAPI_REQUEST_CANCEL               0x08 // cancel request
#define     DHCPCAPI_REQUEST_MASK                 0x0F // allowed flags..

DWORD
APIENTRY
DhcpCApiInitialize(
    OUT     LPDWORD                Version
);

VOID
APIENTRY
DhcpCApiCleanup(
    VOID
);

DWORD                                             // win32 status
APIENTRY
DhcpRequestParams(                                // request parameters of client
    IN      DWORD                  Flags,         // must be DHCPCAPI_REQUEST_SYNCHRONOUS
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPDHCPCAPI_CLASSID     ClassId,       // reserved must be NULL
    IN      DHCPCAPI_PARAMS_ARRAY  SendParams,    // parameters to send.
    IN OUT  DHCPCAPI_PARAMS_ARRAY  RecdParams,    // parameters that are to be requested..
    IN      LPBYTE                 Buffer,        // a buffer to hold data for RecdParams
    IN OUT  LPDWORD                pSize,         // i/p: size of above in BYTES, o/p required bytes..
    IN      LPWSTR                 RequestIdStr   // needed for persistent requests
);  // returns ERROR_MORE_DATA if o/p buffer is of insufficient size, and fills in reqd size in # of bytes

DWORD                                             // win32 status
APIENTRY
DhcpUndoRequestParams(                            // undo the effect of a persistent request -- currently undo from registry
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // the name of the adpater to delete for
    IN      LPWSTR                 RequestIdStr   // needed for persistent requests..
);

#define     DHCPCAPI_REGISTER_HANDLE_EVENT        0x01 // handle returned is to an event
DWORD                                             // win32 status
APIENTRY
DhcpRegisterParamChange(                          // notify if a parameter has changed
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPDHCPCAPI_CLASSID     ClassId,       // reserved must be NULL
    IN      DHCPCAPI_PARAMS_ARRAY  Params,        // parameters of interest
    IN OUT  LPVOID                 Handle         // handle to event that will be SetEvent'ed in case of param change
);

#define     DHCPCAPI_DEREGISTER_HANDLE_EVENT      0x01 // de-register handle that is an event
DWORD
APIENTRY
DhcpDeRegisterParamChange(                        // undo the registration
    IN      DWORD                  Flags,         // MUST BE ZERO --> No flags yet.
    IN      LPVOID                 Reserved,      // MUST BE NULL --> Reserved
    IN      LPVOID                 Event          // handle to event returned by DhcpRegisterParamChange.
);

DWORD
APIENTRY
DhcpRemoveDNSRegistrations(
    VOID
    );

DWORD
APIENTRY
DhcpGetOriginalSubnetMask(
    IN LPCWSTR AdapterName,
    OUT DWORD* pSubnetMask );

#ifdef __cplusplus
}
#endif

//================================================================================
// end of file
//================================================================================
#endif _DHCPCSDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DhcpSSdk.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    dhcpssdk.h

Abstract:

    Header for writing a DHCP Callout DLL.

--*/

#ifndef   _CALLOUT_H_
#define   _CALLOUT_H_

#ifdef __cplusplus
extern "C" {
#endif

#if _MSC_VER > 1000
#pragma once
#endif

//  This structure could change any day.  This will be accurate only for version 0 -- which
//  has to be checked for by any CalloutDLL that is hooking onto the DhcpHandleOptionsHook.


typedef DWORD  DHCP_IP_ADDRESS;
typedef struct _DHCP_SERVER_OPTIONS {
    BYTE                       *MessageType;
    DHCP_IP_ADDRESS UNALIGNED  *SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED  *RequestedAddress;
    DWORD UNALIGNED            *RequestLeaseTime;
    BYTE                       *OverlayFields;
    DHCP_IP_ADDRESS UNALIGNED  *RouterAddress;
    DHCP_IP_ADDRESS UNALIGNED  *Server;
    BYTE                       *ParameterRequestList;
    DWORD                       ParameterRequestListLength;
    CHAR                       *MachineName;
    DWORD                       MachineNameLength;
    BYTE                        ClientHardwareAddressType;
    BYTE                        ClientHardwareAddressLength;
    BYTE                       *ClientHardwareAddress;
    CHAR                       *ClassIdentifier;
    DWORD                       ClassIdentifierLength;
    BYTE                       *VendorClass;
    DWORD                       VendorClassLength;
    DWORD                       DNSFlags;
    DWORD                       DNSNameLength;
    LPBYTE                      DNSName;
    BOOLEAN                     DSDomainNameRequested;
    CHAR                       *DSDomainName;
    DWORD                       DSDomainNameLen;
    DWORD UNALIGNED            *ScopeId;
} DHCP_SERVER_OPTIONS, *LPDHCP_SERVER_OPTIONS;

//
// The location in registry where the REG_MULTI_SZ list of callout DLLs
// that the DHCP Server will try to load.
//

#define   DHCP_CALLOUT_LIST_KEY    L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters"
#define   DHCP_CALLOUT_LIST_VALUE  L"CalloutDlls"
#define   DHCP_CALLOUT_LIST_TYPE   REG_MULTI_SZ
#define   DHCP_CALLOUT_ENTRY_POINT "DhcpServerCalloutEntry"

//
// Control CODES used by DHCP Server to notify server state change.
//

#define   DHCP_CONTROL_START       0x00000001
#define   DHCP_CONTROL_STOP        0x00000002
#define   DHCP_CONTROL_PAUSE       0x00000003
#define   DHCP_CONTROL_CONTINUE    0x00000004

//
// Other ControlCodes used by various Callout HOOKS.
//

#define   DHCP_DROP_DUPLICATE      0x00000001     // duplicate of pkt being processed
#define   DHCP_DROP_NOMEM          0x00000002     // not enough server mem in queues
#define   DHCP_DROP_INTERNAL_ERROR 0x00000003     // ooops?
#define   DHCP_DROP_TIMEOUT        0x00000004     // too late, pkt is too old
#define   DHCP_DROP_UNAUTH         0x00000005     // server is not authorized to run
#define   DHCP_DROP_PAUSED         0x00000006     // service is paused
#define   DHCP_DROP_NO_SUBNETS     0x00000007     // no subnets configured on server
#define   DHCP_DROP_INVALID        0x00000008     // invalid packet or client
#define   DHCP_DROP_WRONG_SERVER   0x00000009     // client in different DS enterprise
#define   DHCP_DROP_NOADDRESS      0x0000000A     // no address available to offer
#define   DHCP_DROP_PROCESSED      0x0000000B     // packet has been processed
#define   DHCP_DROP_GEN_FAILURE    0x00000100     // catch-all error
#define   DHCP_SEND_PACKET         0x10000000     // send the packet on wire
#define   DHCP_PROB_CONFLICT       0x20000001     // address conflicted..
#define   DHCP_PROB_DECLINE        0x20000002     // an addr got declined
#define   DHCP_PROB_RELEASE        0x20000003     // an addr got released
#define   DHCP_PROB_NACKED         0x20000004     // a client is being nacked.
#define   DHCP_GIVE_ADDRESS_NEW    0x30000001     // give client a "new" address
#define   DHCP_GIVE_ADDRESS_OLD    0x30000002     // renew client's "old" address
#define   DHCP_CLIENT_BOOTP        0x30000003     // client is a BOOTP client
#define   DHCP_CLIENT_DHCP         0x30000004     // client is a DHCP client



typedef
DWORD
(APIENTRY *LPDHCP_CONTROL)(
    IN DWORD dwControlCode,
    IN LPVOID lpReserved
)
/*++

Routine Description:

    This routine is called whenever the DHCP Server service is
    started, stopped, paused or continued as defined by the values of
    the dwControlCode parameter.  The lpReserved parameter is reserved
    for future use and it should not be interpreted in any way.   This
    routine should not block.

Arguments:

    dwControlCode - one of the DHCP_CONTROL_* values
    lpReserved - reserved for future use.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_NEWPKT)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN OUT LPVOID *PktContext,
    OUT LPBOOL ProcessIt
)
/*++

Routine Description:

    This routine is called soon after the DHCP Server receives a
    packet that it attempts to process.  This routine is in the
    critical path of server execution and should return very fast, as
    otherwise server performance will be impacted.  The Callout DLL
    can modify the buffer or return a new buffer via the Packet,
    PacketSize arguments.  Also, if the callout DLL has internal
    structures to keep track of the packet and its progress, it can
    then return a context to this packet in the PktContext parameter.
    This context will be passed to almost all other hooks to indicate
    the packet being referred to.  Also, if the Callout DLL is
    planning on processing the packet or for some other reason the
    DHCP server is not expected to process this packet, then it can
    set the ProcessIt flag to FALSE to indicate that the packet is to
    be dropped.

Arguments:

    Packet - This parameter points to a character buffer that holds
    the actual packet received by the DHCP Server.

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer.

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on.

    Reserved -Reserved for future use.

    PktContect - This is an opaque pointer used by the DHCP Server for
    future references to this packet.  It is expected that the callout
    DLL will provide this pointer if it is interested in keeping track
    of the packet.  (See the descriptions for the hooks below for
    other usage of this Context).

    ProcessIt - This is a BOOL flag that the CalloutDll can set to
    TRUE or reset to indicate if the DHCP Server should continue
    processing this packet or not, respectively.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_DROP_SEND)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD ControlCode,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN LPVOID PktContext
)
/*++

Routine Description:

    This hook is called if a packet is (DropPktHook) dropped for some
    reason or if the packet is completely processed.   (If a packet is
    dropped, the hook is called twice as it is called once again to
    note that the packet has been completely processed).  The callout
    DLL should  be prepared to handle this hook multiple times for a
    packet. This routine should not block. The ControlCode parameter
    defines the reasons for the packet being dropped:

    * DHCP_DROP_DUPLICATE - This packet is a duplicate of another
      received by the server.
    * DHCP_DROP_NOMEM - Not enough memory to process the packet.
    * DHCP_DROP_INTERNAL_ERROR - Unexpected nternal error occurred.
    * DHCP_DROP_TIMEOUT - The packet is too old to process.
    * DHCP_DROP_UNAUTH - The server is not authorized.
    * DHCP_DROP_PAUSED - The server is paused.
    * DHCP_DROP_NO_SUBNETS - There are no subnets configured.
    * DHCP_DROP_INVALID - The packet is invalid or it came on an
      invalid socket ..
    * DHCP_DROP_WRONG_SERVER - The packet was sent to the wrong DHCP Server.
    * DHCP_DROP_NOADDRESS - There is no address to offer.
    * DHCP_DROP_PROCESSED - The packet has been processed.
    * DHCP_DROP_GEN_FAILURE - An unknown error occurred.

    This routine is also called right before a response is sent down
    the wire (SendPktHook) and in this case the ControlCode has a
    value of DHCP_SEND_PACKET.

Arguments:

    Packet - This parameter points to a character buffer that holds
    the packet being processed by the DHCP Server.

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer.

    ControlCode - See description for various control codes.

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on.

    Reserved - Reserved for future use.

    PktContext - This parameter is the packet context that the Callout
    DLL NewPkt Hook returned for this packet.  This can be used to
    track a packet.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_PROB)(
    IN LPBYTE Packet,
    IN DWORD PacketSize,
    IN DWORD ControlCode,
    IN DWORD IpAddress,
    IN DWORD AltAddress,
    IN LPVOID Reserved,
    IN LPVOID PktContext
)
/*++

Routine Description:

    This routine is called whenever special events occur that cause
    the packet to be dropped etc.  The possible ControlCodes and their
    meanings are as follows:

    * DHCP_PROB_CONFLICT - The address attempted to be offered
      (AltAddress) is in use in the network already.
    * DHCP_PROB_DECLINE - The packet was a DECLINE message for the
      address specified in AltAddress.
    * DHCP_PROB_RELEASE - The packet was a RELEASE message for the
      address specified in AltAddress.
    * DHCP_PROB_NACKED - The packet was a REQUEST message for address
      specified in AltAddress and it was NACKed by the server.

    This routine should not block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed.

    PacketSize - This is the size of the above buffer.

    ControlCode - Specifies the event. See description below for
    control codes and meanings.

    IpAddress - IpV4 address of socket this packet was received on.

    AltAddress - Request IpV4 Address or Ip address that is in
    conflict.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_GIVE_ADDRESS)(
    IN LPBYTE Packet,
    IN DWORD PacketSize,
    IN DWORD ControlCode,
    IN DWORD IpAddress,
    IN DWORD AltAddress,
    IN DWORD AddrType,
    IN DWORD LeaseTime,
    IN LPVOID Reserved,
    IN LPVOID PktContext
)
/*++

Routine Description:

    This routine is called when the server is about to send an ACK to
    a REQUEST message.  The ControlCode specifies if the address is a
    totally new address or if it an renewal of an old address (with
    values DHCP_GIVE_ADDRESS_NEW and DHCP_GIVE_ADDRESS_OLD
    respectively). The address being offered is passed as the
    AltAddress parameter and the AddrType parameter can be one of
    DHCP_CLIENT_BOOTP or DHCP_CLIENT_DHCP indicating whether the
    client is using BOOTP or DHCP respectively. This call should not
    block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed.

    PacketSize - This is the size of the above buffer.

    ControlCode -  See description above for control codes and
    meanings.

    IpAddress - IpV4 address of socket this packet was received on.

    AltAddress - IpV4 address being ACKed to the client.

    AddrType - Is this a DHCP or BOOTP address?

    LeaseTime - Lease duration being passed.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_HANDLE_OPTIONS)(
    IN LPBYTE Packet,
    IN DWORD PacketSize,
    IN LPVOID Reserved,
    IN LPVOID PktContext,
    IN OUT LPDHCP_SERVER_OPTIONS ServerOptions
)
/*++

Routine Description:

    This routine can be utilized by the CalloutDLL to avoid parsing
    the whole packet.  The packet is parsed by the server and some
    commonly used options are returned in the parsed pointers
    structure (see header for definition of DHCP_SERVER_OPTIONS).  The
    hook is expected to make a copy of the structure pointed to by
    ServerOptions if it needs it beyond this function call.  This
    routine may be called several times for a single packet.  This
    routine should not block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed.

    PacketSize - This is the size of the above buffer.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet.

    ServerOptions - This parameter is the structure that contains a
    bunch of pointers that represent corresponding options.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_DELETE_CLIENT)(
    IN DWORD IpAddress,
    IN LPBYTE HwAddress,
    IN ULONG HwAddressLength,
    IN DWORD Reserved,
    IN DWORD ClientType
)
/*++

Routine Description:

    This routine is called before a client lease is deleted off the
    active leases database.  The ClientType field is currently not
    provided and this should not be used.  This routine should not
    block.

Arguments:

    IpAddress - IpV4 address of the client lease being deleted.

    HwAddress - Buffer holding the Hardware address of the client (MAC).

    HwAddressLength - This specifies the length of the above buffer.

    Reserved - Reserved for future use.

    ClientType - Reserved for future use.
--*/
;

typedef
struct      _DHCP_CALLOUT_TABLE {
    LPDHCP_CONTROL                 DhcpControlHook;
    LPDHCP_NEWPKT                  DhcpNewPktHook;
    LPDHCP_DROP_SEND               DhcpPktDropHook;
    LPDHCP_DROP_SEND               DhcpPktSendHook;
    LPDHCP_PROB                    DhcpAddressDelHook;
    LPDHCP_GIVE_ADDRESS            DhcpAddressOfferHook;
    LPDHCP_HANDLE_OPTIONS          DhcpHandleOptionsHook;
    LPDHCP_DELETE_CLIENT           DhcpDeleteClientHook;
    LPVOID                         DhcpExtensionHook;
    LPVOID                         DhcpReservedHook;
}   DHCP_CALLOUT_TABLE, *LPDHCP_CALLOUT_TABLE;

typedef
DWORD
(APIENTRY *LPDHCP_ENTRY_POINT_FUNC) (
    IN LPWSTR ChainDlls,
    IN DWORD CalloutVersion,
    IN OUT LPDHCP_CALLOUT_TABLE CalloutTbl
)
/*++

Routine Description:

    This is the routine that is called by the DHCP Server when it
    successfully loads a DLL.    If the routine succeeds, then the
    DHCP Server does not attempt to load any of the DLLs specified in
    the ChainDlls list of DLLs.   If this function fails for some
    reason, then the DHCP Server proceeds to the next DLL in the
    ChainDlls structure.

    Note that for version negotiation, the server may call this
    routine several times until a compatible version is found.

    It is expected that the entrypoint routine would walk through the
    names of the dlls and attempt to load each of them and when it
    succeeds in retrieving the entry point, it attempts to get the
    cumulative set of hooks by repeating the above procedure (as done
    by the DHCP Server).

Arguments:

    ChainDlls - This is a set of DLL names in REG_MULTI_SZ format (as
    returned by Registry function calls).  This does not contain the
    name of the current DLL itself, but only the names of all DLLs
    that follow the current DLL.

    CalloutVersion - This is the version that the Callout DLL is
    expected to support.  The current version number is 0.

    CalloutTbl - This is the cumulative set of Hooks that is needed by
    the current DLLs as well as all the DLLs in ChainDlls.   It is the
    responsibility of the current DLL to retrive the cumulative set of
    Hooks and merge that with its own set of hooks and return that in
    this table structure.  The table structure is defined above.

--*/
;

#ifdef __cplusplus
}
#endif
    
#endif     _CALLOUT_H_

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Digitalv.h ===
/****************************************************************************/
/*                                                                          */
/*        DIGITALV.H - Include file for the MCI Digital Video Command Set   */
/*                                                                          */
/*                              Version 1.0                                 */
/*                                                                          */
/*        Copyright (c) 1995-1998, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/*  Date            Modification                                            */
/*  ------------    ------------                                            */
/*  Aug 19, 1992    -Version 1.0 Release                                    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_DIGITALV
#define _INC_DIGITALV  100

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MCI_TEST                            0x00000020L

/* Message values */

#define MCI_CAPTURE                         0x0870
#define MCI_MONITOR                         0x0871
#define MCI_RESERVE                         0x0872
#define MCI_SETAUDIO                        0x0873
#define MCI_SIGNAL                          0x0875
#define MCI_SETVIDEO                        0x0876
#define MCI_QUALITY                         0x0877
#define MCI_LIST                            0x0878
#define MCI_UNDO                            0x0879
#define MCI_CONFIGURE                       0x087a
#define MCI_RESTORE                         0x087b

/* Return and string constant values */

#define MCI_ON   1
#define MCI_OFF  0

#define MCI_DGV_FILE_MODE_SAVING            0x0001
#define MCI_DGV_FILE_MODE_LOADING           0x0002
#define MCI_DGV_FILE_MODE_EDITING           0x0003
#define MCI_DGV_FILE_MODE_IDLE              0x0004

/* These identifiers are used only by device drivers */

#define MCI_ON_S                            0x00008000L
#define MCI_OFF_S                           0x00008001L
#define MCI_DGV_FILE_S                      0x00008002L
#define MCI_DGV_INPUT_S                     0x00008003L

#define MCI_DGV_FILE_MODE_SAVING_S          0x00008004L
#define MCI_DGV_FILE_MODE_LOADING_S         0x00008005L
#define MCI_DGV_FILE_MODE_EDITING_S         0x00008006L
#define MCI_DGV_FILE_MODE_IDLE_S            0x00008007L

#define MCI_DGV_SETVIDEO_SRC_NTSC_S         0x00008010L
#define MCI_DGV_SETVIDEO_SRC_RGB_S          0x00008011L
#define MCI_DGV_SETVIDEO_SRC_SVIDEO_S       0x00008012L
#define MCI_DGV_SETVIDEO_SRC_PAL_S          0x00008013L
#define MCI_DGV_SETVIDEO_SRC_SECAM_S        0x00008014L
#define MCI_DGV_SETVIDEO_SRC_GENERIC_S      0x00008015L

#define MCI_DGV_SETAUDIO_SRC_LEFT_S         0x00008020L
#define MCI_DGV_SETAUDIO_SRC_RIGHT_S        0x00008021L
#define MCI_DGV_SETAUDIO_SRC_AVERAGE_S      0x00008022L
#define MCI_DGV_SETAUDIO_SRC_STEREO_S       0x00008023L

/* Window message for signal notification */

#define MM_MCISIGNAL                        0x3CB

/* error values */

#define MCIERR_DGV_DEVICE_LIMIT             (MCIERR_CUSTOM_DRIVER_BASE+0)
#define MCIERR_DGV_IOERR                    (MCIERR_CUSTOM_DRIVER_BASE+1)
#define MCIERR_DGV_WORKSPACE_EMPTY          (MCIERR_CUSTOM_DRIVER_BASE+2)
#define MCIERR_DGV_DISK_FULL                (MCIERR_CUSTOM_DRIVER_BASE+3)
#define MCIERR_DGV_DEVICE_MEMORY_FULL       (MCIERR_CUSTOM_DRIVER_BASE+4)
#define MCIERR_DGV_BAD_CLIPBOARD_RANGE      (MCIERR_CUSTOM_DRIVER_BASE+5)

/* defines for monitor methods */

#define MCI_DGV_METHOD_PRE                  0x0000a000L
#define MCI_DGV_METHOD_POST                 0x0000a001L
#define MCI_DGV_METHOD_DIRECT               0x0000a002L

/* defines for known file formats */

#define MCI_DGV_FF_AVSS                     0x00004000L
#define MCI_DGV_FF_AVI                      0x00004001L
#define MCI_DGV_FF_DIB                      0x00004002L
#define MCI_DGV_FF_RDIB                     0x00004003L
#define MCI_DGV_FF_JPEG                     0x00004004L
#define MCI_DGV_FF_RJPEG                    0x00004005L
#define MCI_DGV_FF_JFIF                     0x00004006L
#define MCI_DGV_FF_MPEG                     0x00004007L

/* values for dwItem field of MCI_CAPABILITY_PARMS structure */

#define MCI_DGV_GETDEVCAPS_CAN_LOCK         0x00004000L
#define MCI_DGV_GETDEVCAPS_CAN_STRETCH      0x00004001L
#define MCI_DGV_GETDEVCAPS_CAN_FREEZE       0x00004002L
#define MCI_DGV_GETDEVCAPS_MAX_WINDOWS      0x00004003L
#define MCI_DGV_GETDEVCAPS_CAN_REVERSE      0x00004004L
#define MCI_DGV_GETDEVCAPS_HAS_STILL        0x00004005L
#define MCI_DGV_GETDEVCAPS_PALETTES         0x00004006L
#define MCI_DGV_GETDEVCAPS_CAN_STR_IN       0x00004008L
#define MCI_DGV_GETDEVCAPS_CAN_TEST         0x00004009L
#define MCI_DGV_GETDEVCAPS_MAXIMUM_RATE     0x0000400aL
#define MCI_DGV_GETDEVCAPS_MINIMUM_RATE     0x0000400bL

/* flags for dwFlags parameter of MCI_CAPTURE command message */

#define MCI_DGV_CAPTURE_AS                  0x00010000L
#define MCI_DGV_CAPTURE_AT                  0x00020000L

/* flags for dwFlags parameter of MCI_COPY command message */

#define MCI_DGV_COPY_AT                     0x00010000L
#define MCI_DGV_COPY_AUDIO_STREAM           0x00020000L
#define MCI_DGV_COPY_VIDEO_STREAM           0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */

#define MCI_DGV_CUE_INPUT                   0x00010000L
#define MCI_DGV_CUE_OUTPUT                  0x00020000L
#define MCI_DGV_CUE_NOSHOW                  0x00040000L

/* flags for dwFlags parameter of MCI_CUT command message */

#define MCI_DGV_CUT_AT                      0x00010000L
#define MCI_DGV_CUT_AUDIO_STREAM            0x00020000L
#define MCI_DGV_CUT_VIDEO_STREAM            0x00040000L

/* flags for dwFlags parameter of MCI_DELETE command message */

#define MCI_DGV_DELETE_AT                   0x00010000L
#define MCI_DGV_DELETE_AUDIO_STREAM         0x00020000L
#define MCI_DGV_DELETE_VIDEO_STREAM         0x00040000L

/* flags for dwFlags parameter of MCI_FREEZE command message */

#define MCI_DGV_FREEZE_AT                   0x00010000L
#define MCI_DGV_FREEZE_OUTSIDE              0x00020000L

/* flags for dwFlags parameter of MCI_INFO command message */

#define MCI_DGV_INFO_TEXT                   0x00010000L
#define MCI_DGV_INFO_ITEM                   0X00020000L

/* values for dwItem field of MCI_DGV_INFO_PARMS structure */

#define MCI_INFO_VERSION                    0x00000400L

#define MCI_DGV_INFO_USAGE                  0x00004000L
#define MCI_DGV_INFO_AUDIO_QUALITY          0x00004001L
#define MCI_DGV_INFO_STILL_QUALITY          0x00004002L
#define MCI_DGV_INFO_VIDEO_QUALITY          0x00004003L
#define MCI_DGV_INFO_AUDIO_ALG              0x00004004L
#define MCI_DGV_INFO_STILL_ALG              0x00004005L
#define MCI_DGV_INFO_VIDEO_ALG              0x00004006L

/* flags for dwFlags parameter of MCI_LIST command message */

#define MCI_DGV_LIST_ITEM                   0x00010000L
#define MCI_DGV_LIST_COUNT                  0x00020000L
#define MCI_DGV_LIST_NUMBER                 0x00040000L
#define MCI_DGV_LIST_ALG                    0x00080000L

/* values for dwItem field of MCI_DGV_LIST_PARMS structure */

#define MCI_DGV_LIST_AUDIO_ALG              0x00004000L
#define MCI_DGV_LIST_AUDIO_QUALITY          0x00004001L
#define MCI_DGV_LIST_AUDIO_STREAM           0x00004002L
#define MCI_DGV_LIST_STILL_ALG              0x00004003L
#define MCI_DGV_LIST_STILL_QUALITY          0x00004004L
#define MCI_DGV_LIST_VIDEO_ALG              0x00004005L
#define MCI_DGV_LIST_VIDEO_QUALITY          0x00004006L
#define MCI_DGV_LIST_VIDEO_STREAM           0x00004007L
#define MCI_DGV_LIST_VIDEO_SOURCE           0x00004008L


/* flags for dwFlags parameter of MCI_MONITOR command message */

#define MCI_DGV_MONITOR_METHOD              0x00010000L
#define MCI_DGV_MONITOR_SOURCE              0x00020000L

/* values for dwSource parameter of the MCI_DGV_MONITOR_PARMS struture */

#define MCI_DGV_MONITOR_INPUT               0x00004000L
#define MCI_DGV_MONITOR_FILE                0x00004001L

/* flags for dwFlags parameter of MCI_OPEN command message */

#define MCI_DGV_OPEN_WS                     0x00010000L
#define MCI_DGV_OPEN_PARENT                 0x00020000L
#define MCI_DGV_OPEN_NOSTATIC               0x00040000L
#define MCI_DGV_OPEN_16BIT                  0x00080000L
#define MCI_DGV_OPEN_32BIT                  0x00100000L

/* flags for dwFlags parameter of MCI_PASTE command message */

#define MCI_DGV_PASTE_AT                    0x00010000L
#define MCI_DGV_PASTE_AUDIO_STREAM          0x00020000L
#define MCI_DGV_PASTE_VIDEO_STREAM          0x00040000L
#define MCI_DGV_PASTE_INSERT                0x00080000L
#define MCI_DGV_PASTE_OVERWRITE             0x00100000L

/* flags for dwFlags parameter of MCI_PLAY command message */

#define MCI_DGV_PLAY_REPEAT                 0x00010000L
#define MCI_DGV_PLAY_REVERSE                0x00020000L

/* flags for dwFlags parameter of MCI_PUT command message */

#define MCI_DGV_RECT                        0x00010000L
#define MCI_DGV_PUT_SOURCE                  0x00020000L
#define MCI_DGV_PUT_DESTINATION             0x00040000L
#define MCI_DGV_PUT_FRAME                   0x00080000L
#define MCI_DGV_PUT_VIDEO                   0x00100000L
#define MCI_DGV_PUT_WINDOW                  0x00200000L
#define MCI_DGV_PUT_CLIENT                  0x00400000L

/* flags for dwFlags parameter of MCI_QUALITY command message */

#define MCI_QUALITY_ITEM                    0x00010000L
#define MCI_QUALITY_NAME                    0x00020000L
#define MCI_QUALITY_ALG                     0x00040000L
#define MCI_QUALITY_DIALOG                  0x00080000L
#define MCI_QUALITY_HANDLE                  0x00100000L

/* values for dwItem field of MCI_QUALITY_PARMS structure */

#define MCI_QUALITY_ITEM_AUDIO              0x00004000L
#define MCI_QUALITY_ITEM_STILL              0x00004001L
#define MCI_QUALITY_ITEM_VIDEO              0x00004002L

/* flags for dwFlags parameter of MCI_REALIZE command message */

#define MCI_DGV_REALIZE_NORM                0x00010000L
#define MCI_DGV_REALIZE_BKGD                0x00020000L

/* flags for dwFlags parameter of MCI_RECORD command message */

#define MCI_DGV_RECORD_HOLD                 0x00020000L
#define MCI_DGV_RECORD_AUDIO_STREAM         0x00040000L
#define MCI_DGV_RECORD_VIDEO_STREAM         0x00080000L

/* flags for dwFlags parameters of MCI_RESERVE command message */

#define MCI_DGV_RESERVE_IN                  0x00010000L
#define MCI_DGV_RESERVE_SIZE                0x00020000L

/* flags for dwFlags parameter of MCI_RESTORE command message */

#define MCI_DGV_RESTORE_FROM                0x00010000L
#define MCI_DGV_RESTORE_AT                  0x00020000L

/* flags for dwFlags parameters of MCI_SAVE command message */

#define MCI_DGV_SAVE_ABORT                  0x00020000L
#define MCI_DGV_SAVE_KEEPRESERVE            0x00040000L

/* flags for dwFlags parameters of MCI_SET command message */

#define MCI_DGV_SET_SEEK_EXACTLY            0x00010000L
#define MCI_DGV_SET_SPEED                   0x00020000L
#define MCI_DGV_SET_STILL                   0x00040000L
#define MCI_DGV_SET_FILEFORMAT              0x00080000L

/* flags for the dwFlags parameter of MCI_SETAUDIO command message */

#define MCI_DGV_SETAUDIO_OVER               0x00010000L
#define MCI_DGV_SETAUDIO_CLOCKTIME          0x00020000L
#define MCI_DGV_SETAUDIO_ALG                0x00040000L
#define MCI_DGV_SETAUDIO_QUALITY            0x00080000L
#define MCI_DGV_SETAUDIO_RECORD             0x00100000L
#define MCI_DGV_SETAUDIO_LEFT               0x00200000L
#define MCI_DGV_SETAUDIO_RIGHT              0x00400000L
#define MCI_DGV_SETAUDIO_ITEM               0x00800000L
#define MCI_DGV_SETAUDIO_VALUE              0x01000000L
#define MCI_DGV_SETAUDIO_INPUT              0x02000000L
#define MCI_DGV_SETAUDIO_OUTPUT             0x04000000L

/* values for the dwItem parameter of MCI_DGV_SETAUDIO_PARMS */

#define MCI_DGV_SETAUDIO_TREBLE             0x00004000L
#define MCI_DGV_SETAUDIO_BASS               0x00004001L
#define MCI_DGV_SETAUDIO_VOLUME             0x00004002L
#define MCI_DGV_SETAUDIO_STREAM             0x00004003L
#define MCI_DGV_SETAUDIO_SOURCE             0x00004004L
#define MCI_DGV_SETAUDIO_SAMPLESPERSEC      0x00004005L
#define MCI_DGV_SETAUDIO_AVGBYTESPERSEC     0x00004006L
#define MCI_DGV_SETAUDIO_BLOCKALIGN         0x00004007L
#define MCI_DGV_SETAUDIO_BITSPERSAMPLE      0x00004008L

/* values for the dwValue parameter of MCI_DGV_SETAUDIO_PARMS
   used with MCI_DGV_SETAUDIO_SOURCE */

#define MCI_DGV_SETAUDIO_SOURCE_STEREO      0x00000000L
#define MCI_DGV_SETAUDIO_SOURCE_LEFT        0x00000001L
#define MCI_DGV_SETAUDIO_SOURCE_RIGHT       0x00000002L
#define MCI_DGV_SETAUDIO_SOURCE_AVERAGE     0x00004000L

/* flags for the dwFlags parameter of MCI_SETVIDEO command */

#define MCI_DGV_SETVIDEO_QUALITY            0x00010000L
#define MCI_DGV_SETVIDEO_ALG                0x00020000L
#define MCI_DGV_SETVIDEO_CLOCKTIME          0x00040000L
#define MCI_DGV_SETVIDEO_SRC_NUMBER         0x00080000L
#define MCI_DGV_SETVIDEO_ITEM               0x00100000L
#define MCI_DGV_SETVIDEO_OVER               0x00200000L
#define MCI_DGV_SETVIDEO_RECORD             0x00400000L
#define MCI_DGV_SETVIDEO_STILL              0x00800000L
#define MCI_DGV_SETVIDEO_VALUE              0x01000000L
#define MCI_DGV_SETVIDEO_INPUT              0x02000000L
#define MCI_DGV_SETVIDEO_OUTPUT             0x04000000L

/* values for the dwTo field of MCI_SETVIDEO_PARMS
   used with MCI_DGV_SETVIDEO_SOURCE */

#define MCI_DGV_SETVIDEO_SRC_NTSC           0x00004000L
#define MCI_DGV_SETVIDEO_SRC_RGB            0x00004001L
#define MCI_DGV_SETVIDEO_SRC_SVIDEO         0x00004002L
#define MCI_DGV_SETVIDEO_SRC_PAL            0x00004003L
#define MCI_DGV_SETVIDEO_SRC_SECAM          0x00004004L
#define MCI_DGV_SETVIDEO_SRC_GENERIC        0x00004005L

/* values for the dwItem field of MCI_SETVIDEO_PARMS */

#define MCI_DGV_SETVIDEO_BRIGHTNESS         0x00004000L
#define MCI_DGV_SETVIDEO_COLOR              0x00004001L
#define MCI_DGV_SETVIDEO_CONTRAST           0x00004002L
#define MCI_DGV_SETVIDEO_TINT               0x00004003L
#define MCI_DGV_SETVIDEO_SHARPNESS          0x00004004L
#define MCI_DGV_SETVIDEO_GAMMA              0x00004005L
#define MCI_DGV_SETVIDEO_STREAM             0x00004006L
#define MCI_DGV_SETVIDEO_PALHANDLE          0x00004007L
#define MCI_DGV_SETVIDEO_FRAME_RATE         0x00004008L
#define MCI_DGV_SETVIDEO_SOURCE             0x00004009L
#define MCI_DGV_SETVIDEO_KEY_INDEX          0x0000400aL
#define MCI_DGV_SETVIDEO_KEY_COLOR          0x0000400bL
#define MCI_DGV_SETVIDEO_BITSPERPEL         0x0000400cL

/* flags for the dwFlags parameter of MCI_SIGNAL */

#define MCI_DGV_SIGNAL_AT                   0x00010000L
#define MCI_DGV_SIGNAL_EVERY                0x00020000L
#define MCI_DGV_SIGNAL_USERVAL              0x00040000L
#define MCI_DGV_SIGNAL_CANCEL               0x00080000L
#define MCI_DGV_SIGNAL_POSITION             0x00100000L

/* The following is the function digitalvideo drivers must use
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_DGVSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_DGV_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_DGV_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_DGV_SIGNAL_POSITION flag was set
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_DGVSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_DGV_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_DGV_SIGNAL_POSITION) ? (dwUser):(dwPos))

/* flags for the dwFlags parameter of MCI_STATUS command */

#define MCI_DGV_STATUS_NOMINAL              0x00020000L
#define MCI_DGV_STATUS_REFERENCE            0x00040000L
#define MCI_DGV_STATUS_LEFT                 0x00080000L
#define MCI_DGV_STATUS_RIGHT                0x00100000L
#define MCI_DGV_STATUS_DISKSPACE            0x00200000L
#define MCI_DGV_STATUS_INPUT                0x00400000L
#define MCI_DGV_STATUS_OUTPUT               0x00800000L
#define MCI_DGV_STATUS_RECORD               0x01000000L

/* values for dwItem field of MCI_STATUS_PARMS structure */

#define MCI_DGV_STATUS_AUDIO_INPUT          0x00004000L
#define MCI_DGV_STATUS_HWND                 0x00004001L
#define MCI_DGV_STATUS_SPEED                0x00004003L
#define MCI_DGV_STATUS_HPAL                 0x00004004L
#define MCI_DGV_STATUS_BRIGHTNESS           0x00004005L
#define MCI_DGV_STATUS_COLOR                0x00004006L
#define MCI_DGV_STATUS_CONTRAST             0x00004007L
#define MCI_DGV_STATUS_FILEFORMAT           0x00004008L
#define MCI_DGV_STATUS_AUDIO_SOURCE         0x00004009L
#define MCI_DGV_STATUS_GAMMA                0x0000400aL
#define MCI_DGV_STATUS_MONITOR              0x0000400bL
#define MCI_DGV_STATUS_MONITOR_METHOD       0x0000400cL
#define MCI_DGV_STATUS_FRAME_RATE           0x0000400eL
#define MCI_DGV_STATUS_BASS                 0x0000400fL
#define MCI_DGV_STATUS_SIZE                 0x00004010L
#define MCI_DGV_STATUS_SEEK_EXACTLY         0x00004011L
#define MCI_DGV_STATUS_SHARPNESS            0x00004012L
#define MCI_DGV_STATUS_SMPTE                0x00004013L
#define MCI_DGV_STATUS_AUDIO                0x00004014L
#define MCI_DGV_STATUS_TINT                 0x00004015L
#define MCI_DGV_STATUS_TREBLE               0x00004016L
#define MCI_DGV_STATUS_UNSAVED              0x00004017L
#define MCI_DGV_STATUS_VIDEO                0x00004018L
#define MCI_DGV_STATUS_VOLUME               0x00004019L
#define MCI_DGV_STATUS_AUDIO_RECORD         0x0000401aL
#define MCI_DGV_STATUS_VIDEO_SOURCE         0x0000401bL
#define MCI_DGV_STATUS_VIDEO_RECORD         0x0000401cL
#define MCI_DGV_STATUS_STILL_FILEFORMAT     0x0000401dL
#define MCI_DGV_STATUS_VIDEO_SRC_NUM        0x0000401eL
#define MCI_DGV_STATUS_FILE_MODE            0x0000401fL
#define MCI_DGV_STATUS_FILE_COMPLETION      0x00004020L
#define MCI_DGV_STATUS_WINDOW_VISIBLE       0x00004021L
#define MCI_DGV_STATUS_WINDOW_MINIMIZED     0x00004022L
#define MCI_DGV_STATUS_WINDOW_MAXIMIZED     0x00004023L
#define MCI_DGV_STATUS_KEY_INDEX            0x00004024L
#define MCI_DGV_STATUS_KEY_COLOR            0x00004025L
#define MCI_DGV_STATUS_PAUSE_MODE           0x00004026L
#define MCI_DGV_STATUS_SAMPLESPERSEC        0x00004027L
#define MCI_DGV_STATUS_AVGBYTESPERSEC       0x00004028L
#define MCI_DGV_STATUS_BLOCKALIGN           0x00004029L
#define MCI_DGV_STATUS_BITSPERSAMPLE        0x0000402aL
#define MCI_DGV_STATUS_BITSPERPEL           0x0000402bL
#define MCI_DGV_STATUS_FORWARD              0x0000402cL
#define MCI_DGV_STATUS_AUDIO_STREAM         0x0000402dL
#define MCI_DGV_STATUS_VIDEO_STREAM         0x0000402eL

/* flags for dwFlags parameter of MCI_STEP command message */

#define MCI_DGV_STEP_REVERSE                0x00010000L
#define MCI_DGV_STEP_FRAMES                 0x00020000L

/* flags for dwFlags parameter of MCI_STOP command message */

#define MCI_DGV_STOP_HOLD                   0x00010000L

/* flags for dwFlags parameter of MCI_UPDATE command message */

#define MCI_DGV_UPDATE_HDC                  0x00020000L
#define MCI_DGV_UPDATE_PAINT                0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */

#define MCI_DGV_WHERE_SOURCE                0x00020000L
#define MCI_DGV_WHERE_DESTINATION           0x00040000L
#define MCI_DGV_WHERE_FRAME                 0x00080000L
#define MCI_DGV_WHERE_VIDEO                 0x00100000L
#define MCI_DGV_WHERE_WINDOW                0x00200000L
#define MCI_DGV_WHERE_MAX                   0x00400000L

/* flags for dwFlags parameter of MCI_WINDOW command message */

#define MCI_DGV_WINDOW_HWND                 0x00010000L
#define MCI_DGV_WINDOW_STATE                0x00040000L
#define MCI_DGV_WINDOW_TEXT                 0x00080000L

/* flags for hWnd parameter of MCI_DGV_WINDOW_PARMS parameter block */

#define MCI_DGV_WINDOW_DEFAULT              0x00000000L

/* parameter block for MCI_WHERE, MCI_PUT, MCI_FREEZE, MCI_UNFREEZE cmds */

typedef struct {
    DWORD_PTR   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_RECT_PARMS;
typedef MCI_DGV_RECT_PARMS FAR * LPMCI_DGV_RECT_PARMS;

/* parameter block for MCI_CAPTURE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrFileName;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_CAPTURE_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrFileName;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_CAPTURE_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_CAPTURE_PARMSW MCI_DGV_CAPTURE_PARMS;
#else
typedef MCI_DGV_CAPTURE_PARMSA MCI_DGV_CAPTURE_PARMS;
#endif // UNICODE
typedef MCI_DGV_CAPTURE_PARMSA FAR * LPMCI_DGV_CAPTURE_PARMSA;
typedef MCI_DGV_CAPTURE_PARMSW FAR * LPMCI_DGV_CAPTURE_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_CAPTURE_PARMSW LPMCI_DGV_CAPTURE_PARMS;
#else
typedef LPMCI_DGV_CAPTURE_PARMSA LPMCI_DGV_CAPTURE_PARMS;
#endif // UNICODE

/* parameter block for MCI_CLOSE command message */

typedef MCI_GENERIC_PARMS MCI_CLOSE_PARMS;
typedef MCI_CLOSE_PARMS FAR * LPMCI_CLOSE_PARMS;

/* parameter block for MCI_COPY command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_COPY_PARMS;
typedef MCI_DGV_COPY_PARMS FAR * LPMCI_DGV_COPY_PARMS;

/* parameter block for MCI_CUE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwTo;
} MCI_DGV_CUE_PARMS;
typedef MCI_DGV_CUE_PARMS FAR * LPMCI_DGV_CUE_PARMS;

/* parameter block for MCI_CUT command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_CUT_PARMS;
typedef MCI_DGV_CUT_PARMS FAR * LPMCI_DGV_CUT_PARMS;

/* parameter block for MCI_DELETE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_DELETE_PARMS;
typedef MCI_DGV_DELETE_PARMS FAR * LPMCI_DGV_DELETE_PARMS;

/* parameter block for MCI_FREEZE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_FREEZE_PARMS;
typedef MCI_DGV_FREEZE_PARMS FAR * LPMCI_DGV_FREEZE_PARMS;

/* parameter block for MCI_INFO command message */

typedef struct  {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwItem;
} MCI_DGV_INFO_PARMSA;
typedef struct  {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwItem;
} MCI_DGV_INFO_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_INFO_PARMSW MCI_DGV_INFO_PARMS;
#else
typedef MCI_DGV_INFO_PARMSA MCI_DGV_INFO_PARMS;
#endif // UNICODE
//? already typedef'd?  //typedef MCI_INFO_PARMS FAR * LPMCI_INFO_PARMS;
typedef MCI_DGV_INFO_PARMSA FAR * LPMCI_DGV_INFO_PARMSA;
typedef MCI_DGV_INFO_PARMSW FAR * LPMCI_DGV_INFO_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_INFO_PARMSW LPMCI_DGV_INFO_PARMS;
#else
typedef LPMCI_DGV_INFO_PARMSA LPMCI_DGV_INFO_PARMS;
#endif // UNICODE

/* parameter block for MCI_LIST command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwLength;
    DWORD   dwNumber;
    DWORD   dwItem;
    LPSTR   lpstrAlgorithm;
} MCI_DGV_LIST_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwLength;
    DWORD   dwNumber;
    DWORD   dwItem;
    LPWSTR  lpstrAlgorithm;
} MCI_DGV_LIST_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_LIST_PARMSW MCI_DGV_LIST_PARMS;
#else
typedef MCI_DGV_LIST_PARMSA MCI_DGV_LIST_PARMS;
#endif // UNICODE
typedef MCI_DGV_LIST_PARMSA FAR * LPMCI_DGV_LIST_PARMSA;
typedef MCI_DGV_LIST_PARMSW FAR * LPMCI_DGV_LIST_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_LIST_PARMSW LPMCI_DGV_LIST_PARMS;
#else
typedef LPMCI_DGV_LIST_PARMSA LPMCI_DGV_LIST_PARMS;
#endif // UNICODE

/* parameter block for MCI_LOAD command message */

typedef MCI_LOAD_PARMS MCI_DGV_LOAD_PARMS;
typedef MCI_DGV_LOAD_PARMS FAR * LPMCI_DGV_LOAD_PARMS;

/* parameter block for MCI_MONITOR command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwSource;
    DWORD   dwMethod;
} MCI_DGV_MONITOR_PARMS;
typedef MCI_DGV_MONITOR_PARMS FAR * LPMCI_DGV_MONITOR_PARMS;

/* parameter block for MCI_OPEN command message */

typedef struct {
    DWORD_PTR   dwCallback;
    UINT    wDeviceID;
#ifndef _WIN32
    WORD    wReserved0;
#endif
    LPSTR   lpstrDeviceType;
    LPSTR   lpstrElementName;
    LPSTR   lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
#ifndef _WIN32
    WORD    wReserved1;
#endif
} MCI_DGV_OPEN_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    UINT    wDeviceID;
#ifndef _WIN32
    WORD    wReserved0;
#endif
    LPWSTR  lpstrDeviceType;
    LPWSTR  lpstrElementName;
    LPWSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
#ifndef _WIN32
    WORD    wReserved1;
#endif
} MCI_DGV_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_OPEN_PARMSW MCI_DGV_OPEN_PARMS;
#else
typedef MCI_DGV_OPEN_PARMSA MCI_DGV_OPEN_PARMS;
#endif // UNICODE
typedef MCI_DGV_OPEN_PARMSA FAR * LPMCI_DGV_OPEN_PARMSA;
typedef MCI_DGV_OPEN_PARMSW FAR * LPMCI_DGV_OPEN_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_OPEN_PARMSW LPMCI_DGV_OPEN_PARMS;
#else
typedef LPMCI_DGV_OPEN_PARMSA LPMCI_DGV_OPEN_PARMS;
#endif // UNICODE

/* parameter block for MCI_PAUSE command message */

typedef MCI_GENERIC_PARMS MCI_DGV_PAUSE_PARMS;
typedef MCI_DGV_PAUSE_PARMS FAR * LPMCI_DGV_PAUSE_PARMS;

/* parameter block for MCI_PASTE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_PASTE_PARMS;
typedef MCI_DGV_PASTE_PARMS FAR * LPMCI_DGV_PASTE_PARMS;

/* parameter block for MCI_PLAY command message */

typedef MCI_PLAY_PARMS MCI_DGV_PLAY_PARMS;
typedef MCI_DGV_PLAY_PARMS FAR * LPMCI_DGV_PLAY_PARMS;

/* parameter block for MCI_PUT command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_PUT_PARMS;
typedef MCI_DGV_PUT_PARMS FAR * LPMCI_DGV_PUT_PARMS;

/* parameter block for MCI_QUALITY command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD       dwItem;
    LPSTR       lpstrName;
    DWORD       lpstrAlgorithm;
    DWORD       dwHandle;
} MCI_DGV_QUALITY_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    DWORD       dwItem;
    LPWSTR      lpstrName;
    DWORD       lpstrAlgorithm;
    DWORD       dwHandle;
} MCI_DGV_QUALITY_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_QUALITY_PARMSW MCI_DGV_QUALITY_PARMS;
#else
typedef MCI_DGV_QUALITY_PARMSA MCI_DGV_QUALITY_PARMS;
#endif // UNICODE
typedef MCI_DGV_QUALITY_PARMSA FAR * LPMCI_DGV_QUALITY_PARMSA;
typedef MCI_DGV_QUALITY_PARMSW FAR * LPMCI_DGV_QUALITY_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_QUALITY_PARMSW LPMCI_DGV_QUALITY_PARMS;
#else
typedef LPMCI_DGV_QUALITY_PARMSA LPMCI_DGV_QUALITY_PARMS;
#endif // UNICODE

/* parameter block for MCI_REALIZE command message */

typedef MCI_GENERIC_PARMS MCI_REALIZE_PARMS;
typedef MCI_REALIZE_PARMS FAR * LPMCI_REALIZE_PARMS;

/* parameter block for MCI_RECORD command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_RECORD_PARMS;
typedef MCI_DGV_RECORD_PARMS FAR * LPMCI_DGV_RECORD_PARMS;

/* parameter block for MCI_RESERVE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrPath;
    DWORD   dwSize;
} MCI_DGV_RESERVE_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrPath;
    DWORD   dwSize;
} MCI_DGV_RESERVE_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_RESERVE_PARMSW MCI_DGV_RESERVE_PARMS;
#else
typedef MCI_DGV_RESERVE_PARMSA MCI_DGV_RESERVE_PARMS;
#endif // UNICODE
typedef MCI_DGV_RESERVE_PARMSA FAR * LPMCI_DGV_RESERVE_PARMSA;
typedef MCI_DGV_RESERVE_PARMSW FAR * LPMCI_DGV_RESERVE_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_RESERVE_PARMSW LPMCI_DGV_RESERVE_PARMS;
#else
typedef LPMCI_DGV_RESERVE_PARMSA LPMCI_DGV_RESERVE_PARMS;
#endif // UNICODE

/* parameter block for MCI_RESTORE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrFileName;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_RESTORE_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrFileName;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_RESTORE_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_RESTORE_PARMSW MCI_DGV_RESTORE_PARMS;
#else
typedef MCI_DGV_RESTORE_PARMSA MCI_DGV_RESTORE_PARMS;
#endif // UNICODE
typedef MCI_DGV_RESTORE_PARMSA FAR * LPMCI_DGV_RESTORE_PARMSA;
typedef MCI_DGV_RESTORE_PARMSW FAR * LPMCI_DGV_RESTORE_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_RESTORE_PARMSW LPMCI_DGV_RESTORE_PARMS;
#else
typedef LPMCI_DGV_RESTORE_PARMSA LPMCI_DGV_RESTORE_PARMS;
#endif // UNICODE

/* parameter block for MCI_RESUME command message */

typedef MCI_GENERIC_PARMS MCI_DGV_RESUME_PARMS;
typedef MCI_DGV_RESUME_PARMS FAR * LPMCI_DGV_RESUME_PARMS;

/* parameter block for MCI_SAVE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrFileName;
    RECT    rc;
} MCI_DGV_SAVE_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrFileName;
    RECT    rc;
} MCI_DGV_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_SAVE_PARMSW MCI_DGV_SAVE_PARMS;
#else
typedef MCI_DGV_SAVE_PARMSA MCI_DGV_SAVE_PARMS;
#endif // UNICODE
typedef MCI_DGV_SAVE_PARMSA FAR * LPMCI_DGV_SAVE_PARMSA;
typedef MCI_DGV_SAVE_PARMSW FAR * LPMCI_DGV_SAVE_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_SAVE_PARMSW LPMCI_DGV_SAVE_PARMS;
#else
typedef LPMCI_DGV_SAVE_PARMSA LPMCI_DGV_SAVE_PARMS;
#endif // UNICODE

/* parameter block for MCI_SET command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwFileFormat;
    DWORD   dwSpeed;
} MCI_DGV_SET_PARMS;
typedef MCI_DGV_SET_PARMS FAR * LPMCI_DGV_SET_PARMS;

/* parameter block for MCI_SETAUDIO command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPSTR   lpstrAlgorithm;
    LPSTR   lpstrQuality;
} MCI_DGV_SETAUDIO_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPWSTR  lpstrAlgorithm;
    LPWSTR  lpstrQuality;
} MCI_DGV_SETAUDIO_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_SETAUDIO_PARMSW MCI_DGV_SETAUDIO_PARMS;
#else
typedef MCI_DGV_SETAUDIO_PARMSA MCI_DGV_SETAUDIO_PARMS;
#endif // UNICODE
typedef MCI_DGV_SETAUDIO_PARMSA FAR * LPMCI_DGV_SETAUDIO_PARMSA;
typedef MCI_DGV_SETAUDIO_PARMSW FAR * LPMCI_DGV_SETAUDIO_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_SETAUDIO_PARMSW LPMCI_DGV_SETAUDIO_PARMS;
#else
typedef LPMCI_DGV_SETAUDIO_PARMSA LPMCI_DGV_SETAUDIO_PARMS;
#endif // UNICODE

/* parameter block for MCI_SIGNAL command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_DGV_SIGNAL_PARMS;
typedef MCI_DGV_SIGNAL_PARMS FAR * LPMCI_DGV_SIGNAL_PARMS;

/* parameter block for MCI_SETVIDEO command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPSTR   lpstrAlgorithm;
    LPSTR   lpstrQuality;
    DWORD   dwSourceNumber;
} MCI_DGV_SETVIDEO_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPWSTR  lpstrAlgorithm;
    LPWSTR  lpstrQuality;
    DWORD   dwSourceNumber;
} MCI_DGV_SETVIDEO_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_SETVIDEO_PARMSW MCI_DGV_SETVIDEO_PARMS;
#else
typedef MCI_DGV_SETVIDEO_PARMSA MCI_DGV_SETVIDEO_PARMS;
#endif // UNICODE
typedef MCI_DGV_SETVIDEO_PARMSA FAR * LPMCI_DGV_SETVIDEO_PARMSA;
typedef MCI_DGV_SETVIDEO_PARMSW FAR * LPMCI_DGV_SETVIDEO_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_SETVIDEO_PARMSW LPMCI_DGV_SETVIDEO_PARMS;
#else
typedef LPMCI_DGV_SETVIDEO_PARMSA LPMCI_DGV_SETVIDEO_PARMS;
#endif // UNICODE

/* parameter block for MCI_STATUS command message */

typedef struct {
    DWORD_PTR dwCallback;
    DWORD_PTR dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    LPSTR   lpstrDrive;
    DWORD   dwReference;
} MCI_DGV_STATUS_PARMSA;
typedef struct {
    DWORD_PTR dwCallback;
    DWORD_PTR dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    LPWSTR  lpstrDrive;
    DWORD   dwReference;
} MCI_DGV_STATUS_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_STATUS_PARMSW MCI_DGV_STATUS_PARMS;
#else
typedef MCI_DGV_STATUS_PARMSA MCI_DGV_STATUS_PARMS;
#endif // UNICODE
typedef MCI_DGV_STATUS_PARMSA FAR * LPMCI_DGV_STATUS_PARMSA;
typedef MCI_DGV_STATUS_PARMSW FAR * LPMCI_DGV_STATUS_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_STATUS_PARMSW LPMCI_DGV_STATUS_PARMS;
#else
typedef LPMCI_DGV_STATUS_PARMSA LPMCI_DGV_STATUS_PARMS;
#endif // UNICODE

/* parameter block for MCI_STEP command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrames;
} MCI_DGV_STEP_PARMS;
typedef MCI_DGV_STEP_PARMS FAR *LPMCI_DGV_STEP_PARMS;

/* parameter block for MCI_STOP command message */

typedef MCI_GENERIC_PARMS MCI_DGV_STOP_PARMS;
typedef MCI_DGV_STOP_PARMS FAR * LPMCI_DGV_STOP_PARMS;

/* parameter block for MCI_UNFREEZE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_UNFREEZE_PARMS;
typedef MCI_DGV_UNFREEZE_PARMS FAR * LPMCI_DGV_UNFREEZE_PARMS;

/* parameter block for MCI_UPDATE command message */

typedef struct {
    DWORD_PTR   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    HDC     hDC;

#ifndef _WIN32
    WORD    wReserved0;
#endif
} MCI_DGV_UPDATE_PARMS;
typedef MCI_DGV_UPDATE_PARMS FAR * LPMCI_DGV_UPDATE_PARMS;

/* parameter block for MCI_WHERE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_WHERE_PARMS;
typedef MCI_DGV_WHERE_PARMS FAR * LPMCI_DGV_WHERE_PARMS;

/* parameter block for MCI_WINDOW command message */

typedef struct {
    DWORD_PTR   dwCallback;
    HWND    hWnd;
#ifndef _WIN32
    WORD    wReserved1;
#endif
    UINT    nCmdShow;
#ifndef _WIN32
    WORD    wReserved2;
#endif
    LPSTR   lpstrText;
} MCI_DGV_WINDOW_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    HWND    hWnd;
#ifndef _WIN32
    WORD    wReserved1;
#endif
    UINT    nCmdShow;
#ifndef _WIN32
    WORD    wReserved2;
#endif
    LPWSTR  lpstrText;
} MCI_DGV_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_WINDOW_PARMSW MCI_DGV_WINDOW_PARMS;
#else
typedef MCI_DGV_WINDOW_PARMSA MCI_DGV_WINDOW_PARMS;
#endif // UNICODE
typedef MCI_DGV_WINDOW_PARMSA FAR * LPMCI_DGV_WINDOW_PARMSA;
typedef MCI_DGV_WINDOW_PARMSW FAR * LPMCI_DGV_WINDOW_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_WINDOW_PARMSW LPMCI_DGV_WINDOW_PARMS;
#else
typedef LPMCI_DGV_WINDOW_PARMSA LPMCI_DGV_WINDOW_PARMS;
#endif // UNICODE

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#endif  /* !_INC_DIGITALV */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Dimm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dimm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __dimm_h__
#define __dimm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IEnumInputContext_FWD_DEFINED__
#define __IEnumInputContext_FWD_DEFINED__
typedef interface IEnumInputContext IEnumInputContext;
#endif 	/* __IEnumInputContext_FWD_DEFINED__ */


#ifndef __IActiveIMMRegistrar_FWD_DEFINED__
#define __IActiveIMMRegistrar_FWD_DEFINED__
typedef interface IActiveIMMRegistrar IActiveIMMRegistrar;
#endif 	/* __IActiveIMMRegistrar_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


#ifndef __IActiveIMMIME_FWD_DEFINED__
#define __IActiveIMMIME_FWD_DEFINED__
typedef interface IActiveIMMIME IActiveIMMIME;
#endif 	/* __IActiveIMMIME_FWD_DEFINED__ */


#ifndef __IActiveIME_FWD_DEFINED__
#define __IActiveIME_FWD_DEFINED__
typedef interface IActiveIME IActiveIME;
#endif 	/* __IActiveIME_FWD_DEFINED__ */


#ifndef __IActiveIME2_FWD_DEFINED__
#define __IActiveIME2_FWD_DEFINED__
typedef interface IActiveIME2 IActiveIME2;
#endif 	/* __IActiveIME2_FWD_DEFINED__ */


#ifndef __CActiveIMM_FWD_DEFINED__
#define __CActiveIMM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CActiveIMM CActiveIMM;
#else
typedef struct CActiveIMM CActiveIMM;
#endif /* __cplusplus */

#endif 	/* __CActiveIMM_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dimm_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// dimm.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_dimm_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dimm_0000_0000_v0_0_s_ifspec;


#ifndef __ActiveIMM_LIBRARY_DEFINED__
#define __ActiveIMM_LIBRARY_DEFINED__

/* library ActiveIMM */
/* [version][lcid][helpstring][uuid] */ 

#include <imm.h>
#if 0
typedef WORD LANGID;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    } 	REGISTERWORDA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    } 	REGISTERWORDW;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	CANDIDATEFORM;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	COMPOSITIONFORM;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    } 	CANDIDATELIST;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    } 	STYLEBUFA;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    } 	STYLEBUFW;

typedef WORD ATOM;

#endif
#if (WINVER < 0x040A)
typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0010
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0011
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOW;

#endif
#ifndef _DDKIMM_H_
typedef /* [public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0012
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        } 	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    } 	INPUTCONTEXT;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0014
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    } 	IMEINFO;

#endif

EXTERN_C const IID LIBID_ActiveIMM;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/* interface IEnumRegisterWordA */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out REGISTERWORDA *rgRegisterWord,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordA * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordA * This,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out REGISTERWORDA *rgRegisterWord,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumRegisterWordA_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumRegisterWordA_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched) ) 

#define IEnumRegisterWordA_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    ( (This)->lpVtbl -> Skip(This,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/* interface IEnumRegisterWordW */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out REGISTERWORDW *rgRegisterWord,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordW * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordW * This,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out REGISTERWORDW *rgRegisterWord,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumRegisterWordW_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumRegisterWordW_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched) ) 

#define IEnumRegisterWordW_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    ( (This)->lpVtbl -> Skip(This,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IEnumInputContext_INTERFACE_DEFINED__
#define __IEnumInputContext_INTERFACE_DEFINED__

/* interface IEnumInputContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumInputContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09b5eab0-f997-11d1-93d4-0060b067b86e")
    IEnumInputContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out HIMC *rgInputContext,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumInputContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumInputContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumInputContext * This,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out HIMC *rgInputContext,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumInputContextVtbl;

    interface IEnumInputContext
    {
        CONST_VTBL struct IEnumInputContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumInputContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumInputContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumInputContext_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumInputContext_Next(This,ulCount,rgInputContext,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,ulCount,rgInputContext,pcFetched) ) 

#define IEnumInputContext_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumInputContext_Skip(This,ulCount)	\
    ( (This)->lpVtbl -> Skip(This,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumInputContext_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMRegistrar_INTERFACE_DEFINED__
#define __IActiveIMMRegistrar_INTERFACE_DEFINED__

/* interface IActiveIMMRegistrar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3458082-bd00-11d1-939b-0060b067b86e")
    IActiveIMMRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterIME( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ __RPC__in LPCWSTR pszIconFile,
            /* [in] */ __RPC__in LPCWSTR pszDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterIME( 
            /* [in] */ __RPC__in REFCLSID rclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMRegistrar * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterIME )( 
            IActiveIMMRegistrar * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ __RPC__in LPCWSTR pszIconFile,
            /* [in] */ __RPC__in LPCWSTR pszDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterIME )( 
            IActiveIMMRegistrar * This,
            /* [in] */ __RPC__in REFCLSID rclsid);
        
        END_INTERFACE
    } IActiveIMMRegistrarVtbl;

    interface IActiveIMMRegistrar
    {
        CONST_VTBL struct IActiveIMMRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMRegistrar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIMMRegistrar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIMMRegistrar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIMMRegistrar_RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)	\
    ( (This)->lpVtbl -> RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc) ) 

#define IActiveIMMRegistrar_UnregisterIME(This,rclsid)	\
    ( (This)->lpVtbl -> UnregisterIME(This,rclsid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIMMRegistrar_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/* interface IActiveIMMMessagePumpOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ __RPC__in const MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMMessagePumpOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ __RPC__in const MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveIMMMessagePumpOwner * This,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIMMMessagePumpOwner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIMMMessagePumpOwner_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IActiveIMMMessagePumpOwner_End(This)	\
    ( (This)->lpVtbl -> End(This) ) 

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    ( (This)->lpVtbl -> OnTranslateMessage(This,pMsg) ) 

#define IActiveIMMMessagePumpOwner_Pause(This,pdwCookie)	\
    ( (This)->lpVtbl -> Pause(This,pdwCookie) ) 

#define IActiveIMMMessagePumpOwner_Resume(This,dwCookie)	\
    ( (This)->lpVtbl -> Resume(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/* interface IActiveIMMApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ __RPC__out HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ __RPC__out HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIM