_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UniqueName )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ __RPC__in BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ __RPC__in BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CLSID )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *SpaceCLSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkType )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *NetworkTypeGuid);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NetworkType )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ __RPC__in BSTR NetworkTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NetworkType )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out GUID *NetworkTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__NetworkType )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ __RPC__in REFCLSID NetworkTypeGuid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTuneRequest )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **TuneRequest);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumCategoryGUIDs )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumGUID **ppEnum);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceMonikers )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumMoniker **ppEnum);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPreferredComponentTypes )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **ComponentTypes);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPreferredComponentTypes )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ __RPC__in_opt IComponentTypes *NewComponentTypes);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FrequencyMapping )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pMapping);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FrequencyMapping )( 
            IDigitalCableTuningSpace * This,
            __RPC__in BSTR Mapping);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultLocator )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **LocatorVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultLocator )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ __RPC__in_opt ILocator *LocatorVal);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **NewTS);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinChannel )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MinChannelVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinChannel )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMinChannelVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxChannel )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MaxChannelVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxChannel )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMaxChannelVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InputType )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out TunerInputType *InputTypeVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InputType )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ TunerInputType NewInputTypeVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *CountryCodeVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewCountryCodeVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinMinorChannel )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MinMinorChannelVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinMinorChannel )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMinMinorChannelVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxMinorChannel )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MaxMinorChannelVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxMinorChannel )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMaxMinorChannelVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinPhysicalChannel )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MinPhysicalChannelVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinPhysicalChannel )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMinPhysicalChannelVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxPhysicalChannel )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MaxPhysicalChannelVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxPhysicalChannel )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMaxPhysicalChannelVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinMajorChannel )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MinMajorChannelVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinMajorChannel )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMinMajorChannelVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxMajorChannel )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MaxMajorChannelVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxMajorChannel )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMaxMajorChannelVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinSourceID )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MinSourceIDVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinSourceID )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMinSourceIDVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxSourceID )( 
            IDigitalCableTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MaxSourceIDVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxSourceID )( 
            IDigitalCableTuningSpace * This,
            /* [in] */ long NewMaxSourceIDVal);
        
        END_INTERFACE
    } IDigitalCableTuningSpaceVtbl;

    interface IDigitalCableTuningSpace
    {
        CONST_VTBL struct IDigitalCableTuningSpaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDigitalCableTuningSpace_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDigitalCableTuningSpace_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDigitalCableTuningSpace_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDigitalCableTuningSpace_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDigitalCableTuningSpace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDigitalCableTuningSpace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDigitalCableTuningSpace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDigitalCableTuningSpace_get_UniqueName(This,Name)	\
    ( (This)->lpVtbl -> get_UniqueName(This,Name) ) 

#define IDigitalCableTuningSpace_put_UniqueName(This,Name)	\
    ( (This)->lpVtbl -> put_UniqueName(This,Name) ) 

#define IDigitalCableTuningSpace_get_FriendlyName(This,Name)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,Name) ) 

#define IDigitalCableTuningSpace_put_FriendlyName(This,Name)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,Name) ) 

#define IDigitalCableTuningSpace_get_CLSID(This,SpaceCLSID)	\
    ( (This)->lpVtbl -> get_CLSID(This,SpaceCLSID) ) 

#define IDigitalCableTuningSpace_get_NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> get_NetworkType(This,NetworkTypeGuid) ) 

#define IDigitalCableTuningSpace_put_NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> put_NetworkType(This,NetworkTypeGuid) ) 

#define IDigitalCableTuningSpace_get__NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> get__NetworkType(This,NetworkTypeGuid) ) 

#define IDigitalCableTuningSpace_put__NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> put__NetworkType(This,NetworkTypeGuid) ) 

#define IDigitalCableTuningSpace_CreateTuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> CreateTuneRequest(This,TuneRequest) ) 

#define IDigitalCableTuningSpace_EnumCategoryGUIDs(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumCategoryGUIDs(This,ppEnum) ) 

#define IDigitalCableTuningSpace_EnumDeviceMonikers(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumDeviceMonikers(This,ppEnum) ) 

#define IDigitalCableTuningSpace_get_DefaultPreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> get_DefaultPreferredComponentTypes(This,ComponentTypes) ) 

#define IDigitalCableTuningSpace_put_DefaultPreferredComponentTypes(This,NewComponentTypes)	\
    ( (This)->lpVtbl -> put_DefaultPreferredComponentTypes(This,NewComponentTypes) ) 

#define IDigitalCableTuningSpace_get_FrequencyMapping(This,pMapping)	\
    ( (This)->lpVtbl -> get_FrequencyMapping(This,pMapping) ) 

#define IDigitalCableTuningSpace_put_FrequencyMapping(This,Mapping)	\
    ( (This)->lpVtbl -> put_FrequencyMapping(This,Mapping) ) 

#define IDigitalCableTuningSpace_get_DefaultLocator(This,LocatorVal)	\
    ( (This)->lpVtbl -> get_DefaultLocator(This,LocatorVal) ) 

#define IDigitalCableTuningSpace_put_DefaultLocator(This,LocatorVal)	\
    ( (This)->lpVtbl -> put_DefaultLocator(This,LocatorVal) ) 

#define IDigitalCableTuningSpace_Clone(This,NewTS)	\
    ( (This)->lpVtbl -> Clone(This,NewTS) ) 


#define IDigitalCableTuningSpace_get_MinChannel(This,MinChannelVal)	\
    ( (This)->lpVtbl -> get_MinChannel(This,MinChannelVal) ) 

#define IDigitalCableTuningSpace_put_MinChannel(This,NewMinChannelVal)	\
    ( (This)->lpVtbl -> put_MinChannel(This,NewMinChannelVal) ) 

#define IDigitalCableTuningSpace_get_MaxChannel(This,MaxChannelVal)	\
    ( (This)->lpVtbl -> get_MaxChannel(This,MaxChannelVal) ) 

#define IDigitalCableTuningSpace_put_MaxChannel(This,NewMaxChannelVal)	\
    ( (This)->lpVtbl -> put_MaxChannel(This,NewMaxChannelVal) ) 

#define IDigitalCableTuningSpace_get_InputType(This,InputTypeVal)	\
    ( (This)->lpVtbl -> get_InputType(This,InputTypeVal) ) 

#define IDigitalCableTuningSpace_put_InputType(This,NewInputTypeVal)	\
    ( (This)->lpVtbl -> put_InputType(This,NewInputTypeVal) ) 

#define IDigitalCableTuningSpace_get_CountryCode(This,CountryCodeVal)	\
    ( (This)->lpVtbl -> get_CountryCode(This,CountryCodeVal) ) 

#define IDigitalCableTuningSpace_put_CountryCode(This,NewCountryCodeVal)	\
    ( (This)->lpVtbl -> put_CountryCode(This,NewCountryCodeVal) ) 


#define IDigitalCableTuningSpace_get_MinMinorChannel(This,MinMinorChannelVal)	\
    ( (This)->lpVtbl -> get_MinMinorChannel(This,MinMinorChannelVal) ) 

#define IDigitalCableTuningSpace_put_MinMinorChannel(This,NewMinMinorChannelVal)	\
    ( (This)->lpVtbl -> put_MinMinorChannel(This,NewMinMinorChannelVal) ) 

#define IDigitalCableTuningSpace_get_MaxMinorChannel(This,MaxMinorChannelVal)	\
    ( (This)->lpVtbl -> get_MaxMinorChannel(This,MaxMinorChannelVal) ) 

#define IDigitalCableTuningSpace_put_MaxMinorChannel(This,NewMaxMinorChannelVal)	\
    ( (This)->lpVtbl -> put_MaxMinorChannel(This,NewMaxMinorChannelVal) ) 

#define IDigitalCableTuningSpace_get_MinPhysicalChannel(This,MinPhysicalChannelVal)	\
    ( (This)->lpVtbl -> get_MinPhysicalChannel(This,MinPhysicalChannelVal) ) 

#define IDigitalCableTuningSpace_put_MinPhysicalChannel(This,NewMinPhysicalChannelVal)	\
    ( (This)->lpVtbl -> put_MinPhysicalChannel(This,NewMinPhysicalChannelVal) ) 

#define IDigitalCableTuningSpace_get_MaxPhysicalChannel(This,MaxPhysicalChannelVal)	\
    ( (This)->lpVtbl -> get_MaxPhysicalChannel(This,MaxPhysicalChannelVal) ) 

#define IDigitalCableTuningSpace_put_MaxPhysicalChannel(This,NewMaxPhysicalChannelVal)	\
    ( (This)->lpVtbl -> put_MaxPhysicalChannel(This,NewMaxPhysicalChannelVal) ) 


#define IDigitalCableTuningSpace_get_MinMajorChannel(This,MinMajorChannelVal)	\
    ( (This)->lpVtbl -> get_MinMajorChannel(This,MinMajorChannelVal) ) 

#define IDigitalCableTuningSpace_put_MinMajorChannel(This,NewMinMajorChannelVal)	\
    ( (This)->lpVtbl -> put_MinMajorChannel(This,NewMinMajorChannelVal) ) 

#define IDigitalCableTuningSpace_get_MaxMajorChannel(This,MaxMajorChannelVal)	\
    ( (This)->lpVtbl -> get_MaxMajorChannel(This,MaxMajorChannelVal) ) 

#define IDigitalCableTuningSpace_put_MaxMajorChannel(This,NewMaxMajorChannelVal)	\
    ( (This)->lpVtbl -> put_MaxMajorChannel(This,NewMaxMajorChannelVal) ) 

#define IDigitalCableTuningSpace_get_MinSourceID(This,MinSourceIDVal)	\
    ( (This)->lpVtbl -> get_MinSourceID(This,MinSourceIDVal) ) 

#define IDigitalCableTuningSpace_put_MinSourceID(This,NewMinSourceIDVal)	\
    ( (This)->lpVtbl -> put_MinSourceID(This,NewMinSourceIDVal) ) 

#define IDigitalCableTuningSpace_get_MaxSourceID(This,MaxSourceIDVal)	\
    ( (This)->lpVtbl -> get_MaxSourceID(This,MaxSourceIDVal) ) 

#define IDigitalCableTuningSpace_put_MaxSourceID(This,NewMaxSourceIDVal)	\
    ( (This)->lpVtbl -> put_MaxSourceID(This,NewMaxSourceIDVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDigitalCableTuningSpace_INTERFACE_DEFINED__ */


#ifndef __IAnalogRadioTuningSpace_INTERFACE_DEFINED__
#define __IAnalogRadioTuningSpace_INTERFACE_DEFINED__

/* interface IAnalogRadioTuningSpace */
/* [unique][uuid][nonextensible][oleautomation][dual][hidden][object] */ 


EXTERN_C const IID IID_IAnalogRadioTuningSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A6E293B-2595-11d3-B64C-00C04F79498E")
    IAnalogRadioTuningSpace : public ITuningSpace
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinFrequency( 
            /* [retval][out] */ __RPC__out long *MinFrequencyVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MinFrequency( 
            /* [in] */ long NewMinFrequencyVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxFrequency( 
            /* [retval][out] */ __RPC__out long *MaxFrequencyVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxFrequency( 
            /* [in] */ long NewMaxFrequencyVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Step( 
            /* [retval][out] */ __RPC__out long *StepVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Step( 
            /* [in] */ long NewStepVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalogRadioTuningSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalogRadioTuningSpace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalogRadioTuningSpace * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAnalogRadioTuningSpace * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UniqueName )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ __RPC__in BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ __RPC__in BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CLSID )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *SpaceCLSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkType )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *NetworkTypeGuid);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NetworkType )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ __RPC__in BSTR NetworkTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NetworkType )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__out GUID *NetworkTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__NetworkType )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ __RPC__in REFCLSID NetworkTypeGuid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTuneRequest )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **TuneRequest);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumCategoryGUIDs )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumGUID **ppEnum);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceMonikers )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumMoniker **ppEnum);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPreferredComponentTypes )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **ComponentTypes);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPreferredComponentTypes )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ __RPC__in_opt IComponentTypes *NewComponentTypes);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FrequencyMapping )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pMapping);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FrequencyMapping )( 
            IAnalogRadioTuningSpace * This,
            __RPC__in BSTR Mapping);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultLocator )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **LocatorVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultLocator )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ __RPC__in_opt ILocator *LocatorVal);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **NewTS);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinFrequency )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MinFrequencyVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinFrequency )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ long NewMinFrequencyVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxFrequency )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__out long *MaxFrequencyVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxFrequency )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ long NewMaxFrequencyVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Step )( 
            IAnalogRadioTuningSpace * This,
            /* [retval][out] */ __RPC__out long *StepVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Step )( 
            IAnalogRadioTuningSpace * This,
            /* [in] */ long NewStepVal);
        
        END_INTERFACE
    } IAnalogRadioTuningSpaceVtbl;

    interface IAnalogRadioTuningSpace
    {
        CONST_VTBL struct IAnalogRadioTuningSpaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalogRadioTuningSpace_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAnalogRadioTuningSpace_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAnalogRadioTuningSpace_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAnalogRadioTuningSpace_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAnalogRadioTuningSpace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAnalogRadioTuningSpace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAnalogRadioTuningSpace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAnalogRadioTuningSpace_get_UniqueName(This,Name)	\
    ( (This)->lpVtbl -> get_UniqueName(This,Name) ) 

#define IAnalogRadioTuningSpace_put_UniqueName(This,Name)	\
    ( (This)->lpVtbl -> put_UniqueName(This,Name) ) 

#define IAnalogRadioTuningSpace_get_FriendlyName(This,Name)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,Name) ) 

#define IAnalogRadioTuningSpace_put_FriendlyName(This,Name)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,Name) ) 

#define IAnalogRadioTuningSpace_get_CLSID(This,SpaceCLSID)	\
    ( (This)->lpVtbl -> get_CLSID(This,SpaceCLSID) ) 

#define IAnalogRadioTuningSpace_get_NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> get_NetworkType(This,NetworkTypeGuid) ) 

#define IAnalogRadioTuningSpace_put_NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> put_NetworkType(This,NetworkTypeGuid) ) 

#define IAnalogRadioTuningSpace_get__NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> get__NetworkType(This,NetworkTypeGuid) ) 

#define IAnalogRadioTuningSpace_put__NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> put__NetworkType(This,NetworkTypeGuid) ) 

#define IAnalogRadioTuningSpace_CreateTuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> CreateTuneRequest(This,TuneRequest) ) 

#define IAnalogRadioTuningSpace_EnumCategoryGUIDs(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumCategoryGUIDs(This,ppEnum) ) 

#define IAnalogRadioTuningSpace_EnumDeviceMonikers(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumDeviceMonikers(This,ppEnum) ) 

#define IAnalogRadioTuningSpace_get_DefaultPreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> get_DefaultPreferredComponentTypes(This,ComponentTypes) ) 

#define IAnalogRadioTuningSpace_put_DefaultPreferredComponentTypes(This,NewComponentTypes)	\
    ( (This)->lpVtbl -> put_DefaultPreferredComponentTypes(This,NewComponentTypes) ) 

#define IAnalogRadioTuningSpace_get_FrequencyMapping(This,pMapping)	\
    ( (This)->lpVtbl -> get_FrequencyMapping(This,pMapping) ) 

#define IAnalogRadioTuningSpace_put_FrequencyMapping(This,Mapping)	\
    ( (This)->lpVtbl -> put_FrequencyMapping(This,Mapping) ) 

#define IAnalogRadioTuningSpace_get_DefaultLocator(This,LocatorVal)	\
    ( (This)->lpVtbl -> get_DefaultLocator(This,LocatorVal) ) 

#define IAnalogRadioTuningSpace_put_DefaultLocator(This,LocatorVal)	\
    ( (This)->lpVtbl -> put_DefaultLocator(This,LocatorVal) ) 

#define IAnalogRadioTuningSpace_Clone(This,NewTS)	\
    ( (This)->lpVtbl -> Clone(This,NewTS) ) 


#define IAnalogRadioTuningSpace_get_MinFrequency(This,MinFrequencyVal)	\
    ( (This)->lpVtbl -> get_MinFrequency(This,MinFrequencyVal) ) 

#define IAnalogRadioTuningSpace_put_MinFrequency(This,NewMinFrequencyVal)	\
    ( (This)->lpVtbl -> put_MinFrequency(This,NewMinFrequencyVal) ) 

#define IAnalogRadioTuningSpace_get_MaxFrequency(This,MaxFrequencyVal)	\
    ( (This)->lpVtbl -> get_MaxFrequency(This,MaxFrequencyVal) ) 

#define IAnalogRadioTuningSpace_put_MaxFrequency(This,NewMaxFrequencyVal)	\
    ( (This)->lpVtbl -> put_MaxFrequency(This,NewMaxFrequencyVal) ) 

#define IAnalogRadioTuningSpace_get_Step(This,StepVal)	\
    ( (This)->lpVtbl -> get_Step(This,StepVal) ) 

#define IAnalogRadioTuningSpace_put_Step(This,NewStepVal)	\
    ( (This)->lpVtbl -> put_Step(This,NewStepVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAnalogRadioTuningSpace_INTERFACE_DEFINED__ */


#ifndef __IAnalogRadioTuningSpace2_INTERFACE_DEFINED__
#define __IAnalogRadioTuningSpace2_INTERFACE_DEFINED__

/* interface IAnalogRadioTuningSpace2 */
/* [unique][uuid][nonextensible][oleautomation][dual][hidden][object] */ 


EXTERN_C const IID IID_IAnalogRadioTuningSpace2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39DD45DA-2DA8-46BA-8A8A-87E2B73D983A")
    IAnalogRadioTuningSpace2 : public IAnalogRadioTuningSpace
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [retval][out] */ __RPC__out long *CountryCodeVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CountryCode( 
            /* [in] */ long NewCountryCodeVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalogRadioTuningSpace2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalogRadioTuningSpace2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalogRadioTuningSpace2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAnalogRadioTuningSpace2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UniqueName )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ __RPC__in BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ __RPC__in BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CLSID )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *SpaceCLSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkType )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *NetworkTypeGuid);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NetworkType )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ __RPC__in BSTR NetworkTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NetworkType )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__out GUID *NetworkTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__NetworkType )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ __RPC__in REFCLSID NetworkTypeGuid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTuneRequest )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **TuneRequest);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumCategoryGUIDs )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumGUID **ppEnum);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceMonikers )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumMoniker **ppEnum);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPreferredComponentTypes )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **ComponentTypes);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPreferredComponentTypes )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ __RPC__in_opt IComponentTypes *NewComponentTypes);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FrequencyMapping )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pMapping);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FrequencyMapping )( 
            IAnalogRadioTuningSpace2 * This,
            __RPC__in BSTR Mapping);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultLocator )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **LocatorVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultLocator )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ __RPC__in_opt ILocator *LocatorVal);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **NewTS);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinFrequency )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__out long *MinFrequencyVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinFrequency )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ long NewMinFrequencyVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxFrequency )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__out long *MaxFrequencyVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxFrequency )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ long NewMaxFrequencyVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Step )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__out long *StepVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Step )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ long NewStepVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IAnalogRadioTuningSpace2 * This,
            /* [retval][out] */ __RPC__out long *CountryCodeVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IAnalogRadioTuningSpace2 * This,
            /* [in] */ long NewCountryCodeVal);
        
        END_INTERFACE
    } IAnalogRadioTuningSpace2Vtbl;

    interface IAnalogRadioTuningSpace2
    {
        CONST_VTBL struct IAnalogRadioTuningSpace2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalogRadioTuningSpace2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAnalogRadioTuningSpace2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAnalogRadioTuningSpace2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAnalogRadioTuningSpace2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAnalogRadioTuningSpace2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAnalogRadioTuningSpace2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAnalogRadioTuningSpace2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAnalogRadioTuningSpace2_get_UniqueName(This,Name)	\
    ( (This)->lpVtbl -> get_UniqueName(This,Name) ) 

#define IAnalogRadioTuningSpace2_put_UniqueName(This,Name)	\
    ( (This)->lpVtbl -> put_UniqueName(This,Name) ) 

#define IAnalogRadioTuningSpace2_get_FriendlyName(This,Name)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,Name) ) 

#define IAnalogRadioTuningSpace2_put_FriendlyName(This,Name)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,Name) ) 

#define IAnalogRadioTuningSpace2_get_CLSID(This,SpaceCLSID)	\
    ( (This)->lpVtbl -> get_CLSID(This,SpaceCLSID) ) 

#define IAnalogRadioTuningSpace2_get_NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> get_NetworkType(This,NetworkTypeGuid) ) 

#define IAnalogRadioTuningSpace2_put_NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> put_NetworkType(This,NetworkTypeGuid) ) 

#define IAnalogRadioTuningSpace2_get__NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> get__NetworkType(This,NetworkTypeGuid) ) 

#define IAnalogRadioTuningSpace2_put__NetworkType(This,NetworkTypeGuid)	\
    ( (This)->lpVtbl -> put__NetworkType(This,NetworkTypeGuid) ) 

#define IAnalogRadioTuningSpace2_CreateTuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> CreateTuneRequest(This,TuneRequest) ) 

#define IAnalogRadioTuningSpace2_EnumCategoryGUIDs(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumCategoryGUIDs(This,ppEnum) ) 

#define IAnalogRadioTuningSpace2_EnumDeviceMonikers(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumDeviceMonikers(This,ppEnum) ) 

#define IAnalogRadioTuningSpace2_get_DefaultPreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> get_DefaultPreferredComponentTypes(This,ComponentTypes) ) 

#define IAnalogRadioTuningSpace2_put_DefaultPreferredComponentTypes(This,NewComponentTypes)	\
    ( (This)->lpVtbl -> put_DefaultPreferredComponentTypes(This,NewComponentTypes) ) 

#define IAnalogRadioTuningSpace2_get_FrequencyMapping(This,pMapping)	\
    ( (This)->lpVtbl -> get_FrequencyMapping(This,pMapping) ) 

#define IAnalogRadioTuningSpace2_put_FrequencyMapping(This,Mapping)	\
    ( (This)->lpVtbl -> put_FrequencyMapping(This,Mapping) ) 

#define IAnalogRadioTuningSpace2_get_DefaultLocator(This,LocatorVal)	\
    ( (This)->lpVtbl -> get_DefaultLocator(This,LocatorVal) ) 

#define IAnalogRadioTuningSpace2_put_DefaultLocator(This,LocatorVal)	\
    ( (This)->lpVtbl -> put_DefaultLocator(This,LocatorVal) ) 

#define IAnalogRadioTuningSpace2_Clone(This,NewTS)	\
    ( (This)->lpVtbl -> Clone(This,NewTS) ) 


#define IAnalogRadioTuningSpace2_get_MinFrequency(This,MinFrequencyVal)	\
    ( (This)->lpVtbl -> get_MinFrequency(This,MinFrequencyVal) ) 

#define IAnalogRadioTuningSpace2_put_MinFrequency(This,NewMinFrequencyVal)	\
    ( (This)->lpVtbl -> put_MinFrequency(This,NewMinFrequencyVal) ) 

#define IAnalogRadioTuningSpace2_get_MaxFrequency(This,MaxFrequencyVal)	\
    ( (This)->lpVtbl -> get_MaxFrequency(This,MaxFrequencyVal) ) 

#define IAnalogRadioTuningSpace2_put_MaxFrequency(This,NewMaxFrequencyVal)	\
    ( (This)->lpVtbl -> put_MaxFrequency(This,NewMaxFrequencyVal) ) 

#define IAnalogRadioTuningSpace2_get_Step(This,StepVal)	\
    ( (This)->lpVtbl -> get_Step(This,StepVal) ) 

#define IAnalogRadioTuningSpace2_put_Step(This,NewStepVal)	\
    ( (This)->lpVtbl -> put_Step(This,NewStepVal) ) 


#define IAnalogRadioTuningSpace2_get_CountryCode(This,CountryCodeVal)	\
    ( (This)->lpVtbl -> get_CountryCode(This,CountryCodeVal) ) 

#define IAnalogRadioTuningSpace2_put_CountryCode(This,NewCountryCodeVal)	\
    ( (This)->lpVtbl -> put_CountryCode(This,NewCountryCodeVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAnalogRadioTuningSpace2_INTERFACE_DEFINED__ */


#ifndef __ITuneRequest_INTERFACE_DEFINED__
#define __ITuneRequest_INTERFACE_DEFINED__

/* interface ITuneRequest */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_ITuneRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07DDC146-FC3D-11d2-9D8C-00C04F72D980")
    ITuneRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TuningSpace( 
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Components( 
            /* [retval][out] */ __RPC__deref_out_opt IComponents **Components) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **NewTuneRequest) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Locator( 
            /* [retval][out] */ __RPC__deref_out_opt ILocator **Locator) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Locator( 
            /* [in] */ __RPC__in_opt ILocator *Locator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITuneRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITuneRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITuneRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITuneRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITuneRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITuneRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            ITuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Components )( 
            ITuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponents **Components);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **NewTuneRequest);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locator )( 
            ITuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **Locator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locator )( 
            ITuneRequest * This,
            /* [in] */ __RPC__in_opt ILocator *Locator);
        
        END_INTERFACE
    } ITuneRequestVtbl;

    interface ITuneRequest
    {
        CONST_VTBL struct ITuneRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITuneRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITuneRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITuneRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITuneRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITuneRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITuneRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITuneRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITuneRequest_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define ITuneRequest_get_Components(This,Components)	\
    ( (This)->lpVtbl -> get_Components(This,Components) ) 

#define ITuneRequest_Clone(This,NewTuneRequest)	\
    ( (This)->lpVtbl -> Clone(This,NewTuneRequest) ) 

#define ITuneRequest_get_Locator(This,Locator)	\
    ( (This)->lpVtbl -> get_Locator(This,Locator) ) 

#define ITuneRequest_put_Locator(This,Locator)	\
    ( (This)->lpVtbl -> put_Locator(This,Locator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITuneRequest_INTERFACE_DEFINED__ */


#ifndef __IChannelTuneRequest_INTERFACE_DEFINED__
#define __IChannelTuneRequest_INTERFACE_DEFINED__

/* interface IChannelTuneRequest */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IChannelTuneRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0369B4E0-45B6-11d3-B650-00C04F79498E")
    IChannelTuneRequest : public ITuneRequest
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Channel( 
            /* [retval][out] */ __RPC__out long *Channel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Channel( 
            /* [in] */ long Channel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IChannelTuneRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IChannelTuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IChannelTuneRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IChannelTuneRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IChannelTuneRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IChannelTuneRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IChannelTuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IChannelTuneRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IChannelTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Components )( 
            IChannelTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponents **Components);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IChannelTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **NewTuneRequest);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locator )( 
            IChannelTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **Locator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locator )( 
            IChannelTuneRequest * This,
            /* [in] */ __RPC__in_opt ILocator *Locator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IChannelTuneRequest * This,
            /* [retval][out] */ __RPC__out long *Channel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IChannelTuneRequest * This,
            /* [in] */ long Channel);
        
        END_INTERFACE
    } IChannelTuneRequestVtbl;

    interface IChannelTuneRequest
    {
        CONST_VTBL struct IChannelTuneRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IChannelTuneRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IChannelTuneRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IChannelTuneRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IChannelTuneRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IChannelTuneRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IChannelTuneRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IChannelTuneRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IChannelTuneRequest_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define IChannelTuneRequest_get_Components(This,Components)	\
    ( (This)->lpVtbl -> get_Components(This,Components) ) 

#define IChannelTuneRequest_Clone(This,NewTuneRequest)	\
    ( (This)->lpVtbl -> Clone(This,NewTuneRequest) ) 

#define IChannelTuneRequest_get_Locator(This,Locator)	\
    ( (This)->lpVtbl -> get_Locator(This,Locator) ) 

#define IChannelTuneRequest_put_Locator(This,Locator)	\
    ( (This)->lpVtbl -> put_Locator(This,Locator) ) 


#define IChannelTuneRequest_get_Channel(This,Channel)	\
    ( (This)->lpVtbl -> get_Channel(This,Channel) ) 

#define IChannelTuneRequest_put_Channel(This,Channel)	\
    ( (This)->lpVtbl -> put_Channel(This,Channel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IChannelTuneRequest_INTERFACE_DEFINED__ */


#ifndef __IATSCChannelTuneRequest_INTERFACE_DEFINED__
#define __IATSCChannelTuneRequest_INTERFACE_DEFINED__

/* interface IATSCChannelTuneRequest */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IATSCChannelTuneRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0369B4E1-45B6-11d3-B650-00C04F79498E")
    IATSCChannelTuneRequest : public IChannelTuneRequest
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorChannel( 
            /* [retval][out] */ __RPC__out long *MinorChannel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MinorChannel( 
            /* [in] */ long MinorChannel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IATSCChannelTuneRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IATSCChannelTuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IATSCChannelTuneRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IATSCChannelTuneRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IATSCChannelTuneRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IATSCChannelTuneRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IATSCChannelTuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IATSCChannelTuneRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IATSCChannelTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Components )( 
            IATSCChannelTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponents **Components);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IATSCChannelTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **NewTuneRequest);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locator )( 
            IATSCChannelTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **Locator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locator )( 
            IATSCChannelTuneRequest * This,
            /* [in] */ __RPC__in_opt ILocator *Locator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IATSCChannelTuneRequest * This,
            /* [retval][out] */ __RPC__out long *Channel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IATSCChannelTuneRequest * This,
            /* [in] */ long Channel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorChannel )( 
            IATSCChannelTuneRequest * This,
            /* [retval][out] */ __RPC__out long *MinorChannel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinorChannel )( 
            IATSCChannelTuneRequest * This,
            /* [in] */ long MinorChannel);
        
        END_INTERFACE
    } IATSCChannelTuneRequestVtbl;

    interface IATSCChannelTuneRequest
    {
        CONST_VTBL struct IATSCChannelTuneRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IATSCChannelTuneRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IATSCChannelTuneRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IATSCChannelTuneRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IATSCChannelTuneRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IATSCChannelTuneRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IATSCChannelTuneRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IATSCChannelTuneRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IATSCChannelTuneRequest_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define IATSCChannelTuneRequest_get_Components(This,Components)	\
    ( (This)->lpVtbl -> get_Components(This,Components) ) 

#define IATSCChannelTuneRequest_Clone(This,NewTuneRequest)	\
    ( (This)->lpVtbl -> Clone(This,NewTuneRequest) ) 

#define IATSCChannelTuneRequest_get_Locator(This,Locator)	\
    ( (This)->lpVtbl -> get_Locator(This,Locator) ) 

#define IATSCChannelTuneRequest_put_Locator(This,Locator)	\
    ( (This)->lpVtbl -> put_Locator(This,Locator) ) 


#define IATSCChannelTuneRequest_get_Channel(This,Channel)	\
    ( (This)->lpVtbl -> get_Channel(This,Channel) ) 

#define IATSCChannelTuneRequest_put_Channel(This,Channel)	\
    ( (This)->lpVtbl -> put_Channel(This,Channel) ) 


#define IATSCChannelTuneRequest_get_MinorChannel(This,MinorChannel)	\
    ( (This)->lpVtbl -> get_MinorChannel(This,MinorChannel) ) 

#define IATSCChannelTuneRequest_put_MinorChannel(This,MinorChannel)	\
    ( (This)->lpVtbl -> put_MinorChannel(This,MinorChannel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IATSCChannelTuneRequest_INTERFACE_DEFINED__ */


#ifndef __IDigitalCableTuneRequest_INTERFACE_DEFINED__
#define __IDigitalCableTuneRequest_INTERFACE_DEFINED__

/* interface IDigitalCableTuneRequest */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IDigitalCableTuneRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BAD7753B-6B37-4810-AE57-3CE0C4A9E6CB")
    IDigitalCableTuneRequest : public IATSCChannelTuneRequest
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorChannel( 
            /* [retval][out] */ __RPC__out long *pMajorChannel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MajorChannel( 
            /* [in] */ long MajorChannel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SourceID( 
            /* [retval][out] */ __RPC__out long *pSourceID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SourceID( 
            /* [in] */ long SourceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDigitalCableTuneRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDigitalCableTuneRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDigitalCableTuneRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDigitalCableTuneRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IDigitalCableTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Components )( 
            IDigitalCableTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponents **Components);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDigitalCableTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **NewTuneRequest);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locator )( 
            IDigitalCableTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **Locator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locator )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ __RPC__in_opt ILocator *Locator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IDigitalCableTuneRequest * This,
            /* [retval][out] */ __RPC__out long *Channel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ long Channel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorChannel )( 
            IDigitalCableTuneRequest * This,
            /* [retval][out] */ __RPC__out long *MinorChannel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinorChannel )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ long MinorChannel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorChannel )( 
            IDigitalCableTuneRequest * This,
            /* [retval][out] */ __RPC__out long *pMajorChannel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MajorChannel )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ long MajorChannel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceID )( 
            IDigitalCableTuneRequest * This,
            /* [retval][out] */ __RPC__out long *pSourceID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceID )( 
            IDigitalCableTuneRequest * This,
            /* [in] */ long SourceID);
        
        END_INTERFACE
    } IDigitalCableTuneRequestVtbl;

    interface IDigitalCableTuneRequest
    {
        CONST_VTBL struct IDigitalCableTuneRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDigitalCableTuneRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDigitalCableTuneRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDigitalCableTuneRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDigitalCableTuneRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDigitalCableTuneRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDigitalCableTuneRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDigitalCableTuneRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDigitalCableTuneRequest_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define IDigitalCableTuneRequest_get_Components(This,Components)	\
    ( (This)->lpVtbl -> get_Components(This,Components) ) 

#define IDigitalCableTuneRequest_Clone(This,NewTuneRequest)	\
    ( (This)->lpVtbl -> Clone(This,NewTuneRequest) ) 

#define IDigitalCableTuneRequest_get_Locator(This,Locator)	\
    ( (This)->lpVtbl -> get_Locator(This,Locator) ) 

#define IDigitalCableTuneRequest_put_Locator(This,Locator)	\
    ( (This)->lpVtbl -> put_Locator(This,Locator) ) 


#define IDigitalCableTuneRequest_get_Channel(This,Channel)	\
    ( (This)->lpVtbl -> get_Channel(This,Channel) ) 

#define IDigitalCableTuneRequest_put_Channel(This,Channel)	\
    ( (This)->lpVtbl -> put_Channel(This,Channel) ) 


#define IDigitalCableTuneRequest_get_MinorChannel(This,MinorChannel)	\
    ( (This)->lpVtbl -> get_MinorChannel(This,MinorChannel) ) 

#define IDigitalCableTuneRequest_put_MinorChannel(This,MinorChannel)	\
    ( (This)->lpVtbl -> put_MinorChannel(This,MinorChannel) ) 


#define IDigitalCableTuneRequest_get_MajorChannel(This,pMajorChannel)	\
    ( (This)->lpVtbl -> get_MajorChannel(This,pMajorChannel) ) 

#define IDigitalCableTuneRequest_put_MajorChannel(This,MajorChannel)	\
    ( (This)->lpVtbl -> put_MajorChannel(This,MajorChannel) ) 

#define IDigitalCableTuneRequest_get_SourceID(This,pSourceID)	\
    ( (This)->lpVtbl -> get_SourceID(This,pSourceID) ) 

#define IDigitalCableTuneRequest_put_SourceID(This,SourceID)	\
    ( (This)->lpVtbl -> put_SourceID(This,SourceID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDigitalCableTuneRequest_INTERFACE_DEFINED__ */


#ifndef __IDVBTuneRequest_INTERFACE_DEFINED__
#define __IDVBTuneRequest_INTERFACE_DEFINED__

/* interface IDVBTuneRequest */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IDVBTuneRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0D6F567E-A636-42bb-83BA-CE4C1704AFA2")
    IDVBTuneRequest : public ITuneRequest
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ONID( 
            /* [retval][out] */ __RPC__out long *ONID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ONID( 
            /* [in] */ long ONID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ __RPC__out long *TSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TSID( 
            /* [in] */ long TSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SID( 
            /* [retval][out] */ __RPC__out long *SID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SID( 
            /* [in] */ long SID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVBTuneRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVBTuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVBTuneRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVBTuneRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDVBTuneRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDVBTuneRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDVBTuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDVBTuneRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IDVBTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Components )( 
            IDVBTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponents **Components);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDVBTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **NewTuneRequest);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locator )( 
            IDVBTuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **Locator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locator )( 
            IDVBTuneRequest * This,
            /* [in] */ __RPC__in_opt ILocator *Locator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ONID )( 
            IDVBTuneRequest * This,
            /* [retval][out] */ __RPC__out long *ONID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ONID )( 
            IDVBTuneRequest * This,
            /* [in] */ long ONID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IDVBTuneRequest * This,
            /* [retval][out] */ __RPC__out long *TSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IDVBTuneRequest * This,
            /* [in] */ long TSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SID )( 
            IDVBTuneRequest * This,
            /* [retval][out] */ __RPC__out long *SID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SID )( 
            IDVBTuneRequest * This,
            /* [in] */ long SID);
        
        END_INTERFACE
    } IDVBTuneRequestVtbl;

    interface IDVBTuneRequest
    {
        CONST_VTBL struct IDVBTuneRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVBTuneRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVBTuneRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVBTuneRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVBTuneRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDVBTuneRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDVBTuneRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDVBTuneRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDVBTuneRequest_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define IDVBTuneRequest_get_Components(This,Components)	\
    ( (This)->lpVtbl -> get_Components(This,Components) ) 

#define IDVBTuneRequest_Clone(This,NewTuneRequest)	\
    ( (This)->lpVtbl -> Clone(This,NewTuneRequest) ) 

#define IDVBTuneRequest_get_Locator(This,Locator)	\
    ( (This)->lpVtbl -> get_Locator(This,Locator) ) 

#define IDVBTuneRequest_put_Locator(This,Locator)	\
    ( (This)->lpVtbl -> put_Locator(This,Locator) ) 


#define IDVBTuneRequest_get_ONID(This,ONID)	\
    ( (This)->lpVtbl -> get_ONID(This,ONID) ) 

#define IDVBTuneRequest_put_ONID(This,ONID)	\
    ( (This)->lpVtbl -> put_ONID(This,ONID) ) 

#define IDVBTuneRequest_get_TSID(This,TSID)	\
    ( (This)->lpVtbl -> get_TSID(This,TSID) ) 

#define IDVBTuneRequest_put_TSID(This,TSID)	\
    ( (This)->lpVtbl -> put_TSID(This,TSID) ) 

#define IDVBTuneRequest_get_SID(This,SID)	\
    ( (This)->lpVtbl -> get_SID(This,SID) ) 

#define IDVBTuneRequest_put_SID(This,SID)	\
    ( (This)->lpVtbl -> put_SID(This,SID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVBTuneRequest_INTERFACE_DEFINED__ */


#ifndef __IMPEG2TuneRequest_INTERFACE_DEFINED__
#define __IMPEG2TuneRequest_INTERFACE_DEFINED__

/* interface IMPEG2TuneRequest */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IMPEG2TuneRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB7D987F-8A01-42ad-B8AE-574DEEE44D1A")
    IMPEG2TuneRequest : public ITuneRequest
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ __RPC__out long *TSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TSID( 
            /* [in] */ long TSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProgNo( 
            /* [retval][out] */ __RPC__out long *ProgNo) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProgNo( 
            /* [in] */ long ProgNo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2TuneRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2TuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2TuneRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2TuneRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMPEG2TuneRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMPEG2TuneRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMPEG2TuneRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMPEG2TuneRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IMPEG2TuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Components )( 
            IMPEG2TuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponents **Components);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMPEG2TuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **NewTuneRequest);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locator )( 
            IMPEG2TuneRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **Locator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locator )( 
            IMPEG2TuneRequest * This,
            /* [in] */ __RPC__in_opt ILocator *Locator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IMPEG2TuneRequest * This,
            /* [retval][out] */ __RPC__out long *TSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IMPEG2TuneRequest * This,
            /* [in] */ long TSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProgNo )( 
            IMPEG2TuneRequest * This,
            /* [retval][out] */ __RPC__out long *ProgNo);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProgNo )( 
            IMPEG2TuneRequest * This,
            /* [in] */ long ProgNo);
        
        END_INTERFACE
    } IMPEG2TuneRequestVtbl;

    interface IMPEG2TuneRequest
    {
        CONST_VTBL struct IMPEG2TuneRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2TuneRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMPEG2TuneRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMPEG2TuneRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMPEG2TuneRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMPEG2TuneRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMPEG2TuneRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMPEG2TuneRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMPEG2TuneRequest_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define IMPEG2TuneRequest_get_Components(This,Components)	\
    ( (This)->lpVtbl -> get_Components(This,Components) ) 

#define IMPEG2TuneRequest_Clone(This,NewTuneRequest)	\
    ( (This)->lpVtbl -> Clone(This,NewTuneRequest) ) 

#define IMPEG2TuneRequest_get_Locator(This,Locator)	\
    ( (This)->lpVtbl -> get_Locator(This,Locator) ) 

#define IMPEG2TuneRequest_put_Locator(This,Locator)	\
    ( (This)->lpVtbl -> put_Locator(This,Locator) ) 


#define IMPEG2TuneRequest_get_TSID(This,TSID)	\
    ( (This)->lpVtbl -> get_TSID(This,TSID) ) 

#define IMPEG2TuneRequest_put_TSID(This,TSID)	\
    ( (This)->lpVtbl -> put_TSID(This,TSID) ) 

#define IMPEG2TuneRequest_get_ProgNo(This,ProgNo)	\
    ( (This)->lpVtbl -> get_ProgNo(This,ProgNo) ) 

#define IMPEG2TuneRequest_put_ProgNo(This,ProgNo)	\
    ( (This)->lpVtbl -> put_ProgNo(This,ProgNo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMPEG2TuneRequest_INTERFACE_DEFINED__ */


#ifndef __IMPEG2TuneRequestFactory_INTERFACE_DEFINED__
#define __IMPEG2TuneRequestFactory_INTERFACE_DEFINED__

/* interface IMPEG2TuneRequestFactory */
/* [unique][helpstring][oleautomation][dual][uuid][hidden][nonextensible][object] */ 


EXTERN_C const IID IID_IMPEG2TuneRequestFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14E11ABD-EE37-4893-9EA1-6964DE933E39")
    IMPEG2TuneRequestFactory : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateTuneRequest( 
            /* [in] */ __RPC__in_opt ITuningSpace *TuningSpace,
            /* [retval][out] */ __RPC__deref_out_opt IMPEG2TuneRequest **TuneRequest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2TuneRequestFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2TuneRequestFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2TuneRequestFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2TuneRequestFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMPEG2TuneRequestFactory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMPEG2TuneRequestFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMPEG2TuneRequestFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMPEG2TuneRequestFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTuneRequest )( 
            IMPEG2TuneRequestFactory * This,
            /* [in] */ __RPC__in_opt ITuningSpace *TuningSpace,
            /* [retval][out] */ __RPC__deref_out_opt IMPEG2TuneRequest **TuneRequest);
        
        END_INTERFACE
    } IMPEG2TuneRequestFactoryVtbl;

    interface IMPEG2TuneRequestFactory
    {
        CONST_VTBL struct IMPEG2TuneRequestFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2TuneRequestFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMPEG2TuneRequestFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMPEG2TuneRequestFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMPEG2TuneRequestFactory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMPEG2TuneRequestFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMPEG2TuneRequestFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMPEG2TuneRequestFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMPEG2TuneRequestFactory_CreateTuneRequest(This,TuningSpace,TuneRequest)	\
    ( (This)->lpVtbl -> CreateTuneRequest(This,TuningSpace,TuneRequest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMPEG2TuneRequestFactory_INTERFACE_DEFINED__ */


#ifndef __IMPEG2TuneRequestSupport_INTERFACE_DEFINED__
#define __IMPEG2TuneRequestSupport_INTERFACE_DEFINED__

/* interface IMPEG2TuneRequestSupport */
/* [unique][helpstring][uuid][nonextensible][restricted][hidden][object] */ 


EXTERN_C const IID IID_IMPEG2TuneRequestSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1B9D5FC3-5BBC-4b6c-BB18-B9D10E3EEEBF")
    IMPEG2TuneRequestSupport : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2TuneRequestSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2TuneRequestSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2TuneRequestSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2TuneRequestSupport * This);
        
        END_INTERFACE
    } IMPEG2TuneRequestSupportVtbl;

    interface IMPEG2TuneRequestSupport
    {
        CONST_VTBL struct IMPEG2TuneRequestSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2TuneRequestSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMPEG2TuneRequestSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMPEG2TuneRequestSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMPEG2TuneRequestSupport_INTERFACE_DEFINED__ */


#ifndef __ITunerCap_INTERFACE_DEFINED__
#define __ITunerCap_INTERFACE_DEFINED__

/* interface ITunerCap */
/* [unique][helpstring][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_ITunerCap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E60DFA45-8D56-4e65-A8AB-D6BE9412C249")
    ITunerCap : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedNetworkTypes( 
            /* [in] */ ULONG ulcNetworkTypesMax,
            /* [out] */ __RPC__out ULONG *pulcNetworkTypes,
            /* [out][in] */ __RPC__inout GUID *pguidNetworkTypes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedVideoFormats( 
            /* [out] */ __RPC__out ULONG *pulAMTunerModeType,
            /* [out] */ __RPC__out ULONG *pulAnalogVideoStandard) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AuxInputCount( 
            /* [out][in] */ __RPC__inout ULONG *pulCompositeCount,
            /* [out][in] */ __RPC__inout ULONG *pulSvideoCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITunerCapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITunerCap * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITunerCap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITunerCap * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedNetworkTypes )( 
            ITunerCap * This,
            /* [in] */ ULONG ulcNetworkTypesMax,
            /* [out] */ __RPC__out ULONG *pulcNetworkTypes,
            /* [out][in] */ __RPC__inout GUID *pguidNetworkTypes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedVideoFormats )( 
            ITunerCap * This,
            /* [out] */ __RPC__out ULONG *pulAMTunerModeType,
            /* [out] */ __RPC__out ULONG *pulAnalogVideoStandard);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuxInputCount )( 
            ITunerCap * This,
            /* [out][in] */ __RPC__inout ULONG *pulCompositeCount,
            /* [out][in] */ __RPC__inout ULONG *pulSvideoCount);
        
        END_INTERFACE
    } ITunerCapVtbl;

    interface ITunerCap
    {
        CONST_VTBL struct ITunerCapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITunerCap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITunerCap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITunerCap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITunerCap_get_SupportedNetworkTypes(This,ulcNetworkTypesMax,pulcNetworkTypes,pguidNetworkTypes)	\
    ( (This)->lpVtbl -> get_SupportedNetworkTypes(This,ulcNetworkTypesMax,pulcNetworkTypes,pguidNetworkTypes) ) 

#define ITunerCap_get_SupportedVideoFormats(This,pulAMTunerModeType,pulAnalogVideoStandard)	\
    ( (This)->lpVtbl -> get_SupportedVideoFormats(This,pulAMTunerModeType,pulAnalogVideoStandard) ) 

#define ITunerCap_get_AuxInputCount(This,pulCompositeCount,pulSvideoCount)	\
    ( (This)->lpVtbl -> get_AuxInputCount(This,pulCompositeCount,pulSvideoCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITunerCap_INTERFACE_DEFINED__ */


#ifndef __ITuner_INTERFACE_DEFINED__
#define __ITuner_INTERFACE_DEFINED__

/* interface ITuner */
/* [unique][helpstring][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_ITuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28C52640-018A-11d3-9D8E-00C04F72D980")
    ITuner : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TuningSpace( 
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_TuningSpace( 
            /* [in] */ __RPC__in_opt ITuningSpace *TuningSpace) = 0;
        
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE EnumTuningSpaces( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumTuningSpaces **ppEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TuneRequest( 
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **TuneRequest) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_TuneRequest( 
            /* [in] */ __RPC__in_opt ITuneRequest *TuneRequest) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ __RPC__in_opt ITuneRequest *TuneRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredComponentTypes( 
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **ComponentTypes) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PreferredComponentTypes( 
            /* [in] */ __RPC__in_opt IComponentTypes *ComponentTypes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SignalStrength( 
            /* [retval][out] */ __RPC__out long *Strength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TriggerSignalEvents( 
            /* [in] */ long Interval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITuner * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITuner * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            ITuner * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            ITuner * This,
            /* [in] */ __RPC__in_opt ITuningSpace *TuningSpace);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumTuningSpaces )( 
            ITuner * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTuningSpaces **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuneRequest )( 
            ITuner * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **TuneRequest);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TuneRequest )( 
            ITuner * This,
            /* [in] */ __RPC__in_opt ITuneRequest *TuneRequest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Validate )( 
            ITuner * This,
            /* [in] */ __RPC__in_opt ITuneRequest *TuneRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredComponentTypes )( 
            ITuner * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **ComponentTypes);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredComponentTypes )( 
            ITuner * This,
            /* [in] */ __RPC__in_opt IComponentTypes *ComponentTypes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignalStrength )( 
            ITuner * This,
            /* [retval][out] */ __RPC__out long *Strength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TriggerSignalEvents )( 
            ITuner * This,
            /* [in] */ long Interval);
        
        END_INTERFACE
    } ITunerVtbl;

    interface ITuner
    {
        CONST_VTBL struct ITunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITuner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITuner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITuner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITuner_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define ITuner_put_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> put_TuningSpace(This,TuningSpace) ) 

#define ITuner_EnumTuningSpaces(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumTuningSpaces(This,ppEnum) ) 

#define ITuner_get_TuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> get_TuneRequest(This,TuneRequest) ) 

#define ITuner_put_TuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> put_TuneRequest(This,TuneRequest) ) 

#define ITuner_Validate(This,TuneRequest)	\
    ( (This)->lpVtbl -> Validate(This,TuneRequest) ) 

#define ITuner_get_PreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> get_PreferredComponentTypes(This,ComponentTypes) ) 

#define ITuner_put_PreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> put_PreferredComponentTypes(This,ComponentTypes) ) 

#define ITuner_get_SignalStrength(This,Strength)	\
    ( (This)->lpVtbl -> get_SignalStrength(This,Strength) ) 

#define ITuner_TriggerSignalEvents(This,Interval)	\
    ( (This)->lpVtbl -> TriggerSignalEvents(This,Interval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITuner_INTERFACE_DEFINED__ */


#ifndef __IScanningTuner_INTERFACE_DEFINED__
#define __IScanningTuner_INTERFACE_DEFINED__

/* interface IScanningTuner */
/* [unique][helpstring][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IScanningTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DFD0A5C-0284-11d3-9D8E-00C04F72D980")
    IScanningTuner : public ITuner
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SeekUp( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SeekDown( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ScanUp( 
            /* [in] */ long MillisecondsPause) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ScanDown( 
            /* [in] */ long MillisecondsPause) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AutoProgram( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScanningTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScanningTuner * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScanningTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScanningTuner * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IScanningTuner * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IScanningTuner * This,
            /* [in] */ __RPC__in_opt ITuningSpace *TuningSpace);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumTuningSpaces )( 
            IScanningTuner * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTuningSpaces **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuneRequest )( 
            IScanningTuner * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **TuneRequest);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TuneRequest )( 
            IScanningTuner * This,
            /* [in] */ __RPC__in_opt ITuneRequest *TuneRequest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Validate )( 
            IScanningTuner * This,
            /* [in] */ __RPC__in_opt ITuneRequest *TuneRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredComponentTypes )( 
            IScanningTuner * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **ComponentTypes);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredComponentTypes )( 
            IScanningTuner * This,
            /* [in] */ __RPC__in_opt IComponentTypes *ComponentTypes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignalStrength )( 
            IScanningTuner * This,
            /* [retval][out] */ __RPC__out long *Strength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TriggerSignalEvents )( 
            IScanningTuner * This,
            /* [in] */ long Interval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SeekUp )( 
            IScanningTuner * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SeekDown )( 
            IScanningTuner * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ScanUp )( 
            IScanningTuner * This,
            /* [in] */ long MillisecondsPause);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ScanDown )( 
            IScanningTuner * This,
            /* [in] */ long MillisecondsPause);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AutoProgram )( 
            IScanningTuner * This);
        
        END_INTERFACE
    } IScanningTunerVtbl;

    interface IScanningTuner
    {
        CONST_VTBL struct IScanningTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScanningTuner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IScanningTuner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IScanningTuner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IScanningTuner_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define IScanningTuner_put_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> put_TuningSpace(This,TuningSpace) ) 

#define IScanningTuner_EnumTuningSpaces(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumTuningSpaces(This,ppEnum) ) 

#define IScanningTuner_get_TuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> get_TuneRequest(This,TuneRequest) ) 

#define IScanningTuner_put_TuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> put_TuneRequest(This,TuneRequest) ) 

#define IScanningTuner_Validate(This,TuneRequest)	\
    ( (This)->lpVtbl -> Validate(This,TuneRequest) ) 

#define IScanningTuner_get_PreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> get_PreferredComponentTypes(This,ComponentTypes) ) 

#define IScanningTuner_put_PreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> put_PreferredComponentTypes(This,ComponentTypes) ) 

#define IScanningTuner_get_SignalStrength(This,Strength)	\
    ( (This)->lpVtbl -> get_SignalStrength(This,Strength) ) 

#define IScanningTuner_TriggerSignalEvents(This,Interval)	\
    ( (This)->lpVtbl -> TriggerSignalEvents(This,Interval) ) 


#define IScanningTuner_SeekUp(This)	\
    ( (This)->lpVtbl -> SeekUp(This) ) 

#define IScanningTuner_SeekDown(This)	\
    ( (This)->lpVtbl -> SeekDown(This) ) 

#define IScanningTuner_ScanUp(This,MillisecondsPause)	\
    ( (This)->lpVtbl -> ScanUp(This,MillisecondsPause) ) 

#define IScanningTuner_ScanDown(This,MillisecondsPause)	\
    ( (This)->lpVtbl -> ScanDown(This,MillisecondsPause) ) 

#define IScanningTuner_AutoProgram(This)	\
    ( (This)->lpVtbl -> AutoProgram(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScanningTuner_INTERFACE_DEFINED__ */


#ifndef __IScanningTunerEx_INTERFACE_DEFINED__
#define __IScanningTunerEx_INTERFACE_DEFINED__

/* interface IScanningTunerEx */
/* [unique][helpstring][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IScanningTunerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04BBD195-0E2D-4593-9BD5-4F908BC33CF5")
    IScanningTunerEx : public IScanningTuner
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCurrentLocator( 
            __RPC__deref_in_opt ILocator **pILocator) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PerformExhaustiveScan( 
            /* [in] */ long dwLowerFreq,
            /* [in] */ long dwHigherFreq,
            /* [in] */ VARIANT_BOOL bFineTune,
            /* [in] */ HEVENT hEvent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TerminateCurrentScan( 
            /* [retval][out] */ __RPC__out long *pcurrentFreq) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResumeCurrentScan( 
            /* [in] */ HEVENT hEvent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTunerScanningCapability( 
            /* [out] */ __RPC__out long *HardwareAssistedScanning,
            /* [out] */ __RPC__out long *NumStandardsSupported,
            /* [out] */ __RPC__out GUID *BroadcastStandards) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTunerStatus( 
            /* [out] */ __RPC__out long *SecondsLeft,
            /* [out] */ __RPC__out long *CurrentLockType,
            /* [out] */ __RPC__out long *AutoDetect,
            /* [out] */ __RPC__out long *CurrentFreq) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCurrentTunerStandardCapability( 
            /* [in] */ GUID CurrentBroadcastStandard,
            /* [out] */ __RPC__out long *SettlingTime,
            /* [out] */ __RPC__out long *TvStandardsSupported) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetScanSignalTypeFilter( 
            /* [in] */ long ScanModulationTypes,
            /* [in] */ long AnalogVideoStandard) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScanningTunerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScanningTunerEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScanningTunerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScanningTunerEx * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IScanningTunerEx * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuningSpace **TuningSpace);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IScanningTunerEx * This,
            /* [in] */ __RPC__in_opt ITuningSpace *TuningSpace);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumTuningSpaces )( 
            IScanningTunerEx * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTuningSpaces **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuneRequest )( 
            IScanningTunerEx * This,
            /* [retval][out] */ __RPC__deref_out_opt ITuneRequest **TuneRequest);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TuneRequest )( 
            IScanningTunerEx * This,
            /* [in] */ __RPC__in_opt ITuneRequest *TuneRequest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Validate )( 
            IScanningTunerEx * This,
            /* [in] */ __RPC__in_opt ITuneRequest *TuneRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredComponentTypes )( 
            IScanningTunerEx * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **ComponentTypes);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredComponentTypes )( 
            IScanningTunerEx * This,
            /* [in] */ __RPC__in_opt IComponentTypes *ComponentTypes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignalStrength )( 
            IScanningTunerEx * This,
            /* [retval][out] */ __RPC__out long *Strength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TriggerSignalEvents )( 
            IScanningTunerEx * This,
            /* [in] */ long Interval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SeekUp )( 
            IScanningTunerEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SeekDown )( 
            IScanningTunerEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ScanUp )( 
            IScanningTunerEx * This,
            /* [in] */ long MillisecondsPause);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ScanDown )( 
            IScanningTunerEx * This,
            /* [in] */ long MillisecondsPause);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AutoProgram )( 
            IScanningTunerEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentLocator )( 
            IScanningTunerEx * This,
            __RPC__deref_in_opt ILocator **pILocator);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PerformExhaustiveScan )( 
            IScanningTunerEx * This,
            /* [in] */ long dwLowerFreq,
            /* [in] */ long dwHigherFreq,
            /* [in] */ VARIANT_BOOL bFineTune,
            /* [in] */ HEVENT hEvent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TerminateCurrentScan )( 
            IScanningTunerEx * This,
            /* [retval][out] */ __RPC__out long *pcurrentFreq);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ResumeCurrentScan )( 
            IScanningTunerEx * This,
            /* [in] */ HEVENT hEvent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTunerScanningCapability )( 
            IScanningTunerEx * This,
            /* [out] */ __RPC__out long *HardwareAssistedScanning,
            /* [out] */ __RPC__out long *NumStandardsSupported,
            /* [out] */ __RPC__out GUID *BroadcastStandards);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTunerStatus )( 
            IScanningTunerEx * This,
            /* [out] */ __RPC__out long *SecondsLeft,
            /* [out] */ __RPC__out long *CurrentLockType,
            /* [out] */ __RPC__out long *AutoDetect,
            /* [out] */ __RPC__out long *CurrentFreq);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentTunerStandardCapability )( 
            IScanningTunerEx * This,
            /* [in] */ GUID CurrentBroadcastStandard,
            /* [out] */ __RPC__out long *SettlingTime,
            /* [out] */ __RPC__out long *TvStandardsSupported);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetScanSignalTypeFilter )( 
            IScanningTunerEx * This,
            /* [in] */ long ScanModulationTypes,
            /* [in] */ long AnalogVideoStandard);
        
        END_INTERFACE
    } IScanningTunerExVtbl;

    interface IScanningTunerEx
    {
        CONST_VTBL struct IScanningTunerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScanningTunerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IScanningTunerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IScanningTunerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IScanningTunerEx_get_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> get_TuningSpace(This,TuningSpace) ) 

#define IScanningTunerEx_put_TuningSpace(This,TuningSpace)	\
    ( (This)->lpVtbl -> put_TuningSpace(This,TuningSpace) ) 

#define IScanningTunerEx_EnumTuningSpaces(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumTuningSpaces(This,ppEnum) ) 

#define IScanningTunerEx_get_TuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> get_TuneRequest(This,TuneRequest) ) 

#define IScanningTunerEx_put_TuneRequest(This,TuneRequest)	\
    ( (This)->lpVtbl -> put_TuneRequest(This,TuneRequest) ) 

#define IScanningTunerEx_Validate(This,TuneRequest)	\
    ( (This)->lpVtbl -> Validate(This,TuneRequest) ) 

#define IScanningTunerEx_get_PreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> get_PreferredComponentTypes(This,ComponentTypes) ) 

#define IScanningTunerEx_put_PreferredComponentTypes(This,ComponentTypes)	\
    ( (This)->lpVtbl -> put_PreferredComponentTypes(This,ComponentTypes) ) 

#define IScanningTunerEx_get_SignalStrength(This,Strength)	\
    ( (This)->lpVtbl -> get_SignalStrength(This,Strength) ) 

#define IScanningTunerEx_TriggerSignalEvents(This,Interval)	\
    ( (This)->lpVtbl -> TriggerSignalEvents(This,Interval) ) 


#define IScanningTunerEx_SeekUp(This)	\
    ( (This)->lpVtbl -> SeekUp(This) ) 

#define IScanningTunerEx_SeekDown(This)	\
    ( (This)->lpVtbl -> SeekDown(This) ) 

#define IScanningTunerEx_ScanUp(This,MillisecondsPause)	\
    ( (This)->lpVtbl -> ScanUp(This,MillisecondsPause) ) 

#define IScanningTunerEx_ScanDown(This,MillisecondsPause)	\
    ( (This)->lpVtbl -> ScanDown(This,MillisecondsPause) ) 

#define IScanningTunerEx_AutoProgram(This)	\
    ( (This)->lpVtbl -> AutoProgram(This) ) 


#define IScanningTunerEx_GetCurrentLocator(This,pILocator)	\
    ( (This)->lpVtbl -> GetCurrentLocator(This,pILocator) ) 

#define IScanningTunerEx_PerformExhaustiveScan(This,dwLowerFreq,dwHigherFreq,bFineTune,hEvent)	\
    ( (This)->lpVtbl -> PerformExhaustiveScan(This,dwLowerFreq,dwHigherFreq,bFineTune,hEvent) ) 

#define IScanningTunerEx_TerminateCurrentScan(This,pcurrentFreq)	\
    ( (This)->lpVtbl -> TerminateCurrentScan(This,pcurrentFreq) ) 

#define IScanningTunerEx_ResumeCurrentScan(This,hEvent)	\
    ( (This)->lpVtbl -> ResumeCurrentScan(This,hEvent) ) 

#define IScanningTunerEx_GetTunerScanningCapability(This,HardwareAssistedScanning,NumStandardsSupported,BroadcastStandards)	\
    ( (This)->lpVtbl -> GetTunerScanningCapability(This,HardwareAssistedScanning,NumStandardsSupported,BroadcastStandards) ) 

#define IScanningTunerEx_GetTunerStatus(This,SecondsLeft,CurrentLockType,AutoDetect,CurrentFreq)	\
    ( (This)->lpVtbl -> GetTunerStatus(This,SecondsLeft,CurrentLockType,AutoDetect,CurrentFreq) ) 

#define IScanningTunerEx_GetCurrentTunerStandardCapability(This,CurrentBroadcastStandard,SettlingTime,TvStandardsSupported)	\
    ( (This)->lpVtbl -> GetCurrentTunerStandardCapability(This,CurrentBroadcastStandard,SettlingTime,TvStandardsSupported) ) 

#define IScanningTunerEx_SetScanSignalTypeFilter(This,ScanModulationTypes,AnalogVideoStandard)	\
    ( (This)->lpVtbl -> SetScanSignalTypeFilter(This,ScanModulationTypes,AnalogVideoStandard) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScanningTunerEx_INTERFACE_DEFINED__ */


#ifndef __IComponentType_INTERFACE_DEFINED__
#define __IComponentType_INTERFACE_DEFINED__

/* interface IComponentType */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IComponentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6A340DC0-0311-11d3-9D8E-00C04F72D980")
    IComponentType : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ __RPC__out ComponentCategory *Category) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Category( 
            /* [in] */ ComponentCategory Category) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaMajorType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaMajorType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaMajorType( 
            /* [in] */ __RPC__in BSTR MediaMajorType) = 0;
        
        virtual /* [restricted][hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__MediaMajorType( 
            /* [retval][out] */ __RPC__out GUID *MediaMajorTypeGuid) = 0;
        
        virtual /* [restricted][hidden][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put__MediaMajorType( 
            /* [in] */ __RPC__in REFCLSID MediaMajorTypeGuid) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaSubType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaSubType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaSubType( 
            /* [in] */ __RPC__in BSTR MediaSubType) = 0;
        
        virtual /* [restricted][hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__MediaSubType( 
            /* [retval][out] */ __RPC__out GUID *MediaSubTypeGuid) = 0;
        
        virtual /* [restricted][hidden][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put__MediaSubType( 
            /* [in] */ __RPC__in REFCLSID MediaSubTypeGuid) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaFormatType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaFormatType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaFormatType( 
            /* [in] */ __RPC__in BSTR MediaFormatType) = 0;
        
        virtual /* [restricted][hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__MediaFormatType( 
            /* [retval][out] */ __RPC__out GUID *MediaFormatTypeGuid) = 0;
        
        virtual /* [restricted][hidden][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put__MediaFormatType( 
            /* [in] */ __RPC__in REFCLSID MediaFormatTypeGuid) = 0;
        
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ __RPC__out AM_MEDIA_TYPE *MediaType) = 0;
        
        virtual /* [helpstring][restricted][hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaType( 
            /* [in] */ __RPC__in AM_MEDIA_TYPE *MediaType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **NewCT) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComponentType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComponentType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IComponentType * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComponentType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IComponentType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__out ComponentCategory *Category);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )( 
            IComponentType * This,
            /* [in] */ ComponentCategory Category);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaMajorType )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaMajorType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaMajorType )( 
            IComponentType * This,
            /* [in] */ __RPC__in BSTR MediaMajorType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaMajorType )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaMajorTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaMajorType )( 
            IComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaMajorTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaSubType )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaSubType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaSubType )( 
            IComponentType * This,
            /* [in] */ __RPC__in BSTR MediaSubType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaSubType )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaSubTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaSubType )( 
            IComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaSubTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaFormatType )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaFormatType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaFormatType )( 
            IComponentType * This,
            /* [in] */ __RPC__in BSTR MediaFormatType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaFormatType )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaFormatTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaFormatType )( 
            IComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaFormatTypeGuid);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__out AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][restricted][hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaType )( 
            IComponentType * This,
            /* [in] */ __RPC__in AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **NewCT);
        
        END_INTERFACE
    } IComponentTypeVtbl;

    interface IComponentType
    {
        CONST_VTBL struct IComponentTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComponentType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComponentType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComponentType_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IComponentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IComponentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IComponentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IComponentType_get_Category(This,Category)	\
    ( (This)->lpVtbl -> get_Category(This,Category) ) 

#define IComponentType_put_Category(This,Category)	\
    ( (This)->lpVtbl -> put_Category(This,Category) ) 

#define IComponentType_get_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> get_MediaMajorType(This,MediaMajorType) ) 

#define IComponentType_put_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> put_MediaMajorType(This,MediaMajorType) ) 

#define IComponentType_get__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define IComponentType_put__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define IComponentType_get_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> get_MediaSubType(This,MediaSubType) ) 

#define IComponentType_put_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> put_MediaSubType(This,MediaSubType) ) 

#define IComponentType_get__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaSubType(This,MediaSubTypeGuid) ) 

#define IComponentType_put__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaSubType(This,MediaSubTypeGuid) ) 

#define IComponentType_get_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> get_MediaFormatType(This,MediaFormatType) ) 

#define IComponentType_put_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> put_MediaFormatType(This,MediaFormatType) ) 

#define IComponentType_get__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define IComponentType_put__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define IComponentType_get_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,MediaType) ) 

#define IComponentType_put_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> put_MediaType(This,MediaType) ) 

#define IComponentType_Clone(This,NewCT)	\
    ( (This)->lpVtbl -> Clone(This,NewCT) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComponentType_INTERFACE_DEFINED__ */


#ifndef __ILanguageComponentType_INTERFACE_DEFINED__
#define __ILanguageComponentType_INTERFACE_DEFINED__

/* interface ILanguageComponentType */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_ILanguageComponentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B874C8BA-0FA2-11d3-9D8E-00C04F72D980")
    ILanguageComponentType : public IComponentType
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LangID( 
            /* [retval][out] */ __RPC__out long *LangID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LangID( 
            /* [in] */ long LangID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILanguageComponentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILanguageComponentType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILanguageComponentType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILanguageComponentType * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILanguageComponentType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILanguageComponentType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__out ComponentCategory *Category);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )( 
            ILanguageComponentType * This,
            /* [in] */ ComponentCategory Category);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaMajorType )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaMajorType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaMajorType )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in BSTR MediaMajorType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaMajorType )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaMajorTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaMajorType )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaMajorTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaSubType )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaSubType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaSubType )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in BSTR MediaSubType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaSubType )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaSubTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaSubType )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaSubTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaFormatType )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaFormatType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaFormatType )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in BSTR MediaFormatType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaFormatType )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaFormatTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaFormatType )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaFormatTypeGuid);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__out AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][restricted][hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaType )( 
            ILanguageComponentType * This,
            /* [in] */ __RPC__in AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **NewCT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LangID )( 
            ILanguageComponentType * This,
            /* [retval][out] */ __RPC__out long *LangID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LangID )( 
            ILanguageComponentType * This,
            /* [in] */ long LangID);
        
        END_INTERFACE
    } ILanguageComponentTypeVtbl;

    interface ILanguageComponentType
    {
        CONST_VTBL struct ILanguageComponentTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILanguageComponentType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILanguageComponentType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILanguageComponentType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILanguageComponentType_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ILanguageComponentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ILanguageComponentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ILanguageComponentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ILanguageComponentType_get_Category(This,Category)	\
    ( (This)->lpVtbl -> get_Category(This,Category) ) 

#define ILanguageComponentType_put_Category(This,Category)	\
    ( (This)->lpVtbl -> put_Category(This,Category) ) 

#define ILanguageComponentType_get_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> get_MediaMajorType(This,MediaMajorType) ) 

#define ILanguageComponentType_put_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> put_MediaMajorType(This,MediaMajorType) ) 

#define ILanguageComponentType_get__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define ILanguageComponentType_put__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define ILanguageComponentType_get_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> get_MediaSubType(This,MediaSubType) ) 

#define ILanguageComponentType_put_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> put_MediaSubType(This,MediaSubType) ) 

#define ILanguageComponentType_get__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaSubType(This,MediaSubTypeGuid) ) 

#define ILanguageComponentType_put__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaSubType(This,MediaSubTypeGuid) ) 

#define ILanguageComponentType_get_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> get_MediaFormatType(This,MediaFormatType) ) 

#define ILanguageComponentType_put_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> put_MediaFormatType(This,MediaFormatType) ) 

#define ILanguageComponentType_get__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define ILanguageComponentType_put__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define ILanguageComponentType_get_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,MediaType) ) 

#define ILanguageComponentType_put_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> put_MediaType(This,MediaType) ) 

#define ILanguageComponentType_Clone(This,NewCT)	\
    ( (This)->lpVtbl -> Clone(This,NewCT) ) 


#define ILanguageComponentType_get_LangID(This,LangID)	\
    ( (This)->lpVtbl -> get_LangID(This,LangID) ) 

#define ILanguageComponentType_put_LangID(This,LangID)	\
    ( (This)->lpVtbl -> put_LangID(This,LangID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILanguageComponentType_INTERFACE_DEFINED__ */


#ifndef __IMPEG2ComponentType_INTERFACE_DEFINED__
#define __IMPEG2ComponentType_INTERFACE_DEFINED__

/* interface IMPEG2ComponentType */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IMPEG2ComponentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C073D84-B51C-48c9-AA9F-68971E1F6E38")
    IMPEG2ComponentType : public ILanguageComponentType
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamType( 
            /* [retval][out] */ __RPC__out MPEG2StreamType *MP2StreamType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StreamType( 
            /* [in] */ MPEG2StreamType MP2StreamType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2ComponentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2ComponentType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2ComponentType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMPEG2ComponentType * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMPEG2ComponentType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMPEG2ComponentType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__out ComponentCategory *Category);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )( 
            IMPEG2ComponentType * This,
            /* [in] */ ComponentCategory Category);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaMajorType )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaMajorType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaMajorType )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in BSTR MediaMajorType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaMajorType )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaMajorTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaMajorType )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaMajorTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaSubType )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaSubType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaSubType )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in BSTR MediaSubType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaSubType )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaSubTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaSubType )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaSubTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaFormatType )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaFormatType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaFormatType )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in BSTR MediaFormatType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaFormatType )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaFormatTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaFormatType )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaFormatTypeGuid);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__out AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][restricted][hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaType )( 
            IMPEG2ComponentType * This,
            /* [in] */ __RPC__in AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **NewCT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LangID )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__out long *LangID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LangID )( 
            IMPEG2ComponentType * This,
            /* [in] */ long LangID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamType )( 
            IMPEG2ComponentType * This,
            /* [retval][out] */ __RPC__out MPEG2StreamType *MP2StreamType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StreamType )( 
            IMPEG2ComponentType * This,
            /* [in] */ MPEG2StreamType MP2StreamType);
        
        END_INTERFACE
    } IMPEG2ComponentTypeVtbl;

    interface IMPEG2ComponentType
    {
        CONST_VTBL struct IMPEG2ComponentTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2ComponentType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMPEG2ComponentType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMPEG2ComponentType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMPEG2ComponentType_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMPEG2ComponentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMPEG2ComponentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMPEG2ComponentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMPEG2ComponentType_get_Category(This,Category)	\
    ( (This)->lpVtbl -> get_Category(This,Category) ) 

#define IMPEG2ComponentType_put_Category(This,Category)	\
    ( (This)->lpVtbl -> put_Category(This,Category) ) 

#define IMPEG2ComponentType_get_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> get_MediaMajorType(This,MediaMajorType) ) 

#define IMPEG2ComponentType_put_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> put_MediaMajorType(This,MediaMajorType) ) 

#define IMPEG2ComponentType_get__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define IMPEG2ComponentType_put__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define IMPEG2ComponentType_get_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> get_MediaSubType(This,MediaSubType) ) 

#define IMPEG2ComponentType_put_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> put_MediaSubType(This,MediaSubType) ) 

#define IMPEG2ComponentType_get__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaSubType(This,MediaSubTypeGuid) ) 

#define IMPEG2ComponentType_put__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaSubType(This,MediaSubTypeGuid) ) 

#define IMPEG2ComponentType_get_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> get_MediaFormatType(This,MediaFormatType) ) 

#define IMPEG2ComponentType_put_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> put_MediaFormatType(This,MediaFormatType) ) 

#define IMPEG2ComponentType_get__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define IMPEG2ComponentType_put__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define IMPEG2ComponentType_get_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,MediaType) ) 

#define IMPEG2ComponentType_put_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> put_MediaType(This,MediaType) ) 

#define IMPEG2ComponentType_Clone(This,NewCT)	\
    ( (This)->lpVtbl -> Clone(This,NewCT) ) 


#define IMPEG2ComponentType_get_LangID(This,LangID)	\
    ( (This)->lpVtbl -> get_LangID(This,LangID) ) 

#define IMPEG2ComponentType_put_LangID(This,LangID)	\
    ( (This)->lpVtbl -> put_LangID(This,LangID) ) 


#define IMPEG2ComponentType_get_StreamType(This,MP2StreamType)	\
    ( (This)->lpVtbl -> get_StreamType(This,MP2StreamType) ) 

#define IMPEG2ComponentType_put_StreamType(This,MP2StreamType)	\
    ( (This)->lpVtbl -> put_StreamType(This,MP2StreamType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMPEG2ComponentType_INTERFACE_DEFINED__ */


#ifndef __IATSCComponentType_INTERFACE_DEFINED__
#define __IATSCComponentType_INTERFACE_DEFINED__

/* interface IATSCComponentType */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IATSCComponentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FC189E4D-7BD4-4125-B3B3-3A76A332CC96")
    IATSCComponentType : public IMPEG2ComponentType
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out long *Flags) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Flags( 
            /* [in] */ long flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IATSCComponentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IATSCComponentType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IATSCComponentType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IATSCComponentType * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IATSCComponentType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IATSCComponentType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__out ComponentCategory *Category);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )( 
            IATSCComponentType * This,
            /* [in] */ ComponentCategory Category);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaMajorType )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaMajorType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaMajorType )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in BSTR MediaMajorType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaMajorType )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaMajorTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaMajorType )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaMajorTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaSubType )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaSubType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaSubType )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in BSTR MediaSubType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaSubType )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaSubTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaSubType )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaSubTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaFormatType )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaFormatType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaFormatType )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in BSTR MediaFormatType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaFormatType )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaFormatTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaFormatType )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaFormatTypeGuid);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__out AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][restricted][hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaType )( 
            IATSCComponentType * This,
            /* [in] */ __RPC__in AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **NewCT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LangID )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__out long *LangID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LangID )( 
            IATSCComponentType * This,
            /* [in] */ long LangID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamType )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__out MPEG2StreamType *MP2StreamType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StreamType )( 
            IATSCComponentType * This,
            /* [in] */ MPEG2StreamType MP2StreamType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            IATSCComponentType * This,
            /* [retval][out] */ __RPC__out long *Flags);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Flags )( 
            IATSCComponentType * This,
            /* [in] */ long flags);
        
        END_INTERFACE
    } IATSCComponentTypeVtbl;

    interface IATSCComponentType
    {
        CONST_VTBL struct IATSCComponentTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IATSCComponentType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IATSCComponentType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IATSCComponentType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IATSCComponentType_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IATSCComponentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IATSCComponentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IATSCComponentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IATSCComponentType_get_Category(This,Category)	\
    ( (This)->lpVtbl -> get_Category(This,Category) ) 

#define IATSCComponentType_put_Category(This,Category)	\
    ( (This)->lpVtbl -> put_Category(This,Category) ) 

#define IATSCComponentType_get_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> get_MediaMajorType(This,MediaMajorType) ) 

#define IATSCComponentType_put_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> put_MediaMajorType(This,MediaMajorType) ) 

#define IATSCComponentType_get__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define IATSCComponentType_put__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define IATSCComponentType_get_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> get_MediaSubType(This,MediaSubType) ) 

#define IATSCComponentType_put_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> put_MediaSubType(This,MediaSubType) ) 

#define IATSCComponentType_get__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaSubType(This,MediaSubTypeGuid) ) 

#define IATSCComponentType_put__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaSubType(This,MediaSubTypeGuid) ) 

#define IATSCComponentType_get_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> get_MediaFormatType(This,MediaFormatType) ) 

#define IATSCComponentType_put_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> put_MediaFormatType(This,MediaFormatType) ) 

#define IATSCComponentType_get__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define IATSCComponentType_put__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define IATSCComponentType_get_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,MediaType) ) 

#define IATSCComponentType_put_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> put_MediaType(This,MediaType) ) 

#define IATSCComponentType_Clone(This,NewCT)	\
    ( (This)->lpVtbl -> Clone(This,NewCT) ) 


#define IATSCComponentType_get_LangID(This,LangID)	\
    ( (This)->lpVtbl -> get_LangID(This,LangID) ) 

#define IATSCComponentType_put_LangID(This,LangID)	\
    ( (This)->lpVtbl -> put_LangID(This,LangID) ) 


#define IATSCComponentType_get_StreamType(This,MP2StreamType)	\
    ( (This)->lpVtbl -> get_StreamType(This,MP2StreamType) ) 

#define IATSCComponentType_put_StreamType(This,MP2StreamType)	\
    ( (This)->lpVtbl -> put_StreamType(This,MP2StreamType) ) 


#define IATSCComponentType_get_Flags(This,Flags)	\
    ( (This)->lpVtbl -> get_Flags(This,Flags) ) 

#define IATSCComponentType_put_Flags(This,flags)	\
    ( (This)->lpVtbl -> put_Flags(This,flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IATSCComponentType_INTERFACE_DEFINED__ */


#ifndef __IEnumComponentTypes_INTERFACE_DEFINED__
#define __IEnumComponentTypes_INTERFACE_DEFINED__

/* interface IEnumComponentTypes */
/* [unique][uuid][object][restricted][hidden] */ 


EXTERN_C const IID IID_IEnumComponentTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A674B4A-1F63-11d3-B64C-00C04F79498E")
    IEnumComponentTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IComponentType **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumComponentTypes **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumComponentTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumComponentTypes * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumComponentTypes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumComponentTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumComponentTypes * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IComponentType **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumComponentTypes * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumComponentTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumComponentTypes * This,
            /* [out] */ __RPC__deref_out_opt IEnumComponentTypes **ppEnum);
        
        END_INTERFACE
    } IEnumComponentTypesVtbl;

    interface IEnumComponentTypes
    {
        CONST_VTBL struct IEnumComponentTypesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumComponentTypes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumComponentTypes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumComponentTypes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumComponentTypes_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumComponentTypes_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumComponentTypes_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumComponentTypes_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumComponentTypes_INTERFACE_DEFINED__ */


#ifndef __IComponentTypes_INTERFACE_DEFINED__
#define __IComponentTypes_INTERFACE_DEFINED__

/* interface IComponentTypes */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IComponentTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DC13D4A-0313-11d3-9D8E-00C04F72D980")
    IComponentTypes : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *Count) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppNewEnum) = 0;
        
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE EnumComponentTypes( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumComponentTypes **ppNewEnum) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **ComponentType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT Index,
            /* [in] */ __RPC__in_opt IComponentType *ComponentType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IComponentType *ComponentType,
            /* [retval][out] */ __RPC__out VARIANT *NewIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **NewList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComponentTypes * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComponentTypes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComponentTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IComponentTypes * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComponentTypes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IComponentTypes * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IComponentTypes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IComponentTypes * This,
            /* [retval][out] */ __RPC__out long *Count);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IComponentTypes * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppNewEnum);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumComponentTypes )( 
            IComponentTypes * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumComponentTypes **ppNewEnum);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IComponentTypes * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **ComponentType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Item )( 
            IComponentTypes * This,
            /* [in] */ VARIANT Index,
            /* [in] */ __RPC__in_opt IComponentType *ComponentType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IComponentTypes * This,
            /* [in] */ __RPC__in_opt IComponentType *ComponentType,
            /* [retval][out] */ __RPC__out VARIANT *NewIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IComponentTypes * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IComponentTypes * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentTypes **NewList);
        
        END_INTERFACE
    } IComponentTypesVtbl;

    interface IComponentTypes
    {
        CONST_VTBL struct IComponentTypesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentTypes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComponentTypes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComponentTypes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComponentTypes_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IComponentTypes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IComponentTypes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IComponentTypes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IComponentTypes_get_Count(This,Count)	\
    ( (This)->lpVtbl -> get_Count(This,Count) ) 

#define IComponentTypes_get__NewEnum(This,ppNewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppNewEnum) ) 

#define IComponentTypes_EnumComponentTypes(This,ppNewEnum)	\
    ( (This)->lpVtbl -> EnumComponentTypes(This,ppNewEnum) ) 

#define IComponentTypes_get_Item(This,Index,ComponentType)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ComponentType) ) 

#define IComponentTypes_put_Item(This,Index,ComponentType)	\
    ( (This)->lpVtbl -> put_Item(This,Index,ComponentType) ) 

#define IComponentTypes_Add(This,ComponentType,NewIndex)	\
    ( (This)->lpVtbl -> Add(This,ComponentType,NewIndex) ) 

#define IComponentTypes_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IComponentTypes_Clone(This,NewList)	\
    ( (This)->lpVtbl -> Clone(This,NewList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComponentTypes_INTERFACE_DEFINED__ */


#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/* interface IComponent */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1A5576FC-0E19-11d3-9D8E-00C04F72D980")
    IComponent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **CT) = 0;
        
        virtual /* [helpstring][id][propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ __RPC__in_opt IComponentType *CT) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DescLangID( 
            /* [retval][out] */ __RPC__out long *LangID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DescLangID( 
            /* [in] */ long LangID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out ComponentStatus *Status) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ ComponentStatus Status) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Description) = 0;
        
        virtual /* [helpstring][id][propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR Description) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IComponent **NewComponent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComponent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComponent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComponent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IComponent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComponent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IComponent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IComponent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IComponent * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **CT);
        
        /* [helpstring][id][propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Type )( 
            IComponent * This,
            /* [in] */ __RPC__in_opt IComponentType *CT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DescLangID )( 
            IComponent * This,
            /* [retval][out] */ __RPC__out long *LangID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DescLangID )( 
            IComponent * This,
            /* [in] */ long LangID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IComponent * This,
            /* [retval][out] */ __RPC__out ComponentStatus *Status);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Status )( 
            IComponent * This,
            /* [in] */ ComponentStatus Status);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IComponent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Description);
        
        /* [helpstring][id][propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IComponent * This,
            /* [in] */ __RPC__in BSTR Description);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IComponent * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponent **NewComponent);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComponent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComponent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComponent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IComponent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IComponent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IComponent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IComponent_get_Type(This,CT)	\
    ( (This)->lpVtbl -> get_Type(This,CT) ) 

#define IComponent_put_Type(This,CT)	\
    ( (This)->lpVtbl -> put_Type(This,CT) ) 

#define IComponent_get_DescLangID(This,LangID)	\
    ( (This)->lpVtbl -> get_DescLangID(This,LangID) ) 

#define IComponent_put_DescLangID(This,LangID)	\
    ( (This)->lpVtbl -> put_DescLangID(This,LangID) ) 

#define IComponent_get_Status(This,Status)	\
    ( (This)->lpVtbl -> get_Status(This,Status) ) 

#define IComponent_put_Status(This,Status)	\
    ( (This)->lpVtbl -> put_Status(This,Status) ) 

#define IComponent_get_Description(This,Description)	\
    ( (This)->lpVtbl -> get_Description(This,Description) ) 

#define IComponent_put_Description(This,Description)	\
    ( (This)->lpVtbl -> put_Description(This,Description) ) 

#define IComponent_Clone(This,NewComponent)	\
    ( (This)->lpVtbl -> Clone(This,NewComponent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComponent_INTERFACE_DEFINED__ */


#ifndef __IAnalogAudioComponentType_INTERFACE_DEFINED__
#define __IAnalogAudioComponentType_INTERFACE_DEFINED__

/* interface IAnalogAudioComponentType */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IAnalogAudioComponentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2CFEB2A8-1787-4A24-A941-C6EAEC39C842")
    IAnalogAudioComponentType : public IComponentType
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AnalogAudioMode( 
            /* [retval][out] */ __RPC__out TVAudioMode *Mode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AnalogAudioMode( 
            /* [in] */ TVAudioMode Mode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalogAudioComponentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalogAudioComponentType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalogAudioComponentType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAnalogAudioComponentType * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAnalogAudioComponentType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAnalogAudioComponentType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__out ComponentCategory *Category);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )( 
            IAnalogAudioComponentType * This,
            /* [in] */ ComponentCategory Category);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaMajorType )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaMajorType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaMajorType )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in BSTR MediaMajorType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaMajorType )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaMajorTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaMajorType )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaMajorTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaSubType )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaSubType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaSubType )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in BSTR MediaSubType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaSubType )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaSubTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaSubType )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaSubTypeGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaFormatType )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *MediaFormatType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaFormatType )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in BSTR MediaFormatType);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MediaFormatType )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__out GUID *MediaFormatTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MediaFormatType )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in REFCLSID MediaFormatTypeGuid);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__out AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][restricted][hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaType )( 
            IAnalogAudioComponentType * This,
            /* [in] */ __RPC__in AM_MEDIA_TYPE *MediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **NewCT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AnalogAudioMode )( 
            IAnalogAudioComponentType * This,
            /* [retval][out] */ __RPC__out TVAudioMode *Mode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AnalogAudioMode )( 
            IAnalogAudioComponentType * This,
            /* [in] */ TVAudioMode Mode);
        
        END_INTERFACE
    } IAnalogAudioComponentTypeVtbl;

    interface IAnalogAudioComponentType
    {
        CONST_VTBL struct IAnalogAudioComponentTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalogAudioComponentType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAnalogAudioComponentType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAnalogAudioComponentType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAnalogAudioComponentType_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAnalogAudioComponentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAnalogAudioComponentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAnalogAudioComponentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAnalogAudioComponentType_get_Category(This,Category)	\
    ( (This)->lpVtbl -> get_Category(This,Category) ) 

#define IAnalogAudioComponentType_put_Category(This,Category)	\
    ( (This)->lpVtbl -> put_Category(This,Category) ) 

#define IAnalogAudioComponentType_get_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> get_MediaMajorType(This,MediaMajorType) ) 

#define IAnalogAudioComponentType_put_MediaMajorType(This,MediaMajorType)	\
    ( (This)->lpVtbl -> put_MediaMajorType(This,MediaMajorType) ) 

#define IAnalogAudioComponentType_get__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define IAnalogAudioComponentType_put__MediaMajorType(This,MediaMajorTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaMajorType(This,MediaMajorTypeGuid) ) 

#define IAnalogAudioComponentType_get_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> get_MediaSubType(This,MediaSubType) ) 

#define IAnalogAudioComponentType_put_MediaSubType(This,MediaSubType)	\
    ( (This)->lpVtbl -> put_MediaSubType(This,MediaSubType) ) 

#define IAnalogAudioComponentType_get__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaSubType(This,MediaSubTypeGuid) ) 

#define IAnalogAudioComponentType_put__MediaSubType(This,MediaSubTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaSubType(This,MediaSubTypeGuid) ) 

#define IAnalogAudioComponentType_get_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> get_MediaFormatType(This,MediaFormatType) ) 

#define IAnalogAudioComponentType_put_MediaFormatType(This,MediaFormatType)	\
    ( (This)->lpVtbl -> put_MediaFormatType(This,MediaFormatType) ) 

#define IAnalogAudioComponentType_get__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> get__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define IAnalogAudioComponentType_put__MediaFormatType(This,MediaFormatTypeGuid)	\
    ( (This)->lpVtbl -> put__MediaFormatType(This,MediaFormatTypeGuid) ) 

#define IAnalogAudioComponentType_get_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,MediaType) ) 

#define IAnalogAudioComponentType_put_MediaType(This,MediaType)	\
    ( (This)->lpVtbl -> put_MediaType(This,MediaType) ) 

#define IAnalogAudioComponentType_Clone(This,NewCT)	\
    ( (This)->lpVtbl -> Clone(This,NewCT) ) 


#define IAnalogAudioComponentType_get_AnalogAudioMode(This,Mode)	\
    ( (This)->lpVtbl -> get_AnalogAudioMode(This,Mode) ) 

#define IAnalogAudioComponentType_put_AnalogAudioMode(This,Mode)	\
    ( (This)->lpVtbl -> put_AnalogAudioMode(This,Mode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAnalogAudioComponentType_INTERFACE_DEFINED__ */


#ifndef __IMPEG2Component_INTERFACE_DEFINED__
#define __IMPEG2Component_INTERFACE_DEFINED__

/* interface IMPEG2Component */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IMPEG2Component;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1493E353-1EB6-473c-802D-8E6B8EC9D2A9")
    IMPEG2Component : public IComponent
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PID( 
            /* [retval][out] */ __RPC__out long *PID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PID( 
            /* [in] */ long PID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PCRPID( 
            /* [retval][out] */ __RPC__out long *PCRPID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PCRPID( 
            /* [in] */ long PCRPID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProgramNumber( 
            /* [retval][out] */ __RPC__out long *ProgramNumber) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProgramNumber( 
            /* [in] */ long ProgramNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2ComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2Component * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2Component * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2Component * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMPEG2Component * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMPEG2Component * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMPEG2Component * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMPEG2Component * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IMPEG2Component * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponentType **CT);
        
        /* [helpstring][id][propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Type )( 
            IMPEG2Component * This,
            /* [in] */ __RPC__in_opt IComponentType *CT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DescLangID )( 
            IMPEG2Component * This,
            /* [retval][out] */ __RPC__out long *LangID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DescLangID )( 
            IMPEG2Component * This,
            /* [in] */ long LangID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMPEG2Component * This,
            /* [retval][out] */ __RPC__out ComponentStatus *Status);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Status )( 
            IMPEG2Component * This,
            /* [in] */ ComponentStatus Status);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IMPEG2Component * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Description);
        
        /* [helpstring][id][propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IMPEG2Component * This,
            /* [in] */ __RPC__in BSTR Description);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMPEG2Component * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponent **NewComponent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PID )( 
            IMPEG2Component * This,
            /* [retval][out] */ __RPC__out long *PID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PID )( 
            IMPEG2Component * This,
            /* [in] */ long PID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PCRPID )( 
            IMPEG2Component * This,
            /* [retval][out] */ __RPC__out long *PCRPID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PCRPID )( 
            IMPEG2Component * This,
            /* [in] */ long PCRPID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProgramNumber )( 
            IMPEG2Component * This,
            /* [retval][out] */ __RPC__out long *ProgramNumber);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProgramNumber )( 
            IMPEG2Component * This,
            /* [in] */ long ProgramNumber);
        
        END_INTERFACE
    } IMPEG2ComponentVtbl;

    interface IMPEG2Component
    {
        CONST_VTBL struct IMPEG2ComponentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2Component_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMPEG2Component_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMPEG2Component_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMPEG2Component_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMPEG2Component_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMPEG2Component_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMPEG2Component_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMPEG2Component_get_Type(This,CT)	\
    ( (This)->lpVtbl -> get_Type(This,CT) ) 

#define IMPEG2Component_put_Type(This,CT)	\
    ( (This)->lpVtbl -> put_Type(This,CT) ) 

#define IMPEG2Component_get_DescLangID(This,LangID)	\
    ( (This)->lpVtbl -> get_DescLangID(This,LangID) ) 

#define IMPEG2Component_put_DescLangID(This,LangID)	\
    ( (This)->lpVtbl -> put_DescLangID(This,LangID) ) 

#define IMPEG2Component_get_Status(This,Status)	\
    ( (This)->lpVtbl -> get_Status(This,Status) ) 

#define IMPEG2Component_put_Status(This,Status)	\
    ( (This)->lpVtbl -> put_Status(This,Status) ) 

#define IMPEG2Component_get_Description(This,Description)	\
    ( (This)->lpVtbl -> get_Description(This,Description) ) 

#define IMPEG2Component_put_Description(This,Description)	\
    ( (This)->lpVtbl -> put_Description(This,Description) ) 

#define IMPEG2Component_Clone(This,NewComponent)	\
    ( (This)->lpVtbl -> Clone(This,NewComponent) ) 


#define IMPEG2Component_get_PID(This,PID)	\
    ( (This)->lpVtbl -> get_PID(This,PID) ) 

#define IMPEG2Component_put_PID(This,PID)	\
    ( (This)->lpVtbl -> put_PID(This,PID) ) 

#define IMPEG2Component_get_PCRPID(This,PCRPID)	\
    ( (This)->lpVtbl -> get_PCRPID(This,PCRPID) ) 

#define IMPEG2Component_put_PCRPID(This,PCRPID)	\
    ( (This)->lpVtbl -> put_PCRPID(This,PCRPID) ) 

#define IMPEG2Component_get_ProgramNumber(This,ProgramNumber)	\
    ( (This)->lpVtbl -> get_ProgramNumber(This,ProgramNumber) ) 

#define IMPEG2Component_put_ProgramNumber(This,ProgramNumber)	\
    ( (This)->lpVtbl -> put_ProgramNumber(This,ProgramNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMPEG2Component_INTERFACE_DEFINED__ */


#ifndef __IEnumComponents_INTERFACE_DEFINED__
#define __IEnumComponents_INTERFACE_DEFINED__

/* interface IEnumComponents */
/* [unique][uuid][object][restricted][hidden] */ 


EXTERN_C const IID IID_IEnumComponents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A6E2939-2595-11d3-B64C-00C04F79498E")
    IEnumComponents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IComponent **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumComponents **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumComponentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumComponents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumComponents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumComponents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumComponents * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IComponent **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumComponents * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumComponents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumComponents * This,
            /* [out] */ __RPC__deref_out_opt IEnumComponents **ppEnum);
        
        END_INTERFACE
    } IEnumComponentsVtbl;

    interface IEnumComponents
    {
        CONST_VTBL struct IEnumComponentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumComponents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumComponents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumComponents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumComponents_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumComponents_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumComponents_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumComponents_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumComponents_INTERFACE_DEFINED__ */


#ifndef __IComponents_INTERFACE_DEFINED__
#define __IComponents_INTERFACE_DEFINED__

/* interface IComponents */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IComponents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39A48091-FFFE-4182-A161-3FF802640E26")
    IComponents : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *Count) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppNewEnum) = 0;
        
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE EnumComponents( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumComponents **ppNewEnum) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt IComponent **ppComponent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IComponent *Component,
            /* [retval][out] */ __RPC__out VARIANT *NewIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IComponents **NewList) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT Index,
            /* [in] */ __RPC__in_opt IComponent *ppComponent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComponents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComponents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComponents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IComponents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComponents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IComponents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IComponents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IComponents * This,
            /* [retval][out] */ __RPC__out long *Count);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IComponents * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppNewEnum);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumComponents )( 
            IComponents * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumComponents **ppNewEnum);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IComponents * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt IComponent **ppComponent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IComponents * This,
            /* [in] */ __RPC__in_opt IComponent *Component,
            /* [retval][out] */ __RPC__out VARIANT *NewIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IComponents * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IComponents * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponents **NewList);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Item )( 
            IComponents * This,
            /* [in] */ VARIANT Index,
            /* [in] */ __RPC__in_opt IComponent *ppComponent);
        
        END_INTERFACE
    } IComponentsVtbl;

    interface IComponents
    {
        CONST_VTBL struct IComponentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComponents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComponents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComponents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IComponents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IComponents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IComponents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IComponents_get_Count(This,Count)	\
    ( (This)->lpVtbl -> get_Count(This,Count) ) 

#define IComponents_get__NewEnum(This,ppNewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppNewEnum) ) 

#define IComponents_EnumComponents(This,ppNewEnum)	\
    ( (This)->lpVtbl -> EnumComponents(This,ppNewEnum) ) 

#define IComponents_get_Item(This,Index,ppComponent)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppComponent) ) 

#define IComponents_Add(This,Component,NewIndex)	\
    ( (This)->lpVtbl -> Add(This,Component,NewIndex) ) 

#define IComponents_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IComponents_Clone(This,NewList)	\
    ( (This)->lpVtbl -> Clone(This,NewList) ) 

#define IComponents_put_Item(This,Index,ppComponent)	\
    ( (This)->lpVtbl -> put_Item(This,Index,ppComponent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComponents_INTERFACE_DEFINED__ */


#ifndef __IComponentsOld_INTERFACE_DEFINED__
#define __IComponentsOld_INTERFACE_DEFINED__

/* interface IComponentsOld */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IComponentsOld;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FCD01846-0E19-11d3-9D8E-00C04F72D980")
    IComponentsOld : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *Count) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppNewEnum) = 0;
        
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE EnumComponents( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumComponents **ppNewEnum) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt IComponent **ppComponent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IComponent *Component,
            /* [retval][out] */ __RPC__out VARIANT *NewIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IComponents **NewList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentsOldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComponentsOld * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComponentsOld * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComponentsOld * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IComponentsOld * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComponentsOld * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IComponentsOld * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IComponentsOld * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IComponentsOld * This,
            /* [retval][out] */ __RPC__out long *Count);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IComponentsOld * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppNewEnum);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumComponents )( 
            IComponentsOld * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumComponents **ppNewEnum);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IComponentsOld * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt IComponent **ppComponent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IComponentsOld * This,
            /* [in] */ __RPC__in_opt IComponent *Component,
            /* [retval][out] */ __RPC__out VARIANT *NewIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IComponentsOld * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IComponentsOld * This,
            /* [retval][out] */ __RPC__deref_out_opt IComponents **NewList);
        
        END_INTERFACE
    } IComponentsOldVtbl;

    interface IComponentsOld
    {
        CONST_VTBL struct IComponentsOldVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentsOld_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComponentsOld_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComponentsOld_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComponentsOld_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IComponentsOld_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IComponentsOld_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IComponentsOld_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IComponentsOld_get_Count(This,Count)	\
    ( (This)->lpVtbl -> get_Count(This,Count) ) 

#define IComponentsOld_get__NewEnum(This,ppNewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppNewEnum) ) 

#define IComponentsOld_EnumComponents(This,ppNewEnum)	\
    ( (This)->lpVtbl -> EnumComponents(This,ppNewEnum) ) 

#define IComponentsOld_get_Item(This,Index,ppComponent)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppComponent) ) 

#define IComponentsOld_Add(This,Component,NewIndex)	\
    ( (This)->lpVtbl -> Add(This,Component,NewIndex) ) 

#define IComponentsOld_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IComponentsOld_Clone(This,NewList)	\
    ( (This)->lpVtbl -> Clone(This,NewList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComponentsOld_INTERFACE_DEFINED__ */


#ifndef __ILocator_INTERFACE_DEFINED__
#define __ILocator_INTERFACE_DEFINED__

/* interface ILocator */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_ILocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("286D7F89-760C-4F89-80C4-66841D2507AA")
    ILocator : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CarrierFrequency( 
            /* [retval][out] */ __RPC__out long *Frequency) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CarrierFrequency( 
            /* [in] */ long Frequency) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InnerFEC( 
            /* [retval][out] */ __RPC__out FECMethod *FEC) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_InnerFEC( 
            /* [in] */ FECMethod FEC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InnerFECRate( 
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_InnerFECRate( 
            /* [in] */ BinaryConvolutionCodeRate FEC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OuterFEC( 
            /* [retval][out] */ __RPC__out FECMethod *FEC) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OuterFEC( 
            /* [in] */ FECMethod FEC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OuterFECRate( 
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OuterFECRate( 
            /* [in] */ BinaryConvolutionCodeRate FEC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Modulation( 
            /* [retval][out] */ __RPC__out ModulationType *Modulation) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Modulation( 
            /* [in] */ ModulationType Modulation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SymbolRate( 
            /* [retval][out] */ __RPC__out long *Rate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SymbolRate( 
            /* [in] */ long Rate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            ILocator * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            ILocator * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            ILocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            ILocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            ILocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            ILocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            ILocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            ILocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            ILocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            ILocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            ILocator * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            ILocator * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            ILocator * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            ILocator * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ILocator * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        END_INTERFACE
    } ILocatorVtbl;

    interface ILocator
    {
        CONST_VTBL struct ILocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ILocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ILocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ILocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ILocator_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define ILocator_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define ILocator_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define ILocator_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define ILocator_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define ILocator_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define ILocator_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define ILocator_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define ILocator_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define ILocator_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define ILocator_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define ILocator_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define ILocator_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define ILocator_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define ILocator_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocator_INTERFACE_DEFINED__ */


#ifndef __IAnalogLocator_INTERFACE_DEFINED__
#define __IAnalogLocator_INTERFACE_DEFINED__

/* interface IAnalogLocator */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IAnalogLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34D1F26B-E339-430D-ABCE-738CB48984DC")
    IAnalogLocator : public ILocator
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VideoStandard( 
            /* [retval][out] */ __RPC__out AnalogVideoStandard *AVS) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_VideoStandard( 
            /* [in] */ AnalogVideoStandard AVS) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalogLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalogLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalogLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalogLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAnalogLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAnalogLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAnalogLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAnalogLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            IAnalogLocator * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            IAnalogLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IAnalogLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            IAnalogLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IAnalogLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            IAnalogLocator * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IAnalogLocator * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoStandard )( 
            IAnalogLocator * This,
            /* [retval][out] */ __RPC__out AnalogVideoStandard *AVS);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_VideoStandard )( 
            IAnalogLocator * This,
            /* [in] */ AnalogVideoStandard AVS);
        
        END_INTERFACE
    } IAnalogLocatorVtbl;

    interface IAnalogLocator
    {
        CONST_VTBL struct IAnalogLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalogLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAnalogLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAnalogLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAnalogLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAnalogLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAnalogLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAnalogLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAnalogLocator_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define IAnalogLocator_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define IAnalogLocator_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define IAnalogLocator_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define IAnalogLocator_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define IAnalogLocator_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define IAnalogLocator_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define IAnalogLocator_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define IAnalogLocator_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define IAnalogLocator_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define IAnalogLocator_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define IAnalogLocator_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define IAnalogLocator_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define IAnalogLocator_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define IAnalogLocator_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 


#define IAnalogLocator_get_VideoStandard(This,AVS)	\
    ( (This)->lpVtbl -> get_VideoStandard(This,AVS) ) 

#define IAnalogLocator_put_VideoStandard(This,AVS)	\
    ( (This)->lpVtbl -> put_VideoStandard(This,AVS) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAnalogLocator_INTERFACE_DEFINED__ */


#ifndef __IDigitalLocator_INTERFACE_DEFINED__
#define __IDigitalLocator_INTERFACE_DEFINED__

/* interface IDigitalLocator */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][object] */ 


EXTERN_C const IID IID_IDigitalLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19B595D8-839A-47F0-96DF-4F194F3C768C")
    IDigitalLocator : public ILocator
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDigitalLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDigitalLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDigitalLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDigitalLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDigitalLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDigitalLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDigitalLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDigitalLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            IDigitalLocator * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            IDigitalLocator * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            IDigitalLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            IDigitalLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IDigitalLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IDigitalLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            IDigitalLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            IDigitalLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IDigitalLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IDigitalLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            IDigitalLocator * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            IDigitalLocator * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IDigitalLocator * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IDigitalLocator * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDigitalLocator * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        END_INTERFACE
    } IDigitalLocatorVtbl;

    interface IDigitalLocator
    {
        CONST_VTBL struct IDigitalLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDigitalLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDigitalLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDigitalLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDigitalLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDigitalLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDigitalLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDigitalLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDigitalLocator_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define IDigitalLocator_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define IDigitalLocator_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define IDigitalLocator_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define IDigitalLocator_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define IDigitalLocator_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define IDigitalLocator_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define IDigitalLocator_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define IDigitalLocator_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define IDigitalLocator_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define IDigitalLocator_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define IDigitalLocator_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define IDigitalLocator_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define IDigitalLocator_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define IDigitalLocator_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDigitalLocator_INTERFACE_DEFINED__ */


#ifndef __IATSCLocator_INTERFACE_DEFINED__
#define __IATSCLocator_INTERFACE_DEFINED__

/* interface IATSCLocator */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IATSCLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BF8D986F-8C2B-4131-94D7-4D3D9FCC21EF")
    IATSCLocator : public IDigitalLocator
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhysicalChannel( 
            /* [retval][out] */ __RPC__out long *PhysicalChannel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PhysicalChannel( 
            /* [in] */ long PhysicalChannel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ __RPC__out long *TSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TSID( 
            /* [in] */ long TSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IATSCLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IATSCLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IATSCLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IATSCLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IATSCLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IATSCLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IATSCLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IATSCLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            IATSCLocator * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            IATSCLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IATSCLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            IATSCLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IATSCLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            IATSCLocator * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IATSCLocator * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhysicalChannel )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out long *PhysicalChannel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PhysicalChannel )( 
            IATSCLocator * This,
            /* [in] */ long PhysicalChannel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IATSCLocator * This,
            /* [retval][out] */ __RPC__out long *TSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IATSCLocator * This,
            /* [in] */ long TSID);
        
        END_INTERFACE
    } IATSCLocatorVtbl;

    interface IATSCLocator
    {
        CONST_VTBL struct IATSCLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IATSCLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IATSCLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IATSCLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IATSCLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IATSCLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IATSCLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IATSCLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IATSCLocator_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define IATSCLocator_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define IATSCLocator_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define IATSCLocator_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define IATSCLocator_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define IATSCLocator_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define IATSCLocator_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define IATSCLocator_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define IATSCLocator_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define IATSCLocator_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define IATSCLocator_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define IATSCLocator_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define IATSCLocator_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define IATSCLocator_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define IATSCLocator_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 



#define IATSCLocator_get_PhysicalChannel(This,PhysicalChannel)	\
    ( (This)->lpVtbl -> get_PhysicalChannel(This,PhysicalChannel) ) 

#define IATSCLocator_put_PhysicalChannel(This,PhysicalChannel)	\
    ( (This)->lpVtbl -> put_PhysicalChannel(This,PhysicalChannel) ) 

#define IATSCLocator_get_TSID(This,TSID)	\
    ( (This)->lpVtbl -> get_TSID(This,TSID) ) 

#define IATSCLocator_put_TSID(This,TSID)	\
    ( (This)->lpVtbl -> put_TSID(This,TSID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IATSCLocator_INTERFACE_DEFINED__ */


#ifndef __IATSCLocator2_INTERFACE_DEFINED__
#define __IATSCLocator2_INTERFACE_DEFINED__

/* interface IATSCLocator2 */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IATSCLocator2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("612AA885-66CF-4090-BA0A-566F5312E4CA")
    IATSCLocator2 : public IATSCLocator
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProgramNumber( 
            /* [retval][out] */ __RPC__out long *ProgramNumber) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProgramNumber( 
            /* [in] */ long ProgramNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IATSCLocator2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IATSCLocator2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IATSCLocator2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IATSCLocator2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IATSCLocator2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IATSCLocator2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IATSCLocator2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IATSCLocator2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            IATSCLocator2 * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            IATSCLocator2 * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IATSCLocator2 * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            IATSCLocator2 * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IATSCLocator2 * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            IATSCLocator2 * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IATSCLocator2 * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhysicalChannel )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out long *PhysicalChannel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PhysicalChannel )( 
            IATSCLocator2 * This,
            /* [in] */ long PhysicalChannel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out long *TSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IATSCLocator2 * This,
            /* [in] */ long TSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProgramNumber )( 
            IATSCLocator2 * This,
            /* [retval][out] */ __RPC__out long *ProgramNumber);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProgramNumber )( 
            IATSCLocator2 * This,
            /* [in] */ long ProgramNumber);
        
        END_INTERFACE
    } IATSCLocator2Vtbl;

    interface IATSCLocator2
    {
        CONST_VTBL struct IATSCLocator2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IATSCLocator2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IATSCLocator2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IATSCLocator2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IATSCLocator2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IATSCLocator2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IATSCLocator2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IATSCLocator2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IATSCLocator2_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define IATSCLocator2_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define IATSCLocator2_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define IATSCLocator2_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define IATSCLocator2_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define IATSCLocator2_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define IATSCLocator2_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define IATSCLocator2_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define IATSCLocator2_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define IATSCLocator2_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define IATSCLocator2_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define IATSCLocator2_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define IATSCLocator2_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define IATSCLocator2_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define IATSCLocator2_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 



#define IATSCLocator2_get_PhysicalChannel(This,PhysicalChannel)	\
    ( (This)->lpVtbl -> get_PhysicalChannel(This,PhysicalChannel) ) 

#define IATSCLocator2_put_PhysicalChannel(This,PhysicalChannel)	\
    ( (This)->lpVtbl -> put_PhysicalChannel(This,PhysicalChannel) ) 

#define IATSCLocator2_get_TSID(This,TSID)	\
    ( (This)->lpVtbl -> get_TSID(This,TSID) ) 

#define IATSCLocator2_put_TSID(This,TSID)	\
    ( (This)->lpVtbl -> put_TSID(This,TSID) ) 


#define IATSCLocator2_get_ProgramNumber(This,ProgramNumber)	\
    ( (This)->lpVtbl -> get_ProgramNumber(This,ProgramNumber) ) 

#define IATSCLocator2_put_ProgramNumber(This,ProgramNumber)	\
    ( (This)->lpVtbl -> put_ProgramNumber(This,ProgramNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IATSCLocator2_INTERFACE_DEFINED__ */


#ifndef __IDigitalCableLocator_INTERFACE_DEFINED__
#define __IDigitalCableLocator_INTERFACE_DEFINED__

/* interface IDigitalCableLocator */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IDigitalCableLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48F66A11-171A-419A-9525-BEEECD51584C")
    IDigitalCableLocator : public IATSCLocator2
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDigitalCableLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDigitalCableLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDigitalCableLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDigitalCableLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDigitalCableLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDigitalCableLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDigitalCableLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDigitalCableLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            IDigitalCableLocator * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            IDigitalCableLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IDigitalCableLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            IDigitalCableLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IDigitalCableLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            IDigitalCableLocator * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IDigitalCableLocator * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhysicalChannel )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out long *PhysicalChannel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PhysicalChannel )( 
            IDigitalCableLocator * This,
            /* [in] */ long PhysicalChannel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out long *TSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IDigitalCableLocator * This,
            /* [in] */ long TSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProgramNumber )( 
            IDigitalCableLocator * This,
            /* [retval][out] */ __RPC__out long *ProgramNumber);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProgramNumber )( 
            IDigitalCableLocator * This,
            /* [in] */ long ProgramNumber);
        
        END_INTERFACE
    } IDigitalCableLocatorVtbl;

    interface IDigitalCableLocator
    {
        CONST_VTBL struct IDigitalCableLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDigitalCableLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDigitalCableLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDigitalCableLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDigitalCableLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDigitalCableLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDigitalCableLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDigitalCableLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDigitalCableLocator_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define IDigitalCableLocator_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define IDigitalCableLocator_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define IDigitalCableLocator_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define IDigitalCableLocator_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define IDigitalCableLocator_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define IDigitalCableLocator_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define IDigitalCableLocator_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define IDigitalCableLocator_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define IDigitalCableLocator_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define IDigitalCableLocator_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define IDigitalCableLocator_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define IDigitalCableLocator_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define IDigitalCableLocator_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define IDigitalCableLocator_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 



#define IDigitalCableLocator_get_PhysicalChannel(This,PhysicalChannel)	\
    ( (This)->lpVtbl -> get_PhysicalChannel(This,PhysicalChannel) ) 

#define IDigitalCableLocator_put_PhysicalChannel(This,PhysicalChannel)	\
    ( (This)->lpVtbl -> put_PhysicalChannel(This,PhysicalChannel) ) 

#define IDigitalCableLocator_get_TSID(This,TSID)	\
    ( (This)->lpVtbl -> get_TSID(This,TSID) ) 

#define IDigitalCableLocator_put_TSID(This,TSID)	\
    ( (This)->lpVtbl -> put_TSID(This,TSID) ) 


#define IDigitalCableLocator_get_ProgramNumber(This,ProgramNumber)	\
    ( (This)->lpVtbl -> get_ProgramNumber(This,ProgramNumber) ) 

#define IDigitalCableLocator_put_ProgramNumber(This,ProgramNumber)	\
    ( (This)->lpVtbl -> put_ProgramNumber(This,ProgramNumber) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDigitalCableLocator_INTERFACE_DEFINED__ */


#ifndef __IDVBTLocator_INTERFACE_DEFINED__
#define __IDVBTLocator_INTERFACE_DEFINED__

/* interface IDVBTLocator */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IDVBTLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8664DA16-DDA2-42ac-926A-C18F9127C302")
    IDVBTLocator : public IDigitalLocator
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Bandwidth( 
            /* [retval][out] */ __RPC__out long *BandWidthVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Bandwidth( 
            /* [in] */ long BandwidthVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LPInnerFEC( 
            /* [retval][out] */ __RPC__out FECMethod *FEC) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LPInnerFEC( 
            /* [in] */ FECMethod FEC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LPInnerFECRate( 
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LPInnerFECRate( 
            /* [in] */ BinaryConvolutionCodeRate FEC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HAlpha( 
            /* [retval][out] */ __RPC__out HierarchyAlpha *Alpha) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HAlpha( 
            /* [in] */ HierarchyAlpha Alpha) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Guard( 
            /* [retval][out] */ __RPC__out GuardInterval *GI) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Guard( 
            /* [in] */ GuardInterval GI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [retval][out] */ __RPC__out TransmissionMode *mode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ TransmissionMode mode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OtherFrequencyInUse( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *OtherFrequencyInUseVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OtherFrequencyInUse( 
            /* [in] */ VARIANT_BOOL OtherFrequencyInUseVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVBTLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVBTLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVBTLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVBTLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDVBTLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDVBTLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDVBTLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDVBTLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            IDVBTLocator * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            IDVBTLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IDVBTLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            IDVBTLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IDVBTLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            IDVBTLocator * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IDVBTLocator * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out long *BandWidthVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Bandwidth )( 
            IDVBTLocator * This,
            /* [in] */ long BandwidthVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LPInnerFEC )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LPInnerFEC )( 
            IDVBTLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LPInnerFECRate )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LPInnerFECRate )( 
            IDVBTLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HAlpha )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out HierarchyAlpha *Alpha);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HAlpha )( 
            IDVBTLocator * This,
            /* [in] */ HierarchyAlpha Alpha);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Guard )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out GuardInterval *GI);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Guard )( 
            IDVBTLocator * This,
            /* [in] */ GuardInterval GI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out TransmissionMode *mode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IDVBTLocator * This,
            /* [in] */ TransmissionMode mode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OtherFrequencyInUse )( 
            IDVBTLocator * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *OtherFrequencyInUseVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OtherFrequencyInUse )( 
            IDVBTLocator * This,
            /* [in] */ VARIANT_BOOL OtherFrequencyInUseVal);
        
        END_INTERFACE
    } IDVBTLocatorVtbl;

    interface IDVBTLocator
    {
        CONST_VTBL struct IDVBTLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVBTLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVBTLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVBTLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVBTLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDVBTLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDVBTLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDVBTLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDVBTLocator_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define IDVBTLocator_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define IDVBTLocator_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define IDVBTLocator_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define IDVBTLocator_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define IDVBTLocator_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define IDVBTLocator_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define IDVBTLocator_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define IDVBTLocator_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define IDVBTLocator_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define IDVBTLocator_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define IDVBTLocator_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define IDVBTLocator_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define IDVBTLocator_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define IDVBTLocator_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 



#define IDVBTLocator_get_Bandwidth(This,BandWidthVal)	\
    ( (This)->lpVtbl -> get_Bandwidth(This,BandWidthVal) ) 

#define IDVBTLocator_put_Bandwidth(This,BandwidthVal)	\
    ( (This)->lpVtbl -> put_Bandwidth(This,BandwidthVal) ) 

#define IDVBTLocator_get_LPInnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_LPInnerFEC(This,FEC) ) 

#define IDVBTLocator_put_LPInnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_LPInnerFEC(This,FEC) ) 

#define IDVBTLocator_get_LPInnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_LPInnerFECRate(This,FEC) ) 

#define IDVBTLocator_put_LPInnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_LPInnerFECRate(This,FEC) ) 

#define IDVBTLocator_get_HAlpha(This,Alpha)	\
    ( (This)->lpVtbl -> get_HAlpha(This,Alpha) ) 

#define IDVBTLocator_put_HAlpha(This,Alpha)	\
    ( (This)->lpVtbl -> put_HAlpha(This,Alpha) ) 

#define IDVBTLocator_get_Guard(This,GI)	\
    ( (This)->lpVtbl -> get_Guard(This,GI) ) 

#define IDVBTLocator_put_Guard(This,GI)	\
    ( (This)->lpVtbl -> put_Guard(This,GI) ) 

#define IDVBTLocator_get_Mode(This,mode)	\
    ( (This)->lpVtbl -> get_Mode(This,mode) ) 

#define IDVBTLocator_put_Mode(This,mode)	\
    ( (This)->lpVtbl -> put_Mode(This,mode) ) 

#define IDVBTLocator_get_OtherFrequencyInUse(This,OtherFrequencyInUseVal)	\
    ( (This)->lpVtbl -> get_OtherFrequencyInUse(This,OtherFrequencyInUseVal) ) 

#define IDVBTLocator_put_OtherFrequencyInUse(This,OtherFrequencyInUseVal)	\
    ( (This)->lpVtbl -> put_OtherFrequencyInUse(This,OtherFrequencyInUseVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVBTLocator_INTERFACE_DEFINED__ */


#ifndef __IDVBSLocator_INTERFACE_DEFINED__
#define __IDVBSLocator_INTERFACE_DEFINED__

/* interface IDVBSLocator */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IDVBSLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D7C353C-0D04-45f1-A742-F97CC1188DC8")
    IDVBSLocator : public IDigitalLocator
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignalPolarisation( 
            /* [retval][out] */ __RPC__out Polarisation *PolarisationVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SignalPolarisation( 
            /* [in] */ Polarisation PolarisationVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WestPosition( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *WestLongitude) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_WestPosition( 
            /* [in] */ VARIANT_BOOL WestLongitude) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OrbitalPosition( 
            /* [retval][out] */ __RPC__out long *longitude) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OrbitalPosition( 
            /* [in] */ long longitude) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Azimuth( 
            /* [retval][out] */ __RPC__out long *Azimuth) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Azimuth( 
            /* [in] */ long Azimuth) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Elevation( 
            /* [retval][out] */ __RPC__out long *Elevation) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Elevation( 
            /* [in] */ long Elevation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVBSLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVBSLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVBSLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVBSLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDVBSLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDVBSLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDVBSLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDVBSLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            IDVBSLocator * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            IDVBSLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IDVBSLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            IDVBSLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IDVBSLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            IDVBSLocator * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IDVBSLocator * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignalPolarisation )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out Polarisation *PolarisationVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SignalPolarisation )( 
            IDVBSLocator * This,
            /* [in] */ Polarisation PolarisationVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WestPosition )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *WestLongitude);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WestPosition )( 
            IDVBSLocator * This,
            /* [in] */ VARIANT_BOOL WestLongitude);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OrbitalPosition )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out long *longitude);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OrbitalPosition )( 
            IDVBSLocator * This,
            /* [in] */ long longitude);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Azimuth )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out long *Azimuth);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Azimuth )( 
            IDVBSLocator * This,
            /* [in] */ long Azimuth);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Elevation )( 
            IDVBSLocator * This,
            /* [retval][out] */ __RPC__out long *Elevation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Elevation )( 
            IDVBSLocator * This,
            /* [in] */ long Elevation);
        
        END_INTERFACE
    } IDVBSLocatorVtbl;

    interface IDVBSLocator
    {
        CONST_VTBL struct IDVBSLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVBSLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVBSLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVBSLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVBSLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDVBSLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDVBSLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDVBSLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDVBSLocator_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define IDVBSLocator_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define IDVBSLocator_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define IDVBSLocator_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define IDVBSLocator_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define IDVBSLocator_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define IDVBSLocator_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define IDVBSLocator_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define IDVBSLocator_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define IDVBSLocator_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define IDVBSLocator_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define IDVBSLocator_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define IDVBSLocator_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define IDVBSLocator_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define IDVBSLocator_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 



#define IDVBSLocator_get_SignalPolarisation(This,PolarisationVal)	\
    ( (This)->lpVtbl -> get_SignalPolarisation(This,PolarisationVal) ) 

#define IDVBSLocator_put_SignalPolarisation(This,PolarisationVal)	\
    ( (This)->lpVtbl -> put_SignalPolarisation(This,PolarisationVal) ) 

#define IDVBSLocator_get_WestPosition(This,WestLongitude)	\
    ( (This)->lpVtbl -> get_WestPosition(This,WestLongitude) ) 

#define IDVBSLocator_put_WestPosition(This,WestLongitude)	\
    ( (This)->lpVtbl -> put_WestPosition(This,WestLongitude) ) 

#define IDVBSLocator_get_OrbitalPosition(This,longitude)	\
    ( (This)->lpVtbl -> get_OrbitalPosition(This,longitude) ) 

#define IDVBSLocator_put_OrbitalPosition(This,longitude)	\
    ( (This)->lpVtbl -> put_OrbitalPosition(This,longitude) ) 

#define IDVBSLocator_get_Azimuth(This,Azimuth)	\
    ( (This)->lpVtbl -> get_Azimuth(This,Azimuth) ) 

#define IDVBSLocator_put_Azimuth(This,Azimuth)	\
    ( (This)->lpVtbl -> put_Azimuth(This,Azimuth) ) 

#define IDVBSLocator_get_Elevation(This,Elevation)	\
    ( (This)->lpVtbl -> get_Elevation(This,Elevation) ) 

#define IDVBSLocator_put_Elevation(This,Elevation)	\
    ( (This)->lpVtbl -> put_Elevation(This,Elevation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVBSLocator_INTERFACE_DEFINED__ */


#ifndef __IDVBCLocator_INTERFACE_DEFINED__
#define __IDVBCLocator_INTERFACE_DEFINED__

/* interface IDVBCLocator */
/* [unique][helpstring][oleautomation][dual][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IDVBCLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6E42F36E-1DD2-43c4-9F78-69D25AE39034")
    IDVBCLocator : public IDigitalLocator
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDVBCLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVBCLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVBCLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVBCLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDVBCLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDVBCLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDVBCLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDVBCLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CarrierFrequency )( 
            IDVBCLocator * This,
            /* [retval][out] */ __RPC__out long *Frequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CarrierFrequency )( 
            IDVBCLocator * This,
            /* [in] */ long Frequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFEC )( 
            IDVBCLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFEC )( 
            IDVBCLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InnerFECRate )( 
            IDVBCLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InnerFECRate )( 
            IDVBCLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFEC )( 
            IDVBCLocator * This,
            /* [retval][out] */ __RPC__out FECMethod *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFEC )( 
            IDVBCLocator * This,
            /* [in] */ FECMethod FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OuterFECRate )( 
            IDVBCLocator * This,
            /* [retval][out] */ __RPC__out BinaryConvolutionCodeRate *FEC);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OuterFECRate )( 
            IDVBCLocator * This,
            /* [in] */ BinaryConvolutionCodeRate FEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Modulation )( 
            IDVBCLocator * This,
            /* [retval][out] */ __RPC__out ModulationType *Modulation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Modulation )( 
            IDVBCLocator * This,
            /* [in] */ ModulationType Modulation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SymbolRate )( 
            IDVBCLocator * This,
            /* [retval][out] */ __RPC__out long *Rate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SymbolRate )( 
            IDVBCLocator * This,
            /* [in] */ long Rate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDVBCLocator * This,
            /* [retval][out] */ __RPC__deref_out_opt ILocator **NewLocator);
        
        END_INTERFACE
    } IDVBCLocatorVtbl;

    interface IDVBCLocator
    {
        CONST_VTBL struct IDVBCLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVBCLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVBCLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVBCLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVBCLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDVBCLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDVBCLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDVBCLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDVBCLocator_get_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> get_CarrierFrequency(This,Frequency) ) 

#define IDVBCLocator_put_CarrierFrequency(This,Frequency)	\
    ( (This)->lpVtbl -> put_CarrierFrequency(This,Frequency) ) 

#define IDVBCLocator_get_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFEC(This,FEC) ) 

#define IDVBCLocator_put_InnerFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFEC(This,FEC) ) 

#define IDVBCLocator_get_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_InnerFECRate(This,FEC) ) 

#define IDVBCLocator_put_InnerFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_InnerFECRate(This,FEC) ) 

#define IDVBCLocator_get_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFEC(This,FEC) ) 

#define IDVBCLocator_put_OuterFEC(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFEC(This,FEC) ) 

#define IDVBCLocator_get_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> get_OuterFECRate(This,FEC) ) 

#define IDVBCLocator_put_OuterFECRate(This,FEC)	\
    ( (This)->lpVtbl -> put_OuterFECRate(This,FEC) ) 

#define IDVBCLocator_get_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> get_Modulation(This,Modulation) ) 

#define IDVBCLocator_put_Modulation(This,Modulation)	\
    ( (This)->lpVtbl -> put_Modulation(This,Modulation) ) 

#define IDVBCLocator_get_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> get_SymbolRate(This,Rate) ) 

#define IDVBCLocator_put_SymbolRate(This,Rate)	\
    ( (This)->lpVtbl -> put_SymbolRate(This,Rate) ) 

#define IDVBCLocator_Clone(This,NewLocator)	\
    ( (This)->lpVtbl -> Clone(This,NewLocator) ) 



#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVBCLocator_INTERFACE_DEFINED__ */


#ifndef __IBroadcastEvent_INTERFACE_DEFINED__
#define __IBroadcastEvent_INTERFACE_DEFINED__

/* interface IBroadcastEvent */
/* [unique][helpstring][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IBroadcastEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B21263F-26E8-489d-AAC4-924F7EFD9511")
    IBroadcastEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Fire( 
            /* [in] */ GUID EventID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBroadcastEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBroadcastEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBroadcastEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBroadcastEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Fire )( 
            IBroadcastEvent * This,
            /* [in] */ GUID EventID);
        
        END_INTERFACE
    } IBroadcastEventVtbl;

    interface IBroadcastEvent
    {
        CONST_VTBL struct IBroadcastEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBroadcastEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBroadcastEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBroadcastEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBroadcastEvent_Fire(This,EventID)	\
    ( (This)->lpVtbl -> Fire(This,EventID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBroadcastEvent_INTERFACE_DEFINED__ */


#ifndef __IBroadcastEventEx_INTERFACE_DEFINED__
#define __IBroadcastEventEx_INTERFACE_DEFINED__

/* interface IBroadcastEventEx */
/* [unique][helpstring][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IBroadcastEventEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d9e3887-1929-423f-8021-43682de95448")
    IBroadcastEventEx : public IBroadcastEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FireEx( 
            /* [in] */ GUID EventID,
            /* [in] */ ULONG Param1,
            /* [in] */ ULONG Param2,
            /* [in] */ ULONG Param3,
            /* [in] */ ULONG Param4) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBroadcastEventExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBroadcastEventEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBroadcastEventEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBroadcastEventEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Fire )( 
            IBroadcastEventEx * This,
            /* [in] */ GUID EventID);
        
        HRESULT ( STDMETHODCALLTYPE *FireEx )( 
            IBroadcastEventEx * This,
            /* [in] */ GUID EventID,
            /* [in] */ ULONG Param1,
            /* [in] */ ULONG Param2,
            /* [in] */ ULONG Param3,
            /* [in] */ ULONG Param4);
        
        END_INTERFACE
    } IBroadcastEventExVtbl;

    interface IBroadcastEventEx
    {
        CONST_VTBL struct IBroadcastEventExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBroadcastEventEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBroadcastEventEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBroadcastEventEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBroadcastEventEx_Fire(This,EventID)	\
    ( (This)->lpVtbl -> Fire(This,EventID) ) 


#define IBroadcastEventEx_FireEx(This,EventID,Param1,Param2,Param3,Param4)	\
    ( (This)->lpVtbl -> FireEx(This,EventID,Param1,Param2,Param3,Param4) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBroadcastEventEx_INTERFACE_DEFINED__ */


#ifndef __IRegisterTuner_INTERFACE_DEFINED__
#define __IRegisterTuner_INTERFACE_DEFINED__

/* interface IRegisterTuner */
/* [unique][helpstring][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IRegisterTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("359B3901-572C-4854-BB49-CDEF66606A25")
    IRegisterTuner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ __RPC__in_opt ITuner *pTuner,
            /* [in] */ __RPC__in_opt IGraphBuilder *pGraph) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unregister( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegisterTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegisterTuner * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegisterTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegisterTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IRegisterTuner * This,
            /* [in] */ __RPC__in_opt ITuner *pTuner,
            /* [in] */ __RPC__in_opt IGraphBuilder *pGraph);
        
        HRESULT ( STDMETHODCALLTYPE *Unregister )( 
            IRegisterTuner * This);
        
        END_INTERFACE
    } IRegisterTunerVtbl;

    interface IRegisterTuner
    {
        CONST_VTBL struct IRegisterTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegisterTuner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRegisterTuner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRegisterTuner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRegisterTuner_Register(This,pTuner,pGraph)	\
    ( (This)->lpVtbl -> Register(This,pTuner,pGraph) ) 

#define IRegisterTuner_Unregister(This)	\
    ( (This)->lpVtbl -> Unregister(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRegisterTuner_INTERFACE_DEFINED__ */


#ifndef __IBDAComparable_INTERFACE_DEFINED__
#define __IBDAComparable_INTERFACE_DEFINED__

/* interface IBDAComparable */
/* [unique][helpstring][uuid][nonextensible][hidden][object] */ 


EXTERN_C const IID IID_IBDAComparable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B34505E0-2F0E-497b-80BC-D43F3B24ED7F")
    IBDAComparable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareExact( 
            /* [in] */ __RPC__in_opt IDispatch *CompareTo,
            /* [retval][out] */ __RPC__out long *Result) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareEquivalent( 
            /* [in] */ __RPC__in_opt IDispatch *CompareTo,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__out long *Result) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HashExact( 
            /* [retval][out] */ __RPC__out __int64 *Result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashExactIncremental( 
            /* [in] */ __int64 PartialResult,
            /* [retval][out] */ __RPC__out __int64 *Result) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HashEquivalent( 
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__out __int64 *Result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashEquivalentIncremental( 
            /* [in] */ __int64 PartialResult,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__out __int64 *Result) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBDAComparableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBDAComparable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBDAComparable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBDAComparable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CompareExact )( 
            IBDAComparable * This,
            /* [in] */ __RPC__in_opt IDispatch *CompareTo,
            /* [retval][out] */ __RPC__out long *Result);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CompareEquivalent )( 
            IBDAComparable * This,
            /* [in] */ __RPC__in_opt IDispatch *CompareTo,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__out long *Result);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *HashExact )( 
            IBDAComparable * This,
            /* [retval][out] */ __RPC__out __int64 *Result);
        
        HRESULT ( STDMETHODCALLTYPE *HashExactIncremental )( 
            IBDAComparable * This,
            /* [in] */ __int64 PartialResult,
            /* [retval][out] */ __RPC__out __int64 *Result);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *HashEquivalent )( 
            IBDAComparable * This,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__out __int64 *Result);
        
        HRESULT ( STDMETHODCALLTYPE *HashEquivalentIncremental )( 
            IBDAComparable * This,
            /* [in] */ __int64 PartialResult,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__out __int64 *Result);
        
        END_INTERFACE
    } IBDAComparableVtbl;

    interface IBDAComparable
    {
        CONST_VTBL struct IBDAComparableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBDAComparable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBDAComparable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBDAComparable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBDAComparable_CompareExact(This,CompareTo,Result)	\
    ( (This)->lpVtbl -> CompareExact(This,CompareTo,Result) ) 

#define IBDAComparable_CompareEquivalent(This,CompareTo,dwFlags,Result)	\
    ( (This)->lpVtbl -> CompareEquivalent(This,CompareTo,dwFlags,Result) ) 

#define IBDAComparable_HashExact(This,Result)	\
    ( (This)->lpVtbl -> HashExact(This,Result) ) 

#define IBDAComparable_HashExactIncremental(This,PartialResult,Result)	\
    ( (This)->lpVtbl -> HashExactIncremental(This,PartialResult,Result) ) 

#define IBDAComparable_HashEquivalent(This,dwFlags,Result)	\
    ( (This)->lpVtbl -> HashEquivalent(This,dwFlags,Result) ) 

#define IBDAComparable_HashEquivalentIncremental(This,PartialResult,dwFlags,Result)	\
    ( (This)->lpVtbl -> HashEquivalentIncremental(This,PartialResult,dwFlags,Result) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBDAComparable_INTERFACE_DEFINED__ */



#ifndef __TunerLib_LIBRARY_DEFINED__
#define __TunerLib_LIBRARY_DEFINED__

/* library TunerLib */
/* [helpstring][version][uuid] */ 

#define SID_SBroadcastEventService CLSID_BroadcastEventService
#define SID_SContentTuneRequest IID_ITuner
#define SID_ScanningTuner IID_IScanningTuner
#define SID_ScanningTunerEx IID_IScanningTunerEx

EXTERN_C const IID LIBID_TunerLib;

EXTERN_C const CLSID CLSID_SystemTuningSpaces;

#ifdef __cplusplus

class DECLSPEC_UUID("D02AAC50-027E-11d3-9D8E-00C04F72D980")
SystemTuningSpaces;
#endif

EXTERN_C const CLSID CLSID_TuningSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("5FFDC5E6-B83A-4b55-B6E8-C69E765FE9DB")
TuningSpace;
#endif

EXTERN_C const CLSID CLSID_ATSCTuningSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("A2E30750-6C3D-11d3-B653-00C04F79498E")
ATSCTuningSpace;
#endif

EXTERN_C const CLSID CLSID_DigitalCableTuningSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("D9BB4CEE-B87A-47F1-AC92-B08D9C7813FC")
DigitalCableTuningSpace;
#endif

EXTERN_C const CLSID CLSID_AnalogRadioTuningSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("8A674B4C-1F63-11d3-B64C-00C04F79498E")
AnalogRadioTuningSpace;
#endif

EXTERN_C const CLSID CLSID_AuxInTuningSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("F9769A06-7ACA-4e39-9CFB-97BB35F0E77E")
AuxInTuningSpace;
#endif

EXTERN_C const CLSID CLSID_AnalogTVTuningSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("8A674B4D-1F63-11d3-B64C-00C04F79498E")
AnalogTVTuningSpace;
#endif

EXTERN_C const CLSID CLSID_DVBTuningSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("C6B14B32-76AA-4a86-A7AC-5C79AAF58DA7")
DVBTuningSpace;
#endif

EXTERN_C const CLSID CLSID_DVBSTuningSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("B64016F3-C9A2-4066-96F0-BD9563314726")
DVBSTuningSpace;
#endif

EXTERN_C const CLSID CLSID_ComponentTypes;

#ifdef __cplusplus

class DECLSPEC_UUID("A1A2B1C4-0E3A-11d3-9D8E-00C04F72D980")
ComponentTypes;
#endif

EXTERN_C const CLSID CLSID_ComponentType;

#ifdef __cplusplus

class DECLSPEC_UUID("823535A0-0318-11d3-9D8E-00C04F72D980")
ComponentType;
#endif

EXTERN_C const CLSID CLSID_LanguageComponentType;

#ifdef __cplusplus

class DECLSPEC_UUID("1BE49F30-0E1B-11d3-9D8E-00C04F72D980")
LanguageComponentType;
#endif

EXTERN_C const CLSID CLSID_MPEG2ComponentType;

#ifdef __cplusplus

class DECLSPEC_UUID("418008F3-CF67-4668-9628-10DC52BE1D08")
MPEG2ComponentType;
#endif

EXTERN_C const CLSID CLSID_ATSCComponentType;

#ifdef __cplusplus

class DECLSPEC_UUID("A8DCF3D5-0780-4ef4-8A83-2CFFAACB8ACE")
ATSCComponentType;
#endif

EXTERN_C const CLSID CLSID_Components;

#ifdef __cplusplus

class DECLSPEC_UUID("809B6661-94C4-49e6-B6EC-3F0F862215AA")
Components;
#endif

EXTERN_C const CLSID CLSID_Component;

#ifdef __cplusplus

class DECLSPEC_UUID("59DC47A8-116C-11d3-9D8E-00C04F72D980")
Component;
#endif

EXTERN_C const CLSID CLSID_MPEG2Component;

#ifdef __cplusplus

class DECLSPEC_UUID("055CB2D7-2969-45cd-914B-76890722F112")
MPEG2Component;
#endif

EXTERN_C const CLSID CLSID_AnalogAudioComponentType;

#ifdef __cplusplus

class DECLSPEC_UUID("28AB0005-E845-4FFA-AA9B-F4665236141C")
AnalogAudioComponentType;
#endif

EXTERN_C const CLSID CLSID_TuneRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("B46E0D38-AB35-4a06-A137-70576B01B39F")
TuneRequest;
#endif

EXTERN_C const CLSID CLSID_ChannelTuneRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("0369B4E5-45B6-11d3-B650-00C04F79498E")
ChannelTuneRequest;
#endif

EXTERN_C const CLSID CLSID_ATSCChannelTuneRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("0369B4E6-45B6-11d3-B650-00C04F79498E")
ATSCChannelTuneRequest;
#endif

EXTERN_C const CLSID CLSID_DigitalCableTuneRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("26EC0B63-AA90-458A-8DF4-5659F2C8A18A")
DigitalCableTuneRequest;
#endif

EXTERN_C const CLSID CLSID_MPEG2TuneRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("0955AC62-BF2E-4cba-A2B9-A63F772D46CF")
MPEG2TuneRequest;
#endif

EXTERN_C const CLSID CLSID_MPEG2TuneRequestFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("2C63E4EB-4CEA-41b8-919C-E947EA19A77C")
MPEG2TuneRequestFactory;
#endif

EXTERN_C const CLSID CLSID_Locator;

#ifdef __cplusplus

class DECLSPEC_UUID("0888C883-AC4F-4943-B516-2C38D9B34562")
Locator;
#endif

EXTERN_C const CLSID CLSID_DigitalLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("6E50CC0D-C19B-4BF6-810B-5BD60761F5CC")
DigitalLocator;
#endif

EXTERN_C const CLSID CLSID_AnalogLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("49638B91-48AB-48B7-A47A-7D0E75A08EDE")
AnalogLocator;
#endif

EXTERN_C const CLSID CLSID_ATSCLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("8872FF1B-98FA-4d7a-8D93-C9F1055F85BB")
ATSCLocator;
#endif

EXTERN_C const CLSID CLSID_DigitalCableLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("03C06416-D127-407A-AB4C-FDD279ABBE5D")
DigitalCableLocator;
#endif

EXTERN_C const CLSID CLSID_DVBTLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("9CD64701-BDF3-4d14-8E03-F12983D86664")
DVBTLocator;
#endif

EXTERN_C const CLSID CLSID_DVBSLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("1DF7D126-4050-47f0-A7CF-4C4CA9241333")
DVBSLocator;
#endif

EXTERN_C const CLSID CLSID_DVBCLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("C531D9FD-9685-4028-8B68-6E1232079F1E")
DVBCLocator;
#endif

EXTERN_C const CLSID CLSID_DVBTuneRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("15D6504A-5494-499c-886C-973C9E53B9F1")
DVBTuneRequest;
#endif

EXTERN_C const CLSID CLSID_CreatePropBagOnRegKey;

#ifdef __cplusplus

class DECLSPEC_UUID("8A674B49-1F63-11d3-B64C-00C04F79498E")
CreatePropBagOnRegKey;
#endif

EXTERN_C const CLSID CLSID_BroadcastEventService;

#ifdef __cplusplus

class DECLSPEC_UUID("0B3FFB92-0919-4934-9D5B-619C719D0202")
BroadcastEventService;
#endif

EXTERN_C const CLSID CLSID_TunerMarshaler;

#ifdef __cplusplus

class DECLSPEC_UUID("6438570B-0C08-4a25-9504-8012BB4D50CF")
TunerMarshaler;
#endif
#endif /* __TunerLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\tsvirtualchannels.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for tsvirtualchannels.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tsvirtualchannels_h__
#define __tsvirtualchannels_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWTSPlugin_FWD_DEFINED__
#define __IWTSPlugin_FWD_DEFINED__
typedef interface IWTSPlugin IWTSPlugin;
#endif 	/* __IWTSPlugin_FWD_DEFINED__ */


#ifndef __IWTSListener_FWD_DEFINED__
#define __IWTSListener_FWD_DEFINED__
typedef interface IWTSListener IWTSListener;
#endif 	/* __IWTSListener_FWD_DEFINED__ */


#ifndef __IWTSListenerCallback_FWD_DEFINED__
#define __IWTSListenerCallback_FWD_DEFINED__
typedef interface IWTSListenerCallback IWTSListenerCallback;
#endif 	/* __IWTSListenerCallback_FWD_DEFINED__ */


#ifndef __IWTSVirtualChannelCallback_FWD_DEFINED__
#define __IWTSVirtualChannelCallback_FWD_DEFINED__
typedef interface IWTSVirtualChannelCallback IWTSVirtualChannelCallback;
#endif 	/* __IWTSVirtualChannelCallback_FWD_DEFINED__ */


#ifndef __IWTSVirtualChannelManager_FWD_DEFINED__
#define __IWTSVirtualChannelManager_FWD_DEFINED__
typedef interface IWTSVirtualChannelManager IWTSVirtualChannelManager;
#endif 	/* __IWTSVirtualChannelManager_FWD_DEFINED__ */


#ifndef __IWTSVirtualChannel_FWD_DEFINED__
#define __IWTSVirtualChannel_FWD_DEFINED__
typedef interface IWTSVirtualChannel IWTSVirtualChannel;
#endif 	/* __IWTSVirtualChannel_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_tsvirtualchannels_0000_0000 */
/* [local] */ 







#define  WTS_PROPERTY_DEFAULT_CONFIG  L"DefaultConfig"
EXTERN_C __declspec(selectany) const IID IID_IWTSPlugin = {0xA1230201, 0x1439, 0x4e62, { 0xa4, 0x14, 0x19, 0x0d, 0x0a, 0xc3, 0xd4, 0x0e}};


extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0000_v0_0_s_ifspec;

#ifndef __IWTSPlugin_INTERFACE_DEFINED__
#define __IWTSPlugin_INTERFACE_DEFINED__

/* interface IWTSPlugin */
/* [helpstring][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IWTSPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1230201-1439-4e62-a414-190d0ac3d40e")
    IWTSPlugin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IWTSVirtualChannelManager *pChannelMgr) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Connected( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Disconnected( 
            DWORD dwDisconnectCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Terminated( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWTSPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWTSPlugin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWTSPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWTSPlugin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IWTSPlugin * This,
            /* [in] */ __RPC__in_opt IWTSVirtualChannelManager *pChannelMgr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Connected )( 
            IWTSPlugin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Disconnected )( 
            IWTSPlugin * This,
            DWORD dwDisconnectCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Terminated )( 
            IWTSPlugin * This);
        
        END_INTERFACE
    } IWTSPluginVtbl;

    interface IWTSPlugin
    {
        CONST_VTBL struct IWTSPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWTSPlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWTSPlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWTSPlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWTSPlugin_Initialize(This,pChannelMgr)	\
    ( (This)->lpVtbl -> Initialize(This,pChannelMgr) ) 

#define IWTSPlugin_Connected(This)	\
    ( (This)->lpVtbl -> Connected(This) ) 

#define IWTSPlugin_Disconnected(This,dwDisconnectCode)	\
    ( (This)->lpVtbl -> Disconnected(This,dwDisconnectCode) ) 

#define IWTSPlugin_Terminated(This)	\
    ( (This)->lpVtbl -> Terminated(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWTSPlugin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tsvirtualchannels_0000_0001 */
/* [local] */ 

EXTERN_C __declspec(selectany) const IID IID_IWTSListener = {0xA1230206, 0x9a39, 0x4d58, {0x86, 0x74, 0xcd, 0xb4, 0xdf, 0xf4, 0xe7, 0x3b}};


extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0001_v0_0_s_ifspec;

#ifndef __IWTSListener_INTERFACE_DEFINED__
#define __IWTSListener_INTERFACE_DEFINED__

/* interface IWTSListener */
/* [helpstring][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IWTSListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1230206-9a39-4d58-8674-cdb4dff4e73b")
    IWTSListener : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ __RPC__deref_out_opt IPropertyBag **ppPropertyBag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWTSListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWTSListener * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWTSListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWTSListener * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConfiguration )( 
            IWTSListener * This,
            /* [out] */ __RPC__deref_out_opt IPropertyBag **ppPropertyBag);
        
        END_INTERFACE
    } IWTSListenerVtbl;

    interface IWTSListener
    {
        CONST_VTBL struct IWTSListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWTSListener_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWTSListener_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWTSListener_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWTSListener_GetConfiguration(This,ppPropertyBag)	\
    ( (This)->lpVtbl -> GetConfiguration(This,ppPropertyBag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWTSListener_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tsvirtualchannels_0000_0002 */
/* [local] */ 

EXTERN_C __declspec(selectany) const IID IID_IWTSListenerCallback = {0xA1230203, 0xd6a7, 0x11d8, {0xb9, 0xfd, 0x00, 0x0b, 0xdb, 0xd1, 0xf1, 0x98}};


extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0002_v0_0_s_ifspec;

#ifndef __IWTSListenerCallback_INTERFACE_DEFINED__
#define __IWTSListenerCallback_INTERFACE_DEFINED__

/* interface IWTSListenerCallback */
/* [helpstring][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IWTSListenerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1230203-d6a7-11d8-b9fd-000bdbd1f198")
    IWTSListenerCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnNewChannelConnection( 
            /* [in] */ __RPC__in_opt IWTSVirtualChannel *pChannel,
            /* [full][in] */ __RPC__in_opt BSTR data,
            /* [out] */ __RPC__out BOOL *pbAccept,
            /* [out] */ __RPC__deref_out_opt IWTSVirtualChannelCallback **ppCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWTSListenerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWTSListenerCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWTSListenerCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWTSListenerCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnNewChannelConnection )( 
            IWTSListenerCallback * This,
            /* [in] */ __RPC__in_opt IWTSVirtualChannel *pChannel,
            /* [full][in] */ __RPC__in_opt BSTR data,
            /* [out] */ __RPC__out BOOL *pbAccept,
            /* [out] */ __RPC__deref_out_opt IWTSVirtualChannelCallback **ppCallback);
        
        END_INTERFACE
    } IWTSListenerCallbackVtbl;

    interface IWTSListenerCallback
    {
        CONST_VTBL struct IWTSListenerCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWTSListenerCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWTSListenerCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWTSListenerCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWTSListenerCallback_OnNewChannelConnection(This,pChannel,data,pbAccept,ppCallback)	\
    ( (This)->lpVtbl -> OnNewChannelConnection(This,pChannel,data,pbAccept,ppCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWTSListenerCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tsvirtualchannels_0000_0003 */
/* [local] */ 

EXTERN_C __declspec(selectany) const IID IID_IWTSVirtualChannelCallback = {0xA1230204, 0xd6a7, 0x11d8, {0xb9, 0xfd, 0x00, 0x0b, 0xdb, 0xd1, 0xf1, 0x98}};


extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0003_v0_0_s_ifspec;

#ifndef __IWTSVirtualChannelCallback_INTERFACE_DEFINED__
#define __IWTSVirtualChannelCallback_INTERFACE_DEFINED__

/* interface IWTSVirtualChannelCallback */
/* [helpstring][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IWTSVirtualChannelCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1230204-d6a7-11d8-b9fd-000bdbd1f198")
    IWTSVirtualChannelCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnDataReceived( 
            /* [in] */ ULONG cbSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbSize) BYTE *pBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnClose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWTSVirtualChannelCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWTSVirtualChannelCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWTSVirtualChannelCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWTSVirtualChannelCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnDataReceived )( 
            IWTSVirtualChannelCallback * This,
            /* [in] */ ULONG cbSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbSize) BYTE *pBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnClose )( 
            IWTSVirtualChannelCallback * This);
        
        END_INTERFACE
    } IWTSVirtualChannelCallbackVtbl;

    interface IWTSVirtualChannelCallback
    {
        CONST_VTBL struct IWTSVirtualChannelCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWTSVirtualChannelCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWTSVirtualChannelCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWTSVirtualChannelCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWTSVirtualChannelCallback_OnDataReceived(This,cbSize,pBuffer)	\
    ( (This)->lpVtbl -> OnDataReceived(This,cbSize,pBuffer) ) 

#define IWTSVirtualChannelCallback_OnClose(This)	\
    ( (This)->lpVtbl -> OnClose(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWTSVirtualChannelCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tsvirtualchannels_0000_0004 */
/* [local] */ 

EXTERN_C __declspec(selectany) const IID IID_IWTSVirtualChannelManager = {0xA1230205,0xd6a7,0x11d8,{0xb9,0xfd,0x00,0x0b,0xdb,0xd1,0xf1,0x98}};
#define  TS_VC_LISTENER_STATIC_CHANNEL   0x00000001


extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0004_v0_0_s_ifspec;

#ifndef __IWTSVirtualChannelManager_INTERFACE_DEFINED__
#define __IWTSVirtualChannelManager_INTERFACE_DEFINED__

/* interface IWTSVirtualChannelManager */
/* [helpstring][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IWTSVirtualChannelManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1230205-d6a7-11d8-b9fd-000bdbd1f198")
    IWTSVirtualChannelManager : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateListener( 
            /* [string][in] */ __RPC__in const char *pszChannelName,
            /* [in] */ ULONG uFlags,
            /* [in] */ __RPC__in_opt IWTSListenerCallback *pListenerCallback,
            /* [out] */ __RPC__deref_out_opt IWTSListener **ppListener) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWTSVirtualChannelManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWTSVirtualChannelManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWTSVirtualChannelManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWTSVirtualChannelManager * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateListener )( 
            IWTSVirtualChannelManager * This,
            /* [string][in] */ __RPC__in const char *pszChannelName,
            /* [in] */ ULONG uFlags,
            /* [in] */ __RPC__in_opt IWTSListenerCallback *pListenerCallback,
            /* [out] */ __RPC__deref_out_opt IWTSListener **ppListener);
        
        END_INTERFACE
    } IWTSVirtualChannelManagerVtbl;

    interface IWTSVirtualChannelManager
    {
        CONST_VTBL struct IWTSVirtualChannelManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWTSVirtualChannelManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWTSVirtualChannelManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWTSVirtualChannelManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWTSVirtualChannelManager_CreateListener(This,pszChannelName,uFlags,pListenerCallback,ppListener)	\
    ( (This)->lpVtbl -> CreateListener(This,pszChannelName,uFlags,pListenerCallback,ppListener) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWTSVirtualChannelManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tsvirtualchannels_0000_0005 */
/* [local] */ 

EXTERN_C __declspec(selectany) const IID IID_IWTSVirtualChannel = { 0xA1230207, 0xd6a7, 0x11d8, { 0xb9, 0xfd, 0x00, 0x0b, 0xdb, 0xd1, 0xf1, 0x98} };


extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tsvirtualchannels_0000_0005_v0_0_s_ifspec;

#ifndef __IWTSVirtualChannel_INTERFACE_DEFINED__
#define __IWTSVirtualChannel_INTERFACE_DEFINED__

/* interface IWTSVirtualChannel */
/* [helpstring][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IWTSVirtualChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1230207-d6a7-11d8-b9fd-000bdbd1f198")
    IWTSVirtualChannel : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ ULONG cbSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbSize) BYTE *pBuffer,
            /* [in] */ __RPC__in_opt IUnknown *pReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWTSVirtualChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWTSVirtualChannel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWTSVirtualChannel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWTSVirtualChannel * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IWTSVirtualChannel * This,
            /* [in] */ ULONG cbSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbSize) BYTE *pBuffer,
            /* [in] */ __RPC__in_opt IUnknown *pReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWTSVirtualChannel * This);
        
        END_INTERFACE
    } IWTSVirtualChannelVtbl;

    interface IWTSVirtualChannel
    {
        CONST_VTBL struct IWTSVirtualChannelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWTSVirtualChannel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWTSVirtualChannel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWTSVirtualChannel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWTSVirtualChannel_Write(This,cbSize,pBuffer,pReserved)	\
    ( (This)->lpVtbl -> Write(This,cbSize,pBuffer,pReserved) ) 

#define IWTSVirtualChannel_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWTSVirtualChannel_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\TxCtx.h ===
//  Copyright (c) Microsoft Corporation. All rights reserved.
#include "comsvcs.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\UaStrFnc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994-1999.
//
//  File:       uastrfnc.h
//
//  Contents:   Unaligned UNICODE lstr functions for MIPS, PPC, ALPHA, ...
//
//  Classes:
//
//  Functions:
//
//
//--------------------------------------------------------------------------

// NOTE: This file assumes it is included from shellprv.h

#ifndef _UASTRFNC_H_
#define _UASTRFNC_H_

#ifdef __cplusplus
extern "C" {
#endif

// If we are running on a platform that requires aligned data, we need
// to provide custom string functions that can deal with unaligned
// strings.  On other platforms, these call directly to the normal string
// functions.

#ifndef _X86_
#define ALIGNMENT_MACHINE
#endif

#ifdef ALIGNMENT_MACHINE

#define IS_ALIGNED(p)   (((ULONG_PTR)(p) & (sizeof(*(p))-1) )==0)

UNALIGNED WCHAR * ualstrcpynW(UNALIGNED WCHAR * lpString1,
    		  	      UNALIGNED const WCHAR * lpString2,
    			      int iMaxLength);

int 		  ualstrcmpiW (UNALIGNED const WCHAR * dst,
			       UNALIGNED const WCHAR * src);

int 		  ualstrcmpW  (UNALIGNED const WCHAR * src,
			       UNALIGNED const WCHAR * dst);

size_t 		  ualstrlenW  (UNALIGNED const WCHAR * wcs);

UNALIGNED WCHAR * ualstrcpyW  (UNALIGNED WCHAR * dst,
			       UNALIGNED const WCHAR * src);


#else

#define ualstrcpynW StrCpyNW     // lstrcpynW is stubbed out on Windows 95
#define ualstrcmpiW StrCmpIW     // lstrcmpiW is stubbed out on Windows 95
#define ualstrcmpW  StrCmpW      // lstrcmpW is stubbed out on Windows 95
#define ualstrlenW  lstrlenW
#define ualstrcpyW  StrCpyW      // lstrcpyW is stubbed out on Windows 95

#endif // ALIGNMENT_MACHINE

#define ualstrcpynA lstrcpynA
#define ualstrcmpiA lstrcmpiA
#define ualstrcmpA  lstrcmpA
#define ualstrlenA  lstrlenA
#define ualstrcpyA  lstrcpyA

#ifdef UNICODE
#define ualstrcpyn ualstrcpynW
#define ualstrcmpi ualstrcmpiW
#define ualstrcmp  ualstrcmpW
#define ualstrlen  ualstrlenW
#define ualstrcpy  ualstrcpyW
#else
#define ualstrcpyn ualstrcpynA
#define ualstrcmpi ualstrcmpiA
#define ualstrcmp  ualstrcmpA
#define ualstrlen  ualstrlenA
#define ualstrcpy  ualstrcpyA
#endif

#ifdef __cplusplus
}       // extern "C"
#endif

#endif // _UASTRFNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\TxCoord.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for txcoord.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __txcoord_h__
#define __txcoord_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITransactionResourceAsync_FWD_DEFINED__
#define __ITransactionResourceAsync_FWD_DEFINED__
typedef interface ITransactionResourceAsync ITransactionResourceAsync;
#endif 	/* __ITransactionResourceAsync_FWD_DEFINED__ */


#ifndef __ITransactionLastResourceAsync_FWD_DEFINED__
#define __ITransactionLastResourceAsync_FWD_DEFINED__
typedef interface ITransactionLastResourceAsync ITransactionLastResourceAsync;
#endif 	/* __ITransactionLastResourceAsync_FWD_DEFINED__ */


#ifndef __ITransactionResource_FWD_DEFINED__
#define __ITransactionResource_FWD_DEFINED__
typedef interface ITransactionResource ITransactionResource;
#endif 	/* __ITransactionResource_FWD_DEFINED__ */


#ifndef __ITransactionEnlistmentAsync_FWD_DEFINED__
#define __ITransactionEnlistmentAsync_FWD_DEFINED__
typedef interface ITransactionEnlistmentAsync ITransactionEnlistmentAsync;
#endif 	/* __ITransactionEnlistmentAsync_FWD_DEFINED__ */


#ifndef __ITransactionLastEnlistmentAsync_FWD_DEFINED__
#define __ITransactionLastEnlistmentAsync_FWD_DEFINED__
typedef interface ITransactionLastEnlistmentAsync ITransactionLastEnlistmentAsync;
#endif 	/* __ITransactionLastEnlistmentAsync_FWD_DEFINED__ */


#ifndef __ITransactionExportFactory_FWD_DEFINED__
#define __ITransactionExportFactory_FWD_DEFINED__
typedef interface ITransactionExportFactory ITransactionExportFactory;
#endif 	/* __ITransactionExportFactory_FWD_DEFINED__ */


#ifndef __ITransactionImportWhereabouts_FWD_DEFINED__
#define __ITransactionImportWhereabouts_FWD_DEFINED__
typedef interface ITransactionImportWhereabouts ITransactionImportWhereabouts;
#endif 	/* __ITransactionImportWhereabouts_FWD_DEFINED__ */


#ifndef __ITransactionExport_FWD_DEFINED__
#define __ITransactionExport_FWD_DEFINED__
typedef interface ITransactionExport ITransactionExport;
#endif 	/* __ITransactionExport_FWD_DEFINED__ */


#ifndef __ITransactionImport_FWD_DEFINED__
#define __ITransactionImport_FWD_DEFINED__
typedef interface ITransactionImport ITransactionImport;
#endif 	/* __ITransactionImport_FWD_DEFINED__ */


#ifndef __ITipTransaction_FWD_DEFINED__
#define __ITipTransaction_FWD_DEFINED__
typedef interface ITipTransaction ITipTransaction;
#endif 	/* __ITipTransaction_FWD_DEFINED__ */


#ifndef __ITipHelper_FWD_DEFINED__
#define __ITipHelper_FWD_DEFINED__
typedef interface ITipHelper ITipHelper;
#endif 	/* __ITipHelper_FWD_DEFINED__ */


#ifndef __ITipPullSink_FWD_DEFINED__
#define __ITipPullSink_FWD_DEFINED__
typedef interface ITipPullSink ITipPullSink;
#endif 	/* __ITipPullSink_FWD_DEFINED__ */


#ifndef __IDtcNetworkAccessConfig_FWD_DEFINED__
#define __IDtcNetworkAccessConfig_FWD_DEFINED__
typedef interface IDtcNetworkAccessConfig IDtcNetworkAccessConfig;
#endif 	/* __IDtcNetworkAccessConfig_FWD_DEFINED__ */


#ifndef __IDtcNetworkAccessConfig2_FWD_DEFINED__
#define __IDtcNetworkAccessConfig2_FWD_DEFINED__
typedef interface IDtcNetworkAccessConfig2 IDtcNetworkAccessConfig2;
#endif 	/* __IDtcNetworkAccessConfig2_FWD_DEFINED__ */


/* header files for imported files */
#include "transact.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_txcoord_0000_0000 */
/* [local] */ 
















extern RPC_IF_HANDLE __MIDL_itf_txcoord_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txcoord_0000_0000_v0_0_s_ifspec;

#ifndef __ITransactionResourceAsync_INTERFACE_DEFINED__
#define __ITransactionResourceAsync_INTERFACE_DEFINED__

/* interface ITransactionResourceAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionResourceAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69E971F0-23CE-11cf-AD60-00AA00A74CCD")
    ITransactionResourceAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrepareRequest( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfRM,
            /* [in] */ BOOL fWantMoniker,
            /* [in] */ BOOL fSinglePhase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitRequest( 
            /* [in] */ DWORD grfRM,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortRequest( 
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TMDown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionResourceAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionResourceAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionResourceAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionResourceAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareRequest )( 
            ITransactionResourceAsync * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfRM,
            /* [in] */ BOOL fWantMoniker,
            /* [in] */ BOOL fSinglePhase);
        
        HRESULT ( STDMETHODCALLTYPE *CommitRequest )( 
            ITransactionResourceAsync * This,
            /* [in] */ DWORD grfRM,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW);
        
        HRESULT ( STDMETHODCALLTYPE *AbortRequest )( 
            ITransactionResourceAsync * This,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW);
        
        HRESULT ( STDMETHODCALLTYPE *TMDown )( 
            ITransactionResourceAsync * This);
        
        END_INTERFACE
    } ITransactionResourceAsyncVtbl;

    interface ITransactionResourceAsync
    {
        CONST_VTBL struct ITransactionResourceAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionResourceAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionResourceAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionResourceAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionResourceAsync_PrepareRequest(This,fRetaining,grfRM,fWantMoniker,fSinglePhase)	\
    ( (This)->lpVtbl -> PrepareRequest(This,fRetaining,grfRM,fWantMoniker,fSinglePhase) ) 

#define ITransactionResourceAsync_CommitRequest(This,grfRM,pNewUOW)	\
    ( (This)->lpVtbl -> CommitRequest(This,grfRM,pNewUOW) ) 

#define ITransactionResourceAsync_AbortRequest(This,pboidReason,fRetaining,pNewUOW)	\
    ( (This)->lpVtbl -> AbortRequest(This,pboidReason,fRetaining,pNewUOW) ) 

#define ITransactionResourceAsync_TMDown(This)	\
    ( (This)->lpVtbl -> TMDown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionResourceAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionLastResourceAsync_INTERFACE_DEFINED__
#define __ITransactionLastResourceAsync_INTERFACE_DEFINED__

/* interface ITransactionLastResourceAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionLastResourceAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C82BD532-5B30-11d3-8A91-00C04F79EB6D")
    ITransactionLastResourceAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DelegateCommit( 
            /* [in] */ DWORD grfRM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForgetRequest( 
            /* [in] */ __RPC__in XACTUOW *pNewUOW) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionLastResourceAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionLastResourceAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionLastResourceAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionLastResourceAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCommit )( 
            ITransactionLastResourceAsync * This,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( STDMETHODCALLTYPE *ForgetRequest )( 
            ITransactionLastResourceAsync * This,
            /* [in] */ __RPC__in XACTUOW *pNewUOW);
        
        END_INTERFACE
    } ITransactionLastResourceAsyncVtbl;

    interface ITransactionLastResourceAsync
    {
        CONST_VTBL struct ITransactionLastResourceAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionLastResourceAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionLastResourceAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionLastResourceAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionLastResourceAsync_DelegateCommit(This,grfRM)	\
    ( (This)->lpVtbl -> DelegateCommit(This,grfRM) ) 

#define ITransactionLastResourceAsync_ForgetRequest(This,pNewUOW)	\
    ( (This)->lpVtbl -> ForgetRequest(This,pNewUOW) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionLastResourceAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionResource_INTERFACE_DEFINED__
#define __ITransactionResource_INTERFACE_DEFINED__

/* interface ITransactionResource */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE5FF7B3-4572-11d0-9452-00A0C905416E")
    ITransactionResource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrepareRequest( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfRM,
            /* [in] */ BOOL fWantMoniker,
            /* [in] */ BOOL fSinglePhase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitRequest( 
            /* [in] */ DWORD grfRM,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortRequest( 
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TMDown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareRequest )( 
            ITransactionResource * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfRM,
            /* [in] */ BOOL fWantMoniker,
            /* [in] */ BOOL fSinglePhase);
        
        HRESULT ( STDMETHODCALLTYPE *CommitRequest )( 
            ITransactionResource * This,
            /* [in] */ DWORD grfRM,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW);
        
        HRESULT ( STDMETHODCALLTYPE *AbortRequest )( 
            ITransactionResource * This,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW);
        
        HRESULT ( STDMETHODCALLTYPE *TMDown )( 
            ITransactionResource * This);
        
        END_INTERFACE
    } ITransactionResourceVtbl;

    interface ITransactionResource
    {
        CONST_VTBL struct ITransactionResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionResource_PrepareRequest(This,fRetaining,grfRM,fWantMoniker,fSinglePhase)	\
    ( (This)->lpVtbl -> PrepareRequest(This,fRetaining,grfRM,fWantMoniker,fSinglePhase) ) 

#define ITransactionResource_CommitRequest(This,grfRM,pNewUOW)	\
    ( (This)->lpVtbl -> CommitRequest(This,grfRM,pNewUOW) ) 

#define ITransactionResource_AbortRequest(This,pboidReason,fRetaining,pNewUOW)	\
    ( (This)->lpVtbl -> AbortRequest(This,pboidReason,fRetaining,pNewUOW) ) 

#define ITransactionResource_TMDown(This)	\
    ( (This)->lpVtbl -> TMDown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionResource_INTERFACE_DEFINED__ */


#ifndef __ITransactionEnlistmentAsync_INTERFACE_DEFINED__
#define __ITransactionEnlistmentAsync_INTERFACE_DEFINED__

/* interface ITransactionEnlistmentAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionEnlistmentAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0fb15081-af41-11ce-bd2b-204c4f4f5020")
    ITransactionEnlistmentAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrepareRequestDone( 
            /* [in] */ HRESULT hr,
            /* [unique][in] */ __RPC__in_opt IMoniker *pmk,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitRequestDone( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortRequestDone( 
            /* [in] */ HRESULT hr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionEnlistmentAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionEnlistmentAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionEnlistmentAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionEnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareRequestDone )( 
            ITransactionEnlistmentAsync * This,
            /* [in] */ HRESULT hr,
            /* [unique][in] */ __RPC__in_opt IMoniker *pmk,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason);
        
        HRESULT ( STDMETHODCALLTYPE *CommitRequestDone )( 
            ITransactionEnlistmentAsync * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *AbortRequestDone )( 
            ITransactionEnlistmentAsync * This,
            /* [in] */ HRESULT hr);
        
        END_INTERFACE
    } ITransactionEnlistmentAsyncVtbl;

    interface ITransactionEnlistmentAsync
    {
        CONST_VTBL struct ITransactionEnlistmentAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionEnlistmentAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionEnlistmentAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionEnlistmentAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionEnlistmentAsync_PrepareRequestDone(This,hr,pmk,pboidReason)	\
    ( (This)->lpVtbl -> PrepareRequestDone(This,hr,pmk,pboidReason) ) 

#define ITransactionEnlistmentAsync_CommitRequestDone(This,hr)	\
    ( (This)->lpVtbl -> CommitRequestDone(This,hr) ) 

#define ITransactionEnlistmentAsync_AbortRequestDone(This,hr)	\
    ( (This)->lpVtbl -> AbortRequestDone(This,hr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionEnlistmentAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionLastEnlistmentAsync_INTERFACE_DEFINED__
#define __ITransactionLastEnlistmentAsync_INTERFACE_DEFINED__

/* interface ITransactionLastEnlistmentAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionLastEnlistmentAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C82BD533-5B30-11d3-8A91-00C04F79EB6D")
    ITransactionLastEnlistmentAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TransactionOutcome( 
            /* [in] */ XACTSTAT XactStat,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionLastEnlistmentAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionLastEnlistmentAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionLastEnlistmentAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionLastEnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *TransactionOutcome )( 
            ITransactionLastEnlistmentAsync * This,
            /* [in] */ XACTSTAT XactStat,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason);
        
        END_INTERFACE
    } ITransactionLastEnlistmentAsyncVtbl;

    interface ITransactionLastEnlistmentAsync
    {
        CONST_VTBL struct ITransactionLastEnlistmentAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionLastEnlistmentAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionLastEnlistmentAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionLastEnlistmentAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionLastEnlistmentAsync_TransactionOutcome(This,XactStat,pboidReason)	\
    ( (This)->lpVtbl -> TransactionOutcome(This,XactStat,pboidReason) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionLastEnlistmentAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionExportFactory_INTERFACE_DEFINED__
#define __ITransactionExportFactory_INTERFACE_DEFINED__

/* interface ITransactionExportFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionExportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CF9B53-8745-11ce-A9BA-00AA006C3706")
    ITransactionExportFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRemoteClassId( 
            /* [out] */ __RPC__out CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ ULONG cbWhereabouts,
            /* [size_is][in] */ __RPC__in_ecount_full(cbWhereabouts) byte *rgbWhereabouts,
            /* [out] */ __RPC__deref_out_opt ITransactionExport **ppExport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionExportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionExportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionExportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionExportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteClassId )( 
            ITransactionExportFactory * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ITransactionExportFactory * This,
            /* [in] */ ULONG cbWhereabouts,
            /* [size_is][in] */ __RPC__in_ecount_full(cbWhereabouts) byte *rgbWhereabouts,
            /* [out] */ __RPC__deref_out_opt ITransactionExport **ppExport);
        
        END_INTERFACE
    } ITransactionExportFactoryVtbl;

    interface ITransactionExportFactory
    {
        CONST_VTBL struct ITransactionExportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionExportFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionExportFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionExportFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionExportFactory_GetRemoteClassId(This,pclsid)	\
    ( (This)->lpVtbl -> GetRemoteClassId(This,pclsid) ) 

#define ITransactionExportFactory_Create(This,cbWhereabouts,rgbWhereabouts,ppExport)	\
    ( (This)->lpVtbl -> Create(This,cbWhereabouts,rgbWhereabouts,ppExport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionExportFactory_INTERFACE_DEFINED__ */


#ifndef __ITransactionImportWhereabouts_INTERFACE_DEFINED__
#define __ITransactionImportWhereabouts_INTERFACE_DEFINED__

/* interface ITransactionImportWhereabouts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionImportWhereabouts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0141fda4-8fc0-11ce-bd18-204c4f4f5020")
    ITransactionImportWhereabouts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWhereaboutsSize( 
            /* [out] */ __RPC__out ULONG *pcbWhereabouts) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetWhereabouts( 
            /* [in] */ ULONG cbWhereabouts,
            /* [size_is][out] */ byte *rgbWhereabouts,
            /* [out] */ ULONG *pcbUsed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionImportWhereaboutsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionImportWhereabouts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionImportWhereabouts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionImportWhereabouts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWhereaboutsSize )( 
            ITransactionImportWhereabouts * This,
            /* [out] */ __RPC__out ULONG *pcbWhereabouts);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetWhereabouts )( 
            ITransactionImportWhereabouts * This,
            /* [in] */ ULONG cbWhereabouts,
            /* [size_is][out] */ byte *rgbWhereabouts,
            /* [out] */ ULONG *pcbUsed);
        
        END_INTERFACE
    } ITransactionImportWhereaboutsVtbl;

    interface ITransactionImportWhereabouts
    {
        CONST_VTBL struct ITransactionImportWhereaboutsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionImportWhereabouts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionImportWhereabouts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionImportWhereabouts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionImportWhereabouts_GetWhereaboutsSize(This,pcbWhereabouts)	\
    ( (This)->lpVtbl -> GetWhereaboutsSize(This,pcbWhereabouts) ) 

#define ITransactionImportWhereabouts_GetWhereabouts(This,cbWhereabouts,rgbWhereabouts,pcbUsed)	\
    ( (This)->lpVtbl -> GetWhereabouts(This,cbWhereabouts,rgbWhereabouts,pcbUsed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionImportWhereabouts_RemoteGetWhereabouts_Proxy( 
    ITransactionImportWhereabouts * This,
    /* [out] */ __RPC__out ULONG *pcbUsed,
    /* [in] */ ULONG cbWhereabouts,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cbWhereabouts, *pcbUsed) byte *rgbWhereabouts);


void __RPC_STUB ITransactionImportWhereabouts_RemoteGetWhereabouts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionImportWhereabouts_INTERFACE_DEFINED__ */


#ifndef __ITransactionExport_INTERFACE_DEFINED__
#define __ITransactionExport_INTERFACE_DEFINED__

/* interface ITransactionExport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionExport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0141fda5-8fc0-11ce-bd18-204c4f4f5020")
    ITransactionExport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Export( 
            /* [in] */ __RPC__in_opt IUnknown *punkTransaction,
            /* [out] */ __RPC__out ULONG *pcbTransactionCookie) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetTransactionCookie( 
            /* [in] */ IUnknown *punkTransaction,
            /* [in] */ ULONG cbTransactionCookie,
            /* [size_is][out] */ byte *rgbTransactionCookie,
            /* [out] */ ULONG *pcbUsed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionExportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionExport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionExport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionExport * This);
        
        HRESULT ( STDMETHODCALLTYPE *Export )( 
            ITransactionExport * This,
            /* [in] */ __RPC__in_opt IUnknown *punkTransaction,
            /* [out] */ __RPC__out ULONG *pcbTransactionCookie);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetTransactionCookie )( 
            ITransactionExport * This,
            /* [in] */ IUnknown *punkTransaction,
            /* [in] */ ULONG cbTransactionCookie,
            /* [size_is][out] */ byte *rgbTransactionCookie,
            /* [out] */ ULONG *pcbUsed);
        
        END_INTERFACE
    } ITransactionExportVtbl;

    interface ITransactionExport
    {
        CONST_VTBL struct ITransactionExportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionExport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionExport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionExport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionExport_Export(This,punkTransaction,pcbTransactionCookie)	\
    ( (This)->lpVtbl -> Export(This,punkTransaction,pcbTransactionCookie) ) 

#define ITransactionExport_GetTransactionCookie(This,punkTransaction,cbTransactionCookie,rgbTransactionCookie,pcbUsed)	\
    ( (This)->lpVtbl -> GetTransactionCookie(This,punkTransaction,cbTransactionCookie,rgbTransactionCookie,pcbUsed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionExport_RemoteGetTransactionCookie_Proxy( 
    ITransactionExport * This,
    /* [in] */ __RPC__in_opt IUnknown *punkTransaction,
    /* [out] */ __RPC__out ULONG *pcbUsed,
    /* [in] */ ULONG cbTransactionCookie,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cbTransactionCookie, *pcbUsed) byte *rgbTransactionCookie);


void __RPC_STUB ITransactionExport_RemoteGetTransactionCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionExport_INTERFACE_DEFINED__ */


#ifndef __ITransactionImport_INTERFACE_DEFINED__
#define __ITransactionImport_INTERFACE_DEFINED__

/* interface ITransactionImport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CF9B5A-8745-11ce-A9BA-00AA006C3706")
    ITransactionImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Import( 
            /* [in] */ ULONG cbTransactionCookie,
            /* [size_is][in] */ __RPC__in_ecount_full(cbTransactionCookie) byte *rgbTransactionCookie,
            /* [in] */ __RPC__in IID *piid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionImport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *Import )( 
            ITransactionImport * This,
            /* [in] */ ULONG cbTransactionCookie,
            /* [size_is][in] */ __RPC__in_ecount_full(cbTransactionCookie) byte *rgbTransactionCookie,
            /* [in] */ __RPC__in IID *piid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvTransaction);
        
        END_INTERFACE
    } ITransactionImportVtbl;

    interface ITransactionImport
    {
        CONST_VTBL struct ITransactionImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionImport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionImport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionImport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionImport_Import(This,cbTransactionCookie,rgbTransactionCookie,piid,ppvTransaction)	\
    ( (This)->lpVtbl -> Import(This,cbTransactionCookie,rgbTransactionCookie,piid,ppvTransaction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionImport_INTERFACE_DEFINED__ */


#ifndef __ITipTransaction_INTERFACE_DEFINED__
#define __ITipTransaction_INTERFACE_DEFINED__

/* interface ITipTransaction */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITipTransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17CF72D0-BAC5-11d1-B1BF-00C04FC2F3EF")
    ITipTransaction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Push( 
            /* [in] */ __RPC__in char *i_pszRemoteTmUrl,
            /* [out] */ __RPC__deref_out_opt char **o_ppszRemoteTxUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransactionUrl( 
            /* [out] */ __RPC__deref_out_opt char **o_ppszLocalTxUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITipTransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITipTransaction * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITipTransaction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITipTransaction * This);
        
        HRESULT ( STDMETHODCALLTYPE *Push )( 
            ITipTransaction * This,
            /* [in] */ __RPC__in char *i_pszRemoteTmUrl,
            /* [out] */ __RPC__deref_out_opt char **o_ppszRemoteTxUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransactionUrl )( 
            ITipTransaction * This,
            /* [out] */ __RPC__deref_out_opt char **o_ppszLocalTxUrl);
        
        END_INTERFACE
    } ITipTransactionVtbl;

    interface ITipTransaction
    {
        CONST_VTBL struct ITipTransactionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITipTransaction_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITipTransaction_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITipTransaction_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITipTransaction_Push(This,i_pszRemoteTmUrl,o_ppszRemoteTxUrl)	\
    ( (This)->lpVtbl -> Push(This,i_pszRemoteTmUrl,o_ppszRemoteTxUrl) ) 

#define ITipTransaction_GetTransactionUrl(This,o_ppszLocalTxUrl)	\
    ( (This)->lpVtbl -> GetTransactionUrl(This,o_ppszLocalTxUrl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITipTransaction_INTERFACE_DEFINED__ */


#ifndef __ITipHelper_INTERFACE_DEFINED__
#define __ITipHelper_INTERFACE_DEFINED__

/* interface ITipHelper */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITipHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17CF72D1-BAC5-11d1-B1BF-00C04FC2F3EF")
    ITipHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Pull( 
            /* [in] */ __RPC__in char *i_pszTxUrl,
            /* [out] */ __RPC__deref_out_opt ITransaction **o_ppITransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PullAsync( 
            /* [in] */ __RPC__in char *i_pszTxUrl,
            /* [in] */ __RPC__in_opt ITipPullSink *i_pTipPullSink,
            /* [out] */ __RPC__deref_out_opt ITransaction **o_ppITransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalTmUrl( 
            /* [out] */ __RPC__deref_out_opt char **o_ppszLocalTmUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITipHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITipHelper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITipHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITipHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pull )( 
            ITipHelper * This,
            /* [in] */ __RPC__in char *i_pszTxUrl,
            /* [out] */ __RPC__deref_out_opt ITransaction **o_ppITransaction);
        
        HRESULT ( STDMETHODCALLTYPE *PullAsync )( 
            ITipHelper * This,
            /* [in] */ __RPC__in char *i_pszTxUrl,
            /* [in] */ __RPC__in_opt ITipPullSink *i_pTipPullSink,
            /* [out] */ __RPC__deref_out_opt ITransaction **o_ppITransaction);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalTmUrl )( 
            ITipHelper * This,
            /* [out] */ __RPC__deref_out_opt char **o_ppszLocalTmUrl);
        
        END_INTERFACE
    } ITipHelperVtbl;

    interface ITipHelper
    {
        CONST_VTBL struct ITipHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITipHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITipHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITipHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITipHelper_Pull(This,i_pszTxUrl,o_ppITransaction)	\
    ( (This)->lpVtbl -> Pull(This,i_pszTxUrl,o_ppITransaction) ) 

#define ITipHelper_PullAsync(This,i_pszTxUrl,i_pTipPullSink,o_ppITransaction)	\
    ( (This)->lpVtbl -> PullAsync(This,i_pszTxUrl,i_pTipPullSink,o_ppITransaction) ) 

#define ITipHelper_GetLocalTmUrl(This,o_ppszLocalTmUrl)	\
    ( (This)->lpVtbl -> GetLocalTmUrl(This,o_ppszLocalTmUrl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITipHelper_INTERFACE_DEFINED__ */


#ifndef __ITipPullSink_INTERFACE_DEFINED__
#define __ITipPullSink_INTERFACE_DEFINED__

/* interface ITipPullSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITipPullSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17CF72D2-BAC5-11d1-B1BF-00C04FC2F3EF")
    ITipPullSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PullComplete( 
            /* [in] */ HRESULT i_hrPull) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITipPullSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITipPullSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITipPullSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITipPullSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PullComplete )( 
            ITipPullSink * This,
            /* [in] */ HRESULT i_hrPull);
        
        END_INTERFACE
    } ITipPullSinkVtbl;

    interface ITipPullSink
    {
        CONST_VTBL struct ITipPullSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITipPullSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITipPullSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITipPullSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITipPullSink_PullComplete(This,i_hrPull)	\
    ( (This)->lpVtbl -> PullComplete(This,i_hrPull) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITipPullSink_INTERFACE_DEFINED__ */


#ifndef __IDtcNetworkAccessConfig_INTERFACE_DEFINED__
#define __IDtcNetworkAccessConfig_INTERFACE_DEFINED__

/* interface IDtcNetworkAccessConfig */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDtcNetworkAccessConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9797C15D-A428-4291-87B6-0995031A678D")
    IDtcNetworkAccessConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAnyNetworkAccess( 
            /* [out] */ __RPC__out BOOL *pbAnyNetworkAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAnyNetworkAccess( 
            /* [in] */ BOOL bAnyNetworkAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkAdministrationAccess( 
            /* [out] */ __RPC__out BOOL *pbNetworkAdministrationAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkAdministrationAccess( 
            /* [in] */ BOOL bNetworkAdministrationAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkTransactionAccess( 
            /* [out] */ __RPC__out BOOL *pbNetworkTransactionAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkTransactionAccess( 
            /* [in] */ BOOL bNetworkTransactionAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkClientAccess( 
            /* [out] */ __RPC__out BOOL *pbNetworkClientAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkClientAccess( 
            /* [in] */ BOOL bNetworkClientAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkTIPAccess( 
            /* [out] */ __RPC__out BOOL *pbNetworkTIPAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkTIPAccess( 
            /* [in] */ BOOL bNetworkTIPAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXAAccess( 
            /* [out] */ __RPC__out BOOL *pbXAAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetXAAccess( 
            /* [in] */ BOOL bXAAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestartDtcService( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcNetworkAccessConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcNetworkAccessConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcNetworkAccessConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcNetworkAccessConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAnyNetworkAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [out] */ __RPC__out BOOL *pbAnyNetworkAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetAnyNetworkAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [in] */ BOOL bAnyNetworkAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkAdministrationAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [out] */ __RPC__out BOOL *pbNetworkAdministrationAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkAdministrationAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [in] */ BOOL bNetworkAdministrationAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkTransactionAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [out] */ __RPC__out BOOL *pbNetworkTransactionAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkTransactionAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [in] */ BOOL bNetworkTransactionAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkClientAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [out] */ __RPC__out BOOL *pbNetworkClientAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkClientAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [in] */ BOOL bNetworkClientAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkTIPAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [out] */ __RPC__out BOOL *pbNetworkTIPAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkTIPAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [in] */ BOOL bNetworkTIPAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetXAAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [out] */ __RPC__out BOOL *pbXAAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetXAAccess )( 
            IDtcNetworkAccessConfig * This,
            /* [in] */ BOOL bXAAccess);
        
        HRESULT ( STDMETHODCALLTYPE *RestartDtcService )( 
            IDtcNetworkAccessConfig * This);
        
        END_INTERFACE
    } IDtcNetworkAccessConfigVtbl;

    interface IDtcNetworkAccessConfig
    {
        CONST_VTBL struct IDtcNetworkAccessConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcNetworkAccessConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcNetworkAccessConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcNetworkAccessConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcNetworkAccessConfig_GetAnyNetworkAccess(This,pbAnyNetworkAccess)	\
    ( (This)->lpVtbl -> GetAnyNetworkAccess(This,pbAnyNetworkAccess) ) 

#define IDtcNetworkAccessConfig_SetAnyNetworkAccess(This,bAnyNetworkAccess)	\
    ( (This)->lpVtbl -> SetAnyNetworkAccess(This,bAnyNetworkAccess) ) 

#define IDtcNetworkAccessConfig_GetNetworkAdministrationAccess(This,pbNetworkAdministrationAccess)	\
    ( (This)->lpVtbl -> GetNetworkAdministrationAccess(This,pbNetworkAdministrationAccess) ) 

#define IDtcNetworkAccessConfig_SetNetworkAdministrationAccess(This,bNetworkAdministrationAccess)	\
    ( (This)->lpVtbl -> SetNetworkAdministrationAccess(This,bNetworkAdministrationAccess) ) 

#define IDtcNetworkAccessConfig_GetNetworkTransactionAccess(This,pbNetworkTransactionAccess)	\
    ( (This)->lpVtbl -> GetNetworkTransactionAccess(This,pbNetworkTransactionAccess) ) 

#define IDtcNetworkAccessConfig_SetNetworkTransactionAccess(This,bNetworkTransactionAccess)	\
    ( (This)->lpVtbl -> SetNetworkTransactionAccess(This,bNetworkTransactionAccess) ) 

#define IDtcNetworkAccessConfig_GetNetworkClientAccess(This,pbNetworkClientAccess)	\
    ( (This)->lpVtbl -> GetNetworkClientAccess(This,pbNetworkClientAccess) ) 

#define IDtcNetworkAccessConfig_SetNetworkClientAccess(This,bNetworkClientAccess)	\
    ( (This)->lpVtbl -> SetNetworkClientAccess(This,bNetworkClientAccess) ) 

#define IDtcNetworkAccessConfig_GetNetworkTIPAccess(This,pbNetworkTIPAccess)	\
    ( (This)->lpVtbl -> GetNetworkTIPAccess(This,pbNetworkTIPAccess) ) 

#define IDtcNetworkAccessConfig_SetNetworkTIPAccess(This,bNetworkTIPAccess)	\
    ( (This)->lpVtbl -> SetNetworkTIPAccess(This,bNetworkTIPAccess) ) 

#define IDtcNetworkAccessConfig_GetXAAccess(This,pbXAAccess)	\
    ( (This)->lpVtbl -> GetXAAccess(This,pbXAAccess) ) 

#define IDtcNetworkAccessConfig_SetXAAccess(This,bXAAccess)	\
    ( (This)->lpVtbl -> SetXAAccess(This,bXAAccess) ) 

#define IDtcNetworkAccessConfig_RestartDtcService(This)	\
    ( (This)->lpVtbl -> RestartDtcService(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcNetworkAccessConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txcoord_0000_0013 */
/* [local] */ 

typedef 
enum AUTHENTICATION_LEVEL
    {	NO_AUTHENTICATION_REQUIRED	= 0,
	INCOMING_AUTHENTICATION_REQUIRED	= 1,
	MUTUAL_AUTHENTICATION_REQUIRED	= 2
    } 	AUTHENTICATION_LEVEL;



extern RPC_IF_HANDLE __MIDL_itf_txcoord_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txcoord_0000_0013_v0_0_s_ifspec;

#ifndef __IDtcNetworkAccessConfig2_INTERFACE_DEFINED__
#define __IDtcNetworkAccessConfig2_INTERFACE_DEFINED__

/* interface IDtcNetworkAccessConfig2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDtcNetworkAccessConfig2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A7AA013B-EB7D-4f42-B41C-B2DEC09AE034")
    IDtcNetworkAccessConfig2 : public IDtcNetworkAccessConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNetworkInboundAccess( 
            /* [out] */ __RPC__out BOOL *pbInbound) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkOutboundAccess( 
            /* [out] */ __RPC__out BOOL *pbOutbound) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkInboundAccess( 
            /* [in] */ BOOL bInbound) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkOutboundAccess( 
            /* [in] */ BOOL bOutbound) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthenticationLevel( 
            /* [out] */ __RPC__out AUTHENTICATION_LEVEL *pAuthLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthenticationLevel( 
            /* [in] */ AUTHENTICATION_LEVEL AuthLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcNetworkAccessConfig2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcNetworkAccessConfig2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcNetworkAccessConfig2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAnyNetworkAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out BOOL *pbAnyNetworkAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetAnyNetworkAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ BOOL bAnyNetworkAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkAdministrationAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out BOOL *pbNetworkAdministrationAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkAdministrationAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ BOOL bNetworkAdministrationAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkTransactionAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out BOOL *pbNetworkTransactionAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkTransactionAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ BOOL bNetworkTransactionAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkClientAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out BOOL *pbNetworkClientAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkClientAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ BOOL bNetworkClientAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkTIPAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out BOOL *pbNetworkTIPAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkTIPAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ BOOL bNetworkTIPAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetXAAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out BOOL *pbXAAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetXAAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ BOOL bXAAccess);
        
        HRESULT ( STDMETHODCALLTYPE *RestartDtcService )( 
            IDtcNetworkAccessConfig2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkInboundAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out BOOL *pbInbound);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkOutboundAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out BOOL *pbOutbound);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkInboundAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ BOOL bInbound);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkOutboundAccess )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ BOOL bOutbound);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationLevel )( 
            IDtcNetworkAccessConfig2 * This,
            /* [out] */ __RPC__out AUTHENTICATION_LEVEL *pAuthLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthenticationLevel )( 
            IDtcNetworkAccessConfig2 * This,
            /* [in] */ AUTHENTICATION_LEVEL AuthLevel);
        
        END_INTERFACE
    } IDtcNetworkAccessConfig2Vtbl;

    interface IDtcNetworkAccessConfig2
    {
        CONST_VTBL struct IDtcNetworkAccessConfig2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcNetworkAccessConfig2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcNetworkAccessConfig2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcNetworkAccessConfig2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcNetworkAccessConfig2_GetAnyNetworkAccess(This,pbAnyNetworkAccess)	\
    ( (This)->lpVtbl -> GetAnyNetworkAccess(This,pbAnyNetworkAccess) ) 

#define IDtcNetworkAccessConfig2_SetAnyNetworkAccess(This,bAnyNetworkAccess)	\
    ( (This)->lpVtbl -> SetAnyNetworkAccess(This,bAnyNetworkAccess) ) 

#define IDtcNetworkAccessConfig2_GetNetworkAdministrationAccess(This,pbNetworkAdministrationAccess)	\
    ( (This)->lpVtbl -> GetNetworkAdministrationAccess(This,pbNetworkAdministrationAccess) ) 

#define IDtcNetworkAccessConfig2_SetNetworkAdministrationAccess(This,bNetworkAdministrationAccess)	\
    ( (This)->lpVtbl -> SetNetworkAdministrationAccess(This,bNetworkAdministrationAccess) ) 

#define IDtcNetworkAccessConfig2_GetNetworkTransactionAccess(This,pbNetworkTransactionAccess)	\
    ( (This)->lpVtbl -> GetNetworkTransactionAccess(This,pbNetworkTransactionAccess) ) 

#define IDtcNetworkAccessConfig2_SetNetworkTransactionAccess(This,bNetworkTransactionAccess)	\
    ( (This)->lpVtbl -> SetNetworkTransactionAccess(This,bNetworkTransactionAccess) ) 

#define IDtcNetworkAccessConfig2_GetNetworkClientAccess(This,pbNetworkClientAccess)	\
    ( (This)->lpVtbl -> GetNetworkClientAccess(This,pbNetworkClientAccess) ) 

#define IDtcNetworkAccessConfig2_SetNetworkClientAccess(This,bNetworkClientAccess)	\
    ( (This)->lpVtbl -> SetNetworkClientAccess(This,bNetworkClientAccess) ) 

#define IDtcNetworkAccessConfig2_GetNetworkTIPAccess(This,pbNetworkTIPAccess)	\
    ( (This)->lpVtbl -> GetNetworkTIPAccess(This,pbNetworkTIPAccess) ) 

#define IDtcNetworkAccessConfig2_SetNetworkTIPAccess(This,bNetworkTIPAccess)	\
    ( (This)->lpVtbl -> SetNetworkTIPAccess(This,bNetworkTIPAccess) ) 

#define IDtcNetworkAccessConfig2_GetXAAccess(This,pbXAAccess)	\
    ( (This)->lpVtbl -> GetXAAccess(This,pbXAAccess) ) 

#define IDtcNetworkAccessConfig2_SetXAAccess(This,bXAAccess)	\
    ( (This)->lpVtbl -> SetXAAccess(This,bXAAccess) ) 

#define IDtcNetworkAccessConfig2_RestartDtcService(This)	\
    ( (This)->lpVtbl -> RestartDtcService(This) ) 


#define IDtcNetworkAccessConfig2_GetNetworkInboundAccess(This,pbInbound)	\
    ( (This)->lpVtbl -> GetNetworkInboundAccess(This,pbInbound) ) 

#define IDtcNetworkAccessConfig2_GetNetworkOutboundAccess(This,pbOutbound)	\
    ( (This)->lpVtbl -> GetNetworkOutboundAccess(This,pbOutbound) ) 

#define IDtcNetworkAccessConfig2_SetNetworkInboundAccess(This,bInbound)	\
    ( (This)->lpVtbl -> SetNetworkInboundAccess(This,bInbound) ) 

#define IDtcNetworkAccessConfig2_SetNetworkOutboundAccess(This,bOutbound)	\
    ( (This)->lpVtbl -> SetNetworkOutboundAccess(This,bOutbound) ) 

#define IDtcNetworkAccessConfig2_GetAuthenticationLevel(This,pAuthLevel)	\
    ( (This)->lpVtbl -> GetAuthenticationLevel(This,pAuthLevel) ) 

#define IDtcNetworkAccessConfig2_SetAuthenticationLevel(This,AuthLevel)	\
    ( (This)->lpVtbl -> SetAuthenticationLevel(This,AuthLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcNetworkAccessConfig2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txcoord_0000_0014 */
/* [local] */ 



#if _MSC_VER < 1100 || !defined(__cplusplus)

DEFINE_GUID(IID_ITransactionResourceAsync,       0x69E971F0, 0x23CE, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);
DEFINE_GUID(IID_ITransactionLastResourceAsync,   0xC82BD532, 0x5B30, 0x11D3, 0x8A, 0x91, 0x00, 0xC0, 0x4F, 0x79, 0xEB, 0x6D);
DEFINE_GUID(IID_ITransactionResource,            0xEE5FF7B3, 0x4572, 0x11d0, 0x94, 0x52, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_ITransactionEnlistmentAsync,     0x0fb15081, 0xaf41, 0x11ce, 0xbd, 0x2b, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionLastEnlistmentAsync, 0xC82BD533, 0x5B30, 0x11D3, 0x8A, 0x91, 0x00, 0xC0, 0x4F, 0x79, 0xEB, 0x6D);
DEFINE_GUID(IID_ITransactionExportFactory,       0xE1CF9B53, 0x8745, 0x11ce, 0xA9, 0xBA, 0x00, 0xAA, 0x00, 0x6C, 0x37, 0x06);
DEFINE_GUID(IID_ITransactionImportWhereabouts,   0x0141fda4, 0x8fc0, 0x11ce, 0xbd, 0x18, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionExport,              0x0141fda5, 0x8fc0, 0x11ce, 0xbd, 0x18, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionImport,              0xE1CF9B5A, 0x8745, 0x11ce, 0xA9, 0xBA, 0x00, 0xAA, 0x00, 0x6C, 0x37, 0x06);
DEFINE_GUID(IID_ITipTransaction,                 0x17cf72d0, 0xbac5, 0x11d1, 0xb1, 0xbf, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITipHelper,                      0x17cf72d1, 0xbac5, 0x11d1, 0xb1, 0xbf, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITipPullSink,                    0x17cf72d2, 0xbac5, 0x11d1, 0xb1, 0xbf, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_IDtcNetworkAccessConfig,         0x9797c15d, 0xa428, 0x4291, 0x87, 0xb6, 0x9, 0x95, 0x3, 0x1a, 0x67, 0x8d);
DEFINE_GUID(IID_IDtcNetworkAccessConfig2,        0xa7aa013b, 0xeb7d, 0x4f42, 0xb4, 0x1c, 0xb2, 0xde, 0xc0, 0x9a, 0xe0, 0x34);

#else

#define  IID_ITransactionResourceAsync               __uuidof(ITransactionResourceAsync)
#define  IID_ITransactionLastResourceAsync           __uuidof(ITransactionLastResourceAsync)
#define  IID_ITransactionResource                    __uuidof(ITransactionResource)
#define  IID_ITransactionEnlistmentAsync             __uuidof(ITransactionEnlistmentAsync)
#define  IID_ITransactionLastEnlistmentAsync         __uuidof(ITransactionLastEnlistmentAsync)
#define  IID_ITransactionExportFactory               __uuidof(ITransactionExportFactory)
#define  IID_ITransactionImportWhereabouts           __uuidof(ITransactionImportWhereabouts)
#define  IID_ITransactionExport                      __uuidof(ITransactionExport)
#define  IID_ITransactionImport                      __uuidof(ITransactionImport)
#define  IID_ITipTransaction                         __uuidof(ITipTransaction)
#define  IID_ITipHelper                              __uuidof(ITipHelper)
#define  IID_ITipPullSink                            __uuidof(ITipPullSink)
#define  IID_IDtcNetworkAccessConfig                 __uuidof(IDtcNetworkAccessConfig)
#define  IID_IDtcNetworkAccessConfig2                __uuidof(IDtcNetworkAccessConfig2)

#endif
#pragma deprecated (ITipTransaction)
#pragma deprecated (ITipHelper)
#pragma deprecated (ITipPullSink)


extern RPC_IF_HANDLE __MIDL_itf_txcoord_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txcoord_0000_0014_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionImportWhereabouts_GetWhereabouts_Proxy( 
    ITransactionImportWhereabouts * This,
    /* [in] */ ULONG cbWhereabouts,
    /* [size_is][out] */ byte *rgbWhereabouts,
    /* [out] */ ULONG *pcbUsed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionImportWhereabouts_GetWhereabouts_Stub( 
    ITransactionImportWhereabouts * This,
    /* [out] */ __RPC__out ULONG *pcbUsed,
    /* [in] */ ULONG cbWhereabouts,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cbWhereabouts, *pcbUsed) byte *rgbWhereabouts);

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionExport_GetTransactionCookie_Proxy( 
    ITransactionExport * This,
    /* [in] */ IUnknown *punkTransaction,
    /* [in] */ ULONG cbTransactionCookie,
    /* [size_is][out] */ byte *rgbTransactionCookie,
    /* [out] */ ULONG *pcbUsed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionExport_GetTransactionCookie_Stub( 
    ITransactionExport * This,
    /* [in] */ __RPC__in_opt IUnknown *punkTransaction,
    /* [out] */ __RPC__out ULONG *pcbUsed,
    /* [in] */ ULONG cbTransactionCookie,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cbTransactionCookie, *pcbUsed) byte *rgbTransactionCookie);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\tvratings.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for tvratings.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tvratings_h__
#define __tvratings_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXDSToRat_FWD_DEFINED__
#define __IXDSToRat_FWD_DEFINED__
typedef interface IXDSToRat IXDSToRat;
#endif 	/* __IXDSToRat_FWD_DEFINED__ */


#ifndef __IEvalRat_FWD_DEFINED__
#define __IEvalRat_FWD_DEFINED__
typedef interface IEvalRat IEvalRat;
#endif 	/* __IEvalRat_FWD_DEFINED__ */


#ifndef __XDSToRat_FWD_DEFINED__
#define __XDSToRat_FWD_DEFINED__

#ifdef __cplusplus
typedef class XDSToRat XDSToRat;
#else
typedef struct XDSToRat XDSToRat;
#endif /* __cplusplus */

#endif 	/* __XDSToRat_FWD_DEFINED__ */


#ifndef __EvalRat_FWD_DEFINED__
#define __EvalRat_FWD_DEFINED__

#ifdef __cplusplus
typedef class EvalRat EvalRat;
#else
typedef struct EvalRat EvalRat;
#endif /* __cplusplus */

#endif 	/* __EvalRat_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_tvratings_0000_0000 */
/* [local] */ 

typedef 
enum EnTvRat_System
    {	MPAA	= 0,
	US_TV	= 1,
	Canadian_English	= 2,
	Canadian_French	= 3,
	Reserved4	= 4,
	System5	= 5,
	System6	= 6,
	Reserved7	= 7,
	TvRat_kSystems	= 8,
	TvRat_SystemDontKnow	= 255
    } 	EnTvRat_System;

typedef 
enum EnTvRat_GenericLevel
    {	TvRat_0	= 0,
	TvRat_1	= 1,
	TvRat_2	= 2,
	TvRat_3	= 3,
	TvRat_4	= 4,
	TvRat_5	= 5,
	TvRat_6	= 6,
	TvRat_7	= 7,
	TvRat_kLevels	= 8,
	TvRat_LevelDontKnow	= 255
    } 	EnTvRat_GenericLevel;

typedef 
enum EnTvRat_MPAA
    {	MPAA_NotApplicable	= TvRat_0,
	MPAA_G	= TvRat_1,
	MPAA_PG	= TvRat_2,
	MPAA_PG13	= TvRat_3,
	MPAA_R	= TvRat_4,
	MPAA_NC17	= TvRat_5,
	MPAA_X	= TvRat_6,
	MPAA_NotRated	= TvRat_7
    } 	EnTvRat_MPAA;

typedef 
enum EnTvRat_US_TV
    {	US_TV_None	= TvRat_0,
	US_TV_Y	= TvRat_1,
	US_TV_Y7	= TvRat_2,
	US_TV_G	= TvRat_3,
	US_TV_PG	= TvRat_4,
	US_TV_14	= TvRat_5,
	US_TV_MA	= TvRat_6,
	US_TV_None7	= TvRat_7
    } 	EnTvRat_US_TV;

typedef 
enum EnTvRat_CAE_TV
    {	CAE_TV_Exempt	= TvRat_0,
	CAE_TV_C	= TvRat_1,
	CAE_TV_C8	= TvRat_2,
	CAE_TV_G	= TvRat_3,
	CAE_TV_PG	= TvRat_4,
	CAE_TV_14	= TvRat_5,
	CAE_TV_18	= TvRat_6,
	CAE_TV_Reserved	= TvRat_7
    } 	EnTvRat_CAE_TV;

typedef 
enum EnTvRat_CAF_TV
    {	CAF_TV_Exempt	= TvRat_0,
	CAF_TV_G	= TvRat_1,
	CAF_TV_8	= TvRat_2,
	CAF_TV_13	= TvRat_3,
	CAF_TV_16	= TvRat_4,
	CAF_TV_18	= TvRat_5,
	CAF_TV_Reserved6	= TvRat_6,
	CAF_TV_Reserved	= TvRat_7
    } 	EnTvRat_CAF_TV;

typedef 
enum BfEnTvRat_GenericAttributes
    {	BfAttrNone	= 0,
	BfIsBlocked	= 1,
	BfIsAttr_1	= 2,
	BfIsAttr_2	= 4,
	BfIsAttr_3	= 8,
	BfIsAttr_4	= 16,
	BfIsAttr_5	= 32,
	BfIsAttr_6	= 64,
	BfIsAttr_7	= 128,
	BfValidAttrSubmask	= 255
    } 	BfEnTvRat_GenericAttributes;

typedef 
enum BfEnTvRat_Attributes_US_TV
    {	US_TV_IsBlocked	= BfIsBlocked,
	US_TV_IsViolent	= BfIsAttr_1,
	US_TV_IsSexualSituation	= BfIsAttr_2,
	US_TV_IsAdultLanguage	= BfIsAttr_3,
	US_TV_IsSexuallySuggestiveDialog	= BfIsAttr_4,
	US_TV_ValidAttrSubmask	= 31
    } 	BfEnTvRat_Attributes_US_TV;

typedef 
enum BfEnTvRat_Attributes_MPAA
    {	MPAA_IsBlocked	= BfIsBlocked,
	MPAA_ValidAttrSubmask	= 1
    } 	BfEnTvRat_Attributes_MPAA;

typedef 
enum BfEnTvRat_Attributes_CAE_TV
    {	CAE_IsBlocked	= BfIsBlocked,
	CAE_ValidAttrSubmask	= 1
    } 	BfEnTvRat_Attributes_CAE_TV;

typedef 
enum BfEnTvRat_Attributes_CAF_TV
    {	CAF_IsBlocked	= BfIsBlocked,
	CAF_ValidAttrSubmask	= 1
    } 	BfEnTvRat_Attributes_CAF_TV;



extern RPC_IF_HANDLE __MIDL_itf_tvratings_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tvratings_0000_0000_v0_0_s_ifspec;

#ifndef __IXDSToRat_INTERFACE_DEFINED__
#define __IXDSToRat_INTERFACE_DEFINED__

/* interface IXDSToRat */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IXDSToRat;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5C5C5B0-3ABC-11D6-B25B-00C04FA0C026")
    IXDSToRat : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Init( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParseXDSBytePair( 
            /* [in] */ BYTE byte1,
            /* [in] */ BYTE byte2,
            /* [out] */ __RPC__out EnTvRat_System *pEnSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *pEnLevel,
            /* [out] */ __RPC__out LONG *plBfEnAttributes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXDSToRatVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXDSToRat * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXDSToRat * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXDSToRat * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXDSToRat * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXDSToRat * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXDSToRat * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXDSToRat * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IXDSToRat * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParseXDSBytePair )( 
            IXDSToRat * This,
            /* [in] */ BYTE byte1,
            /* [in] */ BYTE byte2,
            /* [out] */ __RPC__out EnTvRat_System *pEnSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *pEnLevel,
            /* [out] */ __RPC__out LONG *plBfEnAttributes);
        
        END_INTERFACE
    } IXDSToRatVtbl;

    interface IXDSToRat
    {
        CONST_VTBL struct IXDSToRatVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXDSToRat_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXDSToRat_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXDSToRat_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXDSToRat_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXDSToRat_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXDSToRat_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXDSToRat_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXDSToRat_Init(This)	\
    ( (This)->lpVtbl -> Init(This) ) 

#define IXDSToRat_ParseXDSBytePair(This,byte1,byte2,pEnSystem,pEnLevel,plBfEnAttributes)	\
    ( (This)->lpVtbl -> ParseXDSBytePair(This,byte1,byte2,pEnSystem,pEnLevel,plBfEnAttributes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXDSToRat_INTERFACE_DEFINED__ */


#ifndef __IEvalRat_INTERFACE_DEFINED__
#define __IEvalRat_INTERFACE_DEFINED__

/* interface IEvalRat */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEvalRat;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5C5C5B1-3ABC-11D6-B25B-00C04FA0C026")
    IEvalRat : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockedRatingAttributes( 
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [retval][out] */ __RPC__out LONG *plbfAttrs) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockedRatingAttributes( 
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [in] */ LONG lbfAttrs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockUnRated( 
            /* [retval][out] */ __RPC__out BOOL *pfBlockUnRatedShows) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockUnRated( 
            /* [in] */ BOOL fBlockUnRatedShows) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MostRestrictiveRating( 
            /* [in] */ EnTvRat_System enSystem1,
            /* [in] */ EnTvRat_GenericLevel enEnLevel1,
            /* [in] */ LONG lbfEnAttr1,
            /* [in] */ EnTvRat_System enSystem2,
            /* [in] */ EnTvRat_GenericLevel enEnLevel2,
            /* [in] */ LONG lbfEnAttr2,
            /* [out] */ __RPC__out EnTvRat_System *penSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *penEnLevel,
            /* [out] */ __RPC__out LONG *plbfEnAttr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TestRating( 
            /* [in] */ EnTvRat_System enShowSystem,
            /* [in] */ EnTvRat_GenericLevel enShowLevel,
            /* [in] */ LONG lbfEnShowAttributes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEvalRatVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEvalRat * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEvalRat * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEvalRat * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEvalRat * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEvalRat * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEvalRat * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEvalRat * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockedRatingAttributes )( 
            IEvalRat * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [retval][out] */ __RPC__out LONG *plbfAttrs);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockedRatingAttributes )( 
            IEvalRat * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [in] */ LONG lbfAttrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockUnRated )( 
            IEvalRat * This,
            /* [retval][out] */ __RPC__out BOOL *pfBlockUnRatedShows);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnRated )( 
            IEvalRat * This,
            /* [in] */ BOOL fBlockUnRatedShows);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MostRestrictiveRating )( 
            IEvalRat * This,
            /* [in] */ EnTvRat_System enSystem1,
            /* [in] */ EnTvRat_GenericLevel enEnLevel1,
            /* [in] */ LONG lbfEnAttr1,
            /* [in] */ EnTvRat_System enSystem2,
            /* [in] */ EnTvRat_GenericLevel enEnLevel2,
            /* [in] */ LONG lbfEnAttr2,
            /* [out] */ __RPC__out EnTvRat_System *penSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *penEnLevel,
            /* [out] */ __RPC__out LONG *plbfEnAttr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *TestRating )( 
            IEvalRat * This,
            /* [in] */ EnTvRat_System enShowSystem,
            /* [in] */ EnTvRat_GenericLevel enShowLevel,
            /* [in] */ LONG lbfEnShowAttributes);
        
        END_INTERFACE
    } IEvalRatVtbl;

    interface IEvalRat
    {
        CONST_VTBL struct IEvalRatVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvalRat_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEvalRat_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEvalRat_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEvalRat_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IEvalRat_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IEvalRat_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IEvalRat_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IEvalRat_get_BlockedRatingAttributes(This,enSystem,enLevel,plbfAttrs)	\
    ( (This)->lpVtbl -> get_BlockedRatingAttributes(This,enSystem,enLevel,plbfAttrs) ) 

#define IEvalRat_put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs)	\
    ( (This)->lpVtbl -> put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs) ) 

#define IEvalRat_get_BlockUnRated(This,pfBlockUnRatedShows)	\
    ( (This)->lpVtbl -> get_BlockUnRated(This,pfBlockUnRatedShows) ) 

#define IEvalRat_put_BlockUnRated(This,fBlockUnRatedShows)	\
    ( (This)->lpVtbl -> put_BlockUnRated(This,fBlockUnRatedShows) ) 

#define IEvalRat_MostRestrictiveRating(This,enSystem1,enEnLevel1,lbfEnAttr1,enSystem2,enEnLevel2,lbfEnAttr2,penSystem,penEnLevel,plbfEnAttr)	\
    ( (This)->lpVtbl -> MostRestrictiveRating(This,enSystem1,enEnLevel1,lbfEnAttr1,enSystem2,enEnLevel2,lbfEnAttr2,penSystem,penEnLevel,plbfEnAttr) ) 

#define IEvalRat_TestRating(This,enShowSystem,enShowLevel,lbfEnShowAttributes)	\
    ( (This)->lpVtbl -> TestRating(This,enShowSystem,enShowLevel,lbfEnShowAttributes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEvalRat_INTERFACE_DEFINED__ */



#ifndef __TVRATINGSLib_LIBRARY_DEFINED__
#define __TVRATINGSLib_LIBRARY_DEFINED__

/* library TVRATINGSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TVRATINGSLib;

EXTERN_C const CLSID CLSID_XDSToRat;

#ifdef __cplusplus

class DECLSPEC_UUID("C5C5C5F0-3ABC-11D6-B25B-00C04FA0C026")
XDSToRat;
#endif

EXTERN_C const CLSID CLSID_EvalRat;

#ifdef __cplusplus

class DECLSPEC_UUID("C5C5C5F1-3ABC-11D6-B25B-00C04FA0C026")
EvalRat;
#endif
#endif /* __TVRATINGSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\TxDtc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for txdtc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __txdtc_h__
#define __txdtc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXATransLookup_FWD_DEFINED__
#define __IXATransLookup_FWD_DEFINED__
typedef interface IXATransLookup IXATransLookup;
#endif 	/* __IXATransLookup_FWD_DEFINED__ */


#ifndef __IXATransLookup2_FWD_DEFINED__
#define __IXATransLookup2_FWD_DEFINED__
typedef interface IXATransLookup2 IXATransLookup2;
#endif 	/* __IXATransLookup2_FWD_DEFINED__ */


#ifndef __IResourceManagerSink_FWD_DEFINED__
#define __IResourceManagerSink_FWD_DEFINED__
typedef interface IResourceManagerSink IResourceManagerSink;
#endif 	/* __IResourceManagerSink_FWD_DEFINED__ */


#ifndef __IResourceManager_FWD_DEFINED__
#define __IResourceManager_FWD_DEFINED__
typedef interface IResourceManager IResourceManager;
#endif 	/* __IResourceManager_FWD_DEFINED__ */


#ifndef __ILastResourceManager_FWD_DEFINED__
#define __ILastResourceManager_FWD_DEFINED__
typedef interface ILastResourceManager ILastResourceManager;
#endif 	/* __ILastResourceManager_FWD_DEFINED__ */


#ifndef __IResourceManager2_FWD_DEFINED__
#define __IResourceManager2_FWD_DEFINED__
typedef interface IResourceManager2 IResourceManager2;
#endif 	/* __IResourceManager2_FWD_DEFINED__ */


#ifndef __IXAConfig_FWD_DEFINED__
#define __IXAConfig_FWD_DEFINED__
typedef interface IXAConfig IXAConfig;
#endif 	/* __IXAConfig_FWD_DEFINED__ */


#ifndef __IRMHelper_FWD_DEFINED__
#define __IRMHelper_FWD_DEFINED__
typedef interface IRMHelper IRMHelper;
#endif 	/* __IRMHelper_FWD_DEFINED__ */


#ifndef __IXAObtainRMInfo_FWD_DEFINED__
#define __IXAObtainRMInfo_FWD_DEFINED__
typedef interface IXAObtainRMInfo IXAObtainRMInfo;
#endif 	/* __IXAObtainRMInfo_FWD_DEFINED__ */


#ifndef __IResourceManagerFactory_FWD_DEFINED__
#define __IResourceManagerFactory_FWD_DEFINED__
typedef interface IResourceManagerFactory IResourceManagerFactory;
#endif 	/* __IResourceManagerFactory_FWD_DEFINED__ */


#ifndef __IResourceManagerFactory2_FWD_DEFINED__
#define __IResourceManagerFactory2_FWD_DEFINED__
typedef interface IResourceManagerFactory2 IResourceManagerFactory2;
#endif 	/* __IResourceManagerFactory2_FWD_DEFINED__ */


#ifndef __IPrepareInfo_FWD_DEFINED__
#define __IPrepareInfo_FWD_DEFINED__
typedef interface IPrepareInfo IPrepareInfo;
#endif 	/* __IPrepareInfo_FWD_DEFINED__ */


#ifndef __IPrepareInfo2_FWD_DEFINED__
#define __IPrepareInfo2_FWD_DEFINED__
typedef interface IPrepareInfo2 IPrepareInfo2;
#endif 	/* __IPrepareInfo2_FWD_DEFINED__ */


#ifndef __IGetDispenser_FWD_DEFINED__
#define __IGetDispenser_FWD_DEFINED__
typedef interface IGetDispenser IGetDispenser;
#endif 	/* __IGetDispenser_FWD_DEFINED__ */


#ifndef __ITransactionVoterBallotAsync2_FWD_DEFINED__
#define __ITransactionVoterBallotAsync2_FWD_DEFINED__
typedef interface ITransactionVoterBallotAsync2 ITransactionVoterBallotAsync2;
#endif 	/* __ITransactionVoterBallotAsync2_FWD_DEFINED__ */


#ifndef __ITransactionVoterNotifyAsync2_FWD_DEFINED__
#define __ITransactionVoterNotifyAsync2_FWD_DEFINED__
typedef interface ITransactionVoterNotifyAsync2 ITransactionVoterNotifyAsync2;
#endif 	/* __ITransactionVoterNotifyAsync2_FWD_DEFINED__ */


#ifndef __ITransactionVoterFactory2_FWD_DEFINED__
#define __ITransactionVoterFactory2_FWD_DEFINED__
typedef interface ITransactionVoterFactory2 ITransactionVoterFactory2;
#endif 	/* __ITransactionVoterFactory2_FWD_DEFINED__ */


#ifndef __ITransactionPhase0EnlistmentAsync_FWD_DEFINED__
#define __ITransactionPhase0EnlistmentAsync_FWD_DEFINED__
typedef interface ITransactionPhase0EnlistmentAsync ITransactionPhase0EnlistmentAsync;
#endif 	/* __ITransactionPhase0EnlistmentAsync_FWD_DEFINED__ */


#ifndef __ITransactionPhase0NotifyAsync_FWD_DEFINED__
#define __ITransactionPhase0NotifyAsync_FWD_DEFINED__
typedef interface ITransactionPhase0NotifyAsync ITransactionPhase0NotifyAsync;
#endif 	/* __ITransactionPhase0NotifyAsync_FWD_DEFINED__ */


#ifndef __ITransactionPhase0Factory_FWD_DEFINED__
#define __ITransactionPhase0Factory_FWD_DEFINED__
typedef interface ITransactionPhase0Factory ITransactionPhase0Factory;
#endif 	/* __ITransactionPhase0Factory_FWD_DEFINED__ */


#ifndef __ITransactionTransmitter_FWD_DEFINED__
#define __ITransactionTransmitter_FWD_DEFINED__
typedef interface ITransactionTransmitter ITransactionTransmitter;
#endif 	/* __ITransactionTransmitter_FWD_DEFINED__ */


#ifndef __ITransactionTransmitterFactory_FWD_DEFINED__
#define __ITransactionTransmitterFactory_FWD_DEFINED__
typedef interface ITransactionTransmitterFactory ITransactionTransmitterFactory;
#endif 	/* __ITransactionTransmitterFactory_FWD_DEFINED__ */


#ifndef __ITransactionReceiver_FWD_DEFINED__
#define __ITransactionReceiver_FWD_DEFINED__
typedef interface ITransactionReceiver ITransactionReceiver;
#endif 	/* __ITransactionReceiver_FWD_DEFINED__ */


#ifndef __ITransactionReceiverFactory_FWD_DEFINED__
#define __ITransactionReceiverFactory_FWD_DEFINED__
typedef interface ITransactionReceiverFactory ITransactionReceiverFactory;
#endif 	/* __ITransactionReceiverFactory_FWD_DEFINED__ */


#ifndef __IDtcLuConfigure_FWD_DEFINED__
#define __IDtcLuConfigure_FWD_DEFINED__
typedef interface IDtcLuConfigure IDtcLuConfigure;
#endif 	/* __IDtcLuConfigure_FWD_DEFINED__ */


#ifndef __IDtcLuRecovery_FWD_DEFINED__
#define __IDtcLuRecovery_FWD_DEFINED__
typedef interface IDtcLuRecovery IDtcLuRecovery;
#endif 	/* __IDtcLuRecovery_FWD_DEFINED__ */


#ifndef __IDtcLuRecoveryFactory_FWD_DEFINED__
#define __IDtcLuRecoveryFactory_FWD_DEFINED__
typedef interface IDtcLuRecoveryFactory IDtcLuRecoveryFactory;
#endif 	/* __IDtcLuRecoveryFactory_FWD_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByDtcTransWork_FWD_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtcTransWork_FWD_DEFINED__
typedef interface IDtcLuRecoveryInitiatedByDtcTransWork IDtcLuRecoveryInitiatedByDtcTransWork;
#endif 	/* __IDtcLuRecoveryInitiatedByDtcTransWork_FWD_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByDtcStatusWork_FWD_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtcStatusWork_FWD_DEFINED__
typedef interface IDtcLuRecoveryInitiatedByDtcStatusWork IDtcLuRecoveryInitiatedByDtcStatusWork;
#endif 	/* __IDtcLuRecoveryInitiatedByDtcStatusWork_FWD_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByDtc_FWD_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtc_FWD_DEFINED__
typedef interface IDtcLuRecoveryInitiatedByDtc IDtcLuRecoveryInitiatedByDtc;
#endif 	/* __IDtcLuRecoveryInitiatedByDtc_FWD_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByLuWork_FWD_DEFINED__
#define __IDtcLuRecoveryInitiatedByLuWork_FWD_DEFINED__
typedef interface IDtcLuRecoveryInitiatedByLuWork IDtcLuRecoveryInitiatedByLuWork;
#endif 	/* __IDtcLuRecoveryInitiatedByLuWork_FWD_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByLu_FWD_DEFINED__
#define __IDtcLuRecoveryInitiatedByLu_FWD_DEFINED__
typedef interface IDtcLuRecoveryInitiatedByLu IDtcLuRecoveryInitiatedByLu;
#endif 	/* __IDtcLuRecoveryInitiatedByLu_FWD_DEFINED__ */


#ifndef __IDtcLuRmEnlistment_FWD_DEFINED__
#define __IDtcLuRmEnlistment_FWD_DEFINED__
typedef interface IDtcLuRmEnlistment IDtcLuRmEnlistment;
#endif 	/* __IDtcLuRmEnlistment_FWD_DEFINED__ */


#ifndef __IDtcLuRmEnlistmentSink_FWD_DEFINED__
#define __IDtcLuRmEnlistmentSink_FWD_DEFINED__
typedef interface IDtcLuRmEnlistmentSink IDtcLuRmEnlistmentSink;
#endif 	/* __IDtcLuRmEnlistmentSink_FWD_DEFINED__ */


#ifndef __IDtcLuRmEnlistmentFactory_FWD_DEFINED__
#define __IDtcLuRmEnlistmentFactory_FWD_DEFINED__
typedef interface IDtcLuRmEnlistmentFactory IDtcLuRmEnlistmentFactory;
#endif 	/* __IDtcLuRmEnlistmentFactory_FWD_DEFINED__ */


#ifndef __IDtcLuSubordinateDtc_FWD_DEFINED__
#define __IDtcLuSubordinateDtc_FWD_DEFINED__
typedef interface IDtcLuSubordinateDtc IDtcLuSubordinateDtc;
#endif 	/* __IDtcLuSubordinateDtc_FWD_DEFINED__ */


#ifndef __IDtcLuSubordinateDtcSink_FWD_DEFINED__
#define __IDtcLuSubordinateDtcSink_FWD_DEFINED__
typedef interface IDtcLuSubordinateDtcSink IDtcLuSubordinateDtcSink;
#endif 	/* __IDtcLuSubordinateDtcSink_FWD_DEFINED__ */


#ifndef __IDtcLuSubordinateDtcFactory_FWD_DEFINED__
#define __IDtcLuSubordinateDtcFactory_FWD_DEFINED__
typedef interface IDtcLuSubordinateDtcFactory IDtcLuSubordinateDtcFactory;
#endif 	/* __IDtcLuSubordinateDtcFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "txcoord.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_txdtc_0000_0000 */
/* [local] */ 

#define XACTTOMSG(dwXact) (dwXact-0x00040000+0x40000000)
typedef 
enum XACT_DTC_CONSTANTS
    {	XACT_E_CONNECTION_REQUEST_DENIED	= 0x8004d100L,
	XACT_E_TOOMANY_ENLISTMENTS	= 0x8004d101L,
	XACT_E_DUPLICATE_GUID	= 0x8004d102L,
	XACT_E_NOTSINGLEPHASE	= 0x8004d103L,
	XACT_E_RECOVERYALREADYDONE	= 0x8004d104L,
	XACT_E_PROTOCOL	= 0x8004d105L,
	XACT_E_RM_FAILURE	= 0x8004d106L,
	XACT_E_RECOVERY_FAILED	= 0x8004d107L,
	XACT_E_LU_NOT_FOUND	= 0x8004d108L,
	XACT_E_DUPLICATE_LU	= 0x8004d109L,
	XACT_E_LU_NOT_CONNECTED	= 0x8004d10aL,
	XACT_E_DUPLICATE_TRANSID	= 0x8004d10bL,
	XACT_E_LU_BUSY	= 0x8004d10cL,
	XACT_E_LU_NO_RECOVERY_PROCESS	= 0x8004d10dL,
	XACT_E_LU_DOWN	= 0x8004d10eL,
	XACT_E_LU_RECOVERING	= 0x8004d10fL,
	XACT_E_LU_RECOVERY_MISMATCH	= 0x8004d110L,
	XACT_E_RM_UNAVAILABLE	= 0x8004d111L,
	XACT_E_LRMRECOVERYALREADYDONE	= 0x8004d112L,
	XACT_E_NOLASTRESOURCEINTERFACE	= 0x8004d113L,
	XACT_S_NONOTIFY	= 0x4d100L,
	XACT_OK_NONOTIFY	= 0x4d101L,
	dwUSER_MS_SQLSERVER	= 0xffff
    } 	XACT_DTC_CONSTANTS;

#ifndef _XID_T_DEFINED
#define _XID_T_DEFINED
typedef struct xid_t
    {
    long formatID;
    long gtrid_length;
    long bqual_length;
    char data[ 128 ];
    } 	XID;

#endif
#ifndef _XA_SWITCH_T_DEFINED
#define _XA_SWITCH_T_DEFINED
typedef struct xa_switch_t
    {
    char name[ 32 ];
    long flags;
    long version;
    int ( __cdecl *xa_open_entry )( 
        char *__MIDL____MIDL_itf_txdtc_0000_00000000,
        int __MIDL____MIDL_itf_txdtc_0000_00000001,
        long __MIDL____MIDL_itf_txdtc_0000_00000002);
    int ( __cdecl *xa_close_entry )( 
        char *__MIDL____MIDL_itf_txdtc_0000_00000004,
        int __MIDL____MIDL_itf_txdtc_0000_00000005,
        long __MIDL____MIDL_itf_txdtc_0000_00000006);
    int ( __cdecl *xa_start_entry )( 
        XID *__MIDL____MIDL_itf_txdtc_0000_00000008,
        int __MIDL____MIDL_itf_txdtc_0000_00000009,
        long __MIDL____MIDL_itf_txdtc_0000_00000010);
    int ( __cdecl *xa_end_entry )( 
        XID *__MIDL____MIDL_itf_txdtc_0000_00000012,
        int __MIDL____MIDL_itf_txdtc_0000_00000013,
        long __MIDL____MIDL_itf_txdtc_0000_00000014);
    int ( __cdecl *xa_rollback_entry )( 
        XID *__MIDL____MIDL_itf_txdtc_0000_00000016,
        int __MIDL____MIDL_itf_txdtc_0000_00000017,
        long __MIDL____MIDL_itf_txdtc_0000_00000018);
    int ( __cdecl *xa_prepare_entry )( 
        XID *__MIDL____MIDL_itf_txdtc_0000_00000020,
        int __MIDL____MIDL_itf_txdtc_0000_00000021,
        long __MIDL____MIDL_itf_txdtc_0000_00000022);
    int ( __cdecl *xa_commit_entry )( 
        XID *__MIDL____MIDL_itf_txdtc_0000_00000024,
        int __MIDL____MIDL_itf_txdtc_0000_00000025,
        long __MIDL____MIDL_itf_txdtc_0000_00000026);
    int ( __cdecl *xa_recover_entry )( 
        XID *__MIDL____MIDL_itf_txdtc_0000_00000028,
        long __MIDL____MIDL_itf_txdtc_0000_00000029,
        int __MIDL____MIDL_itf_txdtc_0000_00000030,
        long __MIDL____MIDL_itf_txdtc_0000_00000031);
    int ( __cdecl *xa_forget_entry )( 
        XID *__MIDL____MIDL_itf_txdtc_0000_00000033,
        int __MIDL____MIDL_itf_txdtc_0000_00000034,
        long __MIDL____MIDL_itf_txdtc_0000_00000035);
    int ( __cdecl *xa_complete_entry )( 
        int *__MIDL____MIDL_itf_txdtc_0000_00000037,
        int *__MIDL____MIDL_itf_txdtc_0000_00000038,
        int __MIDL____MIDL_itf_txdtc_0000_00000039,
        long __MIDL____MIDL_itf_txdtc_0000_00000040);
    } 	xa_switch_t;

#endif


extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0000_v0_0_s_ifspec;

#ifndef __IXATransLookup_INTERFACE_DEFINED__
#define __IXATransLookup_INTERFACE_DEFINED__

/* interface IXATransLookup */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IXATransLookup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F3B1F131-EEDA-11ce-AED4-00AA0051E2C4")
    IXATransLookup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Lookup( 
            /* [out] */ __RPC__deref_out_opt ITransaction **ppTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXATransLookupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXATransLookup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXATransLookup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXATransLookup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Lookup )( 
            IXATransLookup * This,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppTransaction);
        
        END_INTERFACE
    } IXATransLookupVtbl;

    interface IXATransLookup
    {
        CONST_VTBL struct IXATransLookupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXATransLookup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXATransLookup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXATransLookup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXATransLookup_Lookup(This,ppTransaction)	\
    ( (This)->lpVtbl -> Lookup(This,ppTransaction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXATransLookup_INTERFACE_DEFINED__ */


#ifndef __IXATransLookup2_INTERFACE_DEFINED__
#define __IXATransLookup2_INTERFACE_DEFINED__

/* interface IXATransLookup2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IXATransLookup2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BF193C85-0D1A-4290-B88F-D2CB8873D1E7")
    IXATransLookup2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Lookup( 
            /* [in] */ __RPC__in XID *pXID,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXATransLookup2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXATransLookup2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXATransLookup2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXATransLookup2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Lookup )( 
            IXATransLookup2 * This,
            /* [in] */ __RPC__in XID *pXID,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppTransaction);
        
        END_INTERFACE
    } IXATransLookup2Vtbl;

    interface IXATransLookup2
    {
        CONST_VTBL struct IXATransLookup2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXATransLookup2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXATransLookup2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXATransLookup2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXATransLookup2_Lookup(This,pXID,ppTransaction)	\
    ( (This)->lpVtbl -> Lookup(This,pXID,ppTransaction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXATransLookup2_INTERFACE_DEFINED__ */


#ifndef __IResourceManagerSink_INTERFACE_DEFINED__
#define __IResourceManagerSink_INTERFACE_DEFINED__

/* interface IResourceManagerSink */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IResourceManagerSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0D563181-DEFB-11ce-AED1-00AA0051E2C4")
    IResourceManagerSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TMDown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceManagerSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceManagerSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceManagerSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceManagerSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *TMDown )( 
            IResourceManagerSink * This);
        
        END_INTERFACE
    } IResourceManagerSinkVtbl;

    interface IResourceManagerSink
    {
        CONST_VTBL struct IResourceManagerSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceManagerSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResourceManagerSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResourceManagerSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResourceManagerSink_TMDown(This)	\
    ( (This)->lpVtbl -> TMDown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResourceManagerSink_INTERFACE_DEFINED__ */


#ifndef __IResourceManager_INTERFACE_DEFINED__
#define __IResourceManager_INTERFACE_DEFINED__

/* interface IResourceManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IResourceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13741d21-87eb-11ce-8081-0080c758527e")
    IResourceManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Enlist( 
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionResourceAsync *pRes,
            /* [out] */ __RPC__out XACTUOW *pUOW,
            /* [out] */ __RPC__out LONG *pisoLevel,
            /* [out] */ __RPC__deref_out_opt ITransactionEnlistmentAsync **ppEnlist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reenlist( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbPrepInfo) byte *pPrepInfo,
            /* [in] */ ULONG cbPrepInfo,
            /* [in] */ DWORD lTimeout,
            /* [out] */ __RPC__out XACTSTAT *pXactStat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReenlistmentComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDistributedTransactionManager( 
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enlist )( 
            IResourceManager * This,
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionResourceAsync *pRes,
            /* [out] */ __RPC__out XACTUOW *pUOW,
            /* [out] */ __RPC__out LONG *pisoLevel,
            /* [out] */ __RPC__deref_out_opt ITransactionEnlistmentAsync **ppEnlist);
        
        HRESULT ( STDMETHODCALLTYPE *Reenlist )( 
            IResourceManager * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbPrepInfo) byte *pPrepInfo,
            /* [in] */ ULONG cbPrepInfo,
            /* [in] */ DWORD lTimeout,
            /* [out] */ __RPC__out XACTSTAT *pXactStat);
        
        HRESULT ( STDMETHODCALLTYPE *ReenlistmentComplete )( 
            IResourceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDistributedTransactionManager )( 
            IResourceManager * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        END_INTERFACE
    } IResourceManagerVtbl;

    interface IResourceManager
    {
        CONST_VTBL struct IResourceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResourceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResourceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResourceManager_Enlist(This,pTransaction,pRes,pUOW,pisoLevel,ppEnlist)	\
    ( (This)->lpVtbl -> Enlist(This,pTransaction,pRes,pUOW,pisoLevel,ppEnlist) ) 

#define IResourceManager_Reenlist(This,pPrepInfo,cbPrepInfo,lTimeout,pXactStat)	\
    ( (This)->lpVtbl -> Reenlist(This,pPrepInfo,cbPrepInfo,lTimeout,pXactStat) ) 

#define IResourceManager_ReenlistmentComplete(This)	\
    ( (This)->lpVtbl -> ReenlistmentComplete(This) ) 

#define IResourceManager_GetDistributedTransactionManager(This,iid,ppvObject)	\
    ( (This)->lpVtbl -> GetDistributedTransactionManager(This,iid,ppvObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResourceManager_INTERFACE_DEFINED__ */


#ifndef __ILastResourceManager_INTERFACE_DEFINED__
#define __ILastResourceManager_INTERFACE_DEFINED__

/* interface ILastResourceManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ILastResourceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4D964AD4-5B33-11d3-8A91-00C04F79EB6D")
    ILastResourceManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TransactionCommitted( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbPrepInfo) byte *pPrepInfo,
            /* [in] */ ULONG cbPrepInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecoveryDone( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILastResourceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILastResourceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILastResourceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILastResourceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *TransactionCommitted )( 
            ILastResourceManager * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbPrepInfo) byte *pPrepInfo,
            /* [in] */ ULONG cbPrepInfo);
        
        HRESULT ( STDMETHODCALLTYPE *RecoveryDone )( 
            ILastResourceManager * This);
        
        END_INTERFACE
    } ILastResourceManagerVtbl;

    interface ILastResourceManager
    {
        CONST_VTBL struct ILastResourceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILastResourceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILastResourceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILastResourceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILastResourceManager_TransactionCommitted(This,pPrepInfo,cbPrepInfo)	\
    ( (This)->lpVtbl -> TransactionCommitted(This,pPrepInfo,cbPrepInfo) ) 

#define ILastResourceManager_RecoveryDone(This)	\
    ( (This)->lpVtbl -> RecoveryDone(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILastResourceManager_INTERFACE_DEFINED__ */


#ifndef __IResourceManager2_INTERFACE_DEFINED__
#define __IResourceManager2_INTERFACE_DEFINED__

/* interface IResourceManager2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IResourceManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D136C69A-F749-11d1-8F47-00C04F8EE57D")
    IResourceManager2 : public IResourceManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Enlist2( 
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionResourceAsync *pResAsync,
            /* [out] */ __RPC__out XACTUOW *pUOW,
            /* [out] */ __RPC__out LONG *pisoLevel,
            /* [out] */ __RPC__out XID *pXid,
            /* [out] */ __RPC__deref_out_opt ITransactionEnlistmentAsync **ppEnlist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reenlist2( 
            /* [in] */ __RPC__in XID *pXid,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__out XACTSTAT *pXactStat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceManager2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enlist )( 
            IResourceManager2 * This,
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionResourceAsync *pRes,
            /* [out] */ __RPC__out XACTUOW *pUOW,
            /* [out] */ __RPC__out LONG *pisoLevel,
            /* [out] */ __RPC__deref_out_opt ITransactionEnlistmentAsync **ppEnlist);
        
        HRESULT ( STDMETHODCALLTYPE *Reenlist )( 
            IResourceManager2 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbPrepInfo) byte *pPrepInfo,
            /* [in] */ ULONG cbPrepInfo,
            /* [in] */ DWORD lTimeout,
            /* [out] */ __RPC__out XACTSTAT *pXactStat);
        
        HRESULT ( STDMETHODCALLTYPE *ReenlistmentComplete )( 
            IResourceManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDistributedTransactionManager )( 
            IResourceManager2 * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *Enlist2 )( 
            IResourceManager2 * This,
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionResourceAsync *pResAsync,
            /* [out] */ __RPC__out XACTUOW *pUOW,
            /* [out] */ __RPC__out LONG *pisoLevel,
            /* [out] */ __RPC__out XID *pXid,
            /* [out] */ __RPC__deref_out_opt ITransactionEnlistmentAsync **ppEnlist);
        
        HRESULT ( STDMETHODCALLTYPE *Reenlist2 )( 
            IResourceManager2 * This,
            /* [in] */ __RPC__in XID *pXid,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__out XACTSTAT *pXactStat);
        
        END_INTERFACE
    } IResourceManager2Vtbl;

    interface IResourceManager2
    {
        CONST_VTBL struct IResourceManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceManager2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResourceManager2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResourceManager2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResourceManager2_Enlist(This,pTransaction,pRes,pUOW,pisoLevel,ppEnlist)	\
    ( (This)->lpVtbl -> Enlist(This,pTransaction,pRes,pUOW,pisoLevel,ppEnlist) ) 

#define IResourceManager2_Reenlist(This,pPrepInfo,cbPrepInfo,lTimeout,pXactStat)	\
    ( (This)->lpVtbl -> Reenlist(This,pPrepInfo,cbPrepInfo,lTimeout,pXactStat) ) 

#define IResourceManager2_ReenlistmentComplete(This)	\
    ( (This)->lpVtbl -> ReenlistmentComplete(This) ) 

#define IResourceManager2_GetDistributedTransactionManager(This,iid,ppvObject)	\
    ( (This)->lpVtbl -> GetDistributedTransactionManager(This,iid,ppvObject) ) 


#define IResourceManager2_Enlist2(This,pTransaction,pResAsync,pUOW,pisoLevel,pXid,ppEnlist)	\
    ( (This)->lpVtbl -> Enlist2(This,pTransaction,pResAsync,pUOW,pisoLevel,pXid,ppEnlist) ) 

#define IResourceManager2_Reenlist2(This,pXid,dwTimeout,pXactStat)	\
    ( (This)->lpVtbl -> Reenlist2(This,pXid,dwTimeout,pXactStat) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResourceManager2_INTERFACE_DEFINED__ */


#ifndef __IXAConfig_INTERFACE_DEFINED__
#define __IXAConfig_INTERFACE_DEFINED__

/* interface IXAConfig */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IXAConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8A6E3A1-9A8C-11cf-A308-00A0C905416E")
    IXAConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ GUID clsidHelperDll) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXAConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXAConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXAConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXAConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IXAConfig * This,
            /* [in] */ GUID clsidHelperDll);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IXAConfig * This);
        
        END_INTERFACE
    } IXAConfigVtbl;

    interface IXAConfig
    {
        CONST_VTBL struct IXAConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXAConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXAConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXAConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXAConfig_Initialize(This,clsidHelperDll)	\
    ( (This)->lpVtbl -> Initialize(This,clsidHelperDll) ) 

#define IXAConfig_Terminate(This)	\
    ( (This)->lpVtbl -> Terminate(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXAConfig_INTERFACE_DEFINED__ */


#ifndef __IRMHelper_INTERFACE_DEFINED__
#define __IRMHelper_INTERFACE_DEFINED__

/* interface IRMHelper */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IRMHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E793F6D1-F53D-11cf-A60D-00A0C905416E")
    IRMHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RMCount( 
            /* [in] */ DWORD dwcTotalNumberOfRMs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RMInfo( 
            /* [in] */ xa_switch_t *pXa_Switch,
            /* [in] */ BOOL fCDeclCallingConv,
            /* [string][in] */ 
            __nullterminated  char *pszOpenString,
            /* [string][in] */ 
            __nullterminated  char *pszCloseString,
            /* [in] */ GUID guidRMRecovery) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRMHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRMHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRMHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRMHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *RMCount )( 
            IRMHelper * This,
            /* [in] */ DWORD dwcTotalNumberOfRMs);
        
        HRESULT ( STDMETHODCALLTYPE *RMInfo )( 
            IRMHelper * This,
            /* [in] */ xa_switch_t *pXa_Switch,
            /* [in] */ BOOL fCDeclCallingConv,
            /* [string][in] */ 
            __nullterminated  char *pszOpenString,
            /* [string][in] */ 
            __nullterminated  char *pszCloseString,
            /* [in] */ GUID guidRMRecovery);
        
        END_INTERFACE
    } IRMHelperVtbl;

    interface IRMHelper
    {
        CONST_VTBL struct IRMHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRMHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRMHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRMHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRMHelper_RMCount(This,dwcTotalNumberOfRMs)	\
    ( (This)->lpVtbl -> RMCount(This,dwcTotalNumberOfRMs) ) 

#define IRMHelper_RMInfo(This,pXa_Switch,fCDeclCallingConv,pszOpenString,pszCloseString,guidRMRecovery)	\
    ( (This)->lpVtbl -> RMInfo(This,pXa_Switch,fCDeclCallingConv,pszOpenString,pszCloseString,guidRMRecovery) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRMHelper_INTERFACE_DEFINED__ */


#ifndef __IXAObtainRMInfo_INTERFACE_DEFINED__
#define __IXAObtainRMInfo_INTERFACE_DEFINED__

/* interface IXAObtainRMInfo */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IXAObtainRMInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E793F6D2-F53D-11cf-A60D-00A0C905416E")
    IXAObtainRMInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ObtainRMInfo( 
            /* [in] */ __RPC__in_opt IRMHelper *pIRMHelper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXAObtainRMInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXAObtainRMInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXAObtainRMInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXAObtainRMInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *ObtainRMInfo )( 
            IXAObtainRMInfo * This,
            /* [in] */ __RPC__in_opt IRMHelper *pIRMHelper);
        
        END_INTERFACE
    } IXAObtainRMInfoVtbl;

    interface IXAObtainRMInfo
    {
        CONST_VTBL struct IXAObtainRMInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXAObtainRMInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXAObtainRMInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXAObtainRMInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXAObtainRMInfo_ObtainRMInfo(This,pIRMHelper)	\
    ( (This)->lpVtbl -> ObtainRMInfo(This,pIRMHelper) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXAObtainRMInfo_INTERFACE_DEFINED__ */


#ifndef __IResourceManagerFactory_INTERFACE_DEFINED__
#define __IResourceManagerFactory_INTERFACE_DEFINED__

/* interface IResourceManagerFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IResourceManagerFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13741d20-87eb-11ce-8081-0080c758527e")
    IResourceManagerFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in GUID *pguidRM,
            /* [string][in] */ __RPC__in CHAR *pszRMName,
            /* [in] */ __RPC__in_opt IResourceManagerSink *pIResMgrSink,
            /* [out] */ __RPC__deref_out_opt IResourceManager **ppResMgr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceManagerFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceManagerFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceManagerFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceManagerFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IResourceManagerFactory * This,
            /* [in] */ __RPC__in GUID *pguidRM,
            /* [string][in] */ __RPC__in CHAR *pszRMName,
            /* [in] */ __RPC__in_opt IResourceManagerSink *pIResMgrSink,
            /* [out] */ __RPC__deref_out_opt IResourceManager **ppResMgr);
        
        END_INTERFACE
    } IResourceManagerFactoryVtbl;

    interface IResourceManagerFactory
    {
        CONST_VTBL struct IResourceManagerFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceManagerFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResourceManagerFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResourceManagerFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResourceManagerFactory_Create(This,pguidRM,pszRMName,pIResMgrSink,ppResMgr)	\
    ( (This)->lpVtbl -> Create(This,pguidRM,pszRMName,pIResMgrSink,ppResMgr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResourceManagerFactory_INTERFACE_DEFINED__ */


#ifndef __IResourceManagerFactory2_INTERFACE_DEFINED__
#define __IResourceManagerFactory2_INTERFACE_DEFINED__

/* interface IResourceManagerFactory2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IResourceManagerFactory2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6B369C21-FBD2-11d1-8F47-00C04F8EE57D")
    IResourceManagerFactory2 : public IResourceManagerFactory
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEx( 
            /* [in] */ __RPC__in GUID *pguidRM,
            /* [string][in] */ __RPC__in CHAR *pszRMName,
            /* [in] */ __RPC__in_opt IResourceManagerSink *pIResMgrSink,
            /* [in] */ __RPC__in REFIID riidRequested,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvResMgr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceManagerFactory2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceManagerFactory2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceManagerFactory2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceManagerFactory2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IResourceManagerFactory2 * This,
            /* [in] */ __RPC__in GUID *pguidRM,
            /* [string][in] */ __RPC__in CHAR *pszRMName,
            /* [in] */ __RPC__in_opt IResourceManagerSink *pIResMgrSink,
            /* [out] */ __RPC__deref_out_opt IResourceManager **ppResMgr);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEx )( 
            IResourceManagerFactory2 * This,
            /* [in] */ __RPC__in GUID *pguidRM,
            /* [string][in] */ __RPC__in CHAR *pszRMName,
            /* [in] */ __RPC__in_opt IResourceManagerSink *pIResMgrSink,
            /* [in] */ __RPC__in REFIID riidRequested,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvResMgr);
        
        END_INTERFACE
    } IResourceManagerFactory2Vtbl;

    interface IResourceManagerFactory2
    {
        CONST_VTBL struct IResourceManagerFactory2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceManagerFactory2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResourceManagerFactory2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResourceManagerFactory2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResourceManagerFactory2_Create(This,pguidRM,pszRMName,pIResMgrSink,ppResMgr)	\
    ( (This)->lpVtbl -> Create(This,pguidRM,pszRMName,pIResMgrSink,ppResMgr) ) 


#define IResourceManagerFactory2_CreateEx(This,pguidRM,pszRMName,pIResMgrSink,riidRequested,ppvResMgr)	\
    ( (This)->lpVtbl -> CreateEx(This,pguidRM,pszRMName,pIResMgrSink,riidRequested,ppvResMgr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResourceManagerFactory2_INTERFACE_DEFINED__ */


#ifndef __IPrepareInfo_INTERFACE_DEFINED__
#define __IPrepareInfo_INTERFACE_DEFINED__

/* interface IPrepareInfo */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IPrepareInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80c7bfd0-87ee-11ce-8081-0080c758527e")
    IPrepareInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrepareInfoSize( 
            /* [out] */ ULONG *pcbPrepInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrepareInfo( 
            /* [out] */ byte *pPrepInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrepareInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrepareInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrepareInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrepareInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrepareInfoSize )( 
            IPrepareInfo * This,
            /* [out] */ ULONG *pcbPrepInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrepareInfo )( 
            IPrepareInfo * This,
            /* [out] */ byte *pPrepInfo);
        
        END_INTERFACE
    } IPrepareInfoVtbl;

    interface IPrepareInfo
    {
        CONST_VTBL struct IPrepareInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrepareInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrepareInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrepareInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrepareInfo_GetPrepareInfoSize(This,pcbPrepInfo)	\
    ( (This)->lpVtbl -> GetPrepareInfoSize(This,pcbPrepInfo) ) 

#define IPrepareInfo_GetPrepareInfo(This,pPrepInfo)	\
    ( (This)->lpVtbl -> GetPrepareInfo(This,pPrepInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrepareInfo_INTERFACE_DEFINED__ */


#ifndef __IPrepareInfo2_INTERFACE_DEFINED__
#define __IPrepareInfo2_INTERFACE_DEFINED__

/* interface IPrepareInfo2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPrepareInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5FAB2547-9779-11d1-B886-00C04FB9618A")
    IPrepareInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrepareInfoSize( 
            /* [out] */ __RPC__out ULONG *pcbPrepInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrepareInfo( 
            /* [in] */ ULONG cbPrepareInfo,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPrepareInfo) byte *pPrepInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrepareInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrepareInfo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrepareInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrepareInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrepareInfoSize )( 
            IPrepareInfo2 * This,
            /* [out] */ __RPC__out ULONG *pcbPrepInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrepareInfo )( 
            IPrepareInfo2 * This,
            /* [in] */ ULONG cbPrepareInfo,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPrepareInfo) byte *pPrepInfo);
        
        END_INTERFACE
    } IPrepareInfo2Vtbl;

    interface IPrepareInfo2
    {
        CONST_VTBL struct IPrepareInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrepareInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrepareInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrepareInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrepareInfo2_GetPrepareInfoSize(This,pcbPrepInfo)	\
    ( (This)->lpVtbl -> GetPrepareInfoSize(This,pcbPrepInfo) ) 

#define IPrepareInfo2_GetPrepareInfo(This,cbPrepareInfo,pPrepInfo)	\
    ( (This)->lpVtbl -> GetPrepareInfo(This,cbPrepareInfo,pPrepInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrepareInfo2_INTERFACE_DEFINED__ */


#ifndef __IGetDispenser_INTERFACE_DEFINED__
#define __IGetDispenser_INTERFACE_DEFINED__

/* interface IGetDispenser */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IGetDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c23cc370-87ef-11ce-8081-0080c758527e")
    IGetDispenser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDispenser( 
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetDispenserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetDispenser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetDispenser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetDispenser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDispenser )( 
            IGetDispenser * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        END_INTERFACE
    } IGetDispenserVtbl;

    interface IGetDispenser
    {
        CONST_VTBL struct IGetDispenserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetDispenser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetDispenser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetDispenser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetDispenser_GetDispenser(This,iid,ppvObject)	\
    ( (This)->lpVtbl -> GetDispenser(This,iid,ppvObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetDispenser_INTERFACE_DEFINED__ */


#ifndef __ITransactionVoterBallotAsync2_INTERFACE_DEFINED__
#define __ITransactionVoterBallotAsync2_INTERFACE_DEFINED__

/* interface ITransactionVoterBallotAsync2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionVoterBallotAsync2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5433376C-414D-11d3-B206-00C04FC2F3EF")
    ITransactionVoterBallotAsync2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE VoteRequestDone( 
            /* [in] */ HRESULT hr,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVoterBallotAsync2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionVoterBallotAsync2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionVoterBallotAsync2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionVoterBallotAsync2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *VoteRequestDone )( 
            ITransactionVoterBallotAsync2 * This,
            /* [in] */ HRESULT hr,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason);
        
        END_INTERFACE
    } ITransactionVoterBallotAsync2Vtbl;

    interface ITransactionVoterBallotAsync2
    {
        CONST_VTBL struct ITransactionVoterBallotAsync2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionVoterBallotAsync2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionVoterBallotAsync2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionVoterBallotAsync2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionVoterBallotAsync2_VoteRequestDone(This,hr,pboidReason)	\
    ( (This)->lpVtbl -> VoteRequestDone(This,hr,pboidReason) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionVoterBallotAsync2_INTERFACE_DEFINED__ */


#ifndef __ITransactionVoterNotifyAsync2_INTERFACE_DEFINED__
#define __ITransactionVoterNotifyAsync2_INTERFACE_DEFINED__

/* interface ITransactionVoterNotifyAsync2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionVoterNotifyAsync2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5433376B-414D-11d3-B206-00C04FC2F3EF")
    ITransactionVoterNotifyAsync2 : public ITransactionOutcomeEvents
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE VoteRequest( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVoterNotifyAsync2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionVoterNotifyAsync2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionVoterNotifyAsync2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionVoterNotifyAsync2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            ITransactionVoterNotifyAsync2 * This,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *Aborted )( 
            ITransactionVoterNotifyAsync2 * This,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ __RPC__in_opt XACTUOW *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *HeuristicDecision )( 
            ITransactionVoterNotifyAsync2 * This,
            /* [in] */ DWORD dwDecision,
            /* [unique][in] */ __RPC__in_opt BOID *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *Indoubt )( 
            ITransactionVoterNotifyAsync2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *VoteRequest )( 
            ITransactionVoterNotifyAsync2 * This);
        
        END_INTERFACE
    } ITransactionVoterNotifyAsync2Vtbl;

    interface ITransactionVoterNotifyAsync2
    {
        CONST_VTBL struct ITransactionVoterNotifyAsync2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionVoterNotifyAsync2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionVoterNotifyAsync2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionVoterNotifyAsync2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionVoterNotifyAsync2_Committed(This,fRetaining,pNewUOW,hr)	\
    ( (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr) ) 

#define ITransactionVoterNotifyAsync2_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    ( (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr) ) 

#define ITransactionVoterNotifyAsync2_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    ( (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr) ) 

#define ITransactionVoterNotifyAsync2_Indoubt(This)	\
    ( (This)->lpVtbl -> Indoubt(This) ) 


#define ITransactionVoterNotifyAsync2_VoteRequest(This)	\
    ( (This)->lpVtbl -> VoteRequest(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionVoterNotifyAsync2_INTERFACE_DEFINED__ */


#ifndef __ITransactionVoterFactory2_INTERFACE_DEFINED__
#define __ITransactionVoterFactory2_INTERFACE_DEFINED__

/* interface ITransactionVoterFactory2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionVoterFactory2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5433376A-414D-11d3-B206-00C04FC2F3EF")
    ITransactionVoterFactory2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionVoterNotifyAsync2 *pVoterNotify,
            /* [out] */ __RPC__deref_out_opt ITransactionVoterBallotAsync2 **ppVoterBallot) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVoterFactory2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionVoterFactory2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionVoterFactory2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionVoterFactory2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ITransactionVoterFactory2 * This,
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionVoterNotifyAsync2 *pVoterNotify,
            /* [out] */ __RPC__deref_out_opt ITransactionVoterBallotAsync2 **ppVoterBallot);
        
        END_INTERFACE
    } ITransactionVoterFactory2Vtbl;

    interface ITransactionVoterFactory2
    {
        CONST_VTBL struct ITransactionVoterFactory2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionVoterFactory2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionVoterFactory2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionVoterFactory2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionVoterFactory2_Create(This,pTransaction,pVoterNotify,ppVoterBallot)	\
    ( (This)->lpVtbl -> Create(This,pTransaction,pVoterNotify,ppVoterBallot) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionVoterFactory2_INTERFACE_DEFINED__ */


#ifndef __ITransactionPhase0EnlistmentAsync_INTERFACE_DEFINED__
#define __ITransactionPhase0EnlistmentAsync_INTERFACE_DEFINED__

/* interface ITransactionPhase0EnlistmentAsync */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionPhase0EnlistmentAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82DC88E1-A954-11d1-8F88-00600895E7D5")
    ITransactionPhase0EnlistmentAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Enable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForEnlistment( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Phase0Done( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unenlist( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransaction( 
            /* [out] */ __RPC__deref_out_opt ITransaction **ppITransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionPhase0EnlistmentAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionPhase0EnlistmentAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionPhase0EnlistmentAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForEnlistment )( 
            ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *Phase0Done )( 
            ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unenlist )( 
            ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransaction )( 
            ITransactionPhase0EnlistmentAsync * This,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppITransaction);
        
        END_INTERFACE
    } ITransactionPhase0EnlistmentAsyncVtbl;

    interface ITransactionPhase0EnlistmentAsync
    {
        CONST_VTBL struct ITransactionPhase0EnlistmentAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionPhase0EnlistmentAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionPhase0EnlistmentAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionPhase0EnlistmentAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionPhase0EnlistmentAsync_Enable(This)	\
    ( (This)->lpVtbl -> Enable(This) ) 

#define ITransactionPhase0EnlistmentAsync_WaitForEnlistment(This)	\
    ( (This)->lpVtbl -> WaitForEnlistment(This) ) 

#define ITransactionPhase0EnlistmentAsync_Phase0Done(This)	\
    ( (This)->lpVtbl -> Phase0Done(This) ) 

#define ITransactionPhase0EnlistmentAsync_Unenlist(This)	\
    ( (This)->lpVtbl -> Unenlist(This) ) 

#define ITransactionPhase0EnlistmentAsync_GetTransaction(This,ppITransaction)	\
    ( (This)->lpVtbl -> GetTransaction(This,ppITransaction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionPhase0EnlistmentAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionPhase0NotifyAsync_INTERFACE_DEFINED__
#define __ITransactionPhase0NotifyAsync_INTERFACE_DEFINED__

/* interface ITransactionPhase0NotifyAsync */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionPhase0NotifyAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF081809-0C76-11d2-87A6-00C04F990F34")
    ITransactionPhase0NotifyAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Phase0Request( 
            BOOL fAbortingHint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnlistCompleted( 
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionPhase0NotifyAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionPhase0NotifyAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionPhase0NotifyAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionPhase0NotifyAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *Phase0Request )( 
            ITransactionPhase0NotifyAsync * This,
            BOOL fAbortingHint);
        
        HRESULT ( STDMETHODCALLTYPE *EnlistCompleted )( 
            ITransactionPhase0NotifyAsync * This,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } ITransactionPhase0NotifyAsyncVtbl;

    interface ITransactionPhase0NotifyAsync
    {
        CONST_VTBL struct ITransactionPhase0NotifyAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionPhase0NotifyAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionPhase0NotifyAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionPhase0NotifyAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionPhase0NotifyAsync_Phase0Request(This,fAbortingHint)	\
    ( (This)->lpVtbl -> Phase0Request(This,fAbortingHint) ) 

#define ITransactionPhase0NotifyAsync_EnlistCompleted(This,status)	\
    ( (This)->lpVtbl -> EnlistCompleted(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionPhase0NotifyAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionPhase0Factory_INTERFACE_DEFINED__
#define __ITransactionPhase0Factory_INTERFACE_DEFINED__

/* interface ITransactionPhase0Factory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionPhase0Factory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82DC88E0-A954-11d1-8F88-00600895E7D5")
    ITransactionPhase0Factory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in_opt ITransactionPhase0NotifyAsync *pPhase0Notify,
            /* [out] */ __RPC__deref_out_opt ITransactionPhase0EnlistmentAsync **ppPhase0Enlistment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionPhase0FactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionPhase0Factory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionPhase0Factory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionPhase0Factory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ITransactionPhase0Factory * This,
            /* [in] */ __RPC__in_opt ITransactionPhase0NotifyAsync *pPhase0Notify,
            /* [out] */ __RPC__deref_out_opt ITransactionPhase0EnlistmentAsync **ppPhase0Enlistment);
        
        END_INTERFACE
    } ITransactionPhase0FactoryVtbl;

    interface ITransactionPhase0Factory
    {
        CONST_VTBL struct ITransactionPhase0FactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionPhase0Factory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionPhase0Factory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionPhase0Factory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionPhase0Factory_Create(This,pPhase0Notify,ppPhase0Enlistment)	\
    ( (This)->lpVtbl -> Create(This,pPhase0Notify,ppPhase0Enlistment) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionPhase0Factory_INTERFACE_DEFINED__ */


#ifndef __ITransactionTransmitter_INTERFACE_DEFINED__
#define __ITransactionTransmitter_INTERFACE_DEFINED__

/* interface ITransactionTransmitter */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionTransmitter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59313E01-B36C-11cf-A539-00AA006887C3")
    ITransactionTransmitter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ __RPC__in_opt ITransaction *pTransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropagationTokenSize( 
            /* [out] */ __RPC__out ULONG *pcbToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalPropagationToken( 
            /* [in] */ ULONG cbToken,
            /* [size_is][out] */ __RPC__out_ecount_full(cbToken) byte *rgbToken,
            /* [out] */ __RPC__out ULONG *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmarshalReturnToken( 
            /* [in] */ ULONG cbReturnToken,
            /* [size_is][in] */ __RPC__in_ecount_full(cbReturnToken) byte *rgbReturnToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionTransmitterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionTransmitter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionTransmitter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionTransmitter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            ITransactionTransmitter * This,
            /* [in] */ __RPC__in_opt ITransaction *pTransaction);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropagationTokenSize )( 
            ITransactionTransmitter * This,
            /* [out] */ __RPC__out ULONG *pcbToken);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalPropagationToken )( 
            ITransactionTransmitter * This,
            /* [in] */ ULONG cbToken,
            /* [size_is][out] */ __RPC__out_ecount_full(cbToken) byte *rgbToken,
            /* [out] */ __RPC__out ULONG *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *UnmarshalReturnToken )( 
            ITransactionTransmitter * This,
            /* [in] */ ULONG cbReturnToken,
            /* [size_is][in] */ __RPC__in_ecount_full(cbReturnToken) byte *rgbReturnToken);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ITransactionTransmitter * This);
        
        END_INTERFACE
    } ITransactionTransmitterVtbl;

    interface ITransactionTransmitter
    {
        CONST_VTBL struct ITransactionTransmitterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionTransmitter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionTransmitter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionTransmitter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionTransmitter_Set(This,pTransaction)	\
    ( (This)->lpVtbl -> Set(This,pTransaction) ) 

#define ITransactionTransmitter_GetPropagationTokenSize(This,pcbToken)	\
    ( (This)->lpVtbl -> GetPropagationTokenSize(This,pcbToken) ) 

#define ITransactionTransmitter_MarshalPropagationToken(This,cbToken,rgbToken,pcbUsed)	\
    ( (This)->lpVtbl -> MarshalPropagationToken(This,cbToken,rgbToken,pcbUsed) ) 

#define ITransactionTransmitter_UnmarshalReturnToken(This,cbReturnToken,rgbReturnToken)	\
    ( (This)->lpVtbl -> UnmarshalReturnToken(This,cbReturnToken,rgbReturnToken) ) 

#define ITransactionTransmitter_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionTransmitter_INTERFACE_DEFINED__ */


#ifndef __ITransactionTransmitterFactory_INTERFACE_DEFINED__
#define __ITransactionTransmitterFactory_INTERFACE_DEFINED__

/* interface ITransactionTransmitterFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionTransmitterFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59313E00-B36C-11cf-A539-00AA006887C3")
    ITransactionTransmitterFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [out] */ __RPC__deref_out_opt ITransactionTransmitter **ppTransmitter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionTransmitterFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionTransmitterFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionTransmitterFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionTransmitterFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ITransactionTransmitterFactory * This,
            /* [out] */ __RPC__deref_out_opt ITransactionTransmitter **ppTransmitter);
        
        END_INTERFACE
    } ITransactionTransmitterFactoryVtbl;

    interface ITransactionTransmitterFactory
    {
        CONST_VTBL struct ITransactionTransmitterFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionTransmitterFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionTransmitterFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionTransmitterFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionTransmitterFactory_Create(This,ppTransmitter)	\
    ( (This)->lpVtbl -> Create(This,ppTransmitter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionTransmitterFactory_INTERFACE_DEFINED__ */


#ifndef __ITransactionReceiver_INTERFACE_DEFINED__
#define __ITransactionReceiver_INTERFACE_DEFINED__

/* interface ITransactionReceiver */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionReceiver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59313E03-B36C-11cf-A539-00AA006887C3")
    ITransactionReceiver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UnmarshalPropagationToken( 
            /* [in] */ ULONG cbToken,
            /* [size_is][in] */ __RPC__in_ecount_full(cbToken) byte *rgbToken,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppTransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReturnTokenSize( 
            /* [out] */ __RPC__out ULONG *pcbReturnToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalReturnToken( 
            /* [in] */ ULONG cbReturnToken,
            /* [size_is][out] */ __RPC__out_ecount_full(cbReturnToken) byte *rgbReturnToken,
            /* [out] */ __RPC__out ULONG *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionReceiverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionReceiver * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionReceiver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionReceiver * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnmarshalPropagationToken )( 
            ITransactionReceiver * This,
            /* [in] */ ULONG cbToken,
            /* [size_is][in] */ __RPC__in_ecount_full(cbToken) byte *rgbToken,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppTransaction);
        
        HRESULT ( STDMETHODCALLTYPE *GetReturnTokenSize )( 
            ITransactionReceiver * This,
            /* [out] */ __RPC__out ULONG *pcbReturnToken);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalReturnToken )( 
            ITransactionReceiver * This,
            /* [in] */ ULONG cbReturnToken,
            /* [size_is][out] */ __RPC__out_ecount_full(cbReturnToken) byte *rgbReturnToken,
            /* [out] */ __RPC__out ULONG *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ITransactionReceiver * This);
        
        END_INTERFACE
    } ITransactionReceiverVtbl;

    interface ITransactionReceiver
    {
        CONST_VTBL struct ITransactionReceiverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionReceiver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionReceiver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionReceiver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionReceiver_UnmarshalPropagationToken(This,cbToken,rgbToken,ppTransaction)	\
    ( (This)->lpVtbl -> UnmarshalPropagationToken(This,cbToken,rgbToken,ppTransaction) ) 

#define ITransactionReceiver_GetReturnTokenSize(This,pcbReturnToken)	\
    ( (This)->lpVtbl -> GetReturnTokenSize(This,pcbReturnToken) ) 

#define ITransactionReceiver_MarshalReturnToken(This,cbReturnToken,rgbReturnToken,pcbUsed)	\
    ( (This)->lpVtbl -> MarshalReturnToken(This,cbReturnToken,rgbReturnToken,pcbUsed) ) 

#define ITransactionReceiver_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionReceiver_INTERFACE_DEFINED__ */


#ifndef __ITransactionReceiverFactory_INTERFACE_DEFINED__
#define __ITransactionReceiverFactory_INTERFACE_DEFINED__

/* interface ITransactionReceiverFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionReceiverFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59313E02-B36C-11cf-A539-00AA006887C3")
    ITransactionReceiverFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [out] */ __RPC__deref_out_opt ITransactionReceiver **ppReceiver) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionReceiverFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionReceiverFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionReceiverFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionReceiverFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ITransactionReceiverFactory * This,
            /* [out] */ __RPC__deref_out_opt ITransactionReceiver **ppReceiver);
        
        END_INTERFACE
    } ITransactionReceiverFactoryVtbl;

    interface ITransactionReceiverFactory
    {
        CONST_VTBL struct ITransactionReceiverFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionReceiverFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionReceiverFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionReceiverFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionReceiverFactory_Create(This,ppReceiver)	\
    ( (This)->lpVtbl -> Create(This,ppReceiver) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionReceiverFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txdtc_0000_0024 */
/* [local] */ 

typedef struct _ProxyConfigParams
    {
    WORD wcThreadsMax;
    } 	PROXY_CONFIG_PARAMS;



extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0024_v0_0_s_ifspec;

#ifndef __IDtcLuConfigure_INTERFACE_DEFINED__
#define __IDtcLuConfigure_INTERFACE_DEFINED__

/* interface IDtcLuConfigure */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuConfigure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E760-1AEA-11d0-944B-00A0C905416E")
    IDtcLuConfigure : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuConfigureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuConfigure * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuConfigure * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuConfigure * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IDtcLuConfigure * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IDtcLuConfigure * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair);
        
        END_INTERFACE
    } IDtcLuConfigureVtbl;

    interface IDtcLuConfigure
    {
        CONST_VTBL struct IDtcLuConfigureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuConfigure_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuConfigure_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuConfigure_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuConfigure_Add(This,pucLuPair,cbLuPair)	\
    ( (This)->lpVtbl -> Add(This,pucLuPair,cbLuPair) ) 

#define IDtcLuConfigure_Delete(This,pucLuPair,cbLuPair)	\
    ( (This)->lpVtbl -> Delete(This,pucLuPair,cbLuPair) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuConfigure_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecovery_INTERFACE_DEFINED__
#define __IDtcLuRecovery_INTERFACE_DEFINED__

/* interface IDtcLuRecovery */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecovery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC2B8AD2-D6F0-11d0-B386-00A0C9083365")
    IDtcLuRecovery : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecovery * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecovery * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecovery * This);
        
        END_INTERFACE
    } IDtcLuRecoveryVtbl;

    interface IDtcLuRecovery
    {
        CONST_VTBL struct IDtcLuRecoveryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecovery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecovery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecovery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecovery_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryFactory_INTERFACE_DEFINED__
#define __IDtcLuRecoveryFactory_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryFactory */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E762-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [out] */ __RPC__deref_out_opt IDtcLuRecovery **ppRecovery) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IDtcLuRecoveryFactory * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [out] */ __RPC__deref_out_opt IDtcLuRecovery **ppRecovery);
        
        END_INTERFACE
    } IDtcLuRecoveryFactoryVtbl;

    interface IDtcLuRecoveryFactory
    {
        CONST_VTBL struct IDtcLuRecoveryFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryFactory_Create(This,pucLuPair,cbLuPair,ppRecovery)	\
    ( (This)->lpVtbl -> Create(This,pucLuPair,cbLuPair,ppRecovery) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txdtc_0000_0027 */
/* [local] */ 

typedef 
enum _DtcLu_LocalRecovery_Work
    {	DTCINITIATEDRECOVERYWORK_CHECKLUSTATUS	= 1,
	DTCINITIATEDRECOVERYWORK_TRANS	= ( DTCINITIATEDRECOVERYWORK_CHECKLUSTATUS + 1 ) ,
	DTCINITIATEDRECOVERYWORK_TMDOWN	= ( DTCINITIATEDRECOVERYWORK_TRANS + 1 ) 
    } 	DTCINITIATEDRECOVERYWORK;

typedef 
enum _DtcLu_Xln
    {	DTCLUXLN_COLD	= 1,
	DTCLUXLN_WARM	= ( DTCLUXLN_COLD + 1 ) 
    } 	DTCLUXLN;

typedef 
enum _DtcLu_Xln_Confirmation
    {	DTCLUXLNCONFIRMATION_CONFIRM	= 1,
	DTCLUXLNCONFIRMATION_LOGNAMEMISMATCH	= ( DTCLUXLNCONFIRMATION_CONFIRM + 1 ) ,
	DTCLUXLNCONFIRMATION_COLDWARMMISMATCH	= ( DTCLUXLNCONFIRMATION_LOGNAMEMISMATCH + 1 ) ,
	DTCLUXLNCONFIRMATION_OBSOLETE	= ( DTCLUXLNCONFIRMATION_COLDWARMMISMATCH + 1 ) 
    } 	DTCLUXLNCONFIRMATION;

typedef 
enum _DtcLu_Xln_Response
    {	DTCLUXLNRESPONSE_OK_SENDOURXLNBACK	= 1,
	DTCLUXLNRESPONSE_OK_SENDCONFIRMATION	= ( DTCLUXLNRESPONSE_OK_SENDOURXLNBACK + 1 ) ,
	DTCLUXLNRESPONSE_LOGNAMEMISMATCH	= ( DTCLUXLNRESPONSE_OK_SENDCONFIRMATION + 1 ) ,
	DTCLUXLNRESPONSE_COLDWARMMISMATCH	= ( DTCLUXLNRESPONSE_LOGNAMEMISMATCH + 1 ) 
    } 	DTCLUXLNRESPONSE;

typedef 
enum _DtcLu_Xln_Error
    {	DTCLUXLNERROR_PROTOCOL	= 1,
	DTCLUXLNERROR_LOGNAMEMISMATCH	= ( DTCLUXLNERROR_PROTOCOL + 1 ) ,
	DTCLUXLNERROR_COLDWARMMISMATCH	= ( DTCLUXLNERROR_LOGNAMEMISMATCH + 1 ) 
    } 	DTCLUXLNERROR;

typedef 
enum _DtcLu_CompareState
    {	DTCLUCOMPARESTATE_COMMITTED	= 1,
	DTCLUCOMPARESTATE_HEURISTICCOMMITTED	= ( DTCLUCOMPARESTATE_COMMITTED + 1 ) ,
	DTCLUCOMPARESTATE_HEURISTICMIXED	= ( DTCLUCOMPARESTATE_HEURISTICCOMMITTED + 1 ) ,
	DTCLUCOMPARESTATE_HEURISTICRESET	= ( DTCLUCOMPARESTATE_HEURISTICMIXED + 1 ) ,
	DTCLUCOMPARESTATE_INDOUBT	= ( DTCLUCOMPARESTATE_HEURISTICRESET + 1 ) ,
	DTCLUCOMPARESTATE_RESET	= ( DTCLUCOMPARESTATE_INDOUBT + 1 ) 
    } 	DTCLUCOMPARESTATE;

typedef 
enum _DtcLu_CompareStates_Confirmation
    {	DTCLUCOMPARESTATESCONFIRMATION_CONFIRM	= 1,
	DTCLUCOMPARESTATESCONFIRMATION_PROTOCOL	= ( DTCLUCOMPARESTATESCONFIRMATION_CONFIRM + 1 ) 
    } 	DTCLUCOMPARESTATESCONFIRMATION;

typedef 
enum _DtcLu_CompareStates_Error
    {	DTCLUCOMPARESTATESERROR_PROTOCOL	= 1
    } 	DTCLUCOMPARESTATESERROR;

typedef 
enum _DtcLu_CompareStates_Response
    {	DTCLUCOMPARESTATESRESPONSE_OK	= 1,
	DTCLUCOMPARESTATESRESPONSE_PROTOCOL	= ( DTCLUCOMPARESTATESRESPONSE_OK + 1 ) 
    } 	DTCLUCOMPARESTATESRESPONSE;



extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0027_v0_0_s_ifspec;

#ifndef __IDtcLuRecoveryInitiatedByDtcTransWork_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtcTransWork_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByDtcTransWork */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByDtcTransWork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E765-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryInitiatedByDtcTransWork : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLogNameSizes( 
            /* [out] */ DWORD *pcbOurLogName,
            /* [out] */ DWORD *pcbRemoteLogName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurXln( 
            /* [out] */ DTCLUXLN *pXln,
            /* [out][in] */ unsigned char *pOurLogName,
            /* [out][in] */ unsigned char *pRemoteLogName,
            /* [out] */ DWORD *pdwProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleConfirmationFromOurXln( 
            /* [in] */ DTCLUXLNCONFIRMATION Confirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleTheirXlnResponse( 
            /* [in] */ DTCLUXLN Xln,
            /* [in] */ unsigned char *pRemoteLogName,
            /* [in] */ DWORD cbRemoteLogName,
            /* [in] */ DWORD dwProtocol,
            /* [out] */ DTCLUXLNCONFIRMATION *pConfirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleErrorFromOurXln( 
            /* [in] */ DTCLUXLNERROR Error) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckForCompareStates( 
            /* [out] */ BOOL *fCompareStates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurTransIdSize( 
            /* [out][in] */ DWORD *pcbOurTransId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurCompareStates( 
            /* [out][in] */ unsigned char *pOurTransId,
            /* [out] */ DTCLUCOMPARESTATE *pCompareState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleTheirCompareStatesResponse( 
            /* [in] */ DTCLUCOMPARESTATE CompareState,
            /* [out] */ DTCLUCOMPARESTATESCONFIRMATION *pConfirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleErrorFromOurCompareStates( 
            /* [in] */ DTCLUCOMPARESTATESERROR Error) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversationLost( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecoverySeqNum( 
            /* [out] */ LONG *plRecoverySeqNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObsoleteRecoverySeqNum( 
            /* [in] */ LONG lNewRecoverySeqNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByDtcTransWorkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogNameSizes )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out] */ DWORD *pcbOurLogName,
            /* [out] */ DWORD *pcbRemoteLogName);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurXln )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out] */ DTCLUXLN *pXln,
            /* [out][in] */ unsigned char *pOurLogName,
            /* [out][in] */ unsigned char *pRemoteLogName,
            /* [out] */ DWORD *pdwProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *HandleConfirmationFromOurXln )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUXLNCONFIRMATION Confirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleTheirXlnResponse )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUXLN Xln,
            /* [in] */ unsigned char *pRemoteLogName,
            /* [in] */ DWORD cbRemoteLogName,
            /* [in] */ DWORD dwProtocol,
            /* [out] */ DTCLUXLNCONFIRMATION *pConfirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleErrorFromOurXln )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUXLNERROR Error);
        
        HRESULT ( STDMETHODCALLTYPE *CheckForCompareStates )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out] */ BOOL *fCompareStates);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurTransIdSize )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out][in] */ DWORD *pcbOurTransId);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurCompareStates )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out][in] */ unsigned char *pOurTransId,
            /* [out] */ DTCLUCOMPARESTATE *pCompareState);
        
        HRESULT ( STDMETHODCALLTYPE *HandleTheirCompareStatesResponse )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUCOMPARESTATE CompareState,
            /* [out] */ DTCLUCOMPARESTATESCONFIRMATION *pConfirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleErrorFromOurCompareStates )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUCOMPARESTATESERROR Error);
        
        HRESULT ( STDMETHODCALLTYPE *ConversationLost )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecoverySeqNum )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out] */ LONG *plRecoverySeqNum);
        
        HRESULT ( STDMETHODCALLTYPE *ObsoleteRecoverySeqNum )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ LONG lNewRecoverySeqNum);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByDtcTransWorkVtbl;

    interface IDtcLuRecoveryInitiatedByDtcTransWork
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByDtcTransWorkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByDtcTransWork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByDtcTransWork_GetLogNameSizes(This,pcbOurLogName,pcbRemoteLogName)	\
    ( (This)->lpVtbl -> GetLogNameSizes(This,pcbOurLogName,pcbRemoteLogName) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_GetOurXln(This,pXln,pOurLogName,pRemoteLogName,pdwProtocol)	\
    ( (This)->lpVtbl -> GetOurXln(This,pXln,pOurLogName,pRemoteLogName,pdwProtocol) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleConfirmationFromOurXln(This,Confirmation)	\
    ( (This)->lpVtbl -> HandleConfirmationFromOurXln(This,Confirmation) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleTheirXlnResponse(This,Xln,pRemoteLogName,cbRemoteLogName,dwProtocol,pConfirmation)	\
    ( (This)->lpVtbl -> HandleTheirXlnResponse(This,Xln,pRemoteLogName,cbRemoteLogName,dwProtocol,pConfirmation) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleErrorFromOurXln(This,Error)	\
    ( (This)->lpVtbl -> HandleErrorFromOurXln(This,Error) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_CheckForCompareStates(This,fCompareStates)	\
    ( (This)->lpVtbl -> CheckForCompareStates(This,fCompareStates) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_GetOurTransIdSize(This,pcbOurTransId)	\
    ( (This)->lpVtbl -> GetOurTransIdSize(This,pcbOurTransId) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_GetOurCompareStates(This,pOurTransId,pCompareState)	\
    ( (This)->lpVtbl -> GetOurCompareStates(This,pOurTransId,pCompareState) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleTheirCompareStatesResponse(This,CompareState,pConfirmation)	\
    ( (This)->lpVtbl -> HandleTheirCompareStatesResponse(This,CompareState,pConfirmation) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleErrorFromOurCompareStates(This,Error)	\
    ( (This)->lpVtbl -> HandleErrorFromOurCompareStates(This,Error) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_ConversationLost(This)	\
    ( (This)->lpVtbl -> ConversationLost(This) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_GetRecoverySeqNum(This,plRecoverySeqNum)	\
    ( (This)->lpVtbl -> GetRecoverySeqNum(This,plRecoverySeqNum) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_ObsoleteRecoverySeqNum(This,lNewRecoverySeqNum)	\
    ( (This)->lpVtbl -> ObsoleteRecoverySeqNum(This,lNewRecoverySeqNum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByDtcTransWork_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByDtcStatusWork_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtcStatusWork_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByDtcStatusWork */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByDtcStatusWork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E766-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryInitiatedByDtcStatusWork : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleCheckLuStatus( 
            /* [in] */ LONG lRecoverySeqNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByDtcStatusWorkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryInitiatedByDtcStatusWork * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryInitiatedByDtcStatusWork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryInitiatedByDtcStatusWork * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleCheckLuStatus )( 
            IDtcLuRecoveryInitiatedByDtcStatusWork * This,
            /* [in] */ LONG lRecoverySeqNum);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByDtcStatusWorkVtbl;

    interface IDtcLuRecoveryInitiatedByDtcStatusWork
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByDtcStatusWorkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByDtcStatusWork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByDtcStatusWork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByDtcStatusWork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByDtcStatusWork_HandleCheckLuStatus(This,lRecoverySeqNum)	\
    ( (This)->lpVtbl -> HandleCheckLuStatus(This,lRecoverySeqNum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByDtcStatusWork_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByDtc_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtc_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByDtc */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByDtc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E764-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryInitiatedByDtc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWork( 
            /* [out][in] */ DTCINITIATEDRECOVERYWORK *pWork,
            /* [out][in] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByDtcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryInitiatedByDtc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryInitiatedByDtc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryInitiatedByDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWork )( 
            IDtcLuRecoveryInitiatedByDtc * This,
            /* [out][in] */ DTCINITIATEDRECOVERYWORK *pWork,
            /* [out][in] */ void **ppv);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByDtcVtbl;

    interface IDtcLuRecoveryInitiatedByDtc
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByDtcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByDtc_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByDtc_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByDtc_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByDtc_GetWork(This,pWork,ppv)	\
    ( (This)->lpVtbl -> GetWork(This,pWork,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByDtc_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByLuWork_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByLuWork_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByLuWork */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByLuWork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC2B8AD1-D6F0-11d0-B386-00A0C9083365")
    IDtcLuRecoveryInitiatedByLuWork : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleTheirXln( 
            /* [in] */ LONG lRecoverySeqNum,
            /* [in] */ DTCLUXLN Xln,
            /* [in] */ unsigned char *pRemoteLogName,
            /* [in] */ DWORD cbRemoteLogName,
            /* [in] */ unsigned char *pOurLogName,
            /* [in] */ DWORD cbOurLogName,
            /* [in] */ DWORD dwProtocol,
            /* [out] */ DTCLUXLNRESPONSE *pResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurLogNameSize( 
            /* [out][in] */ DWORD *pcbOurLogName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurXln( 
            /* [out] */ DTCLUXLN *pXln,
            /* [out][in] */ unsigned char *pOurLogName,
            /* [out] */ DWORD *pdwProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleConfirmationOfOurXln( 
            /* [in] */ DTCLUXLNCONFIRMATION Confirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleTheirCompareStates( 
            /* [out][in] */ unsigned char *pRemoteTransId,
            /* [in] */ DWORD cbRemoteTransId,
            /* [in] */ DTCLUCOMPARESTATE CompareState,
            /* [out] */ DTCLUCOMPARESTATESRESPONSE *pResponse,
            /* [out] */ DTCLUCOMPARESTATE *pCompareState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleConfirmationOfOurCompareStates( 
            /* [in] */ DTCLUCOMPARESTATESCONFIRMATION Confirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleErrorFromOurCompareStates( 
            /* [in] */ DTCLUCOMPARESTATESERROR Error) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversationLost( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByLuWorkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryInitiatedByLuWork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryInitiatedByLuWork * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleTheirXln )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ LONG lRecoverySeqNum,
            /* [in] */ DTCLUXLN Xln,
            /* [in] */ unsigned char *pRemoteLogName,
            /* [in] */ DWORD cbRemoteLogName,
            /* [in] */ unsigned char *pOurLogName,
            /* [in] */ DWORD cbOurLogName,
            /* [in] */ DWORD dwProtocol,
            /* [out] */ DTCLUXLNRESPONSE *pResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurLogNameSize )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [out][in] */ DWORD *pcbOurLogName);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurXln )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [out] */ DTCLUXLN *pXln,
            /* [out][in] */ unsigned char *pOurLogName,
            /* [out] */ DWORD *pdwProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *HandleConfirmationOfOurXln )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ DTCLUXLNCONFIRMATION Confirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleTheirCompareStates )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [out][in] */ unsigned char *pRemoteTransId,
            /* [in] */ DWORD cbRemoteTransId,
            /* [in] */ DTCLUCOMPARESTATE CompareState,
            /* [out] */ DTCLUCOMPARESTATESRESPONSE *pResponse,
            /* [out] */ DTCLUCOMPARESTATE *pCompareState);
        
        HRESULT ( STDMETHODCALLTYPE *HandleConfirmationOfOurCompareStates )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ DTCLUCOMPARESTATESCONFIRMATION Confirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleErrorFromOurCompareStates )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ DTCLUCOMPARESTATESERROR Error);
        
        HRESULT ( STDMETHODCALLTYPE *ConversationLost )( 
            IDtcLuRecoveryInitiatedByLuWork * This);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByLuWorkVtbl;

    interface IDtcLuRecoveryInitiatedByLuWork
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByLuWorkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByLuWork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByLuWork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByLuWork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByLuWork_HandleTheirXln(This,lRecoverySeqNum,Xln,pRemoteLogName,cbRemoteLogName,pOurLogName,cbOurLogName,dwProtocol,pResponse)	\
    ( (This)->lpVtbl -> HandleTheirXln(This,lRecoverySeqNum,Xln,pRemoteLogName,cbRemoteLogName,pOurLogName,cbOurLogName,dwProtocol,pResponse) ) 

#define IDtcLuRecoveryInitiatedByLuWork_GetOurLogNameSize(This,pcbOurLogName)	\
    ( (This)->lpVtbl -> GetOurLogNameSize(This,pcbOurLogName) ) 

#define IDtcLuRecoveryInitiatedByLuWork_GetOurXln(This,pXln,pOurLogName,pdwProtocol)	\
    ( (This)->lpVtbl -> GetOurXln(This,pXln,pOurLogName,pdwProtocol) ) 

#define IDtcLuRecoveryInitiatedByLuWork_HandleConfirmationOfOurXln(This,Confirmation)	\
    ( (This)->lpVtbl -> HandleConfirmationOfOurXln(This,Confirmation) ) 

#define IDtcLuRecoveryInitiatedByLuWork_HandleTheirCompareStates(This,pRemoteTransId,cbRemoteTransId,CompareState,pResponse,pCompareState)	\
    ( (This)->lpVtbl -> HandleTheirCompareStates(This,pRemoteTransId,cbRemoteTransId,CompareState,pResponse,pCompareState) ) 

#define IDtcLuRecoveryInitiatedByLuWork_HandleConfirmationOfOurCompareStates(This,Confirmation)	\
    ( (This)->lpVtbl -> HandleConfirmationOfOurCompareStates(This,Confirmation) ) 

#define IDtcLuRecoveryInitiatedByLuWork_HandleErrorFromOurCompareStates(This,Error)	\
    ( (This)->lpVtbl -> HandleErrorFromOurCompareStates(This,Error) ) 

#define IDtcLuRecoveryInitiatedByLuWork_ConversationLost(This)	\
    ( (This)->lpVtbl -> ConversationLost(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByLuWork_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByLu_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByLu_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByLu */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByLu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E768-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryInitiatedByLu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectToHandleWorkFromLu( 
            /* [out] */ __RPC__deref_out_opt IDtcLuRecoveryInitiatedByLuWork **ppWork) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByLuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryInitiatedByLu * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryInitiatedByLu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryInitiatedByLu * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectToHandleWorkFromLu )( 
            IDtcLuRecoveryInitiatedByLu * This,
            /* [out] */ __RPC__deref_out_opt IDtcLuRecoveryInitiatedByLuWork **ppWork);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByLuVtbl;

    interface IDtcLuRecoveryInitiatedByLu
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByLuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByLu_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByLu_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByLu_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByLu_GetObjectToHandleWorkFromLu(This,ppWork)	\
    ( (This)->lpVtbl -> GetObjectToHandleWorkFromLu(This,ppWork) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByLu_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRmEnlistment_INTERFACE_DEFINED__
#define __IDtcLuRmEnlistment_INTERFACE_DEFINED__

/* interface IDtcLuRmEnlistment */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRmEnlistment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E769-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRmEnlistment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unplug( 
            /* [in] */ BOOL fConversationLost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Committed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Forget( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCommit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRmEnlistmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRmEnlistment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRmEnlistment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unplug )( 
            IDtcLuRmEnlistment * This,
            /* [in] */ BOOL fConversationLost);
        
        HRESULT ( STDMETHODCALLTYPE *BackedOut )( 
            IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackOut )( 
            IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Forget )( 
            IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestCommit )( 
            IDtcLuRmEnlistment * This);
        
        END_INTERFACE
    } IDtcLuRmEnlistmentVtbl;

    interface IDtcLuRmEnlistment
    {
        CONST_VTBL struct IDtcLuRmEnlistmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRmEnlistment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRmEnlistment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRmEnlistment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRmEnlistment_Unplug(This,fConversationLost)	\
    ( (This)->lpVtbl -> Unplug(This,fConversationLost) ) 

#define IDtcLuRmEnlistment_BackedOut(This)	\
    ( (This)->lpVtbl -> BackedOut(This) ) 

#define IDtcLuRmEnlistment_BackOut(This)	\
    ( (This)->lpVtbl -> BackOut(This) ) 

#define IDtcLuRmEnlistment_Committed(This)	\
    ( (This)->lpVtbl -> Committed(This) ) 

#define IDtcLuRmEnlistment_Forget(This)	\
    ( (This)->lpVtbl -> Forget(This) ) 

#define IDtcLuRmEnlistment_RequestCommit(This)	\
    ( (This)->lpVtbl -> RequestCommit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRmEnlistment_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRmEnlistmentSink_INTERFACE_DEFINED__
#define __IDtcLuRmEnlistmentSink_INTERFACE_DEFINED__

/* interface IDtcLuRmEnlistmentSink */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRmEnlistmentSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E770-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRmEnlistmentSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AckUnplug( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TmDown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SessionLost( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Committed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Forget( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCommit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRmEnlistmentSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRmEnlistmentSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRmEnlistmentSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *AckUnplug )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *TmDown )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *SessionLost )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackedOut )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackOut )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Forget )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prepare )( 
            IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestCommit )( 
            IDtcLuRmEnlistmentSink * This);
        
        END_INTERFACE
    } IDtcLuRmEnlistmentSinkVtbl;

    interface IDtcLuRmEnlistmentSink
    {
        CONST_VTBL struct IDtcLuRmEnlistmentSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRmEnlistmentSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRmEnlistmentSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRmEnlistmentSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRmEnlistmentSink_AckUnplug(This)	\
    ( (This)->lpVtbl -> AckUnplug(This) ) 

#define IDtcLuRmEnlistmentSink_TmDown(This)	\
    ( (This)->lpVtbl -> TmDown(This) ) 

#define IDtcLuRmEnlistmentSink_SessionLost(This)	\
    ( (This)->lpVtbl -> SessionLost(This) ) 

#define IDtcLuRmEnlistmentSink_BackedOut(This)	\
    ( (This)->lpVtbl -> BackedOut(This) ) 

#define IDtcLuRmEnlistmentSink_BackOut(This)	\
    ( (This)->lpVtbl -> BackOut(This) ) 

#define IDtcLuRmEnlistmentSink_Committed(This)	\
    ( (This)->lpVtbl -> Committed(This) ) 

#define IDtcLuRmEnlistmentSink_Forget(This)	\
    ( (This)->lpVtbl -> Forget(This) ) 

#define IDtcLuRmEnlistmentSink_Prepare(This)	\
    ( (This)->lpVtbl -> Prepare(This) ) 

#define IDtcLuRmEnlistmentSink_RequestCommit(This)	\
    ( (This)->lpVtbl -> RequestCommit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRmEnlistmentSink_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRmEnlistmentFactory_INTERFACE_DEFINED__
#define __IDtcLuRmEnlistmentFactory_INTERFACE_DEFINED__

/* interface IDtcLuRmEnlistmentFactory */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRmEnlistmentFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E771-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRmEnlistmentFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ unsigned char *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [in] */ ITransaction *pITransaction,
            /* [in] */ unsigned char *pTransId,
            /* [in] */ DWORD cbTransId,
            /* [in] */ IDtcLuRmEnlistmentSink *pRmEnlistmentSink,
            /* [out][in] */ IDtcLuRmEnlistment **ppRmEnlistment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRmEnlistmentFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRmEnlistmentFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRmEnlistmentFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRmEnlistmentFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IDtcLuRmEnlistmentFactory * This,
            /* [in] */ unsigned char *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [in] */ ITransaction *pITransaction,
            /* [in] */ unsigned char *pTransId,
            /* [in] */ DWORD cbTransId,
            /* [in] */ IDtcLuRmEnlistmentSink *pRmEnlistmentSink,
            /* [out][in] */ IDtcLuRmEnlistment **ppRmEnlistment);
        
        END_INTERFACE
    } IDtcLuRmEnlistmentFactoryVtbl;

    interface IDtcLuRmEnlistmentFactory
    {
        CONST_VTBL struct IDtcLuRmEnlistmentFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRmEnlistmentFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRmEnlistmentFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRmEnlistmentFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRmEnlistmentFactory_Create(This,pucLuPair,cbLuPair,pITransaction,pTransId,cbTransId,pRmEnlistmentSink,ppRmEnlistment)	\
    ( (This)->lpVtbl -> Create(This,pucLuPair,cbLuPair,pITransaction,pTransId,cbTransId,pRmEnlistmentSink,ppRmEnlistment) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRmEnlistmentFactory_INTERFACE_DEFINED__ */


#ifndef __IDtcLuSubordinateDtc_INTERFACE_DEFINED__
#define __IDtcLuSubordinateDtc_INTERFACE_DEFINED__

/* interface IDtcLuSubordinateDtc */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuSubordinateDtc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E773-1AEA-11d0-944B-00A0C905416E")
    IDtcLuSubordinateDtc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unplug( 
            /* [in] */ BOOL fConversationLost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Committed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Forget( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCommit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuSubordinateDtcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuSubordinateDtc * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuSubordinateDtc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unplug )( 
            IDtcLuSubordinateDtc * This,
            /* [in] */ BOOL fConversationLost);
        
        HRESULT ( STDMETHODCALLTYPE *BackedOut )( 
            IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackOut )( 
            IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Forget )( 
            IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prepare )( 
            IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestCommit )( 
            IDtcLuSubordinateDtc * This);
        
        END_INTERFACE
    } IDtcLuSubordinateDtcVtbl;

    interface IDtcLuSubordinateDtc
    {
        CONST_VTBL struct IDtcLuSubordinateDtcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuSubordinateDtc_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuSubordinateDtc_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuSubordinateDtc_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuSubordinateDtc_Unplug(This,fConversationLost)	\
    ( (This)->lpVtbl -> Unplug(This,fConversationLost) ) 

#define IDtcLuSubordinateDtc_BackedOut(This)	\
    ( (This)->lpVtbl -> BackedOut(This) ) 

#define IDtcLuSubordinateDtc_BackOut(This)	\
    ( (This)->lpVtbl -> BackOut(This) ) 

#define IDtcLuSubordinateDtc_Committed(This)	\
    ( (This)->lpVtbl -> Committed(This) ) 

#define IDtcLuSubordinateDtc_Forget(This)	\
    ( (This)->lpVtbl -> Forget(This) ) 

#define IDtcLuSubordinateDtc_Prepare(This)	\
    ( (This)->lpVtbl -> Prepare(This) ) 

#define IDtcLuSubordinateDtc_RequestCommit(This)	\
    ( (This)->lpVtbl -> RequestCommit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuSubordinateDtc_INTERFACE_DEFINED__ */


#ifndef __IDtcLuSubordinateDtcSink_INTERFACE_DEFINED__
#define __IDtcLuSubordinateDtcSink_INTERFACE_DEFINED__

/* interface IDtcLuSubordinateDtcSink */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuSubordinateDtcSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E774-1AEA-11d0-944B-00A0C905416E")
    IDtcLuSubordinateDtcSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AckUnplug( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TmDown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SessionLost( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Committed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Forget( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCommit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuSubordinateDtcSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuSubordinateDtcSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuSubordinateDtcSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *AckUnplug )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *TmDown )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *SessionLost )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackedOut )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackOut )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Forget )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestCommit )( 
            IDtcLuSubordinateDtcSink * This);
        
        END_INTERFACE
    } IDtcLuSubordinateDtcSinkVtbl;

    interface IDtcLuSubordinateDtcSink
    {
        CONST_VTBL struct IDtcLuSubordinateDtcSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuSubordinateDtcSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuSubordinateDtcSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuSubordinateDtcSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuSubordinateDtcSink_AckUnplug(This)	\
    ( (This)->lpVtbl -> AckUnplug(This) ) 

#define IDtcLuSubordinateDtcSink_TmDown(This)	\
    ( (This)->lpVtbl -> TmDown(This) ) 

#define IDtcLuSubordinateDtcSink_SessionLost(This)	\
    ( (This)->lpVtbl -> SessionLost(This) ) 

#define IDtcLuSubordinateDtcSink_BackedOut(This)	\
    ( (This)->lpVtbl -> BackedOut(This) ) 

#define IDtcLuSubordinateDtcSink_BackOut(This)	\
    ( (This)->lpVtbl -> BackOut(This) ) 

#define IDtcLuSubordinateDtcSink_Committed(This)	\
    ( (This)->lpVtbl -> Committed(This) ) 

#define IDtcLuSubordinateDtcSink_Forget(This)	\
    ( (This)->lpVtbl -> Forget(This) ) 

#define IDtcLuSubordinateDtcSink_RequestCommit(This)	\
    ( (This)->lpVtbl -> RequestCommit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuSubordinateDtcSink_INTERFACE_DEFINED__ */


#ifndef __IDtcLuSubordinateDtcFactory_INTERFACE_DEFINED__
#define __IDtcLuSubordinateDtcFactory_INTERFACE_DEFINED__

/* interface IDtcLuSubordinateDtcFactory */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuSubordinateDtcFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E775-1AEA-11d0-944B-00A0C905416E")
    IDtcLuSubordinateDtcFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ unsigned char *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [in] */ IUnknown *punkTransactionOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions *pOptions,
            /* [out] */ ITransaction **ppTransaction,
            /* [in] */ unsigned char *pTransId,
            /* [in] */ DWORD cbTransId,
            /* [in] */ IDtcLuSubordinateDtcSink *pSubordinateDtcSink,
            /* [out][in] */ IDtcLuSubordinateDtc **ppSubordinateDtc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuSubordinateDtcFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuSubordinateDtcFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuSubordinateDtcFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuSubordinateDtcFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IDtcLuSubordinateDtcFactory * This,
            /* [in] */ unsigned char *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [in] */ IUnknown *punkTransactionOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions *pOptions,
            /* [out] */ ITransaction **ppTransaction,
            /* [in] */ unsigned char *pTransId,
            /* [in] */ DWORD cbTransId,
            /* [in] */ IDtcLuSubordinateDtcSink *pSubordinateDtcSink,
            /* [out][in] */ IDtcLuSubordinateDtc **ppSubordinateDtc);
        
        END_INTERFACE
    } IDtcLuSubordinateDtcFactoryVtbl;

    interface IDtcLuSubordinateDtcFactory
    {
        CONST_VTBL struct IDtcLuSubordinateDtcFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuSubordinateDtcFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuSubordinateDtcFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuSubordinateDtcFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuSubordinateDtcFactory_Create(This,pucLuPair,cbLuPair,punkTransactionOuter,isoLevel,isoFlags,pOptions,ppTransaction,pTransId,cbTransId,pSubordinateDtcSink,ppSubordinateDtc)	\
    ( (This)->lpVtbl -> Create(This,pucLuPair,cbLuPair,punkTransactionOuter,isoLevel,isoFlags,pOptions,ppTransaction,pTransId,cbTransId,pSubordinateDtcSink,ppSubordinateDtc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuSubordinateDtcFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txdtc_0000_0038 */
/* [local] */ 



#if _MSC_VER < 1100 || !defined(__cplusplus)

DEFINE_GUID(IID_IXATransLookup, 0xF3B1F131, 0xEEDA, 0x11ce, 0xAE, 0xD4, 0x00, 0xAA, 0x00, 0x51, 0xE2, 0xC4);
DEFINE_GUID(IID_IXATransLookup2,0xbf193c85, 0xd1a, 0x4290, 0xb8, 0x8f, 0xd2, 0xcb, 0x88, 0x73, 0xd1, 0xe7);
DEFINE_GUID(IID_IResourceManagerSink, 0x0D563181, 0xDEFB, 0x11ce, 0xAE, 0xD1, 0x00, 0xAA, 0x00, 0x51, 0xE2, 0xC4);
DEFINE_GUID(IID_IResourceManager, 0x3741d21, 0x87eb, 0x11ce, 0x80, 0x81, 0x00, 0x80, 0xc7, 0x58, 0x52, 0x7e);
DEFINE_GUID(IID_IResourceManager2, 0xd136c69a, 0xf749, 0x11d1, 0x8f, 0x47, 0x0, 0xc0, 0x4f, 0x8e, 0xe5, 0x7d);
DEFINE_GUID(IID_ILastResourceManager, 0x4d964ad4, 0x5b33, 0x11d3, 0x8a, 0x91, 0x00, 0xc0, 0x4f, 0x79, 0xeb, 0x6d);
DEFINE_GUID(IID_IXAConfig, 0xC8A6E3A1, 0x9A8C, 0x11cf, 0xA3, 0x08, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IRMHelper, 0xE793F6D1, 0xF53D, 0x11cf, 0xA6, 0x0D, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IXAObtainRMInfo, 0xE793F6D2, 0xF53D, 0x11cf, 0xA6, 0x0D, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IXAResourceManager, 0x4131E751, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IXAResourceManagerFactory, 0x4131E750, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IXATransaction, 0x4131E752, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IResourceManagerFactory, 0x13741d20, 0x87eb, 0x11ce, 0x80, 0x81, 0x00, 0x80, 0xc7, 0x58, 0x52, 0x7e);
DEFINE_GUID(IID_IResourceManagerFactory2, 0x6b369c21, 0xfbd2, 0x11d1, 0x8f, 0x47, 0x0, 0xc0, 0x4f, 0x8e, 0xe5, 0x7d);
DEFINE_GUID(IID_IPrepareInfo, 0x80c7bfd0, 0x87ee, 0x11ce, 0x80, 0x81, 0x00, 0x80, 0xc7, 0x58, 0x52, 0x7e);
DEFINE_GUID(IID_IPrepareInfo2, 0x5FAB2547, 0x9779, 0x11d1, 0xB8, 0x86, 0x00, 0xC0, 0x4F, 0xB9, 0x61, 0x8A);
DEFINE_GUID(IID_IGetDispenser, 0xc23cc370, 0x87ef, 0x11ce, 0x80, 0x81, 0x00, 0x80, 0xc7, 0x58, 0x52, 0x7e);
DEFINE_GUID(IID_ITransactionVoterNotifyAsync2, 0x5433376b, 0x414d, 0x11d3, 0xb2, 0x6, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITransactionVoterBallotAsync2, 0x5433376c, 0x414d, 0x11d3, 0xb2, 0x6, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITransactionVoterFactory2, 0x5433376a, 0x414d, 0x11d3, 0xb2, 0x6, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITransactionPhase0EnlistmentAsync, 0x82DC88E1, 0xA954, 0x11d1, 0x8F, 0x88, 0x00, 0x60, 0x08, 0x95, 0xE7, 0xD5);
DEFINE_GUID(IID_ITransactionPhase0NotifyAsync, 0xEF081809, 0x0C76, 0x11d2, 0x87, 0xA6, 0x00, 0xC0, 0x4F, 0x99, 0x0F, 0x34);
DEFINE_GUID(IID_ITransactionPhase0Factory, 0x82DC88E0, 0xA954, 0x11d1, 0x8F, 0x88, 0x00, 0x60, 0x08, 0x95, 0xE7, 0xD5);
DEFINE_GUID(IID_ITransactionTransmitter, 0x59313E01, 0xB36C, 0x11cf, 0xA5, 0x39, 0x00, 0xAA, 0x00, 0x68, 0x87, 0xC3);
DEFINE_GUID(IID_ITransactionTransmitterFactory, 0x59313E00, 0xB36C, 0x11cf, 0xA5, 0x39, 0x00, 0xAA, 0x00, 0x68, 0x87, 0xC3);
DEFINE_GUID(IID_ITransactionReceiver, 0x59313E03, 0xB36C, 0x11cf, 0xA5, 0x39, 0x00, 0xAA, 0x00, 0x68, 0x87, 0xC3);
DEFINE_GUID(IID_ITransactionReceiverFactory, 0x59313E02, 0xB36C, 0x11cf, 0xA5, 0x39, 0x00, 0xAA, 0x00, 0x68, 0x87, 0xC3);

DEFINE_GUID(IID_IDtcLuConfigure, 0x4131E760, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecovery, 0xac2b8ad2, 0xd6f0, 0x11d0, 0xb3, 0x86, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0x65);
DEFINE_GUID(IID_IDtcLuRecoveryFactory, 0x4131E762, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByDtcTransWork, 0x4131E765, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByDtcStatusWork, 0x4131E766, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByDtc, 0x4131E764, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByLuWork, 0xac2b8ad1, 0xd6f0, 0x11d0, 0xb3, 0x86, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0x65);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByLu, 0x4131E768, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRmEnlistment, 0x4131E769, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRmEnlistmentSink, 0x4131E770, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRmEnlistmentFactory, 0x4131E771, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuSubordinateDtc, 0x4131E773, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuSubordinateDtcSink, 0x4131E774, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuSubordinateDtcFactory, 0x4131E775, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);

#else

#define  IID_IXATransLookup                          __uuidof(IXATransLookup)
#define  IID_IXATransLookup2                         __uuidof(IXATransLookup2)
#define  IID_IResourceManagerSink                    __uuidof(IResourceManagerSink)
#define  IID_IResourceManager                        __uuidof(IResourceManager)
#define  IID_IResourceManager2                       __uuidof(IResourceManager2)
#define  IID_ILastResourceManager                    __uuidof(ILastResourceManager)
#define  IID_IXAConfig                               __uuidof(IXAConfig)
#define  IID_IRMHelper                               __uuidof(IRMHelper)
#define  IID_IXAObtainRMInfo                         __uuidof(IXAObtainRMInfo)
#define  IID_IXAResourceManager                      __uuidof(IXAResourceManager)
#define  IID_IXAResourceManagerFactory               __uuidof(IXAResourceManagerFactory)
#define  IID_IXATransaction                          __uuidof(IXATransaction)
#define  IID_IResourceManagerFactory                 __uuidof(IResourceManagerFactory)
#define  IID_IResourceManagerFactory2                __uuidof(IResourceManagerFactory2)
#define  IID_IPrepareInfo                            __uuidof(IPrepareInfo)
#define  IID_IPrepareInfo2                           __uuidof(IPrepareInfo2)
#define  IID_IGetDispenser                           __uuidof(IGetDispenser)
#define  IID_ITransactionVoterNotifyAsync2           __uuidof(ITransactionVoterNotifyAsync2)
#define  IID_ITransactionVoterBallotAsync2           __uuidof(ITransactionVoterBallotAsync2)
#define  IID_ITransactionVoterFactory2               __uuidof(ITransactionVoterFactory2)
#define  IID_ITransactionPhase0EnlistmentAsync       __uuidof(ITransactionPhase0EnlistmentAsync)
#define  IID_ITransactionPhase0NotifyAsync           __uuidof(ITransactionPhase0NotifyAsync)
#define  IID_ITransactionPhase0Factory               __uuidof(ITransactionPhase0Factory)
#define  IID_ITransactionTransmitter                 __uuidof(ITransactionTransmitter)
#define  IID_ITransactionTransmitterFactory          __uuidof(ITransactionTransmitterFactory)
#define  IID_ITransactionReceiver                    __uuidof(ITransactionReceiver)
#define  IID_ITransactionReceiverFactory             __uuidof(ITransactionReceiverFactory)

#define  IID_IDtcLuConfigure                         __uuidof(IDtcLuConfigure)
#define  IID_IDtcLuRecovery                          __uuidof(IDtcLuRecovery)
#define  IID_IDtcLuRecoveryFactory                   __uuidof(IDtcLuRecoveryFactory)
#define  IID_IDtcLuRecoveryInitiatedByDtcTransWork   __uuidof(IDtcLuRecoveryInitiatedByDtcTransWork)
#define  IID_IDtcLuRecoveryInitiatedByDtcStatusWork  __uuidof(IDtcLuRecoveryInitiatedByDtcStatusWork)
#define  IID_IDtcLuRecoveryInitiatedByDtc            __uuidof(IDtcLuRecoveryInitiatedByDtc)
#define  IID_IDtcLuRecoveryInitiatedByLuWork         __uuidof(IDtcLuRecoveryInitiatedByLuWork)
#define  IID_IDtcLuRecoveryInitiatedByLu             __uuidof(IDtcLuRecoveryInitiatedByLu)
#define  IID_IDtcLuRmEnlistment                      __uuidof(IDtcLuRmEnlistment)
#define  IID_IDtcLuRmEnlistmentSink                  __uuidof(IDtcLuRmEnlistmentSink)
#define  IID_IDtcLuRmEnlistmentFactory               __uuidof(IDtcLuRmEnlistmentFactory)
#define  IID_IDtcLuSubordinateDtc                    __uuidof(IDtcLuSubordinateDtc)
#define  IID_IDtcLuSubordinateDtcSink                __uuidof(IDtcLuSubordinateDtcSink)
#define  IID_IDtcLuSubordinateDtcFactory             __uuidof(IDtcLuSubordinateDtcFactory)

#endif


extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0038_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\txfw32.h ===
/*=============================================================================

	Copyright (c) 2002  Microsoft Corporation

	Module Name:

		Txfw32.h

	Abstract:

		Header for the exported API set for the Txf Win32
		API dynamic link library.
	Author:

		Jacob Lacouture [jacobl] May 9, 2002

	Environment:

		User Mode

	Revision History:


=============================================================================*/


#include <clfsw32.h>

#ifndef _TXF_W32_H_INCLUDED_
#define _TXF_W32_H_INCLUDED_


//
//  These are the different types of replication records that may be read from the log.
//

#define TXF_LOG_RECORD_TYPE_WRITE           0x01
#define TXF_LOG_RECORD_TYPE_TRUNCATE        0x02
#define TXF_LOG_RECORD_TYPE_AFFECTED_FILE   0x04

#define TXF_LOG_RECORD_GENERIC_TYPE_COMMIT  0x01
#define TXF_LOG_RECORD_GENERIC_TYPE_ABORT   0x02
#define TXF_LOG_RECORD_GENERIC_TYPE_PREPARE 0x04
#define TXF_LOG_RECORD_GENERIC_TYPE_DATA    0x08

//
//  Define alignment for all replication records.
//

#pragma pack(4)


//
//  The TXF_ID is exposed as a 128 bit structure.  This should NOT be treated as a GUID, in
//  that this is a unique identifier only within the context of the RM.  These may collide
//  between different RMs.
//


typedef struct _TXF_ID {
    struct {
        LONGLONG LowPart;
        LONGLONG HighPart;
    };
} TXF_ID, *PTXF_ID;

typedef GUID *PGUID;


//
//  This is the basic record.  If the entire record cannot be copied into the user's buffer,
//  at least this much may be copied if the buffer is big enough, so that the user can 
//  determine how large a buffer he needs.
//

typedef struct _TXF_LOG_RECORD_BASE {
    
    //
    //  This is a version identifier for the replication record generated by TXF.
    //

	USHORT Version;

    //
    //  Type of record, defined above.
    //
        
	USHORT RecordType;

    //
    //  Length of this record in bytes.
    //

	ULONG RecordLength;

} TXF_LOG_RECORD_BASE, *PTXF_LOG_RECORD_BASE;

//
//  This indicates a write.  If this write goes beyond the end of the file, that implies
//  an extension of the file.
//

typedef struct _TXF_LOG_RECORD_WRITE {

    //
    //  This is a version identifier for the replication record generated by TXF.
    //

	USHORT Version;

    //
    //  Type of record, defined above.
    //
        
	USHORT RecordType;

    //
    //  Length of this record in bytes.
    //

	ULONG RecordLength;

    //
    //  Record flags.  (none currently defined)
    //

	ULONG Flags;

    //
    //  TxfFileId for the file this record refers to.
    //

	TXF_ID TxfFileId;

    //
    //  This is the KTM transaction GUID for this update.
    //

    UUID KtmGuid;

    //
	//  Beginning location of the write, as an offset from the beginning of the file.
    //

	LONGLONG ByteOffsetInFile;

    //
	//  Number of bytes written.
    //

	ULONG NumBytesWritten;

    //
	//  Offset of the redo data (bytes written) from the beginning of this record.
    //
    
    ULONG ByteOffsetInStructure;
    
    //
    //  Length of the file name, in bytes.
    //

    ULONG FileNameLength;

    //
    //  Offset of the file name from the beginning of this record.
    //

    ULONG FileNameByteOffsetInStructure;


} TXF_LOG_RECORD_WRITE, *PTXF_LOG_RECORD_WRITE;

//
//  This is a truncate record.
//

typedef struct _TXF_LOG_RECORD_TRUNCATE {

    //
    //  This is a version identifier for the replication record generated by TXF.
    //

	USHORT Version;

    //
    //  Type of record, defined above.
    //
        
	USHORT RecordType;

    //
    //  Length of this record in bytes.
    //

	ULONG RecordLength;

    //
    //  Record flags.  (none currently defined)
    //

	ULONG Flags;

    //
    //  TxfFileId for the file this record refers to.
    //

	TXF_ID TxfFileId;

    //
    //  This is the KTM transaction GUID for this update.
    //

    UUID KtmGuid;

    //
	//  New size of the file.
    //

	LONGLONG NewFileSize;

    //
    //  Length of the file name, in bytes.
    //

    ULONG FileNameLength;

    //
    //  Offset of the file name from the beginning of this record.
    //

    ULONG FileNameByteOffsetInStructure;

} TXF_LOG_RECORD_TRUNCATE, *PTXF_LOG_RECORD_TRUNCATE;

//
//  This structure describes a file that was affected by
//  a transaction in a given virtual clock range.
//

typedef struct _TXF_LOG_RECORD_AFFECTED_FILE {

    //
    //  This is a version identifier for the replication record generated by TXF.
    //

	USHORT Version;

    //
    //  Length of this record in bytes.
    //

	ULONG RecordLength;

    //
    //  Record flags.  (none currently defined)
    //

	ULONG Flags;

    //
    //  TxfFileId for the file this record refers to.
    //

	TXF_ID TxfFileId;

    //
    //  This is the KTM transaction GUID for this update.
    //

    UUID KtmGuid;

    //
    //  Length of the file name, in bytes.
    //

    ULONG FileNameLength;

    //
    //  Offset of the file name from the beginning of this record.
    //

    ULONG FileNameByteOffsetInStructure;

} TXF_LOG_RECORD_AFFECTED_FILE, *PTXF_LOG_RECORD_AFFECTED_FILE;

#pragma pack()


//
//  The following are implemented in the TxfW32.dll module
//
#ifdef __cplusplus
extern "C" {
#endif

BOOL 
TxfLogCreateFileReadContext (
    IN LPCWSTR LogPath,
	IN CLFS_LSN BeginningLsn,
    IN CLFS_LSN EndingLsn,
	IN PTXF_ID TxfFileId,
    OUT PVOID *TxfLogContext
    );
/*

  Description:

    This context will be required to read any replication records.  In order to recover 
    resources, the context must later be closed by calling TxfLogDestroyReadContext.  
    Since the resources are allocated by a user-mode process, if that routine is not called, 
    the resources will be recovered automatically when the process hosting the DLL terminates.

  Parameter Definition:

    LogPath               - Location of the RM's CLFS BLF.

    BeginningLsn          - Start of LSN range to search. (inclusive)

    EndingLsn             - End of LSN range to search. (inclusive)

    TxfFileId             - TxfId to scan the log for.

    TxfLogContext - Pointer to new TxfLogContext

*/


BOOL 
TxfLogCreateRangeReadContext (
    IN LPCWSTR LogPath,
	IN CLFS_LSN BeginningLsn,
    IN CLFS_LSN EndingLsn,
    IN PLARGE_INTEGER BeginningVirtualClock,
    IN PLARGE_INTEGER EndingVirtualClock,
    IN ULONG RecordTypeMask,
    OUT PVOID *TxfLogContext
    );
/*

  Description:

    This context will be required to read any replication records.  In order to recover 
    resources, the context must later be closed by calling TxfLogDestroyReadContext.  
    Since the resources are allocated by a user-mode process, if that routine is not called, 
    the resources will be recovered automatically when the process hosting the DLL terminates.

  Parameter Definition:

    LogPath               - Location of the RM's CLFS BLF.

    BeginningLsn          - Start of LSN range to search. (inclusive)

    EndingLsn             - End of LSN range to search. (inclusive)

    TxfFileId             - TxfId to scan the log for.

    TxfLogContext - Pointer to new TxfLogContext

*/

BOOL 
TxfLogDestroyReadContext (
    IN PVOID TxfLogContext
    );
/*

  Description:

    See comments for TxfLogCreateReadContext

  Parameter Definition:

    TxfLogContext - Pointer to TxfLogContext to destroy.
  
*/


BOOL
TxfLogReadRecords (
    IN PVOID TxfLogContext,
    IN ULONG BufferLength,
    OUT PVOID Buffer,
    OUT PULONG BytesUsed,
    OUT PULONG RecordCount
    );
/*
  Description:

    If all of the available records were copied into the buffer, TRUE will be returned.  
    Otherwise, the return value will be FALSE.  If FALSE is returned, LastError should 
    be checked.

    Possible values for LastError are:

        ERROR_INVALID_HANDLE - The replication context is invalid.

        ERROR_MORE_DATA - Some records were copied into the buffer. 
            This routine should be called again to retrieve the rest.

        ERROR_INSUFFICIENT_BUFFER - There wasn't sufficient buffer 
            space to even copy one record.  If this is set, check the
            value of BytesUsed.  If this is nonzero, then there was 
            enough space to copy the TXF_LOG_RECORD_BASE
            record, which indicates how large a buffer is needed to
            read the next complete record.  Call back with a buffer 
            at least that size.  If BytesUsed is zero, the buffer
            provided to this routine was far too small.  Try again
            with a larger buffer.

        ERROR_FILE_CORRUPT - The format of the log file being 
            processed is unrecognized.

        Other error codes may be returned by CLFS.

    --------------------------------------------------------------------------------------
    NOTE: This routine will return all redo records in the log except for CLRs.  This 
          means that the replication client must be intelligent enough to discard records
          for transactions that will ultimately abort.  We provide the KTM GUID in each
          replication record to assist in this filtering.  Alternatively, the replication
          client could query the last LSN after each abort and commit are complete.  The
          scan could then be done only for ranges in which all the records are for 
          committed transactions.
    --------------------------------------------------------------------------------------

  Parameter Definition:

    TxfLogContext - Pointer to TxfLogContext

    BufferLength          - Length of buffer passed to this routine (in bytes)

    Buffer                - Address of buffer to copy records into.

    BytesUsed             - Amount of buffer actually used.

    RecordCount           - Number of records copied into the buffer.

*/


BOOL
TxfReadMetadataInfo (
    IN HANDLE FileHandle,
    OUT PTXF_ID TxfFileId,
    OUT PCLFS_LSN LastLsn,
    OUT PULONG TransactionState,
    OUT PGUID LockingTransaction
    );
/*
  Description:

    This routine will retrieve the TxfFileId, most recent LSN, and locking transaction (if
    applicable) for the specified file.  If the file has not had any transacted work done on
    it, it will have none of these properties and this call will return failure.

  Parameter Definition:

    FileHandle  - File to read the information for.

    TxfFileId   - Returned TxfId of the file.

    LastLsn     - Returned LastLsn for the file.

    TransactionState    - The state of the transaction locking this file.

    LockingTransaction  - If TransactionState != TXFS_TRANSACTION_STATE_NONE, the GUID of
                          the transaction locking the file.  Otherwise, this value has no
                          meaning.

*/


BOOL
TxfLogRecordGetFileName (
    __in_bcount(RecordBufferLengthInBytes) PVOID RecordBuffer,
    __in ULONG RecordBufferLengthInBytes,
    __out_bcount(NameBufferLengthInBytes) PWSTR NameBuffer,
    __inout PULONG NameBufferLengthInBytes,
    __out_opt PTXF_ID TxfId 
    );
/*
  Description:

    This routine will decode a TXF log record and copy the name of
    the file referred to by the record and optionally the TXF ID 
    for it.    

  Parameter Definition:

    RecordBuffer - The TXF log record.

    RecordBufferLengthInBytes - Length of RecordBuffer.

    NameBuffer - Returned name of the file referred to by RecordBuffer.

    NameBuffer - Supplied length of NameBuffer and returned length or
                 required length if buffer is too short.

    TxfFileId   - Returned TxfId of the file.

*/
    

BOOL
TxfLogRecordGetGenericType (
    IN     PVOID RecordBuffer,
    IN     ULONG RecordBufferLengthInBytes,
    OUT    PULONG GenericType,
    OUT    PLARGE_INTEGER VirtualClock OPTIONAL
    );
/*
  Description:

    This routine will decode a TXF log record and determine what type
    of record it is (commit, undo, etc.).  If the type has a virtual
    clock associated with it, then that is returned as well.
    
  Parameter Definition:

    RecordBuffer - The TXF log record.

    RecordBufferLengthInBytes - Length of RecordBuffer.

    GenericType - Returned type of record.

    VirtualClock - Virtual clock if the type has one (0 if not present).

*/


VOID
TxfSetThreadMiniVersionForCreate (
    IN USHORT MiniVersion
    );
/*
  Description:

    This routine is used to set the MiniVersion that a subsequent create should open.
    It should be returned to its previous state after calling create.  Therefore, prior
    to calling this routine, the caller should invoke TxfGetThreadMiniVersionForCreate.

  Parameter Definition:

    MiniVersion - A USHORT identifying which version should be opened by create.

*/

VOID
TxfGetThreadMiniVersionForCreate (
    OUT PUSHORT MiniVersion
    );
/*
  Description:

    This routine returns what MiniVersion a subsequent create is set to open.

  Parameter Definition:

    MiniVersion - Pointer to a USHORT which will receive the result.

*/


//
//  Either of these constants may be used to identify the miniversion to open.
//

#define TXFS_MINIVERSION_COMMITTED_VIEW                  (0x0000)
#define TXFS_MINIVERSION_DIRTY_VIEW                      (0xFFFF)
#define TXFS_MINIVERSION_DEFAULT_VIEW                    (0xFFFE)



#ifdef __cplusplus
//
//  extern "C"
//
}
#endif



//_TXF_W32_H_INCLUDED_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\txlogpub.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for txlogpub.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __txlogpub_h__
#define __txlogpub_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILog_FWD_DEFINED__
#define __ILog_FWD_DEFINED__
typedef interface ILog ILog;
#endif 	/* __ILog_FWD_DEFINED__ */


#ifndef __IFileBasedLogInit_FWD_DEFINED__
#define __IFileBasedLogInit_FWD_DEFINED__
typedef interface IFileBasedLogInit IFileBasedLogInit;
#endif 	/* __IFileBasedLogInit_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_txlogpub_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------


// LSN
// LSN is the fundamental cookie returned from the log as the name of a
// newly-written  log record. LSNs from successively written records to a
// given log are always monotonically increasing. LSNs are directly
// comparable: lsn2 is later in the log than lsn1 if and only if as integers
// lsn2 > lsn1.
//
// Neither the value zero nor the value MAXLSN are ever used as the value of
// an actual LSN.

typedef LARGE_INTEGER LSN;

#define MAXLSN (0x7FFFFFFFFFFFFFFF)


// RECORD_READING_POLICY
// The RECORD_READING_POLICY enumeration values specify a hint about the
// order in which records will be read from a log.  It is used by
// ILog::SetAccessPolicyHint.

typedef 
enum RECORD_READING_POLICY
    {	RECORD_READING_POLICY_FORWARD	= 1,
	RECORD_READING_POLICY_BACKWARD	= 2,
	RECORD_READING_POLICY_RANDOM	= 3
    } 	RECORD_READING_POLICY;



// ILog
// An interface to the lowest level of a log implementation. This level
// takes care of writing the records to disk in a stable manner. Recovery
// protocols, transaction awareness, and the like are provided by a higher
// semantic level.


extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0000_v0_0_s_ifspec;

#ifndef __ILog_INTERFACE_DEFINED__
#define __ILog_INTERFACE_DEFINED__

/* interface ILog */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ILog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FF222117-0C6C-11d2-B89A-00C04FB9618A")
    ILog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Force( 
            /* [in] */ LSN lsnMinToForce) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendRecord( 
            /* [size_is][in] */ __RPC__in_ecount_full(cBlob) BLOB *rgBlob,
            /* [in] */ ULONG cBlob,
            /* [in] */ BOOL fForceNow,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadRecord( 
            /* [in] */ LSN lsnToRead,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnPrev,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnNext,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbData) BYTE **ppbData,
            /* [out] */ __RPC__out ULONG *pcbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadRecordPrefix( 
            /* [in] */ LSN lsnToRead,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnPrev,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnNext,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbData) BYTE *pbData,
            /* [out][in] */ __RPC__inout ULONG *pcbData,
            /* [out] */ __RPC__out ULONG *pcbRecord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogLimits( 
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnFirst,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnLast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TruncatePrefix( 
            /* [in] */ LSN lsnFirstToKeep) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessPolicyHint( 
            /* [in] */ RECORD_READING_POLICY policy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILog * This);
        
        HRESULT ( STDMETHODCALLTYPE *Force )( 
            ILog * This,
            /* [in] */ LSN lsnMinToForce);
        
        HRESULT ( STDMETHODCALLTYPE *AppendRecord )( 
            ILog * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cBlob) BLOB *rgBlob,
            /* [in] */ ULONG cBlob,
            /* [in] */ BOOL fForceNow,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsn);
        
        HRESULT ( STDMETHODCALLTYPE *ReadRecord )( 
            ILog * This,
            /* [in] */ LSN lsnToRead,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnPrev,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnNext,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbData) BYTE **ppbData,
            /* [out] */ __RPC__out ULONG *pcbData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadRecordPrefix )( 
            ILog * This,
            /* [in] */ LSN lsnToRead,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnPrev,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnNext,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbData) BYTE *pbData,
            /* [out][in] */ __RPC__inout ULONG *pcbData,
            /* [out] */ __RPC__out ULONG *pcbRecord);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogLimits )( 
            ILog * This,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnFirst,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnLast);
        
        HRESULT ( STDMETHODCALLTYPE *TruncatePrefix )( 
            ILog * This,
            /* [in] */ LSN lsnFirstToKeep);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessPolicyHint )( 
            ILog * This,
            /* [in] */ RECORD_READING_POLICY policy);
        
        END_INTERFACE
    } ILogVtbl;

    interface ILog
    {
        CONST_VTBL struct ILogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILog_Force(This,lsnMinToForce)	\
    ( (This)->lpVtbl -> Force(This,lsnMinToForce) ) 

#define ILog_AppendRecord(This,rgBlob,cBlob,fForceNow,plsn)	\
    ( (This)->lpVtbl -> AppendRecord(This,rgBlob,cBlob,fForceNow,plsn) ) 

#define ILog_ReadRecord(This,lsnToRead,plsnPrev,plsnNext,ppbData,pcbData)	\
    ( (This)->lpVtbl -> ReadRecord(This,lsnToRead,plsnPrev,plsnNext,ppbData,pcbData) ) 

#define ILog_ReadRecordPrefix(This,lsnToRead,plsnPrev,plsnNext,pbData,pcbData,pcbRecord)	\
    ( (This)->lpVtbl -> ReadRecordPrefix(This,lsnToRead,plsnPrev,plsnNext,pbData,pcbData,pcbRecord) ) 

#define ILog_GetLogLimits(This,plsnFirst,plsnLast)	\
    ( (This)->lpVtbl -> GetLogLimits(This,plsnFirst,plsnLast) ) 

#define ILog_TruncatePrefix(This,lsnFirstToKeep)	\
    ( (This)->lpVtbl -> TruncatePrefix(This,lsnFirstToKeep) ) 

#define ILog_SetAccessPolicyHint(This,policy)	\
    ( (This)->lpVtbl -> SetAccessPolicyHint(This,policy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txlogpub_0000_0001 */
/* [local] */ 



// IFileBasedLogInit
// An interface used to initialize an instance of a file based implementation of
// ILog.  This interface defines the single method InitNew, which is used to
// create a log on a new log file.  Objects that implement IFileBasedLogInit
// should also implement IPersistFile, to allow existing log files to be opened.


extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0001_v0_0_s_ifspec;

#ifndef __IFileBasedLogInit_INTERFACE_DEFINED__
#define __IFileBasedLogInit_INTERFACE_DEFINED__

/* interface IFileBasedLogInit */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileBasedLogInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00951E8C-1294-11d1-97E4-00C04FB9618A")
    IFileBasedLogInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ __RPC__in LPCWSTR filename,
            /* [in] */ ULONG cbCapacityHint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileBasedLogInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileBasedLogInit * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileBasedLogInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileBasedLogInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IFileBasedLogInit * This,
            /* [in] */ __RPC__in LPCWSTR filename,
            /* [in] */ ULONG cbCapacityHint);
        
        END_INTERFACE
    } IFileBasedLogInitVtbl;

    interface IFileBasedLogInit
    {
        CONST_VTBL struct IFileBasedLogInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileBasedLogInit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileBasedLogInit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileBasedLogInit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileBasedLogInit_InitNew(This,filename,cbCapacityHint)	\
    ( (This)->lpVtbl -> InitNew(This,filename,cbCapacityHint) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileBasedLogInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txlogpub_0000_0002 */
/* [local] */ 



EXTERN_C const CLSID CLSID_SimpleFileBasedLog;


extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\UIAutomationCoreApi.h ===
// -------------------------------------------------------------
// UIAutomationCoreAPI.h
//
// UIAutomation core APIs, types and enums
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// -------------------------------------------------------------


#ifndef _INC_UIAUTOMATIONCOREAPI
#define _INC_UIAUTOMATIONCOREAPI
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
//
// General constants and types
//
// --------------------------------------------------------------------------

// These are all in FACILITY_ITF
#define UIA_E_ELEMENTNOTENABLED      0x80040200
#define UIA_E_ELEMENTNOTAVAILABLE    0x80040201
#define UIA_E_NOCLICKABLEPOINT       0x80040202
#define UIA_E_PROXYASSEMBLYNOTLOADED 0x80040203
// The following are COR error codes, included here as a convenience
// (equivalent codes are in <corerror.h>)
#define UIA_E_INVALIDOPERATION       0x80131509 // COR_E_INVALIDOPERATION
#define UIA_E_TIMEOUT                0x80131505 // COR_E_TIMEOUT

// The following common managed exceptions are not represented here
// since they already have standard COM  error codes assigned to them
// by COM Interop:
//   ArgumentException          E_INVALIDARG
//   ArgumentNullException      - maps to ArgumentException

// Other constants
#define UiaAppendRuntimeId     3
#define UiaRootObjectId        -25

DECLARE_HANDLE(HUIANODE);
DECLARE_HANDLE(HUIAPATTERNOBJECT);
DECLARE_HANDLE(HUIATEXTRANGE);
DECLARE_HANDLE(HUIAEVENT);

enum TreeScope
{
    TreeScope_Element =       0x1,
    TreeScope_Children =      0x2,
    TreeScope_Descendants =   0x4,
    TreeScope_Parent =        0x8,
    TreeScope_Ancestors =     0x10,
    TreeScope_Subtree = TreeScope_Element | TreeScope_Children | TreeScope_Descendants
};

// --------------------------------------------------------------------------
//
// Automation Identifier GUIDs
//
// --------------------------------------------------------------------------

DEFINE_GUID(RuntimeId_Property_GUID,                                    0xa39eebfa, 0x7fba, 0x4c89, 0xb4, 0xd4, 0xb9, 0x9e, 0x2d, 0xe7, 0xd1, 0x60);
DEFINE_GUID(BoundingRectangle_Property_GUID,                            0x7bbfe8b2, 0x3bfc, 0x48dd, 0xb7, 0x29, 0xc7, 0x94, 0xb8, 0x46, 0xe9, 0xa1);
DEFINE_GUID(ProcessId_Property_GUID,                                    0x40499998, 0x9c31, 0x4245, 0xa4, 0x03, 0x87, 0x32, 0x0e, 0x59, 0xea, 0xf6);
DEFINE_GUID(ControlType_Property_GUID,                                  0xca774fea, 0x28ac, 0x4bc2, 0x94, 0xca, 0xac, 0xec, 0x6d, 0x6c, 0x10, 0xa3);
DEFINE_GUID(LocalizedControlType_Property_GUID,                         0x8763404f, 0xa1bd, 0x452a, 0x89, 0xc4, 0x3f, 0x01, 0xd3, 0x83, 0x38, 0x06);
DEFINE_GUID(Name_Property_GUID,                                         0xc3a6921b, 0x4a99, 0x44f1, 0xbc, 0xa6, 0x61, 0x18, 0x70, 0x52, 0xc4, 0x31);
DEFINE_GUID(AcceleratorKey_Property_GUID,                               0x514865df, 0x2557, 0x4cb9, 0xae, 0xed, 0x6c, 0xed, 0x08, 0x4c, 0xe5, 0x2c);
DEFINE_GUID(AccessKey_Property_GUID,                                    0x06827b12, 0xa7f9, 0x4a15, 0x91, 0x7c, 0xff, 0xa5, 0xad, 0x3e, 0xb0, 0xa7);
DEFINE_GUID(HasKeyboardFocus_Property_GUID,                             0xcf8afd39, 0x3f46, 0x4800, 0x96, 0x56, 0xb2, 0xbf, 0x12, 0x52, 0x99, 0x05);
DEFINE_GUID(IsKeyboardFocusable_Property_GUID,                          0xf7b8552a, 0x0859, 0x4b37, 0xb9, 0xcb, 0x51, 0xe7, 0x20, 0x92, 0xf2, 0x9f);
DEFINE_GUID(IsEnabled_Property_GUID,                                    0x2109427f, 0xda60, 0x4fed, 0xbf, 0x1b, 0x26, 0x4b, 0xdc, 0xe6, 0xeb, 0x3a);
DEFINE_GUID(AutomationId_Property_GUID,                                 0xc82c0500, 0xb60e, 0x4310, 0xa2, 0x67, 0x30, 0x3c, 0x53, 0x1f, 0x8e, 0xe5);
DEFINE_GUID(ClassName_Property_GUID,                                    0x157b7215, 0x894f, 0x4b65, 0x84, 0xe2, 0xaa, 0xc0, 0xda, 0x08, 0xb1, 0x6b);
DEFINE_GUID(HelpText_Property_GUID,                                     0x08555685, 0x0977, 0x45c7, 0xa7, 0xa6, 0xab, 0xaf, 0x56, 0x84, 0x12, 0x1a);
DEFINE_GUID(ClickablePoint_Property_GUID,                               0x0196903b, 0xb203, 0x4818, 0xa9, 0xf3, 0xf0, 0x8e, 0x67, 0x5f, 0x23, 0x41);
DEFINE_GUID(Culture_Property_GUID,                                      0xe2d74f27, 0x3d79, 0x4dc2, 0xb8, 0x8b, 0x30, 0x44, 0x96, 0x3a, 0x8a, 0xfb);
DEFINE_GUID(IsControlElement_Property_GUID,                             0x95f35085, 0xabcc, 0x4afd, 0xa5, 0xf4, 0xdb, 0xb4, 0x6c, 0x23, 0x0f, 0xdb);
DEFINE_GUID(IsContentElement_Property_GUID,                             0x4bda64a8, 0xf5d8, 0x480b, 0x81, 0x55, 0xef, 0x2e, 0x89, 0xad, 0xb6, 0x72);
DEFINE_GUID(LabeledBy_Property_GUID,                                    0xe5b8924b, 0xfc8a, 0x4a35, 0x80, 0x31, 0xcf, 0x78, 0xac, 0x43, 0xe5, 0x5e);
DEFINE_GUID(IsPassword_Property_GUID,                                   0xe8482eb1, 0x687c, 0x497b, 0xbe, 0xbc, 0x03, 0xbe, 0x53, 0xec, 0x14, 0x54);
DEFINE_GUID(NewNativeWindowHandle_Property_GUID,                        0x5196b33b, 0x380a, 0x4982, 0x95, 0xe1, 0x91, 0xf3, 0xef, 0x60, 0xe0, 0x24);
DEFINE_GUID(ItemType_Property_GUID,                                     0xcdda434d, 0x6222, 0x413b, 0xa6, 0x8a, 0x32, 0x5d, 0xd1, 0xd4, 0x0f, 0x39);
DEFINE_GUID(IsOffscreen_Property_GUID,                                  0x03c3d160, 0xdb79, 0x42db, 0xa2, 0xef, 0x1c, 0x23, 0x1e, 0xed, 0xe5, 0x07);
DEFINE_GUID(Orientation_Property_GUID,                                  0xa01eee62, 0x3884, 0x4415, 0x88, 0x7e, 0x67, 0x8e, 0xc2, 0x1e, 0x39, 0xba);
DEFINE_GUID(FrameworkId_Property_GUID,                                  0xdbfd9900, 0x7e1a, 0x4f58, 0xb6, 0x1b, 0x70, 0x63, 0x12, 0x0f, 0x77, 0x3b);
DEFINE_GUID(IsRequiredForForm_Property_GUID,                            0x4f5f43cf, 0x59fb, 0x4bde, 0xa2, 0x70, 0x60, 0x2e, 0x5e, 0x11, 0x41, 0xe9);
DEFINE_GUID(ItemStatus_Property_GUID,                                   0x51de0321, 0x3973, 0x43e7, 0x89, 0x13, 0x0b, 0x08, 0xe8, 0x13, 0xc3, 0x7f);
DEFINE_GUID(IsDockPatternAvailable_Property_GUID,                       0x2600a4c4, 0x2ff8, 0x4c96, 0xae, 0x31, 0x8f, 0xe6, 0x19, 0xa1, 0x3c, 0x6c);
DEFINE_GUID(IsExpandCollapsePatternAvailable_Property_GUID,             0x929d3806, 0x5287, 0x4725, 0xaa, 0x16, 0x22, 0x2a, 0xfc, 0x63, 0xd5, 0x95);
DEFINE_GUID(IsGridItemPatternAvailable_Property_GUID,                   0x5a43e524, 0xf9a2, 0x4b12, 0x84, 0xc8, 0xb4, 0x8a, 0x3e, 0xfe, 0xdd, 0x34);
DEFINE_GUID(IsGridPatternAvailable_Property_GUID,                       0x5622c26c, 0xf0ef, 0x4f3b, 0x97, 0xcb, 0x71, 0x4c, 0x08, 0x68, 0x58, 0x8b);
DEFINE_GUID(IsInvokePatternAvailable_Property_GUID,                     0x4e725738, 0x8364, 0x4679, 0xaa, 0x6c, 0xf3, 0xf4, 0x19, 0x31, 0xf7, 0x50);
DEFINE_GUID(IsMultipleViewPatternAvailable_Property_GUID,               0xff0a31eb, 0x8e25, 0x469d, 0x8d, 0x6e, 0xe7, 0x71, 0xa2, 0x7c, 0x1b, 0x90);
DEFINE_GUID(IsRangeValuePatternAvailable_Property_GUID,                 0xfda4244a, 0xeb4d, 0x43ff, 0xb5, 0xad, 0xed, 0x36, 0xd3, 0x73, 0xec, 0x4c);
DEFINE_GUID(IsScrollPatternAvailable_Property_GUID,                     0x3ebb7b4a, 0x828a, 0x4b57, 0x9d, 0x22, 0x2f, 0xea, 0x16, 0x32, 0xed, 0x0d);
DEFINE_GUID(IsScrollItemPatternAvailable_Property_GUID,                 0x1cad1a05, 0x0927, 0x4b76, 0x97, 0xe1, 0x0f, 0xcd, 0xb2, 0x09, 0xb9, 0x8a);
DEFINE_GUID(IsSelectionItemPatternAvailable_Property_GUID,              0x8becd62d, 0x0bc3, 0x4109, 0xbe, 0xe2, 0x8e, 0x67, 0x15, 0x29, 0x0e, 0x68);
DEFINE_GUID(IsSelectionPatternAvailable_Property_GUID,                  0xf588acbe, 0xc769, 0x4838, 0x9a, 0x60, 0x26, 0x86, 0xdc, 0x11, 0x88, 0xc4);
DEFINE_GUID(IsTablePatternAvailable_Property_GUID,                      0xcb83575f, 0x45c2, 0x4048, 0x9c, 0x76, 0x15, 0x97, 0x15, 0xa1, 0x39, 0xdf);
DEFINE_GUID(IsTableItemPatternAvailable_Property_GUID,                  0xeb36b40d, 0x8ea4, 0x489b, 0xa0, 0x13, 0xe6, 0x0d, 0x59, 0x51, 0xfe, 0x34);
DEFINE_GUID(IsTextPatternAvailable_Property_GUID,                       0xfbe2d69d, 0xaff6, 0x4a45, 0x82, 0xe2, 0xfc, 0x92, 0xa8, 0x2f, 0x59, 0x17);
DEFINE_GUID(IsTogglePatternAvailable_Property_GUID,                     0x78686d53, 0xfcd0, 0x4b83, 0x9b, 0x78, 0x58, 0x32, 0xce, 0x63, 0xbb, 0x5b);
DEFINE_GUID(IsTransformPatternAvailable_Property_GUID,                  0xa7f78804, 0xd68b, 0x4077, 0xa5, 0xc6, 0x7a, 0x5e, 0xa1, 0xac, 0x31, 0xc5);
DEFINE_GUID(IsValuePatternAvailable_Property_GUID,                      0x0b5020a7, 0x2119, 0x473b, 0xbe, 0x37, 0x5c, 0xeb, 0x98, 0xbb, 0xfb, 0x22);
DEFINE_GUID(IsWindowPatternAvailable_Property_GUID,                     0xe7a57bb1, 0x5888, 0x4155, 0x98, 0xdc, 0xb4, 0x22, 0xfd, 0x57, 0xf2, 0xbc);
DEFINE_GUID(Value_Value_Property_GUID,                                  0xe95f5e64, 0x269f, 0x4a85, 0xba, 0x99, 0x40, 0x92, 0xc3, 0xea, 0x29, 0x86);
DEFINE_GUID(Value_IsReadOnly_Property_GUID,                             0xeb090f30, 0xe24c, 0x4799, 0xa7, 0x05, 0x0d, 0x24, 0x7b, 0xc0, 0x37, 0xf8);
DEFINE_GUID(RangeValue_Value_Property_GUID,                             0x131f5d98, 0xc50c, 0x489d, 0xab, 0xe5, 0xae, 0x22, 0x08, 0x98, 0xc5, 0xf7);
DEFINE_GUID(RangeValue_IsReadOnly_Property_GUID,                        0x25fa1055, 0xdebf, 0x4373, 0xa7, 0x9e, 0x1f, 0x1a, 0x19, 0x08, 0xd3, 0xc4);
DEFINE_GUID(RangeValue_Minimum_Property_GUID,                           0x78cbd3b2, 0x684d, 0x4860, 0xaf, 0x93, 0xd1, 0xf9, 0x5c, 0xb0, 0x22, 0xfd);
DEFINE_GUID(RangeValue_Maximum_Property_GUID,                           0x19319914, 0xf979, 0x4b35, 0xa1, 0xa6, 0xd3, 0x7e, 0x05, 0x43, 0x34, 0x73);
DEFINE_GUID(RangeValue_LargeChange_Property_GUID,                       0xa1f96325, 0x3a3d, 0x4b44, 0x8e, 0x1f, 0x4a, 0x46, 0xd9, 0x84, 0x40, 0x19);
DEFINE_GUID(RangeValue_SmallChange_Property_GUID,                       0x81c2c457, 0x3941, 0x4107, 0x99, 0x75, 0x13, 0x97, 0x60, 0xf7, 0xc0, 0x72);
DEFINE_GUID(Scroll_HorizontalScrollPercent_Property_GUID,               0xc7c13c0e, 0xeb21, 0x47ff, 0xac, 0xc4, 0xb5, 0xa3, 0x35, 0x0f, 0x51, 0x91);
DEFINE_GUID(Scroll_HorizontalViewSize_Property_GUID,                    0x70c2e5d4, 0xfcb0, 0x4713, 0xa9, 0xaa, 0xaf, 0x92, 0xff, 0x79, 0xe4, 0xcd);
DEFINE_GUID(Scroll_VerticalScrollPercent_Property_GUID,                 0x6c8d7099, 0xb2a8, 0x4948, 0xbf, 0xf7, 0x3c, 0xf9, 0x05, 0x8b, 0xfe, 0xfb);
DEFINE_GUID(Scroll_VerticalViewSize_Property_GUID,                      0xde6a2e22, 0xd8c7, 0x40c5, 0x83, 0xba, 0xe5, 0xf6, 0x81, 0xd5, 0x31, 0x08);
DEFINE_GUID(Scroll_HorizontallyScrollable_Property_GUID,                0x8b925147, 0x28cd, 0x49ae, 0xbd, 0x63, 0xf4, 0x41, 0x18, 0xd2, 0xe7, 0x19);
DEFINE_GUID(Scroll_VerticallyScrollable_Property_GUID,                  0x89164798, 0x0068, 0x4315, 0xb8, 0x9a, 0x1e, 0x7c, 0xfb, 0xbc, 0x3d, 0xfc);
DEFINE_GUID(Selection_Selection_Property_GUID,                          0xaa6dc2a2, 0x0e2b, 0x4d38, 0x96, 0xd5, 0x34, 0xe4, 0x70, 0xb8, 0x18, 0x53);
DEFINE_GUID(Selection_CanSelectMultiple_Property_GUID,                  0x49d73da5, 0xc883, 0x4500, 0x88, 0x3d, 0x8f, 0xcf, 0x8d, 0xaf, 0x6c, 0xbe);
DEFINE_GUID(Selection_IsSelectionRequired_Property_GUID,                0xb1ae4422, 0x63fe, 0x44e7, 0xa5, 0xa5, 0xa7, 0x38, 0xc8, 0x29, 0xb1, 0x9a);
DEFINE_GUID(Grid_RowCount_Property_GUID,                                0x2a9505bf, 0xc2eb, 0x4fb6, 0xb3, 0x56, 0x82, 0x45, 0xae, 0x53, 0x70, 0x3e);
DEFINE_GUID(Grid_ColumnCount_Property_GUID,                             0xfe96f375, 0x44aa, 0x4536, 0xac, 0x7a, 0x2a, 0x75, 0xd7, 0x1a, 0x3e, 0xfc);
DEFINE_GUID(GridItem_Row_Property_GUID,                                 0x6223972a, 0xc945, 0x4563, 0x93, 0x29, 0xfd, 0xc9, 0x74, 0xaf, 0x25, 0x53);
DEFINE_GUID(GridItem_Column_Property_GUID,                              0xc774c15c, 0x62c0, 0x4519, 0x8b, 0xdc, 0x47, 0xbe, 0x57, 0x3c, 0x8a, 0xd5);
DEFINE_GUID(GridItem_RowSpan_Property_GUID,                             0x4582291c, 0x466b, 0x4e93, 0x8e, 0x83, 0x3d, 0x17, 0x15, 0xec, 0x0c, 0x5e);
DEFINE_GUID(GridItem_ColumnSpan_Property_GUID,                          0x583ea3f5, 0x86d0, 0x4b08, 0xa6, 0xec, 0x2c, 0x54, 0x63, 0xff, 0xc1, 0x09);
DEFINE_GUID(GridItem_Parent_Property_GUID,                              0x9d912252, 0xb97f, 0x4ecc, 0x85, 0x10, 0xea, 0x0e, 0x33, 0x42, 0x7c, 0x72);
DEFINE_GUID(Dock_DockPosition_Property_GUID,                            0x6d67f02e, 0xc0b0, 0x4b10, 0xb5, 0xb9, 0x18, 0xd6, 0xec, 0xf9, 0x87, 0x60);
DEFINE_GUID(ExpandCollapse_ExpandCollapseState_Property_GUID,           0x275a4c48, 0x85a7, 0x4f69, 0xab, 0xa0, 0xaf, 0x15, 0x76, 0x10, 0x00, 0x2b);
DEFINE_GUID(MultipleView_CurrentView_Property_GUID,                     0x7a81a67a, 0xb94f, 0x4875, 0x91, 0x8b, 0x65, 0xc8, 0xd2, 0xf9, 0x98, 0xe5);
DEFINE_GUID(MultipleView_SupportedViews_Property_GUID,                  0x8d5db9fd, 0xce3c, 0x4ae7, 0xb7, 0x88, 0x40, 0x0a, 0x3c, 0x64, 0x55, 0x47);
DEFINE_GUID(Window_CanMaximize_Property_GUID,                           0x64fff53f, 0x635d, 0x41c1, 0x95, 0x0c, 0xcb, 0x5a, 0xdf, 0xbe, 0x28, 0xe3);
DEFINE_GUID(Window_CanMinimize_Property_GUID,                           0xb73b4625, 0x5988, 0x4b97, 0xb4, 0xc2, 0xa6, 0xfe, 0x6e, 0x78, 0xc8, 0xc6);
DEFINE_GUID(Window_WindowVisualState_Property_GUID,                     0x4ab7905f, 0xe860, 0x453e, 0xa3, 0x0a, 0xf6, 0x43, 0x1e, 0x5d, 0xaa, 0xd5);
DEFINE_GUID(Window_WindowInteractionState_Property_GUID,                0x4fed26a4, 0x0455, 0x4fa2, 0xb2, 0x1c, 0xc4, 0xda, 0x2d, 0xb1, 0xff, 0x9c);
DEFINE_GUID(Window_IsModal_Property_GUID,                               0xff4e6892, 0x37b9, 0x4fca, 0x85, 0x32, 0xff, 0xe6, 0x74, 0xec, 0xfe, 0xed);
DEFINE_GUID(Window_IsTopmost_Property_GUID,                             0xef7d85d3, 0x0937, 0x4962, 0x92, 0x41, 0xb6, 0x23, 0x45, 0xf2, 0x40, 0x41);
DEFINE_GUID(SelectionItem_IsSelected_Property_GUID,                     0xf122835f, 0xcd5f, 0x43df, 0xb7, 0x9d, 0x4b, 0x84, 0x9e, 0x9e, 0x60, 0x20);
DEFINE_GUID(SelectionItem_SelectionContainer_Property_GUID,             0xa4365b6e, 0x9c1e, 0x4b63, 0x8b, 0x53, 0xc2, 0x42, 0x1d, 0xd1, 0xe8, 0xfb);
DEFINE_GUID(Table_RowHeaders_Property_GUID,                             0xd9e35b87, 0x6eb8, 0x4562, 0xaa, 0xc6, 0xa8, 0xa9, 0x07, 0x52, 0x36, 0xa8);
DEFINE_GUID(Table_ColumnHeaders_Property_GUID,                          0xaff1d72b, 0x968d, 0x42b1, 0xb4, 0x59, 0x15, 0x0b, 0x29, 0x9d, 0xa6, 0x64);
DEFINE_GUID(Table_RowOrColumnMajor_Property_GUID,                       0x83be75c3, 0x29fe, 0x4a30, 0x85, 0xe1, 0x2a, 0x62, 0x77, 0xfd, 0x10, 0x6e);
DEFINE_GUID(TableItem_RowHeaderItems_Property_GUID,                     0xb3f853a0, 0x0574, 0x4cd8, 0xbc, 0xd7, 0xed, 0x59, 0x23, 0x57, 0x2d, 0x97);
DEFINE_GUID(TableItem_ColumnHeaderItems_Property_GUID,                  0x967a56a3, 0x74b6, 0x431e, 0x8d, 0xe6, 0x99, 0xc4, 0x11, 0x03, 0x1c, 0x58);
DEFINE_GUID(Toggle_ToggleState_Property_GUID,                           0xb23cdc52, 0x22c2, 0x4c6c, 0x9d, 0xed, 0xf5, 0xc4, 0x22, 0x47, 0x9e, 0xde);
DEFINE_GUID(Transform_CanMove_Property_GUID,                            0x1b75824d, 0x208b, 0x4fdf, 0xbc, 0xcd, 0xf1, 0xf4, 0xe5, 0x74, 0x1f, 0x4f);
DEFINE_GUID(Transform_CanResize_Property_GUID,                          0xbb98dca5, 0x4c1a, 0x41d4, 0xa4, 0xf6, 0xeb, 0xc1, 0x28, 0x64, 0x41, 0x80);
DEFINE_GUID(Transform_CanRotate_Property_GUID,                          0x10079b48, 0x3849, 0x476f, 0xac, 0x96, 0x44, 0xa9, 0x5c, 0x84, 0x40, 0xd9);
DEFINE_GUID(ToolTipOpened_Event_GUID,                                   0x3f4b97ff, 0x2edc, 0x451d, 0xbc, 0xa4, 0x95, 0xa3, 0x18, 0x8d, 0x5b, 0x03);
DEFINE_GUID(ToolTipClosed_Event_GUID,                                   0x276d71ef, 0x24a9, 0x49b6, 0x8e, 0x97, 0xda, 0x98, 0xb4, 0x01, 0xbb, 0xcd);
DEFINE_GUID(StructureChanged_Event_GUID,                                0x59977961, 0x3edd, 0x4b11, 0xb1, 0x3b, 0x67, 0x6b, 0x2a, 0x2a, 0x6c, 0xa9);
DEFINE_GUID(MenuOpened_Event_GUID,                                      0xebe2e945, 0x66ca, 0x4ed1, 0x9f, 0xf8, 0x2a, 0xd7, 0xdf, 0x0a, 0x1b, 0x08);
DEFINE_GUID(AutomationPropertyChanged_Event_GUID,                       0x2527fba1, 0x8d7a, 0x4630, 0xa4, 0xcc, 0xe6, 0x63, 0x15, 0x94, 0x2f, 0x52);
DEFINE_GUID(AutomationFocusChanged_Event_GUID,                          0xb68a1f17, 0xf60d, 0x41a7, 0xa3, 0xcc, 0xb0, 0x52, 0x92, 0x15, 0x5f, 0xe0);
DEFINE_GUID(AsyncContentLoaded_Event_GUID,                              0x5fdee11c, 0xd2fa, 0x4fb9, 0x90, 0x4e, 0x5c, 0xbe, 0xe8, 0x94, 0xd5, 0xef);
DEFINE_GUID(MenuClosed_Event_GUID,                                      0x3cf1266e, 0x1582, 0x4041, 0xac, 0xd7, 0x88, 0xa3, 0x5a, 0x96, 0x52, 0x97);
DEFINE_GUID(LayoutInvalidated_Event_GUID,                               0xed7d6544, 0xa6bd, 0x4595, 0x9b, 0xae, 0x3d, 0x28, 0x94, 0x6c, 0xc7, 0x15);
DEFINE_GUID(Invoke_Invoked_Event_GUID,                                  0xdfd699f0, 0xc915, 0x49dd, 0xb4, 0x22, 0xdd, 0xe7, 0x85, 0xc3, 0xd2, 0x4b);
DEFINE_GUID(SelectionItem_ElementAddedToSelectionEvent_Event_GUID,      0x3c822dd1, 0xc407, 0x4dba, 0x91, 0xdd, 0x79, 0xd4, 0xae, 0xd0, 0xae, 0xc6);
DEFINE_GUID(SelectionItem_ElementRemovedFromSelectionEvent_Event_GUID,  0x097fa8a9, 0x7079, 0x41af, 0x8b, 0x9c, 0x09, 0x34, 0xd8, 0x30, 0x5e, 0x5c);
DEFINE_GUID(SelectionItem_ElementSelectedEvent_Event_GUID,              0xb9c7dbfb, 0x4ebe, 0x4532, 0xaa, 0xf4, 0x00, 0x8c, 0xf6, 0x47, 0x23, 0x3c);
DEFINE_GUID(Selection_InvalidatedEvent_Event_GUID,                      0xcac14904, 0x16b4, 0x4b53, 0x8e, 0x47, 0x4c, 0xb1, 0xdf, 0x26, 0x7b, 0xb7);
DEFINE_GUID(Text_TextSelectionChangedEvent_Event_GUID,                  0x918edaa1, 0x71b3, 0x49ae, 0x97, 0x41, 0x79, 0xbe, 0xb8, 0xd3, 0x58, 0xf3);
DEFINE_GUID(Text_TextChangedEvent_Event_GUID,                           0x4a342082, 0xf483, 0x48c4, 0xac, 0x11, 0xa8, 0x4b, 0x43, 0x5e, 0x2a, 0x84);
DEFINE_GUID(Window_WindowOpened_Event_GUID,                             0xd3e81d06, 0xde45, 0x4f2f, 0x96, 0x33, 0xde, 0x9e, 0x02, 0xfb, 0x65, 0xaf);
DEFINE_GUID(Window_WindowClosed_Event_GUID,                             0xedf141f8, 0xfa67, 0x4e22, 0xbb, 0xf7, 0x94, 0x4e, 0x05, 0x73, 0x5e, 0xe2);
DEFINE_GUID(Invoke_Pattern_GUID,                                        0xd976c2fc, 0x66ea, 0x4a6e, 0xb2, 0x8f, 0xc2, 0x4c, 0x75, 0x46, 0xad, 0x37);
DEFINE_GUID(Selection_Pattern_GUID,                                     0x66e3b7e8, 0xd821, 0x4d25, 0x87, 0x61, 0x43, 0x5d, 0x2c, 0x8b, 0x25, 0x3f);
DEFINE_GUID(Value_Pattern_GUID,                                         0x17faad9e, 0xc877, 0x475b, 0xb9, 0x33, 0x77, 0x33, 0x27, 0x79, 0xb6, 0x37);
DEFINE_GUID(RangeValue_Pattern_GUID,                                    0x18b00d87, 0xb1c9, 0x476a, 0xbf, 0xbd, 0x5f, 0x0b, 0xdb, 0x92, 0x6f, 0x63);
DEFINE_GUID(Scroll_Pattern_GUID,                                        0x895fa4b4, 0x759d, 0x4c50, 0x8e, 0x15, 0x03, 0x46, 0x06, 0x72, 0x00, 0x3c);
DEFINE_GUID(ExpandCollapse_Pattern_GUID,                                0xae05efa2, 0xf9d1, 0x428a, 0x83, 0x4c, 0x53, 0xa5, 0xc5, 0x2f, 0x9b, 0x8b);
DEFINE_GUID(Grid_Pattern_GUID,                                          0x260a2ccb, 0x93a8, 0x4e44, 0xa4, 0xc1, 0x3d, 0xf3, 0x97, 0xf2, 0xb0, 0x2b);
DEFINE_GUID(GridItem_Pattern_GUID,                                      0xf2d5c877, 0xa462, 0x4957, 0xa2, 0xa5, 0x2c, 0x96, 0xb3, 0x03, 0xbc, 0x63);
DEFINE_GUID(MultipleView_Pattern_GUID,                                  0x547a6ae4, 0x113f, 0x47c4, 0x85, 0x0f, 0xdb, 0x4d, 0xfa, 0x46, 0x6b, 0x1d);
DEFINE_GUID(Window_Pattern_GUID,                                        0x27901735, 0xc760, 0x4994, 0xad, 0x11, 0x59, 0x19, 0xe6, 0x06, 0xb1, 0x10);
DEFINE_GUID(SelectionItem_Pattern_GUID,                                 0x9bc64eeb, 0x87c7, 0x4b28, 0x94, 0xbb, 0x4d, 0x9f, 0xa4, 0x37, 0xb6, 0xef);
DEFINE_GUID(Dock_Pattern_GUID,                                          0x9cbaa846, 0x83c8, 0x428d, 0x82, 0x7f, 0x7e, 0x60, 0x63, 0xfe, 0x06, 0x20);
DEFINE_GUID(Table_Pattern_GUID,                                         0xc415218e, 0xa028, 0x461e, 0xaa, 0x92, 0x8f, 0x92, 0x5c, 0xf7, 0x93, 0x51);
DEFINE_GUID(TableItem_Pattern_GUID,                                     0xdf1343bd, 0x1888, 0x4a29, 0xa5, 0x0c, 0xb9, 0x2e, 0x6d, 0xe3, 0x7f, 0x6f);
DEFINE_GUID(Text_Pattern_GUID,                                          0x8615f05d, 0x7de5, 0x44fd, 0xa6, 0x79, 0x2c, 0xa4, 0xb4, 0x60, 0x33, 0xa8);
DEFINE_GUID(Toggle_Pattern_GUID,                                        0x0b419760, 0xe2f4, 0x43ff, 0x8c, 0x5f, 0x94, 0x57, 0xc8, 0x2b, 0x56, 0xe9);
DEFINE_GUID(Transform_Pattern_GUID,                                     0x24b46fdb, 0x587e, 0x49f1, 0x9c, 0x4a, 0xd8, 0xe9, 0x8b, 0x66, 0x4b, 0x7b);
DEFINE_GUID(ScrollItem_Pattern_GUID,                                    0x4591d005, 0xa803, 0x4d5c, 0xb4, 0xd5, 0x8d, 0x28, 0x00, 0xf9, 0x06, 0xa7);
DEFINE_GUID(Button_Control_GUID,                                        0x5a78e369, 0xc6a1, 0x4f33, 0xa9, 0xd7, 0x79, 0xf2, 0x0d, 0x0c, 0x78, 0x8e);
DEFINE_GUID(Calendar_Control_GUID,                                      0x8913eb88, 0x00e5, 0x46bc, 0x8e, 0x4e, 0x14, 0xa7, 0x86, 0xe1, 0x65, 0xa1);
DEFINE_GUID(CheckBox_Control_GUID,                                      0xfb50f922, 0xa3db, 0x49c0, 0x8b, 0xc3, 0x06, 0xda, 0xd5, 0x57, 0x78, 0xe2);
DEFINE_GUID(ComboBox_Control_GUID,                                      0x54cb426c, 0x2f33, 0x4fff, 0xaa, 0xa1, 0xae, 0xf6, 0x0d, 0xac, 0x5d, 0xeb);
DEFINE_GUID(Edit_Control_GUID,                                          0x6504a5c8, 0x2c86, 0x4f87, 0xae, 0x7b, 0x1a, 0xbd, 0xdc, 0x81, 0x0c, 0xf9);
DEFINE_GUID(Hyperlink_Control_GUID,                                     0x8a56022c, 0xb00d, 0x4d15, 0x8f, 0xf0, 0x5b, 0x6b, 0x26, 0x6e, 0x5e, 0x02);
DEFINE_GUID(Image_Control_GUID,                                         0x2d3736e4, 0x6b16, 0x4c57, 0xa9, 0x62, 0xf9, 0x32, 0x60, 0xa7, 0x52, 0x43);
DEFINE_GUID(ListItem_Control_GUID,                                      0x7b3717f2, 0x44d1, 0x4a58, 0x98, 0xa8, 0xf1, 0x2a, 0x9b, 0x8f, 0x78, 0xe2);
DEFINE_GUID(List_Control_GUID,                                          0x9b149ee1, 0x7cca, 0x4cfc, 0x9a, 0xf1, 0xca, 0xc7, 0xbd, 0xdd, 0x30, 0x31);
DEFINE_GUID(Menu_Control_GUID,                                          0x2e9b1440, 0x0ea8, 0x41fd, 0xb3, 0x74, 0xc1, 0xea, 0x6f, 0x50, 0x3c, 0xd1);
DEFINE_GUID(MenuBar_Control_GUID,                                       0xcc384250, 0x0e7b, 0x4ae8, 0x95, 0xae, 0xa0, 0x8f, 0x26, 0x1b, 0x52, 0xee);
DEFINE_GUID(MenuItem_Control_GUID,                                      0xf45225d3, 0xd0a0, 0x49d8, 0x98, 0x34, 0x9a, 0x00, 0x0d, 0x2a, 0xed, 0xdc);
DEFINE_GUID(ProgressBar_Control_GUID,                                   0x228c9f86, 0xc36c, 0x47bb, 0x9f, 0xb6, 0xa5, 0x83, 0x4b, 0xfc, 0x53, 0xa4);
DEFINE_GUID(RadioButton_Control_GUID,                                   0x3bdb49db, 0xfe2c, 0x4483, 0xb3, 0xe1, 0xe5, 0x7f, 0x21, 0x94, 0x40, 0xc6);
DEFINE_GUID(ScrollBar_Control_GUID,                                     0xdaf34b36, 0x5065, 0x4946, 0xb2, 0x2f, 0x92, 0x59, 0x5f, 0xc0, 0x75, 0x1a);
DEFINE_GUID(Slider_Control_GUID,                                        0xb033c24b, 0x3b35, 0x4cea, 0xb6, 0x09, 0x76, 0x36, 0x82, 0xfa, 0x66, 0x0b);
DEFINE_GUID(Spinner_Control_GUID,                                       0x60cc4b38, 0x3cb1, 0x4161, 0xb4, 0x42, 0xc6, 0xb7, 0x26, 0xc1, 0x78, 0x25);
DEFINE_GUID(StatusBar_Control_GUID,                                     0xd45e7d1b, 0x5873, 0x475f, 0x95, 0xa4, 0x04, 0x33, 0xe1, 0xf1, 0xb0, 0x0a);
DEFINE_GUID(Tab_Control_GUID,                                           0x38cd1f2d, 0x337a, 0x4bd2, 0xa5, 0xe3, 0xad, 0xb4, 0x69, 0xe3, 0x0b, 0xd3);
DEFINE_GUID(TabItem_Control_GUID,                                       0x2c6a634f, 0x921b, 0x4e6e, 0xb2, 0x6e, 0x08, 0xfc, 0xb0, 0x79, 0x8f, 0x4c);
DEFINE_GUID(Text_Control_GUID,                                          0xae9772dc, 0xd331, 0x4f09, 0xbe, 0x20, 0x7e, 0x6d, 0xfa, 0xf0, 0x7b, 0x0a);
DEFINE_GUID(ToolBar_Control_GUID,                                       0x8f06b751, 0xe182, 0x4e98, 0x88, 0x93, 0x22, 0x84, 0x54, 0x3a, 0x7d, 0xce);
DEFINE_GUID(ToolTip_Control_GUID,                                       0x05ddc6d1, 0x2137, 0x4768, 0x98, 0xea, 0x73, 0xf5, 0x2f, 0x71, 0x34, 0xf3);
DEFINE_GUID(Tree_Control_GUID,                                          0x7561349c, 0xd241, 0x43f4, 0x99, 0x08, 0xb5, 0xf0, 0x91, 0xbe, 0xe6, 0x11);
DEFINE_GUID(TreeItem_Control_GUID,                                      0x62c9feb9, 0x8ffc, 0x4878, 0xa3, 0xa4, 0x96, 0xb0, 0x30, 0x31, 0x5c, 0x18);
DEFINE_GUID(Custom_Control_GUID,                                        0xf29ea0c3, 0xadb7, 0x430a, 0xba, 0x90, 0xe5, 0x2c, 0x73, 0x13, 0xe6, 0xed);
DEFINE_GUID(Group_Control_GUID,                                         0xad50aa1c, 0xe8c8, 0x4774, 0xae, 0x1b, 0xdd, 0x86, 0xdf, 0x0b, 0x3b, 0xdc);
DEFINE_GUID(Thumb_Control_GUID,                                         0x701ca877, 0xe310, 0x4dd6, 0xb6, 0x44, 0x79, 0x7e, 0x4f, 0xae, 0xa2, 0x13);
DEFINE_GUID(DataGrid_Control_GUID,                                      0x84b783af, 0xd103, 0x4b0a, 0x84, 0x15, 0xe7, 0x39, 0x42, 0x41, 0x0f, 0x4b);
DEFINE_GUID(DataItem_Control_GUID,                                      0xa0177842, 0xd94f, 0x42a5, 0x81, 0x4b, 0x60, 0x68, 0xad, 0xdc, 0x8d, 0xa5);
DEFINE_GUID(Document_Control_GUID,                                      0x3cd6bb6f, 0x6f08, 0x4562, 0xb2, 0x29, 0xe4, 0xe2, 0xfc, 0x7a, 0x9e, 0xb4);
DEFINE_GUID(SplitButton_Control_GUID,                                   0x7011f01f, 0x4ace, 0x4901, 0xb4, 0x61, 0x92, 0x0a, 0x6f, 0x1c, 0xa6, 0x50);
DEFINE_GUID(Window_Control_GUID,                                        0xe13a7242, 0xf462, 0x4f4d, 0xae, 0xc1, 0x53, 0xb2, 0x8d, 0x6c, 0x32, 0x90);
DEFINE_GUID(Pane_Control_GUID,                                          0x5c2b3f5b, 0x9182, 0x42a3, 0x8d, 0xec, 0x8c, 0x04, 0xc1, 0xee, 0x63, 0x4d);
DEFINE_GUID(Header_Control_GUID,                                        0x5b90cbce, 0x78fb, 0x4614, 0x82, 0xb6, 0x55, 0x4d, 0x74, 0x71, 0x8e, 0x67);
DEFINE_GUID(HeaderItem_Control_GUID,                                    0xe6bc12cb, 0x7c8e, 0x49cf, 0xb1, 0x68, 0x4a, 0x93, 0xa3, 0x2b, 0xeb, 0xb0);
DEFINE_GUID(Table_Control_GUID,                                         0x773bfa0e, 0x5bc4, 0x4deb, 0x92, 0x1b, 0xde, 0x7b, 0x32, 0x06, 0x22, 0x9e);
DEFINE_GUID(TitleBar_Control_GUID,                                      0x98aa55bf, 0x3bb0, 0x4b65, 0x83, 0x6e, 0x2e, 0xa3, 0x0d, 0xbc, 0x17, 0x1f);
DEFINE_GUID(Separator_Control_GUID,                                     0x8767eba3, 0x2a63, 0x4ab0, 0xac, 0x8d, 0xaa, 0x50, 0xe2, 0x3d, 0xe9, 0x78);
DEFINE_GUID(Text_AnimationStyle_Attribute_GUID,                         0x628209f0, 0x7c9a, 0x4d57, 0xbe, 0x64, 0x1f, 0x18, 0x36, 0x57, 0x1f, 0xf5);
DEFINE_GUID(Text_BackgroundColor_Attribute_GUID,                        0xfdc49a07, 0x583d, 0x4f17, 0xad, 0x27, 0x77, 0xfc, 0x83, 0x2a, 0x3c, 0x0b);
DEFINE_GUID(Text_BulletStyle_Attribute_GUID,                            0xc1097c90, 0xd5c4, 0x4237, 0x97, 0x81, 0x3b, 0xec, 0x8b, 0xa5, 0x4e, 0x48);
DEFINE_GUID(Text_CapStyle_Attribute_GUID,                               0xfb059c50, 0x92cc, 0x49a5, 0xba, 0x8f, 0x0a, 0xa8, 0x72, 0xbb, 0xa2, 0xf3);
DEFINE_GUID(Text_Culture_Attribute_GUID,                                0xc2025af9, 0xa42d, 0x4ced, 0xa1, 0xfb, 0xc6, 0x74, 0x63, 0x15, 0x22, 0x2e);
DEFINE_GUID(Text_FontName_Attribute_GUID,                               0x64e63ba8, 0xf2e5, 0x476e, 0xa4, 0x77, 0x17, 0x34, 0xfe, 0xaa, 0xf7, 0x26);
DEFINE_GUID(Text_FontSize_Attribute_GUID,                               0xdc5eeeff, 0x0506, 0x4673, 0x93, 0xf2, 0x37, 0x7e, 0x4a, 0x8e, 0x01, 0xf1);
DEFINE_GUID(Text_FontWeight_Attribute_GUID,                             0x6fc02359, 0xb316, 0x4f5f, 0xb4, 0x01, 0xf1, 0xce, 0x55, 0x74, 0x18, 0x53);
DEFINE_GUID(Text_ForegroundColor_Attribute_GUID,                        0x72d1c95d, 0x5e60, 0x471a, 0x96, 0xb1, 0x6c, 0x1b, 0x3b, 0x77, 0xa4, 0x36);
DEFINE_GUID(Text_HorizontalTextAlignment_Attribute_GUID,                0x04ea6161, 0xfba3, 0x477a, 0x95, 0x2a, 0xbb, 0x32, 0x6d, 0x02, 0x6a, 0x5b);
DEFINE_GUID(Text_IndentationFirstLine_Attribute_GUID,                   0x206f9ad5, 0xc1d3, 0x424a, 0x81, 0x82, 0x6d, 0xa9, 0xa7, 0xf3, 0xd6, 0x32);
DEFINE_GUID(Text_IndentationLeading_Attribute_GUID,                     0x5cf66bac, 0x2d45, 0x4a4b, 0xb6, 0xc9, 0xf7, 0x22, 0x1d, 0x28, 0x15, 0xb0);
DEFINE_GUID(Text_IndentationTrailing_Attribute_GUID,                    0x97ff6c0f, 0x1ce4, 0x408a, 0xb6, 0x7b, 0x94, 0xd8, 0x3e, 0xb6, 0x9b, 0xf2);
DEFINE_GUID(Text_IsHidden_Attribute_GUID,                               0x360182fb, 0xbdd7, 0x47f6, 0xab, 0x69, 0x19, 0xe3, 0x3f, 0x8a, 0x33, 0x44);
DEFINE_GUID(Text_IsItalic_Attribute_GUID,                               0xfce12a56, 0x1336, 0x4a34, 0x96, 0x63, 0x1b, 0xab, 0x47, 0x23, 0x93, 0x20);
DEFINE_GUID(Text_IsReadOnly_Attribute_GUID,                             0xa738156b, 0xca3e, 0x495e, 0x95, 0x14, 0x83, 0x3c, 0x44, 0x0f, 0xeb, 0x11);
DEFINE_GUID(Text_IsSubscript_Attribute_GUID,                            0xf0ead858, 0x8f53, 0x413c, 0x87, 0x3f, 0x1a, 0x7d, 0x7f, 0x5e, 0x0d, 0xe4);
DEFINE_GUID(Text_IsSuperscript_Attribute_GUID,                          0xda706ee4, 0xb3aa, 0x4645, 0xa4, 0x1f, 0xcd, 0x25, 0x15, 0x7d, 0xea, 0x76);
DEFINE_GUID(Text_MarginBottom_Attribute_GUID,                           0x7ee593c4, 0x72b4, 0x4cac, 0x92, 0x71, 0x3e, 0xd2, 0x4b, 0x0e, 0x4d, 0x42);
DEFINE_GUID(Text_MarginLeading_Attribute_GUID,                          0x9e9242d0, 0x5ed0, 0x4900, 0x8e, 0x8a, 0xee, 0xcc, 0x03, 0x83, 0x5a, 0xfc);
DEFINE_GUID(Text_MarginTop_Attribute_GUID,                              0x683d936f, 0xc9b9, 0x4a9a, 0xb3, 0xd9, 0xd2, 0x0d, 0x33, 0x31, 0x1e, 0x2a);
DEFINE_GUID(Text_MarginTrailing_Attribute_GUID,                         0xaf522f98, 0x999d, 0x40af, 0xa5, 0xb2, 0x01, 0x69, 0xd0, 0x34, 0x20, 0x02);
DEFINE_GUID(Text_OutlineStyles_Attribute_GUID,                          0x5b675b27, 0xdb89, 0x46fe, 0x97, 0x0c, 0x61, 0x4d, 0x52, 0x3b, 0xb9, 0x7d);
DEFINE_GUID(Text_OverlineColor_Attribute_GUID,                          0x83ab383a, 0xfd43, 0x40da, 0xab, 0x3e, 0xec, 0xf8, 0x16, 0x5c, 0xbb, 0x6d);
DEFINE_GUID(Text_OverlineStyle_Attribute_GUID,                          0x0a234d66, 0x617e, 0x427f, 0x87, 0x1d, 0xe1, 0xff, 0x1e, 0x0c, 0x21, 0x3f);
DEFINE_GUID(Text_StrikethroughColor_Attribute_GUID,                     0xbfe15a18, 0x8c41, 0x4c5a, 0x9a, 0x0b, 0x04, 0xaf, 0x0e, 0x07, 0xf4, 0x87);
DEFINE_GUID(Text_StrikethroughStyle_Attribute_GUID,                     0x72913ef1, 0xda00, 0x4f01, 0x89, 0x9c, 0xac, 0x5a, 0x85, 0x77, 0xa3, 0x07);
DEFINE_GUID(Text_Tabs_Attribute_GUID,                                   0x2e68d00b, 0x92fe, 0x42d8, 0x89, 0x9a, 0xa7, 0x84, 0xaa, 0x44, 0x54, 0xa1);
DEFINE_GUID(Text_TextFlowDirections_Attribute_GUID,                     0x8bdf8739, 0xf420, 0x423e, 0xaf, 0x77, 0x20, 0xa5, 0xd9, 0x73, 0xa9, 0x07);
DEFINE_GUID(Text_UnderlineColor_Attribute_GUID,                         0xbfa12c73, 0xfde2, 0x4473, 0xbf, 0x64, 0x10, 0x36, 0xd6, 0xaa, 0x0f, 0x45);
DEFINE_GUID(Text_UnderlineStyle_Attribute_GUID,                         0x5f3b21c0, 0xede4, 0x44bd, 0x9c, 0x36, 0x38, 0x53, 0x03, 0x8c, 0xbf, 0xeb);

DEFINE_GUID(SID_IsUIAutomationObject,                                   0xb96fdb85, 0x7204, 0x4724, 0x84, 0x2b, 0xc7, 0x05, 0x9d, 0xed, 0xb9, 0xd0);

// --------------------------------------------------------------------------
//
// Error handling
//
// --------------------------------------------------------------------------

BOOL WINAPI UiaGetErrorDescription(BSTR * pDescription);

// --------------------------------------------------------------------------
//
// Conditions
//
// --------------------------------------------------------------------------

enum ConditionType
{
    ConditionType_True = 0,
    ConditionType_False = 1,
    ConditionType_Property = 2,
    ConditionType_And = 3,
    ConditionType_Or = 4,
    ConditionType_Not = 5,
};

struct UiaCondition
{
    ConditionType ConditionType;
};

enum PropertyConditionFlags
{
    PropertyConditionFlags_None = 0x00,
    PropertyConditionFlags_IgnoreCase = 0x01,
};

struct UiaPropertyCondition
{
    ConditionType ConditionType;
    PROPERTYID PropertyId;
    VARIANT Value;
    PropertyConditionFlags Flags;
};

struct UiaAndOrCondition
{
    ConditionType ConditionType;
    UiaCondition ** ppConditions; // ptr to array-of-ptrs to conditions
    int cConditions;
};

struct UiaNotCondition
{
    ConditionType ConditionType;
    UiaCondition * pCondition;
};


// --------------------------------------------------------------------------
//
// Cache request/response
//
// --------------------------------------------------------------------------

enum AutomationElementMode
{
    AutomationElementMode_None,
    AutomationElementMode_Full
};

struct UiaCacheRequest
{
    UiaCondition *  pViewCondition;
    TreeScope       Scope;

    PROPERTYID *    pProperties;
    int             cProperties;
    PATTERNID *     pPatterns;
    int             cPatterns;
    AutomationElementMode automationElementMode;
};

HRESULT WINAPI UiaHUiaNodeFromVariant(VARIANT * pvar, HUIANODE *phnode);
HRESULT WINAPI UiaHPatternObjectFromVariant(VARIANT * pvar, HUIAPATTERNOBJECT *phobj);
HRESULT WINAPI UiaHTextRangeFromVariant(VARIANT * pvar, HUIATEXTRANGE *phtextrange);

// --------------------------------------------------------------------------
//
// UiaNode methods
//
// --------------------------------------------------------------------------

// Used by UiaGetUpdatedCache
enum NormalizeState
{
    NormalizeState_None,    // Don't normalize
    NormalizeState_View,    // Normalize against condition in UiaCacheRequest
    NormalizeState_Custom   // Normalize against supplied condition
};

struct UiaFindParams
{
    int MaxDepth;
    BOOL FindFirst;
    BOOL ExcludeRoot;
    UiaCondition * pFindCondition;
};

BOOL WINAPI UiaNodeRelease(HUIANODE hnode);

HRESULT WINAPI UiaGetPropertyValue(HUIANODE hnode, PROPERTYID propertyId, VARIANT * pValue);
HRESULT WINAPI UiaGetPatternProvider(HUIANODE hnode, PATTERNID patternId, HUIAPATTERNOBJECT * phobj);
HRESULT WINAPI UiaGetRuntimeId(HUIANODE hnode, SAFEARRAY ** pruntimeId);
HRESULT WINAPI UiaSetFocus(HUIANODE hnode);
HRESULT WINAPI UiaNavigate(HUIANODE hnode, NavigateDirection direction, UiaCondition * pCondition, UiaCacheRequest * pRequest, SAFEARRAY ** ppRequestedData, BSTR * ppTreeStructure);
HRESULT WINAPI UiaGetUpdatedCache(HUIANODE hnode, UiaCacheRequest * pRequest, NormalizeState normalizeState, UiaCondition * pNormalizeCondition, SAFEARRAY ** ppRequestedData, BSTR * ppTreeStructure);
HRESULT WINAPI UiaFind(HUIANODE hnode, UiaFindParams * pParams, UiaCacheRequest * pRequest, SAFEARRAY ** ppRequestedData, SAFEARRAY ** ppOffsets, SAFEARRAY ** ppTreeStructures);

HRESULT WINAPI UiaNodeFromPoint(double x, double y, UiaCacheRequest * pRequest, SAFEARRAY ** ppRequestedData, BSTR * ppTreeStructure);
HRESULT WINAPI UiaNodeFromFocus(UiaCacheRequest * pRequest, SAFEARRAY ** ppRequestedData, BSTR * ppTreeStructure);
HRESULT WINAPI UiaNodeFromHandle(HWND hwnd, HUIANODE * phnode);
HRESULT WINAPI UiaNodeFromProvider(IRawElementProviderSimple * pProvider, HUIANODE * phnode);
HRESULT WINAPI UiaGetRootNode(HUIANODE * phnode);


#ifdef __cplusplus
inline void UiaRectSetEmpty(UiaRect & rc)
{
    rc.left = 0;
    rc.top = 0;
    rc.width = 0;
    rc.height = 0;
}

inline bool UiaRectIsEmpty(const UiaRect & rc)
{
    return rc.width <= 0 || rc.height <= 0;
}
#endif

// --------------------------------------------------------------------------
//
// Client-side provider support
//
// --------------------------------------------------------------------------

enum ProviderType
{
    ProviderType_BaseHwnd,
    ProviderType_Proxy,
    ProviderType_NonClientArea,
};

typedef SAFEARRAY * WINAPI UiaProviderCallback(HWND hwnd, ProviderType providerType);

void WINAPI UiaRegisterProviderCallback(UiaProviderCallback * pCallback);


// --------------------------------------------------------------------------
//
// Identifier mapping
//
// --------------------------------------------------------------------------

enum AutomationIdentifierType
{
    AutomationIdentifierType_Property,
    AutomationIdentifierType_Pattern,
    AutomationIdentifierType_Event,
    AutomationIdentifierType_ControlType,
    AutomationIdentifierType_TextAttribute
};

int WINAPI UiaLookupId(AutomationIdentifierType type, const GUID* pGuid);

HRESULT WINAPI UiaGetReservedNotSupportedValue(IUnknown **punkNotSupportedValue);
HRESULT WINAPI UiaGetReservedMixedAttributeValue(IUnknown **punkMixedAttributeValue);

// --------------------------------------------------------------------------
//
// Event methods
//
// --------------------------------------------------------------------------

//
// Event structs and enums
//

enum EventArgsType
{
    EventArgsType_Simple,
    EventArgsType_PropertyChanged,
    EventArgsType_StructureChanged,
    EventArgsType_AsyncContentLoaded,
    EventArgsType_WindowClosed,
};

enum StructureChangeType
{
    StructureChangeType_ChildAdded,
    StructureChangeType_ChildRemoved,
    StructureChangeType_ChildrenInvalidated,
    StructureChangeType_ChildrenBulkAdded,
    StructureChangeType_ChildrenBulkRemoved,
    StructureChangeType_ChildrenReordered,
};

enum AsyncContentLoadedState
{
    AsyncContentLoadedState_Beginning,
    AsyncContentLoadedState_Progress,
    AsyncContentLoadedState_Completed
};

struct UiaEventArgs
{
    EventArgsType Type;
    int EventId;
};

struct UiaPropertyChangedEventArgs
{
    EventArgsType Type;
    int EventId;
    PROPERTYID PropertyId;
    VARIANT OldValue;
    VARIANT NewValue;
};

struct UiaStructureChangedEventArgs
{
    EventArgsType Type;
    int EventId;
    StructureChangeType StructureChangeType;
    int * pRuntimeId;
    int cRuntimeIdLen;
};

struct UiaAsyncContentLoadedEventArgs
{
    EventArgsType Type;
    int EventId;
    AsyncContentLoadedState AsyncContentLoadedState;
    double PercentComplete;
};

struct UiaWindowClosedEventArgs
{
    EventArgsType Type;
    int EventId;
    int * pRuntimeId;
    int cRuntimeIdLen;
};

//
// Provider Event APIs
//
BOOL WINAPI UiaClientsAreListening();
HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple * pProvider, PROPERTYID id, VARIANT oldValue, VARIANT newValue);
HRESULT WINAPI UiaRaiseAutomationEvent(IRawElementProviderSimple * pProvider, EVENTID id);
HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple * pProvider, StructureChangeType structureChangeType, int * pRuntimeId, int cRuntimeIdLen);
HRESULT WINAPI UiaRaiseAsyncContentLoadedEvent(IRawElementProviderSimple * pProvider, AsyncContentLoadedState asyncContentLoadedState, double percentComplete);

//
// Client Event APIs
//
typedef void WINAPI UiaEventCallback(UiaEventArgs * pArgs, SAFEARRAY * pRequestedData, BSTR pTreeStructure);
HRESULT WINAPI UiaAddEvent(HUIANODE hnode, EVENTID eventId, UiaEventCallback * pCallback, TreeScope scope, PROPERTYID * pProperties, int cProperties, UiaCacheRequest * pRequest, HUIAEVENT * phEvent);
HRESULT WINAPI UiaRemoveEvent(HUIAEVENT hEvent);
HRESULT WINAPI UiaEventAddWindow(HUIAEVENT hEvent, HWND hwnd);
HRESULT WINAPI UiaEventRemoveWindow(HUIAEVENT hEvent, HWND hwnd);


// --------------------------------------------------------------------------
//
// Pattern methods
//
// --------------------------------------------------------------------------

HRESULT WINAPI DockPattern_SetDockPosition(HUIAPATTERNOBJECT hobj, DockPosition dockPosition);
HRESULT WINAPI ExpandCollapsePattern_Collapse(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI ExpandCollapsePattern_Expand(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI GridPattern_GetItem(HUIAPATTERNOBJECT hobj, int row, int column, HUIANODE * pResult);
HRESULT WINAPI InvokePattern_Invoke(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI MultipleViewPattern_GetViewName(HUIAPATTERNOBJECT hobj, int viewId, BSTR * ppStr);
HRESULT WINAPI MultipleViewPattern_SetCurrentView(HUIAPATTERNOBJECT hobj, int viewId);
HRESULT WINAPI RangeValuePattern_SetValue(HUIAPATTERNOBJECT hobj, double val);
HRESULT WINAPI ScrollItemPattern_ScrollIntoView(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI ScrollPattern_Scroll(HUIAPATTERNOBJECT hobj, ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
HRESULT WINAPI ScrollPattern_SetScrollPercent(HUIAPATTERNOBJECT hobj, double horizontalPercent, double verticalPercent);
HRESULT WINAPI SelectionItemPattern_AddToSelection(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI SelectionItemPattern_RemoveFromSelection(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI SelectionItemPattern_Select(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI TogglePattern_Toggle(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI TransformPattern_Move(HUIAPATTERNOBJECT hobj, double x, double y);
HRESULT WINAPI TransformPattern_Resize(HUIAPATTERNOBJECT hobj, double width, double height);
HRESULT WINAPI TransformPattern_Rotate(HUIAPATTERNOBJECT hobj, double degrees);
HRESULT WINAPI ValuePattern_SetValue(HUIAPATTERNOBJECT hobj, LPCWSTR pVal);
HRESULT WINAPI WindowPattern_Close(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI WindowPattern_SetWindowVisualState(HUIAPATTERNOBJECT hobj, WindowVisualState state);
HRESULT WINAPI WindowPattern_WaitForInputIdle(HUIAPATTERNOBJECT hobj, int milliseconds, BOOL * pResult);

HRESULT WINAPI TextPattern_GetSelection(HUIAPATTERNOBJECT hobj, SAFEARRAY** pRetVal);
HRESULT WINAPI TextPattern_GetVisibleRanges(HUIAPATTERNOBJECT hobj, SAFEARRAY** pRetVal);
HRESULT WINAPI TextPattern_RangeFromChild(HUIAPATTERNOBJECT hobj, HUIANODE hnodeChild, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextPattern_RangeFromPoint(HUIAPATTERNOBJECT hobj, UiaPoint point, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextPattern_get_DocumentRange(HUIAPATTERNOBJECT hobj, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextPattern_get_SupportedTextSelection(HUIAPATTERNOBJECT hobj, SupportedTextSelection* pRetVal);
HRESULT WINAPI TextRange_Clone(HUIATEXTRANGE hobj, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextRange_Compare(HUIATEXTRANGE hobj, HUIATEXTRANGE range, BOOL* pRetVal);
HRESULT WINAPI TextRange_CompareEndpoints(HUIATEXTRANGE hobj, TextPatternRangeEndpoint endpoint, HUIATEXTRANGE targetRange, TextPatternRangeEndpoint targetEndpoint, int* pRetVal);
HRESULT WINAPI TextRange_ExpandToEnclosingUnit(HUIATEXTRANGE hobj, TextUnit unit);
HRESULT WINAPI TextRange_GetAttributeValue(HUIATEXTRANGE hobj, TEXTATTRIBUTEID attributeId, VARIANT * pRetVal);
HRESULT WINAPI TextRange_FindAttribute(HUIATEXTRANGE hobj, TEXTATTRIBUTEID attributeId, VARIANT val, BOOL backward, HUIATEXTRANGE * pRetVal);
HRESULT WINAPI TextRange_FindText(HUIATEXTRANGE hobj, BSTR text, BOOL backward, BOOL ignoreCase, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextRange_GetBoundingRectangles(HUIATEXTRANGE hobj, SAFEARRAY** pRetVal);
HRESULT WINAPI TextRange_GetEnclosingElement(HUIATEXTRANGE hobj, HUIANODE* pRetVal);
HRESULT WINAPI TextRange_GetText(HUIATEXTRANGE hobj, int maxLength, BSTR* pRetVal);
HRESULT WINAPI TextRange_Move(HUIATEXTRANGE hobj, TextUnit unit, int count, int* pRetVal);
HRESULT WINAPI TextRange_MoveEndpointByUnit(HUIATEXTRANGE hobj, TextPatternRangeEndpoint endpoint, TextUnit unit, int count, int* pRetVal);
HRESULT WINAPI TextRange_MoveEndpointByRange(HUIATEXTRANGE hobj, TextPatternRangeEndpoint endpoint, HUIATEXTRANGE targetRange, TextPatternRangeEndpoint targetEndpoint);
HRESULT WINAPI TextRange_Select(HUIATEXTRANGE hobj);
HRESULT WINAPI TextRange_AddToSelection(HUIATEXTRANGE hobj);
HRESULT WINAPI TextRange_RemoveFromSelection(HUIATEXTRANGE hobj);
HRESULT WINAPI TextRange_ScrollIntoView(HUIATEXTRANGE hobj, BOOL alignToTop);
HRESULT WINAPI TextRange_GetChildren(HUIATEXTRANGE hobj, SAFEARRAY** pRetVal);

BOOL WINAPI UiaPatternRelease(HUIAPATTERNOBJECT hobj);
BOOL WINAPI UiaTextRangeRelease(HUIATEXTRANGE hobj);


// --------------------------------------------------------------------------
//
// Provider methods
// 
// --------------------------------------------------------------------------

LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple * el);
HRESULT WINAPI UiaHostProviderFromHwnd(HWND hwnd, IRawElementProviderSimple ** pProvider);

// --------------------------------------------------------------------------
//
// Other APIs...
//
// --------------------------------------------------------------------------

BOOL WINAPI UiaHasServerSideProvider(HWND hwnd);

#ifdef __cplusplus
}
#endif


#endif // !_INC_UIAUTOMATIONCOREAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\udpmib.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    udpmib.h

Abstract:

    This module contains the public definitions and structures for the
    UDP-specific parts of MIB-II.  These definitions were previously
    in iprtrmib.h, which now includes this file.

Environment:

    user mode or kernel mode

--*/

#ifndef _UDPMIB_
#define _UDPMIB_
#pragma once

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

#define TCPIP_OWNING_MODULE_SIZE 16

typedef struct _MIB_UDPROW {
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
} MIB_UDPROW, *PMIB_UDPROW;

typedef struct _MIB_UDPTABLE {
    DWORD dwNumEntries;
    MIB_UDPROW table[ANY_SIZE];
} MIB_UDPTABLE, *PMIB_UDPTABLE;

#define SIZEOF_UDPTABLE(X) (FIELD_OFFSET(MIB_UDPTABLE, table[0]) + \
						    ((X) * sizeof(MIB_UDPROW)) + ALIGN_SIZE)

typedef struct _MIB_UDPROW_OWNER_PID {
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
    DWORD dwOwningPid;
} MIB_UDPROW_OWNER_PID, *PMIB_UDPROW_OWNER_PID;

typedef struct _MIB_UDPTABLE_OWNER_PID
{
    DWORD                   dwNumEntries;
    MIB_UDPROW_OWNER_PID    table[ANY_SIZE];
} MIB_UDPTABLE_OWNER_PID, *PMIB_UDPTABLE_OWNER_PID;

#define SIZEOF_UDPTABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_UDPTABLE_OWNER_PID, table[0]) + \
									  ((X) * sizeof(MIB_UDPROW_OWNER_PID)) + ALIGN_SIZE)

typedef struct _MIB_UDPROW_OWNER_MODULE {
    DWORD           dwLocalAddr;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
    LARGE_INTEGER   liCreateTimestamp;
    union {
        struct {
            int     SpecificPortBind : 1;
        };
        int         dwFlags;
    };
    ULONGLONG       OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_UDPROW_OWNER_MODULE, *PMIB_UDPROW_OWNER_MODULE;

typedef struct _MIB_UDPTABLE_OWNER_MODULE
{
    DWORD                   dwNumEntries;
    MIB_UDPROW_OWNER_MODULE table[ANY_SIZE];
} MIB_UDPTABLE_OWNER_MODULE, *PMIB_UDPTABLE_OWNER_MODULE;

#define SIZEOF_UDPTABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_UDPTABLE_OWNER_MODULE, table[0]) + \
										 ((X) * sizeof(MIB_UDPROW_OWNER_MODULE)) + ALIGN_SIZE)

#ifdef _WS2IPDEF_
//
// The following definitions require Winsock2.
//

typedef struct _MIB_UDP6ROW {
    IN6_ADDR dwLocalAddr;
    DWORD dwLocalScopeId;
    DWORD dwLocalPort;
} MIB_UDP6ROW, *PMIB_UDP6ROW;

typedef struct _MIB_UDP6TABLE {
    DWORD dwNumEntries;
    MIB_UDP6ROW table[ANY_SIZE];
} MIB_UDP6TABLE, *PMIB_UDP6TABLE;

#define SIZEOF_UDP6TABLE(X) (FIELD_OFFSET(MIB_UDP6TABLE, table[0]) + \
							 ((X) * sizeof(MIB_UDP6ROW)) + ALIGN_SIZE)

typedef struct _MIB_UDP6ROW_OWNER_PID {
    UCHAR           ucLocalAddr[16];
    DWORD           dwLocalScopeId;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
} MIB_UDP6ROW_OWNER_PID, *PMIB_UDP6ROW_OWNER_PID;

typedef struct _MIB_UDP6TABLE_OWNER_PID
{
    DWORD                   dwNumEntries;
    MIB_UDP6ROW_OWNER_PID   table[ANY_SIZE];
} MIB_UDP6TABLE_OWNER_PID, *PMIB_UDP6TABLE_OWNER_PID;

#define SIZEOF_UDP6TABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_UDP6TABLE_OWNER_PID, table[0]) + \
									   ((X) * sizeof(MIB_UDP6ROW_OWNER_PID)) + ALIGN_SIZE)

typedef struct _MIB_UDP6ROW_OWNER_MODULE {
    UCHAR           ucLocalAddr[16];
    DWORD           dwLocalScopeId;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
    LARGE_INTEGER   liCreateTimestamp;
    union {
        struct {
            int     SpecificPortBind : 1;
        };
        int         dwFlags;
    };
    ULONGLONG       OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_UDP6ROW_OWNER_MODULE, *PMIB_UDP6ROW_OWNER_MODULE;

typedef struct _MIB_UDP6TABLE_OWNER_MODULE
{
    DWORD                    dwNumEntries;
    MIB_UDP6ROW_OWNER_MODULE table[ANY_SIZE];
} MIB_UDP6TABLE_OWNER_MODULE, *PMIB_UDP6TABLE_OWNER_MODULE;

#define SIZEOF_UDP6TABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_UDP6TABLE_OWNER_MODULE, table[0]) + \
										  ((X) * sizeof(MIB_UDP6ROW_OWNER_MODULE)) + ALIGN_SIZE)

#endif // _WS2IPDEF_

typedef struct _MIB_UDPSTATS {
    DWORD dwInDatagrams;
    DWORD dwNoPorts;
    DWORD dwInErrors;
    DWORD dwOutDatagrams;
    DWORD dwNumAddrs;
} MIB_UDPSTATS,*PMIB_UDPSTATS;

#endif // _UDPMIB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\umbus.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for umbus.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __umbus_h__
#define __umbus_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUMBusDriver_FWD_DEFINED__
#define __IUMBusDriver_FWD_DEFINED__
typedef interface IUMBusDriver IUMBusDriver;
#endif 	/* __IUMBusDriver_FWD_DEFINED__ */


#ifndef __IUMBusPDO_FWD_DEFINED__
#define __IUMBusPDO_FWD_DEFINED__
typedef interface IUMBusPDO IUMBusPDO;
#endif 	/* __IUMBusPDO_FWD_DEFINED__ */


#ifndef __IUMBusPDODetails_FWD_DEFINED__
#define __IUMBusPDODetails_FWD_DEFINED__
typedef interface IUMBusPDODetails IUMBusPDODetails;
#endif 	/* __IUMBusPDODetails_FWD_DEFINED__ */


#ifndef __UMBusDriver_FWD_DEFINED__
#define __UMBusDriver_FWD_DEFINED__

#ifdef __cplusplus
typedef class UMBusDriver UMBusDriver;
#else
typedef struct UMBusDriver UMBusDriver;
#endif /* __cplusplus */

#endif 	/* __UMBusDriver_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propsys.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_umbus_0000_0000 */
/* [local] */ 




enum AddChildFlags
    {	UMBUS_CREATEBUSCHILD	= ( 1 << 0 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_umbus_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_umbus_0000_0000_v0_0_s_ifspec;

#ifndef __IUMBusDriver_INTERFACE_DEFINED__
#define __IUMBusDriver_INTERFACE_DEFINED__

/* interface IUMBusDriver */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IUMBusDriver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("712f2e95-9b00-4c34-b049-bd3c9c1402cc")
    IUMBusDriver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindEnumByIdentity( 
            /* [in] */ __RPC__in WCHAR *identity,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddBusEnumerator( 
            /* [in] */ __RPC__in WCHAR *identity,
            /* [in] */ __RPC__in_opt IPropertyStore *pPersistentPropStore,
            /* [in] */ __RPC__in_opt IPropertyStore *pDynamicPropStore,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveBusEnumerator( 
            /* [in] */ __RPC__in_opt IUMBusPDO *ppBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteBusEnumerator( 
            /* [in] */ __RPC__in_opt IUMBusPDO *ppBusPDO) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUMBusDriverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUMBusDriver * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUMBusDriver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUMBusDriver * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IUMBusDriver * This,
            /* [retval][out] */ __RPC__out DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IUMBusDriver * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *FindEnumByIdentity )( 
            IUMBusDriver * This,
            /* [in] */ __RPC__in WCHAR *identity,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *AddBusEnumerator )( 
            IUMBusDriver * This,
            /* [in] */ __RPC__in WCHAR *identity,
            /* [in] */ __RPC__in_opt IPropertyStore *pPersistentPropStore,
            /* [in] */ __RPC__in_opt IPropertyStore *pDynamicPropStore,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveBusEnumerator )( 
            IUMBusDriver * This,
            /* [in] */ __RPC__in_opt IUMBusPDO *ppBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteBusEnumerator )( 
            IUMBusDriver * This,
            /* [in] */ __RPC__in_opt IUMBusPDO *ppBusPDO);
        
        END_INTERFACE
    } IUMBusDriverVtbl;

    interface IUMBusDriver
    {
        CONST_VTBL struct IUMBusDriverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUMBusDriver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUMBusDriver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUMBusDriver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUMBusDriver_GetCount(This,pCount)	\
    ( (This)->lpVtbl -> GetCount(This,pCount) ) 

#define IUMBusDriver_Item(This,index,ppBusPDO)	\
    ( (This)->lpVtbl -> Item(This,index,ppBusPDO) ) 

#define IUMBusDriver_FindEnumByIdentity(This,identity,ppBusPDO)	\
    ( (This)->lpVtbl -> FindEnumByIdentity(This,identity,ppBusPDO) ) 

#define IUMBusDriver_AddBusEnumerator(This,identity,pPersistentPropStore,pDynamicPropStore,ppBusPDO)	\
    ( (This)->lpVtbl -> AddBusEnumerator(This,identity,pPersistentPropStore,pDynamicPropStore,ppBusPDO) ) 

#define IUMBusDriver_RemoveBusEnumerator(This,ppBusPDO)	\
    ( (This)->lpVtbl -> RemoveBusEnumerator(This,ppBusPDO) ) 

#define IUMBusDriver_DeleteBusEnumerator(This,ppBusPDO)	\
    ( (This)->lpVtbl -> DeleteBusEnumerator(This,ppBusPDO) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUMBusDriver_INTERFACE_DEFINED__ */


#ifndef __IUMBusPDO_INTERFACE_DEFINED__
#define __IUMBusPDO_INTERFACE_DEFINED__

/* interface IUMBusPDO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IUMBusPDO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0c06d7f-1f31-4ca9-87f9-c62600f2ca5f")
    IUMBusPDO : public IPropertyStore
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChildCount( 
            /* [retval][out] */ __RPC__out DWORD *pNumBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindChildByIdentity( 
            /* [in] */ __RPC__in WCHAR *identity,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddChild( 
            /* [in] */ __RPC__in WCHAR *identity,
            /* [in] */ __RPC__in_opt IPropertyStore *pPersistentPropStore,
            /* [in] */ __RPC__in_opt IPropertyStore *pDynamicPropStore,
            /* [in] */ ULONG CreateOptions,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveChild( 
            /* [in] */ __RPC__in_opt IUMBusPDO *pBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteChild( 
            /* [in] */ __RPC__in_opt IUMBusPDO *pBusPDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDynamicPropertyStore( 
            /* [retval][out] */ __RPC__deref_out_opt IPropertyStore **ppPropertyStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUMBusPDOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUMBusPDO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUMBusPDO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUMBusPDO * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IUMBusPDO * This,
            /* [out] */ __RPC__out DWORD *cProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IUMBusPDO * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IUMBusPDO * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IUMBusPDO * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IUMBusPDO * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildCount )( 
            IUMBusPDO * This,
            /* [retval][out] */ __RPC__out DWORD *pNumBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IUMBusPDO * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *FindChildByIdentity )( 
            IUMBusPDO * This,
            /* [in] */ __RPC__in WCHAR *identity,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *AddChild )( 
            IUMBusPDO * This,
            /* [in] */ __RPC__in WCHAR *identity,
            /* [in] */ __RPC__in_opt IPropertyStore *pPersistentPropStore,
            /* [in] */ __RPC__in_opt IPropertyStore *pDynamicPropStore,
            /* [in] */ ULONG CreateOptions,
            /* [retval][out] */ __RPC__deref_out_opt IUMBusPDO **ppBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveChild )( 
            IUMBusPDO * This,
            /* [in] */ __RPC__in_opt IUMBusPDO *pBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteChild )( 
            IUMBusPDO * This,
            /* [in] */ __RPC__in_opt IUMBusPDO *pBusPDO);
        
        HRESULT ( STDMETHODCALLTYPE *GetDynamicPropertyStore )( 
            IUMBusPDO * This,
            /* [retval][out] */ __RPC__deref_out_opt IPropertyStore **ppPropertyStore);
        
        END_INTERFACE
    } IUMBusPDOVtbl;

    interface IUMBusPDO
    {
        CONST_VTBL struct IUMBusPDOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUMBusPDO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUMBusPDO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUMBusPDO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUMBusPDO_GetCount(This,cProps)	\
    ( (This)->lpVtbl -> GetCount(This,cProps) ) 

#define IUMBusPDO_GetAt(This,iProp,pkey)	\
    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 

#define IUMBusPDO_GetValue(This,key,pv)	\
    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 

#define IUMBusPDO_SetValue(This,key,propvar)	\
    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 

#define IUMBusPDO_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 


#define IUMBusPDO_GetChildCount(This,pNumBusPDO)	\
    ( (This)->lpVtbl -> GetChildCount(This,pNumBusPDO) ) 

#define IUMBusPDO_Item(This,index,ppBusPDO)	\
    ( (This)->lpVtbl -> Item(This,index,ppBusPDO) ) 

#define IUMBusPDO_FindChildByIdentity(This,identity,ppBusPDO)	\
    ( (This)->lpVtbl -> FindChildByIdentity(This,identity,ppBusPDO) ) 

#define IUMBusPDO_AddChild(This,identity,pPersistentPropStore,pDynamicPropStore,CreateOptions,ppBusPDO)	\
    ( (This)->lpVtbl -> AddChild(This,identity,pPersistentPropStore,pDynamicPropStore,CreateOptions,ppBusPDO) ) 

#define IUMBusPDO_RemoveChild(This,pBusPDO)	\
    ( (This)->lpVtbl -> RemoveChild(This,pBusPDO) ) 

#define IUMBusPDO_DeleteChild(This,pBusPDO)	\
    ( (This)->lpVtbl -> DeleteChild(This,pBusPDO) ) 

#define IUMBusPDO_GetDynamicPropertyStore(This,ppPropertyStore)	\
    ( (This)->lpVtbl -> GetDynamicPropertyStore(This,ppPropertyStore) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUMBusPDO_INTERFACE_DEFINED__ */


#ifndef __IUMBusPDODetails_INTERFACE_DEFINED__
#define __IUMBusPDODetails_INTERFACE_DEFINED__

/* interface IUMBusPDODetails */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IUMBusPDODetails;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("26B40765-59C6-463c-90FE-130176A1F917")
    IUMBusPDODetails : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDevicePath( 
            /* [in] */ __RPC__in LPCWSTR pszDevicePath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUMBusPDODetailsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUMBusPDODetails * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUMBusPDODetails * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUMBusPDODetails * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDevicePath )( 
            IUMBusPDODetails * This,
            /* [in] */ __RPC__in LPCWSTR pszDevicePath);
        
        END_INTERFACE
    } IUMBusPDODetailsVtbl;

    interface IUMBusPDODetails
    {
        CONST_VTBL struct IUMBusPDODetailsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUMBusPDODetails_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUMBusPDODetails_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUMBusPDODetails_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUMBusPDODetails_SetDevicePath(This,pszDevicePath)	\
    ( (This)->lpVtbl -> SetDevicePath(This,pszDevicePath) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUMBusPDODetails_INTERFACE_DEFINED__ */



#ifndef __UMBusLib_LIBRARY_DEFINED__
#define __UMBusLib_LIBRARY_DEFINED__

/* library UMBusLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_UMBusLib;

EXTERN_C const CLSID CLSID_UMBusDriver;

#ifdef __cplusplus

class DECLSPEC_UUID("9197e04d-2b9f-4849-8bf7-75294eb5c043")
UMBusDriver;
#endif
#endif /* __UMBusLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\UIAutomationCore.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for uiautomationcore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __uiautomationcore_h__
#define __uiautomationcore_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRawElementProviderSimple_FWD_DEFINED__
#define __IRawElementProviderSimple_FWD_DEFINED__
typedef interface IRawElementProviderSimple IRawElementProviderSimple;
#endif 	/* __IRawElementProviderSimple_FWD_DEFINED__ */


#ifndef __IRawElementProviderFragmentRoot_FWD_DEFINED__
#define __IRawElementProviderFragmentRoot_FWD_DEFINED__
typedef interface IRawElementProviderFragmentRoot IRawElementProviderFragmentRoot;
#endif 	/* __IRawElementProviderFragmentRoot_FWD_DEFINED__ */


#ifndef __IRawElementProviderFragment_FWD_DEFINED__
#define __IRawElementProviderFragment_FWD_DEFINED__
typedef interface IRawElementProviderFragment IRawElementProviderFragment;
#endif 	/* __IRawElementProviderFragment_FWD_DEFINED__ */


#ifndef __IRawElementProviderAdviseEvents_FWD_DEFINED__
#define __IRawElementProviderAdviseEvents_FWD_DEFINED__
typedef interface IRawElementProviderAdviseEvents IRawElementProviderAdviseEvents;
#endif 	/* __IRawElementProviderAdviseEvents_FWD_DEFINED__ */


#ifndef __IRawElementProviderHwndOverride_FWD_DEFINED__
#define __IRawElementProviderHwndOverride_FWD_DEFINED__
typedef interface IRawElementProviderHwndOverride IRawElementProviderHwndOverride;
#endif 	/* __IRawElementProviderHwndOverride_FWD_DEFINED__ */


#ifndef __IDockProvider_FWD_DEFINED__
#define __IDockProvider_FWD_DEFINED__
typedef interface IDockProvider IDockProvider;
#endif 	/* __IDockProvider_FWD_DEFINED__ */


#ifndef __IExpandCollapseProvider_FWD_DEFINED__
#define __IExpandCollapseProvider_FWD_DEFINED__
typedef interface IExpandCollapseProvider IExpandCollapseProvider;
#endif 	/* __IExpandCollapseProvider_FWD_DEFINED__ */


#ifndef __IGridProvider_FWD_DEFINED__
#define __IGridProvider_FWD_DEFINED__
typedef interface IGridProvider IGridProvider;
#endif 	/* __IGridProvider_FWD_DEFINED__ */


#ifndef __IGridItemProvider_FWD_DEFINED__
#define __IGridItemProvider_FWD_DEFINED__
typedef interface IGridItemProvider IGridItemProvider;
#endif 	/* __IGridItemProvider_FWD_DEFINED__ */


#ifndef __IInvokeProvider_FWD_DEFINED__
#define __IInvokeProvider_FWD_DEFINED__
typedef interface IInvokeProvider IInvokeProvider;
#endif 	/* __IInvokeProvider_FWD_DEFINED__ */


#ifndef __IMultipleViewProvider_FWD_DEFINED__
#define __IMultipleViewProvider_FWD_DEFINED__
typedef interface IMultipleViewProvider IMultipleViewProvider;
#endif 	/* __IMultipleViewProvider_FWD_DEFINED__ */


#ifndef __IRangeValueProvider_FWD_DEFINED__
#define __IRangeValueProvider_FWD_DEFINED__
typedef interface IRangeValueProvider IRangeValueProvider;
#endif 	/* __IRangeValueProvider_FWD_DEFINED__ */


#ifndef __IScrollItemProvider_FWD_DEFINED__
#define __IScrollItemProvider_FWD_DEFINED__
typedef interface IScrollItemProvider IScrollItemProvider;
#endif 	/* __IScrollItemProvider_FWD_DEFINED__ */


#ifndef __ISelectionProvider_FWD_DEFINED__
#define __ISelectionProvider_FWD_DEFINED__
typedef interface ISelectionProvider ISelectionProvider;
#endif 	/* __ISelectionProvider_FWD_DEFINED__ */


#ifndef __IScrollProvider_FWD_DEFINED__
#define __IScrollProvider_FWD_DEFINED__
typedef interface IScrollProvider IScrollProvider;
#endif 	/* __IScrollProvider_FWD_DEFINED__ */


#ifndef __ISelectionItemProvider_FWD_DEFINED__
#define __ISelectionItemProvider_FWD_DEFINED__
typedef interface ISelectionItemProvider ISelectionItemProvider;
#endif 	/* __ISelectionItemProvider_FWD_DEFINED__ */


#ifndef __ITableProvider_FWD_DEFINED__
#define __ITableProvider_FWD_DEFINED__
typedef interface ITableProvider ITableProvider;
#endif 	/* __ITableProvider_FWD_DEFINED__ */


#ifndef __ITableItemProvider_FWD_DEFINED__
#define __ITableItemProvider_FWD_DEFINED__
typedef interface ITableItemProvider ITableItemProvider;
#endif 	/* __ITableItemProvider_FWD_DEFINED__ */


#ifndef __IToggleProvider_FWD_DEFINED__
#define __IToggleProvider_FWD_DEFINED__
typedef interface IToggleProvider IToggleProvider;
#endif 	/* __IToggleProvider_FWD_DEFINED__ */


#ifndef __ITransformProvider_FWD_DEFINED__
#define __ITransformProvider_FWD_DEFINED__
typedef interface ITransformProvider ITransformProvider;
#endif 	/* __ITransformProvider_FWD_DEFINED__ */


#ifndef __IValueProvider_FWD_DEFINED__
#define __IValueProvider_FWD_DEFINED__
typedef interface IValueProvider IValueProvider;
#endif 	/* __IValueProvider_FWD_DEFINED__ */


#ifndef __IWindowProvider_FWD_DEFINED__
#define __IWindowProvider_FWD_DEFINED__
typedef interface IWindowProvider IWindowProvider;
#endif 	/* __IWindowProvider_FWD_DEFINED__ */


#ifndef __ITextRangeProvider_FWD_DEFINED__
#define __ITextRangeProvider_FWD_DEFINED__
typedef interface ITextRangeProvider ITextRangeProvider;
#endif 	/* __ITextRangeProvider_FWD_DEFINED__ */


#ifndef __ITextProvider_FWD_DEFINED__
#define __ITextProvider_FWD_DEFINED__
typedef interface ITextProvider ITextProvider;
#endif 	/* __ITextProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_uiautomationcore_0000_0000 */
/* [local] */ 

// -------------------------------------------------------------
// UIAutomationCore.H
//
// UIAutomation interface definitions and related types and enums
// (Generated from UIAutomationCore.idl)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// -------------------------------------------------------------

enum NavigateDirection
    {	NavigateDirection_Parent	= 0,
	NavigateDirection_NextSibling	= 1,
	NavigateDirection_PreviousSibling	= 2,
	NavigateDirection_FirstChild	= 3,
	NavigateDirection_LastChild	= 4
    } ;

enum ProviderOptions
    {	ProviderOptions_ClientSideProvider	= 0x1,
	ProviderOptions_ServerSideProvider	= 0x2,
	ProviderOptions_NonClientAreaProvider	= 0x4,
	ProviderOptions_OverrideProvider	= 0x8,
	ProviderOptions_ProviderOwnsSetFocus	= 0x10
    } ;

enum OrientationType
    {	OrientationType_None	= 0,
	OrientationType_Horizontal	= 1,
	OrientationType_Vertical	= 2
    } ;

enum DockPosition
    {	DockPosition_Top	= 0,
	DockPosition_Left	= 1,
	DockPosition_Bottom	= 2,
	DockPosition_Right	= 3,
	DockPosition_Fill	= 4,
	DockPosition_None	= 5
    } ;

enum ExpandCollapseState
    {	ExpandCollapseState_Collapsed	= 0,
	ExpandCollapseState_Expanded	= 1,
	ExpandCollapseState_PartiallyExpanded	= 2,
	ExpandCollapseState_LeafNode	= 3
    } ;

enum ScrollAmount
    {	ScrollAmount_LargeDecrement	= 0,
	ScrollAmount_SmallDecrement	= 1,
	ScrollAmount_NoAmount	= 2,
	ScrollAmount_LargeIncrement	= 3,
	ScrollAmount_SmallIncrement	= 4
    } ;

enum RowOrColumnMajor
    {	RowOrColumnMajor_RowMajor	= 0,
	RowOrColumnMajor_ColumnMajor	= 1,
	RowOrColumnMajor_Indeterminate	= 2
    } ;

enum ToggleState
    {	ToggleState_Off	= 0,
	ToggleState_On	= 1,
	ToggleState_Indeterminate	= 2
    } ;

enum WindowVisualState
    {	WindowVisualState_Normal	= 0,
	WindowVisualState_Maximized	= 1,
	WindowVisualState_Minimized	= 2
    } ;

enum WindowInteractionState
    {	WindowInteractionState_Running	= 0,
	WindowInteractionState_Closing	= 1,
	WindowInteractionState_ReadyForUserInteraction	= 2,
	WindowInteractionState_BlockedByModalWindow	= 3,
	WindowInteractionState_NotResponding	= 4
    } ;

enum TextUnit
    {	TextUnit_Character	= 0,
	TextUnit_Format	= 1,
	TextUnit_Word	= 2,
	TextUnit_Line	= 3,
	TextUnit_Paragraph	= 4,
	TextUnit_Page	= 5,
	TextUnit_Document	= 6
    } ;

enum TextPatternRangeEndpoint
    {	TextPatternRangeEndpoint_Start	= 0,
	TextPatternRangeEndpoint_End	= 1
    } ;

enum SupportedTextSelection
    {	SupportedTextSelection_None	= 0,
	SupportedTextSelection_Single	= 1,
	SupportedTextSelection_Multiple	= 2
    } ;

enum AnimationStyle
    {	AnimationStyle_None	= 0,
	AnimationStyle_LasVegasLights	= 1,
	AnimationStyle_BlinkingBackground	= 2,
	AnimationStyle_SparkleText	= 3,
	AnimationStyle_MarchingBlackAnts	= 4,
	AnimationStyle_MarchingRedAnts	= 5,
	AnimationStyle_Shimmer	= 6,
	AnimationStyle_Other	= -1
    } ;

enum BulletStyle
    {	BulletStyle_None	= 0,
	BulletStyle_HollowRoundBullet	= 1,
	BulletStyle_FilledRoundBullet	= 2,
	BulletStyle_HollowSquareBullet	= 3,
	BulletStyle_FilledSquareBullet	= 4,
	BulletStyle_DashBullet	= 5,
	BulletStyle_Other	= -1
    } ;

enum CapStyle
    {	CapStyle_None	= 0,
	CapStyle_SmallCap	= 1,
	CapStyle_AllCap	= 2,
	CapStyle_AllPetiteCaps	= 3,
	CapStyle_PetiteCaps	= 4,
	CapStyle_Unicase	= 5,
	CapStyle_Titling	= 6,
	CapStyle_Other	= -1
    } ;

enum FlowDirections
    {	FlowDirections_Default	= 0,
	FlowDirections_RightToLeft	= 1,
	FlowDirections_BottomToTop	= 2,
	FlowDirections_Vertical	= 4
    } ;

enum HorizontalTextAlignment
    {	HorizontalTextAlignment_Left	= 0,
	HorizontalTextAlignment_Centered	= 1,
	HorizontalTextAlignment_Right	= 2,
	HorizontalTextAlignment_Justified	= 3
    } ;

enum OutlineStyles
    {	OutlineStyles_None	= 0,
	OutlineStyles_Outline	= 1,
	OutlineStyles_Shadow	= 2,
	OutlineStyles_Engraved	= 4,
	OutlineStyles_Embossed	= 8
    } ;

enum TextDecorationLineStyle
    {	TextDecorationLineStyle_None	= 0,
	TextDecorationLineStyle_Single	= 1,
	TextDecorationLineStyle_WordsOnly	= 2,
	TextDecorationLineStyle_Double	= 3,
	TextDecorationLineStyle_Dot	= 4,
	TextDecorationLineStyle_Dash	= 5,
	TextDecorationLineStyle_DashDot	= 6,
	TextDecorationLineStyle_DashDotDot	= 7,
	TextDecorationLineStyle_Wavy	= 8,
	TextDecorationLineStyle_ThickSingle	= 9,
	TextDecorationLineStyle_DoubleWavy	= 11,
	TextDecorationLineStyle_ThickWavy	= 12,
	TextDecorationLineStyle_LongDash	= 13,
	TextDecorationLineStyle_ThickDash	= 14,
	TextDecorationLineStyle_ThickDashDot	= 15,
	TextDecorationLineStyle_ThickDashDotDot	= 16,
	TextDecorationLineStyle_ThickDot	= 17,
	TextDecorationLineStyle_ThickLongDash	= 18,
	TextDecorationLineStyle_Other	= -1
    } ;
typedef int PROPERTYID;

typedef int PATTERNID;

typedef int EVENTID;

typedef int TEXTATTRIBUTEID;

typedef int CONTROLTYPEID;

struct UiaRect
    {
    double left;
    double top;
    double width;
    double height;
    } ;
struct UiaPoint
    {
    double x;
    double y;
    } ;


extern RPC_IF_HANDLE __MIDL_itf_uiautomationcore_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_uiautomationcore_0000_0000_v0_0_s_ifspec;


#ifndef __UIA_LIBRARY_DEFINED__
#define __UIA_LIBRARY_DEFINED__

/* library UIA */
/* [hidden][version][lcid][uuid] */ 




EXTERN_C const IID LIBID_UIA;

#ifndef __IRawElementProviderSimple_INTERFACE_DEFINED__
#define __IRawElementProviderSimple_INTERFACE_DEFINED__

/* interface IRawElementProviderSimple */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderSimple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d6dd68d1-86fd-4332-8666-9abedea2d24c")
    IRawElementProviderSimple : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderOptions( 
            /* [retval][out] */ __RPC__out enum ProviderOptions *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPatternProvider( 
            /* [in] */ PATTERNID patternId,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyValue( 
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__out VARIANT *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HostRawElementProvider( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderSimpleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRawElementProviderSimple * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRawElementProviderSimple * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRawElementProviderSimple * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderOptions )( 
            IRawElementProviderSimple * This,
            /* [retval][out] */ __RPC__out enum ProviderOptions *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPatternProvider )( 
            IRawElementProviderSimple * This,
            /* [in] */ PATTERNID patternId,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyValue )( 
            IRawElementProviderSimple * This,
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__out VARIANT *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostRawElementProvider )( 
            IRawElementProviderSimple * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        END_INTERFACE
    } IRawElementProviderSimpleVtbl;

    interface IRawElementProviderSimple
    {
        CONST_VTBL struct IRawElementProviderSimpleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderSimple_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderSimple_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderSimple_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderSimple_get_ProviderOptions(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ProviderOptions(This,pRetVal) ) 

#define IRawElementProviderSimple_GetPatternProvider(This,patternId,pRetVal)	\
    ( (This)->lpVtbl -> GetPatternProvider(This,patternId,pRetVal) ) 

#define IRawElementProviderSimple_GetPropertyValue(This,propertyId,pRetVal)	\
    ( (This)->lpVtbl -> GetPropertyValue(This,propertyId,pRetVal) ) 

#define IRawElementProviderSimple_get_HostRawElementProvider(This,pRetVal)	\
    ( (This)->lpVtbl -> get_HostRawElementProvider(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderSimple_INTERFACE_DEFINED__ */


#ifndef __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__
#define __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__

/* interface IRawElementProviderFragmentRoot */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderFragmentRoot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("620ce2a5-ab8f-40a9-86cb-de3c75599b58")
    IRawElementProviderFragmentRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ElementProviderFromPoint( 
            /* [in] */ double x,
            /* [in] */ double y,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocus( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderFragmentRootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRawElementProviderFragmentRoot * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRawElementProviderFragmentRoot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRawElementProviderFragmentRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *ElementProviderFromPoint )( 
            IRawElementProviderFragmentRoot * This,
            /* [in] */ double x,
            /* [in] */ double y,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            IRawElementProviderFragmentRoot * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal);
        
        END_INTERFACE
    } IRawElementProviderFragmentRootVtbl;

    interface IRawElementProviderFragmentRoot
    {
        CONST_VTBL struct IRawElementProviderFragmentRootVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderFragmentRoot_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderFragmentRoot_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderFragmentRoot_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderFragmentRoot_ElementProviderFromPoint(This,x,y,pRetVal)	\
    ( (This)->lpVtbl -> ElementProviderFromPoint(This,x,y,pRetVal) ) 

#define IRawElementProviderFragmentRoot_GetFocus(This,pRetVal)	\
    ( (This)->lpVtbl -> GetFocus(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__ */


#ifndef __IRawElementProviderFragment_INTERFACE_DEFINED__
#define __IRawElementProviderFragment_INTERFACE_DEFINED__

/* interface IRawElementProviderFragment */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderFragment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7063da8-8359-439c-9297-bbc5299a7d87")
    IRawElementProviderFragment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ enum NavigateDirection direction,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeId( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundingRectangle( 
            /* [retval][out] */ __RPC__out struct UiaRect *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbeddedFragmentRoots( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FragmentRoot( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragmentRoot **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderFragmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRawElementProviderFragment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRawElementProviderFragment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRawElementProviderFragment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Navigate )( 
            IRawElementProviderFragment * This,
            /* [in] */ enum NavigateDirection direction,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeId )( 
            IRawElementProviderFragment * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundingRectangle )( 
            IRawElementProviderFragment * This,
            /* [retval][out] */ __RPC__out struct UiaRect *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbeddedFragmentRoots )( 
            IRawElementProviderFragment * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            IRawElementProviderFragment * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FragmentRoot )( 
            IRawElementProviderFragment * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragmentRoot **pRetVal);
        
        END_INTERFACE
    } IRawElementProviderFragmentVtbl;

    interface IRawElementProviderFragment
    {
        CONST_VTBL struct IRawElementProviderFragmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderFragment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderFragment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderFragment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderFragment_Navigate(This,direction,pRetVal)	\
    ( (This)->lpVtbl -> Navigate(This,direction,pRetVal) ) 

#define IRawElementProviderFragment_GetRuntimeId(This,pRetVal)	\
    ( (This)->lpVtbl -> GetRuntimeId(This,pRetVal) ) 

#define IRawElementProviderFragment_get_BoundingRectangle(This,pRetVal)	\
    ( (This)->lpVtbl -> get_BoundingRectangle(This,pRetVal) ) 

#define IRawElementProviderFragment_GetEmbeddedFragmentRoots(This,pRetVal)	\
    ( (This)->lpVtbl -> GetEmbeddedFragmentRoots(This,pRetVal) ) 

#define IRawElementProviderFragment_SetFocus(This)	\
    ( (This)->lpVtbl -> SetFocus(This) ) 

#define IRawElementProviderFragment_get_FragmentRoot(This,pRetVal)	\
    ( (This)->lpVtbl -> get_FragmentRoot(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderFragment_INTERFACE_DEFINED__ */


#ifndef __IRawElementProviderAdviseEvents_INTERFACE_DEFINED__
#define __IRawElementProviderAdviseEvents_INTERFACE_DEFINED__

/* interface IRawElementProviderAdviseEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderAdviseEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a407b27b-0f6d-4427-9292-473c7bf93258")
    IRawElementProviderAdviseEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseEventAdded( 
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in SAFEARRAY * propertyIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseEventRemoved( 
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in SAFEARRAY * propertyIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderAdviseEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRawElementProviderAdviseEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRawElementProviderAdviseEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRawElementProviderAdviseEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventAdded )( 
            IRawElementProviderAdviseEvents * This,
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in SAFEARRAY * propertyIDs);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventRemoved )( 
            IRawElementProviderAdviseEvents * This,
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in SAFEARRAY * propertyIDs);
        
        END_INTERFACE
    } IRawElementProviderAdviseEventsVtbl;

    interface IRawElementProviderAdviseEvents
    {
        CONST_VTBL struct IRawElementProviderAdviseEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderAdviseEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderAdviseEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderAdviseEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderAdviseEvents_AdviseEventAdded(This,eventId,propertyIDs)	\
    ( (This)->lpVtbl -> AdviseEventAdded(This,eventId,propertyIDs) ) 

#define IRawElementProviderAdviseEvents_AdviseEventRemoved(This,eventId,propertyIDs)	\
    ( (This)->lpVtbl -> AdviseEventRemoved(This,eventId,propertyIDs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderAdviseEvents_INTERFACE_DEFINED__ */


#ifndef __IRawElementProviderHwndOverride_INTERFACE_DEFINED__
#define __IRawElementProviderHwndOverride_INTERFACE_DEFINED__

/* interface IRawElementProviderHwndOverride */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderHwndOverride;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1d5df27c-8947-4425-b8d9-79787bb460b8")
    IRawElementProviderHwndOverride : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOverrideProviderForHwnd( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderHwndOverrideVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRawElementProviderHwndOverride * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRawElementProviderHwndOverride * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRawElementProviderHwndOverride * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOverrideProviderForHwnd )( 
            IRawElementProviderHwndOverride * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        END_INTERFACE
    } IRawElementProviderHwndOverrideVtbl;

    interface IRawElementProviderHwndOverride
    {
        CONST_VTBL struct IRawElementProviderHwndOverrideVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderHwndOverride_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderHwndOverride_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderHwndOverride_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderHwndOverride_GetOverrideProviderForHwnd(This,hwnd,pRetVal)	\
    ( (This)->lpVtbl -> GetOverrideProviderForHwnd(This,hwnd,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderHwndOverride_INTERFACE_DEFINED__ */


#ifndef __IDockProvider_INTERFACE_DEFINED__
#define __IDockProvider_INTERFACE_DEFINED__

/* interface IDockProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDockProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("159bc72c-4ad3-485e-9637-d7052edf0146")
    IDockProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDockPosition( 
            /* [in] */ enum DockPosition dockPosition) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DockPosition( 
            /* [retval][out] */ __RPC__out enum DockPosition *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDockProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDockProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDockProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDockProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDockPosition )( 
            IDockProvider * This,
            /* [in] */ enum DockPosition dockPosition);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DockPosition )( 
            IDockProvider * This,
            /* [retval][out] */ __RPC__out enum DockPosition *pRetVal);
        
        END_INTERFACE
    } IDockProviderVtbl;

    interface IDockProvider
    {
        CONST_VTBL struct IDockProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDockProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDockProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDockProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDockProvider_SetDockPosition(This,dockPosition)	\
    ( (This)->lpVtbl -> SetDockPosition(This,dockPosition) ) 

#define IDockProvider_get_DockPosition(This,pRetVal)	\
    ( (This)->lpVtbl -> get_DockPosition(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDockProvider_INTERFACE_DEFINED__ */


#ifndef __IExpandCollapseProvider_INTERFACE_DEFINED__
#define __IExpandCollapseProvider_INTERFACE_DEFINED__

/* interface IExpandCollapseProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IExpandCollapseProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d847d3a5-cab0-4a98-8c32-ecb45c59ad24")
    IExpandCollapseProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Expand( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Collapse( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ExpandCollapseState( 
            /* [retval][out] */ __RPC__out enum ExpandCollapseState *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExpandCollapseProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExpandCollapseProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExpandCollapseProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExpandCollapseProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Expand )( 
            IExpandCollapseProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            IExpandCollapseProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpandCollapseState )( 
            IExpandCollapseProvider * This,
            /* [retval][out] */ __RPC__out enum ExpandCollapseState *pRetVal);
        
        END_INTERFACE
    } IExpandCollapseProviderVtbl;

    interface IExpandCollapseProvider
    {
        CONST_VTBL struct IExpandCollapseProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExpandCollapseProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExpandCollapseProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExpandCollapseProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExpandCollapseProvider_Expand(This)	\
    ( (This)->lpVtbl -> Expand(This) ) 

#define IExpandCollapseProvider_Collapse(This)	\
    ( (This)->lpVtbl -> Collapse(This) ) 

#define IExpandCollapseProvider_get_ExpandCollapseState(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ExpandCollapseState(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExpandCollapseProvider_INTERFACE_DEFINED__ */


#ifndef __IGridProvider_INTERFACE_DEFINED__
#define __IGridProvider_INTERFACE_DEFINED__

/* interface IGridProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGridProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b17d6187-0907-464b-a168-0ef17a1572b1")
    IGridProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ int row,
            /* [in] */ int column,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowCount( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ColumnCount( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGridProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGridProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGridProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGridProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IGridProvider * This,
            /* [in] */ int row,
            /* [in] */ int column,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RowCount )( 
            IGridProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColumnCount )( 
            IGridProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        END_INTERFACE
    } IGridProviderVtbl;

    interface IGridProvider
    {
        CONST_VTBL struct IGridProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGridProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGridProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGridProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGridProvider_GetItem(This,row,column,pRetVal)	\
    ( (This)->lpVtbl -> GetItem(This,row,column,pRetVal) ) 

#define IGridProvider_get_RowCount(This,pRetVal)	\
    ( (This)->lpVtbl -> get_RowCount(This,pRetVal) ) 

#define IGridProvider_get_ColumnCount(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ColumnCount(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGridProvider_INTERFACE_DEFINED__ */


#ifndef __IGridItemProvider_INTERFACE_DEFINED__
#define __IGridItemProvider_INTERFACE_DEFINED__

/* interface IGridItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGridItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d02541f1-fb81-4d64-ae32-f520f8a6dbd1")
    IGridItemProvider : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Row( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Column( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowSpan( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ColumnSpan( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainingGrid( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGridItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGridItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGridItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGridItemProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Row )( 
            IGridItemProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Column )( 
            IGridItemProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RowSpan )( 
            IGridItemProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColumnSpan )( 
            IGridItemProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainingGrid )( 
            IGridItemProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        END_INTERFACE
    } IGridItemProviderVtbl;

    interface IGridItemProvider
    {
        CONST_VTBL struct IGridItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGridItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGridItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGridItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGridItemProvider_get_Row(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Row(This,pRetVal) ) 

#define IGridItemProvider_get_Column(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Column(This,pRetVal) ) 

#define IGridItemProvider_get_RowSpan(This,pRetVal)	\
    ( (This)->lpVtbl -> get_RowSpan(This,pRetVal) ) 

#define IGridItemProvider_get_ColumnSpan(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ColumnSpan(This,pRetVal) ) 

#define IGridItemProvider_get_ContainingGrid(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ContainingGrid(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGridItemProvider_INTERFACE_DEFINED__ */


#ifndef __IInvokeProvider_INTERFACE_DEFINED__
#define __IInvokeProvider_INTERFACE_DEFINED__

/* interface IInvokeProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInvokeProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54fcb24b-e18e-47a2-b4d3-eccbe77599a2")
    IInvokeProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Invoke( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInvokeProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInvokeProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInvokeProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInvokeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInvokeProvider * This);
        
        END_INTERFACE
    } IInvokeProviderVtbl;

    interface IInvokeProvider
    {
        CONST_VTBL struct IInvokeProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInvokeProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInvokeProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInvokeProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInvokeProvider_Invoke(This)	\
    ( (This)->lpVtbl -> Invoke(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInvokeProvider_INTERFACE_DEFINED__ */


#ifndef __IMultipleViewProvider_INTERFACE_DEFINED__
#define __IMultipleViewProvider_INTERFACE_DEFINED__

/* interface IMultipleViewProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMultipleViewProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6278cab1-b556-4a1a-b4e0-418acc523201")
    IMultipleViewProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetViewName( 
            /* [in] */ int viewId,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentView( 
            /* [in] */ int viewId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentView( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedViews( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultipleViewProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMultipleViewProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMultipleViewProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMultipleViewProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewName )( 
            IMultipleViewProvider * This,
            /* [in] */ int viewId,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentView )( 
            IMultipleViewProvider * This,
            /* [in] */ int viewId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentView )( 
            IMultipleViewProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedViews )( 
            IMultipleViewProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        END_INTERFACE
    } IMultipleViewProviderVtbl;

    interface IMultipleViewProvider
    {
        CONST_VTBL struct IMultipleViewProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultipleViewProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMultipleViewProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMultipleViewProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMultipleViewProvider_GetViewName(This,viewId,pRetVal)	\
    ( (This)->lpVtbl -> GetViewName(This,viewId,pRetVal) ) 

#define IMultipleViewProvider_SetCurrentView(This,viewId)	\
    ( (This)->lpVtbl -> SetCurrentView(This,viewId) ) 

#define IMultipleViewProvider_get_CurrentView(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CurrentView(This,pRetVal) ) 

#define IMultipleViewProvider_GetSupportedViews(This,pRetVal)	\
    ( (This)->lpVtbl -> GetSupportedViews(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMultipleViewProvider_INTERFACE_DEFINED__ */


#ifndef __IRangeValueProvider_INTERFACE_DEFINED__
#define __IRangeValueProvider_INTERFACE_DEFINED__

/* interface IRangeValueProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRangeValueProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36dc7aef-33e6-4691-afe1-2be7274b3d33")
    IRangeValueProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ double val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsReadOnly( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Maximum( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Minimum( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LargeChange( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SmallChange( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRangeValueProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRangeValueProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRangeValueProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRangeValueProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IRangeValueProvider * This,
            /* [in] */ double val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsReadOnly )( 
            IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Maximum )( 
            IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Minimum )( 
            IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LargeChange )( 
            IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SmallChange )( 
            IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        END_INTERFACE
    } IRangeValueProviderVtbl;

    interface IRangeValueProvider
    {
        CONST_VTBL struct IRangeValueProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRangeValueProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRangeValueProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRangeValueProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRangeValueProvider_SetValue(This,val)	\
    ( (This)->lpVtbl -> SetValue(This,val) ) 

#define IRangeValueProvider_get_Value(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Value(This,pRetVal) ) 

#define IRangeValueProvider_get_IsReadOnly(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsReadOnly(This,pRetVal) ) 

#define IRangeValueProvider_get_Maximum(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Maximum(This,pRetVal) ) 

#define IRangeValueProvider_get_Minimum(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Minimum(This,pRetVal) ) 

#define IRangeValueProvider_get_LargeChange(This,pRetVal)	\
    ( (This)->lpVtbl -> get_LargeChange(This,pRetVal) ) 

#define IRangeValueProvider_get_SmallChange(This,pRetVal)	\
    ( (This)->lpVtbl -> get_SmallChange(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRangeValueProvider_INTERFACE_DEFINED__ */


#ifndef __IScrollItemProvider_INTERFACE_DEFINED__
#define __IScrollItemProvider_INTERFACE_DEFINED__

/* interface IScrollItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IScrollItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2360c714-4bf1-4b26-ba65-9b21316127eb")
    IScrollItemProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScrollIntoView( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScrollItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScrollItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScrollItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScrollItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScrollIntoView )( 
            IScrollItemProvider * This);
        
        END_INTERFACE
    } IScrollItemProviderVtbl;

    interface IScrollItemProvider
    {
        CONST_VTBL struct IScrollItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScrollItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IScrollItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IScrollItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IScrollItemProvider_ScrollIntoView(This)	\
    ( (This)->lpVtbl -> ScrollIntoView(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScrollItemProvider_INTERFACE_DEFINED__ */


#ifndef __ISelectionProvider_INTERFACE_DEFINED__
#define __ISelectionProvider_INTERFACE_DEFINED__

/* interface ISelectionProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISelectionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb8b03af-3bdf-48d4-bd36-1a65793be168")
    ISelectionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanSelectMultiple( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsSelectionRequired( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectionProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ISelectionProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanSelectMultiple )( 
            ISelectionProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSelectionRequired )( 
            ISelectionProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } ISelectionProviderVtbl;

    interface ISelectionProvider
    {
        CONST_VTBL struct ISelectionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISelectionProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISelectionProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISelectionProvider_GetSelection(This,pRetVal)	\
    ( (This)->lpVtbl -> GetSelection(This,pRetVal) ) 

#define ISelectionProvider_get_CanSelectMultiple(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanSelectMultiple(This,pRetVal) ) 

#define ISelectionProvider_get_IsSelectionRequired(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsSelectionRequired(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISelectionProvider_INTERFACE_DEFINED__ */


#ifndef __IScrollProvider_INTERFACE_DEFINED__
#define __IScrollProvider_INTERFACE_DEFINED__

/* interface IScrollProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IScrollProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b38b8077-1fc3-42a5-8cae-d40c2215055a")
    IScrollProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Scroll( 
            /* [in] */ enum ScrollAmount horizontalAmount,
            /* [in] */ enum ScrollAmount verticalAmount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScrollPercent( 
            /* [in] */ double horizontalPercent,
            /* [in] */ double verticalPercent) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HorizontalScrollPercent( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VerticalScrollPercent( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HorizontalViewSize( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VerticalViewSize( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HorizontallyScrollable( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VerticallyScrollable( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScrollProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScrollProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScrollProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScrollProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Scroll )( 
            IScrollProvider * This,
            /* [in] */ enum ScrollAmount horizontalAmount,
            /* [in] */ enum ScrollAmount verticalAmount);
        
        HRESULT ( STDMETHODCALLTYPE *SetScrollPercent )( 
            IScrollProvider * This,
            /* [in] */ double horizontalPercent,
            /* [in] */ double verticalPercent);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HorizontalScrollPercent )( 
            IScrollProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VerticalScrollPercent )( 
            IScrollProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HorizontalViewSize )( 
            IScrollProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VerticalViewSize )( 
            IScrollProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HorizontallyScrollable )( 
            IScrollProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VerticallyScrollable )( 
            IScrollProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } IScrollProviderVtbl;

    interface IScrollProvider
    {
        CONST_VTBL struct IScrollProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScrollProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IScrollProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IScrollProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IScrollProvider_Scroll(This,horizontalAmount,verticalAmount)	\
    ( (This)->lpVtbl -> Scroll(This,horizontalAmount,verticalAmount) ) 

#define IScrollProvider_SetScrollPercent(This,horizontalPercent,verticalPercent)	\
    ( (This)->lpVtbl -> SetScrollPercent(This,horizontalPercent,verticalPercent) ) 

#define IScrollProvider_get_HorizontalScrollPercent(This,pRetVal)	\
    ( (This)->lpVtbl -> get_HorizontalScrollPercent(This,pRetVal) ) 

#define IScrollProvider_get_VerticalScrollPercent(This,pRetVal)	\
    ( (This)->lpVtbl -> get_VerticalScrollPercent(This,pRetVal) ) 

#define IScrollProvider_get_HorizontalViewSize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_HorizontalViewSize(This,pRetVal) ) 

#define IScrollProvider_get_VerticalViewSize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_VerticalViewSize(This,pRetVal) ) 

#define IScrollProvider_get_HorizontallyScrollable(This,pRetVal)	\
    ( (This)->lpVtbl -> get_HorizontallyScrollable(This,pRetVal) ) 

#define IScrollProvider_get_VerticallyScrollable(This,pRetVal)	\
    ( (This)->lpVtbl -> get_VerticallyScrollable(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScrollProvider_INTERFACE_DEFINED__ */


#ifndef __ISelectionItemProvider_INTERFACE_DEFINED__
#define __ISelectionItemProvider_INTERFACE_DEFINED__

/* interface ISelectionItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISelectionItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2acad808-b2d4-452d-a407-91ff1ad167b2")
    ISelectionItemProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Select( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsSelected( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SelectionContainer( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectionItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectionItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectionItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            ISelectionItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddToSelection )( 
            ISelectionItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromSelection )( 
            ISelectionItemProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSelected )( 
            ISelectionItemProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionContainer )( 
            ISelectionItemProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        END_INTERFACE
    } ISelectionItemProviderVtbl;

    interface ISelectionItemProvider
    {
        CONST_VTBL struct ISelectionItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISelectionItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISelectionItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISelectionItemProvider_Select(This)	\
    ( (This)->lpVtbl -> Select(This) ) 

#define ISelectionItemProvider_AddToSelection(This)	\
    ( (This)->lpVtbl -> AddToSelection(This) ) 

#define ISelectionItemProvider_RemoveFromSelection(This)	\
    ( (This)->lpVtbl -> RemoveFromSelection(This) ) 

#define ISelectionItemProvider_get_IsSelected(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsSelected(This,pRetVal) ) 

#define ISelectionItemProvider_get_SelectionContainer(This,pRetVal)	\
    ( (This)->lpVtbl -> get_SelectionContainer(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISelectionItemProvider_INTERFACE_DEFINED__ */


#ifndef __ITableProvider_INTERFACE_DEFINED__
#define __ITableProvider_INTERFACE_DEFINED__

/* interface ITableProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITableProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c860395-97b3-490a-b52a-858cc22af166")
    ITableProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRowHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowOrColumnMajor( 
            /* [retval][out] */ __RPC__out enum RowOrColumnMajor *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITableProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITableProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITableProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRowHeaders )( 
            ITableProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnHeaders )( 
            ITableProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RowOrColumnMajor )( 
            ITableProvider * This,
            /* [retval][out] */ __RPC__out enum RowOrColumnMajor *pRetVal);
        
        END_INTERFACE
    } ITableProviderVtbl;

    interface ITableProvider
    {
        CONST_VTBL struct ITableProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITableProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITableProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITableProvider_GetRowHeaders(This,pRetVal)	\
    ( (This)->lpVtbl -> GetRowHeaders(This,pRetVal) ) 

#define ITableProvider_GetColumnHeaders(This,pRetVal)	\
    ( (This)->lpVtbl -> GetColumnHeaders(This,pRetVal) ) 

#define ITableProvider_get_RowOrColumnMajor(This,pRetVal)	\
    ( (This)->lpVtbl -> get_RowOrColumnMajor(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITableProvider_INTERFACE_DEFINED__ */


#ifndef __ITableItemProvider_INTERFACE_DEFINED__
#define __ITableItemProvider_INTERFACE_DEFINED__

/* interface ITableItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITableItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9734fa6-771f-4d78-9c90-2517999349cd")
    ITableItemProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRowHeaderItems( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnHeaderItems( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITableItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITableItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITableItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRowHeaderItems )( 
            ITableItemProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnHeaderItems )( 
            ITableItemProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        END_INTERFACE
    } ITableItemProviderVtbl;

    interface ITableItemProvider
    {
        CONST_VTBL struct ITableItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITableItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITableItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITableItemProvider_GetRowHeaderItems(This,pRetVal)	\
    ( (This)->lpVtbl -> GetRowHeaderItems(This,pRetVal) ) 

#define ITableItemProvider_GetColumnHeaderItems(This,pRetVal)	\
    ( (This)->lpVtbl -> GetColumnHeaderItems(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITableItemProvider_INTERFACE_DEFINED__ */


#ifndef __IToggleProvider_INTERFACE_DEFINED__
#define __IToggleProvider_INTERFACE_DEFINED__

/* interface IToggleProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IToggleProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56d00bd0-c4f4-433c-a836-1a52a57e0892")
    IToggleProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Toggle( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ToggleState( 
            /* [retval][out] */ __RPC__out enum ToggleState *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IToggleProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IToggleProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IToggleProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IToggleProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Toggle )( 
            IToggleProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ToggleState )( 
            IToggleProvider * This,
            /* [retval][out] */ __RPC__out enum ToggleState *pRetVal);
        
        END_INTERFACE
    } IToggleProviderVtbl;

    interface IToggleProvider
    {
        CONST_VTBL struct IToggleProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToggleProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IToggleProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IToggleProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IToggleProvider_Toggle(This)	\
    ( (This)->lpVtbl -> Toggle(This) ) 

#define IToggleProvider_get_ToggleState(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ToggleState(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IToggleProvider_INTERFACE_DEFINED__ */


#ifndef __ITransformProvider_INTERFACE_DEFINED__
#define __ITransformProvider_INTERFACE_DEFINED__

/* interface ITransformProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransformProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6829ddc4-4f91-4ffa-b86f-bd3e2987cb4c")
    ITransformProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ double x,
            /* [in] */ double y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resize( 
            /* [in] */ double width,
            /* [in] */ double height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate( 
            /* [in] */ double degrees) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanMove( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanResize( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanRotate( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransformProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransformProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransformProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransformProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            ITransformProvider * This,
            /* [in] */ double x,
            /* [in] */ double y);
        
        HRESULT ( STDMETHODCALLTYPE *Resize )( 
            ITransformProvider * This,
            /* [in] */ double width,
            /* [in] */ double height);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate )( 
            ITransformProvider * This,
            /* [in] */ double degrees);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanMove )( 
            ITransformProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanResize )( 
            ITransformProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanRotate )( 
            ITransformProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } ITransformProviderVtbl;

    interface ITransformProvider
    {
        CONST_VTBL struct ITransformProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransformProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransformProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransformProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransformProvider_Move(This,x,y)	\
    ( (This)->lpVtbl -> Move(This,x,y) ) 

#define ITransformProvider_Resize(This,width,height)	\
    ( (This)->lpVtbl -> Resize(This,width,height) ) 

#define ITransformProvider_Rotate(This,degrees)	\
    ( (This)->lpVtbl -> Rotate(This,degrees) ) 

#define ITransformProvider_get_CanMove(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanMove(This,pRetVal) ) 

#define ITransformProvider_get_CanResize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanResize(This,pRetVal) ) 

#define ITransformProvider_get_CanRotate(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanRotate(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransformProvider_INTERFACE_DEFINED__ */


#ifndef __IValueProvider_INTERFACE_DEFINED__
#define __IValueProvider_INTERFACE_DEFINED__

/* interface IValueProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IValueProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7935180-6fb3-4201-b174-7df73adbf64a")
    IValueProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in LPCWSTR val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsReadOnly( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValueProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IValueProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IValueProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IValueProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IValueProvider * This,
            /* [in] */ __RPC__in LPCWSTR val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IValueProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsReadOnly )( 
            IValueProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } IValueProviderVtbl;

    interface IValueProvider
    {
        CONST_VTBL struct IValueProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValueProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IValueProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IValueProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IValueProvider_SetValue(This,val)	\
    ( (This)->lpVtbl -> SetValue(This,val) ) 

#define IValueProvider_get_Value(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Value(This,pRetVal) ) 

#define IValueProvider_get_IsReadOnly(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsReadOnly(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IValueProvider_INTERFACE_DEFINED__ */


#ifndef __IWindowProvider_INTERFACE_DEFINED__
#define __IWindowProvider_INTERFACE_DEFINED__

/* interface IWindowProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWindowProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("987df77b-db06-4d77-8f8a-86a9c3bb90b9")
    IWindowProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVisualState( 
            /* [in] */ enum WindowVisualState state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForInputIdle( 
            /* [in] */ int milliseconds,
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanMaximize( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanMinimize( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsModal( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowVisualState( 
            /* [retval][out] */ __RPC__out enum WindowVisualState *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowInteractionState( 
            /* [retval][out] */ __RPC__out enum WindowInteractionState *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsTopmost( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVisualState )( 
            IWindowProvider * This,
            /* [in] */ enum WindowVisualState state);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWindowProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForInputIdle )( 
            IWindowProvider * This,
            /* [in] */ int milliseconds,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanMaximize )( 
            IWindowProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanMinimize )( 
            IWindowProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsModal )( 
            IWindowProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowVisualState )( 
            IWindowProvider * This,
            /* [retval][out] */ __RPC__out enum WindowVisualState *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowInteractionState )( 
            IWindowProvider * This,
            /* [retval][out] */ __RPC__out enum WindowInteractionState *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsTopmost )( 
            IWindowProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } IWindowProviderVtbl;

    interface IWindowProvider
    {
        CONST_VTBL struct IWindowProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowProvider_SetVisualState(This,state)	\
    ( (This)->lpVtbl -> SetVisualState(This,state) ) 

#define IWindowProvider_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IWindowProvider_WaitForInputIdle(This,milliseconds,pRetVal)	\
    ( (This)->lpVtbl -> WaitForInputIdle(This,milliseconds,pRetVal) ) 

#define IWindowProvider_get_CanMaximize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanMaximize(This,pRetVal) ) 

#define IWindowProvider_get_CanMinimize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanMinimize(This,pRetVal) ) 

#define IWindowProvider_get_IsModal(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsModal(This,pRetVal) ) 

#define IWindowProvider_get_WindowVisualState(This,pRetVal)	\
    ( (This)->lpVtbl -> get_WindowVisualState(This,pRetVal) ) 

#define IWindowProvider_get_WindowInteractionState(This,pRetVal)	\
    ( (This)->lpVtbl -> get_WindowInteractionState(This,pRetVal) ) 

#define IWindowProvider_get_IsTopmost(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsTopmost(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowProvider_INTERFACE_DEFINED__ */


#ifndef __ITextRangeProvider_INTERFACE_DEFINED__
#define __ITextRangeProvider_INTERFACE_DEFINED__

/* interface ITextRangeProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextRangeProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5347ad7b-c355-46f8-aff5-909033582f63")
    ITextRangeProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ __RPC__in_opt ITextRangeProvider *range,
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareEndpoints( 
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ __RPC__in_opt ITextRangeProvider *targetRange,
            /* [in] */ enum TextPatternRangeEndpoint targetEndpoint,
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandToEnclosingUnit( 
            /* [in] */ enum TextUnit unit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAttribute( 
            /* [in] */ TEXTATTRIBUTEID attributeId,
            /* [in] */ VARIANT val,
            /* [in] */ BOOL backward,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindText( 
            /* [in] */ __RPC__in BSTR text,
            /* [in] */ BOOL backward,
            /* [in] */ BOOL ignoreCase,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeValue( 
            /* [in] */ TEXTATTRIBUTEID attributeId,
            /* [retval][out] */ __RPC__out VARIANT *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoundingRectangles( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnclosingElement( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ int maxLength,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveEndpointByUnit( 
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveEndpointByRange( 
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ __RPC__in_opt ITextRangeProvider *targetRange,
            /* [in] */ enum TextPatternRangeEndpoint targetEndpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScrollIntoView( 
            /* [in] */ BOOL alignToTop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildren( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextRangeProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextRangeProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextRangeProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextRangeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITextRangeProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            ITextRangeProvider * This,
            /* [in] */ __RPC__in_opt ITextRangeProvider *range,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEndpoints )( 
            ITextRangeProvider * This,
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ __RPC__in_opt ITextRangeProvider *targetRange,
            /* [in] */ enum TextPatternRangeEndpoint targetEndpoint,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *ExpandToEnclosingUnit )( 
            ITextRangeProvider * This,
            /* [in] */ enum TextUnit unit);
        
        HRESULT ( STDMETHODCALLTYPE *FindAttribute )( 
            ITextRangeProvider * This,
            /* [in] */ TEXTATTRIBUTEID attributeId,
            /* [in] */ VARIANT val,
            /* [in] */ BOOL backward,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *FindText )( 
            ITextRangeProvider * This,
            /* [in] */ __RPC__in BSTR text,
            /* [in] */ BOOL backward,
            /* [in] */ BOOL ignoreCase,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeValue )( 
            ITextRangeProvider * This,
            /* [in] */ TEXTATTRIBUTEID attributeId,
            /* [retval][out] */ __RPC__out VARIANT *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBoundingRectangles )( 
            ITextRangeProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnclosingElement )( 
            ITextRangeProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITextRangeProvider * This,
            /* [in] */ int maxLength,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            ITextRangeProvider * This,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *MoveEndpointByUnit )( 
            ITextRangeProvider * This,
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *MoveEndpointByRange )( 
            ITextRangeProvider * This,
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ __RPC__in_opt ITextRangeProvider *targetRange,
            /* [in] */ enum TextPatternRangeEndpoint targetEndpoint);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            ITextRangeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddToSelection )( 
            ITextRangeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromSelection )( 
            ITextRangeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScrollIntoView )( 
            ITextRangeProvider * This,
            /* [in] */ BOOL alignToTop);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildren )( 
            ITextRangeProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        END_INTERFACE
    } ITextRangeProviderVtbl;

    interface ITextRangeProvider
    {
        CONST_VTBL struct ITextRangeProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextRangeProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITextRangeProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITextRangeProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITextRangeProvider_Clone(This,pRetVal)	\
    ( (This)->lpVtbl -> Clone(This,pRetVal) ) 

#define ITextRangeProvider_Compare(This,range,pRetVal)	\
    ( (This)->lpVtbl -> Compare(This,range,pRetVal) ) 

#define ITextRangeProvider_CompareEndpoints(This,endpoint,targetRange,targetEndpoint,pRetVal)	\
    ( (This)->lpVtbl -> CompareEndpoints(This,endpoint,targetRange,targetEndpoint,pRetVal) ) 

#define ITextRangeProvider_ExpandToEnclosingUnit(This,unit)	\
    ( (This)->lpVtbl -> ExpandToEnclosingUnit(This,unit) ) 

#define ITextRangeProvider_FindAttribute(This,attributeId,val,backward,pRetVal)	\
    ( (This)->lpVtbl -> FindAttribute(This,attributeId,val,backward,pRetVal) ) 

#define ITextRangeProvider_FindText(This,text,backward,ignoreCase,pRetVal)	\
    ( (This)->lpVtbl -> FindText(This,text,backward,ignoreCase,pRetVal) ) 

#define ITextRangeProvider_GetAttributeValue(This,attributeId,pRetVal)	\
    ( (This)->lpVtbl -> GetAttributeValue(This,attributeId,pRetVal) ) 

#define ITextRangeProvider_GetBoundingRectangles(This,pRetVal)	\
    ( (This)->lpVtbl -> GetBoundingRectangles(This,pRetVal) ) 

#define ITextRangeProvider_GetEnclosingElement(This,pRetVal)	\
    ( (This)->lpVtbl -> GetEnclosingElement(This,pRetVal) ) 

#define ITextRangeProvider_GetText(This,maxLength,pRetVal)	\
    ( (This)->lpVtbl -> GetText(This,maxLength,pRetVal) ) 

#define ITextRangeProvider_Move(This,unit,count,pRetVal)	\
    ( (This)->lpVtbl -> Move(This,unit,count,pRetVal) ) 

#define ITextRangeProvider_MoveEndpointByUnit(This,endpoint,unit,count,pRetVal)	\
    ( (This)->lpVtbl -> MoveEndpointByUnit(This,endpoint,unit,count,pRetVal) ) 

#define ITextRangeProvider_MoveEndpointByRange(This,endpoint,targetRange,targetEndpoint)	\
    ( (This)->lpVtbl -> MoveEndpointByRange(This,endpoint,targetRange,targetEndpoint) ) 

#define ITextRangeProvider_Select(This)	\
    ( (This)->lpVtbl -> Select(This) ) 

#define ITextRangeProvider_AddToSelection(This)	\
    ( (This)->lpVtbl -> AddToSelection(This) ) 

#define ITextRangeProvider_RemoveFromSelection(This)	\
    ( (This)->lpVtbl -> RemoveFromSelection(This) ) 

#define ITextRangeProvider_ScrollIntoView(This,alignToTop)	\
    ( (This)->lpVtbl -> ScrollIntoView(This,alignToTop) ) 

#define ITextRangeProvider_GetChildren(This,pRetVal)	\
    ( (This)->lpVtbl -> GetChildren(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextRangeProvider_INTERFACE_DEFINED__ */


#ifndef __ITextProvider_INTERFACE_DEFINED__
#define __ITextProvider_INTERFACE_DEFINED__

/* interface ITextProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3589c92c-63f3-4367-99bb-ada653b77cf2")
    ITextProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisibleRanges( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeFromChild( 
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *childElement,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeFromPoint( 
            /* [in] */ struct UiaPoint point,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DocumentRange( 
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SupportedTextSelection( 
            /* [retval][out] */ __RPC__out enum SupportedTextSelection *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITextProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisibleRanges )( 
            ITextProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *RangeFromChild )( 
            ITextProvider * This,
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *childElement,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *RangeFromPoint )( 
            ITextProvider * This,
            /* [in] */ struct UiaPoint point,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentRange )( 
            ITextProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedTextSelection )( 
            ITextProvider * This,
            /* [retval][out] */ __RPC__out enum SupportedTextSelection *pRetVal);
        
        END_INTERFACE
    } ITextProviderVtbl;

    interface ITextProvider
    {
        CONST_VTBL struct ITextProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITextProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITextProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITextProvider_GetSelection(This,pRetVal)	\
    ( (This)->lpVtbl -> GetSelection(This,pRetVal) ) 

#define ITextProvider_GetVisibleRanges(This,pRetVal)	\
    ( (This)->lpVtbl -> GetVisibleRanges(This,pRetVal) ) 

#define ITextProvider_RangeFromChild(This,childElement,pRetVal)	\
    ( (This)->lpVtbl -> RangeFromChild(This,childElement,pRetVal) ) 

#define ITextProvider_RangeFromPoint(This,point,pRetVal)	\
    ( (This)->lpVtbl -> RangeFromPoint(This,point,pRetVal) ) 

#define ITextProvider_get_DocumentRange(This,pRetVal)	\
    ( (This)->lpVtbl -> get_DocumentRange(This,pRetVal) ) 

#define ITextProvider_get_SupportedTextSelection(This,pRetVal)	\
    ( (This)->lpVtbl -> get_SupportedTextSelection(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextProvider_INTERFACE_DEFINED__ */

#endif /* __UIA_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\unknown.h ===
/*****************************************************************************
 * unknown.h - IUnknown definitions
 *****************************************************************************
 * Copyright (c) 1996 Microsoft Corporation
 */

#ifndef _UNKNOWN_H_
#define _UNKNOWN_H_

#ifdef __cplusplus
extern "C" {
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#include <windef.h>
#define COM_NO_WINDOWS_H
#include <basetyps.h>
#ifdef PUT_GUIDS_HERE
#include <initguid.h>
#endif





DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("00000000-0000-0000-c000-000000000046")) IUnknown;
#endif

/*****************************************************************************
 * IUnknown
 *****************************************************************************
 * Base interface for otherwise unknown objects.
 */
#undef INTERFACE
#define INTERFACE IUnknown
DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface)
    (   THIS_
        IN      REFIID,
        OUT     PVOID *
    )   PURE;

    STDMETHOD_(ULONG,AddRef)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,Release)
    (   THIS
    )   PURE;
};
#undef INTERFACE

typedef IUnknown *PUNKNOWN;

/*****************************************************************************
 * PFNCREATEINSTANCE
 *****************************************************************************
 * Type for object create function.
 */
typedef
HRESULT
(*PFNCREATEINSTANCE)
(
    OUT PUNKNOWN *  Unknown,
    IN  REFCLSID    ClassId,
    IN  PUNKNOWN    OuterUnknown,
    IN  POOL_TYPE   PoolType
);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Unknwn.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for unknwn.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __unknwn_h__
#define __unknwn_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUnknown_FWD_DEFINED__
#define __IUnknown_FWD_DEFINED__
typedef interface IUnknown IUnknown;
#endif 	/* __IUnknown_FWD_DEFINED__ */


#ifndef __AsyncIUnknown_FWD_DEFINED__
#define __AsyncIUnknown_FWD_DEFINED__
typedef interface AsyncIUnknown AsyncIUnknown;
#endif 	/* __AsyncIUnknown_FWD_DEFINED__ */


#ifndef __IClassFactory_FWD_DEFINED__
#define __IClassFactory_FWD_DEFINED__
typedef interface IClassFactory IClassFactory;
#endif 	/* __IClassFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_unknwn_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 1020 )
#pragma once
#endif


extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0000_v0_0_s_ifspec;

#ifndef __IUnknown_INTERFACE_DEFINED__
#define __IUnknown_INTERFACE_DEFINED__

/* interface IUnknown */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IUnknown *LPUNKNOWN;

//////////////////////////////////////////////////////////////////
// IID_IUnknown and all other system IIDs are provided in UUID.LIB
// Link that library in with your proxies, clients and servers
//////////////////////////////////////////////////////////////////

#if (_MSC_VER >= 1100) && defined(__cplusplus) && !defined(CINTERFACE)
    EXTERN_C const IID IID_IUnknown;
    extern "C++"
    {
        MIDL_INTERFACE("00000000-0000-0000-C000-000000000046")
        IUnknown
        {
        public:
            BEGIN_INTERFACE
            virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
                /* [in] */ REFIID riid,
                /* [iid_is][out] */ __RPC__deref_out void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

            virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;

            virtual ULONG STDMETHODCALLTYPE Release( void) = 0;

            template<class Q>
            HRESULT
#ifdef _M_CEE_PURE
            __clrcall
#else
            STDMETHODCALLTYPE
#endif
            QueryInterface(Q** pp)
            {
                return QueryInterface(__uuidof(Q), (void **)pp);
            }

            END_INTERFACE
        };
    } // extern C++
    HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy(
        IUnknown __RPC_FAR * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ __RPC__deref_out void __RPC_FAR *__RPC_FAR *ppvObject);
    
    void __RPC_STUB IUnknown_QueryInterface_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
    
    ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy(
        IUnknown __RPC_FAR * This);
    
    void __RPC_STUB IUnknown_AddRef_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
    
    ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy(
        IUnknown __RPC_FAR * This);
    
    void __RPC_STUB IUnknown_Release_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
#else

EXTERN_C const IID IID_IUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000000-0000-0000-C000-000000000046")
    IUnknown
    {
    public:
        BEGIN_INTERFACE
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject) = 0;
        
        virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
        
        END_INTERFACE
    };
    
#else 	/* C style interface */

    typedef struct IUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUnknown * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUnknown * This);
        
        END_INTERFACE
    } IUnknownVtbl;

    interface IUnknown
    {
        CONST_VTBL struct IUnknownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnknown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUnknown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUnknown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy( 
    IUnknown * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ 
    __RPC__deref_out  void **ppvObject);


void __RPC_STUB IUnknown_QueryInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy( 
    IUnknown * This);


void __RPC_STUB IUnknown_AddRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy( 
    IUnknown * This);


void __RPC_STUB IUnknown_Release_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnknown_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_unknwn_0000_0001 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0001_v0_0_s_ifspec;

#ifndef __AsyncIUnknown_INTERFACE_DEFINED__
#define __AsyncIUnknown_INTERFACE_DEFINED__

/* interface AsyncIUnknown */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_AsyncIUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000e0000-0000-0000-C000-000000000046")
    AsyncIUnknown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin_QueryInterface( 
            /* [in] */ REFIID riid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_QueryInterface( 
            /* [out] */ 
            __RPC__deref_out  void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_AddRef( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE Finish_AddRef( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_Release( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE Finish_Release( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AsyncIUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            AsyncIUnknown * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            AsyncIUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            AsyncIUnknown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_QueryInterface )( 
            AsyncIUnknown * This,
            /* [in] */ REFIID riid);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_QueryInterface )( 
            AsyncIUnknown * This,
            /* [out] */ 
            __RPC__deref_out  void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_AddRef )( 
            AsyncIUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Finish_AddRef )( 
            AsyncIUnknown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_Release )( 
            AsyncIUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Finish_Release )( 
            AsyncIUnknown * This);
        
        END_INTERFACE
    } AsyncIUnknownVtbl;

    interface AsyncIUnknown
    {
        CONST_VTBL struct AsyncIUnknownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AsyncIUnknown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define AsyncIUnknown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define AsyncIUnknown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define AsyncIUnknown_Begin_QueryInterface(This,riid)	\
    ( (This)->lpVtbl -> Begin_QueryInterface(This,riid) ) 

#define AsyncIUnknown_Finish_QueryInterface(This,ppvObject)	\
    ( (This)->lpVtbl -> Finish_QueryInterface(This,ppvObject) ) 

#define AsyncIUnknown_Begin_AddRef(This)	\
    ( (This)->lpVtbl -> Begin_AddRef(This) ) 

#define AsyncIUnknown_Finish_AddRef(This)	\
    ( (This)->lpVtbl -> Finish_AddRef(This) ) 

#define AsyncIUnknown_Begin_Release(This)	\
    ( (This)->lpVtbl -> Begin_Release(This) ) 

#define AsyncIUnknown_Finish_Release(This)	\
    ( (This)->lpVtbl -> Finish_Release(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __AsyncIUnknown_INTERFACE_DEFINED__ */


#ifndef __IClassFactory_INTERFACE_DEFINED__
#define __IClassFactory_INTERFACE_DEFINED__

/* interface IClassFactory */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IClassFactory *LPCLASSFACTORY;


EXTERN_C const IID IID_IClassFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000001-0000-0000-C000-000000000046")
    IClassFactory : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [unique][in] */ IUnknown *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LockServer( 
            /* [in] */ BOOL fLock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClassFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClassFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClassFactory * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            IClassFactory * This,
            /* [unique][in] */ IUnknown *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *LockServer )( 
            IClassFactory * This,
            /* [in] */ BOOL fLock);
        
        END_INTERFACE
    } IClassFactoryVtbl;

    interface IClassFactory
    {
        CONST_VTBL struct IClassFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IClassFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IClassFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IClassFactory_CreateInstance(This,pUnkOuter,riid,ppvObject)	\
    ( (This)->lpVtbl -> CreateInstance(This,pUnkOuter,riid,ppvObject) ) 

#define IClassFactory_LockServer(This,fLock)	\
    ( (This)->lpVtbl -> LockServer(This,fLock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_RemoteCreateInstance_Proxy( 
    IClassFactory * This,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObject);


void __RPC_STUB IClassFactory_RemoteCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy( 
    IClassFactory * This,
    /* [in] */ BOOL fLock);


void __RPC_STUB IClassFactory_RemoteLockServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassFactory_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Proxy( 
    IClassFactory * This,
    /* [unique][in] */ IUnknown *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Stub( 
    IClassFactory * This,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Proxy( 
    IClassFactory * This,
    /* [in] */ BOOL fLock);


/* [call_as] */ HRESULT __stdcall IClassFactory_LockServer_Stub( 
    IClassFactory * This,
    /* [in] */ BOOL fLock);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Umx.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**          Copyright(c) Microsoft Corporation 1992 - 1999          **/
/**********************************************************************/

/*
    umx.h
    This file contains the common messages, manifests, types, and
    structures used by User Manager Extensions.

    NOTE:  You must include windows.h and lmcons.h *before* this file.
*/



#ifndef _UMX_H_
#define _UMX_H_



//
//  This is the maximum length allowed for an extension menu item.
//

#define UME_MENU_TEXT_LEN               50



//
//  This is the current version number of the extension interface.
//

#define UME_VERSION                     0


//
//  These are the two listboxes in the User Manager main window.
//

#define UMS_LISTBOX_USERS               0
#define UMS_LISTBOX_GROUPS              1


//
//  These are the messages sent from the extension to the
//  User Manager application.
//
//      UM_GETSELCOUNT
//
//              Purpose - Retrieves the number of selected items in
//                        the specified listbox.
//
//              wParam  - Listbox index.  This 0-based index specifies
//                        the listbox to query.  For the User Manager,
//                        this may be either UMS_LISTBOX_USERS or
//                        UMS_LISTBOX_GROUPS.
//
//              lParam  - Points to a UMS_GETSELCOUNT structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETUSERSEL[AW]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is used here
//                        since the Users listbox is multiple-select.
//
//              lParam  - Points to a UMS_GETSEL[AW] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETGROUPSEL[AW]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is useful
//                        for muliple-select listboxes.  Since the Groups
//                        listbox is single-select, this value must always
//                        be zero.
//
//              lParam  - Points to a UMS_GETSEL[AW] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETCURFOCUS[AW]
//
//              Purpose - Retrieves the current application focus.
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a UMS_GETCURFOCUS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETOPTIONS[2]
//
//              Purpose - Retrieves the current option settings
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a UMS_GETOPTIONS[2] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//

#define UM_GETSELCOUNT                  (WM_USER + 1000)
#define UM_GETUSERSELA                  (WM_USER + 1001)
#define UM_GETUSERSELW                  (WM_USER + 1002)
#define UM_GETGROUPSELA                 (WM_USER + 1003)
#define UM_GETGROUPSELW                 (WM_USER + 1004)
#define UM_GETCURFOCUSA                 (WM_USER + 1005)
#define UM_GETCURFOCUSW                 (WM_USER + 1006)
#define UM_GETOPTIONS                   (WM_USER + 1007)
#define UM_GETOPTIONS2                  (WM_USER + 1008)

#ifdef UNICODE
#define UM_GETUSERSEL                 UM_GETUSERSELW
#define UM_GETGROUPSEL                UM_GETGROUPSELW
#define UM_GETCURFOCUS                UM_GETCURFOCUSW
#else   // !UNICODE
#define UM_GETUSERSEL                 UM_GETUSERSELA
#define UM_GETGROUPSEL                UM_GETGROUPSELA
#define UM_GETCURFOCUS                UM_GETCURFOCUSA
#endif  // UNICODE



//
//  These structures are used when the extension is
//  communicating with the application.
//


//
//  The UMS_LOADMENU[AW] structure is passed to the extension's
//  UMELoadMenu[AW] entrypoint when the extension is loaded.
//
//      dwVersion       - On entry to UMELoadMenu[AW], this will
//                        contain the maximum extension version
//                        supported by the User Manager.  If the
//                        extension supports a lower version, it
//                        should set this field appropriately before
//                        returning.  The User Manager will use
//                        the returned value to determine the
//                        capabilities of the extension.
//
//      szMenuName      - The name of the menu item that is to appear
//                        in the app's main menu.  This value will also
//                        appear in the "Help On Extensions" submene and
//                        the "View" menu.
//
//      hMenu           - A valid HMENU for the popup-menu to be inserted
//                        into the app's main menu.  Ownership of this
//                        handle transfers to the User Manager.  The
//                        extension should *not* destroy this handle.
//
//      szHelpFileName  - The name of the help file associated with this
//                        extension.  This file will be used for the
//                        "Help On Extensions" menu.  This will also be
//                        used when the user presses [F1] while the
//                        extension's menu is dropped.
//
//      dwMenuDelta     - The User Manager will apply this delta
//                        to each menu ID present in hMenu.  This is
//                        to prevent conflicts with other extension's
//                        menu IDs.
//

typedef struct _UMS_LOADMENUA
{
    DWORD       dwVersion;
    CHAR        szMenuName[UME_MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    CHAR        szHelpFileName[MAX_PATH];
    DWORD       dwMenuDelta;

} UMS_LOADMENUA, * PUMS_LOADMENUA;

typedef struct _UMS_LOADMENUW
{
    DWORD       dwVersion;
    WCHAR       szMenuName[UME_MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    WCHAR       szHelpFileName[MAX_PATH];
    DWORD       dwMenuDelta;

} UMS_LOADMENUW, * PUMS_LOADMENUW;

#ifdef UNICODE
#define UMS_LOADMENU                    UMS_LOADMENUW
#define PUMS_LOADMENU                   PUMS_LOADMENUW
#else   // !UNICODE
#define UMS_LOADMENU                    UMS_LOADMENUA
#define PUMS_LOADMENU                   PUMS_LOADMENUA
#endif  // UNICODE

#define UM_SELTYPE_USER     0x10
#define UM_SELTYPE_NORMALUSER   0x1 | UM_SELTYPE_USER
#define UM_SELTYPE_REMOTEUSER   0x2 | UM_SELTYPE_USER
#define UM_SELTYPE_GROUP    0x20
#define UM_SELTYPE_LOCALGROUP   0x4 | UM_SELTYPE_GROUP
#define UM_SELTYPE_GLOBALGROUP  0x8 | UM_SELTYPE_GROUP


//
//  The UMS_GETSEL[AW] structure is filled in by the User Manager
//  when it handles UM_GETUSERSEL[AW] or UM_GETGROUPSEL[AW] messages.
//  This is used to return the current selection to the extension.
//  Note that this structure contains pointers.  The extension should not
//  assume that these pointers will be valid forever, instead the
//  extension should promptly copy these strings and use the copies.
//
//      dwRID         - The RID of the item.  Note that the RID is not
//                      valid when the UMS_GETSEL describes a group.
//
//      pchName       - Will receive the name of the selected account.
//
//      dwSelType     - Will receive the account type mask associated
//                      with the account.
//
//      pchName       - Will receive the fullname of the selected account.
//                      Note that groups do not have fullnames.
//
//      pchComment    - Will receive the comment of the selected account.
//

typedef struct _UMS_GETSELA
{
    DWORD       dwRID;
    LPSTR       pchName;
    DWORD       dwSelType;
    LPSTR       pchFullName;
    LPSTR       pchComment;

} UMS_GETSELA, * PUMS_GETSELA;

typedef struct _UMS_GETSELW
{
    DWORD       dwRID;
    LPWSTR      pchName;
    DWORD       dwSelType;
    LPWSTR      pchFullName;
    LPWSTR      pchComment;

} UMS_GETSELW, * PUMS_GETSELW;

#ifdef UNICODE
#define UMS_GETSEL                  UMS_GETSELW
#define PUMS_GETSEL                 PUMS_GETSELW
#else   // !UNICODE
#define UMS_GETSEL                  UMS_GETSELA
#define PUMS_GETSEL                 PUMS_GETSELA
#endif  // UNICODE


//
//  The UMS_GETSELCOUNT structure is filled in by the User Manager
//  when it handles the UM_GETSELCOUNT message.  This is used to
//  return the number of selected items to the extension.  This could
//  be more than 1 for the user listbox.
//
//      dwItems         - The number of selected items in the listbox.
//

typedef struct _UMS_GETSELCOUNT
{
    DWORD       dwItems;
} UMS_GETSELCOUNT, * PUMS_GETSELCOUNT;


//
//  The UMS_GETCURFOCUS structure is filled in by the User Manager
//  when it handles the UM_GETCURFOCUS message.  This is used to
//  return the current focus of the User Manager application.
//
//      szFocus         - The domain name or server name of the current
//                        focus.  Server names can be distinguished
//                        by the leading backslashes, or by dwFocusType.
//
//      dwFocusType     - This is the type of focus, either
//                        UM_FOCUS_TYPE_DOMAIN (and szFocus is a domain name)
//                        UM_FOCUS_TYPE_WINNT  (and szFocus is a server name)
//                        UM_FOCUS_TYPE_LM     (and szFocus is a server name)
//                        UM_FOCUS_TYPE_UNKNOWN
//
//      szFocusPDC      - This is the PDC of the domain of focus, and is valid
//                        only if focus is set to UM_FOCUS_TYPE_DOMAIN.
//
//      psidFocus       - This points to the SID of the domain of focus.  It
//                        may be NULL.  Note that this pointer will not be
//                        valid forever, the extension should copy the SID
//                        immediately if it intends to use it.
//

#define UM_FOCUS_TYPE_DOMAIN    1
#define UM_FOCUS_TYPE_WINNT     2
#define UM_FOCUS_TYPE_LM        3
#define UM_FOCUS_TYPE_UNKNOWN   4

typedef struct _UMS_GETCURFOCUSA
{
    CHAR        szFocus[MAX_PATH];
    DWORD       dwFocusType;
    CHAR        szFocusPDC[MAX_PATH];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUSA, * PUMS_GETCURFOCUSA;

typedef struct _UMS_GETCURFOCUSW
{
    WCHAR       szFocus[MAX_PATH];
    DWORD       dwFocusType;
    WCHAR       szFocusPDC[MAX_PATH];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUSW, * PUMS_GETCURFOCUSW;

#ifdef UNICODE
#define UMS_GETCURFOCUS             UMS_GETCURFOCUSW
#define PUMS_GETCURFOCUS            PUMS_GETCURFOCUSW
#else   // UNICODE
#define UMS_GETCURFOCUS             UMS_GETCURFOCUSA
#define PUMS_GETCURFOCUS            PUMS_GETCURFOCUSA
#endif  // UNICODE


//
//  The UMS_GETOPTIONS[2] structure is filled in by the User Manager
//  when it handles the UM_GETOPTIONS[2] message.  This is used to
//  return the current option settings of the User Manager application.
//
//      fSaveSettingsOnExit - Should User Manager settings be saved on exit?
//
//      fConfirmation   - Should permanent and/or dangerous actions be
//                        confirmed?
//
//      fSortByFullName - Should the main user listbox be sorted by
//                        fullname rather than by user name?
//
//      fMiniUserManager - (UMS_GETOPTIONS2 only) Is this the User Manager
//                         rather than the User Manager for Domains?
//
//      fLowSpeedConnection - (UMS_GETOPTIONS2 only) Is the User Manager
//                            optimized for use across a slow network link?
//

typedef struct _UMS_GETOPTIONS
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;
    BOOL        fSortByFullName;
} UMS_GETOPTIONS, * PUMS_GETOPTIONS;

typedef struct _UMS_GETOPTIONS2
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;
    BOOL        fSortByFullName;
    BOOL        fMiniUserManager;
    BOOL        fLowSpeedConnection;
} UMS_GETOPTIONS2, * PUMS_GETOPTIONS2;




//
//  These are the names of the extension entrypoints.
//

#define SZ_UME_UNLOADMENU               "UMEUnloadMenu"
#define SZ_UME_INITIALIZEMENU           "UMEInitializeMenu"
#define SZ_UME_REFRESH                  "UMERefresh"
#define SZ_UME_MENUACTION               "UMEMenuAction"

#define SZ_UME_LOADMENUW                "UMELoadMenuW"
#define SZ_UME_GETEXTENDEDERRORSTRINGW  "UMEGetExtendedErrorStringW"
#define SZ_UME_CREATEW                  "UMECreateW"
#define SZ_UME_DELETEW                  "UMEDeleteW"
#define SZ_UME_RENAMEW                  "UMERenameW"

#define SZ_UME_LOADMENUA                "UMELoadMenuA"
#define SZ_UME_GETEXTENDEDERRORSTRINGA  "UMEGetExtendedErrorStringA"
#define SZ_UME_CREATEA                  "UMECreateA"
#define SZ_UME_DELETEA                  "UMEDeleteA"
#define SZ_UME_RENAMEA                  "UMERenameA"

#ifdef UNICODE
#define SZ_UME_LOADMENU                 SZ_UME_LOADMENUW
#define SZ_UME_GETEXTENDEDERRORSTRING   SZ_UME_GETEXTENDEDERRORSTRINGW
#define SZ_UME_CREATE                   SZ_UME_CREATEW
#define SZ_UME_DELETE                   SZ_UME_DELETEW
#define SZ_UME_RENAME                   SZ_UME_RENAMEW
#else   // !UNICODE
#define SZ_UME_LOADMENU                 SZ_UME_LOADMENUA
#define SZ_UME_GETEXTENDEDERRORSTRING   SZ_UME_GETEXTENDEDERRORSTRINGA
#define SZ_UME_CREATE                   SZ_UME_CREATEA
#define SZ_UME_DELETE                   SZ_UME_DELETEA
#define SZ_UME_RENAME                   SZ_UME_RENAMEA
#endif  // UNICODE



//
//  Typedefs for the extension entrypoints.
//

typedef DWORD (PASCAL * PUMX_LOADMENUW)( HWND          hWnd,
                                         PUMS_LOADMENUW pumsload );
typedef DWORD (PASCAL * PUMX_LOADMENUA)( HWND          hWnd,
                                         PUMS_LOADMENUA pumsload );

typedef LPWSTR (PASCAL * PUMX_GETEXTENDEDERRORSTRINGW)( VOID );
typedef LPSTR  (PASCAL * PUMX_GETEXTENDEDERRORSTRINGA)( VOID );

typedef VOID (PASCAL * PUMX_UNLOADMENU)( VOID );

typedef VOID (PASCAL * PUMX_INITIALIZEMENU)( VOID );

typedef VOID (PASCAL * PUMX_REFRESH)( HWND hwndParent );

typedef VOID (PASCAL * PUMX_MENUACTION)( HWND  hwndParent,
                                         DWORD dwEventId );

typedef VOID (PASCAL * PUMX_CREATEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection );
typedef VOID (PASCAL * PUMX_CREATEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection );

typedef VOID (PASCAL * PUMX_DELETEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection );
typedef VOID (PASCAL * PUMX_DELETEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection );

typedef VOID (PASCAL * PUMX_RENAMEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection,
                                      LPWSTR       pchNewName    );
typedef VOID (PASCAL * PUMX_RENAMEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection,
                                      LPSTR        pchNewName    );


#ifdef  UNICODE
#define PUMX_LOADMENU                   PUMX_LOADMENUW
#define PUMX_GETEXTENDEDERRORSTRING     PUMX_GETEXTENDEDERRORSTRINGW
#define PUMX_CREATE                     PUMX_CREATEW
#define PUMX_DELETE                     PUMX_DELETEW
#define PUMX_RENAME                     PUMX_RENAMEW
#else   // !UNICODE
#define PUMX_LOADMENU                   PUMX_LOADMENUA
#define PUMX_GETEXTENDEDERRORSTRING     PUMX_GETEXTENDEDERRORSTRINGA
#define PUMX_CREATE                     PUMX_CREATEA
#define PUMX_DELETE                     PUMX_DELETEA
#define PUMX_RENAME                     PUMX_RENAMEA
#endif  // UNICODE



//
//  Prototypes for the extension entrypoints.
//

DWORD PASCAL UMELoadMenuA( HWND           hwndMessage,
                           PUMS_LOADMENUA pumsload );

DWORD PASCAL UMELoadMenuW( HWND           hwndMessage,
                           PUMS_LOADMENUW pumsload );

LPSTR  PASCAL UMEGetExtendedErrorStringA( VOID );

LPWSTR PASCAL UMEGetExtendedErrorStringW( VOID );

VOID PASCAL UMEUnloadMenu( VOID );

VOID PASCAL UMEInitializeMenu( VOID );

VOID PASCAL UMERefresh( HWND hwndParent );

VOID PASCAL UMEMenuAction( HWND hwndParent,
                           DWORD dwEventId );

VOID PASCAL UMECreateA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection );
VOID PASCAL UMECreateW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection );

VOID PASCAL UMEDeleteA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection );
VOID PASCAL UMEDeleteW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection );

VOID PASCAL UMERenameA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection,
                        LPSTR pchNewName );
VOID PASCAL UMERenameW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection,
                        LPWSTR pchNewName );


#endif  // _UMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\unexposeenums2managed.h ===
//------------------------------------------------------------------------------
// File: expose.h
//
// Desc: macros to allow the same enum to be exposed to native and managed.  
//
// USAGE:
//
// see comments at top of exposeenums2managed.h
//
// Copyright (c) 2003-2004, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

// !!! do not pragma once or macro guard this file.
// it gets used multiple times by the same compilation units

#undef ENUM
#undef ENUM16
#undef FLAGS
#undef TAG

// end of file - expose.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\upnphost.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for upnphost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __upnphost_h__
#define __upnphost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUPnPEventSink_FWD_DEFINED__
#define __IUPnPEventSink_FWD_DEFINED__
typedef interface IUPnPEventSink IUPnPEventSink;
#endif 	/* __IUPnPEventSink_FWD_DEFINED__ */


#ifndef __IUPnPEventSource_FWD_DEFINED__
#define __IUPnPEventSource_FWD_DEFINED__
typedef interface IUPnPEventSource IUPnPEventSource;
#endif 	/* __IUPnPEventSource_FWD_DEFINED__ */


#ifndef __IUPnPRegistrar_FWD_DEFINED__
#define __IUPnPRegistrar_FWD_DEFINED__
typedef interface IUPnPRegistrar IUPnPRegistrar;
#endif 	/* __IUPnPRegistrar_FWD_DEFINED__ */


#ifndef __IUPnPReregistrar_FWD_DEFINED__
#define __IUPnPReregistrar_FWD_DEFINED__
typedef interface IUPnPReregistrar IUPnPReregistrar;
#endif 	/* __IUPnPReregistrar_FWD_DEFINED__ */


#ifndef __IUPnPDeviceControl_FWD_DEFINED__
#define __IUPnPDeviceControl_FWD_DEFINED__
typedef interface IUPnPDeviceControl IUPnPDeviceControl;
#endif 	/* __IUPnPDeviceControl_FWD_DEFINED__ */


#ifndef __IUPnPDeviceProvider_FWD_DEFINED__
#define __IUPnPDeviceProvider_FWD_DEFINED__
typedef interface IUPnPDeviceProvider IUPnPDeviceProvider;
#endif 	/* __IUPnPDeviceProvider_FWD_DEFINED__ */


#ifndef __IUPnPRemoteEndpointInfo_FWD_DEFINED__
#define __IUPnPRemoteEndpointInfo_FWD_DEFINED__
typedef interface IUPnPRemoteEndpointInfo IUPnPRemoteEndpointInfo;
#endif 	/* __IUPnPRemoteEndpointInfo_FWD_DEFINED__ */


#ifndef __IUPnPEventSink_FWD_DEFINED__
#define __IUPnPEventSink_FWD_DEFINED__
typedef interface IUPnPEventSink IUPnPEventSink;
#endif 	/* __IUPnPEventSink_FWD_DEFINED__ */


#ifndef __IUPnPEventSource_FWD_DEFINED__
#define __IUPnPEventSource_FWD_DEFINED__
typedef interface IUPnPEventSource IUPnPEventSource;
#endif 	/* __IUPnPEventSource_FWD_DEFINED__ */


#ifndef __IUPnPRegistrar_FWD_DEFINED__
#define __IUPnPRegistrar_FWD_DEFINED__
typedef interface IUPnPRegistrar IUPnPRegistrar;
#endif 	/* __IUPnPRegistrar_FWD_DEFINED__ */


#ifndef __IUPnPReregistrar_FWD_DEFINED__
#define __IUPnPReregistrar_FWD_DEFINED__
typedef interface IUPnPReregistrar IUPnPReregistrar;
#endif 	/* __IUPnPReregistrar_FWD_DEFINED__ */


#ifndef __IUPnPDeviceControl_FWD_DEFINED__
#define __IUPnPDeviceControl_FWD_DEFINED__
typedef interface IUPnPDeviceControl IUPnPDeviceControl;
#endif 	/* __IUPnPDeviceControl_FWD_DEFINED__ */


#ifndef __IUPnPDeviceProvider_FWD_DEFINED__
#define __IUPnPDeviceProvider_FWD_DEFINED__
typedef interface IUPnPDeviceProvider IUPnPDeviceProvider;
#endif 	/* __IUPnPDeviceProvider_FWD_DEFINED__ */


#ifndef __IUPnPRemoteEndpointInfo_FWD_DEFINED__
#define __IUPnPRemoteEndpointInfo_FWD_DEFINED__
typedef interface IUPnPRemoteEndpointInfo IUPnPRemoteEndpointInfo;
#endif 	/* __IUPnPRemoteEndpointInfo_FWD_DEFINED__ */


#ifndef __UPnPRegistrar_FWD_DEFINED__
#define __UPnPRegistrar_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPRegistrar UPnPRegistrar;
#else
typedef struct UPnPRegistrar UPnPRegistrar;
#endif /* __cplusplus */

#endif 	/* __UPnPRegistrar_FWD_DEFINED__ */


#ifndef __UPnPRemoteEndpointInfo_FWD_DEFINED__
#define __UPnPRemoteEndpointInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPRemoteEndpointInfo UPnPRemoteEndpointInfo;
#else
typedef struct UPnPRemoteEndpointInfo UPnPRemoteEndpointInfo;
#endif /* __cplusplus */

#endif 	/* __UPnPRemoteEndpointInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_upnphost_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------







#define UPNP_E_REQUIRED_ELEMENT_ERROR        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA020)
#define UPNP_E_DUPLICATE_NOT_ALLOWED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA021)
#define UPNP_E_DUPLICATE_SERVICE_ID          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA022)
#define UPNP_E_INVALID_DESCRIPTION           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA023)
#define UPNP_E_INVALID_SERVICE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA024)
#define UPNP_E_INVALID_ICON                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA025)
#define UPNP_E_INVALID_XML                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA026)
#define UPNP_E_INVALID_ROOT_NAMESPACE        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA027)
#define UPNP_E_SUFFIX_TOO_LONG               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA028)
#define UPNP_E_URLBASE_PRESENT               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA029)
#define UPNP_E_VALUE_TOO_LONG                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA030)
#define UPNP_E_DEVICE_RUNNING                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA031)
#define UPNP_E_DEVICE_NOTREGISTERED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA032)
// Remote address value is a string
#define REMOTE_ADDRESS_VALUE_NAME L"RemoteAddress"
// Address family value is a DWORD
#define ADDRESS_FAMILY_VALUE_NAME L"AddressFamily"


extern RPC_IF_HANDLE __MIDL_itf_upnphost_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_upnphost_0000_0000_v0_0_s_ifspec;

#ifndef __IUPnPEventSink_INTERFACE_DEFINED__
#define __IUPnPEventSink_INTERFACE_DEFINED__

/* interface IUPnPEventSink */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b4-73b2-11d4-bf42-00b0d0118b56")
    IUPnPEventSink : public IUnknown
    {
    public:
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE OnStateChanged( 
            /* [in] */ DWORD cChanges,
            /* [size_is][in] */ __RPC__in_ecount_full(cChanges) DISPID rgdispidChanges[  ]) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnStateChangedSafe( 
            /* [in] */ VARIANT varsadispidChanges) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPEventSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPEventSink * This);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnStateChanged )( 
            IUPnPEventSink * This,
            /* [in] */ DWORD cChanges,
            /* [size_is][in] */ __RPC__in_ecount_full(cChanges) DISPID rgdispidChanges[  ]);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnStateChangedSafe )( 
            IUPnPEventSink * This,
            /* [in] */ VARIANT varsadispidChanges);
        
        END_INTERFACE
    } IUPnPEventSinkVtbl;

    interface IUPnPEventSink
    {
        CONST_VTBL struct IUPnPEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPEventSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPEventSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPEventSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPEventSink_OnStateChanged(This,cChanges,rgdispidChanges)	\
    ( (This)->lpVtbl -> OnStateChanged(This,cChanges,rgdispidChanges) ) 

#define IUPnPEventSink_OnStateChangedSafe(This,varsadispidChanges)	\
    ( (This)->lpVtbl -> OnStateChangedSafe(This,varsadispidChanges) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPEventSink_INTERFACE_DEFINED__ */


#ifndef __IUPnPEventSource_INTERFACE_DEFINED__
#define __IUPnPEventSource_INTERFACE_DEFINED__

/* interface IUPnPEventSource */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPEventSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b5-73b2-11d4-bf42-00b0d0118b56")
    IUPnPEventSource : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IUPnPEventSink *pesSubscriber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ __RPC__in_opt IUPnPEventSink *pesSubscriber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPEventSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPEventSource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPEventSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPEventSource * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IUPnPEventSource * This,
            /* [in] */ __RPC__in_opt IUPnPEventSink *pesSubscriber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IUPnPEventSource * This,
            /* [in] */ __RPC__in_opt IUPnPEventSink *pesSubscriber);
        
        END_INTERFACE
    } IUPnPEventSourceVtbl;

    interface IUPnPEventSource
    {
        CONST_VTBL struct IUPnPEventSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPEventSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPEventSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPEventSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPEventSource_Advise(This,pesSubscriber)	\
    ( (This)->lpVtbl -> Advise(This,pesSubscriber) ) 

#define IUPnPEventSource_Unadvise(This,pesSubscriber)	\
    ( (This)->lpVtbl -> Unadvise(This,pesSubscriber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPEventSource_INTERFACE_DEFINED__ */


#ifndef __IUPnPRegistrar_INTERFACE_DEFINED__
#define __IUPnPRegistrar_INTERFACE_DEFINED__

/* interface IUPnPRegistrar */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b6-73b2-11d4-bf42-00b0d0118b56")
    IUPnPRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterDevice( 
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrProgIDDeviceControlClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterRunningDevice( 
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceControl,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterDeviceProvider( 
            /* [in] */ __RPC__in BSTR bstrProviderName,
            /* [in] */ __RPC__in BSTR bstrProgIDProviderClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUniqueDeviceName( 
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrTemplateUDN,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUDN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ BOOL fPermanent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterDeviceProvider( 
            /* [in] */ __RPC__in BSTR bstrProviderName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPRegistrar * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterDevice )( 
            IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrProgIDDeviceControlClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterRunningDevice )( 
            IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceControl,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterDeviceProvider )( 
            IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrProviderName,
            /* [in] */ __RPC__in BSTR bstrProgIDProviderClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueDeviceName )( 
            IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrTemplateUDN,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUDN);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterDevice )( 
            IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ BOOL fPermanent);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterDeviceProvider )( 
            IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrProviderName);
        
        END_INTERFACE
    } IUPnPRegistrarVtbl;

    interface IUPnPRegistrar
    {
        CONST_VTBL struct IUPnPRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPRegistrar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPRegistrar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPRegistrar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPRegistrar_RegisterDevice(This,bstrXMLDesc,bstrProgIDDeviceControlClass,bstrInitString,bstrContainerId,bstrResourcePath,nLifeTime,pbstrDeviceIdentifier)	\
    ( (This)->lpVtbl -> RegisterDevice(This,bstrXMLDesc,bstrProgIDDeviceControlClass,bstrInitString,bstrContainerId,bstrResourcePath,nLifeTime,pbstrDeviceIdentifier) ) 

#define IUPnPRegistrar_RegisterRunningDevice(This,bstrXMLDesc,punkDeviceControl,bstrInitString,bstrResourcePath,nLifeTime,pbstrDeviceIdentifier)	\
    ( (This)->lpVtbl -> RegisterRunningDevice(This,bstrXMLDesc,punkDeviceControl,bstrInitString,bstrResourcePath,nLifeTime,pbstrDeviceIdentifier) ) 

#define IUPnPRegistrar_RegisterDeviceProvider(This,bstrProviderName,bstrProgIDProviderClass,bstrInitString,bstrContainerId)	\
    ( (This)->lpVtbl -> RegisterDeviceProvider(This,bstrProviderName,bstrProgIDProviderClass,bstrInitString,bstrContainerId) ) 

#define IUPnPRegistrar_GetUniqueDeviceName(This,bstrDeviceIdentifier,bstrTemplateUDN,pbstrUDN)	\
    ( (This)->lpVtbl -> GetUniqueDeviceName(This,bstrDeviceIdentifier,bstrTemplateUDN,pbstrUDN) ) 

#define IUPnPRegistrar_UnregisterDevice(This,bstrDeviceIdentifier,fPermanent)	\
    ( (This)->lpVtbl -> UnregisterDevice(This,bstrDeviceIdentifier,fPermanent) ) 

#define IUPnPRegistrar_UnregisterDeviceProvider(This,bstrProviderName)	\
    ( (This)->lpVtbl -> UnregisterDeviceProvider(This,bstrProviderName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPRegistrar_INTERFACE_DEFINED__ */


#ifndef __IUPnPReregistrar_INTERFACE_DEFINED__
#define __IUPnPReregistrar_INTERFACE_DEFINED__

/* interface IUPnPReregistrar */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPReregistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b7-73b2-11d4-bf42-00b0d0118b56")
    IUPnPReregistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReregisterDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrProgIDDeviceControlClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReregisterRunningDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceControl,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPReregistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPReregistrar * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPReregistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPReregistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReregisterDevice )( 
            IUPnPReregistrar * This,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrProgIDDeviceControlClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime);
        
        HRESULT ( STDMETHODCALLTYPE *ReregisterRunningDevice )( 
            IUPnPReregistrar * This,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceControl,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime);
        
        END_INTERFACE
    } IUPnPReregistrarVtbl;

    interface IUPnPReregistrar
    {
        CONST_VTBL struct IUPnPReregistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPReregistrar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPReregistrar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPReregistrar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPReregistrar_ReregisterDevice(This,bstrDeviceIdentifier,bstrXMLDesc,bstrProgIDDeviceControlClass,bstrInitString,bstrContainerId,bstrResourcePath,nLifeTime)	\
    ( (This)->lpVtbl -> ReregisterDevice(This,bstrDeviceIdentifier,bstrXMLDesc,bstrProgIDDeviceControlClass,bstrInitString,bstrContainerId,bstrResourcePath,nLifeTime) ) 

#define IUPnPReregistrar_ReregisterRunningDevice(This,bstrDeviceIdentifier,bstrXMLDesc,punkDeviceControl,bstrInitString,bstrResourcePath,nLifeTime)	\
    ( (This)->lpVtbl -> ReregisterRunningDevice(This,bstrDeviceIdentifier,bstrXMLDesc,punkDeviceControl,bstrInitString,bstrResourcePath,nLifeTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPReregistrar_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceControl_INTERFACE_DEFINED__
#define __IUPnPDeviceControl_INTERFACE_DEFINED__

/* interface IUPnPDeviceControl */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPDeviceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810ba-73b2-11d4-bf42-00b0d0118b56")
    IUPnPDeviceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrInitString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceObject( 
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [in] */ __RPC__in BSTR bstrServiceId,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppdispService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDeviceControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDeviceControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDeviceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IUPnPDeviceControl * This,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrInitString);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceObject )( 
            IUPnPDeviceControl * This,
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [in] */ __RPC__in BSTR bstrServiceId,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppdispService);
        
        END_INTERFACE
    } IUPnPDeviceControlVtbl;

    interface IUPnPDeviceControl
    {
        CONST_VTBL struct IUPnPDeviceControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceControl_Initialize(This,bstrXMLDesc,bstrDeviceIdentifier,bstrInitString)	\
    ( (This)->lpVtbl -> Initialize(This,bstrXMLDesc,bstrDeviceIdentifier,bstrInitString) ) 

#define IUPnPDeviceControl_GetServiceObject(This,bstrUDN,bstrServiceId,ppdispService)	\
    ( (This)->lpVtbl -> GetServiceObject(This,bstrUDN,bstrServiceId,ppdispService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceControl_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceProvider_INTERFACE_DEFINED__
#define __IUPnPDeviceProvider_INTERFACE_DEFINED__

/* interface IUPnPDeviceProvider */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPDeviceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b8-73b2-11d4-bf42-00b0d0118b56")
    IUPnPDeviceProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ __RPC__in BSTR bstrInitString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDeviceProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDeviceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDeviceProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IUPnPDeviceProvider * This,
            /* [in] */ __RPC__in BSTR bstrInitString);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IUPnPDeviceProvider * This);
        
        END_INTERFACE
    } IUPnPDeviceProviderVtbl;

    interface IUPnPDeviceProvider
    {
        CONST_VTBL struct IUPnPDeviceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceProvider_Start(This,bstrInitString)	\
    ( (This)->lpVtbl -> Start(This,bstrInitString) ) 

#define IUPnPDeviceProvider_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceProvider_INTERFACE_DEFINED__ */


#ifndef __IUPnPRemoteEndpointInfo_INTERFACE_DEFINED__
#define __IUPnPRemoteEndpointInfo_INTERFACE_DEFINED__

/* interface IUPnPRemoteEndpointInfo */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPRemoteEndpointInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c92eb863-0269-4aff-9c72-75321bba2952")
    IUPnPRemoteEndpointInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDwordValue( 
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__out DWORD *pdwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringValue( 
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidValue( 
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__out GUID *pguidValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPRemoteEndpointInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPRemoteEndpointInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPRemoteEndpointInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPRemoteEndpointInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDwordValue )( 
            IUPnPRemoteEndpointInfo * This,
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__out DWORD *pdwValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            IUPnPRemoteEndpointInfo * This,
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidValue )( 
            IUPnPRemoteEndpointInfo * This,
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__out GUID *pguidValue);
        
        END_INTERFACE
    } IUPnPRemoteEndpointInfoVtbl;

    interface IUPnPRemoteEndpointInfo
    {
        CONST_VTBL struct IUPnPRemoteEndpointInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPRemoteEndpointInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPRemoteEndpointInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPRemoteEndpointInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPRemoteEndpointInfo_GetDwordValue(This,bstrValueName,pdwValue)	\
    ( (This)->lpVtbl -> GetDwordValue(This,bstrValueName,pdwValue) ) 

#define IUPnPRemoteEndpointInfo_GetStringValue(This,bstrValueName,pbstrValue)	\
    ( (This)->lpVtbl -> GetStringValue(This,bstrValueName,pbstrValue) ) 

#define IUPnPRemoteEndpointInfo_GetGuidValue(This,bstrValueName,pguidValue)	\
    ( (This)->lpVtbl -> GetGuidValue(This,bstrValueName,pguidValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPRemoteEndpointInfo_INTERFACE_DEFINED__ */



#ifndef __UPnPHostLib_LIBRARY_DEFINED__
#define __UPnPHostLib_LIBRARY_DEFINED__

/* library UPnPHostLib */
/* [helpstring][version][uuid] */ 









EXTERN_C const IID LIBID_UPnPHostLib;

EXTERN_C const CLSID CLSID_UPnPRegistrar;

#ifdef __cplusplus

class DECLSPEC_UUID("204810b9-73b2-11d4-bf42-00b0d0118b56")
UPnPRegistrar;
#endif

EXTERN_C const CLSID CLSID_UPnPRemoteEndpointInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("2e5e84e9-4049-4244-b728-2d24227157c7")
UPnPRemoteEndpointInfo;
#endif
#endif /* __UPnPHostLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\UrlHist.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for urlhist.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __urlhist_h__
#define __urlhist_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumSTATURL_FWD_DEFINED__
#define __IEnumSTATURL_FWD_DEFINED__
typedef interface IEnumSTATURL IEnumSTATURL;
#endif 	/* __IEnumSTATURL_FWD_DEFINED__ */


#ifndef __IUrlHistoryStg_FWD_DEFINED__
#define __IUrlHistoryStg_FWD_DEFINED__
typedef interface IUrlHistoryStg IUrlHistoryStg;
#endif 	/* __IUrlHistoryStg_FWD_DEFINED__ */


#ifndef __IUrlHistoryStg2_FWD_DEFINED__
#define __IUrlHistoryStg2_FWD_DEFINED__
typedef interface IUrlHistoryStg2 IUrlHistoryStg2;
#endif 	/* __IUrlHistoryStg2_FWD_DEFINED__ */


#ifndef __IUrlHistoryNotify_FWD_DEFINED__
#define __IUrlHistoryNotify_FWD_DEFINED__
typedef interface IUrlHistoryNotify IUrlHistoryNotify;
#endif 	/* __IUrlHistoryNotify_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "docobj.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_urlhist_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// UrlHist.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Url History Interfaces.



#define STATURL_QUERYFLAG_ISCACHED		0x00010000
#define STATURL_QUERYFLAG_NOURL              0x00020000
#define STATURL_QUERYFLAG_NOTITLE            0x00040000
#define STATURL_QUERYFLAG_TOPLEVEL           0x00080000
#define STATURLFLAG_ISCACHED		0x00000001
#define STATURLFLAG_ISTOPLEVEL       0x00000002
typedef 
enum _ADDURL_FLAG
    {	ADDURL_FIRST	= 0,
	ADDURL_ADDTOHISTORYANDCACHE	= 0,
	ADDURL_ADDTOCACHE	= 1,
	ADDURL_Max	= 2147483647L
    } 	ADDURL_FLAG;


////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMSTATURL_DEFINED
#define _LPENUMSTATURL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumSTATURL_INTERFACE_DEFINED__
#define __IEnumSTATURL_INTERFACE_DEFINED__

/* interface IEnumSTATURL */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumSTATURL *LPENUMSTATURL;

typedef struct _STATURL
    {
    DWORD cbSize;
    LPWSTR pwcsUrl;
    LPWSTR pwcsTitle;
    FILETIME ftLastVisited;
    FILETIME ftLastUpdated;
    FILETIME ftExpires;
    DWORD dwFlags;
    } 	STATURL;

typedef struct _STATURL *LPSTATURL;


EXTERN_C const IID IID_IEnumSTATURL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C374A42-BAE4-11CF-BF7D-00AA006946EE")
    IEnumSTATURL : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out][in] */ __RPC__inout LPSTATURL rgelt,
            /* [out][in] */ __RPC__inout ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilter( 
            /* [unique][in] */ __RPC__in_opt LPCOLESTR poszFilter,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATURLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSTATURL * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSTATURL * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSTATURL * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSTATURL * This,
            /* [in] */ ULONG celt,
            /* [out][in] */ __RPC__inout LPSTATURL rgelt,
            /* [out][in] */ __RPC__inout ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSTATURL * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSTATURL * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSTATURL * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            IEnumSTATURL * This,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR poszFilter,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IEnumSTATURLVtbl;

    interface IEnumSTATURL
    {
        CONST_VTBL struct IEnumSTATURLVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATURL_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSTATURL_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSTATURL_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSTATURL_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSTATURL_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSTATURL_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSTATURL_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumSTATURL_SetFilter(This,poszFilter,dwFlags)	\
    ( (This)->lpVtbl -> SetFilter(This,poszFilter,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSTATURL_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlhist_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPURLHISTORYSTG_DEFINED
#define _LPURLHISTORYSTG_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0001_v0_0_s_ifspec;

#ifndef __IUrlHistoryStg_INTERFACE_DEFINED__
#define __IUrlHistoryStg_INTERFACE_DEFINED__

/* interface IUrlHistoryStg */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IUrlHistoryStg *LPURLHISTORYSTG;


EXTERN_C const IID IID_IUrlHistoryStg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C374A41-BAE4-11CF-BF7D-00AA006946EE")
    IUrlHistoryStg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddUrl( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteUrl( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryUrl( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags,
            /* [unique][out][in] */ __RPC__inout_opt LPSTATURL lpSTATURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumUrls( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUrlHistoryStgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUrlHistoryStg * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUrlHistoryStg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUrlHistoryStg * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddUrl )( 
            IUrlHistoryStg * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteUrl )( 
            IUrlHistoryStg * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryUrl )( 
            IUrlHistoryStg * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags,
            /* [unique][out][in] */ __RPC__inout_opt LPSTATURL lpSTATURL);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IUrlHistoryStg * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut);
        
        HRESULT ( STDMETHODCALLTYPE *EnumUrls )( 
            IUrlHistoryStg * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppEnum);
        
        END_INTERFACE
    } IUrlHistoryStgVtbl;

    interface IUrlHistoryStg
    {
        CONST_VTBL struct IUrlHistoryStgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUrlHistoryStg_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUrlHistoryStg_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUrlHistoryStg_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUrlHistoryStg_AddUrl(This,pocsUrl,pocsTitle,dwFlags)	\
    ( (This)->lpVtbl -> AddUrl(This,pocsUrl,pocsTitle,dwFlags) ) 

#define IUrlHistoryStg_DeleteUrl(This,pocsUrl,dwFlags)	\
    ( (This)->lpVtbl -> DeleteUrl(This,pocsUrl,dwFlags) ) 

#define IUrlHistoryStg_QueryUrl(This,pocsUrl,dwFlags,lpSTATURL)	\
    ( (This)->lpVtbl -> QueryUrl(This,pocsUrl,dwFlags,lpSTATURL) ) 

#define IUrlHistoryStg_BindToObject(This,pocsUrl,riid,ppvOut)	\
    ( (This)->lpVtbl -> BindToObject(This,pocsUrl,riid,ppvOut) ) 

#define IUrlHistoryStg_EnumUrls(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumUrls(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUrlHistoryStg_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlhist_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPURLHISTORYSTG2_DEFINED
#define _LPURLHISTORYSTG2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0002_v0_0_s_ifspec;

#ifndef __IUrlHistoryStg2_INTERFACE_DEFINED__
#define __IUrlHistoryStg2_INTERFACE_DEFINED__

/* interface IUrlHistoryStg2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IUrlHistoryStg2 *LPURLHISTORYSTG2;


EXTERN_C const IID IID_IUrlHistoryStg2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AFA0DC11-C313-11d0-831A-00C04FD5AE38")
    IUrlHistoryStg2 : public IUrlHistoryStg
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddUrlAndNotify( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL fWriteHistory,
            /* [in] */ __RPC__in_opt IOleCommandTarget *poctNotify,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkISFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearHistory( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUrlHistoryStg2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUrlHistoryStg2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUrlHistoryStg2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddUrl )( 
            IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteUrl )( 
            IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryUrl )( 
            IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags,
            /* [unique][out][in] */ __RPC__inout_opt LPSTATURL lpSTATURL);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut);
        
        HRESULT ( STDMETHODCALLTYPE *EnumUrls )( 
            IUrlHistoryStg2 * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *AddUrlAndNotify )( 
            IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL fWriteHistory,
            /* [in] */ __RPC__in_opt IOleCommandTarget *poctNotify,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkISFolder);
        
        HRESULT ( STDMETHODCALLTYPE *ClearHistory )( 
            IUrlHistoryStg2 * This);
        
        END_INTERFACE
    } IUrlHistoryStg2Vtbl;

    interface IUrlHistoryStg2
    {
        CONST_VTBL struct IUrlHistoryStg2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUrlHistoryStg2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUrlHistoryStg2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUrlHistoryStg2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUrlHistoryStg2_AddUrl(This,pocsUrl,pocsTitle,dwFlags)	\
    ( (This)->lpVtbl -> AddUrl(This,pocsUrl,pocsTitle,dwFlags) ) 

#define IUrlHistoryStg2_DeleteUrl(This,pocsUrl,dwFlags)	\
    ( (This)->lpVtbl -> DeleteUrl(This,pocsUrl,dwFlags) ) 

#define IUrlHistoryStg2_QueryUrl(This,pocsUrl,dwFlags,lpSTATURL)	\
    ( (This)->lpVtbl -> QueryUrl(This,pocsUrl,dwFlags,lpSTATURL) ) 

#define IUrlHistoryStg2_BindToObject(This,pocsUrl,riid,ppvOut)	\
    ( (This)->lpVtbl -> BindToObject(This,pocsUrl,riid,ppvOut) ) 

#define IUrlHistoryStg2_EnumUrls(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumUrls(This,ppEnum) ) 


#define IUrlHistoryStg2_AddUrlAndNotify(This,pocsUrl,pocsTitle,dwFlags,fWriteHistory,poctNotify,punkISFolder)	\
    ( (This)->lpVtbl -> AddUrlAndNotify(This,pocsUrl,pocsTitle,dwFlags,fWriteHistory,poctNotify,punkISFolder) ) 

#define IUrlHistoryStg2_ClearHistory(This)	\
    ( (This)->lpVtbl -> ClearHistory(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUrlHistoryStg2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlhist_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPURLHISTORYNOTIFY_DEFINED
#define _LPURLHISTORYNOTIFY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0003_v0_0_s_ifspec;

#ifndef __IUrlHistoryNotify_INTERFACE_DEFINED__
#define __IUrlHistoryNotify_INTERFACE_DEFINED__

/* interface IUrlHistoryNotify */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IUrlHistoryNotify *LPURLHISTORYNOTIFY;


EXTERN_C const IID IID_IUrlHistoryNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BC40BEC1-C493-11d0-831B-00C04FD5AE38")
    IUrlHistoryNotify : public IOleCommandTarget
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IUrlHistoryNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUrlHistoryNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUrlHistoryNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUrlHistoryNotify * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IUrlHistoryNotify * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ __RPC__inout_ecount_full(cCmds) OLECMD prgCmds[  ],
            /* [unique][out][in] */ __RPC__inout_opt OLECMDTEXT *pCmdText);
        
        HRESULT ( STDMETHODCALLTYPE *Exec )( 
            IUrlHistoryNotify * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvaIn,
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvaOut);
        
        END_INTERFACE
    } IUrlHistoryNotifyVtbl;

    interface IUrlHistoryNotify
    {
        CONST_VTBL struct IUrlHistoryNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUrlHistoryNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUrlHistoryNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUrlHistoryNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUrlHistoryNotify_QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText)	\
    ( (This)->lpVtbl -> QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText) ) 

#define IUrlHistoryNotify_Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut)	\
    ( (This)->lpVtbl -> Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUrlHistoryNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlhist_0000_0004 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\UPnP.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for upnp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __upnp_h__
#define __upnp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUPnPDeviceFinder_FWD_DEFINED__
#define __IUPnPDeviceFinder_FWD_DEFINED__
typedef interface IUPnPDeviceFinder IUPnPDeviceFinder;
#endif 	/* __IUPnPDeviceFinder_FWD_DEFINED__ */


#ifndef __IUPnPAddressFamilyControl_FWD_DEFINED__
#define __IUPnPAddressFamilyControl_FWD_DEFINED__
typedef interface IUPnPAddressFamilyControl IUPnPAddressFamilyControl;
#endif 	/* __IUPnPAddressFamilyControl_FWD_DEFINED__ */


#ifndef __IUPnPDeviceFinderCallback_FWD_DEFINED__
#define __IUPnPDeviceFinderCallback_FWD_DEFINED__
typedef interface IUPnPDeviceFinderCallback IUPnPDeviceFinderCallback;
#endif 	/* __IUPnPDeviceFinderCallback_FWD_DEFINED__ */


#ifndef __IUPnPServices_FWD_DEFINED__
#define __IUPnPServices_FWD_DEFINED__
typedef interface IUPnPServices IUPnPServices;
#endif 	/* __IUPnPServices_FWD_DEFINED__ */


#ifndef __IUPnPService_FWD_DEFINED__
#define __IUPnPService_FWD_DEFINED__
typedef interface IUPnPService IUPnPService;
#endif 	/* __IUPnPService_FWD_DEFINED__ */


#ifndef __IUPnPServiceCallback_FWD_DEFINED__
#define __IUPnPServiceCallback_FWD_DEFINED__
typedef interface IUPnPServiceCallback IUPnPServiceCallback;
#endif 	/* __IUPnPServiceCallback_FWD_DEFINED__ */


#ifndef __IUPnPDevices_FWD_DEFINED__
#define __IUPnPDevices_FWD_DEFINED__
typedef interface IUPnPDevices IUPnPDevices;
#endif 	/* __IUPnPDevices_FWD_DEFINED__ */


#ifndef __IUPnPDevice_FWD_DEFINED__
#define __IUPnPDevice_FWD_DEFINED__
typedef interface IUPnPDevice IUPnPDevice;
#endif 	/* __IUPnPDevice_FWD_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccess_FWD_DEFINED__
#define __IUPnPDeviceDocumentAccess_FWD_DEFINED__
typedef interface IUPnPDeviceDocumentAccess IUPnPDeviceDocumentAccess;
#endif 	/* __IUPnPDeviceDocumentAccess_FWD_DEFINED__ */


#ifndef __IUPnPDescriptionDocument_FWD_DEFINED__
#define __IUPnPDescriptionDocument_FWD_DEFINED__
typedef interface IUPnPDescriptionDocument IUPnPDescriptionDocument;
#endif 	/* __IUPnPDescriptionDocument_FWD_DEFINED__ */


#ifndef __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__
#define __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__
typedef interface IUPnPDeviceFinderAddCallbackWithInterface IUPnPDeviceFinderAddCallbackWithInterface;
#endif 	/* __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__ */


#ifndef __IUPnPDescriptionDocumentCallback_FWD_DEFINED__
#define __IUPnPDescriptionDocumentCallback_FWD_DEFINED__
typedef interface IUPnPDescriptionDocumentCallback IUPnPDescriptionDocumentCallback;
#endif 	/* __IUPnPDescriptionDocumentCallback_FWD_DEFINED__ */


#ifndef __UPnPDeviceFinder_FWD_DEFINED__
#define __UPnPDeviceFinder_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPDeviceFinder UPnPDeviceFinder;
#else
typedef struct UPnPDeviceFinder UPnPDeviceFinder;
#endif /* __cplusplus */

#endif 	/* __UPnPDeviceFinder_FWD_DEFINED__ */


#ifndef __UPnPDevices_FWD_DEFINED__
#define __UPnPDevices_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPDevices UPnPDevices;
#else
typedef struct UPnPDevices UPnPDevices;
#endif /* __cplusplus */

#endif 	/* __UPnPDevices_FWD_DEFINED__ */


#ifndef __UPnPDevice_FWD_DEFINED__
#define __UPnPDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPDevice UPnPDevice;
#else
typedef struct UPnPDevice UPnPDevice;
#endif /* __cplusplus */

#endif 	/* __UPnPDevice_FWD_DEFINED__ */


#ifndef __UPnPServices_FWD_DEFINED__
#define __UPnPServices_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPServices UPnPServices;
#else
typedef struct UPnPServices UPnPServices;
#endif /* __cplusplus */

#endif 	/* __UPnPServices_FWD_DEFINED__ */


#ifndef __UPnPService_FWD_DEFINED__
#define __UPnPService_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPService UPnPService;
#else
typedef struct UPnPService UPnPService;
#endif /* __cplusplus */

#endif 	/* __UPnPService_FWD_DEFINED__ */


#ifndef __UPnPDescriptionDocument_FWD_DEFINED__
#define __UPnPDescriptionDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPDescriptionDocument UPnPDescriptionDocument;
#else
typedef struct UPnPDescriptionDocument UPnPDescriptionDocument;
#endif /* __cplusplus */

#endif 	/* __UPnPDescriptionDocument_FWD_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccess_FWD_DEFINED__
#define __IUPnPDeviceDocumentAccess_FWD_DEFINED__
typedef interface IUPnPDeviceDocumentAccess IUPnPDeviceDocumentAccess;
#endif 	/* __IUPnPDeviceDocumentAccess_FWD_DEFINED__ */


#ifndef __IUPnPDeviceFinderCallback_FWD_DEFINED__
#define __IUPnPDeviceFinderCallback_FWD_DEFINED__
typedef interface IUPnPDeviceFinderCallback IUPnPDeviceFinderCallback;
#endif 	/* __IUPnPDeviceFinderCallback_FWD_DEFINED__ */


#ifndef __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__
#define __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__
typedef interface IUPnPDeviceFinderAddCallbackWithInterface IUPnPDeviceFinderAddCallbackWithInterface;
#endif 	/* __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__ */


#ifndef __IUPnPServiceCallback_FWD_DEFINED__
#define __IUPnPServiceCallback_FWD_DEFINED__
typedef interface IUPnPServiceCallback IUPnPServiceCallback;
#endif 	/* __IUPnPServiceCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_upnp_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------












#define UPNP_E_ROOT_ELEMENT_EXPECTED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)
#define UPNP_E_DEVICE_ELEMENT_EXPECTED   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)
#define UPNP_E_SERVICE_ELEMENT_EXPECTED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)
#define UPNP_E_SERVICE_NODE_INCOMPLETE   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)
#define UPNP_E_DEVICE_NODE_INCOMPLETE    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)
#define UPNP_E_ICON_ELEMENT_EXPECTED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)
#define UPNP_E_ICON_NODE_INCOMPLETE      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)
#define UPNP_E_INVALID_ACTION            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0207)
#define UPNP_E_INVALID_ARGUMENTS         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0208)
#define UPNP_E_OUT_OF_SYNC               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0209)
#define UPNP_E_ACTION_REQUEST_FAILED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0210)
#define UPNP_E_TRANSPORT_ERROR           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0211)
#define UPNP_E_VARIABLE_VALUE_UNKNOWN    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0212)
#define UPNP_E_INVALID_VARIABLE          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0213)
#define UPNP_E_DEVICE_ERROR              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0214)
#define UPNP_E_PROTOCOL_ERROR            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0215)
#define UPNP_E_ERROR_PROCESSING_RESPONSE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0216)
#define UPNP_E_DEVICE_TIMEOUT            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0217)
#define UPNP_E_INVALID_DOCUMENT          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0500)
#define UPNP_E_EVENT_SUBSCRIPTION_FAILED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0501)
#define FAULT_INVALID_ACTION             401
#define FAULT_INVALID_ARG                402
#define FAULT_INVALID_SEQUENCE_NUMBER    403
#define FAULT_INVALID_VARIABLE           404
#define FAULT_DEVICE_INTERNAL_ERROR      501
#define FAULT_ACTION_SPECIFIC_BASE       600
#define FAULT_ACTION_SPECIFIC_MAX        899
#define UPNP_E_ACTION_SPECIFIC_BASE      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0300)
#define UPNP_E_ACTION_SPECIFIC_MAX       (UPNP_E_ACTION_SPECIFIC_BASE + (FAULT_ACTION_SPECIFIC_MAX - FAULT_ACTION_SPECIFIC_BASE))
#ifndef UPNP_ADDRESSFAMILY_IPv4
#define UPNP_ADDRESSFAMILY_IPv4		0x1
#endif
#ifndef UPNP_ADDRESSFAMILY_IPv6
#define UPNP_ADDRESSFAMILY_IPv6		0x2
#endif
#ifndef UPNP_ADDRESSFAMILY_BOTH
#define UPNP_ADDRESSFAMILY_BOTH		0x3
#endif


extern RPC_IF_HANDLE __MIDL_itf_upnp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_upnp_0000_0000_v0_0_s_ifspec;

#ifndef __IUPnPDeviceFinder_INTERFACE_DEFINED__
#define __IUPnPDeviceFinder_INTERFACE_DEFINED__

/* interface IUPnPDeviceFinder */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceFinder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ADDA3D55-6F72-4319-BFF9-18600A539B10")
    IUPnPDeviceFinder : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FindByType( 
            /* [in] */ __RPC__in BSTR bstrTypeURI,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevices **pDevices) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAsyncFind( 
            /* [in] */ __RPC__in BSTR bstrTypeURI,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceFinderCallback,
            /* [retval][out] */ __RPC__out LONG *plFindData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartAsyncFind( 
            /* [in] */ LONG lFindData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelAsyncFind( 
            /* [in] */ LONG lFindData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FindByUDN( 
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **pDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceFinderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDeviceFinder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDeviceFinder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUPnPDeviceFinder * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUPnPDeviceFinder * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPDeviceFinder * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FindByType )( 
            IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in BSTR bstrTypeURI,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevices **pDevices);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateAsyncFind )( 
            IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in BSTR bstrTypeURI,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceFinderCallback,
            /* [retval][out] */ __RPC__out LONG *plFindData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartAsyncFind )( 
            IUPnPDeviceFinder * This,
            /* [in] */ LONG lFindData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CancelAsyncFind )( 
            IUPnPDeviceFinder * This,
            /* [in] */ LONG lFindData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FindByUDN )( 
            IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **pDevice);
        
        END_INTERFACE
    } IUPnPDeviceFinderVtbl;

    interface IUPnPDeviceFinder
    {
        CONST_VTBL struct IUPnPDeviceFinderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceFinder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceFinder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceFinder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceFinder_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPDeviceFinder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPDeviceFinder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPDeviceFinder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPDeviceFinder_FindByType(This,bstrTypeURI,dwFlags,pDevices)	\
    ( (This)->lpVtbl -> FindByType(This,bstrTypeURI,dwFlags,pDevices) ) 

#define IUPnPDeviceFinder_CreateAsyncFind(This,bstrTypeURI,dwFlags,punkDeviceFinderCallback,plFindData)	\
    ( (This)->lpVtbl -> CreateAsyncFind(This,bstrTypeURI,dwFlags,punkDeviceFinderCallback,plFindData) ) 

#define IUPnPDeviceFinder_StartAsyncFind(This,lFindData)	\
    ( (This)->lpVtbl -> StartAsyncFind(This,lFindData) ) 

#define IUPnPDeviceFinder_CancelAsyncFind(This,lFindData)	\
    ( (This)->lpVtbl -> CancelAsyncFind(This,lFindData) ) 

#define IUPnPDeviceFinder_FindByUDN(This,bstrUDN,pDevice)	\
    ( (This)->lpVtbl -> FindByUDN(This,bstrUDN,pDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceFinder_INTERFACE_DEFINED__ */


#ifndef __IUPnPAddressFamilyControl_INTERFACE_DEFINED__
#define __IUPnPAddressFamilyControl_INTERFACE_DEFINED__

/* interface IUPnPAddressFamilyControl */
/* [unique][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IUPnPAddressFamilyControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3BF6178-694E-459F-A5A6-191EA0FFA1C7")
    IUPnPAddressFamilyControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAddressFamily( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressFamily( 
            /* [out] */ __RPC__out LONG *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPAddressFamilyControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPAddressFamilyControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPAddressFamilyControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPAddressFamilyControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAddressFamily )( 
            IUPnPAddressFamilyControl * This,
            /* [in] */ LONG dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressFamily )( 
            IUPnPAddressFamilyControl * This,
            /* [out] */ __RPC__out LONG *pdwFlags);
        
        END_INTERFACE
    } IUPnPAddressFamilyControlVtbl;

    interface IUPnPAddressFamilyControl
    {
        CONST_VTBL struct IUPnPAddressFamilyControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPAddressFamilyControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPAddressFamilyControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPAddressFamilyControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPAddressFamilyControl_SetAddressFamily(This,dwFlags)	\
    ( (This)->lpVtbl -> SetAddressFamily(This,dwFlags) ) 

#define IUPnPAddressFamilyControl_GetAddressFamily(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetAddressFamily(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPAddressFamilyControl_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceFinderCallback_INTERFACE_DEFINED__
#define __IUPnPDeviceFinderCallback_INTERFACE_DEFINED__

/* interface IUPnPDeviceFinderCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceFinderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("415A984A-88B3-49F3-92AF-0508BEDF0D6C")
    IUPnPDeviceFinderCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeviceAdded( 
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in_opt IUPnPDevice *pDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeviceRemoved( 
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in BSTR bstrUDN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SearchComplete( 
            /* [in] */ LONG lFindData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceFinderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDeviceFinderCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDeviceFinderCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDeviceFinderCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceAdded )( 
            IUPnPDeviceFinderCallback * This,
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in_opt IUPnPDevice *pDevice);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceRemoved )( 
            IUPnPDeviceFinderCallback * This,
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in BSTR bstrUDN);
        
        HRESULT ( STDMETHODCALLTYPE *SearchComplete )( 
            IUPnPDeviceFinderCallback * This,
            /* [in] */ LONG lFindData);
        
        END_INTERFACE
    } IUPnPDeviceFinderCallbackVtbl;

    interface IUPnPDeviceFinderCallback
    {
        CONST_VTBL struct IUPnPDeviceFinderCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceFinderCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceFinderCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceFinderCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceFinderCallback_DeviceAdded(This,lFindData,pDevice)	\
    ( (This)->lpVtbl -> DeviceAdded(This,lFindData,pDevice) ) 

#define IUPnPDeviceFinderCallback_DeviceRemoved(This,lFindData,bstrUDN)	\
    ( (This)->lpVtbl -> DeviceRemoved(This,lFindData,bstrUDN) ) 

#define IUPnPDeviceFinderCallback_SearchComplete(This,lFindData)	\
    ( (This)->lpVtbl -> SearchComplete(This,lFindData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceFinderCallback_INTERFACE_DEFINED__ */


#ifndef __IUPnPServices_INTERFACE_DEFINED__
#define __IUPnPServices_INTERFACE_DEFINED__

/* interface IUPnPServices */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F8C8E9E-9A7A-4DC8-BC41-FF31FA374956")
    IUPnPServices : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *ppunk) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR bstrServiceId,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPService **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUPnPServices * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUPnPServices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUPnPServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPServices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IUPnPServices * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IUPnPServices * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *ppunk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IUPnPServices * This,
            /* [in] */ __RPC__in BSTR bstrServiceId,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPService **ppService);
        
        END_INTERFACE
    } IUPnPServicesVtbl;

    interface IUPnPServices
    {
        CONST_VTBL struct IUPnPServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPServices_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPServices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPServices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPServices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPServices_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IUPnPServices_get__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunk) ) 

#define IUPnPServices_get_Item(This,bstrServiceId,ppService)	\
    ( (This)->lpVtbl -> get_Item(This,bstrServiceId,ppService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPServices_INTERFACE_DEFINED__ */


#ifndef __IUPnPService_INTERFACE_DEFINED__
#define __IUPnPService_INTERFACE_DEFINED__

/* interface IUPnPService */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A295019C-DC65-47DD-90DC-7FE918A1AB44")
    IUPnPService : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryStateVariable( 
            /* [in] */ __RPC__in BSTR bstrVariableName,
            /* [retval][out] */ __RPC__out VARIANT *pValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InvokeAction( 
            /* [in] */ __RPC__in BSTR bstrActionName,
            /* [in] */ VARIANT vInActionArgs,
            /* [out][in] */ __RPC__inout VARIANT *pvOutActionArgs,
            /* [retval][out] */ __RPC__out VARIANT *pvRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceTypeIdentifier( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddCallback( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkCallback) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastTransportStatus( 
            /* [retval][out] */ __RPC__out long *plValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUPnPService * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUPnPService * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUPnPService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPService * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryStateVariable )( 
            IUPnPService * This,
            /* [in] */ __RPC__in BSTR bstrVariableName,
            /* [retval][out] */ __RPC__out VARIANT *pValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InvokeAction )( 
            IUPnPService * This,
            /* [in] */ __RPC__in BSTR bstrActionName,
            /* [in] */ VARIANT vInActionArgs,
            /* [out][in] */ __RPC__inout VARIANT *pvOutActionArgs,
            /* [retval][out] */ __RPC__out VARIANT *pvRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceTypeIdentifier )( 
            IUPnPService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddCallback )( 
            IUPnPService * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkCallback);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IUPnPService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastTransportStatus )( 
            IUPnPService * This,
            /* [retval][out] */ __RPC__out long *plValue);
        
        END_INTERFACE
    } IUPnPServiceVtbl;

    interface IUPnPService
    {
        CONST_VTBL struct IUPnPServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPService_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPService_QueryStateVariable(This,bstrVariableName,pValue)	\
    ( (This)->lpVtbl -> QueryStateVariable(This,bstrVariableName,pValue) ) 

#define IUPnPService_InvokeAction(This,bstrActionName,vInActionArgs,pvOutActionArgs,pvRetVal)	\
    ( (This)->lpVtbl -> InvokeAction(This,bstrActionName,vInActionArgs,pvOutActionArgs,pvRetVal) ) 

#define IUPnPService_get_ServiceTypeIdentifier(This,pVal)	\
    ( (This)->lpVtbl -> get_ServiceTypeIdentifier(This,pVal) ) 

#define IUPnPService_AddCallback(This,pUnkCallback)	\
    ( (This)->lpVtbl -> AddCallback(This,pUnkCallback) ) 

#define IUPnPService_get_Id(This,pbstrId)	\
    ( (This)->lpVtbl -> get_Id(This,pbstrId) ) 

#define IUPnPService_get_LastTransportStatus(This,plValue)	\
    ( (This)->lpVtbl -> get_LastTransportStatus(This,plValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPService_INTERFACE_DEFINED__ */


#ifndef __IUPnPServiceCallback_INTERFACE_DEFINED__
#define __IUPnPServiceCallback_INTERFACE_DEFINED__

/* interface IUPnPServiceCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPServiceCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31fadca9-ab73-464b-b67d-5c1d0f83c8b8")
    IUPnPServiceCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StateVariableChanged( 
            /* [in] */ __RPC__in_opt IUPnPService *pus,
            /* [in] */ __RPC__in LPCWSTR pcwszStateVarName,
            /* [in] */ VARIANT vaValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ServiceInstanceDied( 
            /* [in] */ __RPC__in_opt IUPnPService *pus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPServiceCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPServiceCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPServiceCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPServiceCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *StateVariableChanged )( 
            IUPnPServiceCallback * This,
            /* [in] */ __RPC__in_opt IUPnPService *pus,
            /* [in] */ __RPC__in LPCWSTR pcwszStateVarName,
            /* [in] */ VARIANT vaValue);
        
        HRESULT ( STDMETHODCALLTYPE *ServiceInstanceDied )( 
            IUPnPServiceCallback * This,
            /* [in] */ __RPC__in_opt IUPnPService *pus);
        
        END_INTERFACE
    } IUPnPServiceCallbackVtbl;

    interface IUPnPServiceCallback
    {
        CONST_VTBL struct IUPnPServiceCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPServiceCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPServiceCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPServiceCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPServiceCallback_StateVariableChanged(This,pus,pcwszStateVarName,vaValue)	\
    ( (This)->lpVtbl -> StateVariableChanged(This,pus,pcwszStateVarName,vaValue) ) 

#define IUPnPServiceCallback_ServiceInstanceDied(This,pus)	\
    ( (This)->lpVtbl -> ServiceInstanceDied(This,pus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPServiceCallback_INTERFACE_DEFINED__ */


#ifndef __IUPnPDevices_INTERFACE_DEFINED__
#define __IUPnPDevices_INTERFACE_DEFINED__

/* interface IUPnPDevices */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBC0C73-BDA3-4C66-AC4F-F2D96FDAD68C")
    IUPnPDevices : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *ppunk) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDevices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUPnPDevices * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUPnPDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUPnPDevices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IUPnPDevices * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IUPnPDevices * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *ppunk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IUPnPDevices * This,
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppDevice);
        
        END_INTERFACE
    } IUPnPDevicesVtbl;

    interface IUPnPDevices
    {
        CONST_VTBL struct IUPnPDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDevices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDevices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDevices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDevices_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPDevices_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IUPnPDevices_get__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunk) ) 

#define IUPnPDevices_get_Item(This,bstrUDN,ppDevice)	\
    ( (This)->lpVtbl -> get_Item(This,bstrUDN,ppDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDevices_INTERFACE_DEFINED__ */


#ifndef __IUPnPDevice_INTERFACE_DEFINED__
#define __IUPnPDevice_INTERFACE_DEFINED__

/* interface IUPnPDevice */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D44D0D1-98C9-4889-ACD1-F9D674BF2221")
    IUPnPDevice : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsRootDevice( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvarb) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RootDevice( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudRootDevice) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ParentDevice( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudDeviceParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasChildren( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvarb) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Children( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevices **ppudChildren) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UniqueDeviceName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PresentationURL( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ManufacturerName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ManufacturerURL( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModelName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModelNumber( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModelURL( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UPC( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SerialNumber( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IconURL( 
            /* [in] */ __RPC__in BSTR bstrEncodingFormat,
            /* [in] */ LONG lSizeX,
            /* [in] */ LONG lSizeY,
            /* [in] */ LONG lBitDepth,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrIconURL) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Services( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPServices **ppusServices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUPnPDevice * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUPnPDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUPnPDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsRootDevice )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvarb);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootDevice )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudRootDevice);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentDevice )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudDeviceParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasChildren )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvarb);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Children )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevices **ppudChildren);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueDeviceName )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresentationURL )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ManufacturerName )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ManufacturerURL )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModelName )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModelNumber )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModelURL )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UPC )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SerialNumber )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IconURL )( 
            IUPnPDevice * This,
            /* [in] */ __RPC__in BSTR bstrEncodingFormat,
            /* [in] */ LONG lSizeX,
            /* [in] */ LONG lSizeY,
            /* [in] */ LONG lBitDepth,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrIconURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Services )( 
            IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPServices **ppusServices);
        
        END_INTERFACE
    } IUPnPDeviceVtbl;

    interface IUPnPDevice
    {
        CONST_VTBL struct IUPnPDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDevice_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPDevice_get_IsRootDevice(This,pvarb)	\
    ( (This)->lpVtbl -> get_IsRootDevice(This,pvarb) ) 

#define IUPnPDevice_get_RootDevice(This,ppudRootDevice)	\
    ( (This)->lpVtbl -> get_RootDevice(This,ppudRootDevice) ) 

#define IUPnPDevice_get_ParentDevice(This,ppudDeviceParent)	\
    ( (This)->lpVtbl -> get_ParentDevice(This,ppudDeviceParent) ) 

#define IUPnPDevice_get_HasChildren(This,pvarb)	\
    ( (This)->lpVtbl -> get_HasChildren(This,pvarb) ) 

#define IUPnPDevice_get_Children(This,ppudChildren)	\
    ( (This)->lpVtbl -> get_Children(This,ppudChildren) ) 

#define IUPnPDevice_get_UniqueDeviceName(This,pbstr)	\
    ( (This)->lpVtbl -> get_UniqueDeviceName(This,pbstr) ) 

#define IUPnPDevice_get_FriendlyName(This,pbstr)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pbstr) ) 

#define IUPnPDevice_get_Type(This,pbstr)	\
    ( (This)->lpVtbl -> get_Type(This,pbstr) ) 

#define IUPnPDevice_get_PresentationURL(This,pbstr)	\
    ( (This)->lpVtbl -> get_PresentationURL(This,pbstr) ) 

#define IUPnPDevice_get_ManufacturerName(This,pbstr)	\
    ( (This)->lpVtbl -> get_ManufacturerName(This,pbstr) ) 

#define IUPnPDevice_get_ManufacturerURL(This,pbstr)	\
    ( (This)->lpVtbl -> get_ManufacturerURL(This,pbstr) ) 

#define IUPnPDevice_get_ModelName(This,pbstr)	\
    ( (This)->lpVtbl -> get_ModelName(This,pbstr) ) 

#define IUPnPDevice_get_ModelNumber(This,pbstr)	\
    ( (This)->lpVtbl -> get_ModelNumber(This,pbstr) ) 

#define IUPnPDevice_get_Description(This,pbstr)	\
    ( (This)->lpVtbl -> get_Description(This,pbstr) ) 

#define IUPnPDevice_get_ModelURL(This,pbstr)	\
    ( (This)->lpVtbl -> get_ModelURL(This,pbstr) ) 

#define IUPnPDevice_get_UPC(This,pbstr)	\
    ( (This)->lpVtbl -> get_UPC(This,pbstr) ) 

#define IUPnPDevice_get_SerialNumber(This,pbstr)	\
    ( (This)->lpVtbl -> get_SerialNumber(This,pbstr) ) 

#define IUPnPDevice_IconURL(This,bstrEncodingFormat,lSizeX,lSizeY,lBitDepth,pbstrIconURL)	\
    ( (This)->lpVtbl -> IconURL(This,bstrEncodingFormat,lSizeX,lSizeY,lBitDepth,pbstrIconURL) ) 

#define IUPnPDevice_get_Services(This,ppusServices)	\
    ( (This)->lpVtbl -> get_Services(This,ppusServices) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDevice_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccess_INTERFACE_DEFINED__
#define __IUPnPDeviceDocumentAccess_INTERFACE_DEFINED__

/* interface IUPnPDeviceDocumentAccess */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceDocumentAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7772804-3287-418e-9072-CF2B47238981")
    IUPnPDeviceDocumentAccess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentURL( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDocument) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceDocumentAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDeviceDocumentAccess * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDeviceDocumentAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDeviceDocumentAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentURL )( 
            IUPnPDeviceDocumentAccess * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDocument);
        
        END_INTERFACE
    } IUPnPDeviceDocumentAccessVtbl;

    interface IUPnPDeviceDocumentAccess
    {
        CONST_VTBL struct IUPnPDeviceDocumentAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceDocumentAccess_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceDocumentAccess_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceDocumentAccess_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceDocumentAccess_GetDocumentURL(This,pbstrDocument)	\
    ( (This)->lpVtbl -> GetDocumentURL(This,pbstrDocument) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceDocumentAccess_INTERFACE_DEFINED__ */


#ifndef __IUPnPDescriptionDocument_INTERFACE_DEFINED__
#define __IUPnPDescriptionDocument_INTERFACE_DEFINED__

/* interface IUPnPDescriptionDocument */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDescriptionDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11d1c1b2-7daa-4c9e-9595-7f82ed206d1e")
    IUPnPDescriptionDocument : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [retval][out] */ __RPC__out LONG *plReadyState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ __RPC__in BSTR bstrUrl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadAsync( 
            /* [in] */ __RPC__in BSTR bstrUrl,
            /* [in] */ __RPC__in_opt IUnknown *punkCallback) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoadResult( 
            /* [retval][out] */ __RPC__out long *phrError) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RootDevice( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudRootDevice) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeviceByUDN( 
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDescriptionDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDescriptionDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDescriptionDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUPnPDescriptionDocument * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUPnPDescriptionDocument * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPDescriptionDocument * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReadyState )( 
            IUPnPDescriptionDocument * This,
            /* [retval][out] */ __RPC__out LONG *plReadyState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Load )( 
            IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in BSTR bstrUrl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoadAsync )( 
            IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in BSTR bstrUrl,
            /* [in] */ __RPC__in_opt IUnknown *punkCallback);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoadResult )( 
            IUPnPDescriptionDocument * This,
            /* [retval][out] */ __RPC__out long *phrError);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IUPnPDescriptionDocument * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RootDevice )( 
            IUPnPDescriptionDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudRootDevice);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeviceByUDN )( 
            IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudDevice);
        
        END_INTERFACE
    } IUPnPDescriptionDocumentVtbl;

    interface IUPnPDescriptionDocument
    {
        CONST_VTBL struct IUPnPDescriptionDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDescriptionDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDescriptionDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDescriptionDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDescriptionDocument_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPDescriptionDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPDescriptionDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPDescriptionDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPDescriptionDocument_get_ReadyState(This,plReadyState)	\
    ( (This)->lpVtbl -> get_ReadyState(This,plReadyState) ) 

#define IUPnPDescriptionDocument_Load(This,bstrUrl)	\
    ( (This)->lpVtbl -> Load(This,bstrUrl) ) 

#define IUPnPDescriptionDocument_LoadAsync(This,bstrUrl,punkCallback)	\
    ( (This)->lpVtbl -> LoadAsync(This,bstrUrl,punkCallback) ) 

#define IUPnPDescriptionDocument_get_LoadResult(This,phrError)	\
    ( (This)->lpVtbl -> get_LoadResult(This,phrError) ) 

#define IUPnPDescriptionDocument_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IUPnPDescriptionDocument_RootDevice(This,ppudRootDevice)	\
    ( (This)->lpVtbl -> RootDevice(This,ppudRootDevice) ) 

#define IUPnPDescriptionDocument_DeviceByUDN(This,bstrUDN,ppudDevice)	\
    ( (This)->lpVtbl -> DeviceByUDN(This,bstrUDN,ppudDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDescriptionDocument_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceFinderAddCallbackWithInterface_INTERFACE_DEFINED__
#define __IUPnPDeviceFinderAddCallbackWithInterface_INTERFACE_DEFINED__

/* interface IUPnPDeviceFinderAddCallbackWithInterface */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceFinderAddCallbackWithInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("983dfc0b-1796-44df-8975-ca545b620ee5")
    IUPnPDeviceFinderAddCallbackWithInterface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeviceAddedWithInterface( 
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in_opt IUPnPDevice *pDevice,
            /* [in] */ __RPC__in GUID *pguidInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceFinderAddCallbackWithInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDeviceFinderAddCallbackWithInterface * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDeviceFinderAddCallbackWithInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDeviceFinderAddCallbackWithInterface * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceAddedWithInterface )( 
            IUPnPDeviceFinderAddCallbackWithInterface * This,
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in_opt IUPnPDevice *pDevice,
            /* [in] */ __RPC__in GUID *pguidInterface);
        
        END_INTERFACE
    } IUPnPDeviceFinderAddCallbackWithInterfaceVtbl;

    interface IUPnPDeviceFinderAddCallbackWithInterface
    {
        CONST_VTBL struct IUPnPDeviceFinderAddCallbackWithInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceFinderAddCallbackWithInterface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceFinderAddCallbackWithInterface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceFinderAddCallbackWithInterface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceFinderAddCallbackWithInterface_DeviceAddedWithInterface(This,lFindData,pDevice,pguidInterface)	\
    ( (This)->lpVtbl -> DeviceAddedWithInterface(This,lFindData,pDevice,pguidInterface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceFinderAddCallbackWithInterface_INTERFACE_DEFINED__ */


#ifndef __IUPnPDescriptionDocumentCallback_INTERFACE_DEFINED__
#define __IUPnPDescriptionDocumentCallback_INTERFACE_DEFINED__

/* interface IUPnPDescriptionDocumentCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDescriptionDocumentCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77394c69-5486-40d6-9bc3-4991983e02da")
    IUPnPDescriptionDocumentCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadComplete( 
            /* [in] */ HRESULT hrLoadResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDescriptionDocumentCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUPnPDescriptionDocumentCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUPnPDescriptionDocumentCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUPnPDescriptionDocumentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadComplete )( 
            IUPnPDescriptionDocumentCallback * This,
            /* [in] */ HRESULT hrLoadResult);
        
        END_INTERFACE
    } IUPnPDescriptionDocumentCallbackVtbl;

    interface IUPnPDescriptionDocumentCallback
    {
        CONST_VTBL struct IUPnPDescriptionDocumentCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDescriptionDocumentCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDescriptionDocumentCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDescriptionDocumentCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDescriptionDocumentCallback_LoadComplete(This,hrLoadResult)	\
    ( (This)->lpVtbl -> LoadComplete(This,hrLoadResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDescriptionDocumentCallback_INTERFACE_DEFINED__ */



#ifndef __UPNPLib_LIBRARY_DEFINED__
#define __UPNPLib_LIBRARY_DEFINED__

/* library UPNPLib */
/* [helpstring][version][uuid] */ 






EXTERN_C const IID LIBID_UPNPLib;

EXTERN_C const CLSID CLSID_UPnPDeviceFinder;

#ifdef __cplusplus

class DECLSPEC_UUID("E2085F28-FEB7-404A-B8E7-E659BDEAAA02")
UPnPDeviceFinder;
#endif

EXTERN_C const CLSID CLSID_UPnPDevices;

#ifdef __cplusplus

class DECLSPEC_UUID("B9E84FFD-AD3C-40A4-B835-0882EBCBAAA8")
UPnPDevices;
#endif

EXTERN_C const CLSID CLSID_UPnPDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("A32552C5-BA61-457A-B59A-A2561E125E33")
UPnPDevice;
#endif

EXTERN_C const CLSID CLSID_UPnPServices;

#ifdef __cplusplus

class DECLSPEC_UUID("C0BC4B4A-A406-4EFC-932F-B8546B8100CC")
UPnPServices;
#endif

EXTERN_C const CLSID CLSID_UPnPService;

#ifdef __cplusplus

class DECLSPEC_UUID("C624BA95-FBCB-4409-8C03-8CCEEC533EF1")
UPnPService;
#endif

EXTERN_C const CLSID CLSID_UPnPDescriptionDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("1d8a9b47-3a28-4ce2-8a4b-bd34e45bceeb")
UPnPDescriptionDocument;
#endif
#endif /* __UPNPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usb200.h ===
#ifndef   __USB200_H__
#define   __USB200_H__

#include "usb100.h"


#include <PSHPACK1.H>


#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4201)

typedef enum _USB_DEVICE_SPEED {
    UsbLowSpeed = 0,
    UsbFullSpeed,
    UsbHighSpeed
} USB_DEVICE_SPEED;

typedef enum _USB_DEVICE_TYPE {
    Usb11Device = 0,
    Usb20Device
} USB_DEVICE_TYPE;

// standard definitions for the port status
// word of the HUB port register

#define USB_PORT_STATUS_CONNECT         0x0001
#define USB_PORT_STATUS_ENABLE          0x0002
#define USB_PORT_STATUS_SUSPEND         0x0004
#define USB_PORT_STATUS_OVER_CURRENT    0x0008
#define USB_PORT_STATUS_RESET           0x0010
#define USB_PORT_STATUS_POWER           0x0100
#define USB_PORT_STATUS_LOW_SPEED       0x0200
#define USB_PORT_STATUS_HIGH_SPEED      0x0400

typedef union _BM_REQUEST_TYPE {
    struct _BM {
        UCHAR   Recipient:2;
        UCHAR   Reserved:3;
        UCHAR   Type:2;
        UCHAR   Dir:1;
    };
    UCHAR B;
} BM_REQUEST_TYPE, *PBM_REQUEST_TYPE;

typedef struct _USB_DEFAULT_PIPE_SETUP_PACKET {
    BM_REQUEST_TYPE bmRequestType;
    UCHAR bRequest;

    union _wValue {
        struct {
            UCHAR LowByte;
            UCHAR HiByte;
        };
        USHORT W;
    } wValue;

    union _wIndex {
        struct {
            UCHAR LowByte;
            UCHAR HiByte;
        };
        USHORT W;
    } wIndex;
    USHORT wLength;
} USB_DEFAULT_PIPE_SETUP_PACKET, *PUSB_DEFAULT_PIPE_SETUP_PACKET;

// setup packet is eight bytes -- defined by spec
C_ASSERT(sizeof(USB_DEFAULT_PIPE_SETUP_PACKET) == 8);


#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE            0x06
#define USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR_TYPE   0x07

typedef struct _USB_DEVICE_QUALIFIER_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
    UCHAR bNumConfigurations;
    UCHAR bReserved;
} USB_DEVICE_QUALIFIER_DESCRIPTOR, *PUSB_DEVICE_QUALIFIER_DESCRIPTOR;


typedef union _USB_HIGH_SPEED_MAXPACKET {
    struct _MP {
        USHORT   MaxPacket:11;  /* 0..10 */
        USHORT   HSmux:2;        /* 11..12 */
        USHORT   Reserved:3;    /* 13..15 */
    };
    USHORT us;
  } USB_HIGH_SPEED_MAXPACKET, *PUSB_HIGH_SPEED_MAXPACKET;

#define USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE 0x0B

typedef struct _USB_INTERFACE_ASSOCIATION_DESCRIPTOR {

    UCHAR   bLength;
    UCHAR   bDescriptorType;
    UCHAR   bFirstInterface;
    UCHAR   bInterfaceCount;
    UCHAR   bFunctionClass;
    UCHAR   bFunctionSubClass;
    UCHAR   bFunctionProtocol;
    UCHAR   iFunction;

} USB_INTERFACE_ASSOCIATION_DESCRIPTOR, *PUSB_INTERFACE_ASSOCIATION_DESCRIPTOR;


#if _MSC_VER >= 1200
#pragma warning(pop)
#endif



#include <POPPACK.H>

#endif // __USB200_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\UrlMon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for urlmon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __urlmon_h__
#define __urlmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPersistMoniker_FWD_DEFINED__
#define __IPersistMoniker_FWD_DEFINED__
typedef interface IPersistMoniker IPersistMoniker;
#endif 	/* __IPersistMoniker_FWD_DEFINED__ */


#ifndef __IMonikerProp_FWD_DEFINED__
#define __IMonikerProp_FWD_DEFINED__
typedef interface IMonikerProp IMonikerProp;
#endif 	/* __IMonikerProp_FWD_DEFINED__ */


#ifndef __IBindProtocol_FWD_DEFINED__
#define __IBindProtocol_FWD_DEFINED__
typedef interface IBindProtocol IBindProtocol;
#endif 	/* __IBindProtocol_FWD_DEFINED__ */


#ifndef __IBinding_FWD_DEFINED__
#define __IBinding_FWD_DEFINED__
typedef interface IBinding IBinding;
#endif 	/* __IBinding_FWD_DEFINED__ */


#ifndef __IBindStatusCallback_FWD_DEFINED__
#define __IBindStatusCallback_FWD_DEFINED__
typedef interface IBindStatusCallback IBindStatusCallback;
#endif 	/* __IBindStatusCallback_FWD_DEFINED__ */


#ifndef __IAuthenticate_FWD_DEFINED__
#define __IAuthenticate_FWD_DEFINED__
typedef interface IAuthenticate IAuthenticate;
#endif 	/* __IAuthenticate_FWD_DEFINED__ */


#ifndef __IHttpNegotiate_FWD_DEFINED__
#define __IHttpNegotiate_FWD_DEFINED__
typedef interface IHttpNegotiate IHttpNegotiate;
#endif 	/* __IHttpNegotiate_FWD_DEFINED__ */


#ifndef __IHttpNegotiate2_FWD_DEFINED__
#define __IHttpNegotiate2_FWD_DEFINED__
typedef interface IHttpNegotiate2 IHttpNegotiate2;
#endif 	/* __IHttpNegotiate2_FWD_DEFINED__ */


#ifndef __IWinInetFileStream_FWD_DEFINED__
#define __IWinInetFileStream_FWD_DEFINED__
typedef interface IWinInetFileStream IWinInetFileStream;
#endif 	/* __IWinInetFileStream_FWD_DEFINED__ */


#ifndef __IWindowForBindingUI_FWD_DEFINED__
#define __IWindowForBindingUI_FWD_DEFINED__
typedef interface IWindowForBindingUI IWindowForBindingUI;
#endif 	/* __IWindowForBindingUI_FWD_DEFINED__ */


#ifndef __ICodeInstall_FWD_DEFINED__
#define __ICodeInstall_FWD_DEFINED__
typedef interface ICodeInstall ICodeInstall;
#endif 	/* __ICodeInstall_FWD_DEFINED__ */


#ifndef __IUri_FWD_DEFINED__
#define __IUri_FWD_DEFINED__
typedef interface IUri IUri;
#endif 	/* __IUri_FWD_DEFINED__ */


#ifndef __IUriContainer_FWD_DEFINED__
#define __IUriContainer_FWD_DEFINED__
typedef interface IUriContainer IUriContainer;
#endif 	/* __IUriContainer_FWD_DEFINED__ */


#ifndef __IUriBuilder_FWD_DEFINED__
#define __IUriBuilder_FWD_DEFINED__
typedef interface IUriBuilder IUriBuilder;
#endif 	/* __IUriBuilder_FWD_DEFINED__ */


#ifndef __IUriBuilderFactory_FWD_DEFINED__
#define __IUriBuilderFactory_FWD_DEFINED__
typedef interface IUriBuilderFactory IUriBuilderFactory;
#endif 	/* __IUriBuilderFactory_FWD_DEFINED__ */


#ifndef __IWinInetInfo_FWD_DEFINED__
#define __IWinInetInfo_FWD_DEFINED__
typedef interface IWinInetInfo IWinInetInfo;
#endif 	/* __IWinInetInfo_FWD_DEFINED__ */


#ifndef __IHttpSecurity_FWD_DEFINED__
#define __IHttpSecurity_FWD_DEFINED__
typedef interface IHttpSecurity IHttpSecurity;
#endif 	/* __IHttpSecurity_FWD_DEFINED__ */


#ifndef __IWinInetHttpInfo_FWD_DEFINED__
#define __IWinInetHttpInfo_FWD_DEFINED__
typedef interface IWinInetHttpInfo IWinInetHttpInfo;
#endif 	/* __IWinInetHttpInfo_FWD_DEFINED__ */


#ifndef __IWinInetCacheHints_FWD_DEFINED__
#define __IWinInetCacheHints_FWD_DEFINED__
typedef interface IWinInetCacheHints IWinInetCacheHints;
#endif 	/* __IWinInetCacheHints_FWD_DEFINED__ */


#ifndef __IWinInetCacheHints2_FWD_DEFINED__
#define __IWinInetCacheHints2_FWD_DEFINED__
typedef interface IWinInetCacheHints2 IWinInetCacheHints2;
#endif 	/* __IWinInetCacheHints2_FWD_DEFINED__ */


#ifndef __IBindHost_FWD_DEFINED__
#define __IBindHost_FWD_DEFINED__
typedef interface IBindHost IBindHost;
#endif 	/* __IBindHost_FWD_DEFINED__ */


#ifndef __IInternet_FWD_DEFINED__
#define __IInternet_FWD_DEFINED__
typedef interface IInternet IInternet;
#endif 	/* __IInternet_FWD_DEFINED__ */


#ifndef __IInternetBindInfo_FWD_DEFINED__
#define __IInternetBindInfo_FWD_DEFINED__
typedef interface IInternetBindInfo IInternetBindInfo;
#endif 	/* __IInternetBindInfo_FWD_DEFINED__ */


#ifndef __IInternetProtocolRoot_FWD_DEFINED__
#define __IInternetProtocolRoot_FWD_DEFINED__
typedef interface IInternetProtocolRoot IInternetProtocolRoot;
#endif 	/* __IInternetProtocolRoot_FWD_DEFINED__ */


#ifndef __IInternetProtocol_FWD_DEFINED__
#define __IInternetProtocol_FWD_DEFINED__
typedef interface IInternetProtocol IInternetProtocol;
#endif 	/* __IInternetProtocol_FWD_DEFINED__ */


#ifndef __IInternetProtocolEx_FWD_DEFINED__
#define __IInternetProtocolEx_FWD_DEFINED__
typedef interface IInternetProtocolEx IInternetProtocolEx;
#endif 	/* __IInternetProtocolEx_FWD_DEFINED__ */


#ifndef __IInternetProtocolSink_FWD_DEFINED__
#define __IInternetProtocolSink_FWD_DEFINED__
typedef interface IInternetProtocolSink IInternetProtocolSink;
#endif 	/* __IInternetProtocolSink_FWD_DEFINED__ */


#ifndef __IInternetProtocolSinkStackable_FWD_DEFINED__
#define __IInternetProtocolSinkStackable_FWD_DEFINED__
typedef interface IInternetProtocolSinkStackable IInternetProtocolSinkStackable;
#endif 	/* __IInternetProtocolSinkStackable_FWD_DEFINED__ */


#ifndef __IInternetSession_FWD_DEFINED__
#define __IInternetSession_FWD_DEFINED__
typedef interface IInternetSession IInternetSession;
#endif 	/* __IInternetSession_FWD_DEFINED__ */


#ifndef __IInternetThreadSwitch_FWD_DEFINED__
#define __IInternetThreadSwitch_FWD_DEFINED__
typedef interface IInternetThreadSwitch IInternetThreadSwitch;
#endif 	/* __IInternetThreadSwitch_FWD_DEFINED__ */


#ifndef __IInternetPriority_FWD_DEFINED__
#define __IInternetPriority_FWD_DEFINED__
typedef interface IInternetPriority IInternetPriority;
#endif 	/* __IInternetPriority_FWD_DEFINED__ */


#ifndef __IInternetProtocolInfo_FWD_DEFINED__
#define __IInternetProtocolInfo_FWD_DEFINED__
typedef interface IInternetProtocolInfo IInternetProtocolInfo;
#endif 	/* __IInternetProtocolInfo_FWD_DEFINED__ */


#ifndef __IInternetSecurityMgrSite_FWD_DEFINED__
#define __IInternetSecurityMgrSite_FWD_DEFINED__
typedef interface IInternetSecurityMgrSite IInternetSecurityMgrSite;
#endif 	/* __IInternetSecurityMgrSite_FWD_DEFINED__ */


#ifndef __IInternetSecurityManager_FWD_DEFINED__
#define __IInternetSecurityManager_FWD_DEFINED__
typedef interface IInternetSecurityManager IInternetSecurityManager;
#endif 	/* __IInternetSecurityManager_FWD_DEFINED__ */


#ifndef __IInternetSecurityManagerEx_FWD_DEFINED__
#define __IInternetSecurityManagerEx_FWD_DEFINED__
typedef interface IInternetSecurityManagerEx IInternetSecurityManagerEx;
#endif 	/* __IInternetSecurityManagerEx_FWD_DEFINED__ */


#ifndef __IInternetSecurityManagerEx2_FWD_DEFINED__
#define __IInternetSecurityManagerEx2_FWD_DEFINED__
typedef interface IInternetSecurityManagerEx2 IInternetSecurityManagerEx2;
#endif 	/* __IInternetSecurityManagerEx2_FWD_DEFINED__ */


#ifndef __IZoneIdentifier_FWD_DEFINED__
#define __IZoneIdentifier_FWD_DEFINED__
typedef interface IZoneIdentifier IZoneIdentifier;
#endif 	/* __IZoneIdentifier_FWD_DEFINED__ */


#ifndef __IInternetHostSecurityManager_FWD_DEFINED__
#define __IInternetHostSecurityManager_FWD_DEFINED__
typedef interface IInternetHostSecurityManager IInternetHostSecurityManager;
#endif 	/* __IInternetHostSecurityManager_FWD_DEFINED__ */


#ifndef __IInternetZoneManager_FWD_DEFINED__
#define __IInternetZoneManager_FWD_DEFINED__
typedef interface IInternetZoneManager IInternetZoneManager;
#endif 	/* __IInternetZoneManager_FWD_DEFINED__ */


#ifndef __IInternetZoneManagerEx_FWD_DEFINED__
#define __IInternetZoneManagerEx_FWD_DEFINED__
typedef interface IInternetZoneManagerEx IInternetZoneManagerEx;
#endif 	/* __IInternetZoneManagerEx_FWD_DEFINED__ */


#ifndef __IInternetZoneManagerEx2_FWD_DEFINED__
#define __IInternetZoneManagerEx2_FWD_DEFINED__
typedef interface IInternetZoneManagerEx2 IInternetZoneManagerEx2;
#endif 	/* __IInternetZoneManagerEx2_FWD_DEFINED__ */


#ifndef __ISoftDistExt_FWD_DEFINED__
#define __ISoftDistExt_FWD_DEFINED__
typedef interface ISoftDistExt ISoftDistExt;
#endif 	/* __ISoftDistExt_FWD_DEFINED__ */


#ifndef __ICatalogFileInfo_FWD_DEFINED__
#define __ICatalogFileInfo_FWD_DEFINED__
typedef interface ICatalogFileInfo ICatalogFileInfo;
#endif 	/* __ICatalogFileInfo_FWD_DEFINED__ */


#ifndef __IDataFilter_FWD_DEFINED__
#define __IDataFilter_FWD_DEFINED__
typedef interface IDataFilter IDataFilter;
#endif 	/* __IDataFilter_FWD_DEFINED__ */


#ifndef __IEncodingFilterFactory_FWD_DEFINED__
#define __IEncodingFilterFactory_FWD_DEFINED__
typedef interface IEncodingFilterFactory IEncodingFilterFactory;
#endif 	/* __IEncodingFilterFactory_FWD_DEFINED__ */


#ifndef __IWrappedProtocol_FWD_DEFINED__
#define __IWrappedProtocol_FWD_DEFINED__
typedef interface IWrappedProtocol IWrappedProtocol;
#endif 	/* __IWrappedProtocol_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "servprov.h"
#include "msxml.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_urlmon_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// UrlMon.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// URL Moniker Interfaces.












// Side-by-Side clsid
EXTERN_C const IID CLSID_SBS_StdURLMoniker;  
EXTERN_C const IID CLSID_SBS_HttpProtocol;   
EXTERN_C const IID CLSID_SBS_FtpProtocol;    
EXTERN_C const IID CLSID_SBS_GopherProtocol; 
EXTERN_C const IID CLSID_SBS_HttpSProtocol;  
EXTERN_C const IID CLSID_SBS_FileProtocol;   
EXTERN_C const IID CLSID_SBS_MkProtocol;     
EXTERN_C const IID CLSID_SBS_UrlMkBindCtx;   
EXTERN_C const IID CLSID_SBS_SoftDistExt;  
EXTERN_C const IID CLSID_SBS_StdEncodingFilterFac; 
EXTERN_C const IID CLSID_SBS_DeCompMimeFilter;     
EXTERN_C const IID CLSID_SBS_CdlProtocol;          
EXTERN_C const IID CLSID_SBS_ClassInstallFilter;   
EXTERN_C const IID CLSID_SBS_InternetSecurityManager;  
EXTERN_C const IID CLSID_SBS_InternetZoneManager;  
// END Side-by-Side clsid
// These are for backwards compatibility with previous URLMON versions
#define BINDF_DONTUSECACHE BINDF_GETNEWESTVERSION
#define BINDF_DONTPUTINCACHE BINDF_NOWRITECACHE
#define BINDF_NOCOPYDATA BINDF_PULLDATA
#define INVALID_P_ROOT_SECURITY_ID ((BYTE*)-1)
#define PI_DOCFILECLSIDLOOKUP PI_CLSIDLOOKUP
EXTERN_C const IID IID_IAsyncMoniker;    
EXTERN_C const IID CLSID_StdURLMoniker;  
EXTERN_C const IID CLSID_HttpProtocol;   
EXTERN_C const IID CLSID_FtpProtocol;    
EXTERN_C const IID CLSID_GopherProtocol; 
EXTERN_C const IID CLSID_HttpSProtocol;  
EXTERN_C const IID CLSID_FileProtocol;   
EXTERN_C const IID CLSID_MkProtocol;     
EXTERN_C const IID CLSID_StdURLProtocol; 
EXTERN_C const IID CLSID_UrlMkBindCtx;   
EXTERN_C const IID CLSID_StdEncodingFilterFac; 
EXTERN_C const IID CLSID_DeCompMimeFilter;     
EXTERN_C const IID CLSID_CdlProtocol;          
EXTERN_C const IID CLSID_ClassInstallFilter;   
EXTERN_C const IID IID_IAsyncBindCtx;    
 
#define SZ_URLCONTEXT           OLESTR("URL Context")
#define SZ_ASYNC_CALLEE         OLESTR("AsyncCallee")
#define MKSYS_URLMONIKER         6            
#define URL_MK_LEGACY            0            
#define URL_MK_UNIFORM           1            
#define URL_MK_NO_CANONICALIZE   2            
 
STDAPI CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);             
STDAPI CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk, DWORD dwFlags);             
STDAPI GetClassURL(LPCWSTR szURL, CLSID *pClsID);                                           
STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
                                IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CreateURLMonikerEx2(LPMONIKER pMkCtx, IUri* pUri, LPMONIKER FAR * ppmk, DWORD dwFlags);             
#endif
STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
                            IBindCtx **ppBC, DWORD reserved);                                                     
STDAPI MkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten,          
                                LPMONIKER *ppmk);                                           
STDAPI RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved);       
STDAPI RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb);                      
STDAPI GetClassFileOrMime(LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID *pclsid); 
STDAPI IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved);                               
STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
            LPCWSTR szCODE, DWORD dwFileVersionMS, 
            DWORD dwFileVersionLS, LPCWSTR szTYPE,
            LPBINDCTX pBindCtx, DWORD dwClsContext,
            LPVOID pvReserved, REFIID riid, LPVOID * ppv);
STDAPI FaultInIEFeature( HWND hWnd,
            __in uCLSSPEC *pClassSpec,
            __inout_opt QUERYCONTEXT *pQuery, DWORD dwFlags);                                           
STDAPI GetComponentIDFromCLSSPEC(__in uCLSSPEC *pClassspec,
            __deref_out LPSTR * ppszComponentID);                                                      
// flags for FaultInIEFeature
#define FIEF_FLAG_FORCE_JITUI               0x1     // force JIT ui even if
                                                 // previoulsy rejected by 
                                                 // user in this session or
                                                 // marked as Never Ask Again
#define FIEF_FLAG_PEEK                      0x2     // just peek, don't faultin
#define FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK        0x4     // force JIT without checking local version
 
//helper apis                                                                               
STDAPI IsAsyncMoniker(IMoniker* pmk);                                                       
STDAPI CreateURLBinding(LPCWSTR lpszUrl, __in IBindCtx *pbc, __deref_inout IBinding **ppBdg);
 
STDAPI RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes);            
STDAPI FindMediaType(LPCSTR rgszTypes, __out CLIPFORMAT* rgcfTypes);                                       
STDAPI CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc); 
STDAPI RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved);          
STDAPI RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc);                            
STDAPI RegisterMediaTypeClass(LPBC pBC,UINT ctypes, const LPCSTR* rgszTypes, CLSID *rgclsID, DWORD reserved);    
STDAPI FindMediaTypeClass(LPBC pBC, LPCSTR szType, CLSID *pclsID, DWORD reserved);                          
STDAPI UrlMkSetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved);       
STDAPI UrlMkGetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD *pdwBufferLength, DWORD dwReserved);       
STDAPI FindMimeFromData(                                                                                                                  
    __in_opt                LPBC    pBC,                   // bind context - can be NULL                                                 
    __in_opt                LPCWSTR pwzUrl,                // url - can be null                                                          
    __in_bcount_opt(cbSize) LPVOID  pBuffer,               // buffer with data to sniff - can be null (pwzUrl must be valid)             
                            DWORD   cbSize,                // size of buffer                                                             
    __in_opt                LPCWSTR pwzMimeProposed,       // proposed mime if - can be null                                             
                            DWORD   dwMimeFlags,           // will be defined                                                            
    __deref_out             LPWSTR  *ppwzMimeOut,          // the suggested mime                                                         
    __reserved              DWORD   dwReserved);           // must be 0                                                                  
#define     FMFD_DEFAULT             0x00000000 
#define     FMFD_URLASFILENAME       0x00000001 
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define     FMFD_ENABLEMIMESNIFFING  0x00000002 
#define     FMFD_IGNOREMIMETEXTPLAIN  0x00000004 
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
STDAPI ObtainUserAgentString(                           
                                        DWORD dwOption, 
    __out_ecount_part(*cbSize, *cbSize) LPSTR pszUAOut, 
    __inout                             DWORD *cbSize); 
STDAPI CompareSecurityIds(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2, DWORD dwReserved);    
STDAPI CompatFlagsFromClsid(CLSID *pclsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags);             
 
// URLMON-specific defines for UrlMkSetSessionOption() above
#define URLMON_OPTION_USERAGENT           0x10000001
#define URLMON_OPTION_USERAGENT_REFRESH   0x10000002
#define URLMON_OPTION_URL_ENCODING        0x10000004
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLMON_OPTION_USE_BINDSTRINGCREDS 0x10000008
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define URLMON_OPTION_USE_BROWSERAPPSDOCUMENTS 0x10000010
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
 
#define CF_NULL                 0                                  
#define CFSTR_MIME_NULL         NULL                               
#define CFSTR_MIME_TEXT         (TEXT("text/plain"))             
#define CFSTR_MIME_RICHTEXT     (TEXT("text/richtext"))          
#define CFSTR_MIME_X_BITMAP     (TEXT("image/x-xbitmap"))        
#define CFSTR_MIME_POSTSCRIPT   (TEXT("application/postscript")) 
#define CFSTR_MIME_AIFF         (TEXT("audio/aiff"))             
#define CFSTR_MIME_BASICAUDIO   (TEXT("audio/basic"))            
#define CFSTR_MIME_WAV          (TEXT("audio/wav"))              
#define CFSTR_MIME_X_WAV        (TEXT("audio/x-wav"))            
#define CFSTR_MIME_GIF          (TEXT("image/gif"))              
#define CFSTR_MIME_PJPEG        (TEXT("image/pjpeg"))            
#define CFSTR_MIME_JPEG         (TEXT("image/jpeg"))             
#define CFSTR_MIME_TIFF         (TEXT("image/tiff"))             
#define CFSTR_MIME_X_PNG        (TEXT("image/x-png"))            
#define CFSTR_MIME_BMP          (TEXT("image/bmp"))              
#define CFSTR_MIME_X_ART        (TEXT("image/x-jg"))             
#define CFSTR_MIME_X_EMF        (TEXT("image/x-emf"))            
#define CFSTR_MIME_X_WMF        (TEXT("image/x-wmf"))            
#define CFSTR_MIME_AVI          (TEXT("video/avi"))              
#define CFSTR_MIME_MPEG         (TEXT("video/mpeg"))             
#define CFSTR_MIME_FRACTALS     (TEXT("application/fractals"))   
#define CFSTR_MIME_RAWDATA      (TEXT("application/octet-stream"))
#define CFSTR_MIME_RAWDATASTRM  (TEXT("application/octet-stream"))
#define CFSTR_MIME_PDF          (TEXT("application/pdf"))        
#define CFSTR_MIME_HTA          (TEXT("application/hta"))        
#define CFSTR_MIME_X_AIFF       (TEXT("audio/x-aiff"))           
#define CFSTR_MIME_X_REALAUDIO  (TEXT("audio/x-pn-realaudio"))   
#define CFSTR_MIME_XBM          (TEXT("image/xbm"))              
#define CFSTR_MIME_QUICKTIME    (TEXT("video/quicktime"))        
#define CFSTR_MIME_X_MSVIDEO    (TEXT("video/x-msvideo"))        
#define CFSTR_MIME_X_SGI_MOVIE  (TEXT("video/x-sgi-movie"))      
#define CFSTR_MIME_HTML         (TEXT("text/html"))              
#define CFSTR_MIME_XML          (TEXT("text/xml"))               
 
// MessageId: MK_S_ASYNCHRONOUS                                              
// MessageText: Operation is successful, but will complete asynchronously.   
//                                                                           
#define MK_S_ASYNCHRONOUS    _HRESULT_TYPEDEF_(0x000401E8L)                  
#ifndef S_ASYNCHRONOUS                                                       
#define S_ASYNCHRONOUS       MK_S_ASYNCHRONOUS                               
#endif                                                                       
                                                                             
#ifndef E_PENDING                                                            
#define E_PENDING _HRESULT_TYPEDEF_(0x8000000AL)                             
#endif                                                                       
                                                                             
//                                                                           
//                                                                           
// WinINet and protocol specific errors are mapped to one of the following   
// error which are returned in IBSC::OnStopBinding                           
//                                                                           
//                                                                           
// Note: FACILITY C is split into ranges of 1k                               
// C0000 - C03FF  INET_E_ (URLMON's original hresult)                        
// C0400 - C07FF  INET_E_CLIENT_xxx                                          
// C0800 - C0BFF  INET_E_SERVER_xxx                                          
// C0C00 - C0FFF  INET_E_????                                                
// C1000 - C13FF  INET_E_AGENT_xxx (info delivery agents)                    
#define INET_E_INVALID_URL               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_NO_SESSION                _HRESULT_TYPEDEF_(0x800C0003L)      
#define INET_E_CANNOT_CONNECT            _HRESULT_TYPEDEF_(0x800C0004L)      
#define INET_E_RESOURCE_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0005L)      
#define INET_E_OBJECT_NOT_FOUND          _HRESULT_TYPEDEF_(0x800C0006L)      
#define INET_E_DATA_NOT_AVAILABLE        _HRESULT_TYPEDEF_(0x800C0007L)      
#define INET_E_DOWNLOAD_FAILURE          _HRESULT_TYPEDEF_(0x800C0008L)      
#define INET_E_AUTHENTICATION_REQUIRED   _HRESULT_TYPEDEF_(0x800C0009L)      
#define INET_E_NO_VALID_MEDIA            _HRESULT_TYPEDEF_(0x800C000AL)      
#define INET_E_CONNECTION_TIMEOUT        _HRESULT_TYPEDEF_(0x800C000BL)      
#define INET_E_INVALID_REQUEST           _HRESULT_TYPEDEF_(0x800C000CL)      
#define INET_E_UNKNOWN_PROTOCOL          _HRESULT_TYPEDEF_(0x800C000DL)      
#define INET_E_SECURITY_PROBLEM          _HRESULT_TYPEDEF_(0x800C000EL)      
#define INET_E_CANNOT_LOAD_DATA          _HRESULT_TYPEDEF_(0x800C000FL)      
#define INET_E_CANNOT_INSTANTIATE_OBJECT _HRESULT_TYPEDEF_(0x800C0010L)      
#define INET_E_INVALID_CERTIFICATE       _HRESULT_TYPEDEF_(0x800C0019L)      
#define INET_E_REDIRECT_FAILED           _HRESULT_TYPEDEF_(0x800C0014L)      
#define INET_E_REDIRECT_TO_DIR           _HRESULT_TYPEDEF_(0x800C0015L)      
#define INET_E_CANNOT_LOCK_REQUEST       _HRESULT_TYPEDEF_(0x800C0016L)      
#define INET_E_USE_EXTEND_BINDING        _HRESULT_TYPEDEF_(0x800C0017L)      
#define INET_E_TERMINATED_BIND           _HRESULT_TYPEDEF_(0x800C0018L)      
#define INET_E_ERROR_FIRST               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_CODE_DOWNLOAD_DECLINED    _HRESULT_TYPEDEF_(0x800C0100L)      
#define INET_E_RESULT_DISPATCHED         _HRESULT_TYPEDEF_(0x800C0200L)      
#define INET_E_CANNOT_REPLACE_SFP_FILE   _HRESULT_TYPEDEF_(0x800C0300L)      
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define INET_E_CODE_INSTALL_SUPPRESSED   _HRESULT_TYPEDEF_(0x800C0400L)      
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#define INET_E_CODE_INSTALL_BLOCKED_BY_HASH_POLICY   _HRESULT_TYPEDEF_(0x800C0500L)      
#define INET_E_ERROR_LAST                INET_E_CODE_INSTALL_BLOCKED_BY_HASH_POLICY
#ifndef _LPPERSISTMONIKER_DEFINED
#define _LPPERSISTMONIKER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_s_ifspec;

#ifndef __IPersistMoniker_INTERFACE_DEFINED__
#define __IPersistMoniker_INTERFACE_DEFINED__

/* interface IPersistMoniker */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IPersistMoniker *LPPERSISTMONIKER;


EXTERN_C const IID IID_IPersistMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c9-baf9-11ce-8c82-00aa004ba90b")
    IPersistMoniker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [out] */ __RPC__out CLSID *pClassID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pbc,
            /* [in] */ BOOL fRemember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveCompleted( 
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pibc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurMoniker( 
            /* [out] */ __RPC__deref_out_opt IMoniker **ppimkName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistMonikerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistMoniker * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistMoniker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistMoniker * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistMoniker * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            IPersistMoniker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IPersistMoniker * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IPersistMoniker * This,
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pbc,
            /* [in] */ BOOL fRemember);
        
        HRESULT ( STDMETHODCALLTYPE *SaveCompleted )( 
            IPersistMoniker * This,
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pibc);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurMoniker )( 
            IPersistMoniker * This,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppimkName);
        
        END_INTERFACE
    } IPersistMonikerVtbl;

    interface IPersistMoniker
    {
        CONST_VTBL struct IPersistMonikerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistMoniker_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistMoniker_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistMoniker_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistMoniker_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 

#define IPersistMoniker_IsDirty(This)	\
    ( (This)->lpVtbl -> IsDirty(This) ) 

#define IPersistMoniker_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    ( (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode) ) 

#define IPersistMoniker_Save(This,pimkName,pbc,fRemember)	\
    ( (This)->lpVtbl -> Save(This,pimkName,pbc,fRemember) ) 

#define IPersistMoniker_SaveCompleted(This,pimkName,pibc)	\
    ( (This)->lpVtbl -> SaveCompleted(This,pimkName,pibc) ) 

#define IPersistMoniker_GetCurMoniker(This,ppimkName)	\
    ( (This)->lpVtbl -> GetCurMoniker(This,ppimkName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistMoniker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPMONIKERPROP_DEFINED
#define _LPMONIKERPROP_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_s_ifspec;

#ifndef __IMonikerProp_INTERFACE_DEFINED__
#define __IMonikerProp_INTERFACE_DEFINED__

/* interface IMonikerProp */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IMonikerProp *LPMONIKERPROP;

typedef /* [public][public] */ 
enum __MIDL_IMonikerProp_0001
    {	MIMETYPEPROP	= 0,
	USE_SRC_URL	= 0x1,
	CLASSIDPROP	= 0x2,
	TRUSTEDDOWNLOADPROP	= 0x3,
	POPUPLEVELPROP	= 0x4
    } 	MONIKERPROPERTY;


EXTERN_C const IID IID_IMonikerProp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a5ca5f7f-1847-4d87-9c5b-918509f7511d")
    IMonikerProp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ MONIKERPROPERTY mkp,
            /* [in] */ __RPC__in LPCWSTR val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMonikerPropVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMonikerProp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMonikerProp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMonikerProp * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutProperty )( 
            IMonikerProp * This,
            /* [in] */ MONIKERPROPERTY mkp,
            /* [in] */ __RPC__in LPCWSTR val);
        
        END_INTERFACE
    } IMonikerPropVtbl;

    interface IMonikerProp
    {
        CONST_VTBL struct IMonikerPropVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMonikerProp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMonikerProp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMonikerProp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMonikerProp_PutProperty(This,mkp,val)	\
    ( (This)->lpVtbl -> PutProperty(This,mkp,val) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMonikerProp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPBINDPROTOCOL_DEFINED
#define _LPBINDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_s_ifspec;

#ifndef __IBindProtocol_INTERFACE_DEFINED__
#define __IBindProtocol_INTERFACE_DEFINED__

/* interface IBindProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IBindProtocol *LPBINDPROTOCOL;


EXTERN_C const IID IID_IBindProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9cd-baf9-11ce-8c82-00aa004ba90b")
    IBindProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ IBinding **ppb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBinding )( 
            IBindProtocol * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ IBinding **ppb);
        
        END_INTERFACE
    } IBindProtocolVtbl;

    interface IBindProtocol
    {
        CONST_VTBL struct IBindProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindProtocol_CreateBinding(This,szUrl,pbc,ppb)	\
    ( (This)->lpVtbl -> CreateBinding(This,szUrl,pbc,ppb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBindProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPBINDING_DEFINED
#define _LPBINDING_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_s_ifspec;

#ifndef __IBinding_INTERFACE_DEFINED__
#define __IBinding_INTERFACE_DEFINED__

/* interface IBinding */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IBinding *LPBINDING;


EXTERN_C const IID IID_IBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c0-baf9-11ce-8c82-00aa004ba90b")
    IBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ __RPC__out LONG *pnPriority) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindResult( 
            /* [out] */ CLSID *pclsidProtocol,
            /* [out] */ DWORD *pdwResult,
            /* [out] */ LPOLESTR *pszResult,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBinding * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IBinding * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IBinding * This,
            /* [out] */ __RPC__out LONG *pnPriority);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindResult )( 
            IBinding * This,
            /* [out] */ CLSID *pclsidProtocol,
            /* [out] */ DWORD *pdwResult,
            /* [out] */ LPOLESTR *pszResult,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IBindingVtbl;

    interface IBinding
    {
        CONST_VTBL struct IBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBinding_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBinding_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBinding_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBinding_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IBinding_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IBinding_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IBinding_SetPriority(This,nPriority)	\
    ( (This)->lpVtbl -> SetPriority(This,nPriority) ) 

#define IBinding_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#define IBinding_GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)	\
    ( (This)->lpVtbl -> GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_RemoteGetBindResult_Proxy( 
    IBinding * This,
    /* [out] */ __RPC__out CLSID *pclsidProtocol,
    /* [out] */ __RPC__out DWORD *pdwResult,
    /* [out] */ __RPC__deref_out_opt LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBinding_RemoteGetBindResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBinding_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0004 */
/* [local] */ 

#endif
#ifndef _LPBINDSTATUSCALLBACK_DEFINED
#define _LPBINDSTATUSCALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_s_ifspec;

#ifndef __IBindStatusCallback_INTERFACE_DEFINED__
#define __IBindStatusCallback_INTERFACE_DEFINED__

/* interface IBindStatusCallback */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IBindStatusCallback *LPBINDSTATUSCALLBACK;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0001
    {	BINDVERB_GET	= 0,
	BINDVERB_POST	= 0x1,
	BINDVERB_PUT	= 0x2,
	BINDVERB_CUSTOM	= 0x3
    } 	BINDVERB;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0002
    {	BINDINFOF_URLENCODESTGMEDDATA	= 0x1,
	BINDINFOF_URLENCODEDEXTRAINFO	= 0x2
    } 	BINDINFOF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0003
    {	BINDF_ASYNCHRONOUS	= 0x1,
	BINDF_ASYNCSTORAGE	= 0x2,
	BINDF_NOPROGRESSIVERENDERING	= 0x4,
	BINDF_OFFLINEOPERATION	= 0x8,
	BINDF_GETNEWESTVERSION	= 0x10,
	BINDF_NOWRITECACHE	= 0x20,
	BINDF_NEEDFILE	= 0x40,
	BINDF_PULLDATA	= 0x80,
	BINDF_IGNORESECURITYPROBLEM	= 0x100,
	BINDF_RESYNCHRONIZE	= 0x200,
	BINDF_HYPERLINK	= 0x400,
	BINDF_NO_UI	= 0x800,
	BINDF_SILENTOPERATION	= 0x1000,
	BINDF_PRAGMA_NO_CACHE	= 0x2000,
	BINDF_GETCLASSOBJECT	= 0x4000,
	BINDF_RESERVED_1	= 0x8000,
	BINDF_FREE_THREADED	= 0x10000,
	BINDF_DIRECT_READ	= 0x20000,
	BINDF_FORMS_SUBMIT	= 0x40000,
	BINDF_GETFROMCACHE_IF_NET_FAIL	= 0x80000,
	BINDF_FROMURLMON	= 0x100000,
	BINDF_FWD_BACK	= 0x200000,
	BINDF_PREFERDEFAULTHANDLER	= 0x400000,
	BINDF_ENFORCERESTRICTED	= 0x800000
    } 	BINDF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0004
    {	URL_ENCODING_NONE	= 0,
	URL_ENCODING_ENABLE_UTF8	= 0x10000000,
	URL_ENCODING_DISABLE_UTF8	= 0x20000000
    } 	URL_ENCODING;

typedef struct _tagBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    STGMEDIUM stgmedData;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    SECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown *pUnk;
    DWORD dwReserved;
    } 	BINDINFO;

typedef struct _REMSECURITY_ATTRIBUTES
    {
    DWORD nLength;
    DWORD lpSecurityDescriptor;
    BOOL bInheritHandle;
    } 	REMSECURITY_ATTRIBUTES;

typedef struct _REMSECURITY_ATTRIBUTES *PREMSECURITY_ATTRIBUTES;

typedef struct _REMSECURITY_ATTRIBUTES *LPREMSECURITY_ATTRIBUTES;

typedef struct _tagRemBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    REMSECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown *pUnk;
    DWORD dwReserved;
    } 	RemBINDINFO;

typedef struct tagRemFORMATETC
    {
    DWORD cfFormat;
    DWORD ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
    } 	RemFORMATETC;

typedef struct tagRemFORMATETC *LPREMFORMATETC;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0005
    {	BINDINFO_OPTIONS_WININETFLAG	= 0x10000,
	BINDINFO_OPTIONS_ENABLE_UTF8	= 0x20000,
	BINDINFO_OPTIONS_DISABLE_UTF8	= 0x40000,
	BINDINFO_OPTIONS_USE_IE_ENCODING	= 0x80000,
	BINDINFO_OPTIONS_BINDTOOBJECT	= 0x100000,
	BINDINFO_OPTIONS_SECURITYOPTOUT	= 0x200000,
	BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN	= 0x400000,
	BINDINFO_OPTIONS_USEBINDSTRINGCREDS	= 0x800000,
	BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS	= 0x1000000,
	BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE	= 0x2000000,
	BINDINFO_WPC_DOWNLOADBLOCKED	= 0x8000000,
	BINDINFO_WPC_LOGGING_ENABLED	= 0x10000000,
	BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS	= 0x40000000,
	BINDINFO_OPTIONS_SHDOCVW_NAVIGATE	= ( int  )0x80000000
    } 	BINDINFO_OPTIONS;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0006
    {	BSCF_FIRSTDATANOTIFICATION	= 0x1,
	BSCF_INTERMEDIATEDATANOTIFICATION	= 0x2,
	BSCF_LASTDATANOTIFICATION	= 0x4,
	BSCF_DATAFULLYAVAILABLE	= 0x8,
	BSCF_AVAILABLEDATASIZEUNKNOWN	= 0x10
    } 	BSCF;

typedef 
enum tagBINDSTATUS
    {	BINDSTATUS_FINDINGRESOURCE	= 1,
	BINDSTATUS_CONNECTING	= ( BINDSTATUS_FINDINGRESOURCE + 1 ) ,
	BINDSTATUS_REDIRECTING	= ( BINDSTATUS_CONNECTING + 1 ) ,
	BINDSTATUS_BEGINDOWNLOADDATA	= ( BINDSTATUS_REDIRECTING + 1 ) ,
	BINDSTATUS_DOWNLOADINGDATA	= ( BINDSTATUS_BEGINDOWNLOADDATA + 1 ) ,
	BINDSTATUS_ENDDOWNLOADDATA	= ( BINDSTATUS_DOWNLOADINGDATA + 1 ) ,
	BINDSTATUS_BEGINDOWNLOADCOMPONENTS	= ( BINDSTATUS_ENDDOWNLOADDATA + 1 ) ,
	BINDSTATUS_INSTALLINGCOMPONENTS	= ( BINDSTATUS_BEGINDOWNLOADCOMPONENTS + 1 ) ,
	BINDSTATUS_ENDDOWNLOADCOMPONENTS	= ( BINDSTATUS_INSTALLINGCOMPONENTS + 1 ) ,
	BINDSTATUS_USINGCACHEDCOPY	= ( BINDSTATUS_ENDDOWNLOADCOMPONENTS + 1 ) ,
	BINDSTATUS_SENDINGREQUEST	= ( BINDSTATUS_USINGCACHEDCOPY + 1 ) ,
	BINDSTATUS_CLASSIDAVAILABLE	= ( BINDSTATUS_SENDINGREQUEST + 1 ) ,
	BINDSTATUS_MIMETYPEAVAILABLE	= ( BINDSTATUS_CLASSIDAVAILABLE + 1 ) ,
	BINDSTATUS_CACHEFILENAMEAVAILABLE	= ( BINDSTATUS_MIMETYPEAVAILABLE + 1 ) ,
	BINDSTATUS_BEGINSYNCOPERATION	= ( BINDSTATUS_CACHEFILENAMEAVAILABLE + 1 ) ,
	BINDSTATUS_ENDSYNCOPERATION	= ( BINDSTATUS_BEGINSYNCOPERATION + 1 ) ,
	BINDSTATUS_BEGINUPLOADDATA	= ( BINDSTATUS_ENDSYNCOPERATION + 1 ) ,
	BINDSTATUS_UPLOADINGDATA	= ( BINDSTATUS_BEGINUPLOADDATA + 1 ) ,
	BINDSTATUS_ENDUPLOADDATA	= ( BINDSTATUS_UPLOADINGDATA + 1 ) ,
	BINDSTATUS_PROTOCOLCLASSID	= ( BINDSTATUS_ENDUPLOADDATA + 1 ) ,
	BINDSTATUS_ENCODING	= ( BINDSTATUS_PROTOCOLCLASSID + 1 ) ,
	BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE	= ( BINDSTATUS_ENCODING + 1 ) ,
	BINDSTATUS_CLASSINSTALLLOCATION	= ( BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE + 1 ) ,
	BINDSTATUS_DECODING	= ( BINDSTATUS_CLASSINSTALLLOCATION + 1 ) ,
	BINDSTATUS_LOADINGMIMEHANDLER	= ( BINDSTATUS_DECODING + 1 ) ,
	BINDSTATUS_CONTENTDISPOSITIONATTACH	= ( BINDSTATUS_LOADINGMIMEHANDLER + 1 ) ,
	BINDSTATUS_FILTERREPORTMIMETYPE	= ( BINDSTATUS_CONTENTDISPOSITIONATTACH + 1 ) ,
	BINDSTATUS_CLSIDCANINSTANTIATE	= ( BINDSTATUS_FILTERREPORTMIMETYPE + 1 ) ,
	BINDSTATUS_IUNKNOWNAVAILABLE	= ( BINDSTATUS_CLSIDCANINSTANTIATE + 1 ) ,
	BINDSTATUS_DIRECTBIND	= ( BINDSTATUS_IUNKNOWNAVAILABLE + 1 ) ,
	BINDSTATUS_RAWMIMETYPE	= ( BINDSTATUS_DIRECTBIND + 1 ) ,
	BINDSTATUS_PROXYDETECTING	= ( BINDSTATUS_RAWMIMETYPE + 1 ) ,
	BINDSTATUS_ACCEPTRANGES	= ( BINDSTATUS_PROXYDETECTING + 1 ) ,
	BINDSTATUS_COOKIE_SENT	= ( BINDSTATUS_ACCEPTRANGES + 1 ) ,
	BINDSTATUS_COMPACT_POLICY_RECEIVED	= ( BINDSTATUS_COOKIE_SENT + 1 ) ,
	BINDSTATUS_COOKIE_SUPPRESSED	= ( BINDSTATUS_COMPACT_POLICY_RECEIVED + 1 ) ,
	BINDSTATUS_COOKIE_STATE_UNKNOWN	= ( BINDSTATUS_COOKIE_SUPPRESSED + 1 ) ,
	BINDSTATUS_COOKIE_STATE_ACCEPT	= ( BINDSTATUS_COOKIE_STATE_UNKNOWN + 1 ) ,
	BINDSTATUS_COOKIE_STATE_REJECT	= ( BINDSTATUS_COOKIE_STATE_ACCEPT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_PROMPT	= ( BINDSTATUS_COOKIE_STATE_REJECT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_LEASH	= ( BINDSTATUS_COOKIE_STATE_PROMPT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_DOWNGRADE	= ( BINDSTATUS_COOKIE_STATE_LEASH + 1 ) ,
	BINDSTATUS_POLICY_HREF	= ( BINDSTATUS_COOKIE_STATE_DOWNGRADE + 1 ) ,
	BINDSTATUS_P3P_HEADER	= ( BINDSTATUS_POLICY_HREF + 1 ) ,
	BINDSTATUS_SESSION_COOKIE_RECEIVED	= ( BINDSTATUS_P3P_HEADER + 1 ) ,
	BINDSTATUS_PERSISTENT_COOKIE_RECEIVED	= ( BINDSTATUS_SESSION_COOKIE_RECEIVED + 1 ) ,
	BINDSTATUS_SESSION_COOKIES_ALLOWED	= ( BINDSTATUS_PERSISTENT_COOKIE_RECEIVED + 1 ) ,
	BINDSTATUS_CACHECONTROL	= ( BINDSTATUS_SESSION_COOKIES_ALLOWED + 1 ) ,
	BINDSTATUS_CONTENTDISPOSITIONFILENAME	= ( BINDSTATUS_CACHECONTROL + 1 ) ,
	BINDSTATUS_MIMETEXTPLAINMISMATCH	= ( BINDSTATUS_CONTENTDISPOSITIONFILENAME + 1 ) ,
	BINDSTATUS_PUBLISHERAVAILABLE	= ( BINDSTATUS_MIMETEXTPLAINMISMATCH + 1 ) ,
	BINDSTATUS_DISPLAYNAMEAVAILABLE	= ( BINDSTATUS_PUBLISHERAVAILABLE + 1 ) ,
	BINDSTATUS_SSLUX_NAVBLOCKED	= ( BINDSTATUS_DISPLAYNAMEAVAILABLE + 1 ) 
    } 	BINDSTATUS;


EXTERN_C const IID IID_IBindStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c1-baf9-11ce-8c82-00aa004ba90b")
    IBindStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartBinding( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ __RPC__in_opt IBinding *pib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ __RPC__out LONG *pnPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLowResource( 
            /* [in] */ DWORD reserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStopBinding( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szError) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnDataAvailable( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectAvailable( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][in] */ __RPC__in_opt IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindStatusCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindStatusCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindStatusCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartBinding )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ __RPC__in_opt IBinding *pib);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IBindStatusCallback * This,
            /* [out] */ __RPC__out LONG *pnPriority);
        
        HRESULT ( STDMETHODCALLTYPE *OnLowResource )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD reserved);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IBindStatusCallback * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *OnStopBinding )( 
            IBindStatusCallback * This,
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szError);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IBindStatusCallback * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *OnDataAvailable )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectAvailable )( 
            IBindStatusCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][in] */ __RPC__in_opt IUnknown *punk);
        
        END_INTERFACE
    } IBindStatusCallbackVtbl;

    interface IBindStatusCallback
    {
        CONST_VTBL struct IBindStatusCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindStatusCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindStatusCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindStatusCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindStatusCallback_OnStartBinding(This,dwReserved,pib)	\
    ( (This)->lpVtbl -> OnStartBinding(This,dwReserved,pib) ) 

#define IBindStatusCallback_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#define IBindStatusCallback_OnLowResource(This,reserved)	\
    ( (This)->lpVtbl -> OnLowResource(This,reserved) ) 

#define IBindStatusCallback_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)	\
    ( (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText) ) 

#define IBindStatusCallback_OnStopBinding(This,hresult,szError)	\
    ( (This)->lpVtbl -> OnStopBinding(This,hresult,szError) ) 

#define IBindStatusCallback_GetBindInfo(This,grfBINDF,pbindinfo)	\
    ( (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo) ) 

#define IBindStatusCallback_OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)	\
    ( (This)->lpVtbl -> OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed) ) 

#define IBindStatusCallback_OnObjectAvailable(This,riid,punk)	\
    ( (This)->lpVtbl -> OnObjectAvailable(This,riid,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteGetBindInfo_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ __RPC__out DWORD *grfBINDF,
    /* [unique][out][in] */ __RPC__inout_opt RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteGetBindInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteOnDataAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ __RPC__in RemFORMATETC *pformatetc,
    /* [in] */ __RPC__in RemSTGMEDIUM *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteOnDataAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindStatusCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0005 */
/* [local] */ 

#endif
#ifndef _LPAUTHENTICATION_DEFINED
#define _LPAUTHENTICATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_s_ifspec;

#ifndef __IAuthenticate_INTERFACE_DEFINED__
#define __IAuthenticate_INTERFACE_DEFINED__

/* interface IAuthenticate */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IAuthenticate *LPAUTHENTICATION;


EXTERN_C const IID IID_IAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d0-baf9-11ce-8c82-00aa004ba90b")
    IAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszUsername,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAuthenticate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAuthenticate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAuthenticate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Authenticate )( 
            IAuthenticate * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszUsername,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszPassword);
        
        END_INTERFACE
    } IAuthenticateVtbl;

    interface IAuthenticate
    {
        CONST_VTBL struct IAuthenticateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAuthenticate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAuthenticate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAuthenticate_Authenticate(This,phwnd,pszUsername,pszPassword)	\
    ( (This)->lpVtbl -> Authenticate(This,phwnd,pszUsername,pszPassword) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAuthenticate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0006 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE_DEFINED
#define _LPHTTPNEGOTIATE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_s_ifspec;

#ifndef __IHttpNegotiate_INTERFACE_DEFINED__
#define __IHttpNegotiate_INTERFACE_DEFINED__

/* interface IHttpNegotiate */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHttpNegotiate *LPHTTPNEGOTIATE;


EXTERN_C const IID IID_IHttpNegotiate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d2-baf9-11ce-8c82-00aa004ba90b")
    IHttpNegotiate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginningTransaction( 
            /* [in] */ __RPC__in LPCWSTR szURL,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szResponseHeaders,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szRequestHeaders,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalRequestHeaders) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpNegotiateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpNegotiate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpNegotiate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpNegotiate * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            IHttpNegotiate * This,
            /* [in] */ __RPC__in LPCWSTR szURL,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            IHttpNegotiate * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szResponseHeaders,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szRequestHeaders,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalRequestHeaders);
        
        END_INTERFACE
    } IHttpNegotiateVtbl;

    interface IHttpNegotiate
    {
        CONST_VTBL struct IHttpNegotiateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpNegotiate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpNegotiate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpNegotiate_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)	\
    ( (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders) ) 

#define IHttpNegotiate_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)	\
    ( (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpNegotiate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0007 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE2_DEFINED
#define _LPHTTPNEGOTIATE2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_s_ifspec;

#ifndef __IHttpNegotiate2_INTERFACE_DEFINED__
#define __IHttpNegotiate2_INTERFACE_DEFINED__

/* interface IHttpNegotiate2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHttpNegotiate2 *LPHTTPNEGOTIATE2;


EXTERN_C const IID IID_IHttpNegotiate2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F9F9FCB-E0F4-48eb-B7AB-FA2EA9365CB4")
    IHttpNegotiate2 : public IHttpNegotiate
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRootSecurityId( 
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpNegotiate2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpNegotiate2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpNegotiate2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpNegotiate2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            IHttpNegotiate2 * This,
            /* [in] */ __RPC__in LPCWSTR szURL,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            IHttpNegotiate2 * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szResponseHeaders,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szRequestHeaders,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalRequestHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootSecurityId )( 
            IHttpNegotiate2 * This,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IHttpNegotiate2Vtbl;

    interface IHttpNegotiate2
    {
        CONST_VTBL struct IHttpNegotiate2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpNegotiate2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpNegotiate2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpNegotiate2_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)	\
    ( (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders) ) 

#define IHttpNegotiate2_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)	\
    ( (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders) ) 


#define IHttpNegotiate2_GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpNegotiate2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0008 */
/* [local] */ 

#endif
#ifndef _LPWININETFILESTREAM_DEFINED
#define _LPWININETFILESTREAM_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_s_ifspec;

#ifndef __IWinInetFileStream_INTERFACE_DEFINED__
#define __IWinInetFileStream_INTERFACE_DEFINED__

/* interface IWinInetFileStream */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IWinInetFileStream *LPWININETFILESTREAM;


EXTERN_C const IID IID_IWinInetFileStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F134C4B7-B1F8-4e75-B886-74B90943BECB")
    IWinInetFileStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHandleForUnlock( 
            /* [in] */ DWORD_PTR hWinInetLockHandle,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeleteFile( 
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetFileStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetFileStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetFileStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetFileStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHandleForUnlock )( 
            IWinInetFileStream * This,
            /* [in] */ DWORD_PTR hWinInetLockHandle,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeleteFile )( 
            IWinInetFileStream * This,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IWinInetFileStreamVtbl;

    interface IWinInetFileStream
    {
        CONST_VTBL struct IWinInetFileStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetFileStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetFileStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetFileStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetFileStream_SetHandleForUnlock(This,hWinInetLockHandle,dwReserved)	\
    ( (This)->lpVtbl -> SetHandleForUnlock(This,hWinInetLockHandle,dwReserved) ) 

#define IWinInetFileStream_SetDeleteFile(This,dwReserved)	\
    ( (This)->lpVtbl -> SetDeleteFile(This,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetFileStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0009 */
/* [local] */ 

#endif
#ifndef _LPWINDOWFORBINDINGUI_DEFINED
#define _LPWINDOWFORBINDINGUI_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_s_ifspec;

#ifndef __IWindowForBindingUI_INTERFACE_DEFINED__
#define __IWindowForBindingUI_INTERFACE_DEFINED__

/* interface IWindowForBindingUI */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWindowForBindingUI *LPWINDOWFORBINDINGUI;


EXTERN_C const IID IID_IWindowForBindingUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d5-bafa-11ce-8c82-00aa004ba90b")
    IWindowForBindingUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowForBindingUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowForBindingUI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowForBindingUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowForBindingUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IWindowForBindingUI * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        END_INTERFACE
    } IWindowForBindingUIVtbl;

    interface IWindowForBindingUI
    {
        CONST_VTBL struct IWindowForBindingUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowForBindingUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowForBindingUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowForBindingUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowForBindingUI_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowForBindingUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0010 */
/* [local] */ 

#endif
#ifndef _LPCODEINSTALL_DEFINED
#define _LPCODEINSTALL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_s_ifspec;

#ifndef __ICodeInstall_INTERFACE_DEFINED__
#define __ICodeInstall_INTERFACE_DEFINED__

/* interface ICodeInstall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICodeInstall *LPCODEINSTALL;

typedef /* [public] */ 
enum __MIDL_ICodeInstall_0001
    {	CIP_DISK_FULL	= 0,
	CIP_ACCESS_DENIED	= ( CIP_DISK_FULL + 1 ) ,
	CIP_NEWER_VERSION_EXISTS	= ( CIP_ACCESS_DENIED + 1 ) ,
	CIP_OLDER_VERSION_EXISTS	= ( CIP_NEWER_VERSION_EXISTS + 1 ) ,
	CIP_NAME_CONFLICT	= ( CIP_OLDER_VERSION_EXISTS + 1 ) ,
	CIP_TRUST_VERIFICATION_COMPONENT_MISSING	= ( CIP_NAME_CONFLICT + 1 ) ,
	CIP_EXE_SELF_REGISTERATION_TIMEOUT	= ( CIP_TRUST_VERIFICATION_COMPONENT_MISSING + 1 ) ,
	CIP_UNSAFE_TO_ABORT	= ( CIP_EXE_SELF_REGISTERATION_TIMEOUT + 1 ) ,
	CIP_NEED_REBOOT	= ( CIP_UNSAFE_TO_ABORT + 1 ) ,
	CIP_NEED_REBOOT_UI_PERMISSION	= ( CIP_NEED_REBOOT + 1 ) 
    } 	CIP_STATUS;


EXTERN_C const IID IID_ICodeInstall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d1-baf9-11ce-8c82-00aa004ba90b")
    ICodeInstall : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCodeInstallProblem( 
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeInstallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodeInstall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodeInstall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodeInstall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            ICodeInstall * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnCodeInstallProblem )( 
            ICodeInstall * This,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } ICodeInstallVtbl;

    interface ICodeInstall
    {
        CONST_VTBL struct ICodeInstallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeInstall_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICodeInstall_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICodeInstall_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICodeInstall_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 


#define ICodeInstall_OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved)	\
    ( (This)->lpVtbl -> OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICodeInstall_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0011 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPUri_DEFINED
#define _LPUri_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_s_ifspec;

#ifndef __IUri_INTERFACE_DEFINED__
#define __IUri_INTERFACE_DEFINED__

/* interface IUri */
/* [unique][uuid][object] */ 

typedef /* [public][public][public][public][public][helpstring] */ 
enum __MIDL_IUri_0001
    {	Uri_PROPERTY_ABSOLUTE_URI	= 0,
	Uri_PROPERTY_STRING_START	= Uri_PROPERTY_ABSOLUTE_URI,
	Uri_PROPERTY_AUTHORITY	= ( Uri_PROPERTY_STRING_START + 1 ) ,
	Uri_PROPERTY_DISPLAY_URI	= ( Uri_PROPERTY_AUTHORITY + 1 ) ,
	Uri_PROPERTY_DOMAIN	= ( Uri_PROPERTY_DISPLAY_URI + 1 ) ,
	Uri_PROPERTY_EXTENSION	= ( Uri_PROPERTY_DOMAIN + 1 ) ,
	Uri_PROPERTY_FRAGMENT	= ( Uri_PROPERTY_EXTENSION + 1 ) ,
	Uri_PROPERTY_HOST	= ( Uri_PROPERTY_FRAGMENT + 1 ) ,
	Uri_PROPERTY_PASSWORD	= ( Uri_PROPERTY_HOST + 1 ) ,
	Uri_PROPERTY_PATH	= ( Uri_PROPERTY_PASSWORD + 1 ) ,
	Uri_PROPERTY_PATH_AND_QUERY	= ( Uri_PROPERTY_PATH + 1 ) ,
	Uri_PROPERTY_QUERY	= ( Uri_PROPERTY_PATH_AND_QUERY + 1 ) ,
	Uri_PROPERTY_RAW_URI	= ( Uri_PROPERTY_QUERY + 1 ) ,
	Uri_PROPERTY_SCHEME_NAME	= ( Uri_PROPERTY_RAW_URI + 1 ) ,
	Uri_PROPERTY_USER_INFO	= ( Uri_PROPERTY_SCHEME_NAME + 1 ) ,
	Uri_PROPERTY_USER_NAME	= ( Uri_PROPERTY_USER_INFO + 1 ) ,
	Uri_PROPERTY_STRING_LAST	= Uri_PROPERTY_USER_NAME,
	Uri_PROPERTY_HOST_TYPE	= ( Uri_PROPERTY_STRING_LAST + 1 ) ,
	Uri_PROPERTY_DWORD_START	= Uri_PROPERTY_HOST_TYPE,
	Uri_PROPERTY_PORT	= ( Uri_PROPERTY_DWORD_START + 1 ) ,
	Uri_PROPERTY_SCHEME	= ( Uri_PROPERTY_PORT + 1 ) ,
	Uri_PROPERTY_ZONE	= ( Uri_PROPERTY_SCHEME + 1 ) ,
	Uri_PROPERTY_DWORD_LAST	= Uri_PROPERTY_ZONE
    } 	Uri_PROPERTY;

typedef /* [public][helpstring] */ 
enum __MIDL_IUri_0002
    {	Uri_HOST_UNKNOWN	= 0,
	Uri_HOST_DNS	= ( Uri_HOST_UNKNOWN + 1 ) ,
	Uri_HOST_IPV4	= ( Uri_HOST_DNS + 1 ) ,
	Uri_HOST_IPV6	= ( Uri_HOST_IPV4 + 1 ) ,
	Uri_HOST_IDN	= ( Uri_HOST_IPV6 + 1 ) 
    } 	Uri_HOST_TYPE;


EXTERN_C const IID IID_IUri;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A39EE748-6A27-4817-A6F2-13914BEF5890")
    IUri : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyBSTR( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyLength( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out DWORD *pcchProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyDWORD( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out DWORD *pdwProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HasProperty( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out BOOL *pfHasProperty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAbsoluteUri( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAbsoluteUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAuthority( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAuthority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayUri( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDisplayString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDomain( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDomain) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtension( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrExtension) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFragment( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFragment) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHost( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrHost) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPassword( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPassword) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPathAndQuery( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPathAndQuery) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrQuery) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRawUri( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrRawUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSchemeName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSchemeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUserInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUserName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHostType( 
            /* [out] */ __RPC__out DWORD *pdwHostType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ __RPC__out DWORD *pdwPort) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetScheme( 
            /* [out] */ __RPC__out DWORD *pdwScheme) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetZone( 
            /* [out] */ __RPC__out DWORD *pdwZone) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out LPDWORD pdwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [out] */ __RPC__out BOOL *pfEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUri * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUri * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUri * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyBSTR )( 
            IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrProperty,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyLength )( 
            IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out DWORD *pcchProperty,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyDWORD )( 
            IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out DWORD *pdwProperty,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *HasProperty )( 
            IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out BOOL *pfHasProperty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAbsoluteUri )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAbsoluteUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAuthority )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAuthority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDisplayUri )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDisplayString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDomain )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDomain);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtension )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrExtension);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFragment )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFragment);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHost )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrHost);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPassword )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPassword);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPathAndQuery )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPathAndQuery);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrQuery);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRawUri )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrRawUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSchemeName )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSchemeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserInfo )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUserInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserName )( 
            IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHostType )( 
            IUri * This,
            /* [out] */ __RPC__out DWORD *pdwHostType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IUri * This,
            /* [out] */ __RPC__out DWORD *pdwPort);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetScheme )( 
            IUri * This,
            /* [out] */ __RPC__out DWORD *pdwScheme);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetZone )( 
            IUri * This,
            /* [out] */ __RPC__out DWORD *pdwZone);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IUri * This,
            /* [out] */ __RPC__out LPDWORD pdwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IUri * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [out] */ __RPC__out BOOL *pfEqual);
        
        END_INTERFACE
    } IUriVtbl;

    interface IUri
    {
        CONST_VTBL struct IUriVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUri_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUri_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUri_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUri_GetPropertyBSTR(This,uriProp,pbstrProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyBSTR(This,uriProp,pbstrProperty,dwFlags) ) 

#define IUri_GetPropertyLength(This,uriProp,pcchProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyLength(This,uriProp,pcchProperty,dwFlags) ) 

#define IUri_GetPropertyDWORD(This,uriProp,pdwProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyDWORD(This,uriProp,pdwProperty,dwFlags) ) 

#define IUri_HasProperty(This,uriProp,pfHasProperty)	\
    ( (This)->lpVtbl -> HasProperty(This,uriProp,pfHasProperty) ) 

#define IUri_GetAbsoluteUri(This,pbstrAbsoluteUri)	\
    ( (This)->lpVtbl -> GetAbsoluteUri(This,pbstrAbsoluteUri) ) 

#define IUri_GetAuthority(This,pbstrAuthority)	\
    ( (This)->lpVtbl -> GetAuthority(This,pbstrAuthority) ) 

#define IUri_GetDisplayUri(This,pbstrDisplayString)	\
    ( (This)->lpVtbl -> GetDisplayUri(This,pbstrDisplayString) ) 

#define IUri_GetDomain(This,pbstrDomain)	\
    ( (This)->lpVtbl -> GetDomain(This,pbstrDomain) ) 

#define IUri_GetExtension(This,pbstrExtension)	\
    ( (This)->lpVtbl -> GetExtension(This,pbstrExtension) ) 

#define IUri_GetFragment(This,pbstrFragment)	\
    ( (This)->lpVtbl -> GetFragment(This,pbstrFragment) ) 

#define IUri_GetHost(This,pbstrHost)	\
    ( (This)->lpVtbl -> GetHost(This,pbstrHost) ) 

#define IUri_GetPassword(This,pbstrPassword)	\
    ( (This)->lpVtbl -> GetPassword(This,pbstrPassword) ) 

#define IUri_GetPath(This,pbstrPath)	\
    ( (This)->lpVtbl -> GetPath(This,pbstrPath) ) 

#define IUri_GetPathAndQuery(This,pbstrPathAndQuery)	\
    ( (This)->lpVtbl -> GetPathAndQuery(This,pbstrPathAndQuery) ) 

#define IUri_GetQuery(This,pbstrQuery)	\
    ( (This)->lpVtbl -> GetQuery(This,pbstrQuery) ) 

#define IUri_GetRawUri(This,pbstrRawUri)	\
    ( (This)->lpVtbl -> GetRawUri(This,pbstrRawUri) ) 

#define IUri_GetSchemeName(This,pbstrSchemeName)	\
    ( (This)->lpVtbl -> GetSchemeName(This,pbstrSchemeName) ) 

#define IUri_GetUserInfo(This,pbstrUserInfo)	\
    ( (This)->lpVtbl -> GetUserInfo(This,pbstrUserInfo) ) 

#define IUri_GetUserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> GetUserName(This,pbstrUserName) ) 

#define IUri_GetHostType(This,pdwHostType)	\
    ( (This)->lpVtbl -> GetHostType(This,pdwHostType) ) 

#define IUri_GetPort(This,pdwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pdwPort) ) 

#define IUri_GetScheme(This,pdwScheme)	\
    ( (This)->lpVtbl -> GetScheme(This,pdwScheme) ) 

#define IUri_GetZone(This,pdwZone)	\
    ( (This)->lpVtbl -> GetZone(This,pdwZone) ) 

#define IUri_GetProperties(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetProperties(This,pdwFlags) ) 

#define IUri_IsEqual(This,pUri,pfEqual)	\
    ( (This)->lpVtbl -> IsEqual(This,pUri,pfEqual) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUri_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0012 */
/* [local] */ 

STDAPI CreateUri(__in LPCWSTR pwzURI,
                 __in DWORD dwFlags,
                 __in __reserved DWORD_PTR dwReserved,   // must be 0
                 __out IUri** ppURI);

STDAPI CreateUriWithFragment(
                 __in LPCWSTR pwzURI,
                 __in_opt LPCWSTR pwzFragment,        // can be NULL
                 __in DWORD dwFlags,
                 __in __reserved DWORD_PTR dwReserved,   // must be 0
                 __out IUri** ppURI);

STDAPI CreateUriFromMultiByteString(
    __in       LPCSTR    pszANSIInputUri,
               DWORD     dwEncodingFlags, // ORed set of Uri_ENCODING_ flags
               DWORD     dwCodePage,
               DWORD     dwCreateFlags,
    __reserved DWORD_PTR dwReserved,   // must be 0
    __out      IUri**    ppUri);

//The following flags are used with IUri::GetProperties.
#define Uri_HAS_ABSOLUTE_URI    (1 << Uri_PROPERTY_ABSOLUTE_URI)
#define Uri_HAS_AUTHORITY       (1 << Uri_PROPERTY_AUTHORITY)
#define Uri_HAS_DISPLAY_URI     (1 << Uri_PROPERTY_DISPLAY_URI)
#define Uri_HAS_DOMAIN          (1 << Uri_PROPERTY_DOMAIN)
#define Uri_HAS_EXTENSION       (1 << Uri_PROPERTY_EXTENSION)
#define Uri_HAS_FRAGMENT        (1 << Uri_PROPERTY_FRAGMENT)
#define Uri_HAS_HOST            (1 << Uri_PROPERTY_HOST)
#define Uri_HAS_PASSWORD        (1 << Uri_PROPERTY_PASSWORD)
#define Uri_HAS_PATH            (1 << Uri_PROPERTY_PATH)
#define Uri_HAS_QUERY           (1 << Uri_PROPERTY_QUERY)
#define Uri_HAS_RAW_URI         (1 << Uri_PROPERTY_RAW_URI)
#define Uri_HAS_SCHEME_NAME     (1 << Uri_PROPERTY_SCHEME_NAME)
#define Uri_HAS_USER_NAME       (1 << Uri_PROPERTY_USER_NAME)
#define Uri_HAS_PATH_AND_QUERY  (1 << Uri_PROPERTY_PATH_AND_QUERY)
#define Uri_HAS_USER_INFO       (1 << Uri_PROPERTY_USER_INFO)
#define Uri_HAS_HOST_TYPE       (1 << Uri_PROPERTY_HOST_TYPE)
#define Uri_HAS_PORT            (1 << Uri_PROPERTY_PORT)
#define Uri_HAS_SCHEME          (1 << Uri_PROPERTY_SCHEME)
#define Uri_HAS_ZONE            (1 << Uri_PROPERTY_ZONE)

//The following public Uri_CREATE flags may be passed in 
//through the dwFlags parameter of the CreateUri functions.
//Note that ALLOW_RELATIVE and ALLOW_IMPLICIT_WILDCARD_SCHEME are mutually exclusive and may not be passed together.
#define Uri_CREATE_ALLOW_RELATIVE                 0x00000001    // When the scheme is unspecified and not implicit file, assume relative.
#define Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME 0x00000002    // When the scheme is unspecified and not implicit file, assume wildcard.
#define Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME     0x00000004    // When the scheme is unspecified and it starts with X: or \\ assume its a file scheme.
#define Uri_CREATE_NOFRAG                         0x00000008    // If there's a query string don't look for a fragment
#define Uri_CREATE_NO_CANONICALIZE                0x00000010    // Do not canonicalize the scheme, host, authority, or path
#define Uri_CREATE_CANONICALIZE                   0x00000100    // DEFAULT: Canonicalize the scheme, host, authority, and path
#define Uri_CREATE_FILE_USE_DOS_PATH              0x00000020    // Use DOS path compat mode for file URI creation
#define Uri_CREATE_DECODE_EXTRA_INFO              0x00000040    // Beta2 DEFAULT: Decode the contents of query and fragment, then re-encode reserved characters
#define Uri_CREATE_NO_DECODE_EXTRA_INFO           0x00000080    // Beta1 DEFAULT: Neither decode nor re-encode any part of the query or fragment
#define Uri_CREATE_CRACK_UNKNOWN_SCHEMES          0x00000200    // Beta2 DEFAULT: Heirarchical URIs with present and unknown schemes will be treated like heirarchical URIs
#define Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES       0x00000400    // Beta1 DEFAULT: Heirarchical URIs with present and unknown schemes will be treated like opaque URIs
#define Uri_CREATE_PRE_PROCESS_HTML_URI           0x00000800    // DEFAULT:  Perform pre-processing on the URI to remove control characters and whitespace as if the URI comes from the raw href value of an HTML page.
#define Uri_CREATE_NO_PRE_PROCESS_HTML_URI        0x00001000    // Don't perform pre-processing to remove control characters and whitespace as appropriate.
#define Uri_CREATE_IE_SETTINGS                    0x00002000    // Use IE registry settings for such things as whether or not to use IDN.
#define Uri_CREATE_NO_IE_SETTINGS                 0x00004000    // DEFAULT: Don't use IE registry settings.
#define Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS 0x00008000    // Don't percent-encode characters that are forbidden by the RFC.
//The following flags may be passed in through the dwFlags 
//parameter of the IUri::GetPropertyBSTR or IUri::GetPropertyLength functions.
//The following flags apply only to the property Uri_PROPERTY_DISPLAY_URI:
#define Uri_DISPLAY_NO_FRAGMENT               0x00000001    // Exclude fragment from the DisplayUri, if one exists
#define Uri_PUNYCODE_IDN_HOST                 0x00000002    // Show the hostname encoded as punycode inside the Host, Domain, or AbsoluteUri properties, if the Uri is IDN
#define Uri_DISPLAY_IDN_HOST                  0x00000004    // Show the hostname encoded as punycode or Unicode as it would appear in the DisplayUri property. This applies to the Host, Domain, and AbsoluteUri properties.
// The following are Uri_ENCODING_ flags for use with the function CreateUriFromMultiByteString
#define Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8  0x00000001
#define Uri_ENCODING_USER_INFO_AND_PATH_IS_CP                    0x00000002
#define Uri_ENCODING_HOST_IS_IDN                                 0x00000004
#define Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8                0x00000008
#define Uri_ENCODING_HOST_IS_PERCENT_ENCODED_CP                  0x00000010
#define Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8  0x00000020
#define Uri_ENCODING_QUERY_AND_FRAGMENT_IS_CP                    0x00000040
#define Uri_ENCODING_RFC (Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8 | Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8 | Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8)

//The following flags may be passed in through the dwUriBuilderFlags 
//parameter of the IUriBuilder::CreateUri
#define UriBuilder_USE_ORIGINAL_FLAGS             0x00000001    // Use the create flags from the underlying IUri if they are available.

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_s_ifspec;

#ifndef __IUriContainer_INTERFACE_DEFINED__
#define __IUriContainer_INTERFACE_DEFINED__

/* interface IUriContainer */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IUriContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a158a630-ed6f-45fb-b987-f68676f57752")
    IUriContainer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIUri( 
            /* [out] */ IUri **ppIUri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriContainer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIUri )( 
            IUriContainer * This,
            /* [out] */ IUri **ppIUri);
        
        END_INTERFACE
    } IUriContainerVtbl;

    interface IUriContainer
    {
        CONST_VTBL struct IUriContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriContainer_GetIUri(This,ppIUri)	\
    ( (This)->lpVtbl -> GetIUri(This,ppIUri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0013 */
/* [local] */ 

#if !defined(SORTPP_PASS)
//                       Temporary workaround for sortpp.exe problem in base\wow64\cgen
//                       Windows OS Bug 2242537 tracks this build break for 64-bit platforms


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_s_ifspec;

#ifndef __IUriBuilder_INTERFACE_DEFINED__
#define __IUriBuilder_INTERFACE_DEFINED__

/* interface IUriBuilder */
/* [unique][uuid][object][local][helpstring] */ 


EXTERN_C const IID IID_IUriBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4221B2E1-8955-46c0-BD5B-DE9897565DE7")
    IUriBuilder : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateUriSimple( 
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUri **ppIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateUri( 
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUri **ppIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateUriWithFlags( 
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwUriBuilderFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUri **ppIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIUri( 
            /* [out] */ 
            __deref_out_opt  IUri **ppIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIUri( 
            /* [unique][in] */ 
            __in_opt  IUri *pIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFragment( 
            /* [out] */ 
            __out  DWORD *pcchFragment,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzFragment) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHost( 
            /* [out] */ 
            __out  DWORD *pcchHost,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzHost) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPassword( 
            /* [out] */ 
            __out  DWORD *pcchPassword,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzPassword) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ 
            __out  DWORD *pcchPath,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ 
            __out  BOOL *pfHasPort,
            /* [out] */ 
            __out  DWORD *pdwPort) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out] */ 
            __out  DWORD *pcchQuery,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzQuery) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSchemeName( 
            /* [out] */ 
            __out  DWORD *pcchSchemeName,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzSchemeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserName( 
            /* [out] */ 
            __out  DWORD *pcchUserName,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzUserName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFragment( 
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetHost( 
            /* [in] */ 
            __in  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPort( 
            /* [in] */ BOOL fHasPort,
            /* [in] */ DWORD dwNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetQuery( 
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSchemeName( 
            /* [in] */ 
            __in  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUserName( 
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveProperties( 
            /* [in] */ DWORD dwPropertyMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HasBeenModified( 
            /* [out] */ 
            __out  BOOL *pfModified) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriBuilder * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateUriSimple )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUri **ppIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateUri )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUri **ppIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateUriWithFlags )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwUriBuilderFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUri **ppIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIUri )( 
            IUriBuilder * This,
            /* [out] */ 
            __deref_out_opt  IUri **ppIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIUri )( 
            IUriBuilder * This,
            /* [unique][in] */ 
            __in_opt  IUri *pIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFragment )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  DWORD *pcchFragment,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzFragment);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHost )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  DWORD *pcchHost,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzHost);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPassword )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  DWORD *pcchPassword,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzPassword);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  DWORD *pcchPath,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  BOOL *pfHasPort,
            /* [out] */ 
            __out  DWORD *pdwPort);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  DWORD *pcchQuery,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzQuery);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSchemeName )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  DWORD *pcchSchemeName,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzSchemeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserName )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  DWORD *pcchUserName,
            /* [out] */ 
            __deref_out_opt  LPCWSTR *ppwzUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFragment )( 
            IUriBuilder * This,
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetHost )( 
            IUriBuilder * This,
            /* [in] */ 
            __in  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IUriBuilder * This,
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IUriBuilder * This,
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            IUriBuilder * This,
            /* [in] */ BOOL fHasPort,
            /* [in] */ DWORD dwNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetQuery )( 
            IUriBuilder * This,
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSchemeName )( 
            IUriBuilder * This,
            /* [in] */ 
            __in  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetUserName )( 
            IUriBuilder * This,
            /* [in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveProperties )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwPropertyMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *HasBeenModified )( 
            IUriBuilder * This,
            /* [out] */ 
            __out  BOOL *pfModified);
        
        END_INTERFACE
    } IUriBuilderVtbl;

    interface IUriBuilder
    {
        CONST_VTBL struct IUriBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriBuilder_CreateUriSimple(This,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUriSimple(This,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_CreateUri(This,dwCreateFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUri(This,dwCreateFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_CreateUriWithFlags(This,dwCreateFlags,dwUriBuilderFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUriWithFlags(This,dwCreateFlags,dwUriBuilderFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_GetIUri(This,ppIUri)	\
    ( (This)->lpVtbl -> GetIUri(This,ppIUri) ) 

#define IUriBuilder_SetIUri(This,pIUri)	\
    ( (This)->lpVtbl -> SetIUri(This,pIUri) ) 

#define IUriBuilder_GetFragment(This,pcchFragment,ppwzFragment)	\
    ( (This)->lpVtbl -> GetFragment(This,pcchFragment,ppwzFragment) ) 

#define IUriBuilder_GetHost(This,pcchHost,ppwzHost)	\
    ( (This)->lpVtbl -> GetHost(This,pcchHost,ppwzHost) ) 

#define IUriBuilder_GetPassword(This,pcchPassword,ppwzPassword)	\
    ( (This)->lpVtbl -> GetPassword(This,pcchPassword,ppwzPassword) ) 

#define IUriBuilder_GetPath(This,pcchPath,ppwzPath)	\
    ( (This)->lpVtbl -> GetPath(This,pcchPath,ppwzPath) ) 

#define IUriBuilder_GetPort(This,pfHasPort,pdwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pfHasPort,pdwPort) ) 

#define IUriBuilder_GetQuery(This,pcchQuery,ppwzQuery)	\
    ( (This)->lpVtbl -> GetQuery(This,pcchQuery,ppwzQuery) ) 

#define IUriBuilder_GetSchemeName(This,pcchSchemeName,ppwzSchemeName)	\
    ( (This)->lpVtbl -> GetSchemeName(This,pcchSchemeName,ppwzSchemeName) ) 

#define IUriBuilder_GetUserName(This,pcchUserName,ppwzUserName)	\
    ( (This)->lpVtbl -> GetUserName(This,pcchUserName,ppwzUserName) ) 

#define IUriBuilder_SetFragment(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetFragment(This,pwzNewValue) ) 

#define IUriBuilder_SetHost(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetHost(This,pwzNewValue) ) 

#define IUriBuilder_SetPassword(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetPassword(This,pwzNewValue) ) 

#define IUriBuilder_SetPath(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetPath(This,pwzNewValue) ) 

#define IUriBuilder_SetPort(This,fHasPort,dwNewValue)	\
    ( (This)->lpVtbl -> SetPort(This,fHasPort,dwNewValue) ) 

#define IUriBuilder_SetQuery(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetQuery(This,pwzNewValue) ) 

#define IUriBuilder_SetSchemeName(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetSchemeName(This,pwzNewValue) ) 

#define IUriBuilder_SetUserName(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetUserName(This,pwzNewValue) ) 

#define IUriBuilder_RemoveProperties(This,dwPropertyMask)	\
    ( (This)->lpVtbl -> RemoveProperties(This,dwPropertyMask) ) 

#define IUriBuilder_HasBeenModified(This,pfModified)	\
    ( (This)->lpVtbl -> HasBeenModified(This,pfModified) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriBuilder_INTERFACE_DEFINED__ */


#ifndef __IUriBuilderFactory_INTERFACE_DEFINED__
#define __IUriBuilderFactory_INTERFACE_DEFINED__

/* interface IUriBuilderFactory */
/* [unique][uuid][object][local][helpstring] */ 


EXTERN_C const IID IID_IUriBuilderFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E982CE48-0B96-440c-BC37-0C869B27A29E")
    IUriBuilderFactory : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateIUriBuilder( 
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [in] */ 
            __in  DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUriBuilder **ppIUriBuilder) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateInitializedIUriBuilder( 
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [in] */ 
            __in  DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUriBuilder **ppIUriBuilder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriBuilderFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriBuilderFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriBuilderFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriBuilderFactory * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateIUriBuilder )( 
            IUriBuilderFactory * This,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [in] */ 
            __in  DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUriBuilder **ppIUriBuilder);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateInitializedIUriBuilder )( 
            IUriBuilderFactory * This,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [in] */ 
            __in  DWORD_PTR dwReserved,
            /* [out] */ 
            __deref_out  IUriBuilder **ppIUriBuilder);
        
        END_INTERFACE
    } IUriBuilderFactoryVtbl;

    interface IUriBuilderFactory
    {
        CONST_VTBL struct IUriBuilderFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriBuilderFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriBuilderFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriBuilderFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriBuilderFactory_CreateIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder)	\
    ( (This)->lpVtbl -> CreateIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder) ) 

#define IUriBuilderFactory_CreateInitializedIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder)	\
    ( (This)->lpVtbl -> CreateInitializedIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriBuilderFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0015 */
/* [local] */ 

STDAPI CreateIUriBuilder(
    __in_opt    IUri         *pIUri,
    __in        DWORD         dwFlags,
    __in        DWORD_PTR     dwReserved,
    __deref_out IUriBuilder **ppIUriBuilder
    );
#endif // (!defined(SORTPP_PASS)
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPWININETINFO_DEFINED
#define _LPWININETINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_s_ifspec;

#ifndef __IWinInetInfo_INTERFACE_DEFINED__
#define __IWinInetInfo_INTERFACE_DEFINED__

/* interface IWinInetInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IWinInetInfo *LPWININETINFO;


EXTERN_C const IID IID_IWinInetInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d6-bafa-11ce-8c82-00aa004ba90b")
    IWinInetInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryOption( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryOption )( 
            IWinInetInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf);
        
        END_INTERFACE
    } IWinInetInfoVtbl;

    interface IWinInetInfo
    {
        CONST_VTBL struct IWinInetInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)	\
    ( (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_RemoteQueryOption_Proxy( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf);


void __RPC_STUB IWinInetInfo_RemoteQueryOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinInetInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0016 */
/* [local] */ 

#endif
#define WININETINFO_OPTION_LOCK_HANDLE 65534
#ifndef _LPHTTPSECURITY_DEFINED
#define _LPHTTPSECURITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0016_v0_0_s_ifspec;

#ifndef __IHttpSecurity_INTERFACE_DEFINED__
#define __IHttpSecurity_INTERFACE_DEFINED__

/* interface IHttpSecurity */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IHttpSecurity *LPHTTPSECURITY;


EXTERN_C const IID IID_IHttpSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d7-bafa-11ce-8c82-00aa004ba90b")
    IHttpSecurity : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSecurityProblem( 
            /* [in] */ DWORD dwProblem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpSecurity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpSecurity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpSecurity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IHttpSecurity * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSecurityProblem )( 
            IHttpSecurity * This,
            /* [in] */ DWORD dwProblem);
        
        END_INTERFACE
    } IHttpSecurityVtbl;

    interface IHttpSecurity
    {
        CONST_VTBL struct IHttpSecurityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpSecurity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpSecurity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpSecurity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpSecurity_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 


#define IHttpSecurity_OnSecurityProblem(This,dwProblem)	\
    ( (This)->lpVtbl -> OnSecurityProblem(This,dwProblem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpSecurity_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0017 */
/* [local] */ 

#endif
#ifndef _LPWININETHTTPINFO_DEFINED
#define _LPWININETHTTPINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0017_v0_0_s_ifspec;

#ifndef __IWinInetHttpInfo_INTERFACE_DEFINED__
#define __IWinInetHttpInfo_INTERFACE_DEFINED__

/* interface IWinInetHttpInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IWinInetHttpInfo *LPWININETHTTPINFO;


EXTERN_C const IID IID_IWinInetHttpInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d8-bafa-11ce-8c82-00aa004ba90b")
    IWinInetHttpInfo : public IWinInetInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetHttpInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetHttpInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetHttpInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetHttpInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryOption )( 
            IWinInetHttpInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IWinInetHttpInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetHttpInfoVtbl;

    interface IWinInetHttpInfo
    {
        CONST_VTBL struct IWinInetHttpInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetHttpInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetHttpInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetHttpInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetHttpInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)	\
    ( (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf) ) 


#define IWinInetHttpInfo_QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved)	\
    ( (This)->lpVtbl -> QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_RemoteQueryInfo_Proxy( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf,
    /* [out][in] */ __RPC__inout DWORD *pdwFlags,
    /* [out][in] */ __RPC__inout DWORD *pdwReserved);


void __RPC_STUB IWinInetHttpInfo_RemoteQueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinInetHttpInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0018 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPWININETCACHEHINTS_DEFINED
#define _LPWININETCACHEHINTS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_s_ifspec;

#ifndef __IWinInetCacheHints_INTERFACE_DEFINED__
#define __IWinInetCacheHints_INTERFACE_DEFINED__

/* interface IWinInetCacheHints */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWinInetCacheHints *LPWININETCACHEHINTS;


EXTERN_C const IID IID_IWinInetCacheHints;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD1EC3B3-8391-4fdb-A9E6-347C3CAAA7DD")
    IWinInetCacheHints : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCacheExtension( 
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetCacheHintsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetCacheHints * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetCacheHints * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetCacheHints * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension )( 
            IWinInetCacheHints * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetCacheHintsVtbl;

    interface IWinInetCacheHints
    {
        CONST_VTBL struct IWinInetCacheHintsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetCacheHints_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetCacheHints_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetCacheHints_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetCacheHints_SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetCacheHints_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0019 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPWININETCACHEHINTS2_DEFINED
#define _LPWININETCACHEHINTS2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_s_ifspec;

#ifndef __IWinInetCacheHints2_INTERFACE_DEFINED__
#define __IWinInetCacheHints2_INTERFACE_DEFINED__

/* interface IWinInetCacheHints2 */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWinInetCacheHints2 *LPWININETCACHEHINTS2;


EXTERN_C const IID IID_IWinInetCacheHints2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7857AEAC-D31F-49bf-884E-DD46DF36780A")
    IWinInetCacheHints2 : public IWinInetCacheHints
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCacheExtension2( 
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out] */ WCHAR *pwzCacheFile,
            /* [out][in] */ DWORD *pcchCacheFile,
            /* [out] */ DWORD *pdwWinInetError,
            /* [out] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetCacheHints2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetCacheHints2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetCacheHints2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetCacheHints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension )( 
            IWinInetCacheHints2 * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension2 )( 
            IWinInetCacheHints2 * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out] */ WCHAR *pwzCacheFile,
            /* [out][in] */ DWORD *pcchCacheFile,
            /* [out] */ DWORD *pdwWinInetError,
            /* [out] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetCacheHints2Vtbl;

    interface IWinInetCacheHints2
    {
        CONST_VTBL struct IWinInetCacheHints2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetCacheHints2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetCacheHints2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetCacheHints2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetCacheHints2_SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved) ) 


#define IWinInetCacheHints2_SetCacheExtension2(This,pwzExt,pwzCacheFile,pcchCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension2(This,pwzExt,pwzCacheFile,pcchCacheFile,pdwWinInetError,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetCacheHints2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0020 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define SID_IBindHost IID_IBindHost
#define SID_SBindHost IID_IBindHost
#ifndef _LPBINDHOST_DEFINED
#define _LPBINDHOST_DEFINED
EXTERN_C const GUID SID_BindHost;


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_s_ifspec;

#ifndef __IBindHost_INTERFACE_DEFINED__
#define __IBindHost_INTERFACE_DEFINED__

/* interface IBindHost */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IBindHost *LPBINDHOST;


EXTERN_C const IID IID_IBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc4801a1-2ba9-11cf-a229-00aa003d7352")
    IBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMoniker( 
            /* [in] */ __RPC__in LPOLESTR szName,
            /* [in] */ __RPC__in_opt IBindCtx *pBC,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppmk,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToStorage( 
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToObject( 
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMoniker )( 
            IBindHost * This,
            /* [in] */ __RPC__in LPOLESTR szName,
            /* [in] */ __RPC__in_opt IBindCtx *pBC,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppmk,
            /* [in] */ DWORD dwReserved);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MonikerBindToStorage )( 
            IBindHost * This,
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MonikerBindToObject )( 
            IBindHost * This,
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj);
        
        END_INTERFACE
    } IBindHostVtbl;

    interface IBindHost
    {
        CONST_VTBL struct IBindHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindHost_CreateMoniker(This,szName,pBC,ppmk,dwReserved)	\
    ( (This)->lpVtbl -> CreateMoniker(This,szName,pBC,ppmk,dwReserved) ) 

#define IBindHost_MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)	\
    ( (This)->lpVtbl -> MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj) ) 

#define IBindHost_MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)	\
    ( (This)->lpVtbl -> MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToStorage_Proxy( 
    IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToObject_Proxy( 
    IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0021 */
/* [local] */ 

#endif
                                                                                                           
// These are for backwards compatibility with previous URLMON versions
// Flags for the UrlDownloadToCacheFile                                                                    
#define URLOSTRM_USECACHEDCOPY_ONLY             0x1      // Only get from cache                            
#define URLOSTRM_USECACHEDCOPY                  0x2      // Get from cache if available else download      
#define URLOSTRM_GETNEWESTVERSION               0x3      // Get new version only. But put it in cache too  
                                                                                                           
                                                                                                           
struct IBindStatusCallback;                                                                                
STDAPI HlinkSimpleNavigateToString(                                                                        
    /* [in] */ LPCWSTR szTarget,         // required - target document - null if local jump w/in doc       
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI HlinkSimpleNavigateToMoniker(                                                                       
    /* [in] */ IMoniker *pmkTarget,      // required - target document - (may be null                      
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                        
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                       
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                    
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                   
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                             
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                           
STDAPI URLDownloadToCacheFileA(__in LPUNKNOWN, __in LPCSTR,  __out_ecount(cchFileName) LPSTR,  DWORD cchFileName, DWORD, __in LPBINDSTATUSCALLBACK);                   
STDAPI URLDownloadToCacheFileW(__in LPUNKNOWN, __in LPCWSTR, __out_ecount(cchFileName) LPWSTR, DWORD cchFileName, DWORD, __in LPBINDSTATUSCALLBACK);                 
STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                      
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                     
                                                                                                           
#ifdef UNICODE                                                                                             
#define URLOpenStream            URLOpenStreamW                                                            
#define URLOpenPullStream        URLOpenPullStreamW                                                        
#define URLDownloadToFile        URLDownloadToFileW                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileW                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamW                                                    
#else                                                                                                      
#define URLOpenStream            URLOpenStreamA                                                            
#define URLOpenPullStream        URLOpenPullStreamA                                                        
#define URLDownloadToFile        URLDownloadToFileA                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileA                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamA                                                    
#endif // !UNICODE                                                                                         
                                                                                                           
                                                                                                           
STDAPI HlinkGoBack(IUnknown *pUnk);                                                                        
STDAPI HlinkGoForward(IUnknown *pUnk);                                                                     
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);                                              
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);                                          
                                                                                                           
#ifndef  _URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_   









#ifndef _LPIINTERNET
#define _LPIINTERNET


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_s_ifspec;

#ifndef __IInternet_INTERFACE_DEFINED__
#define __IInternet_INTERFACE_DEFINED__

/* interface IInternet */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternet *LPIINTERNET;


EXTERN_C const IID IID_IInternet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e0-baf9-11ce-8c82-00aa004ba90b")
    IInternet : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInternetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternet * This);
        
        END_INTERFACE
    } IInternetVtbl;

    interface IInternet
    {
        CONST_VTBL struct IInternetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternet_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0022 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETBINDINFO
#define _LPIINTERNETBINDINFO


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_s_ifspec;

#ifndef __IInternetBindInfo_INTERFACE_DEFINED__
#define __IInternetBindInfo_INTERFACE_DEFINED__

/* interface IInternetBindInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetBindInfo *LPIINTERNETBINDINFO;

typedef 
enum tagBINDSTRING
    {	BINDSTRING_HEADERS	= 1,
	BINDSTRING_ACCEPT_MIMES	= ( BINDSTRING_HEADERS + 1 ) ,
	BINDSTRING_EXTRA_URL	= ( BINDSTRING_ACCEPT_MIMES + 1 ) ,
	BINDSTRING_LANGUAGE	= ( BINDSTRING_EXTRA_URL + 1 ) ,
	BINDSTRING_USERNAME	= ( BINDSTRING_LANGUAGE + 1 ) ,
	BINDSTRING_PASSWORD	= ( BINDSTRING_USERNAME + 1 ) ,
	BINDSTRING_UA_PIXELS	= ( BINDSTRING_PASSWORD + 1 ) ,
	BINDSTRING_UA_COLOR	= ( BINDSTRING_UA_PIXELS + 1 ) ,
	BINDSTRING_OS	= ( BINDSTRING_UA_COLOR + 1 ) ,
	BINDSTRING_USER_AGENT	= ( BINDSTRING_OS + 1 ) ,
	BINDSTRING_ACCEPT_ENCODINGS	= ( BINDSTRING_USER_AGENT + 1 ) ,
	BINDSTRING_POST_COOKIE	= ( BINDSTRING_ACCEPT_ENCODINGS + 1 ) ,
	BINDSTRING_POST_DATA_MIME	= ( BINDSTRING_POST_COOKIE + 1 ) ,
	BINDSTRING_URL	= ( BINDSTRING_POST_DATA_MIME + 1 ) ,
	BINDSTRING_IID	= ( BINDSTRING_URL + 1 ) ,
	BINDSTRING_FLAG_BIND_TO_OBJECT	= ( BINDSTRING_IID + 1 ) ,
	BINDSTRING_PTR_BIND_CONTEXT	= ( BINDSTRING_FLAG_BIND_TO_OBJECT + 1 ) 
    } 	BINDSTRING;


EXTERN_C const IID IID_IInternetBindInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e1-baf9-11ce-8c82-00aa004ba90b")
    IInternetBindInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindString( 
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetBindInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetBindInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetBindInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetBindInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IInternetBindInfo * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindString )( 
            IInternetBindInfo * This,
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched);
        
        END_INTERFACE
    } IInternetBindInfoVtbl;

    interface IInternetBindInfo
    {
        CONST_VTBL struct IInternetBindInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetBindInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetBindInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetBindInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetBindInfo_GetBindInfo(This,grfBINDF,pbindinfo)	\
    ( (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo) ) 

#define IInternetBindInfo_GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)	\
    ( (This)->lpVtbl -> GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetBindInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0023 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLROOT_DEFINED
#define _LPIINTERNETPROTOCOLROOT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_s_ifspec;

#ifndef __IInternetProtocolRoot_INTERFACE_DEFINED__
#define __IInternetProtocolRoot_INTERFACE_DEFINED__

/* interface IInternetProtocolRoot */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolRoot *LPIINTERNETPROTOCOLROOT;

typedef 
enum _tagPI_FLAGS
    {	PI_PARSE_URL	= 0x1,
	PI_FILTER_MODE	= 0x2,
	PI_FORCE_ASYNC	= 0x4,
	PI_USE_WORKERTHREAD	= 0x8,
	PI_MIMEVERIFICATION	= 0x10,
	PI_CLSIDLOOKUP	= 0x20,
	PI_DATAPROGRESS	= 0x40,
	PI_SYNCHRONOUS	= 0x80,
	PI_APARTMENTTHREADED	= 0x100,
	PI_CLASSINSTALL	= 0x200,
	PI_PASSONBINDCTX	= 0x2000,
	PI_NOMIMEHANDLER	= 0x8000,
	PI_LOADAPPDIRECT	= 0x4000,
	PD_FORCE_SWITCH	= 0x10000,
	PI_PREFERDEFAULTHANDLER	= 0x20000
    } 	PI_FLAGS;

typedef struct _tagPROTOCOLDATA
    {
    DWORD grfFlags;
    DWORD dwState;
    LPVOID pData;
    ULONG cbData;
    } 	PROTOCOLDATA;

typedef struct _tagStartParam
    {
    IID iid;
    IBindCtx *pIBindCtx;
    IUnknown *pItf;
    } 	StartParam;


EXTERN_C const IID IID_IInternetProtocolRoot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e3-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ PROTOCOLDATA *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolRootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolRoot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolRoot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocolRoot * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocolRoot * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocolRoot * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocolRoot * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocolRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocolRoot * This);
        
        END_INTERFACE
    } IInternetProtocolRootVtbl;

    interface IInternetProtocolRoot
    {
        CONST_VTBL struct IInternetProtocolRootVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolRoot_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolRoot_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolRoot_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolRoot_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocolRoot_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocolRoot_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocolRoot_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocolRoot_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocolRoot_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolRoot_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0024 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOL_DEFINED
#define _LPIINTERNETPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_s_ifspec;

#ifndef __IInternetProtocol_INTERFACE_DEFINED__
#define __IInternetProtocol_INTERFACE_DEFINED__

/* interface IInternetProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocol *LPIINTERNETPROTOCOL;


EXTERN_C const IID IID_IInternetProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e4-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocol : public IInternetProtocolRoot
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockRequest( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockRequest( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocol * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocol * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocol * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocol * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IInternetProtocol * This,
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IInternetProtocol * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *LockRequest )( 
            IInternetProtocol * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRequest )( 
            IInternetProtocol * This);
        
        END_INTERFACE
    } IInternetProtocolVtbl;

    interface IInternetProtocol
    {
        CONST_VTBL struct IInternetProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocol_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocol_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocol_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocol_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocol_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocol_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 


#define IInternetProtocol_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IInternetProtocol_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IInternetProtocol_LockRequest(This,dwOptions)	\
    ( (This)->lpVtbl -> LockRequest(This,dwOptions) ) 

#define IInternetProtocol_UnlockRequest(This)	\
    ( (This)->lpVtbl -> UnlockRequest(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0025 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPIINTERNETPROTOCOLEX_DEFINED
#define _LPIINTERNETPROTOCOLEX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_s_ifspec;

#ifndef __IInternetProtocolEx_INTERFACE_DEFINED__
#define __IInternetProtocolEx_INTERFACE_DEFINED__

/* interface IInternetProtocolEx */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetProtocolEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C7A98E66-1010-492c-A1C8-C809E1F75905")
    IInternetProtocolEx : public IInternetProtocol
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartEx( 
            /* [in] */ IUri *pUri,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocolEx * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocolEx * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocolEx * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocolEx * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IInternetProtocolEx * This,
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IInternetProtocolEx * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *LockRequest )( 
            IInternetProtocolEx * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRequest )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartEx )( 
            IInternetProtocolEx * This,
            /* [in] */ IUri *pUri,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        END_INTERFACE
    } IInternetProtocolExVtbl;

    interface IInternetProtocolEx
    {
        CONST_VTBL struct IInternetProtocolExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolEx_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocolEx_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocolEx_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocolEx_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocolEx_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocolEx_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 


#define IInternetProtocolEx_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IInternetProtocolEx_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IInternetProtocolEx_LockRequest(This,dwOptions)	\
    ( (This)->lpVtbl -> LockRequest(This,dwOptions) ) 

#define IInternetProtocolEx_UnlockRequest(This)	\
    ( (This)->lpVtbl -> UnlockRequest(This) ) 


#define IInternetProtocolEx_StartEx(This,pUri,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> StartEx(This,pUri,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0026 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPIINTERNETPROTOCOLSINK_DEFINED
#define _LPIINTERNETPROTOCOLSINK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_s_ifspec;

#ifndef __IInternetProtocolSink_INTERFACE_DEFINED__
#define __IInternetProtocolSink_INTERFACE_DEFINED__

/* interface IInternetProtocolSink */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolSink *LPIINTERNETPROTOCOLSINK;


EXTERN_C const IID IID_IInternetProtocolSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e5-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Switch( 
            /* [in] */ PROTOCOLDATA *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportProgress( 
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportData( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportResult( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Switch )( 
            IInternetProtocolSink * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *ReportProgress )( 
            IInternetProtocolSink * This,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *ReportData )( 
            IInternetProtocolSink * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax);
        
        HRESULT ( STDMETHODCALLTYPE *ReportResult )( 
            IInternetProtocolSink * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult);
        
        END_INTERFACE
    } IInternetProtocolSinkVtbl;

    interface IInternetProtocolSink
    {
        CONST_VTBL struct IInternetProtocolSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolSink_Switch(This,pProtocolData)	\
    ( (This)->lpVtbl -> Switch(This,pProtocolData) ) 

#define IInternetProtocolSink_ReportProgress(This,ulStatusCode,szStatusText)	\
    ( (This)->lpVtbl -> ReportProgress(This,ulStatusCode,szStatusText) ) 

#define IInternetProtocolSink_ReportData(This,grfBSCF,ulProgress,ulProgressMax)	\
    ( (This)->lpVtbl -> ReportData(This,grfBSCF,ulProgress,ulProgressMax) ) 

#define IInternetProtocolSink_ReportResult(This,hrResult,dwError,szResult)	\
    ( (This)->lpVtbl -> ReportResult(This,hrResult,dwError,szResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0027 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED
#define _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_s_ifspec;

#ifndef __IInternetProtocolSinkStackable_INTERFACE_DEFINED__
#define __IInternetProtocolSinkStackable_INTERFACE_DEFINED__

/* interface IInternetProtocolSinkStackable */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolSinkStackable *LPIINTERNETPROTOCOLSINKStackable;


EXTERN_C const IID IID_IInternetProtocolSinkStackable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9f0-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolSinkStackable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SwitchSink( 
            /* [in] */ IInternetProtocolSink *pOIProtSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitSwitch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RollbackSwitch( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolSinkStackableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolSinkStackable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolSinkStackable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolSinkStackable * This);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchSink )( 
            IInternetProtocolSinkStackable * This,
            /* [in] */ IInternetProtocolSink *pOIProtSink);
        
        HRESULT ( STDMETHODCALLTYPE *CommitSwitch )( 
            IInternetProtocolSinkStackable * This);
        
        HRESULT ( STDMETHODCALLTYPE *RollbackSwitch )( 
            IInternetProtocolSinkStackable * This);
        
        END_INTERFACE
    } IInternetProtocolSinkStackableVtbl;

    interface IInternetProtocolSinkStackable
    {
        CONST_VTBL struct IInternetProtocolSinkStackableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolSinkStackable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolSinkStackable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolSinkStackable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolSinkStackable_SwitchSink(This,pOIProtSink)	\
    ( (This)->lpVtbl -> SwitchSink(This,pOIProtSink) ) 

#define IInternetProtocolSinkStackable_CommitSwitch(This)	\
    ( (This)->lpVtbl -> CommitSwitch(This) ) 

#define IInternetProtocolSinkStackable_RollbackSwitch(This)	\
    ( (This)->lpVtbl -> RollbackSwitch(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolSinkStackable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0028 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETSESSION_DEFINED
#define _LPIINTERNETSESSION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_s_ifspec;

#ifndef __IInternetSession_INTERFACE_DEFINED__
#define __IInternetSession_INTERFACE_DEFINED__

/* interface IInternetSession */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetSession *LPIINTERNETSESSION;

typedef 
enum _tagOIBDG_FLAGS
    {	OIBDG_APARTMENTTHREADED	= 0x100,
	OIBDG_DATAONLY	= 0x1000
    } 	OIBDG_FLAGS;


EXTERN_C const IID IID_IInternetSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e7-baf9-11ce-8c82-00aa004ba90b")
    IInternetSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterNameSpace( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR *ppwzPatterns,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterNameSpace( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pszProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterMimeFilter( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterMimeFilter( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown *pUnkOuter,
            /* [unique][out] */ IUnknown **ppUnk,
            /* [unique][out] */ IInternetProtocol **ppOInetProt,
            /* [in] */ DWORD dwOption) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pdwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNameSpace )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR *ppwzPatterns,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterNameSpace )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pszProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterMimeFilter )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterMimeFilter )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBinding )( 
            IInternetSession * This,
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown *pUnkOuter,
            /* [unique][out] */ IUnknown **ppUnk,
            /* [unique][out] */ IInternetProtocol **ppOInetProt,
            /* [in] */ DWORD dwOption);
        
        HRESULT ( STDMETHODCALLTYPE *SetSessionOption )( 
            IInternetSession * This,
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionOption )( 
            IInternetSession * This,
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pdwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetSessionVtbl;

    interface IInternetSession
    {
        CONST_VTBL struct IInternetSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSession_RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved)	\
    ( (This)->lpVtbl -> RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved) ) 

#define IInternetSession_UnregisterNameSpace(This,pCF,pszProtocol)	\
    ( (This)->lpVtbl -> UnregisterNameSpace(This,pCF,pszProtocol) ) 

#define IInternetSession_RegisterMimeFilter(This,pCF,rclsid,pwzType)	\
    ( (This)->lpVtbl -> RegisterMimeFilter(This,pCF,rclsid,pwzType) ) 

#define IInternetSession_UnregisterMimeFilter(This,pCF,pwzType)	\
    ( (This)->lpVtbl -> UnregisterMimeFilter(This,pCF,pwzType) ) 

#define IInternetSession_CreateBinding(This,pBC,szUrl,pUnkOuter,ppUnk,ppOInetProt,dwOption)	\
    ( (This)->lpVtbl -> CreateBinding(This,pBC,szUrl,pUnkOuter,ppUnk,ppOInetProt,dwOption) ) 

#define IInternetSession_SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved)	\
    ( (This)->lpVtbl -> SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved) ) 

#define IInternetSession_GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved)	\
    ( (This)->lpVtbl -> GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0029 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETTHREADSWITCH_DEFINED
#define _LPIINTERNETTHREADSWITCH_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_s_ifspec;

#ifndef __IInternetThreadSwitch_INTERFACE_DEFINED__
#define __IInternetThreadSwitch_INTERFACE_DEFINED__

/* interface IInternetThreadSwitch */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetThreadSwitch *LPIINTERNETTHREADSWITCH;


EXTERN_C const IID IID_IInternetThreadSwitch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e8-baf9-11ce-8c82-00aa004ba90b")
    IInternetThreadSwitch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetThreadSwitchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetThreadSwitch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetThreadSwitch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetThreadSwitch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prepare )( 
            IInternetThreadSwitch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetThreadSwitch * This);
        
        END_INTERFACE
    } IInternetThreadSwitchVtbl;

    interface IInternetThreadSwitch
    {
        CONST_VTBL struct IInternetThreadSwitchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetThreadSwitch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetThreadSwitch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetThreadSwitch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetThreadSwitch_Prepare(This)	\
    ( (This)->lpVtbl -> Prepare(This) ) 

#define IInternetThreadSwitch_Continue(This)	\
    ( (This)->lpVtbl -> Continue(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetThreadSwitch_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0030 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPRIORITY_DEFINED
#define _LPIINTERNETPRIORITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_s_ifspec;

#ifndef __IInternetPriority_INTERFACE_DEFINED__
#define __IInternetPriority_INTERFACE_DEFINED__

/* interface IInternetPriority */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetPriority *LPIINTERNETPRIORITY;


EXTERN_C const IID IID_IInternetPriority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9eb-baf9-11ce-8c82-00aa004ba90b")
    IInternetPriority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG *pnPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetPriorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetPriority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetPriority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetPriority * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IInternetPriority * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IInternetPriority * This,
            /* [out] */ LONG *pnPriority);
        
        END_INTERFACE
    } IInternetPriorityVtbl;

    interface IInternetPriority
    {
        CONST_VTBL struct IInternetPriorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetPriority_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetPriority_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetPriority_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetPriority_SetPriority(This,nPriority)	\
    ( (This)->lpVtbl -> SetPriority(This,nPriority) ) 

#define IInternetPriority_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetPriority_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0031 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLINFO_DEFINED
#define _LPIINTERNETPROTOCOLINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_s_ifspec;

#ifndef __IInternetProtocolInfo_INTERFACE_DEFINED__
#define __IInternetProtocolInfo_INTERFACE_DEFINED__

/* interface IInternetProtocolInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolInfo *LPIINTERNETPROTOCOLINFO;

typedef 
enum _tagPARSEACTION
    {	PARSE_CANONICALIZE	= 1,
	PARSE_FRIENDLY	= ( PARSE_CANONICALIZE + 1 ) ,
	PARSE_SECURITY_URL	= ( PARSE_FRIENDLY + 1 ) ,
	PARSE_ROOTDOCUMENT	= ( PARSE_SECURITY_URL + 1 ) ,
	PARSE_DOCUMENT	= ( PARSE_ROOTDOCUMENT + 1 ) ,
	PARSE_ANCHOR	= ( PARSE_DOCUMENT + 1 ) ,
	PARSE_ENCODE	= ( PARSE_ANCHOR + 1 ) ,
	PARSE_DECODE	= ( PARSE_ENCODE + 1 ) ,
	PARSE_PATH_FROM_URL	= ( PARSE_DECODE + 1 ) ,
	PARSE_URL_FROM_PATH	= ( PARSE_PATH_FROM_URL + 1 ) ,
	PARSE_MIME	= ( PARSE_URL_FROM_PATH + 1 ) ,
	PARSE_SERVER	= ( PARSE_MIME + 1 ) ,
	PARSE_SCHEMA	= ( PARSE_SERVER + 1 ) ,
	PARSE_SITE	= ( PARSE_SCHEMA + 1 ) ,
	PARSE_DOMAIN	= ( PARSE_SITE + 1 ) ,
	PARSE_LOCATION	= ( PARSE_DOMAIN + 1 ) ,
	PARSE_SECURITY_DOMAIN	= ( PARSE_LOCATION + 1 ) ,
	PARSE_ESCAPE	= ( PARSE_SECURITY_DOMAIN + 1 ) ,
	PARSE_UNESCAPE	= ( PARSE_ESCAPE + 1 ) 
    } 	PARSEACTION;

typedef 
enum _tagPSUACTION
    {	PSU_DEFAULT	= 1,
	PSU_SECURITY_URL_ONLY	= ( PSU_DEFAULT + 1 ) 
    } 	PSUACTION;

typedef 
enum _tagQUERYOPTION
    {	QUERY_EXPIRATION_DATE	= 1,
	QUERY_TIME_OF_LAST_CHANGE	= ( QUERY_EXPIRATION_DATE + 1 ) ,
	QUERY_CONTENT_ENCODING	= ( QUERY_TIME_OF_LAST_CHANGE + 1 ) ,
	QUERY_CONTENT_TYPE	= ( QUERY_CONTENT_ENCODING + 1 ) ,
	QUERY_REFRESH	= ( QUERY_CONTENT_TYPE + 1 ) ,
	QUERY_RECOMBINE	= ( QUERY_REFRESH + 1 ) ,
	QUERY_CAN_NAVIGATE	= ( QUERY_RECOMBINE + 1 ) ,
	QUERY_USES_NETWORK	= ( QUERY_CAN_NAVIGATE + 1 ) ,
	QUERY_IS_CACHED	= ( QUERY_USES_NETWORK + 1 ) ,
	QUERY_IS_INSTALLEDENTRY	= ( QUERY_IS_CACHED + 1 ) ,
	QUERY_IS_CACHED_OR_MAPPED	= ( QUERY_IS_INSTALLEDENTRY + 1 ) ,
	QUERY_USES_CACHE	= ( QUERY_IS_CACHED_OR_MAPPED + 1 ) ,
	QUERY_IS_SECURE	= ( QUERY_USES_CACHE + 1 ) ,
	QUERY_IS_SAFE	= ( QUERY_IS_SECURE + 1 ) ,
	QUERY_USES_HISTORYFOLDER	= ( QUERY_IS_SAFE + 1 ) 
    } 	QUERYOPTION;


EXTERN_C const IID IID_IInternetProtocolInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ec-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseUrl( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CombineUrl( 
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareUrl( 
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *CombineUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *CompareUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetProtocolInfoVtbl;

    interface IInternetProtocolInfo
    {
        CONST_VTBL struct IInternetProtocolInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolInfo_ParseUrl(This,pwzUrl,ParseAction,dwParseFlags,pwzResult,cchResult,pcchResult,dwReserved)	\
    ( (This)->lpVtbl -> ParseUrl(This,pwzUrl,ParseAction,dwParseFlags,pwzResult,cchResult,pcchResult,dwReserved) ) 

#define IInternetProtocolInfo_CombineUrl(This,pwzBaseUrl,pwzRelativeUrl,dwCombineFlags,pwzResult,cchResult,pcchResult,dwReserved)	\
    ( (This)->lpVtbl -> CombineUrl(This,pwzBaseUrl,pwzRelativeUrl,dwCombineFlags,pwzResult,cchResult,pcchResult,dwReserved) ) 

#define IInternetProtocolInfo_CompareUrl(This,pwzUrl1,pwzUrl2,dwCompareFlags)	\
    ( (This)->lpVtbl -> CompareUrl(This,pwzUrl1,pwzUrl2,dwCompareFlags) ) 

#define IInternetProtocolInfo_QueryInfo(This,pwzUrl,OueryOption,dwQueryFlags,pBuffer,cbBuffer,pcbBuf,dwReserved)	\
    ( (This)->lpVtbl -> QueryInfo(This,pwzUrl,OueryOption,dwQueryFlags,pBuffer,cbBuffer,pcbBuf,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0032 */
/* [local] */ 

#endif
#define IOInet               IInternet            
#define IOInetBindInfo       IInternetBindInfo    
#define IOInetProtocolRoot   IInternetProtocolRoot
#define IOInetProtocol       IInternetProtocol    
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define IOInetProtocolEx     IInternetProtocolEx  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define IOInetProtocolSink   IInternetProtocolSink
#define IOInetProtocolInfo   IInternetProtocolInfo
#define IOInetSession        IInternetSession     
#define IOInetPriority       IInternetPriority    
#define IOInetThreadSwitch   IInternetThreadSwitch
#define IOInetProtocolSinkStackable   IInternetProtocolSinkStackable
#define LPOINET              LPIINTERNET             
#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO 
#define LPOINETBINDINFO      LPIINTERNETBINDINFO     
#define LPOINETPROTOCOLROOT  LPIINTERNETPROTOCOLROOT 
#define LPOINETPROTOCOL      LPIINTERNETPROTOCOL     
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define LPOINETPROTOCOLEX    LPIINTERNETPROTOCOLEX   
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define LPOINETPROTOCOLSINK  LPIINTERNETPROTOCOLSINK 
#define LPOINETSESSION       LPIINTERNETSESSION      
#define LPOINETTHREADSWITCH  LPIINTERNETTHREADSWITCH 
#define LPOINETPRIORITY      LPIINTERNETPRIORITY     
#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO 
#define LPOINETPROTOCOLSINKSTACKABLE  LPIINTERNETPROTOCOLSINKSTACKABLE 
#define IID_IOInet               IID_IInternet            
#define IID_IOInetBindInfo       IID_IInternetBindInfo    
#define IID_IOInetProtocolRoot   IID_IInternetProtocolRoot
#define IID_IOInetProtocol       IID_IInternetProtocol    
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define IID_IOInetProtocolEx     IID_IInternetProtocolEx  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define IID_IOInetProtocolSink   IID_IInternetProtocolSink
#define IID_IOInetProtocolInfo   IID_IInternetProtocolInfo
#define IID_IOInetSession        IID_IInternetSession     
#define IID_IOInetPriority       IID_IInternetPriority    
#define IID_IOInetThreadSwitch   IID_IInternetThreadSwitch
#define IID_IOInetProtocolSinkStackable   IID_IInternetProtocolSinkStackable
STDAPI CoInternetParseUrl(                              
                            LPCWSTR      pwzUrl,        
                            PARSEACTION  ParseAction,   
                            DWORD        dwFlags,       
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR       pszResult,     
                            DWORD        cchResult,     
                      __out DWORD       *pcchResult,    
                            DWORD        dwReserved     
    );                                                  
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetParseIUri(                             
                       __in IUri        *pIUri,         
                            PARSEACTION  ParseAction,   
                            DWORD        dwFlags,       
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR       pwzResult,     
                            DWORD        cchResult,     
                      __out DWORD       *pcchResult,    
                            DWORD_PTR    dwReserved     
    );                                                  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCombineUrl(                                             
                                               LPCWSTR   pwzBaseUrl,     
                                               LPCWSTR   pwzRelativeUrl, 
                                               DWORD     dwCombineFlags, 
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR    pszResult,      
                                               DWORD     cchResult,      
    __out_opt                                  DWORD     *pcchResult,    
    __reserved                                 DWORD     dwReserved      
    );                                                                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCombineUrlEx(              
    __in_opt    IUri       *pBaseUri,       
    __in_opt    LPCWSTR     pwzRelativeUrl, 
                DWORD       dwCombineFlags, 
    __deref_out IUri      **ppCombinedUri,  
    __in_opt    DWORD_PTR   dwReserved      
    );                                      
STDAPI CoInternetCombineIUri (              
    __in        IUri       *pBaseUri,       
    __in        IUri       *pRelativeUri,   
                DWORD       dwCombineFlags, 
    __deref_out IUri      **ppCombinedUri,  
    __in_opt    DWORD_PTR   dwReserved      
    );                                      
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCompareUrl(             
    LPCWSTR pwzUrl1,                     
    LPCWSTR pwzUrl2,                     
    DWORD dwFlags                        
    );                                   
STDAPI CoInternetGetProtocolFlags(       
    LPCWSTR     pwzUrl,                  
    DWORD      *pdwFlags,                
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetQueryInfo(              
    LPCWSTR     pwzUrl,                  
    QUERYOPTION QueryOptions,            
    DWORD       dwQueryFlags,            
    LPVOID      pvBuffer,                
    DWORD       cbBuffer,                
    DWORD      *pcbBuffer,               
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetGetSession(             
    DWORD       dwSessionMode,           
    __deref_out IInternetSession **ppIInternetSession,
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetGetSecurityUrl(         
    LPCWSTR pwszUrl,                     
    __deref_out LPWSTR *ppwszSecUrl,     
    __in PSUACTION   psuAction,          
    __reserved DWORD dwReserved          
    );                                   
STDAPI AsyncInstallDistributionUnit(     
    LPCWSTR szDistUnit,                  
    LPCWSTR szTYPE,                      
    LPCWSTR szExt,                       
    DWORD dwFileVersionMS,               
    DWORD dwFileVersionLS,               
    LPCWSTR szURL,                       
    IBindCtx *pbc,                       
    LPVOID   pvReserved,                 
    DWORD   flags                        
    );                                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetGetSecurityUrlEx(       
    __in IUri         *pUri,             
    __deref_out IUri **ppSecUri,         
    PSUACTION          psuAction,        
    __reserved  DWORD_PTR dwReserved 

    
    );                                   
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _INTERNETFEATURELIST_DEFINED
#define _INTERNETFEATURELIST_DEFINED
typedef 
enum _tagINTERNETFEATURELIST
    {	FEATURE_OBJECT_CACHING	= 0,
	FEATURE_ZONE_ELEVATION	= ( FEATURE_OBJECT_CACHING + 1 ) ,
	FEATURE_MIME_HANDLING	= ( FEATURE_ZONE_ELEVATION + 1 ) ,
	FEATURE_MIME_SNIFFING	= ( FEATURE_MIME_HANDLING + 1 ) ,
	FEATURE_WINDOW_RESTRICTIONS	= ( FEATURE_MIME_SNIFFING + 1 ) ,
	FEATURE_WEBOC_POPUPMANAGEMENT	= ( FEATURE_WINDOW_RESTRICTIONS + 1 ) ,
	FEATURE_BEHAVIORS	= ( FEATURE_WEBOC_POPUPMANAGEMENT + 1 ) ,
	FEATURE_DISABLE_MK_PROTOCOL	= ( FEATURE_BEHAVIORS + 1 ) ,
	FEATURE_LOCALMACHINE_LOCKDOWN	= ( FEATURE_DISABLE_MK_PROTOCOL + 1 ) ,
	FEATURE_SECURITYBAND	= ( FEATURE_LOCALMACHINE_LOCKDOWN + 1 ) ,
	FEATURE_RESTRICT_ACTIVEXINSTALL	= ( FEATURE_SECURITYBAND + 1 ) ,
	FEATURE_VALIDATE_NAVIGATE_URL	= ( FEATURE_RESTRICT_ACTIVEXINSTALL + 1 ) ,
	FEATURE_RESTRICT_FILEDOWNLOAD	= ( FEATURE_VALIDATE_NAVIGATE_URL + 1 ) ,
	FEATURE_ADDON_MANAGEMENT	= ( FEATURE_RESTRICT_FILEDOWNLOAD + 1 ) ,
	FEATURE_PROTOCOL_LOCKDOWN	= ( FEATURE_ADDON_MANAGEMENT + 1 ) ,
	FEATURE_HTTP_USERNAME_PASSWORD_DISABLE	= ( FEATURE_PROTOCOL_LOCKDOWN + 1 ) ,
	FEATURE_SAFE_BINDTOOBJECT	= ( FEATURE_HTTP_USERNAME_PASSWORD_DISABLE + 1 ) ,
	FEATURE_UNC_SAVEDFILECHECK	= ( FEATURE_SAFE_BINDTOOBJECT + 1 ) ,
	FEATURE_GET_URL_DOM_FILEPATH_UNENCODED	= ( FEATURE_UNC_SAVEDFILECHECK + 1 ) ,
	FEATURE_TABBED_BROWSING	= ( FEATURE_GET_URL_DOM_FILEPATH_UNENCODED + 1 ) ,
	FEATURE_SSLUX	= ( FEATURE_TABBED_BROWSING + 1 ) ,
	FEATURE_DISABLE_NAVIGATION_SOUNDS	= ( FEATURE_SSLUX + 1 ) ,
	FEATURE_DISABLE_LEGACY_COMPRESSION	= ( FEATURE_DISABLE_NAVIGATION_SOUNDS + 1 ) ,
	FEATURE_FORCE_ADDR_AND_STATUS	= ( FEATURE_DISABLE_LEGACY_COMPRESSION + 1 ) ,
	FEATURE_XMLHTTP	= ( FEATURE_FORCE_ADDR_AND_STATUS + 1 ) ,
	FEATURE_DISABLE_TELNET_PROTOCOL	= ( FEATURE_XMLHTTP + 1 ) ,
	FEATURE_FEEDS	= ( FEATURE_DISABLE_TELNET_PROTOCOL + 1 ) ,
	FEATURE_BLOCK_INPUT_PROMPTS	= ( FEATURE_FEEDS + 1 ) ,
	FEATURE_ENTRY_COUNT	= ( FEATURE_BLOCK_INPUT_PROMPTS + 1 ) 
    } 	INTERNETFEATURELIST;


// CoInternetSetFeatureEnabled can be used to set/reset features. 
// The following flags control where the feature is set

#define SET_FEATURE_ON_THREAD                       0x00000001
#define SET_FEATURE_ON_PROCESS                      0x00000002
#define SET_FEATURE_IN_REGISTRY                     0x00000004
#define SET_FEATURE_ON_THREAD_LOCALMACHINE          0x00000008
#define SET_FEATURE_ON_THREAD_INTRANET              0x00000010
#define SET_FEATURE_ON_THREAD_TRUSTED               0x00000020
#define SET_FEATURE_ON_THREAD_INTERNET              0x00000040
#define SET_FEATURE_ON_THREAD_RESTRICTED            0x00000080

// CoInternetIsFeatureEnabled can be used to get features. 
// The following flags control where the feature is obtained from
// default is from process

#define GET_FEATURE_FROM_THREAD                      0x00000001
#define GET_FEATURE_FROM_PROCESS                     0x00000002
#define GET_FEATURE_FROM_REGISTRY                    0x00000004
#define GET_FEATURE_FROM_THREAD_LOCALMACHINE         0x00000008
#define GET_FEATURE_FROM_THREAD_INTRANET             0x00000010
#define GET_FEATURE_FROM_THREAD_TRUSTED              0x00000020
#define GET_FEATURE_FROM_THREAD_INTERNET             0x00000040
#define GET_FEATURE_FROM_THREAD_RESTRICTED           0x00000080
#endif
STDAPI CoInternetSetFeatureEnabled(      
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags,                       
    BOOL fEnable                         
    );                                   
STDAPI CoInternetIsFeatureEnabled(       
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags                        
    );                                   
STDAPI CoInternetIsFeatureEnabledForUrl( 
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags,                       
    LPCWSTR szURL,                       
    IInternetSecurityManager *pSecMgr    
    );                                   
STDAPI CoInternetIsFeatureEnabledForIUri( 
    INTERNETFEATURELIST FeatureEntry,     
    DWORD dwFlags,                        
    IUri * pIUri,                         
    IInternetSecurityManagerEx2 *pSecMgr  
    );                                    
STDAPI CoInternetIsFeatureZoneElevationEnabled( 
    LPCWSTR szFromURL,                          
    LPCWSTR szToURL,                            
    IInternetSecurityManager *pSecMgr,          
    DWORD dwFlags                               
    );                                          
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
 
STDAPI CopyStgMedium(const STGMEDIUM * pcstgmedSrc,  
                           STGMEDIUM * pstgmedDest); 
STDAPI CopyBindInfo( const BINDINFO * pcbiSrc,   
                           BINDINFO * pbiDest ); 
STDAPI_(void) ReleaseBindInfo( BINDINFO * pbindinfo );  
 
#define INET_E_USE_DEFAULT_PROTOCOLHANDLER _HRESULT_TYPEDEF_(0x800C0011L)      
#define INET_E_USE_DEFAULT_SETTING         _HRESULT_TYPEDEF_(0x800C0012L)      
#define INET_E_DEFAULT_ACTION              INET_E_USE_DEFAULT_PROTOCOLHANDLER  
#define INET_E_QUERYOPTION_UNKNOWN         _HRESULT_TYPEDEF_(0x800C0013L)      
#define INET_E_REDIRECTING                 _HRESULT_TYPEDEF_(0x800C0014L)      
#define OInetParseUrl               CoInternetParseUrl               
#define OInetCombineUrl             CoInternetCombineUrl             
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define OInetCombineUrlEx           CoInternetCombineUrlEx           
#define OInetCombineIUri            CoInternetCombineIUri            
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define OInetCompareUrl             CoInternetCompareUrl             
#define OInetQueryInfo              CoInternetQueryInfo              
#define OInetGetSession             CoInternetGetSession             
#endif // !_URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_ 
//
// Static Protocol flags
//
#define PROTOCOLFLAG_NO_PICS_CHECK     0x00000001

// Creates the security manager object. The first argument is the Service provider
// to allow for delegation
STDAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

STDAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved);


// Security manager CLSID's
EXTERN_C const IID CLSID_InternetSecurityManager;  
EXTERN_C const IID CLSID_InternetZoneManager;  
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
EXTERN_C const IID CLSID_PersistentZoneIdentifier;  
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
// This service is used for delegation support on the Security Manager interface
#define SID_SInternetSecurityManager         IID_IInternetSecurityManager

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define SID_SInternetSecurityManagerEx         IID_IInternetSecurityManagerEx
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)

#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SID_SInternetSecurityManagerEx2         IID_IInternetSecurityManagerEx2
#endif //(_WIN32_IE >= _WIN32_IE_IE70)

#define SID_SInternetHostSecurityManager     IID_IInternetHostSecurityManager

#ifndef _LPINTERNETSECURITYMGRSITE_DEFINED
#define _LPINTERNETSECURITYMGRSITE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_s_ifspec;

#ifndef __IInternetSecurityMgrSite_INTERFACE_DEFINED__
#define __IInternetSecurityMgrSite_INTERFACE_DEFINED__

/* interface IInternetSecurityMgrSite */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetSecurityMgrSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ed-baf9-11ce-8c82-00aa004ba90b")
    IInternetSecurityMgrSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityMgrSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityMgrSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityMgrSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityMgrSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IInternetSecurityMgrSite * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IInternetSecurityMgrSite * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IInternetSecurityMgrSiteVtbl;

    interface IInternetSecurityMgrSite
    {
        CONST_VTBL struct IInternetSecurityMgrSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityMgrSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityMgrSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityMgrSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityMgrSite_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IInternetSecurityMgrSite_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityMgrSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0033 */
/* [local] */ 

#endif
#ifndef _LPINTERNETSECURITYMANANGER_DEFINED
#define _LPINTERNETSECURITYMANANGER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_s_ifspec;

#ifndef __IInternetSecurityManager_INTERFACE_DEFINED__
#define __IInternetSecurityManager_INTERFACE_DEFINED__

/* interface IInternetSecurityManager */
/* [object][unique][helpstring][uuid] */ 

#define MUTZ_NOSAVEDFILECHECK        0x00000001 // don't check file: for saved file comment
#define MUTZ_ISFILE                  0x00000002 // Assume URL if File, url does not need file://
#define MUTZ_ACCEPT_WILDCARD_SCHEME  0x00000080 // Accept a wildcard scheme
#define MUTZ_ENFORCERESTRICTED       0x00000100 // enforce restricted zone independent of URL
#define MUTZ_RESERVED                0x00000200 // This is same as PUAF_NOSAVEDFILECHECK. However we already have MUTZ_NOSAVEDFILECHECK for this.
#define MUTZ_REQUIRESAVEDFILECHECK   0x00000400 // always check the file for MOTW (overriding FEATURE_UNC_SAVEDFILECHECK)
#define MUTZ_DONT_UNESCAPE           0x00000800 // Do not unescape the url
#define MUTZ_DONT_USE_CACHE          0x00001000 // Do not check the cache
#define MUTZ_FORCE_INTRANET_FLAGS    0x00002000 // Force the intranet flags to be active
#define MUTZ_IGNORE_ZONE_MAPPINGS    0x00004000 // Don't look up the Zone Mappings
// MapUrlToZone returns the zone index given a URL
#define MAX_SIZE_SECURITY_ID 512 // bytes
typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0001
    {	PUAF_DEFAULT	= 0,
	PUAF_NOUI	= 0x1,
	PUAF_ISFILE	= 0x2,
	PUAF_WARN_IF_DENIED	= 0x4,
	PUAF_FORCEUI_FOREGROUND	= 0x8,
	PUAF_CHECK_TIFS	= 0x10,
	PUAF_DONTCHECKBOXINDIALOG	= 0x20,
	PUAF_TRUSTED	= 0x40,
	PUAF_ACCEPT_WILDCARD_SCHEME	= 0x80,
	PUAF_ENFORCERESTRICTED	= 0x100,
	PUAF_NOSAVEDFILECHECK	= 0x200,
	PUAF_REQUIRESAVEDFILECHECK	= 0x400,
	PUAF_DONT_USE_CACHE	= 0x1000,
	PUAF_RESERVED1	= 0x2000,
	PUAF_RESERVED2	= 0x4000,
	PUAF_LMZ_UNLOCKED	= 0x10000,
	PUAF_LMZ_LOCKED	= 0x20000,
	PUAF_DEFAULTZONEPOL	= 0x40000,
	PUAF_NPL_USE_LOCKED_IF_RESTRICTED	= 0x80000,
	PUAF_NOUIIFLOCKED	= 0x100000,
	PUAF_DRAGPROTOCOLCHECK	= 0x200000
    } 	PUAF;

typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0002
    {	PUAFOUT_DEFAULT	= 0,
	PUAFOUT_ISLOCKZONEPOLICY	= 0x1
    } 	PUAFOUT;

// This is the wrapper function that most clients will use.
// It figures out the current Policy for the passed in Action,
// and puts up UI if the current Policy indicates that the user
// should be queried. It returns back the Policy which the caller
// will use to determine if the action should be allowed
// This is the wrapper function to conveniently read a custom policy.
typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0003
    {	SZM_CREATE	= 0,
	SZM_DELETE	= 0x1
    } 	SZM_FLAGS;

// SetZoneMapping
//    lpszPattern: string denoting a URL pattern
//        Examples of valid patterns:   
//            *://*.msn.com             
//            http://*.sony.co.jp       
//            *://et.msn.com            
//            ftp://157.54.23.41/       
//            https://localsvr          
//            file:\localsvr\share     
//            *://157.54.100-200.*      
//        Examples of invalid patterns: 
//            http://*.lcs.mit.edu      
//            ftp://*                   
//    dwFlags: SZM_FLAGS values         

EXTERN_C const IID IID_IInternetSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ee-baf9-11ce-8c82-00aa004ba90b")
    IInternetSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSecuritySite( 
            /* [unique][in] */ __RPC__in_opt IInternetSecurityMgrSite *pSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecuritySite( 
            /* [out] */ __RPC__deref_out_opt IInternetSecurityMgrSite **ppSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapUrlToZone( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurityId( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneMapping( 
            /* [in] */ DWORD dwZone,
            /* [in] */ __RPC__in LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneMappings( 
            /* [in] */ DWORD dwZone,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            IInternetSecurityManager * This,
            /* [unique][in] */ __RPC__in_opt IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            IInternetSecurityManager * This,
            /* [out] */ __RPC__deref_out_opt IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            IInternetSecurityManager * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetSecurityManager * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetSecurityManager * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetSecurityManager * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            IInternetSecurityManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ __RPC__in LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            IInternetSecurityManager * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IInternetSecurityManagerVtbl;

    interface IInternetSecurityManager
    {
        CONST_VTBL struct IInternetSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManager_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManager_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManager_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManager_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManager_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManager_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManager_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManager_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0034 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETSECURITYMANANGEREX_DEFINED
#define _LPINTERNETSECURITYMANANGEREX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_s_ifspec;

#ifndef __IInternetSecurityManagerEx_INTERFACE_DEFINED__
#define __IInternetSecurityManagerEx_INTERFACE_DEFINED__

/* interface IInternetSecurityManagerEx */
/* [object][unique][helpstring][uuid] */ 

// This is the wrapper function that most clients will use.
// It figures out the current Policy for the passed in Action,
// and puts up UI if the current Policy indicates that the user
// should be queried. It returns back the Policy which the caller
// will use to determine if the action should be allowed

EXTERN_C const IID IID_IInternetSecurityManagerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F164EDF1-CC7C-4f0d-9A94-34222625C393")
    IInternetSecurityManagerEx : public IInternetSecurityManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlActionEx( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityManagerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityManagerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            IInternetSecurityManagerEx * This,
            /* [unique][in] */ __RPC__in_opt IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            IInternetSecurityManagerEx * This,
            /* [out] */ __RPC__deref_out_opt IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ __RPC__in LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags);
        
        END_INTERFACE
    } IInternetSecurityManagerExVtbl;

    interface IInternetSecurityManagerEx
    {
        CONST_VTBL struct IInternetSecurityManagerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManagerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManagerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManagerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManagerEx_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManagerEx_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManagerEx_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManagerEx_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManagerEx_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManagerEx_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManagerEx_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 


#define IInternetSecurityManagerEx_ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManagerEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0035 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETSECURITYMANANGEREx2_DEFINED
#define _LPINTERNETSECURITYMANANGEREx2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_s_ifspec;

#ifndef __IInternetSecurityManagerEx2_INTERFACE_DEFINED__
#define __IInternetSecurityManagerEx2_INTERFACE_DEFINED__

/* interface IInternetSecurityManagerEx2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInternetSecurityManagerEx2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1E50292-A795-4117-8E09-2B560A72AC60")
    IInternetSecurityManagerEx2 : public IInternetSecurityManagerEx
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapUrlToZoneEx2( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwszMappedUrl,
            /* [out] */ __RPC__out DWORD *pdwOutFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlActionEx2( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ __RPC__in_opt BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurityIdEx2( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicyEx2( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerEx2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityManagerEx2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityManagerEx2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            IInternetSecurityManagerEx2 * This,
            /* [unique][in] */ __RPC__in_opt IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            IInternetSecurityManagerEx2 * This,
            /* [out] */ __RPC__deref_out_opt IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ __RPC__in LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZoneEx2 )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwszMappedUrl,
            /* [out] */ __RPC__out DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx2 )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ __RPC__in_opt BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityIdEx2 )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicyEx2 )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IInternetSecurityManagerEx2Vtbl;

    interface IInternetSecurityManagerEx2
    {
        CONST_VTBL struct IInternetSecurityManagerEx2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManagerEx2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManagerEx2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManagerEx2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManagerEx2_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManagerEx2_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManagerEx2_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManagerEx2_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx2_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManagerEx2_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManagerEx2_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManagerEx2_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 


#define IInternetSecurityManagerEx2_ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 


#define IInternetSecurityManagerEx2_MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags)	\
    ( (This)->lpVtbl -> MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags) ) 

#define IInternetSecurityManagerEx2_ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 

#define IInternetSecurityManagerEx2_GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx2_QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManagerEx2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0036 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_s_ifspec;

#ifndef __IZoneIdentifier_INTERFACE_DEFINED__
#define __IZoneIdentifier_INTERFACE_DEFINED__

/* interface IZoneIdentifier */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IZoneIdentifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cd45f185-1b21-48e2-967b-ead743a8914e")
    IZoneIdentifier : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ DWORD *pdwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetId( 
            /* [in] */ DWORD dwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IZoneIdentifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IZoneIdentifier * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IZoneIdentifier * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IZoneIdentifier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            IZoneIdentifier * This,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *SetId )( 
            IZoneIdentifier * This,
            /* [in] */ DWORD dwZone);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IZoneIdentifier * This);
        
        END_INTERFACE
    } IZoneIdentifierVtbl;

    interface IZoneIdentifier
    {
        CONST_VTBL struct IZoneIdentifierVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IZoneIdentifier_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IZoneIdentifier_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IZoneIdentifier_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IZoneIdentifier_GetId(This,pdwZone)	\
    ( (This)->lpVtbl -> GetId(This,pdwZone) ) 

#define IZoneIdentifier_SetId(This,dwZone)	\
    ( (This)->lpVtbl -> SetId(This,dwZone) ) 

#define IZoneIdentifier_Remove(This)	\
    ( (This)->lpVtbl -> Remove(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IZoneIdentifier_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0037 */
/* [local] */ 

#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETHOSTSECURITYMANANGER_DEFINED
#define _LPINTERNETHOSTSECURITYMANANGER_DEFINED
//This is the interface MSHTML exposes to its clients
//The clients need not pass in a URL to these functions
//since MSHTML maintains the notion of the current URL


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_s_ifspec;

#ifndef __IInternetHostSecurityManager_INTERFACE_DEFINED__
#define __IInternetHostSecurityManager_INTERFACE_DEFINED__

/* interface IInternetHostSecurityManager */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetHostSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3af280b6-cb3f-11d0-891e-00c04fb6bfc4")
    IInternetHostSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSecurityId( 
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction( 
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy( 
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetHostSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetHostSecurityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetHostSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetHostSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetHostSecurityManager * This,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetHostSecurityManager * This,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetHostSecurityManager * This,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetHostSecurityManagerVtbl;

    interface IInternetHostSecurityManager
    {
        CONST_VTBL struct IInternetHostSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetHostSecurityManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetHostSecurityManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetHostSecurityManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetHostSecurityManager_GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetHostSecurityManager_ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetHostSecurityManager_QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetHostSecurityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0038 */
/* [local] */ 

#endif

// The zone manager maintains policies for a set of standard actions. 
// These actions are identified by integral values (called action indexes)
// specified below.

// Minimum legal value for an action    
#define URLACTION_MIN                                          0x00001000

#define URLACTION_DOWNLOAD_MIN                                 0x00001000
#define URLACTION_DOWNLOAD_SIGNED_ACTIVEX                      0x00001001
#define URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX                    0x00001004
#define URLACTION_DOWNLOAD_CURR_MAX                            0x00001004
#define URLACTION_DOWNLOAD_MAX                                 0x000011FF

#define URLACTION_ACTIVEX_MIN                                  0x00001200
#define URLACTION_ACTIVEX_RUN                                  0x00001200
#define URLPOLICY_ACTIVEX_CHECK_LIST                           0x00010000
#define URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY               0x00001201 // aggregate next four
#define URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY                 0x00001202 //
#define URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY               0x00001203 //
#define URLACTION_SCRIPT_OVERRIDE_SAFETY                       0x00001401 //
#define URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY               0x00001204 //
#define URLACTION_ACTIVEX_TREATASUNTRUSTED                     0x00001205
#define URLACTION_ACTIVEX_NO_WEBOC_SCRIPT                      0x00001206
#define URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION          0x00001207
#define URLACTION_ACTIVEX_OVERRIDE_OPTIN                       0x00001208
#define URLACTION_ACTIVEX_SCRIPTLET_RUN                        0x00001209
#define URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION           0x0000120A //
#define URLACTION_ACTIVEX_CURR_MAX                             0x0000120A
#define URLACTION_ACTIVEX_MAX                                  0x000013ff

#define URLACTION_SCRIPT_MIN                                   0x00001400
#define URLACTION_SCRIPT_RUN                                   0x00001400
#define URLACTION_SCRIPT_JAVA_USE                              0x00001402
#define URLACTION_SCRIPT_SAFE_ACTIVEX                          0x00001405
#define URLACTION_CROSS_DOMAIN_DATA                            0x00001406
#define URLACTION_SCRIPT_PASTE                                 0x00001407
#define URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE                0x00001408
#define URLACTION_SCRIPT_CURR_MAX                              0x00001408
#define URLACTION_SCRIPT_MAX                                   0x000015ff

#define URLACTION_HTML_MIN                                     0x00001600
#define URLACTION_HTML_SUBMIT_FORMS                            0x00001601 // aggregate next two
#define URLACTION_HTML_SUBMIT_FORMS_FROM                       0x00001602 //
#define URLACTION_HTML_SUBMIT_FORMS_TO                         0x00001603 //
#define URLACTION_HTML_FONT_DOWNLOAD                           0x00001604
#define URLACTION_HTML_JAVA_RUN                                0x00001605 // derive from Java custom policy
#define URLACTION_HTML_USERDATA_SAVE                           0x00001606
#define URLACTION_HTML_SUBFRAME_NAVIGATE                       0x00001607
#define URLACTION_HTML_META_REFRESH                            0x00001608
#define URLACTION_HTML_MIXED_CONTENT                           0x00001609
#define URLACTION_HTML_INCLUDE_FILE_PATH                       0x0000160A
#define URLACTION_HTML_MAX                                     0x000017ff

#define URLACTION_SHELL_MIN                                    0x00001800
#define URLACTION_SHELL_INSTALL_DTITEMS                        0x00001800
#define URLACTION_SHELL_MOVE_OR_COPY                           0x00001802
#define URLACTION_SHELL_FILE_DOWNLOAD                          0x00001803
#define URLACTION_SHELL_VERB                                   0x00001804
#define URLACTION_SHELL_WEBVIEW_VERB                           0x00001805
#define URLACTION_SHELL_SHELLEXECUTE                           0x00001806
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_SHELL_EXECUTE_HIGHRISK                       0x00001806
#define URLACTION_SHELL_EXECUTE_MODRISK                        0x00001807
#define URLACTION_SHELL_EXECUTE_LOWRISK                        0x00001808
#define URLACTION_SHELL_POPUPMGR                               0x00001809
#define URLACTION_SHELL_RTF_OBJECTS_LOAD                       0x0000180A
#define URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY             0x0000180B
#define URLACTION_SHELL_EXTENSIONSECURITY                      0x0000180C
#define URLACTION_SHELL_SECURE_DRAGSOURCE                      0x0000180D
#define URLACTION_SHELL_CURR_MAX                               0x0000180D
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_SHELL_MAX                                    0x000019ff

#define URLACTION_NETWORK_MIN                                  0x00001A00

#define URLACTION_CREDENTIALS_USE                              0x00001A00
#define URLPOLICY_CREDENTIALS_SILENT_LOGON_OK        0x00000000
#define URLPOLICY_CREDENTIALS_MUST_PROMPT_USER       0x00010000
#define URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT     0x00020000
#define URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY         0x00030000

#define URLACTION_AUTHENTICATE_CLIENT                          0x00001A01
#define URLPOLICY_AUTHENTICATE_CLEARTEXT_OK          0x00000000
#define URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE    0x00010000
#define URLPOLICY_AUTHENTICATE_MUTUAL_ONLY           0x00030000


#define URLACTION_COOKIES                                      0x00001A02
#define URLACTION_COOKIES_SESSION                              0x00001A03

#define URLACTION_CLIENT_CERT_PROMPT                           0x00001A04

#define URLACTION_COOKIES_THIRD_PARTY                          0x00001A05
#define URLACTION_COOKIES_SESSION_THIRD_PARTY                  0x00001A06

#define URLACTION_COOKIES_ENABLED                              0x00001A10

#define URLACTION_NETWORK_CURR_MAX                             0x00001A10
#define URLACTION_NETWORK_MAX                                  0x00001Bff


#define URLACTION_JAVA_MIN                                     0x00001C00
#define URLACTION_JAVA_PERMISSIONS                             0x00001C00
#define URLPOLICY_JAVA_PROHIBIT                      0x00000000
#define URLPOLICY_JAVA_HIGH                          0x00010000
#define URLPOLICY_JAVA_MEDIUM                        0x00020000
#define URLPOLICY_JAVA_LOW                           0x00030000
#define URLPOLICY_JAVA_CUSTOM                        0x00800000
#define URLACTION_JAVA_CURR_MAX                                0x00001C00
#define URLACTION_JAVA_MAX                                     0x00001Cff


// The following Infodelivery actions should have no default policies
// in the registry.  They assume that no default policy means fall
// back to the global restriction.  If an admin sets a policy per
// zone, then it overrides the global restriction.

#define URLACTION_INFODELIVERY_MIN                           0x00001D00
#define URLACTION_INFODELIVERY_NO_ADDING_CHANNELS            0x00001D00
#define URLACTION_INFODELIVERY_NO_EDITING_CHANNELS           0x00001D01
#define URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS          0x00001D02
#define URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS       0x00001D03
#define URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS      0x00001D04
#define URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS     0x00001D05
#define URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING            0x00001D06
#define URLACTION_INFODELIVERY_CURR_MAX                      0x00001D06
#define URLACTION_INFODELIVERY_MAX                           0x00001Dff
#define URLACTION_CHANNEL_SOFTDIST_MIN                       0x00001E00
#define URLACTION_CHANNEL_SOFTDIST_PERMISSIONS               0x00001E05
#define URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT          0x00010000
#define URLPOLICY_CHANNEL_SOFTDIST_PRECACHE          0x00020000
#define URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL       0x00030000
#define URLACTION_CHANNEL_SOFTDIST_MAX                       0x00001Eff
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_BEHAVIOR_MIN                               0x00002000
#define URLACTION_BEHAVIOR_RUN                               0x00002000
#define URLPOLICY_BEHAVIOR_CHECK_LIST                        0x00010000

// The following actions correspond to the Feature options above.
// However, they are NOT in the same order.
#define URLACTION_FEATURE_MIN                                0x00002100
#define URLACTION_FEATURE_MIME_SNIFFING                      0x00002100
#define URLACTION_FEATURE_ZONE_ELEVATION                     0x00002101
#define URLACTION_FEATURE_WINDOW_RESTRICTIONS                0x00002102
#define URLACTION_FEATURE_SCRIPT_STATUS_BAR                  0x00002103
#define URLACTION_FEATURE_FORCE_ADDR_AND_STATUS              0x00002104
#define URLACTION_FEATURE_BLOCK_INPUT_PROMPTS                0x00002105

#define URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN                  0x00002200
#define URLACTION_AUTOMATIC_DOWNLOAD_UI                      0x00002200
#define URLACTION_AUTOMATIC_ACTIVEX_UI                       0x00002201

#define URLACTION_ALLOW_RESTRICTEDPROTOCOLS                0x00002300

// Whether to do the Anti-Phishing check.
#define URLACTION_ALLOW_APEVALUATION                       0x00002301

#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
// The following ExpressAPP and XPS actions are trumped by registry in
// case of Internet Explorer upgrade from IE 6.0 which honors registry.
#define URLACTION_WINDOWS_BROWSER_APPLICATIONS             0x00002400
#define URLACTION_XPS_DOCUMENTS                            0x00002401
#define URLACTION_LOOSE_XAML                               0x00002402
#define URLACTION_LOWRIGHTS                                0x00002500
// The following action belong to WinFX Bootstrapper
#define URLACTION_WINFX_SETUP                              0x00002600

#endif //(_WIN32_IE >= _WIN32_IE_IE70)
// For each action specified above the system maintains
// a set of policies for the action. 
// The only policies supported currently are permissions (i.e. is something allowed)
// and logging status. 
// IMPORTANT: If you are defining your own policies don't overload the meaning of the
// loword of the policy. You can use the hiword to store any policy bits which are only
// meaningful to your action.
// For an example of how to do this look at the URLPOLICY_JAVA above

// Permissions 
#define URLPOLICY_ALLOW                0x00
#define URLPOLICY_QUERY                0x01
#define URLPOLICY_DISALLOW             0x03

// Notifications are not done when user already queried.
#define URLPOLICY_NOTIFY_ON_ALLOW      0x10
#define URLPOLICY_NOTIFY_ON_DISALLOW   0x20

// Logging is done regardless of whether user was queried.
#define URLPOLICY_LOG_ON_ALLOW         0x40
#define URLPOLICY_LOG_ON_DISALLOW      0x80

#define URLPOLICY_MASK_PERMISSIONS     0x0f
#define GetUrlPolicyPermissions(dw)        (dw & URLPOLICY_MASK_PERMISSIONS)
#define SetUrlPolicyPermissions(dw,dw2)    ((dw) = ((dw) & ~(URLPOLICY_MASK_PERMISSIONS)) | (dw2))


#define URLPOLICY_DONTCHECKDLGBOX     0x100
// The ordinal #'s that define the predefined zones internet explorer knows about. 
// When we support user-defined zones their zone numbers should be between 
// URLZONE_USER_MIN and URLZONE_USER_MAX
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
// Custom policy to query whether the local machine zone
// has been unlocked for current document.
EXTERN_C const GUID GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED; 
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETZONEMANAGER_DEFINED
#define _LPINTERNETZONEMANAGER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_s_ifspec;

#ifndef __IInternetZoneManager_INTERFACE_DEFINED__
#define __IInternetZoneManager_INTERFACE_DEFINED__

/* interface IInternetZoneManager */
/* [unique][helpstring][uuid][object][local] */ 

typedef /* [unique] */ IInternetZoneManager *LPURLZONEMANAGER;

typedef 
enum tagURLZONE
    {	URLZONE_INVALID	= -1,
	URLZONE_PREDEFINED_MIN	= 0,
	URLZONE_LOCAL_MACHINE	= 0,
	URLZONE_INTRANET	= ( URLZONE_LOCAL_MACHINE + 1 ) ,
	URLZONE_TRUSTED	= ( URLZONE_INTRANET + 1 ) ,
	URLZONE_INTERNET	= ( URLZONE_TRUSTED + 1 ) ,
	URLZONE_UNTRUSTED	= ( URLZONE_INTERNET + 1 ) ,
	URLZONE_PREDEFINED_MAX	= 999,
	URLZONE_USER_MIN	= 1000,
	URLZONE_USER_MAX	= 10000
    } 	URLZONE;

// Enhanced Security Configuration zone mapping flag for IInternetSecurityManager::SetZoneMapping
#define URLZONE_ESC_FLAG     0x100
typedef 
enum tagURLTEMPLATE
    {	URLTEMPLATE_CUSTOM	= 0,
	URLTEMPLATE_PREDEFINED_MIN	= 0x10000,
	URLTEMPLATE_LOW	= 0x10000,
	URLTEMPLATE_MEDLOW	= 0x10500,
	URLTEMPLATE_MEDIUM	= 0x11000,
	URLTEMPLATE_MEDHIGH	= 0x11500,
	URLTEMPLATE_HIGH	= 0x12000,
	URLTEMPLATE_PREDEFINED_MAX	= 0x20000
    } 	URLTEMPLATE;


enum __MIDL_IInternetZoneManager_0001
    {	MAX_ZONE_PATH	= 260,
	MAX_ZONE_DESCRIPTION	= 200
    } ;
typedef /* [public] */ 
enum __MIDL_IInternetZoneManager_0002
    {	ZAFLAGS_CUSTOM_EDIT	= 0x1,
	ZAFLAGS_ADD_SITES	= 0x2,
	ZAFLAGS_REQUIRE_VERIFICATION	= 0x4,
	ZAFLAGS_INCLUDE_PROXY_OVERRIDE	= 0x8,
	ZAFLAGS_INCLUDE_INTRANET_SITES	= 0x10,
	ZAFLAGS_NO_UI	= 0x20,
	ZAFLAGS_SUPPORTS_VERIFICATION	= 0x40,
	ZAFLAGS_UNC_AS_INTRANET	= 0x80,
	ZAFLAGS_DETECT_INTRANET	= 0x100,
	ZAFLAGS_USE_LOCKED_ZONES	= 0x10000,
	ZAFLAGS_VERIFY_TEMPLATE_SETTINGS	= 0x20000,
	ZAFLAGS_NO_CACHE	= 0x40000
    } 	ZAFLAGS;

typedef struct _ZONEATTRIBUTES
    {
    ULONG cbSize;
    WCHAR szDisplayName[ 260 ];
    WCHAR szDescription[ 200 ];
    WCHAR szIconPath[ 260 ];
    DWORD dwTemplateMinLevel;
    DWORD dwTemplateRecommended;
    DWORD dwTemplateCurrentLevel;
    DWORD dwFlags;
    } 	ZONEATTRIBUTES;

typedef struct _ZONEATTRIBUTES *LPZONEATTRIBUTES;

// Gets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes are fixed as:
// Sets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes as above.
// Returns S_OK or ??? if failed to write the zone attributes.
/* Registry Flags

    When reading, default behavior is:
        If HKLM allows override and HKCU value exists
            Then use HKCU value
            Else use HKLM value
    When writing, default behavior is same as HKCU
        If HKLM allows override
           Then Write to HKCU
           Else Fail
*/
typedef 
enum _URLZONEREG
    {	URLZONEREG_DEFAULT	= 0,
	URLZONEREG_HKLM	= ( URLZONEREG_DEFAULT + 1 ) ,
	URLZONEREG_HKCU	= ( URLZONEREG_HKLM + 1 ) 
    } 	URLZONEREG;

// Gets a named custom policy associated with a zone;
// e.g. the Java VM settings can be defined with a unique key such as 'Java'.
// Custom policy support is intended to allow extensibility from the predefined
// set of policies that IE4 has built in.
// 
// pwszKey is the string name designating the custom policy.  Components are
//   responsible for having unique names.
// ppPolicy is the callee allocated buffer for the policy byte blob; caller is
//   responsible for freeing this buffer eventually.
// pcbPolicy is the size of the byte blob returned.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if key is found and buffer allocated; ??? if key is not found (no buffer alloced).
// Sets a named custom policy associated with a zone;
// e.g. the Java VM settings can be defined with a unique key such as 'Java'.
// Custom policy support is intended to allow extensibility from the predefined
// set of policies that IE4 has built in.  
// 
// pwszKey is the string name designating the custom policy.  Components are
//   responsible for having unique names.
// ppPolicy is the caller allocated buffer for the policy byte blob.
// pcbPolicy is the size of the byte blob to be set.
// dwRegFlags determines if HTCU or HKLM is set.
// Returns S_OK or ??? if failed to write the zone custom policy.
// Gets action policy associated with a zone, the builtin, fixed-length policies info.

// dwAction is the action code for the action as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.

EXTERN_C const IID IID_IInternetZoneManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ef-baf9-11ce-8c82-00aa004ba90b")
    IInternetZoneManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneAttributes( 
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneAttributes( 
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneCustomPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneCustomPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PromptAction( 
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogAction( 
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateZoneEnumerator( 
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneAt( 
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyZoneEnumerator( 
            /* [in] */ DWORD dwEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyTemplatePoliciesToZone( 
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManager * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetZoneManagerVtbl;

    interface IInternetZoneManager
    {
        CONST_VTBL struct IInternetZoneManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManager_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManager_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManager_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManager_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManager_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManager_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManager_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManager_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0039 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETZONEMANAGEREX_DEFINED
#define _LPINTERNETZONEMANAGEREX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_s_ifspec;

#ifndef __IInternetZoneManagerEx_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx_INTERFACE_DEFINED__

/* interface IInternetZoneManagerEx */
/* [unique][helpstring][uuid][object][local] */ 

// Gets action policy associated with a zone, the builtin, fixed-length policies info.

// dwAction is the action code for the action as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// dwFlags determine which registry policies are accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.

EXTERN_C const IID IID_IInternetZoneManagerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4C23339-8E06-431e-9BF4-7E711C085648")
    IInternetZoneManagerEx : public IInternetZoneManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicyEx( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicyEx( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManagerEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManagerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManagerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManagerEx * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicyEx )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicyEx )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IInternetZoneManagerExVtbl;

    interface IInternetZoneManagerEx
    {
        CONST_VTBL struct IInternetZoneManagerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManagerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManagerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManagerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManagerEx_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManagerEx_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManagerEx_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManagerEx_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManagerEx_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManagerEx_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 


#define IInternetZoneManagerEx_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#define IInternetZoneManagerEx_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManagerEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0040 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETZONEMANAGEREX2_DEFINED
#define _LPINTERNETZONEMANAGEREX2_DEFINED
#define SECURITY_IE_STATE_GREEN 0x00000000
#define SECURITY_IE_STATE_RED   0x00000001


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_s_ifspec;

#ifndef __IInternetZoneManagerEx2_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx2_INTERFACE_DEFINED__

/* interface IInternetZoneManagerEx2 */
/* [unique][helpstring][uuid][object][local] */ 

// Gets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes are fixed as:
// Can also verify template settings by matching current settings with security template

EXTERN_C const IID IID_IInternetZoneManagerEx2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EDC17559-DD5D-4846-8EEF-8BECBA5A4ABF")
    IInternetZoneManagerEx2 : public IInternetZoneManagerEx
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneAttributesEx( 
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneSecurityState( 
            /* [in] */ DWORD dwZoneIndex,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIESecurityState( 
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered,
            /* [in] */ BOOL fNoCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FixUnsecureSettings( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerEx2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManagerEx2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManagerEx2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManagerEx2 * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicyEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicyEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributesEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneSecurityState )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZoneIndex,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered);
        
        HRESULT ( STDMETHODCALLTYPE *GetIESecurityState )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered,
            /* [in] */ BOOL fNoCache);
        
        HRESULT ( STDMETHODCALLTYPE *FixUnsecureSettings )( 
            IInternetZoneManagerEx2 * This);
        
        END_INTERFACE
    } IInternetZoneManagerEx2Vtbl;

    interface IInternetZoneManagerEx2
    {
        CONST_VTBL struct IInternetZoneManagerEx2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManagerEx2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManagerEx2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManagerEx2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManagerEx2_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx2_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx2_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManagerEx2_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManagerEx2_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManagerEx2_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManagerEx2_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManagerEx2_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 


#define IInternetZoneManagerEx2_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#define IInternetZoneManagerEx2_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 


#define IInternetZoneManagerEx2_GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags) ) 

#define IInternetZoneManagerEx2_GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered)	\
    ( (This)->lpVtbl -> GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered) ) 

#define IInternetZoneManagerEx2_GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache)	\
    ( (This)->lpVtbl -> GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache) ) 

#define IInternetZoneManagerEx2_FixUnsecureSettings(This)	\
    ( (This)->lpVtbl -> FixUnsecureSettings(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManagerEx2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0041 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
EXTERN_C const IID CLSID_SoftDistExt;  
#ifndef _LPSOFTDISTEXT_DEFINED
#define _LPSOFTDISTEXT_DEFINED

#define SOFTDIST_FLAG_USAGE_EMAIL        0x00000001
#define SOFTDIST_FLAG_USAGE_PRECACHE     0x00000002
#define SOFTDIST_FLAG_USAGE_AUTOINSTALL  0x00000004
#define SOFTDIST_FLAG_DELETE_SUBSCRIPTION 0x00000008


#define SOFTDIST_ADSTATE_NONE                0x00000000
#define SOFTDIST_ADSTATE_AVAILABLE       0x00000001
#define SOFTDIST_ADSTATE_DOWNLOADED      0x00000002
#define SOFTDIST_ADSTATE_INSTALLED           0x00000003

typedef struct _tagCODEBASEHOLD
    {
    ULONG cbSize;
    LPWSTR szDistUnit;
    LPWSTR szCodeBase;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwStyle;
    } 	CODEBASEHOLD;

typedef struct _tagCODEBASEHOLD *LPCODEBASEHOLD;

typedef struct _tagSOFTDISTINFO
    {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwAdState;
    LPWSTR szTitle;
    LPWSTR szAbstract;
    LPWSTR szHREF;
    DWORD dwInstalledVersionMS;
    DWORD dwInstalledVersionLS;
    DWORD dwUpdateVersionMS;
    DWORD dwUpdateVersionLS;
    DWORD dwAdvertisedVersionMS;
    DWORD dwAdvertisedVersionLS;
    DWORD dwReserved;
    } 	SOFTDISTINFO;

typedef struct _tagSOFTDISTINFO *LPSOFTDISTINFO;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_s_ifspec;

#ifndef __ISoftDistExt_INTERFACE_DEFINED__
#define __ISoftDistExt_INTERFACE_DEFINED__

/* interface ISoftDistExt */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_ISoftDistExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B15B8DC1-C7E1-11d0-8680-00AA00BDCB71")
    ISoftDistExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessSoftDist( 
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstCodeBase( 
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextCodeBase( 
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncInstallDistributionUnit( 
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftDistExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftDistExt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftDistExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftDistExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSoftDist )( 
            ISoftDistExt * This,
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstCodeBase )( 
            ISoftDistExt * This,
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextCodeBase )( 
            ISoftDistExt * This,
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *AsyncInstallDistributionUnit )( 
            ISoftDistExt * This,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh);
        
        END_INTERFACE
    } ISoftDistExtVtbl;

    interface ISoftDistExt
    {
        CONST_VTBL struct ISoftDistExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftDistExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftDistExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftDistExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftDistExt_ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi)	\
    ( (This)->lpVtbl -> ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi) ) 

#define ISoftDistExt_GetFirstCodeBase(This,szCodeBase,dwMaxSize)	\
    ( (This)->lpVtbl -> GetFirstCodeBase(This,szCodeBase,dwMaxSize) ) 

#define ISoftDistExt_GetNextCodeBase(This,szCodeBase,dwMaxSize)	\
    ( (This)->lpVtbl -> GetNextCodeBase(This,szCodeBase,dwMaxSize) ) 

#define ISoftDistExt_AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh)	\
    ( (This)->lpVtbl -> AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftDistExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0042 */
/* [local] */ 

STDAPI GetSoftwareUpdateInfo( LPCWSTR szDistUnit, LPSOFTDISTINFO psdi );
STDAPI SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS );
#endif
#ifndef _LPCATALOGFILEINFO_DEFINED
#define _LPCATALOGFILEINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_s_ifspec;

#ifndef __ICatalogFileInfo_INTERFACE_DEFINED__
#define __ICatalogFileInfo_INTERFACE_DEFINED__

/* interface ICatalogFileInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICatalogFileInfo *LPCATALOGFILEINFO;


EXTERN_C const IID IID_ICatalogFileInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("711C7600-6B48-11d1-B403-00AA00B92AF1")
    ICatalogFileInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCatalogFile( 
            /* [out] */ LPSTR *ppszCatalogFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJavaTrust( 
            /* [out] */ void **ppJavaTrust) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogFileInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogFileInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogFileInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogFileInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogFile )( 
            ICatalogFileInfo * This,
            /* [out] */ LPSTR *ppszCatalogFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetJavaTrust )( 
            ICatalogFileInfo * This,
            /* [out] */ void **ppJavaTrust);
        
        END_INTERFACE
    } ICatalogFileInfoVtbl;

    interface ICatalogFileInfo
    {
        CONST_VTBL struct ICatalogFileInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogFileInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatalogFileInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatalogFileInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatalogFileInfo_GetCatalogFile(This,ppszCatalogFile)	\
    ( (This)->lpVtbl -> GetCatalogFile(This,ppszCatalogFile) ) 

#define ICatalogFileInfo_GetJavaTrust(This,ppJavaTrust)	\
    ( (This)->lpVtbl -> GetJavaTrust(This,ppJavaTrust) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatalogFileInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0043 */
/* [local] */ 

#endif
#ifndef _LPDATAFILTER_DEFINED
#define _LPDATAFILTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_s_ifspec;

#ifndef __IDataFilter_INTERFACE_DEFINED__
#define __IDataFilter_INTERFACE_DEFINED__

/* interface IDataFilter */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IDataFilter *LPDATAFILTER;


EXTERN_C const IID IID_IDataFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69d14c80-c18e-11d0-a9ce-006097942311")
    IDataFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoEncode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDecode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEncodingLevel( 
            /* [in] */ DWORD dwEncLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoEncode )( 
            IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *DoDecode )( 
            IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetEncodingLevel )( 
            IDataFilter * This,
            /* [in] */ DWORD dwEncLevel);
        
        END_INTERFACE
    } IDataFilterVtbl;

    interface IDataFilter
    {
        CONST_VTBL struct IDataFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataFilter_DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)	\
    ( (This)->lpVtbl -> DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) ) 

#define IDataFilter_DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)	\
    ( (This)->lpVtbl -> DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) ) 

#define IDataFilter_SetEncodingLevel(This,dwEncLevel)	\
    ( (This)->lpVtbl -> SetEncodingLevel(This,dwEncLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0044 */
/* [local] */ 

#endif
#ifndef _LPENCODINGFILTERFACTORY_DEFINED
#define _LPENCODINGFILTERFACTORY_DEFINED
typedef struct _tagPROTOCOLFILTERDATA
    {
    DWORD cbSize;
    IInternetProtocolSink *pProtocolSink;
    IInternetProtocol *pProtocol;
    IUnknown *pUnk;
    DWORD dwFilterFlags;
    } 	PROTOCOLFILTERDATA;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_s_ifspec;

#ifndef __IEncodingFilterFactory_INTERFACE_DEFINED__
#define __IEncodingFilterFactory_INTERFACE_DEFINED__

/* interface IEncodingFilterFactory */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IEncodingFilterFactory *LPENCODINGFILTERFACTORY;

typedef struct _tagDATAINFO
    {
    ULONG ulTotalSize;
    ULONG ulavrPacketSize;
    ULONG ulConnectSpeed;
    ULONG ulProcessorSpeed;
    } 	DATAINFO;


EXTERN_C const IID IID_IEncodingFilterFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70bdde00-c18e-11d0-a9ce-006097942311")
    IEncodingFilterFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindBestFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEncodingFilterFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEncodingFilterFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEncodingFilterFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEncodingFilterFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindBestFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF);
        
        END_INTERFACE
    } IEncodingFilterFactoryVtbl;

    interface IEncodingFilterFactory
    {
        CONST_VTBL struct IEncodingFilterFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEncodingFilterFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEncodingFilterFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEncodingFilterFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEncodingFilterFactory_FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF)	\
    ( (This)->lpVtbl -> FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF) ) 

#define IEncodingFilterFactory_GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF)	\
    ( (This)->lpVtbl -> GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEncodingFilterFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0045 */
/* [local] */ 

#endif
#ifndef _HITLOGGING_DEFINED
#define _HITLOGGING_DEFINED
// Logging-specific apis
BOOL WINAPI IsLoggingEnabledA(IN LPCSTR  pszUrl);                    
BOOL WINAPI IsLoggingEnabledW(IN LPCWSTR  pwszUrl);                  
#ifdef UNICODE                                                       
#define IsLoggingEnabled         IsLoggingEnabledW                   
#else                                                                
#define IsLoggingEnabled         IsLoggingEnabledA                   
#endif // !UNICODE                                                   
typedef struct _tagHIT_LOGGING_INFO
    {
    DWORD dwStructSize;
    LPSTR lpszLoggedUrlName;
    SYSTEMTIME StartTime;
    SYSTEMTIME EndTime;
    LPSTR lpszExtendedInfo;
    } 	HIT_LOGGING_INFO;

typedef struct _tagHIT_LOGGING_INFO *LPHIT_LOGGING_INFO;

BOOL WINAPI WriteHitLogging(IN LPHIT_LOGGING_INFO lpLogginginfo);    
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
    {
    CLSID clsid;
    IUnknown *pUnk;
    DWORD dwFlags;
    } ;
EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY; 
#endif
#ifndef _LPIWRAPPEDPROTOCOL_DEFINED
#define _LPIWRAPPEDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_s_ifspec;

#ifndef __IWrappedProtocol_INTERFACE_DEFINED__
#define __IWrappedProtocol_INTERFACE_DEFINED__

/* interface IWrappedProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWrappedProtocol *LPIWRAPPEDPROTOCOL;


EXTERN_C const IID IID_IWrappedProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53c84785-8425-4dc5-971b-e58d9c19f9b6")
    IWrappedProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWrapperCode( 
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrappedProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWrappedProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWrappedProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWrappedProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWrapperCode )( 
            IWrappedProtocol * This,
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IWrappedProtocolVtbl;

    interface IWrappedProtocol
    {
        CONST_VTBL struct IWrappedProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrappedProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWrappedProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWrappedProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWrappedProtocol_GetWrapperCode(This,pnCode,dwReserved)	\
    ( (This)->lpVtbl -> GetWrapperCode(This,pnCode,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWrappedProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0046 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Proxy( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [out] */ LPOLESTR *pszResult,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Stub( 
    IBinding * This,
    /* [out] */ __RPC__out CLSID *pclsidProtocol,
    /* [out] */ __RPC__out DWORD *pdwResult,
    /* [out] */ __RPC__deref_out_opt LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ BINDINFO *pbindinfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Stub( 
    IBindStatusCallback * This,
    /* [out] */ __RPC__out DWORD *grfBINDF,
    /* [unique][out][in] */ __RPC__inout_opt RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC *pformatetc,
    /* [in] */ STGMEDIUM *pstgmed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Stub( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ __RPC__in RemFORMATETC *pformatetc,
    /* [in] */ __RPC__in RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Proxy( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Stub( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Proxy( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Stub( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf,
    /* [out][in] */ __RPC__inout DWORD *pdwFlags,
    /* [out][in] */ __RPC__inout DWORD *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Stub( 
    IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Stub( 
    IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usb.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        USB.H

Abstract:

   structures and APIs for USB drivers.

Environment:

    Kernel & user mode

Revision History:

    09-29-95 : created
    02-10-04 : Updated to include header versioning

--*/

#ifndef   __USB_H__
#define   __USB_H__

/*
    This file is equivalent to USBDI.H with extensions supported by
    usbport.sys for eUSB.

    This file replaces usbdi.h and is compatible with older versions
    of the USB stack.
*/

#ifdef OSR21_COMPAT
#pragma message("WARNING: OSR21_COMPAT SWITCH NOT SUPPORTED")
#endif

#ifndef _NTDDK_
#ifndef _WDMDDK_
typedef PVOID PIRP;
typedef PVOID PMDL;
#endif
#endif

#define USBDI_VERSION    0x00000600

#include "usb200.h"
#ifdef _WDMDDK_
#endif

/*
    Microsoft Extended Port Attribute Flags
*/

#define USB_PORTATTR_NO_CONNECTOR       0x00000001
#define USB_PORTATTR_SHARED_USB2        0x00000002
#define USB_PORTATTR_MINI_CONNECTOR     0x00000004
#define USB_PORTATTR_OEM_CONNECTOR      0x00000008

/* dynamic attributes */
#define USB_PORTATTR_OWNED_BY_CC        0x01000000
#define USB_PORTATTR_NO_OVERCURRENT_UI  0x02000000


/* define USB controller flavors:
    These are all known HW implementations that require special
    hacks.
*/

typedef enum _USB_CONTROLLER_FLAVOR {

    USB_HcGeneric   = 0,

    OHCI_Generic    = 100,
    OHCI_Hydra,
    OHCI_NEC,

    UHCI_Generic    = 200,
    UHCI_Piix4      = 201,
    UHCI_Piix3      = 202,
    UHCI_Ich2       = 203,  
    UHCI_Reserved204   = 204,  // was ich2_2
    UHCI_Ich1       = 205,
    UHCI_Ich3m      = 206,
    UHCI_Ich4       = 207,
    UHCI_Ich5       = 208,
    UHCI_Ich6       = 209,

    UHCI_Intel      = 249,        

    //these VIA revs require special handling in the uhci miniport
    UHCI_VIA          = 250,
    UHCI_VIA_x01      = 251,
    UHCI_VIA_x02      = 252,
    UHCI_VIA_x03      = 253,
    UHCI_VIA_x04      = 254,

    UHCI_VIA_x0E_FIFO = 264,

    EHCI_Generic    = 1000,
    EHCI_NEC        = 2000,
    EHCI_Lucent     = 3000

} USB_CONTROLLER_FLAVOR;


//
// USB defined structures and constants
// (see chapter 9 of USB specification)
//

#define USB_DEFAULT_DEVICE_ADDRESS     0
#define USB_DEFAULT_ENDPOINT_ADDRESS   0

//
// max packet size (bytes) for default endpoint
// until SET_ADDRESS command is received.
//

#define USB_DEFAULT_MAX_PACKET         64

//
// USBD interface structures and constants
//


#define URB_FROM_IRP(Irp) ((IoGetCurrentIrpStackLocation(Irp))->Parameters.Others.Argument1)

//
//  URB request codes
//

#define URB_FUNCTION_SELECT_CONFIGURATION            0x0000
#define URB_FUNCTION_SELECT_INTERFACE                0x0001
#define URB_FUNCTION_ABORT_PIPE                      0x0002
#define URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL       0x0003
#define URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL    0x0004
#define URB_FUNCTION_GET_FRAME_LENGTH                0x0005
#define URB_FUNCTION_SET_FRAME_LENGTH                0x0006
#define URB_FUNCTION_GET_CURRENT_FRAME_NUMBER        0x0007
#define URB_FUNCTION_CONTROL_TRANSFER                0x0008
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER      0x0009
#define URB_FUNCTION_ISOCH_TRANSFER                  0x000A
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE      0x000B
#define URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE        0x000C
#define URB_FUNCTION_SET_FEATURE_TO_DEVICE           0x000D
#define URB_FUNCTION_SET_FEATURE_TO_INTERFACE        0x000E
#define URB_FUNCTION_SET_FEATURE_TO_ENDPOINT         0x000F
#define URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE         0x0010
#define URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE      0x0011
#define URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT       0x0012
#define URB_FUNCTION_GET_STATUS_FROM_DEVICE          0x0013
#define URB_FUNCTION_GET_STATUS_FROM_INTERFACE       0x0014
#define URB_FUNCTION_GET_STATUS_FROM_ENDPOINT        0x0015
#define URB_FUNCTION_RESERVED_0X0016                 0x0016
#define URB_FUNCTION_VENDOR_DEVICE                   0x0017
#define URB_FUNCTION_VENDOR_INTERFACE                0x0018
#define URB_FUNCTION_VENDOR_ENDPOINT                 0x0019
#define URB_FUNCTION_CLASS_DEVICE                    0x001A
#define URB_FUNCTION_CLASS_INTERFACE                 0x001B
#define URB_FUNCTION_CLASS_ENDPOINT                  0x001C
#define URB_FUNCTION_RESERVE_0X001D                  0x001D
// previously URB_FUNCTION_RESET_PIPE
#define URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL 0x001E
#define URB_FUNCTION_CLASS_OTHER                     0x001F
#define URB_FUNCTION_VENDOR_OTHER                    0x0020
#define URB_FUNCTION_GET_STATUS_FROM_OTHER           0x0021
#define URB_FUNCTION_CLEAR_FEATURE_TO_OTHER          0x0022
#define URB_FUNCTION_SET_FEATURE_TO_OTHER            0x0023
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT    0x0024
#define URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT      0x0025
#define URB_FUNCTION_GET_CONFIGURATION               0x0026
#define URB_FUNCTION_GET_INTERFACE                   0x0027
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE   0x0028
#define URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE     0x0029 

// USB 2.0 calls start at 0x0030

#if (_WIN32_WINNT >= 0x0501)

#define URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR       0x002A
#define URB_FUNCTION_SYNC_RESET_PIPE                 0x0030
#define URB_FUNCTION_SYNC_CLEAR_STALL                0x0031

#endif

#if (_WIN32_WINNT >= 0x0600)

#define URB_FUNCTION_CONTROL_TRANSFER_EX             0x0032
#define URB_FUNCTION_SET_PIPE_IO_POLICY              0x0033
#define URB_FUNCTION_GET_PIPE_IO_POLICY              0x0034

#endif

// Reserve 0x002B-0x002F
#define URB_FUNCTION_RESERVE_0X002B                  0x002B
#define URB_FUNCTION_RESERVE_0X002C                  0x002C
#define URB_FUNCTION_RESERVE_0X002D                  0x002D
#define URB_FUNCTION_RESERVE_0X002E                  0x002E
#define URB_FUNCTION_RESERVE_0X002F                  0x002F


// for backward drivers
#define URB_FUNCTION_RESET_PIPE     \
    URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL

/* Control Pipe Function Groupings

   These functions correspond to the standard commands
   on the default pipe, direction is implied


URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE
URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT
URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE

URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE
URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT
URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE

URB_FUNCTION_SET_FEATURE_TO_DEVICE
URB_FUNCTION_SET_FEATURE_TO_INTERFACE
URB_FUNCTION_SET_FEATURE_TO_ENDPOINT
URB_FUNCTION_SET_FEATURE_TO_OTHER

URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE
URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE
URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT
URB_FUNCTION_CLEAR_FEATURE_TO_OTHER

URB_FUNCTION_GET_STATUS_FROM_DEVICE
URB_FUNCTION_GET_STATUS_FROM_INTERFACE
URB_FUNCTION_GET_STATUS_FROM_ENDPOINT
URB_FUNCTION_GET_STATUS_FROM_OTHER

URB_FUNCTION_VENDOR_DEVICE
URB_FUNCTION_VENDOR_INTERFACE
URB_FUNCTION_VENDOR_ENDPOINT
URB_FUNCTION_VENDOR_OTHER

URB_FUNCTION_CLASS_DEVICE
URB_FUNCTION_CLASS_INTERFACE
URB_FUNCTION_CLASS_ENDPOINT
URB_FUNCTION_CLASS_OTHER

*/

//
// Values for URB TransferFlags Field
//

/*
    Set if data moves device->host
*/
#define USBD_TRANSFER_DIRECTION               0x00000001
/*
    This bit if not set indicates that a short packet, and hence,
    a short transfer is an error condition
*/
#define USBD_SHORT_TRANSFER_OK                0x00000002
/*
    Subit the iso transfer on the next frame
*/
#define USBD_START_ISO_TRANSFER_ASAP          0x00000004
#define USBD_DEFAULT_PIPE_TRANSFER            0x00000008


#define USBD_TRANSFER_DIRECTION_FLAG(flags)  ((flags) & USBD_TRANSFER_DIRECTION)

#define USBD_TRANSFER_DIRECTION_OUT           0
#define USBD_TRANSFER_DIRECTION_IN            1

#define VALID_TRANSFER_FLAGS_MASK             (USBD_SHORT_TRANSFER_OK | \
                                               USBD_TRANSFER_DIRECTION | \
                                               USBD_START_ISO_TRANSFER_ASAP | \
                                               USBD_DEFAULT_PIPE_TRANSFER)

#define USBD_ISO_START_FRAME_RANGE            1024

typedef LONG USBD_STATUS;

//
// USBD status codes
//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+---------------------------+-------------------------------+
//  | S |               Status Code                                 |
//  +---+---------------------------+-------------------------------+
//
//  where
//
//      S - is the state code
//
//          00 - completed with success
//          01 - request is pending
//          11, 10 - completed with error
//
//
//      Code - is the status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
// Macro to check the status code only
//
//
//define USBD_STATUS(Status) ((ULONG)(Status) & 0x0FFFFFFFL)

// the high order bits (0xC) will always be set on an error

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
//
//#define USBD_STATUS_ERROR                    ((USBD_STATUS)0xC0000000L)


// The following are defined for backward compatibility with the usb 1.0 stack


//
// HC (Hardware) status codes range 0x00000001 - 0x000000FF
//

#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

#define USBD_STATUS_XACT_ERROR               ((USBD_STATUS)0xC0000011L)
#define USBD_STATUS_BABBLE_DETECTED          ((USBD_STATUS)0xC0000012L)
#define USBD_STATUS_DATA_BUFFER_ERROR        ((USBD_STATUS)0xC0000013L)

//
// returned by HCD if a transfer is submitted to an endpoint that is
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED          ((USBD_STATUS)0xC0000030L)

//
// Software status codes
//
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)

//
// returned if client driver attempts to close an endpoint/interface
// or configuration with outstanding transfers.
//
#define USBD_STATUS_ERROR_BUSY               ((USBD_STATUS)0x80000400L)
//
// returned by USBD if it cannot complete a URB request, typically this
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
//#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000500L)

#define USBD_STATUS_INVALID_PIPE_HANDLE      ((USBD_STATUS)0x80000600L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000700L)
//
// generic HC error
//
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000800L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
//
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000900L)
//
// returned if the requested start frame is not within
// USBD_ISO_START_FRAME_RANGE of the current USB frame,
// note that the stall bit is set
//
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000A00L)
//
// returned by HCD if all packets in an iso transfer complete with an error
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000B00L)
//
// returned by USBD if the frame length control for a given
// HC is already taken by anothe driver
//
#define USBD_STATUS_FRAME_CONTROL_OWNED      ((USBD_STATUS)0xC0000C00L)
//
// returned by USBD if the caller does not own frame length control and
// attempts to release or modify the HC frame length
//
#define USBD_STATUS_FRAME_CONTROL_NOT_OWNED  ((USBD_STATUS)0xC0000D00L)

//
// additonal software error codes added for usb 2.0
//

//
// returned for APIS not supported/implemented
//
#define USBD_STATUS_NOT_SUPPORTED            ((USBD_STATUS)0xC0000E00L)

#define USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR \
                                             ((USBD_STATUS)0xC0000F00L)

#define USBD_STATUS_INVALID_CONFIGURATION_DESCRIPTOR \
                                             ((USBD_STATUS)0xC0000F00L)

#define USBD_STATUS_INSUFFICIENT_RESOURCES   ((USBD_STATUS)0xC0001000L)

#define USBD_STATUS_SET_CONFIG_FAILED        ((USBD_STATUS)0xC0002000L)

#define USBD_STATUS_BUFFER_TOO_SMALL         ((USBD_STATUS)0xC0003000L)

#define USBD_STATUS_INTERFACE_NOT_FOUND      ((USBD_STATUS)0xC0004000L)

#define USBD_STATUS_INAVLID_PIPE_FLAGS       ((USBD_STATUS)0xC0005000L)

#define USBD_STATUS_TIMEOUT                  ((USBD_STATUS)0xC0006000L)

#define USBD_STATUS_DEVICE_GONE              ((USBD_STATUS)0xC0007000L)

#define USBD_STATUS_STATUS_NOT_MAPPED        ((USBD_STATUS)0xC0008000L)

// returned when urb is intercepted or handled by the hub driver
#define USBD_STATUS_HUB_INTERNAL_ERROR       ((USBD_STATUS)0xC0009000L)


//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC0010000L)

//
// extended isochronous error codes, these errors appear in the
// packet status field of an isochronous transfer
//


// for some reason the controller did not access the TD asocated with this
// packet
#define USBD_STATUS_ISO_NOT_ACCESSED_BY_HW   ((USBD_STATUS)0xC0020000L)
// controller reported an error in the TD
// since TD errors are controoler specific they are reorted
// generically with this error code
#define USBD_STATUS_ISO_TD_ERROR             ((USBD_STATUS)0xC0030000L)
// the packet was submitted in time by the client but
// failed to reach the miniport in time
#define USBD_STATUS_ISO_NA_LATE_USBPORT      ((USBD_STATUS)0xC0040000L)
// the packet was not sent because the client submitted it too late
// to transmit
#define USBD_STATUS_ISO_NOT_ACCESSED_LATE    ((USBD_STATUS)0xC0050000L)

// new parameter validation status codes
#define USBD_STATUS_BAD_DESCRIPTOR                      ((USBD_STATUS)0xC0100000L)
#define USBD_STATUS_BAD_DESCRIPTOR_BLEN                 ((USBD_STATUS)0xC0100001L)
#define USBD_STATUS_BAD_DESCRIPTOR_TYPE                 ((USBD_STATUS)0xC0100002L)
#define USBD_STATUS_BAD_INTERFACE_DESCRIPTOR            ((USBD_STATUS)0xC0100003L)
#define USBD_STATUS_BAD_ENDPOINT_DESCRIPTOR             ((USBD_STATUS)0xC0100004L)
#define USBD_STATUS_BAD_INTERFACE_ASSOC_DESCRIPTOR      ((USBD_STATUS)0xC0100005L)
#define USBD_STATUS_BAD_CONFIG_DESC_LENGTH              ((USBD_STATUS)0xC0100006L)
#define USBD_STATUS_BAD_NUMBER_OF_INTERFACES            ((USBD_STATUS)0xC0100007L)
#define USBD_STATUS_BAD_NUMBER_OF_ENDPOINTS             ((USBD_STATUS)0xC0100008L)
#define USBD_STATUS_BAD_ENDPOINT_ADDRESS                ((USBD_STATUS)0xC0100009L)



typedef PVOID USBD_PIPE_HANDLE;
typedef PVOID USBD_CONFIGURATION_HANDLE;
typedef PVOID USBD_INTERFACE_HANDLE;

//
// Value used to indicate the default max transfer size
//

/*
    MAX TRANSFER SIZE

    Specified during select_configuration or
    selec_interface.  This is the largest
    transfer a client driver will do to an
    endpoint.

    This value may be from 0x00000001 to
    0xFFFFFFFF (1 to 4GB)

*/
//

#if (_WIN32_WINNT >= 0x0501)

//
// For windows XP and later
//

#define USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE  0xFFFFFFFF

#else

//
// For Windows 2000
//

#define USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE  PAGE_SIZE

#endif

//
// structure returned from USBD_GetVersion function
//

typedef struct _USBD_VERSION_INFORMATION {
    ULONG USBDI_Version;          //BCD usb interface version number
    ULONG Supported_USB_Version;  //BCD USB spec version number
} USBD_VERSION_INFORMATION, *PUSBD_VERSION_INFORMATION;

typedef enum _USBD_PIPE_TYPE {
    UsbdPipeTypeControl,
    UsbdPipeTypeIsochronous,
    UsbdPipeTypeBulk,
    UsbdPipeTypeInterrupt
} USBD_PIPE_TYPE;

#define USBD_PIPE_DIRECTION_IN(pipeInformation) ((pipeInformation)->EndpointAddress & \
                                                  USB_ENDPOINT_DIRECTION_MASK)

typedef struct _USBD_DEVICE_INFORMATION {
    ULONG OffsetNext;
    PVOID UsbdDeviceHandle;
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;
} USBD_DEVICE_INFORMATION, *PUSBD_DEVICE_INFORMATION;

//
//      URB request structures
//

//
// USBD pipe information structure, this structure
// is returned for each pipe opened thru an
// SELECT_CONFIGURATION or SELECT_INTERFACE request.
//

typedef struct _USBD_PIPE_INFORMATION {
    //
    // OUTPUT
    // These fields are filled in by USBD
    //
    USHORT MaximumPacketSize;  // Maximum packet size for this pipe
    UCHAR EndpointAddress;     // 8 bit USB endpoint address (includes direction)
                               // taken from endpoint descriptor
    UCHAR Interval;            // Polling interval in ms if interrupt pipe

    USBD_PIPE_TYPE PipeType;   // PipeType identifies type of transfer valid for this pipe
    USBD_PIPE_HANDLE PipeHandle;

    //
    // INPUT
    // These fields are filled in by the client driver
    //
    ULONG MaximumTransferSize; // Maximum size for a single request
                               // in bytes.
    ULONG PipeFlags;
} USBD_PIPE_INFORMATION, *PUSBD_PIPE_INFORMATION;

//
// values for PipeFlags field in USBD_PIPE_INFORMATION field
//

// override the enpoint max_packet size
// with the value in pipe_information
// field
#define USBD_PF_CHANGE_MAX_PACKET             0x00000001
// optimize for short packets
// 'bulk optimization #1'
#define USBD_PF_SHORT_PACKET_OPT              0x00000002
// optimize transfers for use
// with 'real time threads
#define USBD_PF_ENABLE_RT_THREAD_ACCESS       0x00000004
// causes the driver to allocate map
// map more transfers in the queue.
#define USBD_PF_MAP_ADD_TRANSFERS             0x00000008

#define USBD_PF_VALID_MASK    (USBD_PF_CHANGE_MAX_PACKET | \
                               USBD_PF_SHORT_PACKET_OPT | \
                               USBD_PF_ENABLE_RT_THREAD_ACCESS | \
                               USBD_PF_MAP_ADD_TRANSFERS)


//
// USBD interface information structure, this structure
// is returned for each interface opened thru an
// SELECT_CONFIGURATION or SELECT_INTERFACE request.
//

typedef struct _USBD_INTERFACE_INFORMATION {
    USHORT Length;       // Length of this structure, including
                         // all pipe information structures that
                         // follow.
    //
    // INPUT
    //
    // Interface number and Alternate setting this
    // structure is associated with
    //
    UCHAR InterfaceNumber;
    UCHAR AlternateSetting;

    //
    // OUTPUT
    // These fields are filled in by USBD
    //
    UCHAR Class;
    UCHAR SubClass;
    UCHAR Protocol;
    UCHAR Reserved;

    USBD_INTERFACE_HANDLE InterfaceHandle;
    ULONG NumberOfPipes;

    //
    // INPUT/OUPUT
    // see PIPE_INFORMATION

    USBD_PIPE_INFORMATION Pipes[1];
} USBD_INTERFACE_INFORMATION, *PUSBD_INTERFACE_INFORMATION;

//
// work space provided for HCDs
//

struct _URB_HCD_AREA {
    PVOID Reserved8[8];
};

struct _URB_HEADER {
    //
    // Fields filled in by client driver
    //
    USHORT Length;
    USHORT Function;
    USBD_STATUS Status;
    //
    // Fields used only by USBD
    //
    PVOID UsbdDeviceHandle; // device handle assigned to this device
                            // by USBD
    ULONG UsbdFlags;        // flags field reserved for USBD use.
};

struct _URB_SELECT_INTERFACE {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // client must input AlternateSetting & Interface Number
    // class driver returns interface and handle
    // for new alternate setting
    USBD_INTERFACE_INFORMATION Interface;
};

struct _URB_SELECT_CONFIGURATION {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    // NULL indicates to set the device
    // to the 'unconfigured' state
    // ie set to configuration 0
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;
    USBD_INTERFACE_INFORMATION Interface;
};

//
// This structure used for ABORT_PIPE & RESET_PIPE
//

struct _URB_PIPE_REQUEST {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    USBD_PIPE_HANDLE PipeHandle;
    ULONG Reserved;
};

//
// This structure used for
// TAKE_FRAME_LENGTH_CONTROL &
//        RELEASE_FRAME_LENGTH_CONTROL
//

struct _URB_FRAME_LENGTH_CONTROL {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
};

struct _URB_GET_FRAME_LENGTH {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    ULONG FrameLength;
    ULONG FrameNumber;
};

struct _URB_SET_FRAME_LENGTH {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    LONG FrameLengthDelta;
};

struct _URB_GET_CURRENT_FRAME_NUMBER {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    ULONG FrameNumber;
};

//
// Structures for specific control transfers
// on the default pipe.
//

// GET_DESCRIPTOR
// SET_DESCRIPTOR

struct _URB_CONTROL_DESCRIPTOR_REQUEST {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    PVOID Reserved;
    ULONG Reserved0;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *reserved MBZ*
    struct _URB_HCD_AREA hca;           // fields for HCD use
    USHORT Reserved1;
    UCHAR Index;
    UCHAR DescriptorType;
    USHORT LanguageId;
    USHORT Reserved2;
};

// GET_STATUS

struct _URB_CONTROL_GET_STATUS_REQUEST {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    PVOID Reserved;
    ULONG Reserved0;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *reserved MBZ*
    struct _URB_HCD_AREA hca;           // fields for HCD use
    UCHAR Reserved1[4];
    USHORT Index;                       // zero, interface or endpoint
    USHORT Reserved2;
};

// SET_FEATURE
// CLEAR_FEATURE

struct _URB_CONTROL_FEATURE_REQUEST {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    PVOID Reserved;
    ULONG Reserved2;
    ULONG Reserved3;
    PVOID Reserved4;
    PMDL Reserved5;
    struct _URB *UrbLink;               // *reserved MBZ*
    struct _URB_HCD_AREA hca;           // fields for HCD use
    USHORT Reserved0;
    USHORT FeatureSelector;
    USHORT Index;                       // zero, interface or endpoint
    USHORT Reserved1;
};

// VENDOR & CLASS

struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    PVOID Reserved;
    ULONG TransferFlags;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *reserved MBZ*
    struct _URB_HCD_AREA hca;           // fields for HCD use
    UCHAR RequestTypeReservedBits;
    UCHAR Request;
    USHORT Value;
    USHORT Index;
    USHORT Reserved1;
};


struct _URB_CONTROL_GET_INTERFACE_REQUEST {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    PVOID Reserved;
    ULONG Reserved0;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *reserved MBZ*
    struct _URB_HCD_AREA hca;           // fields for HCD use
    UCHAR Reserved1[4];
    USHORT Interface;
    USHORT Reserved2;
};


struct _URB_CONTROL_GET_CONFIGURATION_REQUEST {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    PVOID Reserved;
    ULONG Reserved0;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *resrved MBZ*
    struct _URB_HCD_AREA hca;           // fields for HCD use
    UCHAR Reserved1[8];
};

#if (_WIN32_WINNT >= 0x0501)
   
// Microsoft OS Descriptor APIs
// supported in windows XP and later

#define OS_STRING_DESCRIPTOR_INDEX                  0xEE

#define MS_GENRE_DESCRIPTOR_INDEX                   0x0001
#define MS_POWER_DESCRIPTOR_INDEX                   0x0002

#define MS_OS_STRING_SIGNATURE                      L"MSFT100"

typedef struct _OS_STRING {
    UCHAR bLength;
    UCHAR bDescriptorType;
    WCHAR MicrosoftString[7];
    UCHAR bVendorCode;
    UCHAR bPad;
} OS_STRING, *POS_STRING;

struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST {
    struct _URB_HEADER Hdr;  // function code indicates get or set.
    PVOID Reserved;
    ULONG Reserved0;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *optional* link to next urb request
                                        // if this is a chain of commands
    struct _URB_HCD_AREA hca;           // fields for HCD use
    UCHAR   Recipient:5;                // Recipient {Device,Interface,Endpoint}
    UCHAR   Reserved1:3;
    UCHAR   Reserved2;
    UCHAR   InterfaceNumber;            // wValue - high byte
    UCHAR   MS_PageIndex;               // wValue - low byte
    USHORT  MS_FeatureDescriptorIndex;  // wIndex field
    USHORT  Reserved3;
};

#endif

//
// request format for a control transfer on
// the non-default pipe.
//

struct _URB_CONTROL_TRANSFER {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    USBD_PIPE_HANDLE PipeHandle;
    ULONG TransferFlags;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *reserved MBZ*
    struct _URB_HCD_AREA hca;           // fields for HCD use
    UCHAR SetupPacket[8];
};

#if (_WIN32_WINNT >= 0x0600)

//
// Suported for Windows Longhorn and later
//

struct _URB_CONTROL_TRANSFER_EX {
    struct _URB_HEADER Hdr;
    USBD_PIPE_HANDLE PipeHandle;
    ULONG TransferFlags;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    ULONG Timeout;                      // *optional* timeout in milliseconds
                                        // for this request, 0 = no timeout
                                        // if this is a chain of commands
#ifdef WIN64
    ULONG Pad;
#endif
    struct _URB_HCD_AREA hca;           // fields for HCD use
    UCHAR SetupPacket[8];
};


/*
SFIO parameters 
*/

typedef enum _USB_IO_PRIORITY  {

    UsbIoPriorty_Normal = 0,
    UsbIoPriority_High = 8,
    UsbIoPriority_VeryHigh = 16

} USB_IO_PRIORITY  ;

typedef struct _USB_IO_PARAMETERS {

    /* iomap and schedule priority for pipe */
    USB_IO_PRIORITY UsbIoPriority;    
   
    /* max-irp, number of irps that can complete per frame */
    ULONG UsbMaxPendingIrps;

    /* These fields are read-only */
    /* This is the same value returned in the pipe_info structure and is the largest request the 
       controller driver can handle */
    ULONG UsbMaxControllerTransfer;

} USB_IO_PARAMETERS, *PUSB_IO_PARAMETERS;


struct _URB_PIPE_IO_POLICY {
    
    struct _URB_HEADER Hdr;
    /* NULL indicates default pipe */
    USBD_PIPE_HANDLE PipeHandle; 
    USB_IO_PARAMETERS UsbIoParamters;
  
};


#endif

struct _URB_BULK_OR_INTERRUPT_TRANSFER {
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    USBD_PIPE_HANDLE PipeHandle;
    ULONG TransferFlags;                // note: the direction bit will be set by USBD
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *optional* link to next urb request
                                        // if this is a chain of commands
    struct _URB_HCD_AREA hca;           // fields for HCD use
};


//
// ISO Transfer request
//
// TransferBufferMDL must point to a single virtually
// contiguous buffer.
//
// StartFrame - the frame to send/receive the first packet of
// the request.
//
// NumberOfPackets - number of packets to send in this request
//
//
// IsoPacket Array
//
//      Input:  Offset - offset of the packet from the beginig
//                 of the client buffer.
//      Output: Length -  is set to the actual length of the packet
//                (For IN transfers).
//      Status: error that occurred during transmission or
//              reception of the packet.
//

typedef struct _USBD_ISO_PACKET_DESCRIPTOR {
    ULONG Offset;       // INPUT Offset of the packet from the begining of the
                        // buffer.

    ULONG Length;       // OUTPUT length of data received (for in).
                        // OUTPUT 0 for OUT.
    USBD_STATUS Status; // status code for this packet.
} USBD_ISO_PACKET_DESCRIPTOR, *PUSBD_ISO_PACKET_DESCRIPTOR;

struct _URB_ISOCH_TRANSFER {
    //
    // This block is the same as CommonTransfer
    //
    struct _URB_HEADER Hdr;                 // function code indicates get or set.
    USBD_PIPE_HANDLE PipeHandle;
    ULONG TransferFlags;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;             // *optional*
    struct _URB *UrbLink;               // *optional* link to next urb request
                                        // if this is a chain of commands
    struct _URB_HCD_AREA hca;           // fields for HCD use

    //
    // this block contains transfer fields
    // specific to isochronous transfers
    //

    // 32 bit frame number to begin this transfer on, must be within 1000
    // frames of the current USB frame or an error is returned.

    // START_ISO_TRANSFER_ASAP flag in transferFlags:
    // If this flag is set and no transfers have been submitted
    // for the pipe then the transfer will begin on the next frame
    // and StartFrame will be updated with the frame number the transfer
    // was started on.
    // If this flag is set and the pipe has active transfers then
    // the transfer will be queued to begin on the frame after the
    // last transfer queued is completed.
    //
    ULONG StartFrame;
    // number of packets that make up this request
    ULONG NumberOfPackets;
    // number of packets that completed with errors
    ULONG ErrorCount;
    USBD_ISO_PACKET_DESCRIPTOR IsoPacket[1];
};


typedef struct _URB {
    union {
        struct _URB_HEADER
            UrbHeader;
        struct _URB_SELECT_INTERFACE
            UrbSelectInterface;
        struct _URB_SELECT_CONFIGURATION
            UrbSelectConfiguration;
        struct _URB_PIPE_REQUEST
            UrbPipeRequest;
        struct _URB_FRAME_LENGTH_CONTROL
            UrbFrameLengthControl;
        struct _URB_GET_FRAME_LENGTH
            UrbGetFrameLength;
        struct _URB_SET_FRAME_LENGTH
            UrbSetFrameLength;
        struct _URB_GET_CURRENT_FRAME_NUMBER
            UrbGetCurrentFrameNumber;
        struct _URB_CONTROL_TRANSFER
            UrbControlTransfer;
            
    #if (_WIN32_WINNT >= 0x0600)
    
        struct _URB_CONTROL_TRANSFER_EX
            UrbControlTransferEx;

        struct _URB_PIPE_IO_POLICY
            UrbPipeIoPolicy;
    #endif
    
        struct _URB_BULK_OR_INTERRUPT_TRANSFER
            UrbBulkOrInterruptTransfer;
        struct _URB_ISOCH_TRANSFER
            UrbIsochronousTransfer;

        // for standard control transfers on the default pipe
        struct _URB_CONTROL_DESCRIPTOR_REQUEST
            UrbControlDescriptorRequest;
        struct _URB_CONTROL_GET_STATUS_REQUEST
            UrbControlGetStatusRequest;
        struct _URB_CONTROL_FEATURE_REQUEST
            UrbControlFeatureRequest;
        struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST
            UrbControlVendorClassRequest;
        struct _URB_CONTROL_GET_INTERFACE_REQUEST
            UrbControlGetInterfaceRequest;
        struct _URB_CONTROL_GET_CONFIGURATION_REQUEST
            UrbControlGetConfigurationRequest;
            
    #if (_WIN32_WINNT >= 0x0501)
    
        struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST
            UrbOSFeatureDescriptorRequest;
    #endif
    
    };
} URB, *PURB;


#endif /*  __USB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usbcamdi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        USBCAMDI.H

Abstract:

   interface definition for .

Environment:

    Kernel & user mode

Revision History:


--*/


#ifndef   __USBCAMDI_H__
#define   __USBCAMDI_H__

// the purpose of this structure is to establish a connection between pipes discovered and
// streams to be declared (video,still). the following structure will be be passed along with 
// USBD_PIPE_INFO structure in CamConfigEx to the cam driver. The Cam driver has to indicate 
// pipe stream asscociation by oring all the relevant streams associated with this particular 
// pipe. If there is more than one stream association, USBCAMD creates a virtual still pin,
// and assumes the first stream is video followed by still stream.
// The cam driver has to set the first field to USBCAMD_DONT_CARE_PIPE if a particular pipe should not be used by 
// usbcamd. For example, if you have an iso audio pipe, iso video pipe in a camera device that 
// supports stills and video .you should set the flag field in the first structure to 
// USBCAMD_DONT_CARE_PIPE, The second structure should be set as foolows:
// {USBCAMD_VIDEO_STILL_STREAM,USBCAMD_MULTIPLEX_PIPE)}. 
// the assumption here is that cam has one config descr, and all alt.interfcaes have the same 
// number and types of pipes.
// also, notice that the flags are mutually exclusive. 
//

typedef struct _pipe_config_descriptor {
    CHAR     StreamAssociation ;         // video stream, still stream, or both
    UCHAR    PipeConfigFlags;           // USBCAMD_PIPECONFIG_*
} USBCAMD_Pipe_Config_Descriptor, *PUSBCAMD_Pipe_Config_Descriptor;

#define USBCAMD_DATA_PIPE           0x0001  // video or still data pipe
#define USBCAMD_MULTIPLEX_PIPE      0x0002  // pipe used for both still & video  
#define USBCAMD_SYNC_PIPE           0x0004  // out-of-band signalling pipe.
#define USBCAMD_DONT_CARE_PIPE      0x0008  // pipe is not to be used for streaming vidoe or still.

#define USBCAMD_VIDEO_STREAM        0x1
#define USBCAMD_STILL_STREAM        0x2
#define USBCAMD_VIDEO_STILL_STREAM  (USBCAMD_VIDEO_STREAM | USBCAMD_STILL_STREAM)

                                                       
// PacketFlag definitions for CamProcessUSBPacketEx
// *** Notice *** : these flags are mutually exclusive.

// current frame is unsalvageable, recycle the read IRP
#define USBCAMD_PROCESSPACKETEX_DropFrame           0x0002 
// following frame is still.
#define USBCAMD_PROCESSPACKETEX_NextFrameIsStill    0x0004 
// copy this frame to still pin. .                                               
#define USBCAMD_PROCESSPACKETEX_CurrentFrameIsStill 0x0008 

// these flags are used in PipeStateFlag in usbcamd_setpipestate function.

#define USBCAMD_STOP_STREAM             0x00000001
#define USBCAMD_START_STREAM            0x00000000

//
// the following flags are passed to usbcamd in USBCAMD_InitializeNewInterface.
// If Cam driver doesn't need to operate on the still image raw frame, then it should 
// set the second flag in order to elminate on ebuffer copy. Likewise for the video frame.
// the associatedformat flag is set if the cam driver use the same format fro video and 
// virtual still pin. Once, this flag is set, USBCAMD will not allow virtual still pin to be
// opened at different format than the video pin. USE this flag only when the virtual still
// pin produces frames that have exact format as video frames.
// EnableDeviceEvents will expose a deviceevents to stream class & DSHOW which will enable an STI
// Monitor to lunch a still image app if still button is pressed on the camera.

typedef enum {
    USBCAMD_CamControlFlag_NoVideoRawProcessing  = 0x0001,
    USBCAMD_CamControlFlag_NoStillRawProcessing  = 0x0002,
    USBCAMD_CamControlFlag_AssociatedFormat      = 0x0004,
    USBCAMD_CamControlFlag_EnableDeviceEvents    = 0x0008,
} USBCAMD_CamControlFlags;


// ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

typedef 
NTSTATUS
(*PCOMMAND_COMPLETE_FUNCTION)(
    PVOID DeviceContext,
    PVOID CommandContext,
    NTSTATUS NtStatus
    );


typedef
VOID
(*PSTREAM_RECEIVE_PACKET) (
    IN PVOID Srb,
    IN PVOID DeviceContext,
    IN PBOOLEAN Completed
    );


typedef
NTSTATUS
(*PCAM_INITIALIZE_ROUTINE)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );



typedef
NTSTATUS
(*PCAM_CONFIGURE_ROUTINE)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PUSBD_INTERFACE_INFORMATION Interface,
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    PLONG DataPipeIndex,
    PLONG SyncPipeIndex
    );    

typedef
NTSTATUS
(*PCAM_CONFIGURE_ROUTINE_EX)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PUSBD_INTERFACE_INFORMATION Interface,
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    ULONG   PipeConfigListSize,
    PUSBCAMD_Pipe_Config_Descriptor PipeConfig,
    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor
    );    


typedef
NTSTATUS
(*PCAM_START_CAPTURE_ROUTINE)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );    

typedef
NTSTATUS
(*PCAM_START_CAPTURE_ROUTINE_EX)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    ULONG StreamNumber

    );    


typedef
NTSTATUS
(*PCAM_ALLOCATE_BW_ROUTINE)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PULONG RawFrameLength,
    PVOID Format
    );      

typedef
NTSTATUS
(*PCAM_ALLOCATE_BW_ROUTINE_EX)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PULONG RawFrameLength,
    PVOID Format,
    ULONG StreamNumber
    );      

typedef
NTSTATUS
(*PCAM_FREE_BW_ROUTINE)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );      

typedef
NTSTATUS
(*PCAM_FREE_BW_ROUTINE_EX)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    ULONG STreamNumber
    );      

typedef 
VOID
(*PADAPTER_RECEIVE_PACKET_ROUTINE)(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

typedef
NTSTATUS
(*PCAM_STOP_CAPTURE_ROUTINE)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );   
   
typedef
NTSTATUS
(*PCAM_STOP_CAPTURE_ROUTINE_EX)(
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    ULONG StreamNumber
    );      

typedef
ULONG
(*PCAM_PROCESS_PACKET_ROUTINE) (
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PVOID CurrentFrameContext,
    PUSBD_ISO_PACKET_DESCRIPTOR SyncPacket,
    PVOID SyncBuffer,
    PUSBD_ISO_PACKET_DESCRIPTOR DataPacket,
    PVOID DataBuffer,
    PBOOLEAN FrameComplete,
    PBOOLEAN NextFrameIsStill
    );    

typedef
ULONG
(*PCAM_PROCESS_PACKET_ROUTINE_EX) (
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PVOID CurrentFrameContext,
    PUSBD_ISO_PACKET_DESCRIPTOR SyncPacket,
    PVOID SyncBuffer,
    PUSBD_ISO_PACKET_DESCRIPTOR DataPacket,
    PVOID DataBuffer,
    PBOOLEAN FrameComplete,
    PULONG PacketFlag,
    PULONG ValidDataOffset
    );    


typedef
VOID
(*PCAM_NEW_FRAME_ROUTINE) (
    PVOID DeviceContext,
    PVOID FrameContext
    );

typedef
VOID
(*PCAM_NEW_FRAME_ROUTINE_EX) (
    PVOID DeviceContext,
    PVOID FrameContext,
    ULONG StreamNumber,
    PULONG FrameLength
    );

typedef
NTSTATUS
(*PCAM_PROCESS_RAW_FRAME_ROUTINE) (
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PVOID FrameContext,
    PVOID FrameBuffer,
    ULONG FrameLength,
    PVOID RawFrameBuffer,
    ULONG RawFrameLength,
    ULONG NumberOfPackets,
    PULONG BytesReturned
    );

typedef
NTSTATUS
(*PCAM_PROCESS_RAW_FRAME_ROUTINE_EX) (
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext,
    PVOID FrameContext,
    PVOID FrameBuffer,
    ULONG FrameLength,
    PVOID RawFrameBuffer,
    ULONG RawFrameLength,
    ULONG NumberOfPackets,
    PULONG BytesReturned,
    ULONG ActualRawFrameLength,
    ULONG StreamNumber
    );

typedef
NTSTATUS
(*PCAM_STATE_ROUTINE) (
    PDEVICE_OBJECT BusDeviceObject,
    PVOID DeviceContext
    );      


#ifdef DEBUG_LOG

VOID
USBCAMD_Debug_LogEntry(
    IN CHAR *Name,
    IN ULONG Info1,
    IN ULONG Info2,
    IN ULONG Info3
    );

#define ILOGENTRY(sig, info1, info2, info3) \
    USBCAMD_Debug_LogEntry(sig, (ULONG)info1, (ULONG)info2, (ULONG)info3)

#else

#define ILOGENTRY(sig, info1, info2, info3)

#endif /* DEBUG_LOG */



typedef struct _USBCAMD_DEVICE_DATA {
    ULONG Sig;
    PCAM_INITIALIZE_ROUTINE                 CamInitialize;
    PCAM_INITIALIZE_ROUTINE                 CamUnInitialize;
    PCAM_PROCESS_PACKET_ROUTINE             CamProcessUSBPacket;
    PCAM_NEW_FRAME_ROUTINE                  CamNewVideoFrame;
    PCAM_PROCESS_RAW_FRAME_ROUTINE          CamProcessRawVideoFrame;
    PCAM_START_CAPTURE_ROUTINE              CamStartCapture;
    PCAM_STOP_CAPTURE_ROUTINE               CamStopCapture;
    PCAM_CONFIGURE_ROUTINE                  CamConfigure;
    PCAM_STATE_ROUTINE                      CamSaveState;
    PCAM_STATE_ROUTINE                      CamRestoreState;
    PCAM_ALLOCATE_BW_ROUTINE                CamAllocateBandwidth;
    PCAM_FREE_BW_ROUTINE                    CamFreeBandwidth;
    
} USBCAMD_DEVICE_DATA, *PUSBCAMD_DEVICE_DATA;

typedef struct _USBCAMD_DEVICE_DATA2 {
    ULONG Sig;
    PCAM_INITIALIZE_ROUTINE                 CamInitialize;
    PCAM_INITIALIZE_ROUTINE                 CamUnInitialize;
    PCAM_PROCESS_PACKET_ROUTINE_EX          CamProcessUSBPacketEx;
    PCAM_NEW_FRAME_ROUTINE_EX               CamNewVideoFrameEx;
    PCAM_PROCESS_RAW_FRAME_ROUTINE_EX       CamProcessRawVideoFrameEx;
    PCAM_START_CAPTURE_ROUTINE_EX           CamStartCaptureEx;
    PCAM_STOP_CAPTURE_ROUTINE_EX            CamStopCaptureEx;
    PCAM_CONFIGURE_ROUTINE_EX               CamConfigureEx;
    PCAM_STATE_ROUTINE                      CamSaveState;
    PCAM_STATE_ROUTINE                      CamRestoreState;
    PCAM_ALLOCATE_BW_ROUTINE_EX             CamAllocateBandwidthEx;
    PCAM_FREE_BW_ROUTINE_EX                 CamFreeBandwidthEx;
    
} USBCAMD_DEVICE_DATA2, *PUSBCAMD_DEVICE_DATA2;



//
// USBCAMD services
//

/* 

This function is called from the "cam" driver DriverEntry routine to register 
the driver with USBCAMD.  This effectively binds the two drivers together.

Context1, Context2 - these are passed to the "cam" drivers DriverEntry and 
    should simply be passed on 
DeviceContextSize - amount of memory needed for the "cam" driver's device 
    specific context. 
FrameContextSize - size of an optional per video frame structure passed to 
    NewVideoFrame and ProcessRawVideoFrame.

*/

ULONG
USBCAMD_DriverEntry(
    PVOID Context1,
    PVOID Context2,
    ULONG DeviceContextSize,
    ULONG FrameContextSize,
    PADAPTER_RECEIVE_PACKET_ROUTINE ReceivePacket
    );

/*
This function is called by the "cam" driver from the AdapterReceivePacket 
routine to allow USBCAMD to process an SRB.  

Srb - The srb passed to the "cam" driver's AdapterReceievPacket Routine.
DeviceData - filled in USBCAMD_DEVICE_DATAx structure with entry points to the 
    "cam" driver for iso stream processing.
DeviceObject - this pointer will be filled in the device PDO, this is used by 
    the "cam" driver for calls to the USB stack through IoCallDriver. 
NeedsCompletion - if this flag is true USBCAMD will process the SRB and 
    complete it, otherwise USBCAMD will ignore the SRB and just return the 
    DeveiceConext.

Returns:
    Returns a pointer to the device specific context for this instance of the 
    camera "DeviceContext".

*/

PVOID
USBCAMD_AdapterReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PUSBCAMD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT *DeviceObject,
    IN BOOLEAN NeedsCompletion
    );    

/*
This function is available to the "cam" driver to send vendor commands on the 
control pipe.   This function may be called at IRQL >= PASSIVE_LEVEL.  If the 
function is called at IRQL > PASSIVE_LEVEL the command will be deferred until 
passive level, once completed the callers CommandComplete function is called 
with a pointer to the CommandContext. 


DeviceContext - device specific context.
Request - value for the bRequest field for the vendor command.
Value - value for the wValue field of the vendor command.
Index - value for the wIndex field of the vendor conmmand.
Buffer - data buffer if the command has data, may be NULL.
BufferLength - pointer length of Buffer in bytes, may be NULL if buffer is NULL
GetData - flag indicating data direction, "GetData" indicates data is send 
    device-to-host.
CommandComplete - function called when command is completed.
CommandContext - context passed to CommandComplete function

Returns:
    Returns NTSTATUS code from command of STTAUS_PENDING if command is deferred.
    
*/

NTSTATUS
USBCAMD_ControlVendorCommand(
    IN PVOID DeviceContext,
    IN UCHAR Request,
    IN USHORT Value,
    IN USHORT Index,
    IN PVOID Buffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN GetData,
    IN PCOMMAND_COMPLETE_FUNCTION CommandComplete,
    IN PVOID CommandContext
    );    

/*
This function is called by the "cam" driver to select an alternate interface, 
The RequestInterface structure is filled in with the information from the 
SELECT_INTERFACE request on successful completion.  This function is 
typically called from the "cam" driver in response to a request to allocate 
or free bandwidth.

DeviceContext - device specific context.
RequestInterface - USBD_INTERFACE_INFORMATION structure for the appropriate 
    interface to select. The same rules apply to this structure as for the 
    SELECT_INTERFACE USBD request (see USBDI doc). 

Returns:
    Returns the status from the SELECT_INTERFACE request to USBD.

*/

NTSTATUS
USBCAMD_SelectAlternateInterface(
    IN PVOID DeviceContext,
    IN OUT PUSBD_INTERFACE_INFORMATION RequestInterface
    );  

/*
    Handy function to get a device instance specific registry key value
*/

NTSTATUS 
USBCAMD_GetRegistryKeyValue (
    __in HANDLE Handle,
    __in_bcount(KeyNameStringLength) PWCHAR KeyNameString,
    __in ULONG KeyNameStringLength,
    __in_bcount(DataLength) PVOID Data,
    __in ULONG DataLength
    );
//
// These services are new.
//

/* 

This function is called from the "cam" driver upon recieving SRB_INITIALIZE_DEVICE 
to provid usbcamd with all the necessary info to configure the cam driver correctly with
stream class and USB Bus drivers.

DeviceContext - device specific context.
DeviceData - filled in USBCAMD_DEVICE_DATAx structure with entry points to the 
    "cam" driver .
Version - USBCAMD version
CamControlFlag - flags to control interaction with cam driver.

*/

ULONG
USBCAMD_InitializeNewInterface( 
    IN PVOID DeviceContext,
    IN PVOID DeviceData,
    IN ULONG Version,
    IN ULONG CamControlFlag
    );



// To access the new USBCAMD functionality in a CAM driver , the driver sends 
// the following IRP to itself once it received SRB_INITIALIZATION_COMPLETE.

// MajorFunction = IRP_MJ_PNP;
// MinorFunction = IRP_MN_QUERY_INTERFACE;

// {2BCB75C0-B27F-11d1-BA41-00A0C90D2B05}
DEFINE_GUID( GUID_USBCAMD_INTERFACE ,
     0x2bcb75c0, 0xb27f, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5);



//The QUERY_INTERFACE Irp will return an interface (set of function pointers)
// of the type xxxxINTERFACE, defined below. This is essentially a table of
// function pointers.


typedef
NTSTATUS
(*PFNUSBCAMD_SetVideoFormat)( 
    IN PVOID DeviceContext,
    IN     IN PHW_STREAM_REQUEST_BLOCK pSrb
    );


typedef
NTSTATUS
(*PFNUSBCAMD_WaitOnDeviceEvent)( 
    IN PVOID DeviceContext,
    IN ULONG PipeIndex,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PCOMMAND_COMPLETE_FUNCTION   EventComplete,
    IN PVOID EventContext,
    IN BOOLEAN LoopBack
    );

// this function is callable at PASSIVE_LEVEL Only.

typedef
NTSTATUS
(*PFNUSBCAMD_CancelBulkReadWrite)( 
    IN PVOID DeviceContext,
    IN ULONG PipeIndex
    );


typedef
NTSTATUS
(*PFNUSBCAMD_SetIsoPipeState)( 
    IN PVOID DeviceContext,
    IN ULONG PipeStateFlags
    );


typedef
NTSTATUS
(*PFNUSBCAMD_BulkReadWrite)( 
    IN PVOID DeviceContext,
    IN USHORT PipeIndex,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PCOMMAND_COMPLETE_FUNCTION CommandComplete,
    IN PVOID CommandContext
    );

#define USBCAMD_VERSION_200    0x200

typedef struct {
    INTERFACE Interface;
    PFNUSBCAMD_WaitOnDeviceEvent      USBCAMD_WaitOnDeviceEvent;
    PFNUSBCAMD_BulkReadWrite          USBCAMD_BulkReadWrite;
    PFNUSBCAMD_SetVideoFormat         USBCAMD_SetVideoFormat;
    PFNUSBCAMD_SetIsoPipeState        USBCAMD_SetIsoPipeState;
    PFNUSBCAMD_CancelBulkReadWrite    USBCAMD_CancelBulkReadWrite;
} USBCAMD_INTERFACE, *PUSBCAMD_INTERFACE;




#endif /*  __USBCAMDI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usb100.h ===
#ifndef   __USB100_H__
#define   __USB100_H__


#include <PSHPACK1.H>


//bmRequest.Dir
#define BMREQUEST_HOST_TO_DEVICE        0
#define BMREQUEST_DEVICE_TO_HOST        1

//bmRequest.Type
#define BMREQUEST_STANDARD              0
#define BMREQUEST_CLASS                 1
#define BMREQUEST_VENDOR                2

//bmRequest.Recipient
#define BMREQUEST_TO_DEVICE             0
#define BMREQUEST_TO_INTERFACE          1
#define BMREQUEST_TO_ENDPOINT           2
#define BMREQUEST_TO_OTHER              3


#define MAXIMUM_USB_STRING_LENGTH 255

// values for the bits returned by the USB GET_STATUS command
#define USB_GETSTATUS_SELF_POWERED                0x01
#define USB_GETSTATUS_REMOTE_WAKEUP_ENABLED       0x02


#define USB_DEVICE_DESCRIPTOR_TYPE                0x01
#define USB_CONFIGURATION_DESCRIPTOR_TYPE         0x02
#define USB_STRING_DESCRIPTOR_TYPE                0x03
#define USB_INTERFACE_DESCRIPTOR_TYPE             0x04
#define USB_ENDPOINT_DESCRIPTOR_TYPE              0x05

// descriptor types defined by DWG documents
#define USB_RESERVED_DESCRIPTOR_TYPE              0x06
#define USB_CONFIG_POWER_DESCRIPTOR_TYPE          0x07
#define USB_INTERFACE_POWER_DESCRIPTOR_TYPE       0x08

#define USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(d, i) ((USHORT)((USHORT)d<<8 | i))

//
// Values for bmAttributes field of an
// endpoint descriptor
//

#define USB_ENDPOINT_TYPE_MASK                    0x03

#define USB_ENDPOINT_TYPE_CONTROL                 0x00
#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01
#define USB_ENDPOINT_TYPE_BULK                    0x02
#define USB_ENDPOINT_TYPE_INTERRUPT               0x03


//
// definitions for bits in the bmAttributes field of a 
// configuration descriptor.
//
#define USB_CONFIG_POWERED_MASK                   0xc0

#define USB_CONFIG_BUS_POWERED                    0x80
#define USB_CONFIG_SELF_POWERED                   0x40
#define USB_CONFIG_REMOTE_WAKEUP                  0x20

//
// Endpoint direction bit, stored in address
//

#define USB_ENDPOINT_DIRECTION_MASK               0x80

// test direction bit in the bEndpointAddress field of
// an endpoint descriptor.
#define USB_ENDPOINT_DIRECTION_OUT(addr)          (!((addr) & USB_ENDPOINT_DIRECTION_MASK))
#define USB_ENDPOINT_DIRECTION_IN(addr)           ((addr) & USB_ENDPOINT_DIRECTION_MASK)

//
// USB defined request codes
// see chapter 9 of the USB 1.0 specifcation for
// more information.
//

// These are the correct values based on the USB 1.0
// specification

#define USB_REQUEST_GET_STATUS                    0x00
#define USB_REQUEST_CLEAR_FEATURE                 0x01

#define USB_REQUEST_SET_FEATURE                   0x03

#define USB_REQUEST_SET_ADDRESS                   0x05
#define USB_REQUEST_GET_DESCRIPTOR                0x06
#define USB_REQUEST_SET_DESCRIPTOR                0x07
#define USB_REQUEST_GET_CONFIGURATION             0x08
#define USB_REQUEST_SET_CONFIGURATION             0x09
#define USB_REQUEST_GET_INTERFACE                 0x0A
#define USB_REQUEST_SET_INTERFACE                 0x0B
#define USB_REQUEST_SYNC_FRAME                    0x0C


//
// defined USB device classes
//


#define USB_DEVICE_CLASS_RESERVED           0x00
#define USB_DEVICE_CLASS_AUDIO              0x01
#define USB_DEVICE_CLASS_COMMUNICATIONS     0x02
#define USB_DEVICE_CLASS_HUMAN_INTERFACE    0x03
#define USB_DEVICE_CLASS_MONITOR            0x04
#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE 0x05
#define USB_DEVICE_CLASS_POWER              0x06
#define USB_DEVICE_CLASS_PRINTER            0x07
#define USB_DEVICE_CLASS_STORAGE            0x08
#define USB_DEVICE_CLASS_HUB                0x09
#define USB_DEVICE_CLASS_VENDOR_SPECIFIC    0xFF

//
// USB Core defined Feature selectors
//

#define USB_FEATURE_ENDPOINT_STALL          0x0000
#define USB_FEATURE_REMOTE_WAKEUP           0x0001

//
// USB DWG defined Feature selectors
//

#define USB_FEATURE_INTERFACE_POWER_D0      0x0002
#define USB_FEATURE_INTERFACE_POWER_D1      0x0003
#define USB_FEATURE_INTERFACE_POWER_D2      0x0004
#define USB_FEATURE_INTERFACE_POWER_D3      0x0005

typedef struct _USB_DEVICE_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
    USHORT idVendor;
    USHORT idProduct;
    USHORT bcdDevice;
    UCHAR iManufacturer;
    UCHAR iProduct;
    UCHAR iSerialNumber;
    UCHAR bNumConfigurations;
} USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;

typedef struct _USB_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bEndpointAddress;
    UCHAR bmAttributes;
    USHORT wMaxPacketSize;
    UCHAR bInterval;
} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;

typedef struct _USB_CONFIGURATION_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT wTotalLength;
    UCHAR bNumInterfaces;
    UCHAR bConfigurationValue;
    UCHAR iConfiguration;
    UCHAR bmAttributes;
    UCHAR MaxPower;
} USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;

typedef struct _USB_INTERFACE_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bInterfaceNumber;
    UCHAR bAlternateSetting;
    UCHAR bNumEndpoints;
    UCHAR bInterfaceClass;
    UCHAR bInterfaceSubClass;
    UCHAR bInterfaceProtocol;
    UCHAR iInterface;
} USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;

typedef struct _USB_STRING_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    WCHAR bString[1];
} USB_STRING_DESCRIPTOR, *PUSB_STRING_DESCRIPTOR;

typedef struct _USB_COMMON_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
} USB_COMMON_DESCRIPTOR, *PUSB_COMMON_DESCRIPTOR;


//
// Standard USB HUB definitions 
//
// See Chapter 11 USB core specification
//

typedef struct _USB_HUB_DESCRIPTOR {
    UCHAR        bDescriptorLength;      // Length of this descriptor
    UCHAR        bDescriptorType;        // Hub configuration type
    UCHAR        bNumberOfPorts;         // number of ports on this hub
    USHORT       wHubCharacteristics;    // Hub Charateristics
    UCHAR        bPowerOnToPowerGood;    // port power on till power good in 2ms
    UCHAR        bHubControlCurrent;     // max current in mA
    //
    // room for 255 ports power control and removable bitmask
    UCHAR        bRemoveAndPowerMask[64];       
} USB_HUB_DESCRIPTOR, *PUSB_HUB_DESCRIPTOR;


//
// Structures defined by various DWG feature documents
//


//
// See DWG USB Feature Specification: Interface Power Management
//

#define USB_SUPPORT_D0_COMMAND      0x01
#define USB_SUPPORT_D1_COMMAND      0x02
#define USB_SUPPORT_D2_COMMAND      0x04
#define USB_SUPPORT_D3_COMMAND      0x08

#define USB_SUPPORT_D1_WAKEUP       0x10
#define USB_SUPPORT_D2_WAKEUP       0x20


typedef struct _USB_CONFIGURATION_POWER_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR SelfPowerConsumedD0[3];
    UCHAR bPowerSummaryId;
    UCHAR bBusPowerSavingD1;
    UCHAR bSelfPowerSavingD1;
    UCHAR bBusPowerSavingD2;
    UCHAR bSelfPowerSavingD2; 
    UCHAR bBusPowerSavingD3;
    UCHAR bSelfPowerSavingD3; 
    USHORT TransitionTimeFromD1;
    USHORT TransitionTimeFromD2;
    USHORT TransitionTimeFromD3;
} USB_CONFIGURATION_POWER_DESCRIPTOR, *PUSB_CONFIGURATION_POWER_DESCRIPTOR;


typedef struct _USB_INTERFACE_POWER_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bmCapabilitiesFlags;
    UCHAR bBusPowerSavingD1;
    UCHAR bSelfPowerSavingD1;
    UCHAR bBusPowerSavingD2;
    UCHAR bSelfPowerSavingD2; 
    UCHAR bBusPowerSavingD3;
    UCHAR bSelfPowerSavingD3; 
    USHORT TransitionTimeFromD1;
    USHORT TransitionTimeFromD2;
    USHORT TransitionTimeFromD3;
} USB_INTERFACE_POWER_DESCRIPTOR, *PUSB_INTERFACE_POWER_DESCRIPTOR;


#include <POPPACK.H>


#endif   /* __USB100_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usbdi.h ===
/*++

Copyright 2004(c) Microsoft Corporation. All rights reserved.

Module Name:

        USBDI.H

Abstract:

   Obsolete header.  Use usb.h.

Environment:

    Kernel & user mode

Revision History:

    09-29-95 : created
    02-01-04 : updated to use usb.h

--*/

#ifndef   __USBDI_H__
#define   __USBDI_H__

#include <usb.h>

#include <usbioctl.h>

//
// The following are deprecated definitions.  These should not be used
//

#define USBD_STATUS_CANCELLING      ((USBD_STATUS)0x00020000L)
#define USBD_STATUS_CANCELING       ((USBD_STATUS)0x00020000L)
#define USBD_STATUS_NO_MEMORY       ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_ERROR           ((USBD_STATUS)0x80000000L)
#define USBD_STATUS_REQUEST_FAILED  ((USBD_STATUS)0x80000500L)
#define USBD_STATUS_HALTED          ((USBD_STATUS)0xC0000000L)


#define USBD_HALTED(Status)  ((ULONG)(Status) >> 30 == 3)
#define USBD_STATUS(Status) ((ULONG)(Status) & 0x0FFFFFFFL)

#define URB_FUNCTION_RESERVED0                      0x0016
#define URB_FUNCTION_RESERVED                       0x001D
#define URB_FUNCTION_LAST                           0x0029

#define USBD_PF_DOUBLE_BUFFER           0x00000002

#ifdef USBD_PF_VALID_MASK
#undef USBD_PF_VALID_MASK
#endif

#define USBD_PF_VALID_MASK    (USBD_PF_CHANGE_MAX_PACKET | \
                               USBD_PF_DOUBLE_BUFFER | \
                               USBD_PF_ENABLE_RT_THREAD_ACCESS | \
                               USBD_PF_MAP_ADD_TRANSFERS)

#define USBD_TRANSFER_DIRECTION_BIT             0
#define USBD_SHORT_TRANSFER_OK_BIT              1
#define USBD_START_ISO_TRANSFER_ASAP_BIT        2

#ifdef USBD_TRANSFER_DIRECTION
#undef USBD_TRANSFER_DIRECTION
#endif

#define USBD_TRANSFER_DIRECTION(x)      ((x) & USBD_TRANSFER_DIRECTION_IN)

#endif /*  __USBDI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\UtilLib.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  utillib.h
//
//  Purpose: gather up utillib headers into one catch-all
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef UTILLIB_HEADERFILE_IS_INCLUDED
#define UTILLIB_HEADERFILE_IS_INCLUDED

#include <ProvExce.h>

#include <GenLex.h>
#include <ObjPath.h> 
#include <OPathLex.h> 

#include <CHString.h>
#include <CHStrArr.h>
#include <CHPtrArr.h>
#include <Polarity.h>
#include <WbemTime.h>


#ifndef _DBG_ASSERT
  #ifdef DBG
    #define _DBG_ASSERT(X) { if (!(X)) { DebugBreak(); } }
  #else
    #define _DBG_ASSERT(X)
  #endif
#endif

// MACRO for tracing the safe string return failure  -- currently empty
#ifndef DoTraceHRFailureEmpty
#define DoTraceHRFailureEmpty(hr1, szTraceInfo, hr2)    ;
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\vbinterf.h ===
//---------------------------------------------------------------------------
// IVBGetControl
//---------------------------------------------------------------------------
// This interface lives on the Extender Object
//---------------------------------------------------------------------------

// Constants for dwWhich parameter:
#define GC_WCH_SIBLING          0x00000001L
#define GC_WCH_CONTAINER        0x00000002L   // no FONLYAFTER/BEFORE
#define GC_WCH_CONTAINED        0x00000003L   // no FONLYAFTER/BEFORE
#define GC_WCH_ALL              0x00000004L
#define GC_WCH_FREVERSEDIR      0x08000000L   // OR'd with others
#define GC_WCH_FONLYAFTER       0x10000000L   // OR'd with others
#define GC_WCH_FONLYBEFORE      0x20000000L   // OR'd with others
#define GC_WCH_FSELECTED        0x40000000L   // OR'd with others

DECLARE_INTERFACE_(IVBGetControl, IUnknown)
    {
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IVBGetControl methods ****
    STDMETHOD(EnumControls)(THIS_ DWORD dwOleContF, DWORD dwWhich, LPENUMUNKNOWN FAR *ppenumUnk) PURE;
    };

//---------------------------------------------------------------------------
// IGetOleObject
//---------------------------------------------------------------------------
// This interface lives on the Extender Object (X-Object / hctl)
//---------------------------------------------------------------------------
DECLARE_INTERFACE_(IGetOleObject, IUnknown)
    {
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IGetOleObject methods ****
    STDMETHOD(GetOleObject)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    };

DECLARE_INTERFACE_(IVBFormat,IUnknown)
  {
  /* IUnknown methods */
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
  STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
  STDMETHOD_(unsigned long, Release)(THIS) PURE;
  STDMETHOD(Format)(VARIANT FAR *vData,  BSTR bstrFormat, LPVOID lpBuffer,
	USHORT cb,  LONG lcid, SHORT sFirstDayOfWeek,
	USHORT sFirstWeekOfYear, USHORT * rcb) PURE;
  };

DECLARE_INTERFACE_(IGetVBAObject,IUnknown)
  {
  /* IUnknown methods */
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
  STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
  STDMETHOD_(unsigned long, Release)(THIS) PURE;

  STDMETHOD(GetObject)(THIS_ REFIID riid, void FAR* FAR* ppvObj, DWORD dwReserved) PURE;
  };

#include <initguid.h>

//IVBGetControl & IGetOleObject
DEFINE_GUID(IID_IVBGetControl, 0x40A050A0L, 0x3C31, 0x101B, 0xA8, 0x2E, 0x08, 0x00, 0x2B, 0x2B, 0x23, 0x37);
DEFINE_GUID(IID_IGetOleObject, 0x8A701DA0L, 0x4FEB, 0x101B, 0xA8, 0x2E, 0x08, 0x00, 0x2B, 0x2B, 0x23, 0x37);

//Format
DEFINE_GUID(IID_IGetVBAObject, 0x91733A60L, 0x3F4C, 0x101B, 0xA3, 0xF6, 0x00, 0xAA, 0x00, 0x34, 0xE4, 0xE9);
DEFINE_GUID(IID_IVBFormat, 0x9849FD60L, 0x3768, 0x101B, 0x8D, 0x72, 0xAE, 0x61,0x64, 0xFF, 0xE3, 0xCF);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usbuser.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        USBUSER.H

Abstract:

        This file contains USER Mode IOCTLS supported by
        the USB PORT or (HC - Host Controller) driver.

Environment:

    user mode

Revision History:


--*/

#ifndef   __USBUSER_H__
#define   __USBUSER_H__

/*
    User IOCTLS defined for Windows XP and later only
*/
#if (_WIN32_WINNT >= 0x0501)

#include "usbiodef.h"

#include <PSHPACK1.H>

#define USBUSER_VERSION     0x00000004

#define IOCTL_USB_USER_REQUEST          USB_CTL(HCD_USER_REQUEST)
/*
    The following were used by test applications and are no
    longer supported (they have been replaced with USBUSER Opcodes):


#define IOCTL_USB_HCD_GET_STATS_1   USB_CTL(HCD_GET_STATS_1)
#define IOCTL_USB_HCD_GET_STATS_2   USB_CTL(HCD_GET_STATS_2)
#define IOCTL_USB_HCD_DISABLE_PORT  USB_CTL(HCD_DISABLE_PORT)
#define IOCTL_USB_HCD_ENABLE_PORT   USB_CTL(HCD_ENABLE_PORT)
*/

/*
   The following are used by the 'USBDIAG' driver
*/
#ifndef IOCTL_USB_DIAGNOSTIC_MODE_ON
#define IOCTL_USB_DIAGNOSTIC_MODE_ON    USB_CTL(HCD_DIAGNOSTIC_MODE_ON)
#endif
#ifndef IOCTL_USB_DIAGNOSTIC_MODE_OFF
#define IOCTL_USB_DIAGNOSTIC_MODE_OFF   USB_CTL(HCD_DIAGNOSTIC_MODE_OFF)
#endif

#ifndef IOCTL_USB_GET_ROOT_HUB_NAME
#define IOCTL_USB_GET_ROOT_HUB_NAME     USB_CTL(HCD_GET_ROOT_HUB_NAME)
#endif
#ifndef IOCTL_GET_HCD_DRIVERKEY_NAME
#define IOCTL_GET_HCD_DRIVERKEY_NAME    USB_CTL(HCD_GET_DRIVERKEY_NAME)
#endif

/*
    define error codes
*/
typedef enum _USB_USER_ERROR_CODE {

    UsbUserSuccess = 0,
    UsbUserNotSupported,
    UsbUserInvalidRequestCode,
    UsbUserFeatureDisabled,
    UsbUserInvalidHeaderParameter,
    UsbUserInvalidParameter,
    UsbUserMiniportError,
    UsbUserBufferTooSmall,
    UsbUserErrorNotMapped,
    UsbUserDeviceNotStarted,
    UsbUserNoDeviceConnected

} USB_USER_ERROR_CODE;

/*
    define USB USER request Codes
*/

/*
    The following APIS are enabled always
*/
#define USBUSER_GET_CONTROLLER_INFO_0           0x00000001
#define USBUSER_GET_CONTROLLER_DRIVER_KEY       0x00000002
#define USBUSER_PASS_THRU                       0x00000003
#define USBUSER_GET_POWER_STATE_MAP             0x00000004
#define USBUSER_GET_BANDWIDTH_INFORMATION       0x00000005
#define USBUSER_GET_BUS_STATISTICS_0            0x00000006
#define USBUSER_GET_ROOTHUB_SYMBOLIC_NAME       0x00000007
#define USBUSER_GET_USB_DRIVER_VERSION          0x00000008
#define USBUSER_GET_USB2_HW_VERSION             0x00000009
#define USBUSER_USB_REFRESH_HCT_REG             0x0000000a

/*
    The following APIs are only enabled when the
    devlopr key is set in the registry.
*/
#define USBUSER_OP_SEND_ONE_PACKET              0x10000001

/*
    The following APIs are only enabled when the
    root hub is disabled.
*/

#define USBUSER_OP_RAW_RESET_PORT               0x20000001
#define USBUSER_OP_OPEN_RAW_DEVICE              0x20000002
#define USBUSER_OP_CLOSE_RAW_DEVICE             0x20000003
#define USBUSER_OP_SEND_RAW_COMMAND             0x20000004

#define USBUSER_SET_ROOTPORT_FEATURE            0x20000005
#define USBUSER_CLEAR_ROOTPORT_FEATURE          0x20000006
#define USBUSER_GET_ROOTPORT_STATUS             0x20000007

#define USBUSER_INVALID_REQUEST                 0xFFFFFFF0

#define USBUSER_OP_MASK_DEVONLY_API             0x10000000
#define USBUSER_OP_MASK_HCTEST_API              0x20000000


/*
    Common Header used by all USBUSER APIS
*/

typedef struct _USBUSER_REQUEST_HEADER {
    /*
        API Requested
    */
    ULONG UsbUserRequest;
    /*
        status code returned by port driver
    */
    USB_USER_ERROR_CODE UsbUserStatusCode;
    /*
        size of client input/output buffer
        we always use the same buffer for input
        and output
    */
    ULONG RequestBufferLength;
    /*
        size of buffer required to get all of the data
    */
    ULONG ActualBufferLength;

} USBUSER_REQUEST_HEADER, *PUSBUSER_REQUEST_HEADER;


/*****************************************************
    API - Send a single usb packet on the bus

    USBUSER_OP_SEND_ONE_PACKET

    This API is used to implement the 'single step'
    USB transaction development tool.

*******************************************************/

/*
  transaction speed
*/
#define USB_PACKETFLAG_LOW_SPEED            0x00000001
#define USB_PACKETFLAG_FULL_SPEED           0x00000002
#define USB_PACKETFLAG_HIGH_SPEED           0x00000004

/*
  transaction type async(bulk, control, interrupt) or iso
*/
#define USB_PACKETFLAG_ASYNC_IN             0x00000008
#define USB_PACKETFLAG_ASYNC_OUT            0x00000010
#define USB_PACKETFLAG_ISO_IN               0x00000020
#define USB_PACKETFLAG_ISO_OUT              0x00000040
#define USB_PACKETFLAG_SETUP                0x00000080

/*
  transaction data toggle
*/
#define USB_PACKETFLAG_TOGGLE0              0x00000100
#define USB_PACKETFLAG_TOGGLE1              0x00000200

typedef struct _PACKET_PARAMETERS {

    UCHAR DeviceAddress;
    UCHAR EndpointAddress;
    USHORT MaximumPacketSize;
    /* timeout in ms, zero means default */
    /* default timeout is 10 ms */
    ULONG Timeout;
    ULONG Flags;
    ULONG DataLength;
    /* for 2.0 hubs */
    USHORT HubDeviceAddress;
    USHORT PortTTNumber;

    UCHAR ErrorCount;
    UCHAR Pad[3];

    USBD_STATUS UsbdStatusCode;
    UCHAR Data[4];

} PACKET_PARAMETERS, *PPACKET_PARAMETERS;

typedef struct _USBUSER_SEND_ONE_PACKET {

    USBUSER_REQUEST_HEADER Header;
    PACKET_PARAMETERS PacketParameters;

} USBUSER_SEND_ONE_PACKET, *PUSBUSER_SEND_ONE_PACKET;

/*****************************************************
    API - Test Reset Root Port

    USBUSER_OP_RAW_RESET_PORT
******************************************************/

typedef struct _RAW_RESET_PORT_PARAMETERS {

    USHORT PortNumber;
    USHORT PortStatus;

} RAW_RESET_PORT_PARAMETERS, *PRAW_RESET_PORT_PARAMETERS;

typedef struct _USBUSER_RAW_RESET_ROOT_PORT {

    USBUSER_REQUEST_HEADER Header;
    RAW_RESET_PORT_PARAMETERS Parameters;

} USBUSER_RAW_RESET_ROOT_PORT, *PUSBUSER_RAW_RESET_ROOT_PORT;

/*****************************************************
    API - Test Set/Clear Root Port Feature

    USBUSER_SET_ROOTPORT_FEATURE
    USBUSER_CLEAR_ROOTPORT_FEATURE
******************************************************/

typedef struct _RAW_ROOTPORT_FEATURE {

    USHORT PortNumber;
    USHORT PortFeature;
    USHORT PortStatus;

} RAW_ROOTPORT_FEATURE, *PRAW_ROOTPORT_FEATURE;

typedef struct _USBUSER_ROOTPORT_FEATURE_REQUEST {

    USBUSER_REQUEST_HEADER Header;
    RAW_ROOTPORT_FEATURE Parameters;

} USBUSER_ROOTPORT_FEATURE_REQUEST, *PUSBUSER_ROOTPORT_FEATURE_REQUEST;

/*****************************************************
    API - Get RootPort Status

    USBUSER_GET_ROOTPORT_STATUS

******************************************************/

typedef struct _RAW_ROOTPORT_PARAMETERS {

    USHORT PortNumber;
    USHORT PortStatus;

} RAW_ROOTPORT_PARAMETERS, *PRAW_ROOTPORT_PARAMETERS;

typedef struct _USBUSER_ROOTPORT_PARAMETERS {

    USBUSER_REQUEST_HEADER Header;
    RAW_ROOTPORT_PARAMETERS Parameters;

} USBUSER_ROOTPORT_PARAMETERS, *PUSBUSER_ROOTPORT_PARAMETERS;

/****************************************************
    API - Get Controller Information

    Return some information about the controller

    USBUSER_GET_CONTROLLER_INFO_0
****************************************************/

/* these flags indicate features of the HC */

#define USB_HC_FEATURE_FLAG_PORT_POWER_SWITCHING    0x00000001
#define USB_HC_FEATURE_FLAG_SEL_SUSPEND             0x00000002
#define USB_HC_FEATURE_LEGACY_BIOS                  0x00000004

typedef struct _USB_CONTROLLER_INFO_0 {

    ULONG PciVendorId;
    ULONG PciDeviceId;
    ULONG PciRevision;

    ULONG NumberOfRootPorts;

    USB_CONTROLLER_FLAVOR ControllerFlavor;

    ULONG HcFeatureFlags;

} USB_CONTROLLER_INFO_0 , *PUSB_CONTROLLER_INFO_0;

typedef struct _USBUSER_CONTROLLER_INFO_0 {

    USBUSER_REQUEST_HEADER Header;
    USB_CONTROLLER_INFO_0 Info0;

} USBUSER_CONTROLLER_INFO_0, *PUSBUSER_CONTROLLER_INFO_0;

/****************************************************
    API - Get Controller Driver Key

    Returns the driver key in the registry associated
    with this controller.

    The key is returned NULL terminated, KeyLength
    is the length of the key in bytes including the
    UNICODE_NULL

    USBUSER_GET_CONTROLLER_DRIVER_KEY

    API - Get Root Hub Name

    Returns the symbolic name for the root hub on the
    host controller. Length is the length of the name
    in bytes including the NULL.

    USBUSER_GET_ROOTHUB_SYMBOLIC_NAME

----------------------------------------------------

    The following structure is used to return unicode
    names from the port driver for both of these APIs.

****************************************************/

typedef struct _USB_UNICODE_NAME {

    ULONG Length;
    WCHAR String[1];

} USB_UNICODE_NAME, *PUSB_UNICODE_NAME;

typedef struct _USBUSER_CONTROLLER_UNICODE_NAME {

    USBUSER_REQUEST_HEADER Header;
    USB_UNICODE_NAME UnicodeName;

} USBUSER_CONTROLLER_UNICODE_NAME, *PUSBUSER_CONTROLLER_UNICODE_NAME;

/****************************************************
    API - PassThru

    allows for vendor specific APIs to be passed to
    Host Controller Miniport Driver

    The vendors must pass a guid that is recognized
    by the miniport , this enures that the parameters
    are not miss-interpreted

    USBUSER_PASS_THRU
****************************************************/

typedef struct _USB_PASS_THRU_PARAMETERS {

    GUID FunctionGUID;
    ULONG ParameterLength;
    UCHAR Parameters[4];

} USB_PASS_THRU_PARAMETERS, *PUSB_PASS_THRU_PARAMETERS;

typedef struct _USBUSER_PASS_THRU_REQUEST {

    USBUSER_REQUEST_HEADER Header;
    USB_PASS_THRU_PARAMETERS PassThru;

} USBUSER_PASS_THRU_REQUEST, *PUSBUSER_PASS_THRU_REQUEST;


/****************************************************
    API - GetPowerStateMap

    Returns specific information about a controller
    and root hubs power state given a specific
    system state.

    USBUSER_GET_POWER_STATE_MAP
****************************************************/

typedef enum _WDMUSB_POWER_STATE {

    WdmUsbPowerNotMapped = 0,

    WdmUsbPowerSystemUnspecified = 100,
    WdmUsbPowerSystemWorking,
    WdmUsbPowerSystemSleeping1,
    WdmUsbPowerSystemSleeping2,
    WdmUsbPowerSystemSleeping3,
    WdmUsbPowerSystemHibernate,
    WdmUsbPowerSystemShutdown,

    WdmUsbPowerDeviceUnspecified = 200,
    WdmUsbPowerDeviceD0,
    WdmUsbPowerDeviceD1,
    WdmUsbPowerDeviceD2,
    WdmUsbPowerDeviceD3

} WDMUSB_POWER_STATE;

typedef struct _USB_POWER_INFO {

    /* input */
    WDMUSB_POWER_STATE SystemState;
    /* output */
    WDMUSB_POWER_STATE HcDevicePowerState;
    WDMUSB_POWER_STATE HcDeviceWake;
    WDMUSB_POWER_STATE HcSystemWake;

    WDMUSB_POWER_STATE RhDevicePowerState;
    WDMUSB_POWER_STATE RhDeviceWake;
    WDMUSB_POWER_STATE RhSystemWake;

    WDMUSB_POWER_STATE LastSystemSleepState;

    BOOLEAN CanWakeup;
    BOOLEAN IsPowered;

} USB_POWER_INFO, *PUSB_POWER_INFO;

typedef struct _USBUSER_POWER_INFO_REQUEST {

    USBUSER_REQUEST_HEADER Header;
    USB_POWER_INFO PowerInformation;

} USBUSER_POWER_INFO_REQUEST, *PUSBUSER_POWER_INFO_REQUEST;


/****************************************************
    API - Open Raw Device access on the bus

    USBUSER_OP_OPEN_RAW_DEVICE
****************************************************/

typedef struct _USB_OPEN_RAW_DEVICE_PARAMETERS {

    USHORT PortStatus;
    USHORT MaxPacketEp0;

} USB_OPEN_RAW_DEVICE_PARAMETERS , *PUSB_OPEN_RAW_DEVICE_PARAMETERS;

typedef struct _USBUSER_OPEN_RAW_DEVICE {

    USBUSER_REQUEST_HEADER Header;
    USB_OPEN_RAW_DEVICE_PARAMETERS Parameters;

} USBUSER_OPEN_RAW_DEVICE, *PUSBUSER_OPEN_RAW_DEVICE;

/****************************************************
    API - Close Raw Device access on the bus

    USBUSER_OP_CLOSE_RAW_DEVICE
****************************************************/

typedef struct _USB_CLOSE_RAW_DEVICE_PARAMETERS {

    ULONG xxx;

} USB_CLOSE_RAW_DEVICE_PARAMETERS , *PUSB_CLOSE_RAW_DEVICE_PARAMETERS;

typedef struct _USBUSER_CLOSE_RAW_DEVICE {

    USBUSER_REQUEST_HEADER Header;
    USB_CLOSE_RAW_DEVICE_PARAMETERS Parameters;

} USBUSER_CLOSE_RAW_DEVICE, *PUSBUSER_CLOSE_RAW_DEVICE;


/****************************************************
    API - Send control command via raw device handle

    USBUSER_OP_SEND_RAW_COMMAND
****************************************************/

typedef struct _USB_SEND_RAW_COMMAND_PARAMETERS {

    /* setup packet */
    UCHAR Usb_bmRequest;
    UCHAR Usb_bRequest;
    USHORT Usb_wVlaue;
    USHORT Usb_wIndex;
    USHORT Usb_wLength;

    /* other parameters */
    USHORT DeviceAddress;
    USHORT MaximumPacketSize;
    ULONG Timeout;
    ULONG DataLength;
    USBD_STATUS UsbdStatusCode;
    UCHAR Data[4];

} USB_SEND_RAW_COMMAND_PARAMETERS, *PUSB_SEND_RAW_COMMAND_PARAMETERS;

typedef struct _USBUSER_SEND_RAW_COMMAND {

    USBUSER_REQUEST_HEADER Header;
    USB_SEND_RAW_COMMAND_PARAMETERS Parameters;

} USBUSER_SEND_RAW_COMMAND, *PUSBUSER_SEND_RAW_COMMAND;


/****************************************************
    API - return information about allocated
        bandwidth

    USBUSER_GET_BANDWIDTH_INFORMATION
****************************************************/

typedef struct _USB_BANDWIDTH_INFO {

    ULONG DeviceCount;
    // total bandith in bits/sec
    ULONG TotalBusBandwidth;

    // allocated bandwidth based on a 32 sec
    // slice of bus time ie bits/32 sec
    ULONG Total32secBandwidth;

    ULONG AllocedBulkAndControl;
    ULONG AllocedIso;
    ULONG AllocedInterrupt_1ms;
    ULONG AllocedInterrupt_2ms;
    ULONG AllocedInterrupt_4ms;
    ULONG AllocedInterrupt_8ms;
    ULONG AllocedInterrupt_16ms;
    ULONG AllocedInterrupt_32ms;

} USB_BANDWIDTH_INFO, *PUSB_BANDWIDTH_INFO;

typedef struct _USBUSER_BANDWIDTH_INFO_REQUEST {

    USBUSER_REQUEST_HEADER Header;
    USB_BANDWIDTH_INFO BandwidthInformation;

} USBUSER_BANDWIDTH_INFO_REQUEST, *PUSBUSER_BANDWIDTH_INFO_REQUEST;


/****************************************************
    API - return information data transferred on the
        bus

    USBUSER_BUS_STATISTICS_0
****************************************************/

typedef struct _USB_BUS_STATISTICS_0 {

    ULONG DeviceCount;

    LARGE_INTEGER CurrentSystemTime;

    ULONG CurrentUsbFrame;

    ULONG BulkBytes;
    ULONG IsoBytes;
    ULONG InterruptBytes;
    ULONG ControlDataBytes;

    ULONG PciInterruptCount;
    ULONG HardResetCount;
    ULONG WorkerSignalCount;
    ULONG CommonBufferBytes;
    ULONG WorkerIdleTimeMs;

    BOOLEAN RootHubEnabled;
     // 0=D0, 1=D1, 2=D2, 3=D3
    UCHAR RootHubDevicePowerState;
    // 1 = active 0 = idle
    UCHAR Unused;
    // used to generate legacy name HCDn
    UCHAR NameIndex;

} USB_BUS_STATISTICS_0, *PUSB_BUS_STATISTICS_0;

typedef struct _USBUSER_BUS_STATISTICS_0_REQUEST {

    USBUSER_REQUEST_HEADER Header;
    USB_BUS_STATISTICS_0 BusStatistics0;

} USBUSER_BUS_STATISTICS_0_REQUEST, *PUSBUSER_BUS_STATISTICS_0_REQUEST;


/****************************************************
    API - Get USB DRIVER Version

    USBUSER_GET_USB_DRIVER_VERSION
****************************************************/

typedef struct _USB_DRIVER_VERSION_PARAMETERS {

    /* goat code for this rev of the stack */
    ULONG DriverTrackingCode;
    /* USBDI Api set supported */
    ULONG USBDI_Version;
    /* USB USER Api Set supported */
    ULONG USBUSER_Version;

    /* set to true if checked vesrion(s) on
       the stack are loaded
    */
    BOOLEAN CheckedPortDriver;
    BOOLEAN CheckedMiniportDriver;

    /* BCD usb version 0x0110 (1.1) 0x0200 (2.0) */
    USHORT USB_Version;

} USB_DRIVER_VERSION_PARAMETERS , *PUSB_DRIVER_VERSION_PARAMETERS;

typedef struct _USBUSER_GET_DRIVER_VERSION {

    USBUSER_REQUEST_HEADER Header;
    USB_DRIVER_VERSION_PARAMETERS Parameters;

} USBUSER_GET_DRIVER_VERSION, *PUSBUSER_GET_DRIVER_VERSION;

/****************************************************
    API - Get USB 2 Hardware Revision

    USBUSER_GET_USB2HW_VERSION
*****************************************************/

//#define USB2HW_UNKNOWN  0x00
//#define USB2HW_A0       0xA0
//#define USB2HW_A1       0xA1
//#define USB2HW_B0       0xB0

typedef struct _USB_USB2HW_VERSION_PARAMETERS {

    UCHAR Usb2HwRevision;

} USB_USB2HW_VERSION_PARAMETERS, *PUSB_USB2HW_VERSION_PARAMETERS;

typedef struct _USBUSER_GET_USB2HW_VERSION {

    USBUSER_REQUEST_HEADER Header;
    USB_USB2HW_VERSION_PARAMETERS Parameters;

} USBUSER_GET_USB2HW_VERSION, *PUSBUSER_GET_USB2HW_VERSION;

/****************************************************
    API - Get USB refresh global keys

    USBUSER_REFRESH_G_REG
*****************************************************/



typedef struct _USBUSER_REFRESH_HCT_REG {

    USBUSER_REQUEST_HEADER Header;
    ULONG Flags;

} USBUSER_REFRESH_HCT_REG, *PUSBUSER_REFRESH_HCT_REG;


#include <POPPACK.H>

#endif
#endif //__USBUSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\UserEnv.h ===
//=============================================================================
//  userenv.h   -   Header file for user environment API.
//                  User Profiles, environment variables, and Group Policy
//
//  Copyright (c) Microsoft Corporation 1995-2002
//  All rights reserved
//
//=============================================================================


#ifndef _INC_USERENV
#define _INC_USERENV

#include <wbemcli.h>
#include <profinfo.h>

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_USERENV_)
#define USERENVAPI DECLSPEC_IMPORT
#else
#define USERENVAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif

//=============================================================================
//
// LoadUserProfile
//
// Loads the specified user's profile.
//
// Most applications should not need to use this function.  It's used
// when a user has logged onto the system or a service starts in a named
// user account.
//
// hToken        - Token for the user, returned from LogonUser()
// lpProfileInfo - Address of a PROFILEINFO structure
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:  The caller of this function must have admin privileges on the machine.
//
//        Upon successful return, the hProfile member of the PROFILEINFO
//        structure is a registry key handle opened to the root
//        of the user's hive.  It has been opened with full access. If
//        you need to read or write to the user's registry file, use
//        this key instead of HKEY_CURRENT_USER.  Do not close this
//        handle.  Instead pass it to UnloadUserProfile to close
//        the handle.
//
//=============================================================================

//
// Flags that can be set in the dwFlags field
//

#define PI_NOUI         0x00000001      // Prevents displaying of messages
#define PI_APPLYPOLICY  0x00000002      // Apply NT4 style policy

USERENVAPI
BOOL
WINAPI
LoadUserProfileA(
    IN HANDLE hToken,
    IN OUT LPPROFILEINFOA lpProfileInfo);
USERENVAPI
BOOL
WINAPI
LoadUserProfileW(
    IN HANDLE hToken,
    IN OUT LPPROFILEINFOW lpProfileInfo);
#ifdef UNICODE
#define LoadUserProfile  LoadUserProfileW
#else
#define LoadUserProfile  LoadUserProfileA
#endif // !UNICODE


//=============================================================================
//
// UnloadUserProfile
//
// Unloads a user's profile that was loaded by LoadUserProfile()
//
// hToken        -  Token for the user, returned from LogonUser()
// hProfile      -  hProfile member of the PROFILEINFO structure
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     The caller of this function must have admin privileges on the machine.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
UnloadUserProfile(
    IN HANDLE hToken,
    IN HANDLE hProfile);


//=============================================================================
//
// GetProfilesDirectory
//
// Returns the path to the root of where all user profiles are stored.
//
// lpProfilesDir  -  Receives the path
// lpcchSize      -  Size of lpProfilesDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfilesDir is not large enough, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Documents and Settings
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GetProfilesDirectoryA(
    OUT LPSTR lpProfilesDir,
    IN OUT LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetProfilesDirectoryW(
    OUT LPWSTR lpProfilesDir,
    IN OUT LPDWORD lpcchSize);
#ifdef UNICODE
#define GetProfilesDirectory  GetProfilesDirectoryW
#else
#define GetProfilesDirectory  GetProfilesDirectoryA
#endif // !UNICODE


//=============================================================================
//
//  GetProfileType()
//
//  Returns the type of the profile that is loaded for a user.
//
//  dwFlags   - Returns the profile flags
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError for more details
//
//  Comments:   if profile is not already loaded the function will return an error.
//              The caller needs to have access to HKLM part of the registry.
//              (exists by default)
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Flags that can be set in the dwFlags field
//

#define PT_TEMPORARY         0x00000001      // A profile has been allocated that will be deleted at logoff.
#define PT_ROAMING           0x00000002      // The loaded profile is a roaming profile.
#define PT_MANDATORY         0x00000004      // The loaded profile is mandatory.

USERENVAPI
BOOL
WINAPI
GetProfileType(
    OUT DWORD *dwFlags);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  DeleteProfile()
//
//  Deletes the profile and all other user related settings from the machine
//
//  lpSidString    - String form of the user sid.
//  lpProfilePath  - ProfilePath (if Null, lookup in the registry)
//  lpComputerName - Computer Name from which profile has to be deleted
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError for more details
//
//  Comments:   Deletes the profile directory, registry and appmgmt stuff
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
DeleteProfileA (
        IN LPCSTR lpSidString,
        IN LPCSTR lpProfilePath,
        IN LPCSTR lpComputerName);
USERENVAPI
BOOL
WINAPI
DeleteProfileW (
        IN LPCWSTR lpSidString,
        IN LPCWSTR lpProfilePath,
        IN LPCWSTR lpComputerName);
#ifdef UNICODE
#define DeleteProfile  DeleteProfileW
#else
#define DeleteProfile  DeleteProfileA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  CreateProfile()
//
//  Creating a user profile without loading it. 
//
//  pszUserSid     - String form of the user sid.
//  pszUserName    - Name of the user, used as the base name to create the 
//                   profile directory
//  pszProfilePath - Returned full profile path 
//  cchProfilePath - Size of pszProfilePath buffer
//
//  Return:     S_OK : Successfully created the profile
//              E_ACCESSDENIED : The caller does not have enough permission to
//                     create the profile. The caller has to be administrators
//                     in order for this API to succeed.
//              HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) : a profile is 
//                     already exists for the given user.
//              Others : Standard HRESULT error codes.
//                          
//  Comments:   
//=============================================================================

#if(WINVER >= 0x0600)

USERENVAPI
HRESULT
WINAPI
CreateProfile(LPCWSTR pszUserSid,
              LPCWSTR pszUserName,
              __out_ecount(cchProfilePath) LPWSTR pszProfilePath,
              DWORD cchProfilePath);

#endif /* WINVER >= 0x0600 */

//=============================================================================
//
// GetDefaultUserProfilesDirectory
//
// Returns the path to the root of the default user profile
//
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Documents and Settings\Default User
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
GetDefaultUserProfileDirectoryA(
    OUT LPSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetDefaultUserProfileDirectoryW(
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
#ifdef UNICODE
#define GetDefaultUserProfileDirectory  GetDefaultUserProfileDirectoryW
#else
#define GetDefaultUserProfileDirectory  GetDefaultUserProfileDirectoryA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetAllUsersProfilesDirectory
//
// Returns the path to the root of the All Users profile
//
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Documents and Settings\All Users
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
GetAllUsersProfileDirectoryA(
    OUT LPSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetAllUsersProfileDirectoryW(
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
#ifdef UNICODE
#define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryW
#else
#define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetUserProfileDirectory
//
// Returns the path to the root of the requested user's profile
//
// hToken         -  User's token returned from LogonUser()
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Documents and Settings\Joe
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GetUserProfileDirectoryA(
    IN HANDLE  hToken,
    OUT LPSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetUserProfileDirectoryW(
    IN HANDLE  hToken,
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
#ifdef UNICODE
#define GetUserProfileDirectory  GetUserProfileDirectoryW
#else
#define GetUserProfileDirectory  GetUserProfileDirectoryA
#endif // !UNICODE


//=============================================================================
//
// CreateEnvironmentBlock
//
// Returns the environment variables for the specified user.  This block
// can then be passed to CreateProcessAsUser().
//
// lpEnvironment  -  Receives a pointer to the new environment block
// hToken         -  User's token returned from LogonUser() (optional, can be NULL)
// bInherit       -  Inherit from the current process's environment block
//                   or start from a clean state.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If hToken is NULL, the returned environment block will contain
//           system variables only.
//
//           Call DestroyEnvironmentBlock to free the buffer when finished.
//
//           If this block is passed to CreateProcessAsUser, the
//           CREATE_UNICODE_ENVIRONMENT flag must also be set.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
CreateEnvironmentBlock(
    OUT LPVOID *lpEnvironment,
    IN HANDLE  hToken,
    IN BOOL    bInherit);


//=============================================================================
//
// DestroyEnvironmentBlock
//
// Frees environment variables created by CreateEnvironmentBlock
//
// lpEnvironment  -  A pointer to the environment block
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
DestroyEnvironmentBlock(
    IN LPVOID  lpEnvironment);


//=============================================================================
//
// ExpandEnvironmentStringsForUser
//
// Expands the source string using the environment block for the
// specified user.  If hToken is null, the system environment block
// will be used (no user environment variables).
//
// hToken         -  User's token returned from LogonUser() (optional, can be NULL)
// lpSrc          -  Pointer to the string with environment variables
// lpDest         -  Buffer that receives the expanded string
// dwSize         -  Size of lpDest in characters (max chars)
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If the user profile for hToken is not loaded, this api will fail.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
ExpandEnvironmentStringsForUserA(
    IN HANDLE hToken,
    IN LPCSTR lpSrc,
    OUT LPSTR lpDest,
    IN DWORD dwSize);
USERENVAPI
BOOL
WINAPI
ExpandEnvironmentStringsForUserW(
    IN HANDLE hToken,
    IN LPCWSTR lpSrc,
    OUT LPWSTR lpDest,
    IN DWORD dwSize);
#ifdef UNICODE
#define ExpandEnvironmentStringsForUser  ExpandEnvironmentStringsForUserW
#else
#define ExpandEnvironmentStringsForUser  ExpandEnvironmentStringsForUserA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RefreshPolicy()
//
// Causes group policy to be applied immediately on the client machine
//
// bMachine  -  Refresh machine or user policy
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
RefreshPolicy(
    IN BOOL bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RefreshPolicyEx()
//
// Causes group policy to be applied immediately on the client machine. 
//
// bMachine  -  Refresh machine or user policy
// dwOptions -  Option specifying the kind of refresh that needs to be done.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

#if(WINVER >= 0x0500)

#define RP_FORCE            1      // Refresh policies without any optimisations.
#define RP_SYNC             2      // Refresh Policy sync; the call does not return till the time policy processing is completed

USERENVAPI
BOOL
WINAPI
RefreshPolicyEx(
    IN BOOL bMachine, IN DWORD dwOptions);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// EnterCriticalPolicySection
//
// Pauses the background application of group policy to allow safe
// reading of the registry.  Applications that need to read multiple
// policy entries and ensure that the values are not changed while reading
// them should use this function.
//
// The maximum amount of time an application can hold a critical section
// is 10 minutes.  After 10 minutes, policy can be applied again.
//
// bMachine -  Pause machine or user policy
//
// Returns:  Handle if successful
//           NULL if not.  Call GetLastError() for more details
//
// Note 1:  The handle returned should be passed to LeaveCriticalPolicySection
// when finished.  Do not close this handle, LeaveCriticalPolicySection
// will do that.
//
// Note 2:  If both user and machine critical sections need to be acquired then
// they should be done in this order: first acquire user critical section and
// then acquire machine critical section.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HANDLE
WINAPI
EnterCriticalPolicySection(
    IN BOOL bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// LeaveCriticalPolicySection
//
// Resumes the background application of group policy.  See
// EnterCriticalPolicySection for more details.
//
// hSection - Handle returned from EnterCriticalPolicySection
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:  This function will close the handle.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
LeaveCriticalPolicySection(
    IN HANDLE hSection);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RegisterGPNotification
//
// Entry point for registering for Group Policy change notification.
//
// Parameters: hEvent     -   Event to be notified, by calling SetEvent(hEvent)
//             bMachine   -   If true, then register machine policy notification
//                                     else register user policy notification
//
// Returns:    True if successful
//             False if error occurs
//
// Notes:      Group Policy Notifications.  There are 2 ways an application can
//             be notify when Group Policy is finished being applied.
//
//             1) Using the RegisterGPNotifcation function and waiting for the
//                event to be signalled.
//
//             2) A WM_SETTINGCHANGE message is broadcast to all desktops.
//                wParam - 1 if machine policy was applied, 0 if user policy was applied.
//                lParam - Points to the string "Policy"
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
RegisterGPNotification(
    IN HANDLE hEvent,
    IN BOOL bMachine );

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// UnregisterGPNotification
//
// Removes registration for a Group Policy change notification.
//
// Parameters: hEvent    -   Event to be removed
//
// Returns:    True if successful
//             False if error occurs
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
UnregisterGPNotification(
    IN HANDLE hEvent );

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GPOptions flags
//
// These are the flags found in the GPOptions property of a DS object
//
// For a given DS object (Site, Domain, OU), the GPOptions property
// contains options that effect all the GPOs link to this SDOU.
//
// This is a DWORD type
//
//=============================================================================

#if(WINVER >= 0x0500)

#define GPC_BLOCK_POLICY        0x00000001  // Block all non-forced policy from above

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GPLink flags
//
// These are the flags found on the GPLink property of a DS object after
// the GPO path.
//
// For a given DS object (Site, Domain, OU), the GPLink property will
// be in this text format
//
// [LDAP://CN={E615A0E3-C4F1-11D1-A3A7-00AA00615092},CN=Policies,CN=System,DC=mydomain,DC=Microsoft,DC=Com;1]
//
// The GUID is the GPO name, and the number following the LDAP path are the options
// for that link from this DS object.  Note, there can be multiple GPOs
// each in their own square brackets in a prioritized list.
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Options for a GPO link
//

#define GPO_FLAG_DISABLE        0x00000001  // This GPO is disabled
#define GPO_FLAG_FORCE          0x00000002  // Don't override the settings in
                                            // this GPO with settings from
                                            // a GPO below it.
#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetGPOList
//
//
// Queries for the list of Group Policy Objects for the specified
// user or machine.  This function will return a link list
// of Group Policy Objects.  Call FreeGPOList to free the list.
//
// Note, most applications will not need to call this function.
// This will primarily be used by services acting on behalf of
// another user or machine.  The caller of this function will
// need to look in each GPO for their specific policy
//
// This function can be called in two different ways.  Either the hToken for
// a user or machine can be supplied and the correct name and domain
// controller name will be generated, or hToken is NULL and the caller
// must supply the name and the domain controller name.
//
// Calling this function with an hToken ensures the list of Group Policy
// Objects is correct for the user or machine since security access checking
// can be perfomed.  If hToken is not supplied, the security of the caller
// is used instead which means that list may or may not be 100% correct
// for the intended user / machine.  However, this is the fastest way
// to call this function.
//
// hToken           - User or machine token, if NULL, lpName and lpHostName must be supplied
// lpName           - User or machine name in DN format, if hToken is supplied, this must be NULL
// lpHostName       - Domain DN name or domain controller name. If hToken is supplied, this must be NULL
// lpComputerName   - Computer name to use to determine site location.  If NULL,
//                    the local computer is used as the reference. Format:  \\machinename
// dwFlags          - Flags field.  See flags definition below
// pGPOList         - Address of a pointer which receives the link list of GPOs
//
//
// Returns:  TRUE if successful
//           FALSE if not.  Use GetLastError() for more details.
//
// Examples:
//
// Here's how this function will typically be called for
// looking up the list of GPOs for a user:
//
//      LPGROUP_POLICY_OBJECT  pGPOList;
//
//      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &pGPOList))
//      {
//          // do processing here...
//          FreeGPOList (pGPOList);
//      }
//
//
// Here's how this function will typically be called for
// looking up the list of GPOs for a machine:
//
//      LPGROUP_POLICY_OBJECT  pGPOList;
//
//      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName,
//                      GPO_LIST_FLAG_MACHINE, &pGPOList))
//      {
//          // do processing here...
//          FreeGPOList (pGPOList);
//      }
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Each Group Policy Object is associated (linked) with a site, domain,
// organizational unit, or machine.
//

typedef enum _GPO_LINK {
    GPLinkUnknown = 0,                     // No link information available
    GPLinkMachine,                         // GPO linked to a machine (local or remote)
    GPLinkSite,                            // GPO linked to a site
    GPLinkDomain,                          // GPO linked to a domain
    GPLinkOrganizationalUnit               // GPO linked to a organizational unit
} GPO_LINK, *PGPO_LINK;

typedef struct _GROUP_POLICY_OBJECTA {
    DWORD       dwOptions;                  // See GPLink option flags above
    DWORD       dwVersion;                  // Revision number of the GPO
    LPSTR       lpDSPath;                   // Path to the Active Directory portion of the GPO
    LPSTR       lpFileSysPath;              // Path to the file system portion of the GPO
    LPSTR       lpDisplayName;              // Friendly display name
    CHAR        szGPOName[50];              // Unique name
    GPO_LINK    GPOLink;                    // Link information
    LPARAM      lParam;                     // Free space for the caller to store GPO specific information
    struct _GROUP_POLICY_OBJECTA * pNext;   // Next GPO in the list
    struct _GROUP_POLICY_OBJECTA * pPrev;   // Previous GPO in the list
    LPSTR       lpExtensions;               // Extensions that are relevant for this GPO
    LPARAM      lParam2;                    // Free space for the caller to store GPO specific information
    LPSTR       lpLink;                     // Path to the Active Directory site, domain, or organizational unit this GPO is linked to
                                            // If this is the local GPO, this points to the word "Local"
} GROUP_POLICY_OBJECTA, *PGROUP_POLICY_OBJECTA;
typedef struct _GROUP_POLICY_OBJECTW {
    DWORD       dwOptions;                  // See GPLink option flags above
    DWORD       dwVersion;                  // Revision number of the GPO
    LPWSTR      lpDSPath;                   // Path to the Active Directory portion of the GPO
    LPWSTR      lpFileSysPath;              // Path to the file system portion of the GPO
    LPWSTR      lpDisplayName;              // Friendly display name
    WCHAR       szGPOName[50];              // Unique name
    GPO_LINK    GPOLink;                    // Link information
    LPARAM      lParam;                     // Free space for the caller to store GPO specific information
    struct _GROUP_POLICY_OBJECTW * pNext;   // Next GPO in the list
    struct _GROUP_POLICY_OBJECTW * pPrev;   // Previous GPO in the list
    LPWSTR      lpExtensions;               // Extensions that are relevant for this GPO
    LPARAM      lParam2;                    // Free space for the caller to store GPO specific information
    LPWSTR      lpLink;                     // Path to the Active Directory site, domain, or organizational unit this GPO is linked to
                                            // If this is the local GPO, this points to the word "Local"
} GROUP_POLICY_OBJECTW, *PGROUP_POLICY_OBJECTW;
#ifdef UNICODE
typedef GROUP_POLICY_OBJECTW GROUP_POLICY_OBJECT;
typedef PGROUP_POLICY_OBJECTW PGROUP_POLICY_OBJECT;
#else
typedef GROUP_POLICY_OBJECTA GROUP_POLICY_OBJECT;
typedef PGROUP_POLICY_OBJECTA PGROUP_POLICY_OBJECT;
#endif // UNICODE


//
// dwFlags for GetGPOList()
//

#define GPO_LIST_FLAG_MACHINE        0x00000001  // Return machine policy information
#define GPO_LIST_FLAG_SITEONLY       0x00000002  // Return site policy information only
#define GPO_LIST_FLAG_NO_WMIFILTERS  0x00000004  // Ignore WMI filters when filtering GPO's
#define GPO_LIST_FLAG_NO_SECURITYFILTERS 0x00000008 // Ignore security filters

USERENVAPI
BOOL
WINAPI
GetGPOListA (
    IN HANDLE hToken,
    IN LPCSTR lpName,
    IN LPCSTR lpHostName,
    IN LPCSTR lpComputerName,
    IN DWORD dwFlags,
    OUT PGROUP_POLICY_OBJECTA *pGPOList);
USERENVAPI
BOOL
WINAPI
GetGPOListW (
    IN HANDLE hToken,
    IN LPCWSTR lpName,
    IN LPCWSTR lpHostName,
    IN LPCWSTR lpComputerName,
    IN DWORD dwFlags,
    OUT PGROUP_POLICY_OBJECTW *pGPOList);
#ifdef UNICODE
#define GetGPOList  GetGPOListW
#else
#define GetGPOList  GetGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// FreeGPOList
//
//
// Frees the linked list returned from GetGPOList
//
// pGPOList - Pointer to the linked list of GPOs
//
//
// Returns:  TRUE if successful
//           FALSE if not
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
FreeGPOListA (
    IN PGROUP_POLICY_OBJECTA pGPOList);
USERENVAPI
BOOL
WINAPI
FreeGPOListW (
    IN PGROUP_POLICY_OBJECTW pGPOList);
#ifdef UNICODE
#define FreeGPOList  FreeGPOListW
#else
#define FreeGPOList  FreeGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetAppliedGPOList
//
// Queries for the list of applied Group Policy Objects for the specified
// user or machine and specified client side extension. This function will return
// a linked list of Group Policy Objects.  Call FreeGPOList to free the list.
//
// dwFlags          - User or machine policy, if it is GPO_LIST_FLAG_MACHINE then
//                    return machine policy information
// pMachineName     - Name of remote computer in the form \\computername. If null
//                    then local computer is used.
// pSidUser         - Security id of user (relevant for user policy). If pMachineName is
//                    null and pSidUser is null then it means current logged on user.
//                    If pMachine is null and pSidUser is non-null then it means user
//                    represented by pSidUser on local machine. If pMachineName is non-null
//                    then and if dwFlags specifies user policy, then pSidUser must be
//                    non-null.
// pGuidExtension   - Guid of the specified extension
// ppGPOList        - Address of a pointer which receives the link list of GPOs
//
// The return value is a Win32 error code. ERROR_SUCCESS means the GetAppliedGPOList
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
GetAppliedGPOListA (
    IN DWORD dwFlags,
    IN LPCSTR pMachineName,
    IN PSID pSidUser,
    IN GUID *pGuidExtension,
    OUT PGROUP_POLICY_OBJECTA *ppGPOList);
USERENVAPI
DWORD
WINAPI
GetAppliedGPOListW (
    IN DWORD dwFlags,
    IN LPCWSTR pMachineName,
    IN PSID pSidUser,
    IN GUID *pGuidExtension,
    OUT PGROUP_POLICY_OBJECTW *ppGPOList);
#ifdef UNICODE
#define GetAppliedGPOList  GetAppliedGPOListW
#else
#define GetAppliedGPOList  GetAppliedGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side extension support
//
// Flags, data structures and function prototype
//
// To register your extension, create a subkey under this key
//
// Software\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
//
// The subkey needs to be a guid so that it is unique. The noname value of the subkey
// can be the friendly name of the extension. Then add these values:
//
//     DllName                      REG_EXPAND_SZ  Path to your DLL
//     ProcessGroupPolicy           REG_SZ       Function name (see PFNPROCESSGROUPPOLICY prototype). This
//                                                 is obsolete, it has been superseded by ProcessGroupPolicyEx.
//                                                 It's here for backward compatibility reasons only.
//     ProcessGroupPolicyEx         REG_SZ       Function name (see PFNPROCESSGROUPPOLICYEX prototype)
//     GenerateGroupPolicy          REG_SZ       Function name for Rsop (see PFNGENERATEGROUPPOLICY prototype)
//     NoMachinePolicy              REG_DWORD    True, if extension does not have to be called when
//                                                 machine policies are being processed.
//     NoUserPolicy                 REG_DWORD    True, if extension does not have to be called when
//                                                 user policies are being processed.
//     NoSlowLink                   REG_DWORD    True, if extension does not have to be called on a slow link
//     NoBackgroundPolicy           REG_DWORD    True, if extension does not have to be called 
//                                                 for background policy processing.
//     NoGPOListChanges             REG_DWORD    True, if extension does not have to be called when
//                                                 there are no changes between cached and current GPO lists.
//     PerUserLocalSettings         REG_DWORD    True, if user policies have to be cached on a per user and
//                                                 per machine basis.
//     RequiresSuccessfulRegistry   REG_DWORD    True, if extension should be called only if registry extension
//                                                 was successfully processed.
//     EnableAsynchronousProcessing REG_DWORD    True, if registry extension will complete its processing
//                                                 asynchronously.
//     NotifyLinkTransition         REG_DWORD    True, if extension should be called when a change in link
//                                                 speed is detected between previous policy application and
//                                                 current policy application.
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicy
// function completed successfully. If return value is ERROR_OVERRIDE_NOCHANGES then it
// means that the extension will be called the next time even if NoGPOListChanges is set
// and there are no changes to the GPO list. Any other return value indicates that the
// ProcessGroupPolicy or ProcessGroupPolicyEx function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

#define GP_DLLNAME                         TEXT("DllName")
#define GP_ENABLEASYNCHRONOUSPROCESSING    TEXT("EnableAsynchronousProcessing")
#define GP_MAXNOGPOLISTCHANGESINTERVAL     TEXT("MaxNoGPOListChangesInterval")
#define GP_NOBACKGROUNDPOLICY              TEXT("NoBackgroundPolicy")
#define GP_NOGPOLISTCHANGES                TEXT("NoGPOListChanges")
#define GP_NOMACHINEPOLICY                 TEXT("NoMachinePolicy")
#define GP_NOSLOWLINK                      TEXT("NoSlowLink")
#define GP_NOTIFYLINKTRANSITION            TEXT("NotifyLinkTransition")
#define GP_NOUSERPOLICY                    TEXT("NoUserPolicy")
#define GP_PERUSERLOCALSETTINGS            TEXT("PerUserLocalSettings")
#define GP_PROCESSGROUPPOLICY              TEXT("ProcessGroupPolicy")
#define GP_REQUIRESSUCCESSFULREGISTRY      TEXT("RequiresSuccessfulRegistry")

#define GPO_INFO_FLAG_MACHINE              0x00000001  // Apply machine policy rather than user policy
#define GPO_INFO_FLAG_BACKGROUND           0x00000010  // Background refresh of policy (ok to do slow stuff)
#define GPO_INFO_FLAG_SLOWLINK             0x00000020  // Policy is being applied across a slow link
#define GPO_INFO_FLAG_VERBOSE              0x00000040  // Verbose output to the eventlog
#define GPO_INFO_FLAG_NOCHANGES            0x00000080  // No changes were detected to the Group Policy Objects
#define GPO_INFO_FLAG_LINKTRANSITION       0x00000100  // A change in link speed was detected between previous policy
                                                       // application and current policy application
#define GPO_INFO_FLAG_LOGRSOP_TRANSITION   0x00000200  // A Change in Rsop Logging was detected between previous policy
                                                       // application and current policy application, (new intf only)
#define GPO_INFO_FLAG_FORCED_REFRESH       0x00000400  // Forced Refresh is being applied. redo policies.
#define GPO_INFO_FLAG_SAFEMODE_BOOT        0x00000800  // windows safe mode boot flag
#define GPO_INFO_FLAG_ASYNC_FOREGROUND     0x00001000  // Asynchronous foreground refresh of policy

typedef UINT_PTR ASYNCCOMPLETIONHANDLE;
typedef DWORD (*PFNSTATUSMESSAGECALLBACK)(BOOL bVerbose, LPWSTR lpMessage);

typedef DWORD(*PFNPROCESSGROUPPOLICY)(
    IN DWORD dwFlags,                              // GPO_INFO_FLAGS
    IN HANDLE hToken,                              // User or machine token
    IN HKEY hKeyRoot,                              // Root of registry
    IN PGROUP_POLICY_OBJECT  pDeletedGPOList,      // Linked list of deleted GPOs
    IN PGROUP_POLICY_OBJECT  pChangedGPOList,      // Linked list of changed GPOs
    IN ASYNCCOMPLETIONHANDLE pHandle,              // For asynchronous completion
    IN BOOL *pbAbort,                              // If true, then abort GPO processing
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback);  // Callback function for displaying status messages
                                                   // Note, this can be NULL

typedef DWORD(*PFNPROCESSGROUPPOLICYEX)(
    IN DWORD dwFlags,                              // GPO_INFO_FLAGS
    IN HANDLE hToken,                              // User or machine token
    IN HKEY hKeyRoot,                              // Root of registry
    IN PGROUP_POLICY_OBJECT  pDeletedGPOList,      // Linked list of deleted GPOs
    IN PGROUP_POLICY_OBJECT  pChangedGPOList,      // Linked list of changed GPOs
    IN ASYNCCOMPLETIONHANDLE pHandle,              // For asynchronous completion
    IN BOOL *pbAbort,                              // If true, then abort GPO processing
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback,   // Callback function for displaying status messages
                                                   // Note, this can be NULL
    IN IWbemServices *pWbemServices,               // Pointer to namespace to log diagnostic mode data
                                                   // Note, this will be NULL when Rsop logging is disabled
    OUT HRESULT      *pRsopStatus);                // RSOP Logging succeeded or not.

typedef PVOID PRSOPTOKEN;

typedef struct _RSOP_TARGET {
    WCHAR *     pwszAccountName;                   // Account name
    WCHAR *     pwszNewSOM;                        // New domain or OU location for account
    SAFEARRAY * psaSecurityGroups;                 // New security groups
    PRSOPTOKEN  pRsopToken;                        // Rsop token for use with Rsop security Api's
    PGROUP_POLICY_OBJECT pGPOList;                 // Linked list of GPOs
    IWbemServices *      pWbemServices;            // Pointer to namespace to log planning mode data
} RSOP_TARGET, *PRSOP_TARGET;

typedef DWORD(*PFNGENERATEGROUPPOLICY)(
    IN DWORD dwFlags,                              // GPO_INFO_FLAGS
    IN BOOL  *pbAbort,                             // If true, then abort GPO processing
    IN WCHAR *pwszSite,                            // Site the target computer is in
    IN PRSOP_TARGET pComputerTarget,               // Computer target info, can be null
    IN PRSOP_TARGET pUserTarget );                 // User target info, can be null

//
// GUID that identifies the registry extension
//

#define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side asynchronous extension processing
//
// extensionId    - Unique guid identifying the extension
// pAsyncHandle   - Asynchronous completion handle that was passed to extension in
//                  ProcessGroupPolicy call
// dwStatus       - Completion status of asynchronous processing
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicyCompleted
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

typedef GUID *REFGPEXTENSIONID;

USERENVAPI
DWORD
WINAPI
ProcessGroupPolicyCompleted(
    IN REFGPEXTENSIONID extensionId,
    IN ASYNCCOMPLETIONHANDLE pAsyncHandle,
    IN DWORD dwStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side asynchronous extension processing
//
// extensionId    - Unique guid identifying the extension
// pAsyncHandle   - Asynchronous completion handle that was passed to extension in
//                  ProcessGroupPolicy call
// dwStatus       - Completion status of asynchronous processing
// RsopStatus     - RSoP Logging status
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicyCompleted
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
ProcessGroupPolicyCompletedEx(
    IN REFGPEXTENSIONID extensionId,
    IN ASYNCCOMPLETIONHANDLE pAsyncHandle,
    IN DWORD dwStatus,
    IN HRESULT RsopStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Function:    RsopAccessCheckByType
//
// Description: Determines whether the security descriptor pointed to by pSecurityDescriptor
//                              grants the set of access rights specified in dwDesiredAccessMask
//                              to the client identified by the RSOPTOKEN pointed to by pRsopToken.
//
// pSecurityDescriptor  - Security Descriptor on the object
// pPrincipalSelfSid    - Principal Sid
// pRsopToken           - Pointer to a valid RSOPTOKEN against which access needs to be checked
// dwDesiredAccessMask  - Mask of requested generic and/or standard and or specific access rights
// pObjectTypeList      - Object Type List
// ObjectTypeListLength - Object Type List Length
// pGenericMapping      - Generic Mapping
// pPrivilegeSet        - privilege set
// pdwPrivilegeSetLength- privilege set length
// pdwGrantedAccessMask - On success, if pbAccessStatus is true, it contains
//                                         the mask of standard and specific rights granted.
//                                         If pbAccessStatus is false, it is set to 0.
//                                         On failure, it is not modified.
// pbAccessStatus       - On success, indicates wether the requested set
//                                    of access rights was granted.
//                                    On failure, it is not modified
//
// Returns S_OK on success or appropriate error code.
// For additional details, look at the documentation of AccessCheckByType
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HRESULT 
WINAPI
RsopAccessCheckByType(  
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN  PSID pPrincipalSelfSid,
    IN  PRSOPTOKEN pRsopToken,
    IN  DWORD dwDesiredAccessMask,
    IN  POBJECT_TYPE_LIST pObjectTypeList,
    IN  DWORD ObjectTypeListLength,
    IN  PGENERIC_MAPPING pGenericMapping,
    IN  PPRIVILEGE_SET pPrivilegeSet,
    IN  LPDWORD pdwPrivilegeSetLength,
    OUT LPDWORD pdwGrantedAccessMask,
    OUT LPBOOL pbAccessStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Function:    RsopFileAccessCheck
//
// Description: Determines whether the security descriptor on the file grants the set of file access 
//                              rights specified in dwDesiredAccessMask
//                              to the client identified by the RSOPTOKEN pointed to by pRsopToken.
//
// pszFileName          - Name of an existing filename
// pRsopToken           - Pointer to a valid RSOPTOKEN against which access needs to be checked
// dwDesiredAccessMask  - Mask of requested generic and/or standard and or specific access rights
// pdwGrantedAccessMask - On success, if pbAccessStatus is true, it contains
//                                         the mask of standard and specific rights granted.
//                                         If pbAccessStatus is false, it is set to 0.
//                                         On failure, it is not modified.
// pbAccessStatus       - On success, indicates wether the requested set
//                                    of access rights was granted.
//                                    On failure, it is not modified
//
// Returns S_OK on success or appropriate error code
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HRESULT 
WINAPI
RsopFileAccessCheck(
    IN  LPWSTR pszFileName,
    IN  PRSOPTOKEN pRsopToken,
    IN  DWORD dwDesiredAccessMask,
    OUT LPDWORD pdwGrantedAccessMask,
    OUT LPBOOL pbAccessStatus);

#endif /* WINVER >= 0x0500 */

typedef enum _SETTINGSTATUS
{
        RSOPUnspecified = 0,
        RSOPApplied,
        RSOPIgnored,
        RSOPFailed,
        RSOPSubsettingFailed
} SETTINGSTATUS;

//=============================================================================
//
//  POLICYSETTINGSTATUSINFO
//
//  Describes the instance of RSOP_PolicySettingStatus
//
//  szKey               - OPTIONAL, if NULL, the key is generated on the fly
//  szEventSource       - name of the source generation event log messages
//  szEventLogName      - name of the event log database where the messages are logged
//  dwEventID           - event log message ID
//  status              - status of the policy setting
//  timeLogged          - time at which the event log message was logged
//
//=============================================================================

typedef struct _POLICYSETTINGSTATUSINFO
{
        LPWSTR                  szKey;
        LPWSTR                  szEventSource;
        LPWSTR                  szEventLogName;
        DWORD                   dwEventID;
        DWORD                   dwErrorCode;
        SETTINGSTATUS   status;
        SYSTEMTIME              timeLogged;
} POLICYSETTINGSTATUSINFO, *LPPOLICYSETTINGSTATUSINFO;

//=============================================================================
//
//  RsopSetPolicySettingStatus
//
//  Creates an instance of RSOP_PolicySettingStatus and RSOP_PolicySettingLink
//  and links RSOP_PolicySettingStatus to RSOP_PolicySetting
//
//  dwFlags             - flags
//  pServices           - RSOP namespace
//  pSettingInstance    - instance of RSOP_PolicySetting or its children
//  nInfo               - number of PolicySettingStatusInfo
//  pStatus             - array of PolicySettingStatusInfo
//
//  Return:     S_OK if successful, HRESULT otherwise
//
//=============================================================================

USERENVAPI
HRESULT
WINAPI
RsopSetPolicySettingStatus( DWORD                       dwFlags,
                            IWbemServices*              pServices,
                            IWbemClassObject*           pSettingInstance,
                            DWORD                                       nInfo,
                            POLICYSETTINGSTATUSINFO*    pStatus );

//=============================================================================
//
//  RsopResetPolicySettingStatus
//
//  Unlinks RSOP_PolicySettingStatus from RSOP_PolicySetting,
//  deletes the instance of RSOP_PolicySettingStatus and RSOP_PolicySettingLink
//  and optionally deletes the instance of RSOP_PolicySetting
//
//  dwFlags             - flags
//  pServices           - RSOP namespace
//  pSettingInstance    - instance of RSOP_PolicySetting or its children
//
//  Return:     S_OK if successful, HRESULT otherwise
//
//=============================================================================

USERENVAPI
HRESULT
WINAPI
RsopResetPolicySettingStatus(   DWORD               dwFlags,
                                IWbemServices*      pServices,
                                IWbemClassObject*   pSettingInstance );

//=============================================================================
//
// Flags for RSoP WMI providers
//
//=============================================================================

// planning mode provider flags
#define FLAG_NO_GPO_FILTER      0x80000000  // GPOs are not filtered, implies FLAG_NO_CSE_INVOKE
#define FLAG_NO_CSE_INVOKE      0x40000000  // only GP processing done for planning mode
#define FLAG_ASSUME_SLOW_LINK   0x20000000  // planning mode RSoP assumes slow link
#define FLAG_LOOPBACK_MERGE     0x10000000  // planning mode RSoP assumes merge loop back
#define FLAG_LOOPBACK_REPLACE   0x08000000  // planning mode RSoP assumes replace loop back

#define FLAG_ASSUME_USER_WQLFILTER_TRUE   0x04000000  // planning mode RSoP assumes all comp filters to be true
#define FLAG_ASSUME_COMP_WQLFILTER_TRUE   0x02000000  // planning mode RSoP assumes all user filters to be true

#define FLAG_PLANNING_MODE                0x01000000  // flag that indicates that a given namespace was created
                                                      // for planning mode. This flag cannot be passed in but the
                                                      // relevant subnamespace will be marked with this flag

// diagnostic mode provider flags
#define FLAG_NO_USER                      0x00000001  // Don't get any user data
#define FLAG_NO_COMPUTER                  0x00000002  // Don't get any machine data
#define FLAG_FORCE_CREATENAMESPACE        0x00000004  
                   // Delete and recreate the namespace for this snapshot.

//=============================================================================
//
// Extended Errors returned by RSoP WMI Providers
//
//=============================================================================

// User accessing the rsop provider doesn't have access to user data.
#define RSOP_USER_ACCESS_DENIED         0x00000001  

// User accessing the rsop provider doesn't have access to computer data.
#define RSOP_COMPUTER_ACCESS_DENIED     0x00000002  

// This user is an interactive non admin user, the temp snapshot namespace already exists
// and the FLAG_FORCE_CREATENAMESPACE was not passed in
#define RSOP_TEMPNAMESPACE_EXISTS        0x00000004



#ifdef __cplusplus
}
#endif


#endif // _INC_USERENV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\uuids.h ===
//------------------------------------------------------------------------------
// File: uuids.h
//
// Desc: Contains the GUIDs for the MediaType type, subtype fields and format
//       types for standard media types, and also class ids for well-known
//       components.
//
// Copyright (c) 1992 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL

// -- Use this subtype if you don't have a use for a subtype for your type
// e436eb8e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_None
OUR_GUID_ENTRY(MEDIASUBTYPE_None,
0xe436eb8e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 73(s)76(v)61(a)69(i)-0000-0010-8000-00AA00389B71  'iavs' == MEDIATYPE_Interleaved
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,
0x73766169, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 656c6966-0000-0010-8000-00AA00389B71  'file' == MEDIATYPE_File
OUR_GUID_ENTRY(MEDIATYPE_File,
0x656c6966, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_ScriptCommand
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 670AEA80-3A82-11d0-B79B-00AA003767A7            MEDIATYPE_AUXLine21Data
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,
0x670aea80, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)



// FB77E152-53B2-499c-B46B-509FC33EDFD7             MEDIATYPE_DTVCCData
OUR_GUID_ENTRY(MEDIATYPE_DTVCCData,
0xfb77e152, 0x53b2, 0x499c, 0xb4, 0x6b, 0x50, 0x9f, 0xc3, 0x3e, 0xdf, 0xd7)

// B88B8A89-B049-4C80-ADCF-5898985E22C1             MEDIATYPE_MSTVCaption
OUR_GUID_ENTRY(MEDIATYPE_MSTVCaption,
0xB88B8A89, 0xB049, 0x4C80, 0xAD, 0xCF, 0x58, 0x98, 0x98, 0x5E, 0x22, 0xC1)

// F72A76E1-EB0A-11D0-ACE4-0000C0CC16BA            MEDIATYPE_VBI
OUR_GUID_ENTRY(MEDIATYPE_VBI,
0xf72a76e1, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 0482DEE3-7817-11cf-8a03-00aa006ecb65            MEDIATYPE_Timecode
OUR_GUID_ENTRY(MEDIATYPE_Timecode,
0x482dee3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
OUR_GUID_ENTRY(MEDIATYPE_LMRT,
0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 74726c6d-0000-0010-8000-00AA00389B71  'urls' == MEDIATYPE_URL_STREAM
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,
0x736c7275, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// -- sub types ---

// 4C504C43-0000-0010-8000-00AA00389B71  'CLPL' == MEDIASUBTYPE_CLPL
OUR_GUID_ENTRY(MEDIASUBTYPE_CLPL,
0x4C504C43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56595559-0000-0010-8000-00AA00389B71  'YUYV' == MEDIASUBTYPE_YUYV
OUR_GUID_ENTRY(MEDIASUBTYPE_YUYV,
0x56595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56555949-0000-0010-8000-00AA00389B71  'IYUV' == MEDIASUBTYPE_IYUV
OUR_GUID_ENTRY(MEDIASUBTYPE_IYUV,
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A4D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,
0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 4A4D5654-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_TVMJ
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,
0x4A4D5654, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 454B4157-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_WAKE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,
0x454B4157, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 43434643-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_CFCC
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,
0x43434643, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A49-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_IJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,
0x47504A49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6D756C50-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_Plum
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,
0x6D756C50, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 53435644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVCS
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,
0x53435644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// H.264 compressed video stream
// 34363248-0000-0010-8000-00AA00389B71  'H264' == MEDIASUBTYPE_H264
OUR_GUID_ENTRY(MEDIASUBTYPE_H264,
0x34363248, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 44535644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVSD
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,
0x44535644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// MIROVideo DV
// 4656444D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MDVF
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,
0x4656444D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


//
// RGB surfaces that contain per pixel alpha values.
//

// 297C55AF-E209-4cb3-B757-C76D6B9C88A8            MEDIASUBTYPE_ARGB1555
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555,
0x297c55af, 0xe209, 0x4cb3, 0xb7, 0x57, 0xc7, 0x6d, 0x6b, 0x9c, 0x88, 0xa8)

// 6E6415E6-5C24-425f-93CD-80102B3D1CCA            MEDIASUBTYPE_ARGB4444
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444,
0x6e6415e6, 0x5c24, 0x425f, 0x93, 0xcd, 0x80, 0x10, 0x2b, 0x3d, 0x1c, 0xca)

// 773c9ac0-3274-11d0-B724-00aa006c1A01            MEDIASUBTYPE_ARGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32,
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 )


// 2f8bb76d-b644-4550-acf3-d30caa65d5c5            MEDIASUBTYPE_A2R10G10B10
OUR_GUID_ENTRY(MEDIASUBTYPE_A2R10G10B10,
0x2f8bb76d, 0xb644, 0x4550, 0xac, 0xf3, 0xd3, 0x0c, 0xaa, 0x65, 0xd5, 0xc5)

// 576f7893-bdf6-48c4-875f-ae7b81834567            MEDIASUBTYPE_A2B10G10R10
OUR_GUID_ENTRY(MEDIASUBTYPE_A2B10G10R10,
0x576f7893, 0xbdf6, 0x48c4, 0x87, 0x5f, 0xae, 0x7b, 0x81, 0x83, 0x45, 0x67)


// 56555941-0000-0010-8000-00AA00389B71  'AYUV' == MEDIASUBTYPE_AYUV
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AYUV,
0x56555941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344941-0000-0010-8000-00AA00389B71  'AI44' == MEDIASUBTYPE_AI44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AI44,
0x34344941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344149-0000-0010-8000-00AA00389B71  'IA44' == MEDIASUBTYPE_IA44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_IA44,
0x34344149, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX7 D3D Render Target media subtypes.
//

// 32335237-0000-0010-8000-00AA00389B71  '7R32' == MEDIASUBTYPE_RGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX7_RT,
0x32335237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315237-0000-0010-8000-00AA00389B71  '7R16' == MEDIASUBTYPE_RGB16_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX7_RT,
0x36315237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384137-0000-0010-8000-00AA00389B71  '7A88' == MEDIASUBTYPE_ARGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX7_RT,
0x38384137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344137-0000-0010-8000-00AA00389B71  '7A44' == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX7_RT,
0x34344137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314137-0000-0010-8000-00AA00389B71  '7A15' == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX7_RT,
0x35314137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX9 D3D Render Target media subtypes.
//

// 32335239-0000-0010-8000-00AA00389B71  '9R32' == MEDIASUBTYPE_RGB32_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX9_RT,
0x32335239, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315239-0000-0010-8000-00AA00389B71  '9R16' == MEDIASUBTYPE_RGB16_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX9_RT,
0x36315239, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384139-0000-0010-8000-00AA00389B71  '9A88' == MEDIASUBTYPE_ARGB32_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX9_RT,
0x38384139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344139-0000-0010-8000-00AA00389B71  '9A44' == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX9_RT,
0x34344139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314139-0000-0010-8000-00AA00389B71  '9A15' == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX9_RT,
0x35314139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


#define MEDIASUBTYPE_HASALPHA(mt) ( ((mt).subtype == MEDIASUBTYPE_ARGB4444)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32)              || \
                                    ((mt).subtype == MEDIASUBTYPE_AYUV)                || \
                                    ((mt).subtype == MEDIASUBTYPE_AI44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_IA44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) )

#define MEDIASUBTYPE_HASALPHA7(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) )

#define MEDIASUBTYPE_D3D_DX7_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX7_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX7_RT))

#define MEDIASUBTYPE_HASALPHA9(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) )


#define MEDIASUBTYPE_D3D_DX9_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX9_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX9_RT))


//
// DX-VA uncompressed surface formats
//

// 32315659-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12
OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3231564E-0000-0010-8000-00AA00389B71  'NV12' ==  MEDIASUBTYPE_NV12
OUR_GUID_ENTRY(MEDIASUBTYPE_NV12,
0x3231564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3231564E-0000-0010-8000-00AA00389B71  'NV24' ==  MEDIASUBTYPE_NV24
OUR_GUID_ENTRY(MEDIASUBTYPE_NV24,
0x3432564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31434D49-0000-0010-8000-00AA00389B71  'IMC1' ==  MEDIASUBTYPE_IMC1
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC1,
0x31434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32434d49-0000-0010-8000-00AA00389B71  'IMC2' ==  MEDIASUBTYPE_IMC2
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC2,
0x32434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 33434d49-0000-0010-8000-00AA00389B71  'IMC3' ==  MEDIASUBTYPE_IMC3
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC3,
0x33434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34434d49-0000-0010-8000-00AA00389B71  'IMC4' ==  MEDIASUBTYPE_IMC4
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC4,
0x34434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30343353-0000-0010-8000-00AA00389B71  'S340' ==  MEDIASUBTYPE_S340
OUR_GUID_ENTRY(MEDIASUBTYPE_S340,
0x30343353, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32343353-0000-0010-8000-00AA00389B71  'S342' ==  MEDIASUBTYPE_S342
OUR_GUID_ENTRY(MEDIASUBTYPE_S342,
0x32343353, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000050-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_MPEG1AudioPayload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,
0x00000050, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {3DB80F90-9412-11d1-ADED-0000F8754B99}          MEDIASUBTYPE_Asf
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,
0x3db80f90, 0x9412, 0x11d1, 0xad, 0xed, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 617a7072-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Rpza
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,
0x617a7072, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20636d73-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Smc
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,
0x20636d73, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20656c72-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Rle
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,
0x20656c72, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6765706a-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Jpeg
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,
0x6765706a, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio_Obsolete
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000001-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_PCM
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 64(d)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsd' == MEDIASUBTYPE_dvsd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,
0x64737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 64(d)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvhd' == MEDIASUBTYPE_dvhd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,
0x64687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6c(l)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsl' == MEDIASUBTYPE_dvsl
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,
0x6c737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35(5)32(2)76(v)64(d)-0000-0010-8000-00AA00389B71  'dv25' ==  MEDIASUBTYPE_dv25
OUR_GUID_ENTRY(MEDIASUBTYPE_dv25,
0x35327664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30(0)35(5)76(v)64(d)-0000-0010-8000-00AA00389B71  'dv50' ==  MEDIASUBTYPE_dv50
OUR_GUID_ENTRY(MEDIASUBTYPE_dv50,
0x30357664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31(1)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvh1' ==  MEDIASUBTYPE_dvh1
OUR_GUID_ENTRY(MEDIASUBTYPE_dvh1,
0x31687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6E8D4A22-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_BytePair
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,
0x6e8d4a22, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A23-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_GOPPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,
0x6e8d4a23, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A24-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_VBIRawData
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,
0x6e8d4a24, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

//0AF414BC-4ED2-445e-9839-8F095568AB3C          MEDIASUBTYPE_708_608Data
OUR_GUID_ENTRY(MEDIASUBTYPE_708_608Data,
0xaf414bc, 0x4ed2, 0x445e, 0x98, 0x39, 0x8f, 0x9, 0x55, 0x68, 0xab, 0x3c)

// F52ADDAA-36F0-43F5-95EA-6D866484262A         MEDIASUBTYPE_DtvCcData
OUR_GUID_ENTRY(MEDIASUBTYPE_DtvCcData,
0xF52ADDAA, 0x36F0, 0x43F5, 0x95, 0xEA, 0x6D, 0x86, 0x64, 0x84, 0x26, 0x2A)

// F72A76E3-EB0A-11D0-ACE4-0000C0CC16BA         MEDIASUBTYPE_TELETEXT
OUR_GUID_ENTRY(MEDIASUBTYPE_TELETEXT,
0xf72a76e3, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 2791D576-8E7A-466F-9E90-5D3F3083738B        MEDIASUBTYPE_WSS
OUR_GUID_ENTRY(MEDIASUBTYPE_WSS,
0x2791D576, 0x8E7A, 0x466F, 0x9E, 0x90, 0x5D, 0x3F, 0x30, 0x83, 0x73, 0x8B)

// A1B3F620-9792-4d8d-81A4-86AF25772090        MEDIASUBTYPE_VPS
OUR_GUID_ENTRY(MEDIASUBTYPE_VPS,
0xa1b3f620, 0x9792, 0x4d8d, 0x81, 0xa4, 0x86, 0xaf, 0x25, 0x77, 0x20, 0x90)

// derived from WAVE_FORMAT_DRM
// 00000009-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DRM_Audio,
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_IEEE_FLOAT
// 00000003-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_IEEE_FLOAT,
0x00000003, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_DOLBY_AC3_SPDIF
// 00000092-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3_SPDIF,
0x00000092, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_RAW_SPORT
// 00000240-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_RAW_SPORT,
0x00000240, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from wave format tag 0x241, call it SPDIF_TAG_241h for now
// 00000241-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_SPDIF_TAG_241h,
0x00000241, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)



// DirectShow DSS definitions

// A0AF4F81-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,
0xa0af4f81, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// A0AF4F82-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,
0xa0af4f82, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A40-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,
0x5a9b6a40, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A41-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,
0x5a9b6a41, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// BF87B6E0-8C27-11d0-B3F0-00AA003761C5     Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,
0xBF87B6E0, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// BF87B6E1-8C27-11d0-B3F0-00AA003761C5     New Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder2,
0xBF87B6E1, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb8-524f-11ce-9f53-0020af0ba770           Filter Graph no thread
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,
0xe436ebb8, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// a3ecbc41-581a-4476-b693-a63340462d8b
OUR_GUID_ENTRY(CLSID_FilterGraphPrivateThread,
0xa3ecbc41, 0x581a, 0x4476, 0xb6, 0x93, 0xa6, 0x33, 0x40, 0x46, 0x2d, 0x8b)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)



// {F8388A40-D5BB-11d0-BE5A-0080C706568E}
OUR_GUID_ENTRY(CLSID_InfTee,
0xf8388a40, 0xd5bb, 0x11d0, 0xbe, 0x5a, 0x0, 0x80, 0xc7, 0x6, 0x56, 0x8e)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

OUR_GUID_ENTRY(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85           .MOV reader (old)
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D51BD5A0-7548-11cf-A520-0080C77EF58A           QT Splitter
OUR_GUID_ENTRY(CLSID_QuickTimeParser,
0xd51bd5a0, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// FDFE9681-74A3-11d0-AFA7-00AA00B67A42           QT Decoder
OUR_GUID_ENTRY(CLSID_QTDec,
0xfdfe9681, 0x74a3, 0x11d0, 0xaf, 0xa7, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// D3588AB0-0781-11ce-B03A-0020AF0BA770           AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a           Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio recorder
OUR_GUID_ENTRY(CLSID_AudioRecord,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {2CA8CA52-3C3F-11d2-B73D-00C04FB6BD3D}         IAMAudioInputMixer property page
OUR_GUID_ENTRY(CLSID_AudioInputMixerProperties,
0x2ca8ca52, 0x3c3f, 0x11d2, 0xb7, 0x3d, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}         AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}         AVI ICDraw* wrapper
OUR_GUID_ENTRY(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {D76E2820-1563-11cf-AC98-00AA004C0FA9}
OUR_GUID_ENTRY(CLSID_AVICo,
0xd76e2820, 0x1563, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// {8596E5F0-0DA5-11d0-BD21-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_FileWriter,
0x8596e5f0, 0xda5, 0x11d0, 0xbd, 0x21, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {E2510970-F137-11CE-8B67-00AA00A3F1A6}     AVI mux filter
OUR_GUID_ENTRY(CLSID_AviDest,
0xe2510970, 0xf137, 0x11ce, 0x8b, 0x67, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6)

// {C647B5C0-157C-11d0-BD23-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,
0xc647b5c0, 0x157c, 0x11d0, 0xbd, 0x23, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {0A9AE910-85C0-11d0-BD42-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,
0xa9ae910, 0x85c0, 0x11d0, 0xbd, 0x42, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {07b65360-c445-11ce-afde-00aa006c14f4}
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4)

// {187463A0-5BB7-11d3-ACBE-0080C75E246E}    WMSDK-based ASF reader
OUR_GUID_ENTRY(CLSID_WMAsfReader,
0x187463a0, 0x5bb7, 0x11d3, 0xac, 0xbe, 0x0, 0x80, 0xc7, 0x5e, 0x24, 0x6e)

// {7c23220e-55bb-11d3-8b16-00c04fb6bd3d}    WMSDK-based ASF writer
OUR_GUID_ENTRY(CLSID_WMAsfWriter,
0x7c23220e, 0x55bb, 0x11d3, 0x8b, 0x16, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

//  {afb6c280-2c41-11d3-8a60-0000f81e0e4a}
OUR_GUID_ENTRY(CLSID_MPEG2Demultiplexer,
0xafb6c280, 0x2c41, 0x11d3, 0x8a, 0x60, 0x00, 0x00, 0xf8, 0x1e, 0x0e, 0x4a)

// {3ae86b20-7be8-11d1-abe6-00a0c905f375}
OUR_GUID_ENTRY(CLSID_MMSPLITTER,
0x3ae86b20, 0x7be8, 0x11d1, 0xab, 0xe6, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// {2DB47AE5-CF39-43c2-B4D6-0CD8D90946F4}
OUR_GUID_ENTRY(CLSID_StreamBufferSink,
0x2db47ae5, 0xcf39, 0x43c2, 0xb4, 0xd6, 0xc, 0xd8, 0xd9, 0x9, 0x46, 0xf4)

// {C9F5FE02-F851-4eb5-99EE-AD602AF1E619}
OUR_GUID_ENTRY(CLSID_StreamBufferSource,
0xc9f5fe02, 0xf851, 0x4eb5, 0x99, 0xee, 0xad, 0x60, 0x2a, 0xf1, 0xe6, 0x19)

// {FA8A68B2-C864-4ba2-AD53-D3876A87494B}
OUR_GUID_ENTRY(CLSID_StreamBufferConfig,
0xfa8a68b2, 0xc864, 0x4ba2, 0xad, 0x53, 0xd3, 0x87, 0x6a, 0x87, 0x49, 0x4b)

// {6CFAD761-735D-4aa5-8AFC-AF91A7D61EBA}
OUR_GUID_ENTRY(CLSID_Mpeg2VideoStreamAnalyzer,
0x6cfad761, 0x735d, 0x4aa5, 0x8a, 0xfc, 0xaf, 0x91, 0xa7, 0xd6, 0x1e, 0xba)

// {CCAA63AC-1057-4778-AE92-1206AB9ACEE6}
OUR_GUID_ENTRY(CLSID_StreamBufferRecordingAttributes,
0xccaa63ac, 0x1057, 0x4778, 0xae, 0x92, 0x12, 0x6, 0xab, 0x9a, 0xce, 0xe6)

// {D682C4BA-A90A-42fe-B9E1-03109849C423}
OUR_GUID_ENTRY(CLSID_StreamBufferComposeRecording,
0xd682c4ba, 0xa90a, 0x42fe, 0xb9, 0xe1, 0x3, 0x10, 0x98, 0x49, 0xc4, 0x23)

// {B1B77C00-C3E4-11cf-AF79-00AA00B67A42}               DV video decoder
OUR_GUID_ENTRY(CLSID_DVVideoCodec,
0xb1b77c00, 0xc3e4, 0x11cf, 0xaf, 0x79, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {13AA3650-BB6F-11d0-AFB9-00AA00B67A42}               DV video encoder
OUR_GUID_ENTRY(CLSID_DVVideoEnc,
0x13aa3650, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4EB31670-9FC6-11cf-AF6E-00AA00B67A42}               DV splitter
OUR_GUID_ENTRY(CLSID_DVSplitter,
0x4eb31670, 0x9fc6, 0x11cf, 0xaf, 0x6e, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {129D7E40-C10D-11d0-AFB9-00AA00B67A42}               DV muxer
OUR_GUID_ENTRY(CLSID_DVMux,
0x129d7e40, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {060AF76C-68DD-11d0-8FC1-00C04FD9189D}
OUR_GUID_ENTRY(CLSID_SeekingPassThru,
0x60af76c, 0x68dd, 0x11d0, 0x8f, 0xc1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d)

// 6E8D4A20-310C-11d0-B79A-00AA003767A7                 Line21 (CC) Decoder
OUR_GUID_ENTRY(CLSID_Line21Decoder,
0x6e8d4a20, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// E4206432-01A1-4BEE-B3E1-3702C8EDC574                 Line21 (CC) Decoder v2
OUR_GUID_ENTRY(CLSID_Line21Decoder2,
0xe4206432, 0x01a1, 0x4bee, 0xb3, 0xe1, 0x37, 0x02, 0xc8, 0xed, 0xc5, 0x74)

// {CD8743A1-3736-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_OverlayMixer,
0xcd8743a1, 0x3736, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9800-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VBISurfaces,
0x814b9800, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {70BC06E0-5666-11d3-A184-00105AEF9F33}               WST Teletext Decoder
OUR_GUID_ENTRY(CLSID_WSTDecoder,
0x70bc06e0, 0x5666, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// {301056D0-6DFF-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MjpegDec,
0x301056d0, 0x6dff, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)

// {B80AB0A0-7416-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MJPGEnc,
0xb80ab0a0, 0x7416, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)



// pnp objects and categories
// 62BE5D10-60EB-11d0-BD3B-00A0C911CE86                 ICreateDevEnum
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,
0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 4315D437-5B8C-11d0-BD3B-00A0C911CE86
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,
0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 860BB310-5D01-11d0-BD3B-00A0C911CE86                 Video capture category
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 083863F1-70DE-11d0-BD40-00A0C911CE86                 Filter category
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 33D9A760-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A761-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A762-90C8-11d0-BD43-00A0C911CE86                 Audio source cateogry
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// E0F158E1-CB04-11d0-BD4E-00A0C911CE86                 Audio renderer category
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 4EFE2452-168A-11d1-BC76-00C04FB9453B                 Midi renderer category
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)

// CC7BFB41-F175-11d1-A392-00E0291F3959     External Renderers Category
OUR_GUID_ENTRY(CLSID_TransmitCategory,
0xcc7bfb41, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// CC7BFB46-F175-11d1-A392-00E0291F3959     Device Control Filters
OUR_GUID_ENTRY(CLSID_DeviceControlCategory,
0xcc7bfb46, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// DA4E3DA0-D07D-11d0-BD50-00A0C911CE86
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,
0xda4e3da0, 0xd07d, 0x11d0, 0xbd, 0x50, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 2721AE20-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,
0x2721AE20, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 7D22E920-5CA9-4787-8C2B-A6779BD11781     Encoder API encoder category
OUR_GUID_ENTRY(CLSID_MediaEncoderCategory,
0x7D22E920, 0x5CA9, 0x4787, 0x8C, 0x2B, 0xA6, 0x77, 0x9B, 0xD1, 0x17, 0x81)

// 236C9559-ADCE-4736-BF72-BAB34E392196     Encoder API multiplexer category
OUR_GUID_ENTRY(CLSID_MediaMultiplexerCategory,
0x236C9559, 0xADCE, 0x4736, 0xBF, 0x72, 0xBA, 0xB3, 0x4E, 0x39, 0x21, 0x96)

// CDA42200-BD88-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_FilterMapper2,
0xcda42200, 0xbd88, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)


// 1e651cc0-b199-11d0-8212-00c04fc32c45
OUR_GUID_ENTRY(CLSID_MemoryAllocator,
0x1e651cc0, 0xb199, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45)

// CDBD8D00-C193-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,
0xcdbd8d00, 0xc193, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// FCC152B7-F372-11d0-8E00-00C04FD7C08B
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,
0xFCC152B7, 0xF372, 0x11d0, 0x8E, 0x00, 0x00, 0xC0, 0x4F, 0xD7, 0xC0, 0x8B)

// 9B8C4620-2C1A-11d0-8493-00A02438AD48
OUR_GUID_ENTRY(CLSID_DVDNavigator,
0x9b8c4620, 0x2c1a, 0x11d0, 0x84, 0x93, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48)

// f963c5cf-a659-4a93-9638-caf3cd277d13
OUR_GUID_ENTRY(CLSID_DVDState,
0xf963c5cf, 0xa659, 0x4a93, 0x96, 0x38, 0xca, 0xf3, 0xcd, 0x27, 0x7d, 0x13)

// CC58E280-8AA1-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(CLSID_SmartTee,
0xcc58e280, 0x8aa1, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// FB056BA0-2502-45B9-8E86-2B40DE84AD29
OUR_GUID_ENTRY(CLSID_DtvCcFilter,
0xfb056ba0, 0x2502, 0x45b9, 0x8e, 0x86, 0x2b, 0x40, 0xde, 0x84, 0xad, 0x29)

// 2F7EE4B6-6FF5-4EB4-B24A-2BFC41117171
OUR_GUID_ENTRY(CLSID_MSTVCaptionFilter,
0x2F7EE4B6, 0x6FF5, 0x4EB4, 0xB2, 0x4A, 0x2B, 0xFC, 0x41, 0x11, 0x71, 0x71)

// -- format types ---

// 0F6417D6-C318-11D0-A43F-00A0C9223196        FORMAT_None
OUR_GUID_ENTRY(FORMAT_None,
0x0F6417D6, 0xc318, 0x11d0, 0xa4, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96)

// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA        FORMAT_VideoInfo2
OUR_GUID_ENTRY(FORMAT_VideoInfo2,
0xf72a76A0, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f84-c356-11ce-bf01-00aa0055595a        FORMAT_DvInfo, DVINFO
OUR_GUID_ENTRY(FORMAT_DvInfo,
0x05589f84, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// C7ECF04D-4582-4869-9ABB-BFB523B62EDF       FORMAT_525WSS    
OUR_GUID_ENTRY(FORMAT_525WSS,
0xc7ecf04d, 0x4582, 0x4869, 0x9a, 0xbb, 0xbf, 0xb5, 0x23, 0xb6, 0x2e, 0xdf)


// -- Video related GUIDs ---

// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// {CE292861-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_VPObject,
0xce292861, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {CE292862-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPObject,
0xce292862, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {25DF12C1-3DE0-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPControl,
0x25df12c1, 0x3de0, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9801-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VPVBIObject,
0x814b9801, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {814B9802-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIObject,
0x814b9802, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {BC29A660-30E3-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPConfig,
0xbc29a660, 0x30e3, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {C76794A1-D6C5-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify,
0xc76794a1, 0xd6c5, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47183-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify2,
0xebf47183, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// {EC529B00-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIConfig,
0xec529b00, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {EC529B01-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBINotify,
0xec529b01, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {593CDDE1-0759-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig,
0x593cdde1, 0x759, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47182-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig2,
0xebf47182, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// This is a real pain in the neck. The OLE GUIDs are separated out into a
// different file from the main header files. The header files can then be
// included multiple times and are protected with the following statements,
//
//      #ifndef __SOMETHING_DEFINED__
//      #define __SOMETHING_DEFINED__
//          all the header contents
//      #endif // __SOMETHING_DEFINED__
//
// When the actual GUIDs are to be defined (using initguid) the GUID header
// file can then be included to really define them just once. Unfortunately
// DirectDraw has the GUIDs defined in the main header file. So if the base
// classes bring in ddraw.h to get at the DirectDraw structures and so on
// nobody would then be able to really include ddraw.h to allocate the GUID
// memory structures because of the aforementioned header file protection
// Therefore the DirectDraw GUIDs are defined and allocated for real here

#ifndef __DDRAW_INCLUDED__
OUR_GUID_ENTRY(CLSID_DirectDraw,            0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,     0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,             0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,            0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,      0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,     0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,     0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawSurface4,     0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B)
OUR_GUID_ENTRY(IID_IDirectDrawSurface7,     0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,      0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,      0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl, 0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,    0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif

#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,        0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel, 0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// {101193C0-0BFE-11d0-AF91-00AA00B67A42}           DV decoder property
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,
0x101193c0, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4150F050-BB6F-11d0-AFB9-00AA00B67A42}           DV encoder property
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,
0x4150f050, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4DB880E0-C10D-11d0-AFB9-00AA00B67A42}           DV Muxer property
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,
0x4db880e0, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)


// -- Direct Sound Audio related GUID ---

// 546F4260-D53E-11cf-B3F0-00AA003761C5
OUR_GUID_ENTRY(IID_IAMDirectSound,
0x546f4260, 0xd53e, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- MPEG audio decoder properties

// {b45dd570-3c77-11d1-abe1-00a0c905f375}
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,
0xb45dd570, 0x3c77, 0x11d1, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// --- Line21 Decoder interface GUID ---

// 6E8D4A21-310C-11d0-B79A-00AA003767A7            IID_IAMLine21Decoder
OUR_GUID_ENTRY(IID_IAMLine21Decoder,
0x6e8d4a21, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// --- WST Decoder interface GUID ---

// C056DE21-75C2-11d3-A184-00105AEF9F33            IID_IAMWstDecoder
OUR_GUID_ENTRY(IID_IAMWstDecoder,
0xc056de21, 0x75c2, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// --- WST Decoder Property Page ---

// 04E27F80-91E4-11d3-A184-00105AEF9F33            WST Decoder Property Page
OUR_GUID_ENTRY(CLSID_WstDecoderPropertyPage,
0x4e27f80, 0x91e4, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)


// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEC-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO,
0x482ddec, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// --  External audio related GUIDs ---

// -- major types, Analog Audio

// 0482DEE1-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,
0x482dee1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

//
// DirectShow's include file based on ksmedia.h from WDM DDK
//
#include "ksuuids.h"


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// for IKsPropertySet

// 9B00F101-1567-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(AMPROPSETID_Pin,
0x9b00f101, 0x1567, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// fb6c4281-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,
0xfb6c4281, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4282-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,
0xfb6c4282, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4283-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,
0xfb6c4283, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4284-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,
0xfb6c4284, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4285-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,
0xfb6c4285, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4286-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,
0xfb6c4286, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4287-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,
0xfb6c4287, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4288-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,
0xfb6c4288, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4289-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CC,
0xfb6c4289, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428a-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,
0xfb6c428a, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428b-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,
0xfb6c428b, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428c-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,
0xfb6c428c, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)


// the following special GUIDS are used by ICaptureGraphBuilder::FindInterface

// {AC798BE0-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,
0xac798be0, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// {AC798BE1-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,
0xac798be1, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -------------------------------------------------------------------------
// KSProxy GUIDS
// -------------------------------------------------------------------------

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage,
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96464-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,
0x71f96464, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96465-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,
0x71f96465, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96466-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,
0x71f96466, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96467-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,
0x71f96467, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {37E92A92-D9AA-11d2-BF84-8EF2B1555AED} Audio Renderer Advanced Property Page
OUR_GUID_ENTRY(CLSID_AudioRendererAdvancedProperties,
0x37e92a92, 0xd9aa, 0x11d2, 0xbf, 0x84, 0x8e, 0xf2, 0xb1, 0x55, 0x5a, 0xed)


// -------------------------------------------------------------------------
// VMR GUIDS
// -------------------------------------------------------------------------

// {B87BEB7B-8D29-423f-AE4D-6582C10175AC}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer,
0xB87BEB7B, 0x8D29, 0x423f, 0xAE, 0x4D, 0x65, 0x82, 0xC1, 0x01, 0x75, 0xAC)

// {6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50}
OUR_GUID_ENTRY(CLSID_VideoRendererDefault,
0x6BC1CFFA, 0x8FC1, 0x4261, 0xAC, 0x22, 0xCF, 0xB4, 0xCC, 0x38, 0xDB, 0x50)

// {99d54f63-1a69-41ae-aa4d-c976eb3f0713}
OUR_GUID_ENTRY(CLSID_AllocPresenter,
0x99d54f63, 0x1a69, 0x41ae, 0xaa, 0x4d, 0xc9, 0x76, 0xeb, 0x3f, 0x07, 0x13)

// {4444ac9e-242e-471b-a3c7-45dcd46352bc}
OUR_GUID_ENTRY(CLSID_AllocPresenterDDXclMode,
0x4444ac9e, 0x242e, 0x471b, 0xa3, 0xc7, 0x45, 0xdc, 0xd4, 0x63, 0x52, 0xbc)

// {6f26a6cd-967b-47fd-874a-7aed2c9d25a2}
OUR_GUID_ENTRY(CLSID_VideoPortManager,
0x6f26a6cd, 0x967b, 0x47fd, 0x87, 0x4a, 0x7a, 0xed, 0x2c, 0x9d, 0x25, 0xa2)


// -------------------------------------------------------------------------
// VMR GUIDS for DX9
// -------------------------------------------------------------------------

// {51b4abf3-748f-4e3b-a276-c828330e926a}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer9,
0x51b4abf3, 0x748f, 0x4e3b, 0xa2, 0x76, 0xc8, 0x28, 0x33, 0x0e, 0x92, 0x6a)


// -------------------------------------------------------------------------
// EVR GUIDS
// -------------------------------------------------------------------------

// {FA10746C-9B63-4b6c-BC49-FC300EA5F256}
OUR_GUID_ENTRY(CLSID_EnhancedVideoRenderer,
0xfa10746c, 0x9b63, 0x4b6c, 0xbc, 0x49, 0xfc, 0x30, 0xe, 0xa5, 0xf2, 0x56)

// {E474E05A-AB65-4f6a-827C-218B1BAAF31F}
OUR_GUID_ENTRY(CLSID_MFVideoMixer9,
0xE474E05A, 0xAB65, 0x4f6a, 0x82, 0x7C, 0x21, 0x8B, 0x1B, 0xAA, 0xF3, 0x1F)

// {98455561-5136-4d28-AB08-4CEE40EA2781}
OUR_GUID_ENTRY(CLSID_MFVideoPresenter9, 
0x98455561, 0x5136, 0x4d28, 0xab, 0x8, 0x4c, 0xee, 0x40, 0xea, 0x27, 0x81)

// {a0a7a57b-59b2-4919-a694-add0a526c373}
OUR_GUID_ENTRY(CLSID_EVRTearlessWindowPresenter9,
0xa0a7a57b, 0x59b2, 0x4919, 0xa6, 0x94, 0xad, 0xd0, 0xa5, 0x26, 0xc3, 0x73)

// -------------------------------------------------------------------------
// BDA Network Provider GUIDS
// -------------------------------------------------------------------------

// This is the GUID for the generic NP which would replace ATSC, DVBT, DVBS
// and DVBC NP. All the other GUIDs are still kept for backward compatibility
// {B2F3A67C-29DA-4c78-8831-091ED509A475}
OUR_GUID_ENTRY(CLSID_NetworkProvider,
0xb2f3a67c, 0x29da, 0x4c78, 0x88, 0x31, 0x9, 0x1e, 0xd5, 0x9, 0xa4, 0x75)

// {0DAD2FDD-5FD7-11D3-8F50-00C04F7971E2}
OUR_GUID_ENTRY(CLSID_ATSCNetworkProvider,
0x0dad2fdd, 0x5fd7, 0x11d3, 0x8f, 0x50, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2)

// {E3444D16-5AC4-4386-88DF-13FD230E1DDA}
OUR_GUID_ENTRY(CLSID_ATSCNetworkPropertyPage,
0xe3444d16, 0x5ac4, 0x4386, 0x88, 0xdf, 0x13, 0xfd, 0x23, 0x0e, 0x1d, 0xda)

// {FA4B375A-45B4-4d45-8440-263957B11623}
OUR_GUID_ENTRY(CLSID_DVBSNetworkProvider,
0xfa4b375a, 0x45b4, 0x4d45, 0x84, 0x40, 0x26, 0x39, 0x57, 0xb1, 0x16, 0x23)

// {216C62DF-6D7F-4e9a-8571-05F14EDB766A}
OUR_GUID_ENTRY(CLSID_DVBTNetworkProvider,
0x216c62df, 0x6d7f, 0x4e9a, 0x85, 0x71, 0x5, 0xf1, 0x4e, 0xdb, 0x76, 0x6a)

// {DC0C0FE7-0485-4266-B93F-68FBF80ED834}
OUR_GUID_ENTRY(CLSID_DVBCNetworkProvider,
0xdc0c0fe7, 0x485, 0x4266, 0xb9, 0x3f, 0x68, 0xfb, 0xf8, 0xe, 0xd8, 0x34)

// -------------------------------------------------------------------------
// attribute GUIDs
// -------------------------------------------------------------------------

// {EB7836CA-14FF-4919-BCE7-3AF12319E50C}
OUR_GUID_ENTRY(DSATTRIB_UDCRTag,
0xEB7836CA, 0x14FF, 0x4919, 0xbc, 0xe7, 0x3a, 0xf1, 0x23, 0x19, 0xe5, 0x0c)

// {2F5BAE02-7B8F-4f60-82D6-E4EA2F1F4C99}
OUR_GUID_ENTRY(DSATTRIB_PicSampleSeq,
0x2f5bae02, 0x7b8f, 0x4f60, 0x82, 0xd6, 0xe4, 0xea, 0x2f, 0x1f, 0x4c, 0x99)

// -------------------------------------------------------------------------
// TVE Receiver filter guids
// -------------------------------------------------------------------------

// The CLSID used by the TVE Receiver filter
// {05500280-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_DShowTVEFilter,
0x05500280, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500281-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterTuneProperties,
0x05500281, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)


// {05500282-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterCCProperties,
0x05500282, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500283-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterStatsProperties,
0x05500283, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// -------------------------------------------------------------------------
// Defined ENCAPI parameter GUIDs
// -------------------------------------------------------------------------

// The CLSID for the original IVideoEncoder proxy plug-in
// {B43C4EEC-8C32-4791-9102-508ADA5EE8E7}
OUR_GUID_ENTRY(CLSID_IVideoEncoderProxy,
0xb43c4eec, 0x8c32, 0x4791, 0x91, 0x2, 0x50, 0x8a, 0xda, 0x5e, 0xe8, 0xe7)

// The CLSID for the ICodecAPI proxy plug-in
// {7ff0997a-1999-4286-a73c-622b8814e7eb}
OUR_GUID_ENTRY(CLSID_ICodecAPIProxy,
0x7ff0997a, 0x1999, 0x4286, 0xa7, 0x3c, 0x62, 0x2b, 0x88, 0x14, 0xe7, 0xeb )

// The CLSID for the combination ICodecAPI/IVideoEncoder proxy plug-in
// {b05dabd9-56e5-4fdc-afa4-8a47e91f1c9c}
OUR_GUID_ENTRY(CLSID_IVideoEncoderCodecAPIProxy,
0xb05dabd9, 0x56e5, 0x4fdc, 0xaf, 0xa4, 0x8a, 0x47, 0xe9, 0x1f, 0x1c, 0x9c )

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

// {49CC4C43-CA83-4ad4-A9AF-F3696AF666DF}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE,
0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf)

// {703F16A9-3D48-44a1-B077-018DFF915D19}
OUR_GUID_ENTRY(ENCAPIPARAM_PEAK_BITRATE,
0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19)

// {EE5FB25C-C713-40d1-9D58-C0D7241E250F}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE_MODE,
0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf)

// {0C0171DB-FEFC-4af7-9991-A5657C191CD1}
OUR_GUID_ENTRY(ENCAPIPARAM_SAP_MODE,
0xc0171db, 0xfefc, 0x4af7, 0x99, 0x91, 0xa5, 0x65, 0x7c, 0x19, 0x1c, 0xd1)

// for kernel control

// {62b12acf-f6b0-47d9-9456-96f22c4e0b9d}
OUR_GUID_ENTRY(CODECAPI_CHANGELISTS,
0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d)

// {7112e8e1-3d03-47ef-8e60-03f1cf537301 }
OUR_GUID_ENTRY(CODECAPI_VIDEO_ENCODER,
0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01)

// {b9d19a3e-f897-429c-bc46-8138b7272b2d }
OUR_GUID_ENTRY(CODECAPI_AUDIO_ENCODER,
0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d)

// {6c5e6a7c-acf8-4f55-a999-1a628109051b }
OUR_GUID_ENTRY(CODECAPI_SETALLDEFAULTS,
0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b)

// {6a577e92-83e1-4113-adc2-4fcec32f83a1 }
OUR_GUID_ENTRY(CODECAPI_ALLSETTINGS,
0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1)

// {0581af97-7693-4dbd-9dca-3f9ebd6585a1 }
OUR_GUID_ENTRY(CODECAPI_SUPPORTSEVENTS,
0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1 )

// {1cb14e83-7d72-4657-83fd-47a2c5b9d13d }
OUR_GUID_ENTRY(CODECAPI_CURRENTCHANGELIST,
0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d )

// When generating strmiids.lib, include codecapi definitions
#ifdef INITGUID
#define UUID_GEN
#include <codecapi.h>
#endif

#endif // __ENCODER_API_GUIDS__

// -----------------------------------------------
// Used for decoders that exposing ICodecAPI
// -----------------------------------------------
OUR_GUID_ENTRY(CODECAPI_AVDecMmcssClass,
0xe0ad4828, 0xdf66, 0x4893, 0x9f, 0x33, 0x78, 0x8a, 0xa4, 0xec, 0x40, 0x82)

#undef OUR_GUID_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usbioctl.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        USBIOCTL.H

Abstract:

   This file defines both kernel and user mode IOCTL
   codes supported by the USB core stack.

   These APIs are the APIS supported by th USB hub driver and the USB bus
   driver AKA USBPORT.

   Typically only user mode applications (usbui) or the hub driver include this
   file, USB drivers should use usbdrivr.h usb bus drivers should include
   usbkern.h

Environment:

    Kernel & user mode

Revision History:

    09-29-95 : created
    01-06-97 : added user mode hub ioctls
    10-31-99 : cleanup and document, jdunn
    1-25-03  : more cleanup and documentation
    2-10-04  : header versioning

--*/

#ifndef   __USBIOCTL_H__
#define   __USBIOCTL_H__

#include "usb200.h"

#ifndef FAR
#define FAR
#endif

#include "usbiodef.h"

/*
    IOCTL definitions
*/

/*
   USB kernel Mode IOCTLS
*/

/*
Routine Description:
Define the standard USB 'URB' IOCTL

IOCTL_INTERNAL_USB_SUBMIT_URB

This IOCTL is used by client drivers to submit URB (USB Request Blocks)

Parameters.Others.Argument1 = pointer to URB

*/

#define IOCTL_INTERNAL_USB_SUBMIT_URB  \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_SUBMIT_URB,  \
                                            METHOD_NEITHER,  \
                                            FILE_ANY_ACCESS)

/* IOCTL_INTERNAL_USB_RESET_PORT

    This IOCTL is used by kernel mode drivers to reset their
    upstream port.

    After a successful reset the device is re-configured to the
    same configuration it was in before the reset.  All pipe
    handles, configuration handles and interface handles remain
    valid.

*/

#define IOCTL_INTERNAL_USB_RESET_PORT  \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_RESET_PORT, \
                                            METHOD_NEITHER,  \
                                            FILE_ANY_ACCESS)

/*  IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO

Routine Description:
This function is used to by hubs to get the top of the physical USB stack.
All IRPs passed to a hub PDO are either serviced by the hub or forwarded
directly to the top of the bus driver stack i.e. the root hub PDO.  A filter
driver interested only in bus traffic (AKA Urbs) can see such traffic by
attaching to the top of the root hub PDO, see section 9.

Parameters:
ioStackLocation->Parameters.Others.Argument1
>>RootHubPhysicalDeviceObject
This parameter contains a pointer that is filled in with the root hub PDO.
This is the actual PDO created by the USBPORT driver for the root hub.

ioStackLocation->Parameters.Others.Argument2
>> HcdTopOfStack
This parameter contains a pointer that is filled in with the top of the bus
driver stack is the device object returned when the hub driver attached to
top of the device stack associated with the root hub PDO.
*/

#define IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO  \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_GET_ROOTHUB_PDO, \
                                            METHOD_NEITHER,  \
                                            FILE_ANY_ACCESS)



#define  USBD_PORT_ENABLED      0x00000001
#define  USBD_PORT_CONNECTED    0x00000002

/* IOCTL_INTERNAL_USB_GET_PORT_STATUS

Routine Description:
This function returns the current 'live' status of the port.  It can be used
by client drivers to determine the current state of their device because
certain hardware errors on the bus can result in a device port being disabled
.  The hub driver must communicate with the hub to get this information, if
it cannot for some reason a failure status is returned.

This API will fail if called at raised IRQL.

IRQL: Passive

Parameters:
ioStackLocation->Parameters.Others.Argument1
A pointer to a ULONG that is filled in with the port status bits defined below:

*/

#define IOCTL_INTERNAL_USB_GET_PORT_STATUS  \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_GET_PORT_STATUS, \
                                            METHOD_NEITHER,  \
                                            FILE_ANY_ACCESS)

/*
    IOCTL_INTERNAL_USB_ENABLE_PORT is obsolete, drivers should use
    IOCTL_INTERNAL_USB_RESET_PORT
*/

#define IOCTL_INTERNAL_USB_ENABLE_PORT      \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_ENABLE_PORT, \
                                            METHOD_NEITHER,  \
                                            FILE_ANY_ACCESS)


/* IOCTL_INTERNAL_USB_GET_HUB_COUNT

Routine Description:
This function is used to count the number of hubs in the stack.  It is used
to enforce the electrical limitation of no more that 5 hubs plus the root
being chained together.

Parameters:
ioStackLocation->Parameters.Others.Argument1
>>Count
This parameter contains a pointer that is filled in with the current count of
hubs in the stack. Each instance of the hub driver that receives the IRP
increments the counter and passes the irp on to its' PDO.  When the Irp
reaches the hub that is the root the IRP is completed.  This will result in
the count value being equal to the number of hubs (including the root).


*/

#define IOCTL_INTERNAL_USB_GET_HUB_COUNT    \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_GET_HUB_COUNT, \
                                            METHOD_NEITHER,  \
                                            FILE_ANY_ACCESS)

/* IOCTL_INTERNAL_USB_CYCLE_PORT

    This IOCTL will simulate a plug/unplug on the drivers upstream
    port.  The device will be removed and re-added by PnP.
*/

#define IOCTL_INTERNAL_USB_CYCLE_PORT  \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_CYCLE_PORT, \
                                            METHOD_NEITHER,  \
                                            FILE_ANY_ACCESS)

/* IOCTL_INTERNAL_USB_GET_HUB_NAME

Routine Description:
This API returns the UNICODE symbolic name for the PDO if the PDO is for a
usbhub, otherwise a NULL string is returned.  The symbolic name can be used
to retrieve additional information about the hub through user mode ioctl apis
and WMI calls.

Parameters:
ioStackLocation->Parameters.DeviceIoControl.OutputBufferLength
Length of buffer passed bytes.

Irp->AssociatedIrp.SystemBuffer
A pointer to a structure (USB_HUB_NAME) to receive the symbolic name.

 USB_BUS_NOTIFICATION.
ActualLength - The structure size in bytes necessary to hold the NULL
   terminated symbolic link name.  This includes the entire structure, not
   just the name.

  HubName - The UNICODE NULL terminated symbolic link name of the external
hub attached to the port.  If there is no external hub attached to the port a
single NULL is returned.

*/

#define IOCTL_INTERNAL_USB_GET_HUB_NAME  \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_GET_HUB_NAME,  \
                                            METHOD_BUFFERED,  \
                                            FILE_ANY_ACCESS)

/*
    IOCTL_INTERNAL_USB_GET_BUS_INFO is obsolete -- it has been replaced by the
    USB_BUSIFFN_QUERY_BUS_INFORMATION service available thru the usb stack bus
    interface. Drivers should use the bus interface function instead
*/
#define IOCTL_INTERNAL_USB_GET_BUS_INFO         CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_GET_BUS_INFO,  \
                                                    METHOD_BUFFERED,  \
                                                    FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME  CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_GET_CONTROLLER_NAME,  \
                                                    METHOD_BUFFERED,  \
                                                    FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_BUSGUID_INFO     CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_GET_BUSGUID_INFO,  \
                                                    METHOD_BUFFERED,  \
                                                    FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO  CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_GET_PARENT_HUB_INFO,  \
                                                    METHOD_BUFFERED,  \
                                                    FILE_ANY_ACCESS)

/*
   USB kernel Mode IOCTLS defined for windows XP and later
*/

#if (_WIN32_WINNT >= 0x0501)

/* IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION

This ioctl registers a device to receive notification when a specific
timeout has expired and it should now be suspended in order to conserve
power. If all devices on a hub are suspended, then the actual hub
can be suspended.

Routine Description:
This function is part of the hub drivers selective suspend feature (see
section 2 usbhub.doc).   This API is serviced only by hubs it is not supported
by a USB Port driver.  The client USB drivers use this API to register an idle
callback request with the parent hub.  The details on how this API is handled
can be found in section 2.

Parameters:
ioStackLocation->Parameters.Others.Argument1
>>IdeCallbackInfo
A pointer to a structure containing the callback routine and a context value.

typedef
VOID
(*USB_IDLE_CALLBACK)(
    PVOID Context
    );

typedef struct _USB_IDLE_CALLBACK_INFO {
    USB_IDLE_CALLBACK IdleCallback;
    PVOID IdleContext;
} USB_IDLE_CALLBACK_INFO, *PUSB_IDLE_CALLBACK_INFO;

*/

#define IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION   \
                                            CTL_CODE(FILE_DEVICE_USB,  \
                                            USB_IDLE_NOTIFICATION,  \
                                            METHOD_NEITHER,  \
                                            FILE_ANY_ACCESS)

/* IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE

Routine Description:
This function returns the device handle associated with the callers PDO. The
device handle is an opaque structure that is used as a parameter for other
APIs/

Parameters:
ioStackLocation->Parameters.Others.Argument1
A pointer to a device handle (pointer to pointer).
*/

#define IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE     CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_GET_DEVICE_HANDLE, \
                                                    METHOD_NEITHER,  \
                                                    FILE_ANY_ACCESS)

#endif

/*
   USB kernel Mode IOCTLS defined for windows Longhorn and later
*/

#if (_WIN32_WINNT >= 0x0600)


#define IOCTL_INTERNAL_USB_NOTIFY_IDLE_READY     CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_IDLE_NOTIFICATION_EX, \
                                                    METHOD_NEITHER,  \
                                                    FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_REQ_GLOBAL_SUSPEND    CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_REQ_GLOBAL_SUSPEND, \
                                                    METHOD_NEITHER,  \
                                                    FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_REQ_GLOBAL_RESUME     CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_REQ_GLOBAL_RESUME, \
                                                    METHOD_NEITHER,  \
                                                    FILE_ANY_ACCESS)


/* IOCTL_INTERNAL_USB_RECORD_FAILURE

*/

#ifdef USB20_API
typedef struct _USB_START_FAILDATA {
    ULONG LengthInBytes;
    NTSTATUS NtStatus;
    USBD_STATUS UsbdStatus;
    ULONG ConnectStatus;
    UCHAR DriverData[4];
} USB_START_FAILDATA, *PUSB_START_FAILDATA;
#endif

#define IOCTL_INTERNAL_USB_RECORD_FAILURE        CTL_CODE(FILE_DEVICE_USB,  \
                                                    USB_RECORD_FAILURE, \
                                                    METHOD_NEITHER,  \
                                                    FILE_ANY_ACCESS)


#define IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE_EX   CTL_CODE(FILE_DEVICE_USB,  \
                                                      USB_GET_DEVICE_HANDLE_EX, \
                                                      METHOD_NEITHER,  \
                                                      FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_TT_DEVICE_HANDLE   CTL_CODE(FILE_DEVICE_USB,  \
                                                      USB_GET_TT_DEVICE_HANDLE, \
                                                      METHOD_NEITHER,  \
                                                      FILE_ANY_ACCESS)
                                                      
/*  IOCTL_INTERNAL_USB_GET_TOPOLOGY_ADDRESS  */

typedef struct _USB_TOPOLOGY_ADDRESS {
        ULONG PciBusNumber;
        ULONG PciDeviceNumber;
        ULONG PciFunctionNumber;
        ULONG Reserved;
        USHORT RootHubPortNumber;
        USHORT HubPortNumber[5];
        USHORT Reserved2;
} USB_TOPOLOGY_ADDRESS, *PUSB_TOPOLOGY_ADDRESS;
        
#define IOCTL_INTERNAL_USB_GET_TOPOLOGY_ADDRESS   CTL_CODE(FILE_DEVICE_USB,  \
                                                      USB_GET_TOPOLOGY_ADDRESS, \
                                                      METHOD_NEITHER,  \
                                                      FILE_ANY_ACCESS)
                                                      
#define IOCTL_INTERNAL_USB_GET_DEVICE_CONFIG_INFO    CTL_CODE(FILE_DEVICE_USB,  \
                                                      USB_GET_HUB_CONFIG_INFO, \
                                                      METHOD_NEITHER,  \
                                                      FILE_ANY_ACCESS)

#endif



/*
   USB user mode IOCTLS
*/
#ifndef USB_KERNEL_IOCTL

/**************************************************************************
The following IOCTLS are always sent to the HCD symbolic name
***************************************************************************/

/* IOCTL_USB_HCD_GET_STATS_1 (OPTIONAL)

    The following IOCTL is used to return internal statictics
    for HCDs

*/

#define IOCTL_USB_HCD_GET_STATS_1           CTL_CODE(FILE_DEVICE_USB,  \
                                                HCD_GET_STATS_1,  \
                                                METHOD_BUFFERED,  \
                                                FILE_ANY_ACCESS)

/* IOCTL_USB_HCD_GET_STATS_2 (OPTIONAL)

    The following IOCTL is used to return internal statictics
    for HCDs

*/

#define IOCTL_USB_HCD_GET_STATS_2           CTL_CODE(FILE_DEVICE_USB,  \
                                                HCD_GET_STATS_2,  \
                                                METHOD_BUFFERED,  \
                                                FILE_ANY_ACCESS)

#define IOCTL_USB_HCD_DISABLE_PORT          CTL_CODE(FILE_DEVICE_USB, \
                                                HCD_DISABLE_PORT, \
                                                METHOD_BUFFERED, \
                                                FILE_ANY_ACCESS)

#define IOCTL_USB_HCD_ENABLE_PORT           CTL_CODE(FILE_DEVICE_USB, \
                                                HCD_ENABLE_PORT, \
                                                METHOD_BUFFERED, \
                                                FILE_ANY_ACCESS)


/*
   These ioctls are used for USB diagnostic and test applications
*/
#ifndef IOCTL_USB_DIAGNOSTIC_MODE_ON
#define IOCTL_USB_DIAGNOSTIC_MODE_ON   CTL_CODE(FILE_DEVICE_USB,  \
                                                HCD_DIAGNOSTIC_MODE_ON,  \
                                                METHOD_BUFFERED,  \
                                                FILE_ANY_ACCESS)
#endif                                                

#ifndef IOCTL_USB_DIAGNOSTIC_MODE_OFF
#define IOCTL_USB_DIAGNOSTIC_MODE_OFF  CTL_CODE(FILE_DEVICE_USB,  \
                                                HCD_DIAGNOSTIC_MODE_OFF,  \
                                                METHOD_BUFFERED,  \
                                                FILE_ANY_ACCESS)
#endif

#ifndef IOCTL_USB_GET_ROOT_HUB_NAME
#define IOCTL_USB_GET_ROOT_HUB_NAME    CTL_CODE(FILE_DEVICE_USB,  \
                                                HCD_GET_ROOT_HUB_NAME,  \
                                                METHOD_BUFFERED,  \
                                                FILE_ANY_ACCESS)
#endif

#ifndef IOCTL_GET_HCD_DRIVERKEY_NAME
#define IOCTL_GET_HCD_DRIVERKEY_NAME   CTL_CODE(FILE_DEVICE_USB,  \
                                                HCD_GET_DRIVERKEY_NAME,  \
                                                METHOD_BUFFERED,  \
                                                FILE_ANY_ACCESS)
#endif                                                

/**************************************************************************
The following IOCTLS are always sent to symbolic names
created by usbhub
***************************************************************************/

/*
    Utility IOCTLS supported by the hub device
*/

/*
   These ioctls are supported by the hub driver for
   use by user mode USB utilities.
*/

/*
IOCTL_USB_GET_NODE_INFORMATION

Routine Description:
Returns information about the USB hub in the user buffer passed in.  If the
IOCTL is sent to the hub NodeType is set to UsbHub and USB_HUB_INFORMATION is
returned this includes the hub descriptor and a flag indicating if the hub is
bus vs self powered .
This API returns FAILURE (STATUS_UNSUCCESSFUL) if the hub is not started or
otherwise not functional.

Parameters:
Input:
Irp->AssociatedIrp.SystemBuffer - pointer to USB_NODE_INFORMATION structure

Ouput:
USB_NODE_INFORMATION filled in as appropriate
*/
#define IOCTL_USB_GET_NODE_INFORMATION   \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_GET_NODE_INFORMATION,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)


/*
IOCTL_USB_GET_NODE_CONNECTION_INFORMATION

Exactly the same as _EX but the speed field is a Boolean
LowSpeed
-TRUE if the device is low speed.
*/
#define IOCTL_USB_GET_NODE_CONNECTION_INFORMATION  \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_GET_NODE_CONNECTION_INFORMATION,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

#define IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION   \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

#define IOCTL_USB_GET_NODE_CONNECTION_NAME    \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_GET_NODE_CONNECTION_NAME,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

#define IOCTL_USB_DIAG_IGNORE_HUBS_ON   CTL_CODE(FILE_DEVICE_USB,  \
                                USB_DIAG_IGNORE_HUBS_ON,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

#define IOCTL_USB_DIAG_IGNORE_HUBS_OFF  \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_DIAG_IGNORE_HUBS_OFF,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

#define IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME  \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_GET_NODE_CONNECTION_DRIVERKEY_NAME,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

/*
*  IOCTLS defined for Windows XP and later
*/

#if (_WIN32_WINNT >= 0x0501)

#define IOCTL_USB_GET_HUB_CAPABILITIES  \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_GET_HUB_CAPABILITIES,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

#define IOCTL_USB_HUB_CYCLE_PORT  \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_HUB_CYCLE_PORT,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

/*
IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES

Routine Description:
Returns the Microsoft extended port attributes for a specific port. The
caller inputs the port number as the 'ConnectionIndex'.  Microsoft extended
port attributes are defined in the Extended Port Attribute specification.
This API also returns the current connection status of the port.

This API returns FAILURE (STATUS_UNSUCCESSFUL) if the hub is not started or
otherwise not functional.

Parameters:
Input:
Irp->AssociatedIrp.SystemBuffer - pointer to
Struct  _USB_NODE_CONNECTION_INFORMATION {
    ULONG ConnectionIndex;
}
ConnectionIndex
-is the one based port number.

Ouput: (if a device is attached)
ConnectionStatus
-The current USB connection status. Indicates things like enumeration failure
or overcurrent.
PortAttributes
-Extended port attributes defined in usb.h.
*/

#define IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES  \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_GET_NODE_CONNECTION_ATTRIBUTES,\
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

/*
IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX

Routine Description:
Returns information about a specific USB hub port (AKA connection).  If there
is a device connected to the port information about the device is also
returned. The caller inputs the port number as the 'ConnectionIndex'.

This API returns FAILURE (STATUS_UNSUCCESSFUL) if the hub is not started or
otherwise not functional.

Parameters:
Input:
Irp->AssociatedIrp.SystemBuffer - pointer to
Struct  _USB_NODE_CONNECTION_INFORMATION {
    ULONG ConnectionIndex;
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;
    UCHAR CurrentConfigurationValue;
    BOOLEAN LowSpeed;
    BOOLEAN DeviceIsHub;
    USHORT DeviceAddress;
    ULONG NumberOfOpenPipes;
    USB_CONNECTION_STATUS ConnectionStatus;
    USB_PIPE_INFO PipeList[0];
}
ConnectionIndex
-is the one based port number.

Ouput: (if a device is attached)
DeviceDescriptor
-USB device descriptor.
CurrentConfigurationValue
-Currently selected configuration value.
Speed
-indicates the 'current' operating speed, note that high speed devices can
operate at full speed when necessary.
DeviceIsHub
- TRUE if the attached device is a hub
DeviceAddress
- USB assigned device address.
NumberOfOpenPipes
- Number of open USB pipes in the current configuration
ConnectionStatus
- The current USB connection status.
USB_PIPE_INFO PipeList[0];
- list of open pipes including schedule offset and endpoint descriptor.  This
information can be used to calculate bandwidthusage.
*/

#define IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX  \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                USB_GET_NODE_CONNECTION_INFORMATION_EX,  \
                                METHOD_BUFFERED,  \
                                FILE_ANY_ACCESS)

#endif

/*
* The following IOCTLS are defined for Windows Longhorn and Later
*/
#if (_WIN32_WINNT >= 0x0600)

#define IOCTL_USB_RESET_HUB  \
            CTL_CODE(FILE_DEVICE_USB,  \
                    USB_RESET_HUB,\
                    METHOD_BUFFERED,  \
                    FILE_ANY_ACCESS)
                    
#define IOCTL_USB_GET_HUB_CAPABILITIES_EX  \
                                CTL_CODE(FILE_DEVICE_USB,  \
                                    USB_GET_HUB_CAPABILITIES_EX,  \
                                    METHOD_BUFFERED,  \
                                    FILE_ANY_ACCESS)
#endif

/*
   structures for user mode ioctls
*/

#include <pshpack1.h>

typedef enum _USB_HUB_NODE {
    UsbHub,
    UsbMIParent
} USB_HUB_NODE;

typedef struct _USB_HUB_INFORMATION {
    /*
       copy of data from hub descriptor
    */
    USB_HUB_DESCRIPTOR HubDescriptor;

    BOOLEAN HubIsBusPowered;

} USB_HUB_INFORMATION, *PUSB_HUB_INFORMATION;

typedef struct _USB_MI_PARENT_INFORMATION {
    ULONG NumberOfInterfaces;
} USB_MI_PARENT_INFORMATION, *PUSB_MI_PARENT_INFORMATION;

typedef struct _USB_NODE_INFORMATION {
    USB_HUB_NODE NodeType;        /* hub, mi parent */
    union {
        USB_HUB_INFORMATION HubInformation;
        USB_MI_PARENT_INFORMATION MiParentInformation;
    } u;
} USB_NODE_INFORMATION, *PUSB_NODE_INFORMATION;

typedef struct _USB_PIPE_INFO {
    USB_ENDPOINT_DESCRIPTOR EndpointDescriptor;
    ULONG ScheduleOffset;
} USB_PIPE_INFO, *PUSB_PIPE_INFO;


#if (_WIN32_WINNT >= 0x0600)
/*
    For Windows Longhorn
*/

typedef enum _USB_CONNECTION_STATUS {
    NoDeviceConnected,
    DeviceConnected,

    /* failure codes, these map to fail reasons */
    DeviceFailedEnumeration,
    DeviceGeneralFailure,
    DeviceCausedOvercurrent,
    DeviceNotEnoughPower,
    DeviceNotEnoughBandwidth,
    DeviceHubNestedTooDeeply,
    DeviceInLegacyHub,
    DeviceEnumerating,
    DeviceReset
} USB_CONNECTION_STATUS, *PUSB_CONNECTION_STATUS;

#elif (_WIN32_WINNT >= 0x0501)

/*
    For Windows XP
*/

typedef enum _USB_CONNECTION_STATUS {
    NoDeviceConnected,
    DeviceConnected,

    /* failure codes, these map to fail reasons */
    DeviceFailedEnumeration,
    DeviceGeneralFailure,
    DeviceCausedOvercurrent,
    DeviceNotEnoughPower,
    DeviceNotEnoughBandwidth,
    DeviceHubNestedTooDeeply,
    DeviceInLegacyHub
} USB_CONNECTION_STATUS, *PUSB_CONNECTION_STATUS;

#else

/*
    For Windows 2000
*/

typedef enum _USB_CONNECTION_STATUS {
    NoDeviceConnected,
    DeviceConnected,

    /* failure codes, these map to fail reasons */
    DeviceFailedEnumeration,
    DeviceGeneralFailure,
    DeviceCausedOvercurrent,
    DeviceNotEnoughPower,
    DeviceNotEnoughBandwidth
} USB_CONNECTION_STATUS, *PUSB_CONNECTION_STATUS;

#endif


/** IOCTL_USB_GET_NODE_CONNECTION_INFORMATION **/
typedef struct _USB_NODE_CONNECTION_INFORMATION {
    ULONG ConnectionIndex;  /* INPUT */
    /* usb device descriptor returned by this device
       during enumeration */
    USB_DEVICE_DESCRIPTOR DeviceDescriptor; /* OUTPUT */
    UCHAR CurrentConfigurationValue;/* OUTPUT */
    BOOLEAN LowSpeed;/* OUTPUT */
    BOOLEAN DeviceIsHub;/* OUTPUT */
    USHORT DeviceAddress;/* OUTPUT */
    ULONG NumberOfOpenPipes;/* OUTPUT */
    USB_CONNECTION_STATUS ConnectionStatus;/* OUTPUT */
    USB_PIPE_INFO PipeList[0];/* OUTPUT */
} USB_NODE_CONNECTION_INFORMATION, *PUSB_NODE_CONNECTION_INFORMATION;

/** IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME **/
typedef struct _USB_NODE_CONNECTION_DRIVERKEY_NAME {
    ULONG ConnectionIndex;  /* INPUT */
    ULONG ActualLength;     /* OUTPUT */
    /* unicode name for the devnode */
    WCHAR DriverKeyName[1]; /* OUTPUT */
} USB_NODE_CONNECTION_DRIVERKEY_NAME, *PUSB_NODE_CONNECTION_DRIVERKEY_NAME;

/** IOCTL_USB_GET_NODE_CONNECTION_NAME **/
typedef struct _USB_NODE_CONNECTION_NAME {
    ULONG ConnectionIndex;  /* INPUT */
    ULONG ActualLength;     /* OUTPUT */
    /* unicode symbolic name for this node if it is a hub or parent driver
       null if this node is a device. */
    WCHAR NodeName[1];      /* OUTPUT */
} USB_NODE_CONNECTION_NAME, *PUSB_NODE_CONNECTION_NAME;

typedef struct _USB_HUB_NAME {
    ULONG ActualLength;     /* OUTPUT */
    /* NULL terminated unicode symbolic name for the root hub */
    WCHAR HubName[1];       /* OUTPUT */
} USB_HUB_NAME, *PUSB_HUB_NAME;

typedef struct _USB_ROOT_HUB_NAME {
    ULONG ActualLength;     /* OUTPUT */
    /* NULL terminated unicode symbolic name for the root hub */
    WCHAR RootHubName[1];   /* OUTPUT */
} USB_ROOT_HUB_NAME, *PUSB_ROOT_HUB_NAME;

typedef struct _USB_HCD_DRIVERKEY_NAME {
    ULONG ActualLength;     /* OUTPUT */
    /* NULL terminated unicode driverkeyname for hcd */
    WCHAR DriverKeyName[1]; /* OUTPUT */
} USB_HCD_DRIVERKEY_NAME, *PUSB_HCD_DRIVERKEY_NAME;

typedef struct _USB_DESCRIPTOR_REQUEST {
    ULONG ConnectionIndex;
    struct {
        UCHAR bmRequest;
        UCHAR bRequest;
        USHORT wValue;
        USHORT wIndex;
        USHORT wLength;
    } SetupPacket;
    UCHAR Data[0];
} USB_DESCRIPTOR_REQUEST, *PUSB_DESCRIPTOR_REQUEST;


/*
    Structures defined for Windows XP and later only
*/

#if (_WIN32_WINNT >= 0x0501)

typedef struct _USB_HUB_CAPABILITIES {
    /*
        Unlike the USB_HUB_INFORMATION structure used by
        IOCTL_USB_GET_NODE_INFORMATION, this structure can be extended in the
        future to accomodate more data.  The IOCTL will return only as much
        data as indicated by the size of the request buffer, to maintain
        backward compatibility with older callers that don't know about the
        new data.
    */

    ULONG HubIs2xCapable:1;

} USB_HUB_CAPABILITIES, *PUSB_HUB_CAPABILITIES;


/** IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES **/

typedef struct _USB_NODE_CONNECTION_ATTRIBUTES {
    /* one based port number */
    ULONG ConnectionIndex;  /* INPUT */
    /* current USB connect status for the port*/
    USB_CONNECTION_STATUS ConnectionStatus; /* OUTPUT */
    /* extended port attributes defined in usb.h*/
    ULONG PortAttributes; /* OUTPUT */
} USB_NODE_CONNECTION_ATTRIBUTES, *PUSB_NODE_CONNECTION_ATTRIBUTES;

/** IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX **/
typedef struct _USB_NODE_CONNECTION_INFORMATION_EX {
    ULONG ConnectionIndex;  /* INPUT */
    /* usb device descriptor returned by this device
       during enumeration */
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;/* OUTPUT */
    UCHAR CurrentConfigurationValue;/* OUTPUT */
    /* values for the speed field are defined in USB200.h */
    UCHAR Speed;/* OUTPUT */
    BOOLEAN DeviceIsHub;/* OUTPUT */
    USHORT DeviceAddress;/* OUTPUT */
    ULONG NumberOfOpenPipes;/* OUTPUT */
    USB_CONNECTION_STATUS ConnectionStatus;/* OUTPUT */
    USB_PIPE_INFO PipeList[0];/* OUTPUT */
} USB_NODE_CONNECTION_INFORMATION_EX, *PUSB_NODE_CONNECTION_INFORMATION_EX;

C_ASSERT(sizeof(USB_NODE_CONNECTION_INFORMATION_EX) == \
    sizeof(USB_NODE_CONNECTION_INFORMATION));

#endif

/*
  Structures defined for windows Longhorn and later only
*/

#if (_WIN32_WINNT >= 0x0600)

typedef union _USB_HUB_CAP_FLAGS {
    ULONG ul;
    struct {
        ULONG HubIsHighSpeedCapable:1;
        ULONG HubIsHighSpeed:1;
        ULONG HubIsMultiTtCapable:1;
        ULONG HubIsMultiTt:1;
        ULONG HubIsRoot:1;
        ULONG HubIsArmedWakeOnConnect:1;
        ULONG HubIsBusPowered:1;
        ULONG ReservedMBZ:25;
    };

} USB_HUB_CAP_FLAGS, *PUSB_HUB_CAP_FLAGS;

C_ASSERT(sizeof(USB_HUB_CAP_FLAGS) == sizeof(ULONG));

typedef struct _USB_HUB_CAPABILITIES_EX {

    USB_HUB_CAP_FLAGS CapabilityFlags;

} USB_HUB_CAPABILITIES_EX, *PUSB_HUB_CAPABILITIES_EX;

typedef struct _USB_CYCLE_PORT_PARAMS {
    /* one based port number */
    ULONG ConnectionIndex;  /* INPUT */
  
    ULONG StatusReturned; /* OUTPUT */
} USB_CYCLE_PORT_PARAMS, *PUSB_CYCLE_PORT_PARAMS;


/************************************************************************
*     Structures used for IOCTL_INTERNAL_USB_GET_DEVICE_CONFIG_INFO
**************************************************************************/

/*
    structure for storing PnP ids
    the length includes any trailing NULLs
*/

typedef struct _USB_ID_STRING {

    USHORT LanguageId;      // laguage id where apllicable
    USHORT Pad;
    ULONG LengthInBytes;    // length of <Buffer> in Bytes includes NULLs etc
    PWCHAR Buffer;

} USB_ID_STRING, *PUSB_ID_STRING;

typedef struct _HUB_DEVICE_CONFIG_INFO_V1{
    ULONG                               Version;
    ULONG                               Length;
    USB_HUB_CAP_FLAGS                   HubFlags;
    USB_ID_STRING			HardwareIds;
    USB_ID_STRING			CompatibleIds;
    USB_ID_STRING			DeviceDescription;
    ULONG                               Reserved[36];
}HUB_DEVICE_CONFIG_INFO, *PHUB_DEVICE_CONFIG_INFO;


#endif

/*
   Structure for returning HCD debug and statistic information to
   a user mode application.
*/

typedef struct _HCD_STAT_COUNTERS {
    ULONG BytesTransferred;

    USHORT IsoMissedCount;
    USHORT DataOverrunErrorCount;

    USHORT CrcErrorCount;
    USHORT ScheduleOverrunCount;

    USHORT TimeoutErrorCount;
    USHORT InternalHcErrorCount;

    USHORT BufferOverrunErrorCount;
    USHORT SWErrorCount;

    USHORT StallPidCount;
    USHORT PortDisableCount;

} HCD_STAT_COUNTERS, *PHCD_STAT_COUNTERS;


typedef struct _HCD_ISO_STAT_COUNTERS {

    USHORT  LateUrbs;
    USHORT  DoubleBufferedPackets;

    USHORT  TransfersCF_5ms;
    USHORT  TransfersCF_2ms;

    USHORT  TransfersCF_1ms;
    USHORT  MaxInterruptLatency;

    USHORT  BadStartFrame;
    USHORT  StaleUrbs;

    /* total count of packets programmed but not accessed by
       the controller either due to software scheduling
       problems or HW problems */
    USHORT  IsoPacketNotAccesed;
    USHORT  IsoPacketHWError;

    USHORT  SmallestUrbPacketCount;
    USHORT  LargestUrbPacketCount;

    USHORT IsoCRC_Error;
    USHORT IsoOVERRUN_Error;
    USHORT IsoINTERNAL_Error;
    USHORT IsoUNKNOWN_Error;

    ULONG  IsoBytesTransferred;

    /* count of packets missed due to software scheduling
       problems */
    USHORT LateMissedCount;
    /* incremented when a packet is scheduled but not
       accessed by the controller */
    USHORT HWIsoMissedCount;

    ULONG  Reserved7[8];

} HCD_ISO_STAT_COUNTERS, *PHCD_ISO_STAT_COUNTERS;



typedef struct _HCD_STAT_INFORMATION_1 {
    ULONG Reserved1;
    ULONG Reserved2;
    ULONG ResetCounters;
    LARGE_INTEGER TimeRead;
    /*
       stat registers
    */
    HCD_STAT_COUNTERS Counters;

} HCD_STAT_INFORMATION_1, *PHCD_STAT_INFORMATION_1;

typedef struct _HCD_STAT_INFORMATION_2 {
    ULONG Reserved1;
    ULONG Reserved2;
    ULONG ResetCounters;
    LARGE_INTEGER TimeRead;

    LONG LockedMemoryUsed;
    /*
       stat registers
    */
    HCD_STAT_COUNTERS Counters;
    HCD_ISO_STAT_COUNTERS IsoCounters;

} HCD_STAT_INFORMATION_2, *PHCD_STAT_INFORMATION_2;

/*
   WMI related structures
*/

/* these index in to our array of guids for the hub FDO */
#define WMI_USB_DRIVER_INFORMATION      0
#define WMI_USB_DRIVER_NOTIFICATION     1
#define WMI_USB_POWER_DEVICE_ENABLE     2
#define WMI_USB_HUB_NODE_INFORMATION    4

/* Index into array of guids for the HUB pdos */

#define WMI_USB_PERFORMANCE_INFORMATION 1
#define WMI_USB_DEVICE_NODE_INFORMATION 2

#if (_WIN32_WINNT >= 0x0501)
    /*
        Windows XP and later
    */

typedef enum _USB_NOTIFICATION_TYPE {

    /*  the following return a
        USB_CONNECTION_NOTIFICATION structure: */
    EnumerationFailure = 0,
    InsufficentBandwidth,
    InsufficentPower,
    OverCurrent,
    ResetOvercurrent,

    /* the following return a
       USB_BUS_NOTIFICATION structure:*/
    AcquireBusInfo,

    /* the following return a
      USB_ACQUIRE_INFO structure: */
    AcquireHubName,
    AcquireControllerName,

    /* the following return a
       USB_HUB_NOTIFICATION structure: */
    HubOvercurrent,
    HubPowerChange,
    HubNestedTooDeeply,
    ModernDeviceInLegacyHub

} USB_NOTIFICATION_TYPE;

#else

/*
    For Windows 2000
*/

typedef enum _USB_NOTIFICATION_TYPE {

    /*  the following return a
        USB_CONNECTION_NOTIFICATION structure: */
    EnumerationFailure = 0,
    InsufficentBandwidth,
    InsufficentPower,
    OverCurrent,
    ResetOvercurrent,

    /* the following return a
       USB_BUS_NOTIFICATION structure:*/
    AcquireBusInfo,

    /* the following return a
      USB_ACQUIRE_INFO structure: */
    AcquireHubName,
    AcquireControllerName,

    /* the following return a
       USB_HUB_NOTIFICATION structure: */
    HubOvercurrent,
    HubPowerChange

} USB_NOTIFICATION_TYPE;

#endif

typedef struct _USB_NOTIFICATION {
    /* indicates type of notification */
    USB_NOTIFICATION_TYPE NotificationType;

} USB_NOTIFICATION, *PUSB_NOTIFICATION;

/* this structure is used for connection notification
   codes */

typedef struct _USB_CONNECTION_NOTIFICATION {
    /* indicates type of notification */
    USB_NOTIFICATION_TYPE NotificationType;

    /* valid for all connection notifictaion codes,
       0 indicates global condition for hub or parent
       this value will be a port number for devices
       attached to a hub, otherwise a one based
       index if the device is a child of a composite
       parent */
    ULONG ConnectionNumber;

    /* valid for InsufficentBandwidth,
       the amount of bandwidth the device
       tried to allocate and was denied. */
    ULONG RequestedBandwidth;

    /* valid for EnumerationFailure,
       gives some indication why the device failed
       to enumerate */
    ULONG EnumerationFailReason;

    /* valid for InsufficentPower,
       the amount of power requested to configure
       this device. */
    ULONG PowerRequested;

    /* length of the UNICODE symbolic name (in bytes) for the HUB
       that this device is attached to.
       not including NULL */
    ULONG HubNameLength;

} USB_CONNECTION_NOTIFICATION, *PUSB_CONNECTION_NOTIFICATION;

/*
   This structure is used for the bus notification code 'AcquireBusInfo'
*/

typedef struct _USB_BUS_NOTIFICATION {
    /* indicates type of notification */
    USB_NOTIFICATION_TYPE NotificationType;     /* indicates type of */
                                                /* notification */
    ULONG TotalBandwidth;
    ULONG ConsumedBandwidth;

    /* length of the UNICODE symbolic name (in bytes) for the controller
       that this device is attached to.
       not including NULL */
    ULONG ControllerNameLength;

} USB_BUS_NOTIFICATION, *PUSB_BUS_NOTIFICATION;

/*
   used to acquire user mode filenames to open respective objects
*/

typedef struct _USB_ACQUIRE_INFO {
    /* indicates type of notification */
    USB_NOTIFICATION_TYPE NotificationType;
    /* TotalSize of this struct */
    ULONG TotalSize;

    WCHAR Buffer[1];
} USB_ACQUIRE_INFO, *PUSB_ACQUIRE_INFO;


/*
    Structures defined for windows Longhorn and later only
*/

#if (_WIN32_WINNT >= 0x0600)

/*
    structures used to acquire device specific info via
    GUID_USB_WMI_NODE_INFO
*/

#define USB_NODE_INFO_SIG 'USBN'

typedef enum _USB_WMI_DEVICE_NODE_TYPE {
    UsbDevice,
    HubDevice,
    CompositeDevice,
    UsbController
} USB_WMI_DEVICE_NODE_TYPE, *PUSB_WMI_DEVICE_NODE_TYPE;

typedef struct _USB_DEVICE_STATE {

    ULONG DeviceConnected:1;
    ULONG DeviceStarted:1;

} USB_DEVICE_STATE, *PUSB_DEVICE_STATE;

//
// Specific information about a hub device
//

typedef struct _USB_HUB_PORT_INFORMATION{
    
    USB_DEVICE_STATE DeviceState;
    
    USHORT PortNumber;

    USHORT DeviceAddress;
    
    // Legacy ConnectionIndex used with USB user IOCTLS
    ULONG ConnectionIndex;
    
    // Legacy ConnectionStatus
    USB_CONNECTION_STATUS ConnectionStatus;
     
} USB_HUB_PORT_INFORMATION, *PUSB_HUB_PORT_INFORMATION;

typedef struct _USB_HUB_DEVICE_INFO {
    
    // Hub Descriptor
    USB_HUB_DESCRIPTOR HubDescriptor;
    
    // Unique Hub number
    ULONG HubNumber;
    
    // Device Address
    USHORT DeviceAddress;
    
    // Hub power bit
    BOOLEAN HubIsSelfPowered;
    
    // Root hub
    BOOLEAN HubIsRootHub;
    
    // Hub capabilities
    USB_HUB_CAPABILITIES HubCapabilities;
    
    // Number of hub ports
    ULONG NumberOfHubPorts;
    
    // Variable length array of info about hub ports
    USB_HUB_PORT_INFORMATION PortInfo[1];
    
} USB_HUB_DEVICE_INFO, *PUSB_HUB_DEVICE_INFO;

//
// Specific info about a composite device
//

typedef struct _USB_COMPOSITE_FUNCTION_INFO{

    UCHAR FunctionNumber;
    
    UCHAR BaseInterfaceNumber;
    
    UCHAR NumberOfInterfaces;
    
    BOOLEAN FunctionIsIdle;
    
} USB_COMPOSITE_FUNCTION_INFO, *PUSB_COMPOSITE_FUNCTION_INFO;
    

typedef struct _USB_COMPOSITE_DEVICE_INFO {

    // USB Device Descriptor
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;
    
    // Usb Configuration Descriptor
    USB_CONFIGURATION_DESCRIPTOR CurrentConfigDescriptor;
    
    // 0-based configuration number
    UCHAR CurrentConfigurationValue;
    
    // Number of composite PDOs
    UCHAR NumberOfFunctions;
    
    USB_COMPOSITE_FUNCTION_INFO FunctionInfo[1];

} USB_COMPOSITE_DEVICE_INFO, *PUSB_COMPOSITE_DEVICE_INFO;

//
// Specific info about a USB controller
//

typedef struct _USB_CONTROLLER_DEVICE_INFO {
    
    ULONG PciVendorId;
    ULONG PciDeviceId;
    ULONG PciRevision;

    ULONG NumberOfRootPorts;

    ULONG HcFeatureFlags;

} USB_CONTROLLER_DEVICE_INFO, *PUSB_CONTROLLER_DEVICE_INFO;

//
// Specific info about a connected USB device
//

typedef struct _USB_DEVICE_INFO{
    
    // Device State
    USB_DEVICE_STATE DeviceState;

    // Hub Port Number
    USHORT PortNumber;
    
    // USB Device Descriptor
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;
    
    // Current configuration value
    UCHAR CurrentConfigurationValue;
    
    // Device speed
    USB_DEVICE_SPEED Speed;
    
    // Device Address
    USHORT DeviceAddress;

    // Legacy ConnectionIndex used with USB user IOCTLS
    ULONG ConnectionIndex;
    
    // Legacy ConnectionStatus
    USB_CONNECTION_STATUS ConnectionStatus;
 
    // PNP HardwareID in multi-string format
    WCHAR PnpHardwareId[128];
    
    // PNP Compatible ID in multi-string format
    WCHAR PnpCompatibleId[128];
    
    // USB Serial Number string if present
    WCHAR SerialNumberId[128];
    
    // PNP Device Description
    WCHAR PnpDeviceDescription[128];
    
    // Number of pipes contained in the PipeList
    ULONG NumberOfOpenPipes;
    
    // Variable length list of open pipes
    USB_PIPE_INFO PipeList[1];

} USB_DEVICE_INFO, *PUSB_DEVICE_INFO;


typedef struct _USB_DEVICE_NODE_INFO {
    
    // Structure signature
    ULONG Sig;
    
    // Length of structure
    ULONG LengthInBytes;
    
    // Device Description
    WCHAR DeviceDescription[40];
    
    // Device Type
    USB_WMI_DEVICE_NODE_TYPE NodeType;
    
    // Bus Address
    USB_TOPOLOGY_ADDRESS BusAddress;
   
    // device information
    union{
        USB_DEVICE_INFO UsbDeviceInfo;
        USB_HUB_DEVICE_INFO HubDeviceInfo;
        USB_COMPOSITE_DEVICE_INFO CompositeDeviceInfo;
        USB_CONTROLLER_DEVICE_INFO ControllerDeviceInfo;
        UCHAR DeviceInformation[4];
    };
    
} USB_DEVICE_NODE_INFO, *PUSB_DEVICE_NODE_INFO;


/*
    structures used to acquire device specific performance info
    GUID_USB_WMI_DEVICE_PERF_INFO
*/

typedef struct _USB_DEVICE_PERFORMANCE_INFO {

    //total bulk bytes transfered for this device
    ULONG BulkBytes;

    //total control bytes transfered for this device
    ULONG ControlDataBytes;

    // total iso bytes transfered for this device
    ULONG IsoBytes;

    // total interrupt bytes transfered for this device
    ULONG InterruptBytes;

    // Total number of transfer URBs processed for this device
    ULONG BulkUrbCount;
    ULONG ControlUrbCount;
    ULONG IsoUrbCount;
    ULONG InterruptUrbCount;

    // BW reported in bits/32ms(32 frames)
    // Interrupt BW is reported by endpoint period in AllocedInterrupt[n] where period = 2^n
    // The total interrupt BW allocated for this device is the sum of the BW
    // for all periods
    //
    ULONG AllocedInterrupt[6];
    
    // Iso BW allocated for all iso endpoints on the device.  
    // Reported in bits/32ms(32 frames)
    //
    ULONG AllocedIso;

    // Total USB controller BW available in bits/32ms.
    ULONG Total32secBandwidth;
    
    // Total USB BW available on the device's TT in bits/32ms
    ULONG TotalTtBandwidth;

    // Text description of the device
    WCHAR DeviceDescription[60];

    // operating speed of the device
    USB_DEVICE_SPEED DeviceSpeed;
    
    // total number of ms iso transfers have waited after being scheduled
    ULONG TotalIsoLatency;
    
    // Number of ISO packets that were not scheduled or processed by the controller
    ULONG DroppedIsoPackets;
    
    // Number of transfers completing with an error
    ULONG TransferErrors;
    
    //
    //  Following values are for CONTROLLER instances only.
    //
    
    // Number of controller interrupts
    ULONG PciInterruptCount;
    
    // HC Idle State -- non zero if the HC is not running
    ULONG HcIdleState;

    // Async (EHCI) Idle State -- non zero if the async segment is off
    ULONG HcAsyncIdleState;

    // Async (EHCI) Cache stats -- incremented each time we flush the async cache (doorbell).
    ULONG HcAsyncCacheFlushCount;

    // Periodic (EHCI) Idle State -- non zero if the periodic segment is off
    ULONG HcPeriodicIdleState;

    // Periodic (EHCI) Cache stats -- incremented each time we flush the periodic prefetch cache.
    ULONG HcPeriodicCacheFlushCount;

} USB_DEVICE_PERFORMANCE_INFO, *PUSB_DEVICE_PERFORMANCE_INFO;

#endif

#include <poppack.h>

#endif //#if USB_KERNEL_IOCTL
#endif /* __USBIOCTL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usp10.h ===
/*++

   Copyright (c) Microsoft Corporation. All rights reserved.

*/

#ifndef __usp10__
#define __usp10__
#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <specstrings.h>
#ifdef __cplusplus
extern "C" {
#endif


/////   USP - Unicode Complex Script processor
//
//      Copyright (c) Microsoft Corporation. All rights reserved.




/////   SCRIPT
//
//      The SCRIPT enum is an opaque type used internally to identify
//      which shaping engine functions are used to process a given run.
//
//
#define SCRIPT_UNDEFINED  0
//
//p     SCRIPT_UNDEFINED: This is the only public script ordinal. May be
//      forced into the eScript field of a SCRIPT_ANALYSIS to disable shaping.
//      SCRIPT_UNDEFINED is supported by all fonts - ScriptShape will display
//      whatever glyph is defined in the font CMAP table, or, if none, the
//      missing glyph.







/////   USP Status Codes
//
#define USP_E_SCRIPT_NOT_IN_FONT   \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x200)    // Script doesn't exist in font






/////   SCRIPT_CACHE
//
//      Many script APIs take a combination of HDC and SCRIPT_CACHE parameter.
//
//      A SCRIPT_CACHE is an opaque pointer to a Uniscribe font metric cache
//      structure.


typedef void *SCRIPT_CACHE;


//      The client must allocate and retain one SCRIPT_CACHE variable for each
//      character style used. It must be initialised by the client to NULL.
//
//      APIs are passed an HDC and the address of a SCRIPT_CACHE variable.
//      Uniscribe will first attempt to access font data via the SCRIPT_CACHE
//      and will only inspect the HDC if the required data is not already
//      cached.
//
//      The HDC may be passed as NULL. If data required by Uniscribe is
//      already cached, the HDC won't be accessed and operation continues
//      normally.
//
//      If the HDC is passed as NULL, and Uniscribe needs to access it for
//      any reason, Uniscribe will return E_PENDING.
//
//      E_PENDING is returned quickly, allowing the client to avoid time
//      consuming SelectObject calls. The following example applies to all
//      APIs that take a SCRIPT_CACHE and an optional HDC.
//
//c     hr = ScriptShape(NULL, &sc, ..);
//c     if (hr == E_PENDING) {
//c         ... select font into hdc ...
//c         hr = ScriptShape(hdc, &sc, ...);
//c     }






/////   ScriptFreeCache
//
//      The client may free a SCRIPT_CACHE at any time. Uniscribe maintains
//      reference counts in it's font and shaper caches, and frees font data
//      only when all sizes of the font are free, and shaper data only when
//      all fonts it supports are freed.
//
//      The client should free the SCRIPT_CACHE for a style when it discards
//      that style.
//
//      ScriptFreeCache always sets it's parameter to NULL to help avoid
//      mis-referencing.


__checkReturn HRESULT WINAPI ScriptFreeCache(
    __deref_inout_ecount(1) SCRIPT_CACHE   *psc);       //InOut  Cache handle






/////   SCRIPT_CONTROL
//
//      The SCRIPT_CONTROL structure provides itemization control flags to the
//      ScriptItemize function.
//
//
typedef struct tag_SCRIPT_CONTROL {
    DWORD   uDefaultLanguage    :16; // For NADS, also default for context
    DWORD   fContextDigits      :1;  // Means use previous script instead of uDefaultLanguage

    // The following flags provide legacy support for GetCharacterPlacement features
    DWORD   fInvertPreBoundDir  :1;  // Reading order of virtual item immediately prior to string
    DWORD   fInvertPostBoundDir :1;  // Reading order of virtual item immediately following string
    DWORD   fLinkStringBefore   :1;  // Equivalent to presence of ZWJ before string
    DWORD   fLinkStringAfter    :1;  // Equivalent to presence of ZWJ after string
    DWORD   fNeutralOverride    :1;  // Causes all neutrals to be strong in the current embedding direction
    DWORD   fNumericOverride    :1;  // Causes all numerals to be strong in the current embedding direction
    DWORD   fLegacyBidiClass    :1;  // Causes plus and minus to be reated as neutrals, slash as a common separator
    DWORD   fMergeNeutralItems  :1;  // Causes merging neutral characters into strong items, when possible
    DWORD   fReserved           :7;  
} SCRIPT_CONTROL;
//
//
//p     uDefaultLanguage: Language to use when Unicode values are ambiguous.
//              Used by numeric processing to select digit shape when
//              fDigitSubstitute (see SCRIPT_STATE) is in force.
//
//p     fContextDigits: Specifies that national digits are chosen according to
//              the nearest previous strong text, rather than using
//              uDefaultLanguage.
//
//p     fInvertPreBoundDir: By default text at the start of the string is
//              laid out as if it follows strong text of the same direction
//              as the base embedding level. Set fInvertPreBoundDir to change
//              the initial context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fInvertPostBoundDir: By default text at the end of the string is
//              laid out as if it preceeds strong text of the same direction
//              as the base embedding level. Set fInvertPostBoundDir to change
//              the final context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fLinkStringBefore: Causes the first character of the string to be
//              shaped as if were joined to a previous character.
//
//p     fLinkStringAfter: Causes the last character of the string to be
//              shaped as if were joined to a following character.
//
//p     fNeutralOverride: Causes all neutral characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks neutrals in place,
//              reordering occuring only between neutrals.
//
//p     fNumericOverride: Causes all numeric characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks numerics in place,
//              reordering occuring only between numerics.
//
//p     fReserved: Reserved. Always initialise to 0.






/////   SCRIPT_STATE
//
//      The SCRIPT_STATE structure is used both to initialise the unicode
//      algorithm state as an input parameter to ScriptItemize, and is also
//      a component of each item analysis returned by ScriptItemize.
//
//
typedef struct tag_SCRIPT_STATE {
    WORD    uBidiLevel         :5;  // Unicode Bidi algorithm embedding level (0-16)
    WORD    fOverrideDirection :1;  // Set when in LRO/RLO embedding
    WORD    fInhibitSymSwap    :1;  // Set by U+206A (ISS), cleared by U+206B (ASS)
    WORD    fCharShape         :1;  // Set by U+206D (AAFS), cleared by U+206C (IAFS)
    WORD    fDigitSubstitute   :1;  // Set by U+206E (NADS), cleared by U+206F (NODS)
    WORD    fInhibitLigate     :1;  // Equiv !GCP_Ligate, no Unicode control chars yet
    WORD    fDisplayZWG        :1;  // Equiv GCP_DisplayZWG, no Unicode control characters yet
    WORD    fArabicNumContext  :1;  // For EN->AN Unicode rule
    WORD    fGcpClusters       :1;  // For Generating Backward Compatible GCP Clusters (legacy Apps)
    WORD    fReserved          :1;
    WORD    fEngineReserved    :2;  // For use by shaping engine
} SCRIPT_STATE;
//
//
//p     uBidiLevel: The embedding level associated with all characters in this
//              run according to the Unicode bidi algorithm. When passed to
//              ScriptItemize, should be initialised to 0 for an LTR base
//              embedding level, or 1 for RTL.
//
//p     fOverrideDirection: TRUE if this level is an override level (LRO/RLO).
//              In an override level, characters are layed out purely
//              left to right, or purely right to left. No reordering of digits
//              or strong characters of opposing direction takes place.
//              Note that this initial value is reset by LRE, RLE, LRO or
//              RLO codes in the string.
//
//p     fInhibitSymSwap: TRUE if the shaping engine is to bypass mirroring of
//              Unicode Mirrored glyphs such as brackets. Set by Unicode
//              character ISS, cleared by ASS.
//
//p     fCharShape: TRUE if character codes in the Arabic Presentation Forms
//              areas of Unicode should be shaped. (Not implemented).
//
//p     fDigitSubstitute: TRUE if character codes U+0030 through U+0039
//              (European digits) are to be substituted by national digits.
//              Set by Unicode NADS, Cleared by NODS.
//
//p     fInhibitLigate: TRUE if ligatures are not to be used in the shaping
//              of Arabic or Hebrew characters.
//
//p     fDisplayZWG: TRUE if control characters are to be shaped as
//              representational glyphs. (Normally, control characters are
//              shaped to the blank glyph and given a width of zero).
//
//p     fArabicNumContext: TRUE indicates prior strong characters were Arabic
//              for the purposes of rule P0 on page 3-19 of 'The Unicode
//              Standard, version 2.0'. Should normally be set TRUE before
//              itemizing an RTL paragraph in an Arabic language, FALSE
//              otherwise.
//
//p     fGcpClusters: For GetCharaterPlacement legacy support only.
//              Initialise to TRUE to request ScriptShape to generate
//              the LogClust array the same way as GetCharacterPlacement
//              does in Arabic and Hebrew Windows95. Affects only Arabic
//              and Hebrew items.
//
//p     fReserved: Reserved. Always initialise to 0.
//
//p     fEngineReserved: Reserved. Always initialise to 0.






/////   SCRIPT_ANALYSIS
//
//      Each analysed item is described by a SCRIPT_ANALYSIS structure.
//      It also includes a copy of the Unicode algorithm state (SCRIPT_STATE).
//
//
typedef struct tag_SCRIPT_ANALYSIS {
    WORD    eScript         :10;    // Shaping engine
    WORD    fRTL            :1;     // Rendering direction
    WORD    fLayoutRTL      :1;     // Set for GCP classes ARABIC/HEBREW and LOCALNUMBER
    WORD    fLinkBefore     :1;     // Implies there was a ZWJ before this item
    WORD    fLinkAfter      :1;     // Implies there is a ZWJ following this item.
    WORD    fLogicalOrder   :1;     // Set by client as input to ScriptShape/Place
    WORD    fNoGlyphIndex   :1;     // Generated by ScriptShape/Place - this item does not use glyph indices
    SCRIPT_STATE s;
} SCRIPT_ANALYSIS;
//
//
//p     eScript: Opaque value identifying which engine Uniscribe will use to
//              Shape, Place and TextOut this item. The value of eScript is
//              undefined, and will change in future releases, but attributes
//              of eScript may be obtained by calling ScriptGetProperties.
//
//p     fRTL: Rendering direction. Normally identical to the parity of the
//              Unicode embedding level, but may differ if overridden by
//              GetCharacterPlacement legacy support.
//
//p     fLayoutRTL: Logical direction - whether conceptually part of a
//              left-to-right sequenece or a right-to-left sequence. Although
//              this is usually the same as fRTL, for a number in a
//              right-to-left run, fRTL is False (because digits are always
//              displayed LTR), but fLayoutRTL is True (because the number is
//              read as part of the right-to-left sequence).
//
//p     fLinkBefore: If set, the shaping engine will shape the first character
//              of this item as if it were joining with a previous character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLinkAfter: If set, the shaping engine will shape the last character
//              of this item as if it were joining with a subsequient character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLogicalOrder: If set, the shaping engine will generate all glyph
//              related arrays in logical order. By default glyph related
//              arrays are in visual order, the first array entry corresponding
//              to the leftmost glyph.
//              Set to FALSE by ScriptItemize, may be overriden before calling
//              ScriptShape.
//
//p     fNoGlyphIndex: May be set TRUE on input to ScriptShape to disable use
//              of glyphs for this item. Additionally, ScriptShape will set it
//              TRUE for hdcs containing symbolic, unrecognised and device fonts.
//              Disabling glyphing disables complex script shaping. When set,
//              shaping and placing for this item is implemented directly by
//              calls to GetTextExtentExPoint and ExtTextOut.
/////   SCRIPT_ITEM
//
//      The SCRIPT_ITEM structure includes a SCRIPT_ANALYSIS with the string
//      ofset of the first character of the item.
//
//
typedef struct tag_SCRIPT_ITEM {
    int              iCharPos;      // Logical offset to first character in this item
    SCRIPT_ANALYSIS  a;
} SCRIPT_ITEM;
//
//
//p     iCharPos: Offset from beginning of itemised string to first character
//              of this item, counted in Unicode codepoints (i.e. words).
//
//p     a: Script analysis structure containing analysis specific to this
//              item, to be passed to ScriptShape, ScriptPlace etc.






/////   ScriptItemize - break text into items
//
//      Breaks a run of unicode into individually shapeable items.
//      Items are delimited by
//
//      o Change of shaping engine
//      o Change of direction
//
//      The client may create multiple runs from each item returned by
//      ScriptItemize, but should not combine multiple items into a single run.
//
//      Later the client will call ScriptShape for each run (when measuring or
//      rendering), and must pass the SCRIPT_ANALYSIS that ScriptItemize
//      returned.


__checkReturn HRESULT WINAPI ScriptItemize(
    __in_ecount(cInChars) const WCHAR                   *pwcInChars,    // In   Unicode string to be itemized
    int                                                 cInChars,       // In   Codepoint count to itemize
    int                                                 cMaxItems,      // In   Max length of itemization array
    __in_ecount_opt(1) const SCRIPT_CONTROL             *psControl,     // In   Analysis control (optional)
    __in_ecount_opt(1) const SCRIPT_STATE               *psState,       // In   Initial bidi algorithm state (optional)
    __out_ecount_part(cMaxItems, *pcItems) SCRIPT_ITEM  *pItems,        // Out  Array to receive itemization
    __out_ecount(1) int                                 *pcItems);      // Out  Count of items processed (optional)






/////
//
//
//      Returns E_INVALIDARG if pwcInChars == NULL or cInChars == 0
//          or pItems == NULL or cMaxItems < 2.
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxItems) is
//          insufficient. Note that in this case, as in all error cases, no
//          items have been fully processed so no part of the output array
//          contains defined values.
//
//      If psControl and psState are NULL on entry, ScriptItemize
//      breaks the unicode string purely by character code.  If they are all
//      non-null, it performs a full Unicode bidi analysis.
//
//      ScriptItemize always adds a terminal item to the item analysis array
//      (pItems) such that the length of an item at pItem is always available as:
//
//c     pItem[1].iCharPos - pItem[0].iCharPos
//
//      For this reason, it is invalid to call ScriptItemize with a buffer
//      of less than two SCRIPT_ANALYSIS items.
//
//      To perform a correct Unicode Bidi analysis, the SCRIPT_STATE should
//      be initialised according to the paragraph reading order at paragraph
//      start, and ScriptItemize should be passed the whole paragraph.
//
//      fRTL and fNumeric together provide the same classification as
//      the lpClass output from GetCharacterPlacement.
//
//      European digits U+0030 through U+0039 may be rendered as national
//      digits as follows:
//
//t     fDigitSubstitute | FContextDigits | Digit shapes displayed for Unicode U+0030 through U+0039
//t     ---------------- | -------------- | ------------------------------------
//t     False            | Any            | Western (European / American) digits
//t     True             | False          | As specified in SCRIPT_CONTROL.uDefaultLanguage
//t     True             | True           | As prior strong text, defaulting to SCRIPT_CONTROL.uDefaultLanguage
//
//
//      For fContextDigits, any Western digits (U+0030 - U+0039) encountered
//      before the first strongly directed character are substituted by the
//      traditional digits of the SCRIPT_CONTROL.uDefaultLanguage when that
//      language is written in the same direction as SCRIPT_STATE.uBidiLevel.
//
//      Thus, in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage is
//      1 (LANG_ARABIC), then leading Western digits will be substituted by
//      traditional Arabic digits.
//
//      However, also in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage
//      is 0x1e (LANG_THAI), then no substitution occurs on leading Western
//      digits because the Thai language is written left-to-right.
//
//      Following strongly directed characters, digits are substituted
//      by the traditional digits associated with the closest prior strongly
//      directed character.
//
//      The left-to-right mark (LRM) and right-to-left mark (RLM) are strong
//      characters whose language depends on the SCRIPT_CONTROL.uDefaultLangauge.
//
//      If SCRIPT_CONTROL.uDefaultLangauge is a left-to-right langauge, then
//      LRM causes subsequent Western digits to be substituted by the
//      traditional digits associated with that language, while Western
//      digits following RLM are not substituted.
//
//      Conversly, if SCRIPT_CONTROL.uDefaultLangauge is a right-to-left
//      langauge, then Western digits following LRM are not substituted, while
//      Western digits following RLM are substituted by the traditional digits
//      associated with that language.
//
//
//
//      Effect of Unicode control characters on SCRIPT_STATE:
//
//t     SCRIPT_STATE flag | Set by | Cleared by
//t     ----------------- | ------   ----------
//t     fDigitSubstitute  |  NADS  |   NODS
//t     fInhibitSymSwap   |  ISS   |   ASS
//t     fCharShape        |  AAFS  |   IAFS
//
//      SCRIPT_STATE.fArabicNumContext controls the Unicode EN->AN rule.
//      It should normally be initialised to TRUE
//      before itemizing an RTL paragraph in an Arabic language, FALSE
//      otherwise.
/////   ScriptLayout
//
//      The ScriptLayout function converts an array of run embedding levels to
//      a map of visual to logical position, and/or logical to visual position.
//
//      pbLevel must contain the embedding levels for all runs on the line,
//      ordered logically.
//
//      On output, piVisualToLogical[0] is the logical index of the run to
//      display at the far left. Subsequent entries should be displayed
//      progressing from left to right.
//
//      piLogicalToVisual[0] is the relative visual position where the first
//      logical run should be displayed - the leftmost display position being zero.
//
//      The caller may request either piLogicalToVisual or piVisualToLogical
//      or both.
//
//      Note: No other input is required since the embedding levels give all
//      necessary information for layout.


__checkReturn HRESULT WINAPI ScriptLayout(
    int                             cRuns,                  // In   Number of runs to process
    __in_ecount(cRuns) const BYTE   *pbLevel,               // In   Array of run embedding levels
    __out_ecount_full_opt(cRuns) int    *piVisualToLogical,     // Out  List of run indices in visual order
    __out_ecount_full_opt(cRuns) int    *piLogicalToVisual);    // Out  List of visual run positions






/////   SCRIPT_JUSTIFY
//
//      The script justification enumeration provides the client with the
//      glyph characteristic information it needs to implement justification.


typedef enum tag_SCRIPT_JUSTIFY {
    SCRIPT_JUSTIFY_NONE           = 0,   // Justification can't be applied at this glyph
    SCRIPT_JUSTIFY_ARABIC_BLANK   = 1,   // This glyph represents a blank in an Arabic run
    SCRIPT_JUSTIFY_CHARACTER      = 2,   // Inter-character justification point follows this glyph
    SCRIPT_JUSTIFY_RESERVED1      = 3,   // Reserved #1
    SCRIPT_JUSTIFY_BLANK          = 4,   // This glyph represents a blank outside an Arabic run
    SCRIPT_JUSTIFY_RESERVED2      = 5,   // Reserved #2
    SCRIPT_JUSTIFY_RESERVED3      = 6,   // Reserved #3
    SCRIPT_JUSTIFY_ARABIC_NORMAL  = 7,   // Normal Middle-Of-Word glyph that connects to the right (begin)
    SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8,   // Kashida(U+640) in middle of word
    SCRIPT_JUSTIFY_ARABIC_ALEF    = 9,   // Final form of Alef-like (U+627, U+625, U+623, U+632)
    SCRIPT_JUSTIFY_ARABIC_HA      = 10,  // Final form of Ha (U+647)
    SCRIPT_JUSTIFY_ARABIC_RA      = 11,  // Final form of Ra (U+631)
    SCRIPT_JUSTIFY_ARABIC_BA      = 12,  // Middle-Of-Word form of Ba (U+628)
    SCRIPT_JUSTIFY_ARABIC_BARA    = 13,  // Ligature of alike (U+628,U+631)
    SCRIPT_JUSTIFY_ARABIC_SEEN    = 14,  // Highest priority: Initial shape of Seen(U+633) (end)
    SCRIPT_JUSTIFY_ARABIC_SEEN_M  = 15,  // Reserved #4
} SCRIPT_JUSTIFY;



/////   SCRIPT_VISATTR
//
//      The visual (glyph) attribute buffer generated by ScriptShape
//      identifies clusters and justification points:


typedef struct tag_SCRIPT_VISATTR {
    WORD           uJustification   :4;  // Justification class
    WORD           fClusterStart    :1;  // First glyph of representation of cluster
    WORD           fDiacritic       :1;  // Diacritic
    WORD           fZeroWidth       :1;  // Blank, ZWJ, ZWNJ etc, with no width
    WORD           fReserved        :1;  // General reserved
    WORD           fShapeReserved   :8;  // Reserved for use by shaping engines
} SCRIPT_VISATTR;
//
//
//p     uJustification: Justification class for this glyph. See SCRIPT_JUSTIFY.
//
//p     fClusterStart: Set for the logically first glyph in every cluster,
//          even for clusters containing just one glyph.
//
//p     fDiacritic: Set for glyphs that combine with base characters.
//
//p     fZeroWidth: Set by the shaping engine for some, but not all, zero
//          width characters.


/////   ScriptShape
//
//      The ScriptShape function takes a Unicode run and generates glyphs and
//      visual attributes.
//
//      The number of glyphs generated varies according to the script and the
//      font. Only for simple scripts and fonts does each Unicode code point
//      generates a single glyph.
//
//      There is no limit on the number of glyphs generated by a codepoint.
//      For example, a sophisticated complex script font might choose to
//      constuct characters from components, and so generate many times as
//      many glyphs as characters.
//
//      There are also special cases like invalid character representations,
//      where extra glyphs are added to represent the invalid sequence.
//
//      A reasonable guess might be to provide a glyph buffer 1.5 times the
//      length of the character buffer, plus a 16 glyph fixed addition for
//      rare cases like invalid sequenece representation.
//
//      If ScriptShape returns E_OUTOFMEMORY it will be necessary to recall
//      it, possibly more than once, until a large enough buffer is found.


__checkReturn HRESULT WINAPI ScriptShape(
    HDC                                                     hdc,            // In    Optional (see under caching)
    __deref_inout_ecount(1) SCRIPT_CACHE                    *psc,           // InOut Cache handle
    __in_ecount(cChars) const WCHAR                         *pwcChars,      // In    Logical unicode run
    int                                                     cChars,         // In    Length of unicode run
    int                                                     cMaxGlyphs,     // In    Max glyphs to generate
    __inout_ecount(1) SCRIPT_ANALYSIS                       *psa,           // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) WORD           *pwOutGlyphs,   // Out   Output glyph buffer
    __out_ecount_full(cChars) WORD                          *pwLogClust,    // Out   Logical clusters
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) SCRIPT_VISATTR *psva,          // Out   Visual glyph attributes
    __out_ecount(1) int                                     *pcGlyphs);     // Out   Count of glyphs generated






/////
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxGlyphs) is
//          insufficient. Note that in this case, as in all error cases, the
//          content of all output parameters are undefined.
//
//p     psa: Pass the SCRIPT_ANALYSIS field of the SCRIPT_ITEM entry for this
//          item. (The SCRIPT_ITEM array is returned by ScriptItemize.)
//
//      Clusters are sequenced uniformly within the run, as are glyphs within
//      the cluster - the fRTL item flag (from ScriptItemize) identifies
//      whether left to right, or right to left.
//
//p     pwLogClust: has cChars elements - each entry in pwLogClust corresponds
//          to a character in the input string (pwcChars). The value in each
//          pwLogCLust entry is the offset of the first glyph in the cluster
//          that contains this character.
//
//      Example: In the following example, there are four clusters:
//      1st cluster: one character represented by one glyph
//      2nd cluster: one character represented by 3 glyphs
//      3rd cluster: three characters represented by one glyph
//      4th cluster: 2 characters represented by three glyphs
//
//      Glyph array: (c<n>g<m> means cluster n glyph m)
//c        0      1    2    3      4      5    6    7
//c     -------------------------------------------------
//c     | c1g1 | c2g1 c2g2 c2g3 | c3g1 | c4g1 c4g2 c4g3 |
//c     -------------------------------------------------
//
//      Character array: (c<n>u<m> means cluster n Unicode codepoint m)
//c        0      1      2    3    4      5    6
//c     --------------------------------------------
//c     | c1u1 | c2u1 | c3u1 c3u2 c3u3 | c4u1 c4u2 |
//c     --------------------------------------------
//
//      LogClust: (one entry per character gives 1st glyph in cluster
//c     --------------------------------------------
//c     |   0  |   1  |   4    4    4  |   5    5  |
//c     --------------------------------------------
//
//      Note that for an RTL run (SCRIPT_ANALYSIS.a.fRTL == TRUE) and when
//      fLogicalOrder == FALSE (the default), glyphs are generated in visual
//      order - the reverse of the codepoint order, and the values in the
//      LogClust array will be descending.
//
//
//p     psva: has one visual attribute per glyph and so has maxGlyphs entries.
//
//
//      ScriptShape may set the fNoGlyphIndex flag in psa if the font or
//      OS cannot support glyph indices.
//
//      If fLogicalOrder is requested in psa, glyphs will be always be
//      generated in the same order as the original Unicode characters.
//
//      If fLogicalOrder is not set, right to left items are generated in
//      reverse order, so ScriptTextOut does not need to reverse them before
//      calling ExtTextOut.
/////   ScriptPlace
//
//      The ScriptPlace function takes the output of a ScriptShape call and
//      generates glyph advance width and 2D offset information.
//
//      The composite ABC width for the whole item identifies how much the
//      glyphs overhang to the left of the start position and to the right of
//      the length implied by the sum of the advance widths.
//
//      The total advance width of the line is exactly abcA + abcB + abcC.
//
//      abcA and abcC are maintained internally by Uniscribe as proportions
//      of the cell height represented in 8 bits and are thus roughly +/- 1%.
//      The total width returned (as the sum of piAdvance, and as the sum of
//      abcA+abcB+abcC) is accurate to the resolution of the TrueType shaping
//      engine.
//
//      All glyph related arrays are in visual order unless the fLogicalOrder
//      flag is set in psa.


#ifndef LSDEFS_DEFINED
typedef struct tagGOFFSET {
    LONG  du;
    LONG  dv;
} GOFFSET;
#endif


__checkReturn HRESULT WINAPI ScriptPlace(
    HDC                                         hdc,        // In    Optional (see under caching)
    __deref_inout_ecount(1) SCRIPT_CACHE        *psc,       // InOut Cache handle
    __in_ecount(cGlyphs) const WORD             *pwGlyphs,  // In    Glyph buffer from prior ScriptShape call
    int                                         cGlyphs,    // In    Number of glyphs
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,      // In    Visual glyph attributes
    __inout_ecount(1) SCRIPT_ANALYSIS           *psa,       // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    __out_ecount_full(cGlyphs) int              *piAdvance, // Out   Advance wdiths
    __out_ecount_full_opt(cGlyphs) GOFFSET      *pGoffset,  // Out   x,y offset for combining glyph
    __out_ecount(1) ABC                         *pABC);     // Out   Composite ABC for the whole run (Optional)






/////   ScriptTextOut
//
//      The ScriptTextOut function takes the output of both ScriptShape and
//      ScriptPlace calls and calls the operating system ExtTextOut function
//      appropriately. If the last parameter is not null, GDI's ExtTextOutW calls
//      are routed to this function.
//
//      All arrays are in visual order unless the fLogicalOrder flag is set in
//      psa.


__checkReturn HRESULT WINAPI ScriptTextOut(
    const HDC                               hdc,            // In     OS handle to device context (required)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,           // InOut  Cache handle
    int                                     x,              // In     x,y position for first glyph
    int                                     y,              // In
    UINT                                    fuOptions,      // In     ExtTextOut options
    __in_ecount_opt(1) const RECT           *lprc,          // In     optional clipping/opaquing rectangle
    __in_ecount(1) const SCRIPT_ANALYSIS    *psa,           // In     Result of ScriptItemize
    __reserved const WCHAR                  *pwcReserved,   // In     Reserved (requires NULL)
    __reserved int                          iReserved,      // In     Reserved (requires 0)
    __in_ecount(cGlyphs) const WORD         *pwGlyphs,      // In     Glyph buffer from prior ScriptShape call
    int                                     cGlyphs,        // In     Number of glyphs
    __in_ecount(cGlyphs) const int          *piAdvance,     // In     Advance widths from ScriptPlace
    __in_ecount_opt(cGlyphs) const int      *piJustify,     // In     Justified advance widths (optional)
    __in_ecount(cGlyphs) const GOFFSET      *pGoffset);     // In     x,y offset for combining glyph






/////
//
//      The caller should normally use SetTextAlign(hdc, TA_RIGHT) before
//      calling ScriptTextOut with an RTL item inlogical order.
//
//      The piJustify array provides requested cell widths for each glyph.
//      When the piJustify width of a glyph differs from the unjustified
//      width (in PiAdvance), space is added to or removed from the glyph
//      cell at it's trailing edge. The glyph is always aligned with the
//      leading edge of it's cell. (This rule applies even in visual order.)
//
//      When a glyph cell is extended the extra space is uaually made up by
//      the addition of white space, however for Arabic scripts, the extra
//      space is made up by one or more kashida glyphs, unless the extra space
//      is insufficient for the shortest kashida glyph in the font. (The
//      width of the shortest kashida is available by calling
//      ScriptGetFontProperties.)
//
//      piJustify should only be passed if re-justification of the string is
//      required. Normally pass NULL to this parameter.
//
//      fuOptions may contain ETO_CLIPPED or ETO_OPAQUE (or neither or both).
//
//      Do not use ScriptTextOut to write to a metafile unless you are sure
//      that the metafile will eventually be played back without any font
//      substitution. ScriptTextOut record glyph numbers in the metafile.
//      Since glyph numbers vary considerably from one font to another
//      such a metafile is unlikely to play back correctly when differant
//      fonts are substituted.
//
//      For example when a metafile is played back at a different scale
//      CreateFont requests recorded in the metafile may resolve to bitmap
//      instead of truetype fonts, or if the metafile is played back on
//      a different machine requested fonts may not be installed.//
//
//      To write complex scripts in a metafile in a font independant manner,
//      use ExtTextOut to write the logical characters directly, so that
//      glyph generation and placement does not occur until the text is
//      played back.
/////   ScriptJustify
//
//      ScriptJustify provides a simple minded implementation of multilingual
//      justification.
//
//      Sophisticated text formatters may prefer to generate their own delta
//      dx array by combining their own features with the information returned
//      by ScriptShape in the SCRIPT_VISATTR array.
//
//      ScriptJustify establishes how much adjustment to make at each glyph
//      position on the line. It interprets the SCRIPT_VISATTR array generated
//      by a call to ScriptShape, and gives top priority to kashida, then uses
//      inter word spacing if there's no kashida points, then uses
//      intercharacter spacing if there are no inter-word points.
//
//      The justified advance widths generated in ScriptJustify should be
//      passed to ScriptTextOut in the piJustify paramter.
//
//      ScriptJustify creates a justify array containing updated advance
//      widths for each glyph. Where a glyphs advance width is increased, it
//      is expected that the extra width will be rendered to the right of the
//      glyph, with as white space or, for Arabic text, as kashida.
/////
__checkReturn HRESULT WINAPI ScriptJustify(
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Collected visual attributes for entire line
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths from ScriptPlace
    int                                         cGlyphs,        // In   Size of all arrays
    int                                         iDx,            // In   Desired width change, either increase or descrease
    int                                         iMinKashida,    // In   Minimum length of continuous kashida glyph to generate
    __out_ecount_full(cGlyphs) int              *piJustify);    // Out  Updated advance widths to pass to ScriptTextOut






/////   SCRIPT_LOGATTR
//
//      The SCRIPT_LOGATTR structure describes attributes of logical
//      characters useful when editing and formatting text.
//
//      Note that for wordbreaking and linebreaking, if the first character of
//      the run passed in is not whitespace, the client needs to check whether
//      the last character of the previous run is whitespace to determine if
//      the first character of this run is the start of a word.
//
//
typedef struct tag_SCRIPT_LOGATTR {
    BYTE    fSoftBreak      :1;     // Potential linebreak point
    BYTE    fWhiteSpace     :1;     // A unicode whitespace character, except NBSP, ZWNBSP
    BYTE    fCharStop       :1;     // Valid cursor position (for left/right arrow)
    BYTE    fWordStop       :1;     // Valid cursor position (for ctrl + left/right arrow)
    BYTE    fInvalid        :1;     // Invalid character sequence
    BYTE    fReserved       :3;
} SCRIPT_LOGATTR;
//
//
//p     fSoftBreak: It would be valid to break the line in front of this
//              character. This flag is set on the first character of
//              South-East Asian words. Note that when linebreaking the
//              client would usually also treat any nonblank following a blank
//              as a softbreak position, by inspecting the fWhiteSPace flag
//              below.
//
//p     fWhiteSpace: This character is one of the many Unicode character
//              that are classified as breakable whitespace.
//
//p     fCharStop: Valid cursor position. Set on most characters, but not
//              on codepoints inside Indian and South East Asian character
//              clusters. May be used to implement left and right arrow
//              operation in editors.
//
//p     fWordStop: Valid position following word advance/retire commonly
//              implemented at ctrl/left-arrow and ctrl/right-arrow.
//              May be used to implement ctrl+left and ctrl+right arrow
//              operation in editors. As with fSoftBreak clients should
//              normally also inspect the fWhiteSpace flag and treat the
//              first character after a run of whitespace as the start of a
//              word.
//
//p     fInvalid: Marks characters which form an invalid or undisplayable
//              combination. Scripts which can set this flag have the flag
//              fInvalidLogAttr set in their SCRIPT_PROPERTIES.






/////   ScriptBreak
//
//      The ScriptBreak function returns cursor movement and formatting break
//      positions for an item as an array of SCRIPT_LOGATTRs. To support
//      mixed formatting within a single word correctly, ScriptBreak should
//      be passed whole items as returned by ScriptItemize.
//
//      ScriptBreak does not require an hdc and does not execute glyph shaping.
//
//      The fCharStop flag marks cluster boundaries for those scripts where
//      it is conventional to restrict from moving inside clusters. The same
//      boundaries could also be inferred by inspecting the pLogCLust array
//      returned by ScriptShape, however ScriptBreak is considerably faster in
//      implementation and does not require an hdc to be prepared.
//
//      The fWordStop, fSoftBreak and fWhiteSpace flags are only available
//      through ScriptBreak.
//
//      Most shaping engines that identify invalid sequences do so by setting
//      the fInvalid flag in ScriptBreak. The fInvalidLogAttr flag in
//      ScriptProperties identifies which scripts do this.


__checkReturn HRESULT WINAPI ScriptBreak(
    __in_ecount(cChars) const WCHAR             *pwcChars,  // In   Logical unicode item
    int                                         cChars,     // In   Length of unicode item
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,       // In   Result of earlier ScriptItemize call
    __out_ecount_full(cChars) SCRIPT_LOGATTR    *psla);     // Out  Logical character attributes






/////   ScriptCPtoX
//
//      The ScriptCPtoX function returns the x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to either the leading
//      or the trailing edge of a logical character cluster.
//
//      iCP is the offset of any logical character in the cluster.
//
//      For scripts where the caret may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned X may be
//      an interpolated position for any codepoint in the line.
//
//      For scripts where the caret is conventionally snapped to the boundaries
//      of clusters, (e.g. Thai, Indian), the resulting X position will be
//      snapped to the requested edge of the cluster containing CP.


__checkReturn HRESULT WINAPI ScriptCPtoX(
    int                                         iCP,            // In   Logical character position in run
    BOOL                                        fTrailing,      // In   Which edge (default - leading)
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes array
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    int                                         *piX);          // Out  Resulting X position






/////   ScriptXtoCP
//
//      The ScriptXtoCP function converts an x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to a logical
//      character position and a flag that indicates whether the X position
//      fell in the leading or the trailing half of the character.
//
//      For scripts where the cursor may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned CP may be
//      for any codepoint in the line, and fTrailing will be either zero
//      or one.
//
//      For scripts where the cursor is conventionally snapped to the
//      boundaries of a cluster, the returned CP is always the position of
//      the logically first codepoint in a cluster, and fTrailing is either
//      zero, or the number of codepoints in the cluster.
//
//      Thus the appropriate cursor position for a mouse hit is always the
//      returned CP plus the value of fTrailing.
//
//      If the X positition passed is not in the item at all, the resulting
//      position will be the trailing edge of character -1 (for X positions
//      before the item), or the leading edge of character 'cChars' (for
//      X positions following the item).


__checkReturn HRESULT WINAPI ScriptXtoCP(
    int                                         iX,             // In   X offset from left of run
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    __out_ecount(1) int                         *piCP,          // Out  Resulting character position
    __out_ecount(1) int                         *piTrailing);   // Out  Leading or trailing half flag






/////   Relationship between caret positions, justifications points and clusters
//
//
//t     Job                              | Uniscribe support
//t     -------------------------------- | --------------------------------------------------------
//t     Caret move by character cluster  | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Line breaking between characters | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Caret move by word               | LOGATTR.fWordStop
//t     Line breaking between words      | LOGATTR.fWordStop
//t     Justification                    | VISATTR.uJustification
//
//
//
/////   Character clusters
//
//      Character clusters are glyph sequences that cannot be split between
//      lines.
//
//      Some languages (e.g. Thai, Indic) restrict caret placement to points
//      betwen clusters. This applies both to keyboard initiated caret
//      movement (e.g. cursor keys) and pointing and clicking with the mouse
//      (hit testing).
//
//      Uniscribe provides cluster information in both the visual and logical
//      attributes. If you've called ScriptShape you'll find the cluster
//      information represented both by sequences of the same value in the
//      pwLogClust array, and by the fClusterStart flag in the psva
//      SCRIPT_VISATTR array.
//
//      ScriptBreak also returns the fCharStop flag in the SCRIPT_LOGATTR
//      array to identify cluster positions.
//
//
//
/////   Word break points
//
//      Valid positions for moving the caret when moving in whole words are
//      marked by the fWordStop flag returned by ScriptBreak.
//
//      Valid positions for breaking lines between words are marked by the
//      fSoftBreak flag returned by ScriptBreak.
//
//
//
/////   Justification
//
//      Justification space or kashida should be inserted where identified by
//      the uJustificaion field of the SCRIPT_VISATTR.
//
//      When performing inter-character justification, insert extra space
//      only after glyphs marked with uJustify == SCRIPT_JUSTIFY_CHARACTER.
//
//
//
/////   Script specific processing
//
//      Uniscribe provides information about special processing for each
//      script in the SCRIPT_PROPERTIES array.
//
//      Use the following code during initialisation to get a pointer to
//      the SCRIPT_PROPERTIES array:
//
//c     const SCRIPT_PROPERTIES **g_ppScriptProperties; // Array of pointers to properties
//c     int iMaxScript;
//c     HRESULT hr;
//
//c     hr = ScriptGetProperties(&g_ppScriptProperties, &g_iMaxScript);
//
//      Then inspect the properties of the script of an item 'iItem' as follows:
//
//c     hr = ScriptItemize( ... , pItems, ... );
//c     ...
//c     if (g_ppScriptProperties[pItems[iItem].a.eScript]->fNeedsCaretInfo) {
//c         // Use ScriptBreak to restrict the caret from entering clusters (for example).
//c     }
//
//
//      SCRIPT_PROPERTIES.fNeedsCaretInfo
//
//      Caret placement should be restricted to cluster
//      edges for scripts such as Thai and Indian. The fNeedsCaretInfo flag
//      in SCRIPT_PROPERTIES identifies such languages.
//
//      Note that ScriptXtoCP and ScriptCPtoX automatically apply caret
//      placement restictions.
//
//
//      SCRIPT_PROPERTIES.fNeedsWordBreaking
//
//      For most scripts, word break placement  may be
//      identified by scanning for characters marked as fWhiteSpace in
//      SCRIPT_LOGATTR, or for glyphs marked as uJustify ==
//      SCRIPT_JUSTIFY_BLANK or SCRIPT_JUSTIFY_ARABIC_BLANK in SCRIPT_VISATTR.
//
//      For languages such as Thai, it is also necessary to call ScriptBreak,
//      and include character positions marked as fWordStop in SCRIPT_LOGATTR.
//      Such scripts are marked as fNeedsWordbreaking in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fNeedsCharacterJustify
//
//      Languages such as Thai also require inter-character spacing when
//      justifying (where uJustify == SCRIPT_JUSTIFY_CHARACTER in the
//      SCRIPT_VISATTR). Such languages are marked as fNeedsCharacterJustify
//      in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fAmbiguousCharSet
//
//      Many Uniscribe scripts do not correspond directly to 8 bit character
//      sets. For example Unicode characters in the range U+100 through U+024F
//      represent extended latin shapes used for many languages, including
//      those supported by EASTEUROPE_CHARSET, TURKISH_CHARSET and
//      VIETNAMESE_CHARSET. However many of these characters are supported by
//      more han one of thsese charsets.
//      fAmbiguousCharset is set for any script token which could contain
//      characters from a number of these charsets. In these cases the bCharSet
//      field may contain ANSI_CHARSET or DEFAULT_CHARSET. The Uniscribe client
//      will generally need to apply futher processing to determine which charset
//      to use when requesting a font suitable for this run. For example it
//      determine that the run consists of multiple languages and split it up
//      to use a different font for each language.






/////   Notes on ScriptXtoCP and ScriptCPtoX
//
//      Both functions work only within runs and require the results of a
//      previous ScriptShape call.
//
//      The client must establish which run a given cursor offset or x
//      position is within before passing it to ScriptCPtoX or ScriptXtoCP.
//
//      Cluster information in the logical cluster array is used to share
//      the width of a cluster of glyphs equally among the logical characters
//      they represent.
//
//      For example, the lam alif glyph is divided into four areas: the
//      leading half of the lam, the trailing half of the lam, the leading
//      half of the alif and the trailing half of the alif.
//
//      ScriptXtoCP Understands the caret position conventions of each script.
//      For Indian and Thai, caret positions are snapped to cluster boundaries,
//      for Arabic and Hebrew, caret positions are interpolated within clusters.
//
//
/////   Translating mouse hit 'x' offset to caret position
//
//      Conventionally, caret position 'cp' may be selected by clicking either
//      on the trailing half of character 'cp-1' or on the leading half of
//      character 'cp'. This may easily be implemented as follows:
//
//c     int iCharPos;
//c     int iCaretPos
//c     int fTrailing;
//
//c     ScriptXtoCP(iMouseX, ..., &iCharPos, &fTrailing);
//c     iCaretPos = iCharPos + fTrailing;
//
//      For scripts that snap the caret to cluster boundaries, ScriptXtoCP
//      returns ftrailing set to either 0, or the width of the cluster in
//      codepoints. Thus the above code correctly returns only valid
//      caret positions.
//
//
/////   Displaying the caret in bidi strings
//
//      In unidirectional text, the leading edge of a character is at the same
//      place as the trailing edge of the previous character, so there is no
//      ambiguity in placing the caret between characters.
//
//      In bidirectional text, the caret position between runs of opposing
//      direction may be ambiguous.
//
//      For example in the left to right paragraph 'helloMAALAS', the last
//      letter of 'hello' immediately preceeds the first letter of 'salaam'.
//      The best position to display the caret depends on whether it is
//      considered to follow the 'o' of 'hello', or to preceed the 's' of
//      'salaam'.
//
/////   Commonly used caret positioning conventions
//
//t     Situation       | Visual caret placement
//t     ---------       | -------------------------------------------
//t     Typing          | Trailing edge of last character typed
//t     Pasting         | Trailing edge of last character pasted
//t     Caret advancing | Trailing edge of last character passed over
//t     Caret retiring  | Leading edge of last character passed over
//t     Home            | Leading edge of line
//t     End             | Trailing edge of line
//
//      The caret may be positioned as follows:
//
//c     if (advancing) {
//c         ScriptCPtoX(iCharPos-1, TRUE, ..., &iCaretX);
//c     } else {
//c         ScriptCPtoX(iCharPos, FALSE, ..., &iCaretX);
//c     }
//
//      Or, more simply, given an fAdvancing BOOL restricted to TRUE or FALSE:
//
//c     ScriptCPtoX(iCharPos-fAdvancing, fAdvancing, ..., &iCaretX);
//
//      ScriptCPtoX handles out of range positions logically: it returns the
//      leading edge of the run for iCharPos <0, and the trailing edge of the
//      run for iCharPos >=length.
/////   ScriptGetLogicalWidths
//
//      Converts visual withs in piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Ligature glyphs widths are divided evenly amongst the characters
//      they represent.


__checkReturn HRESULT WINAPI ScriptGetLogicalWidths(
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cGlyphs) const int              *piGlyphWidth,  // In   Advance widths
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes
    __in_ecount(cChars) int                     *piDx);         // Out  Logical widths






/////
//      ScriptGetLogicalWidths is useful for recording widths in a
//      font independant manner. By passing the recorded logical widths
//      to ScriptApplyLogicalWidths, a block of text can be replayed in the
//      same boundaries with acceptable loss of quality even when the original
//      font is not available.
/////   ScriptApplyLogicalWidth
//
//      Accepts an array of advance widths in logical order, corresponding
//      one to one with codepoints, and generates an array of glyph widths
//      suitable for passing to the piJustify parameter of ScriptTextOut.
//
//      ScriptApplyLogicalWidth may be used to reapply logical widths
//      obtained with ScriptGetLogicalWidths. It may be useful in situations
//      such as metafiling, where it is necessary to record and reapply
//      advance width information in a font independant manner.



__checkReturn HRESULT WINAPI ScriptApplyLogicalWidth(
    __in_ecount(cChars) const int               *piDx,          // In     Logical dx array to apply
    int                                         cChars,         // In     Count of logical codepoints in run
    int                                         cGlyphs,        // In     Glyph count
    __in_ecount(cChars) const WORD              *pwLogClust,    // In     Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In     Visual attributes from ScriptShape/Place
    __in_ecount(cGlyphs) const int              *piAdvance,     // In     Glyph advance widths from ScriptPlace
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In     Script analysis from item attributes
    __inout_ecount_opt(1) ABC                   *pABC,          // InOut  Updated item ABC width (optional)
    __out_ecount_full(cGlyphs) int              *piJustify);    // Out    Resulting glyph advance widths for ScriptTextOut






/////
//p     piDx: Pointer to an array of dx widths in logical order, one per codepoint.
//
//p     cChars: Count of the logical codepoints in the run.
//
//p     cGlyphs: Glyph count.
//
//p     pwLogClust: Pointer to an array of logical clusters from ScriptShape
//
//p     psva: Pointer to an array of visual attributes from ScriptShape and
//          updated by ScriptPlace.
//
//p     piAdvance: Pointer to an array of glyph advance widths from ScriptPlace.
//
//p     psa: Pointer to a SCRIPT_ANALYSIS structure from ScriptItemize and
//          updated by ScriptShape and SriptPlace..
//
//p     pABC: Pointer to the run overall ABC width (optional). If present,
//          when the function is called, it should contain the run ABC width
//          returned by ScriptPlace; when the function returns, the ABC width
//          has been updated to match the new widths.
//
//p     piJustify:Pointer to an array of the resulting glyph advance widths.
//          This is suitable for passing to the piJustify parameter of ScriptTextOut.
/////   ScriptGetCMap
//
//      ScriptGetCMap may be used to determine which characters in a run
//      are supported by the selected font.
//
//      It returns glyph indices of Unicode characters according to Truetype
//      Cmap table, or standard Cmap implemented for old style fonts. The
//      glyph indices are returned in the same order as the input string.
//
//      The caller may scan the returned glyph buffer looking for the default
//      glyph to determine which characters are not available. (The default
//      glyph index for the selected font should be determined by calling
//      ScriptGetFontProperties).
//
//      The return value indicates the presence of any missing glyphs.


#define SGCM_RTL  0x00000001      // Return mirrored glyph for mirrorable Unicode codepoints


__checkReturn HRESULT WINAPI ScriptGetCMap(
    HDC                                     hdc,            // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,           // InOut Address of Cache handle
    __in_ecount(cChars) const WCHAR         *pwcInChars,    // In    Unicode codepoint(s) to look up
    int                                     cChars,         // In    Number of characters
    DWORD                                   dwFlags,        // In    Flags such as SGCM_RTL
    __out_ecount(cChars) WORD               *pwOutGlyphs);  // Out   Array of glyphs, one per input character






/////
//  returns S_OK     - All unicode codepoints were present in the font
//          S_FALSE  - Some of the Unicode codepoints were mapped to the default glyph
//          E_HANDLE - font or system does not support glyph indices
/////   ScriptGetGlyphABCWidth
//
//      Returns ABC width of a given glyph.
//      May be useful for drawing glyph charts. Should not be used for
//      run of the mill complex script text formatting.


__checkReturn HRESULT WINAPI ScriptGetGlyphABCWidth(
    HDC                                     hdc,        // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,       // InOut Address of Cache handle
    WORD                                    wGlyph,     // In    Glyph
    __out_ecount(1) ABC                     *pABC);     // Out   ABC width






/////
//  returns S_OK     - Glyph width returned
//          E_HANDLE - font or system does not support glyph indices
/////   SCRIPT_PROPERTIES
//
typedef struct {
    DWORD   langid                 :16; // Primary and sublanguage associated with script
    DWORD   fNumeric               :1;
    DWORD   fComplex               :1;  // Script requires special shaping or layout
    DWORD   fNeedsWordBreaking     :1;  // Requires ScriptBreak for word breaking information
    DWORD   fNeedsCaretInfo        :1;  // Requires caret restriction to cluster boundaries
    DWORD   bCharSet               :8;  // Charset to use when creating font
    DWORD   fControl               :1;  // Contains only control characters
    DWORD   fPrivateUseArea        :1;  // This item is from the Unicode range U+E000 through U+F8FF
    DWORD   fNeedsCharacterJustify :1;  // Requires inter-character justification
    DWORD   fInvalidGlyph          :1;  // Invalid combinations generate glyph wgInvalid in the glyph buffer
    DWORD   fInvalidLogAttr        :1;  // Invalid combinations are marked by fInvalid in the logical attributes
    DWORD   fCDM                   :1;  // Contains Combining Diacritical Marks
    DWORD   fAmbiguousCharSet      :1;  // Script does not correspond 1:1 with a charset
    DWORD   fClusterSizeVaries     :1;  // Measured cluster width depends on adjacent clusters
    DWORD   fRejectInvalid         :1;  // Invalid combinations should be rejected
} SCRIPT_PROPERTIES;
//
//p     langid: Language associated with this script. When a script is used for many languages,
//          langid id represents a default language. For example, Western script is represented
//          by LANG_ENGLISH although it is also used for French, German, Spanish etc.
//
//p     fNumeric: Script contains numerics and characters used in conjunction with numerics
//          by the rules of the Unicode bidirectional algorithm. For example
//          dollar sign and period are classified as numeric when adjacent to or in between
//          digits.
//
//p     fComplex: Indicates a script that requires complex script handling. If fComplex is false
//          the script contains no combining characters and requires no contextual shaping or reordering.
//
//p     fNeedsWordBreaking: A script, such as Thai, which requires algorithmic wordbreaking.
//          Use ScriptBreak to obtain a wordbreak points using the standard system wordbreaker.
//
//p     fNeedsCaretInfo: A script, such as Thai and Indian, where the caret may not be placed
//          inside a cluster. To determine valid caret positions inspect the fCharStop flag in the
//          logical attributes returned by ScriptBreak, or compare adjacent values in the pwLogClust
//          array returned by ScriptShape.
//
//p     bCharSet: Nominal charset associated with script. May be used in a logfont when creating
//          a font suitable for displaying this script. Note that for new scripts where there
//          is no charset defined, bCharSet may be innapropriate and DEFAULT_CHARSET should
//          be used instead - see the description of fAmbiguousCharSet below.
//
//p     fControl: contains control characters.
//
//p     fPrivateUseArea: The Unicode range U+E000 through U+F8FF.
//
//p     fNeedsCharacterJustify: A script, such as Thai, where justification is conventionally
//          achieved by increasing the space between all letters, not just between words.
//
//p     fInvalidGlyph: A script for which ScriptShape generates an invalid glyph
//          to represent invalid sequences. The glyph index of the invalid glyph for
//          a particular font may be obtained by calling ScriptGetFontProperties.
//
//p     fInvalidLogAttr: A script for which ScriptBreak sets the fInvalid flag
//          in the logical attributes to mark invalid sequences.
//
//p     fCDM: Implies that an item analysed by ScriptItemize included combining
//          diacritical marks (U+0300 through U+36F).
//
//p     fAmbiguousCharSet: No single legacy charset supports this script.
//          For example the extended Latin Extended-A Unicode range includes
//          characters from the EASTUROPE_CHARSET, the TURKISH_CHARSET and the
//          BALTIC_CHARSET. It also contains characters that are not available
//          in any legacy charset. Use DEFAULT_CHARSET when creating fonts to
//          display parts of this run.
//
//p     fClusterSizeVaries: A script, such as Arabic, where contextual shaping
//          may cause a string to increase in size when removing characters.
//
//p     fRejectInvalid: A script, such as Thai, where invalid sequences conventionally
//          cause an editor such as notepad to beep, and ignore keypresses.


/////   ScriptGetProperties
//
//      ScriptGetProperties returns the address of a table that maps a
//      script in a SCRIPT_ANALYSIS uScript field to properties including
//      the primary language associated with that script, whether it's
//      numeric and whether it's complex.


__checkReturn HRESULT WINAPI ScriptGetProperties(
    __deref_out_ecount(1) const SCRIPT_PROPERTIES   ***ppSp,        // Out  Receives pointer to table of pointers to properties indexed by script
    __out_ecount(1) int                             *piNumScripts); // Out  Receives number of scripts (valid values are 0 through NumScripts-1)






/////   SCRIPT_FONTPROPERTIES
//
typedef struct {
    int     cBytes;         // Structure length
    WORD    wgBlank;        // Blank glyph
    WORD    wgDefault;      // Glyph used for Unicode values not present in the font
    WORD    wgInvalid;      // Glyph used for invalid character combinations (especially in Thai)
    WORD    wgKashida;      // Shortest continuous kashida glyph in the font, -1 if doesn't exist
    int     iKashidaWidth;  // Widths of shortest continuous kashida glyph in the font
} SCRIPT_FONTPROPERTIES;


/////   ScriptGetFontProperties
//
//      Returns information from the font cache


__checkReturn HRESULT WINAPI ScriptGetFontProperties(
    HDC                                     hdc,    // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,   // InOut Address of Cache handle
    __out_ecount(1) SCRIPT_FONTPROPERTIES   *sfp);  // Out   Receives properties for this font






/////   ScriptCacheGetHeight
//
//


__checkReturn HRESULT WINAPI ScriptCacheGetHeight(
    HDC                                     hdc,        // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,       // InOut Address of Cache handle
    __out_ecount(1) long                    *tmHeight); // Out   Receives font height in pixels






/////   ScriptStringAnalyse
//
//
#define SSA_PASSWORD         0x00000001  // Input string contains a single character to be duplicated iLength times
#define SSA_TAB              0x00000002  // Expand tabs
#define SSA_CLIP             0x00000004  // Clip string at iReqWidth
#define SSA_FIT              0x00000008  // Justify string to iReqWidth
#define SSA_DZWG             0x00000010  // Provide representation glyphs for control characters
#define SSA_FALLBACK         0x00000020  // Use fallback fonts
#define SSA_BREAK            0x00000040  // Return break flags (character and word stops)
#define SSA_GLYPHS           0x00000080  // Generate glyphs, positions and attributes
#define SSA_RTL              0x00000100  // Base embedding level 1
#define SSA_GCP              0x00000200  // Return missing glyphs and LogCLust with GetCharacterPlacement conventions
#define SSA_HOTKEY           0x00000400  // Replace '&' with underline on subsequent codepoint
#define SSA_METAFILE         0x00000800  // Write items with ExtTextOutW Unicode calls, not glyphs
#define SSA_LINK             0x00001000  // Apply FE font linking/association to non-complex text
#define SSA_HIDEHOTKEY       0x00002000  // Remove first '&' from displayed string
#define SSA_HOTKEYONLY       0x00002400  // Display underline only.

#define SSA_FULLMEASURE      0x04000000  // Internal - calculate full width and out the number of chars can fit in iReqWidth.
#define SSA_LPKANSIFALLBACK  0x08000000  // Internal - enable FallBack for all LPK Ansi calls Except BiDi hDC calls
#define SSA_PIDX             0x10000000  // Internal
#define SSA_LAYOUTRTL        0x20000000  // Internal - Used when DC is mirrored
#define SSA_DONTGLYPH        0x40000000  // Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning
#define SSA_NOKASHIDA        0x80000000  // Internal - Used by GCP to justify the non Arabic glyphs only.
//
//
//p     SSA_HOTKEY: Note that SSA_HOTKEY and SSA_HIDEHOTKEY remove the
//          hotkey '&' character from further processing, so functions
//          such as ScriptString_pLogAttr return arrays based on a string
//          which excludes the '&'.




/////   SCRIPT_TABDEF
//
//      Defines tabstop positions for ScriptStringAnalyse (ignored unless SSA_TAB passed)
//
typedef struct tag_SCRIPT_TABDEF {
    int   cTabStops;        // Number of entries in pTabStops array
    int   iScale;           // Scale factor for pTabStops (see below)
    int  *pTabStops;        // Pointer to array of one or more tab stops
    int   iTabOrigin;       // Initial offset for tab stops (logical units)
} SCRIPT_TABDEF;
//
//
//p     cTabStops: Number of entries in the pTabStops array. If zero, tabstops
//          are every 8 average character widths. If one, all tabstops are
//          the length of the first entry in pTabStops. If more than one,
//          the first cTabStops are as specified in the pTabStops array,
//          subsequent tabstops are every 8 average characters from the last
//          tabstop in the array.
//
//p     iScale: Scale factor for iTabOrigin and pTabStops entries. Values are
//          converted to device coordinates by multiplying by iScale then
//          dividing by 4. If values are already in device units, set iScale to
//          4. If values are in dialog units, set iScale to the average char
//          width of the dialog font. If values are multiples of the average
//          character width for the selected font, set iScale to 0.
//
//p     pTabStops: Array of cTabStops entries. Each entry specifies a
//          tabstop position. Positive values give nearedge alignment,
//          negative values give faredge alignment.
//
//p     iTabOrigin: Tabs are considered to start iTabOrigin before the
//          beginning of the string. Helps with multiple tabbed
//          outputs on the same line.






/////   ScriptStringAnalyse
//
//      cString - Input string must contain at least one character
//
//      hdc - required if SSA_GLYPH requested. Optional for SSA_BREAK.
//      If present the current font in the hdc is inspected and if a symbolic
//      font the character string is treated as a single neutral SCRIPT_UNDEFINED item.
//
//      Note that the uBidiLevel field in the initial SCRIPT_STATE value
//      is ignored - the uBidiLevel used is derived from the SSA_RTL
//      flag in combination with the layout of the hdc.


typedef void* SCRIPT_STRING_ANALYSIS;


__checkReturn HRESULT WINAPI ScriptStringAnalyse(
    HDC                                             hdc,        //In  Device context (required)
    const void                                      *pString,   //In  String in 8 or 16 bit characters
    int                                             cString,    //In  Length in characters (Must be at least 1)
    int                                             cGlyphs,    //In  Required glyph buffer size (default cString*1.5 + 16)
    int                                             iCharset,   //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD                                           dwFlags,    //In  Analysis required
    int                                             iReqWidth,  //In  Required width for fit and/or clip
    __in_ecount_opt(1) SCRIPT_CONTROL               *psControl, //In  Analysis control (optional)
    __in_ecount_opt(1) SCRIPT_STATE                 *psState,   //In  Analysis initial state (optional)
    __in_ecount_opt(cString) const int              *piDx,      //In  Requested logical dx array
    __in_ecount_opt(1) SCRIPT_TABDEF                *pTabdef,   //In  Tab positions (optional)
    const BYTE                                      *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)
    __deref_out_ecount(1) SCRIPT_STRING_ANALYSIS    *pssa);     //Out Analysis of string






/////   ScriptStringFree - free a string analysis
//
//


__checkReturn HRESULT WINAPI ScriptStringFree(
    __deref_inout_ecount(1) SCRIPT_STRING_ANALYSIS  *pssa);  //InOut Address of pointer to analysis






/////   ScriptStringSize
//
//      returns a pointer to the size (width and height) of an analysed string
//
//      Note that the SIZE pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const SIZE* WINAPI ScriptString_pSize(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pcOutChars
//
//      returns pointer to length of string after clipping (requires SSA_CLIP set)
//
//      Note that the int pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const int* WINAPI ScriptString_pcOutChars(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pLogAttr
//
//      returns pointer to logical attributes buffer in a SCRIPT_STRING_ANALYSIS
//
//      Note that the buffer pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.
//
//      The logical attribute array contains *ScriptString_pcOutChars(ssa)
//      entries.


const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttr(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringGetOrder
//
//      Creates an array mapping original character position to glyph position.
//
//      Treats clusters as they were in legacy systems - Unless a cluster
//      contains more glyphs than codepoints, each glyph is referenced at
//      least once from the puOrder array.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The puOrder parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


__checkReturn HRESULT WINAPI ScriptStringGetOrder(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,
    UINT                                    *puOrder); 






/////   ScriptStringCPtoX
//
//      Return x coordinate for leading or trailing edge of character icp.


__checkReturn HRESULT WINAPI ScriptStringCPtoX(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,        //In  String analysis
    int                                     icp,        //In  Caret character position
    BOOL                                    fTrailing,  //In  Which edge of icp
    __out_ecount(1) int                     *pX);       //Out Corresponding x offset






/////   ScriptStringXtoCP
//
//


__checkReturn HRESULT WINAPI ScriptStringXtoCP(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,            // In
    int                                     iX,             // In
    __out_ecount(1) int                     *piCh,          // Out
    __out_ecount(1) int                     *piTrailing);   // Out






/////   ScriptStringGetLogicalWidths
//
//      Converts visual withs in psa->piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The piDx parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


__checkReturn HRESULT WINAPI ScriptStringGetLogicalWidths(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,
    int                                     *piDx); 






/////   ScriptStringValidate
//
//      Scans the string analysis for invalid glyphs.
//
//      Only glyphs generated by scripts that can generate invalid glyphs
//      are scanned.
//
//      returns S_OK    - no invalid glyphs are present
//              S_FALSE - one or more invalid glyphs are present


__checkReturn HRESULT WINAPI ScriptStringValidate(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringOut
//
//      Displays the string generated by a prior ScriptStringAnalyze call,
//      then optionally adds highlighting corresponding to a logical selection.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.


__checkReturn HRESULT WINAPI ScriptStringOut(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,            //In  Analysis with glyphs
    int                                     iX,             //In
    int                                     iY,             //In
    UINT                                    uOptions,       //In  ExtTextOut options
    __in_ecount_opt(1) const RECT           *prc,           //In  Clipping rectangle (iff ETO_CLIPPED)
    int                                     iMinSel,        //In  Logical selection. Set iMinSel>=iMaxSel for no selection
    int                                     iMaxSel,        //In
    BOOL                                    fDisabled);     //In  If disabled, only the background is highlighted.






/////
//      uOptions may nclude only ETO_CLIPPED or ETO_OPAQUE.
/////   ScriptIsComplex
//
//      Determines whether a Unicode string requires complex script processing
//
//      The dwFlags parameter may include the following requests
//
#define SIC_COMPLEX     1   // Treat complex script letters as complex
#define SIC_ASCIIDIGIT  2   // Treat digits U+0030 through U+0039 as complex
#define SIC_NEUTRAL     4   // Treat neutrals as complex
//
//      SIC_COMPLEX: Should normally set. Causes complex script letters to
//      be treated as complex.
//
//      SIC_ASCIIDIGIT: Set this flag if the string would be displayed with
//      digit substitution enabled. If you are following the users NLS
//      settings using the ScriptRecordDigitSubstitution API, you can pass
//      scriptDigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE.
//
//      SIC_NEUTRAL: Set this flag if you may be displaying the string with
//      right-to-left reading order. When this flag is set, neutral characters
//      are considered as complex.
//
//
//      Returns S_OK     if string requires complex script processing,
//              S_FALSE  if string contains only characters laid out side by
//                       side from left to right.


__checkReturn HRESULT WINAPI ScriptIsComplex(
    __in_ecount(cInChars) const WCHAR   *pwcInChars,    //In  String to be tested
    int                                 cInChars,       //In  Length in characters
    DWORD                               dwFlags);       //In  Flags (see above)






/////   ScriptRecordDigitSubstitution
//
//      Reads NLS native digit and digit substitution settings and records
//      them in the SCRIPT_DIGITSUBSTITUTE structure.
//
//
typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
    DWORD  NationalDigitLanguage    :16;   // Language for native substitution
    DWORD  TraditionalDigitLanguage :16;   // Language for traditional substitution
    DWORD  DigitSubstitute          :8;    // Substitution type
    DWORD  dwReserved;                     // Reserved
} SCRIPT_DIGITSUBSTITUTE;
//
//
//p     NationalDigitLanguage: Standard digits for the selected locale as
//          defined by the countries standard setting authority.
//
//p     TraditionalDigitLangauge: Digits originally used with the locales
//          script.
//
//p     DigitSubstitute: Selects between None, Context, National and
//          Traditional. See ScriptApplyDigitSubstitution below for
//          constant definitions.
//
//      Although most complex scripts have their own associated digits, many
//      countries using those scripts use western (so called
//      'Arabic') digits as their standard. NationalDigitLanguage reflects the
//      digits used as standard, and is set from
//      the NLS data for the locale.
//      On Windows 2000 the national digit langauge can be
//      adjusted to any digit script with the control panel/regional
//      options/numbers/Standard digits listbox.
//
//      The TraditionalDigitLanguage for a locale is derived directly from the
//      script used by that locale.


__checkReturn HRESULT WINAPI ScriptRecordDigitSubstitution(
    LCID                                    Locale,     // In   LOCALE_USER_DEFAULT or desired locale
    __out_ecount(1) SCRIPT_DIGITSUBSTITUTE  *psds);     // Out  Digit substitution settings






/////
//p     Locale: NLS locale to be queried. Should usually be set to
//          LOCALE_USER_DEFAULT. Alternatively may be passed as a locale
//          combined with LOCALE_NOUSEROVERRIDE to obtain default settings
//          for a given locale. Note that context digit substitution is
//          supported only in ARABIC and FARSI locales. In other locales,
//          context digit is mapped to no substitution.
//
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE. This structure may be passed
//          later to ScriptApplyDigitSubstitution.
//
//p     returns: E_INVALIDARG if Locale is invalid or not installed. E_POINTER
//          if psds is NULL. Otherwise S_OK.
//
//      For performance reasons, you should not call
//      ScriptRecordDigitSubstitution frequently. In particular it would be a
//      considerable overhead to call it every time you call ScriptItemize
//      or ScriptStringAnalyse.
//
//      Instead, you may choose to save the SCRIPT_DIGITSUBSTITUTE
//      structure, and update it only when you receive a
//      WM_SETTINGCHANGE message or when a RegNotifyChangeKeyValue
//      call in a dedicated thread indicates a change in the registry
//      under HKCU\Control Panel\\International.
//
//      The normal way to call this function is simply
//
//c     SCRIPT_DIGITSUBSTITUTE sds;
//c     ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
//
//      Then every time you itemize, you'd use the results like this:
//
//c     SCRIPT_CONTROL  sc = {0};
//c     SCRIPT_STATE    ss = {0};
//
//c     ScriptApplyDigitSubstitution(&sds, &sc, &ss);
//
//
/////   ScriptApplyDigitSubstitution
//
//      Aplies the digit substitution settings recorded in a
//      SCRIPT_DIGIT_SUBSTITUTE structure to the SCRIPT_CONTROL and
//      SCRIPT_STATE structures.
//
//      The DigitSubstitute field of the SCRIPT_DIGITSUBSTITUTE structure
//      is normally set by ScriptRecordDigitSubstitution, however it may
//      be replaced by any one of the following values:
//
//
#define SCRIPT_DIGITSUBSTITUTE_CONTEXT      0  // Substitute to match preceeding letters
#define SCRIPT_DIGITSUBSTITUTE_NONE         1  // No substitution
#define SCRIPT_DIGITSUBSTITUTE_NATIONAL     2  // Substitute with official national digits
#define SCRIPT_DIGITSUBSTITUTE_TRADITIONAL  3  // Substitute with traditional digits of the locale
//
//
//p     SCRIPT_DIGITSUBSTITUTE_CONTEXT: Digits U+0030 - U+0039 will be
//          substituted according to the language of prior letters. Before
//          any letters, digits will be substituted according to the
//          TraditionalDigitLangauge field of the SCRIPT_DIGIT_SUBSTITUTE
//          structure. This field is normally set to the primary language of
//          the Locale passed to ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_NONE: Digits will not be substituted. Unicode
//          values U+0030 to U+0039 will be displayed with Arabic (i.e.
//          Western) numerals.
//
//p     SCRIPT_DIGITSUBSTITUTE_NATIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the NationalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the national digits returned for the NLS LCTYPE
//          LOCALE_SNATIVEDIGITS by ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_TRADITIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the TraditionalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the primary language of the Locale passed to
//          ScriptRecordDigitSubstitution.


__checkReturn HRESULT WINAPI ScriptApplyDigitSubstitution(
    __in_ecount(1) const SCRIPT_DIGITSUBSTITUTE *psds,  // In   Digit substitution settings
    __out_ecount(1) SCRIPT_CONTROL              *psc,   // Out  Script control structure
    __out_ecount(1) SCRIPT_STATE                *pss);  // Out  Script state structure






/////
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE structure recorded earlier.
//          If NULL, ScriptApplyDigitSubstitution calls
//          ScriptRecordDigitSubstitution with LOCALE_USER_DEFAULT.
//
//p     psc: SCRIPT_CONTROL structure. The fContextDigits and uDefaultLanguage
//          fields will be updated.
//
//p     pss: SCRIPT_CONTROL structure. The fDigitSubstitute field will be
//          updated.
//
//p     returns: E_INVALIDARG if the DigitSubstitute field of the
//          SCRIPT_DIGITSUBSTITUTE structure is unrecognised, else S_OK;



//******************************************************
//
//          OpenType enabled Uniscribe APIs
//
//******************************************************

#ifndef UNISCRIBE_OPENTYPE
#if (_WIN32_WINNT >= 0x0600)
#define UNISCRIBE_OPENTYPE 0x0100
#endif
#endif

#if (UNISCRIBE_OPENTYPE >= 0x0100)

// 4-byte OpenType tag used to identify Script, LangSys or Feature
typedef ULONG OPENTYPE_TAG;

// Undefined script tag.
#define SCRIPT_TAG_UNKNOWN   0x00000000

// Single OpenType feature
typedef struct opentype_feature_record{

    OPENTYPE_TAG    tagFeature;     // Feature tag
    LONG            lParameter;     // Feature parameter (0 - disabled)

} OPENTYPE_FEATURE_RECORD;

// Set of OpenType properties applied to the range of characters
typedef struct textrange_properties{

    OPENTYPE_FEATURE_RECORD   *potfRecords;
    int                        cotfRecords;

} TEXTRANGE_PROPERTIES;

//
// Character properties
//
// Used by shaping engines to pass shaping information between calls
//
typedef struct script_charprop{

    WORD           fCanGlyphAlone : 1;

    WORD           reserved       : 15; // Reserved

} SCRIPT_CHARPROP;

//
// Glyph properties
//
typedef struct script_glyphprop{

    SCRIPT_VISATTR sva;
    WORD           reserved; // Reserved

} SCRIPT_GLYPHPROP;

// 
// ScriptShapeOpenType
// 
// New parameters comparing to ScriptShape:
//
// tagScript            - script tag to be used by OpenType layout
// tagLangSys           - language system tag to be used by OpenType layout
// rcRangeChars         - Number of characters in each range
//                                          (total should be equal to cChars)
//
// rpRangeProperties     - Range properties for each range
//
// cRanges              - Number of ranges
//
//
// New output parameters:
//
// pCharProps           - array of character properties, generated by Uniscribe
//
// pGlyphProps          - array of glyph properties, replaces visual attributes (4 bytes now)
// pfCanGlyphAlone      - flag per character, indicate that char can be shaped independently 
//
__checkReturn HRESULT WINAPI ScriptShapeOpenType(
    __in_opt                   HDC                     hdc,            // In    Optional (see under caching)
    __inout                    SCRIPT_CACHE           *psc,            // InOut Cache handle
    __inout                    SCRIPT_ANALYSIS        *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)

    __in                       OPENTYPE_TAG            tagScript,      // In    Font script tag for shaping
    __in                       OPENTYPE_TAG            tagLangSys,     // In    Font language system tag for shaping
    __in_ecount_opt(cRanges)   int                    *rcRangeChars,      // In    Array of number of characters per range
    __in_ecount_opt(cRanges)   TEXTRANGE_PROPERTIES  **rpRangeProperties, // In    Array of range properties (for each range)
    __in                       int                     cRanges,           // In    Number of ranges

    __in_ecount(cChars)        const WCHAR            *pwcChars,       // In    Logical unicode run
    __in                       int                     cChars,         // In    Length of unicode run
    __in                       int                     cMaxGlyphs,     // In    Max glyphs to generate

    __out_ecount_full(cChars)  WORD                   *pwLogClust,     // Out   Logical clusters
    __out_ecount_full(cChars)  SCRIPT_CHARPROP        *pCharProps,     // Out   Output buffer for character properties
    
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) WORD                   *pwOutGlyphs,    // Out   Output glyph buffer
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) SCRIPT_GLYPHPROP       *pOutGlyphProps, // Out   Visual glyph attributes
    __out                                    int                    *pcGlyphs);      // Out   Count of glyphs generated

// 
// ScriptPlaceOpenType
// 
// New parameters comparing to ScriptPlace:
//
// tagScript            - script tag to be used by OpenType layout
// tagLangSys           - language system tag to be used by OpenType layout
// rcRangeChars         - Number of characters in each range
//                                          (total should be equal to cChars)
//
// rpRangeProperties    - Range properties for each range
//
// cRanges              - Number of ranges
//
//
// New output parameters:
//
// Character information - pwcChars, pwLogClust, pCharProps are now passed to ScriptPlace
// pGlyphProps           - array of glyph properties, replaces visual attributes (4 bytes now)
//
__checkReturn HRESULT WINAPI ScriptPlaceOpenType(
    __in_opt                   HDC                     hdc,            // In    Optional (see under caching)
    __inout                    SCRIPT_CACHE           *psc,            // InOut Cache handle
    __inout                    SCRIPT_ANALYSIS        *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)

    __in                       OPENTYPE_TAG            tagScript,      // In    Font script tag for shaping
    __in                       OPENTYPE_TAG            tagLangSys,     // In    Font language system tag for shaping
    __in_ecount_opt(cRanges)   int                    *rcRangeChars,      // In    Array of number of characters per range
    __in_ecount_opt(cRanges)   TEXTRANGE_PROPERTIES  **rpRangeProperties, // In    Array of range properties (for each range)
    __in                       int                     cRanges,           // In    Number of ranges

    __in_ecount(cChars)        const WCHAR            *pwcChars,       // In    Logical unicode run
    __in_ecount(cChars)        WORD                   *pwLogClust,     // In    Logical clusters
    __in_ecount(cChars)        SCRIPT_CHARPROP        *pCharProps,     // In    Output buffer for character properties
    __in                       int                     cChars,         // In    Length of unicode run
    
    __in_ecount(cGlyphs)       const WORD             *pwGlyphs,       // In    Glyph buffer from prior ScriptShape call
    __in_ecount(cGlyphs)       const SCRIPT_GLYPHPROP *pGlyphProps,    // In    Glyph properties
    __in                       int                     cGlyphs,        // In    Number of glyphs
    
    __out_ecount_full(cGlyphs) int                    *piAdvance,      // Out   Advance widths
    __out_ecount_full(cGlyphs) GOFFSET                *pGoffset,       // Out   x,y offset for combining glyph
    __out_opt                  ABC                    *pABC);          // Out   Composite ABC for the whole run (Optional)

//
// ScriptItemizeOpenType
//
// New parameter comapring to ScriptItemize:
//
// pScriptTags -- array parallel to items, contains script tags
//                                              to be passed to ScriptShapeOpenType.
//
__checkReturn HRESULT WINAPI ScriptItemizeOpenType(
    __in_ecount(cInChars) const WCHAR                   *pwcInChars,    // In   Unicode string to be itemized
    __in                  int                            cInChars,      // In   Codepoint count to itemize
    __in                  int                            cMaxItems,     // In   Max length of itemization array
    __in_opt              const SCRIPT_CONTROL          *psControl,     // In   Analysis control (optional)
    __in_opt              const SCRIPT_STATE            *psState,       // In   Initial bidi algorithm state (optional)
    __out_ecount_part(cMaxItems, *pcItems) SCRIPT_ITEM  *pItems,        // Out  Array to receive itemization
    __out_ecount_part(cMaxItems, *pcItems) OPENTYPE_TAG *pScriptTags,   // Out  Array of script tags - parallel to items
    __out                 int                           *pcItems);      // Out  Count of items processed (optional)


// ScriptGetFontScriptList
// 
// Returns list of script tags supported by layout tables. 
// Only scripts that can be shaped by eScript will be returned ( or full list if psa==NULL).
// Usually complex scripts return single tag and neutral (like digits) return all tags from the font
//
// Note: If tag coresponding to some script is present it does not guarantee
//       that font won't be rejected by particular shaping engine because 
//       shaping engine may require particular language system or feature
//       to be present.
//
__checkReturn HRESULT WINAPI ScriptGetFontScriptTags(
    __in_opt           HDC                              hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE                    *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS                 *psa,             // In    Result of ScriptItemize (can be NULL)
    __in               int                              cMaxTags,        // In    Length of pScriptTags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG  *pScriptTags,     // Out:  list of script tags in the font
    __out              int                             *pcTags           // Out:  Number of tags returned
);

//
// ScriptGetFontLanguageTags
// 
// Returns list of language system tags supported by layout tables for particular script.
//
__checkReturn HRESULT WINAPI ScriptGetFontLanguageTags(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    
    __in               int                    cMaxTags,        // In    Length of pLangsys tags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG *pLangsysTags,    // Out:  list of Langsys tags in the font
    __out              int                   *pcTags           // Out:  Number of tags returned
);

//
// ScriptGetFontFeatureTags
// 
// Returns list of feature tags supported by layout tables for particular language system.
//
// This method will hide features that are language specific, because they are 
// controlled by shaping engines and can not be switched on or off by the client.
// Example of such features are initial, medial and final forms for Arabic script
//
// If psa==NULL function returns unfiltered feature list
//
__checkReturn HRESULT WINAPI ScriptGetFontFeatureTags(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    
    __in               int                    cMaxTags,        // In    Length of pLangsys tags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG *pFeatureTags,   // Out:  list of feature tags in the font
    __out              int                   *pcTags           // Out:  Number of tags returned
);

//
//  ScriptGetFontAlternateGlyphs
// 
//  Returns list alternates for particular glyph. 
//
//  Original glyph is always added as a first element. Index in this array 
//  is exactly the feature parameter that should be passed to ScriptShape.
//
//  To get variants it is a good idea to reshape input without feature 
//  applied to current glyph so it will be always alternates for default 
//  glyph for this position. Original glyph could have variants, while 
//  variants may not. So UI will stick with this final form wihtout ability 
//  to choose another one.
//
//  Note: It theoretically can be emulated by ScriptSubstituteSingleGlyph. 
//        Just try parameters one by one while glyphs are substituted.
//
__checkReturn HRESULT WINAPI ScriptGetFontAlternateGlyphs(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    
    __in               WORD                   wGlyphId,        // In    Original glyph
    
    __in               int                    cMaxAlternates,  // In    Length of pAlternateGlyphs tags array
    __out_ecount_part(cMaxAlternates, *pcAlternates) WORD *pAlternateGlyphs, // Out:  list of feature tags in the font
    __out              int                   *pcAlternates     // Out:  Number of alternates returned
);

//
//  ScriptSubstituteSingleGlyph
//
//  Apply partcular feature to single glyph, assuming that 
//  expected result is one-to-one substitution
//
__checkReturn HRESULT WINAPI ScriptSubstituteSingleGlyph(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    __in               LONG                   lParameter,      // In    Feature parameter

    __in               WORD                   wGlyphId,         // In    Original glyph id
    __out              WORD                  *pwOutGlyphId      // Out   Substituted glyph id
);

//
//  ScriptPositionSingleGlyph
//
//  Apply particular feature to single glyph, assuming that 
//  expected result is single position adjustment.
//
__checkReturn HRESULT WINAPI ScriptPositionSingleGlyph(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    __in               LONG                   lParameter,      // In    Feature parameter

    __in               WORD                   wGlyphId,         // In    Glyph id to be moved
    __in               int                    iAdvance,         // In    Original glyph advance width
    __in               GOFFSET                GOffset,          // In    Original glyph offset
    
    __out              int                   *piOutAdvance,     // Out   Adjusted advance width
    __out              GOFFSET               *pOutGoffset       // Out   Adjusted offset
);

#endif // (UNISCRIBE_OPENTYPE >= 0x0100)

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Uxtheme.h ===
//---------------------------------------------------------------------------
//
// uxtheme.h - theming API header file.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//---------------------------------------------------------------------------

#ifndef _UXTHEME_H_
#define _UXTHEME_H_

#include <commctrl.h>
#include <SpecStrings.h>

#ifndef THEMEAPI
#if !defined(_UXTHEME_)
#define THEMEAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define THEMEAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define THEMEAPI          STDAPI
#define THEMEAPI_(type)   STDAPI_(type)
#endif /* _UXTHEME_ */
#endif /* THEMEAPI */

typedef HANDLE HTHEME;          // handle to a section of theme data for class

#define MAX_THEMECOLOR  64
#define MAX_THEMESIZE   64

//---------------------------------------------------------------------------
// NOTE: PartId's and StateId's used in the theme API are defined in the 
//       hdr file <vssym32.h> using the TM_PART and TM_STATE macros.  For
//       example, "TM_PART(BP, PUSHBUTTON)" defines the PartId "BP_PUSHBUTTON".

//---------------------------------------------------------------------------
//  OpenThemeData()     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
OpenThemeData(
    HWND hwnd,
    LPCWSTR pszClassList
    );

#define OTD_FORCE_RECT_SIZING   0x00000001          // make all parts size to rect
#define OTD_NONCLIENT           0x00000002          // set if hTheme to be used for nonclient area
#define OTD_VALIDBITS           (OTD_FORCE_RECT_SIZING | \
                                 OTD_NONCLIENT)

//---------------------------------------------------------------------------
//  OpenThemeDataEx     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//
//  dwFlags              - allows certain overrides of std features
//                         (see OTD_XXX defines above)
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
OpenThemeDataEx(
    HWND hwnd,
    LPCWSTR pszClassList,
    DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  CloseThemeData()    - closes the theme data handle.  This should be done 
//                        when the window being themed is destroyed or
//                        whenever a WM_THEMECHANGED msg is received 
//                        (followed by an attempt to create a new Theme data 
//                        handle).
//
//  hTheme              - open theme data handle (returned from prior call
//                        to OpenThemeData() API).
//---------------------------------------------------------------------------
THEMEAPI
CloseThemeData(
    HTHEME hTheme
    );

//---------------------------------------------------------------------------
//    functions for basic drawing support 
//---------------------------------------------------------------------------
// The following methods are the theme-aware drawing services.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// For the list of all themed classes and the definition of all
// parts and states, see the file "tmschmea.h".
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Note: draw operations are always scaled to fit (and not to exceed)  
// the specified "Rect".
//-----------------------------------------------------------------------

//------------------------------------------------------------------------
//  DrawThemeBackground()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pClipRect           - optional clipping rect (don't draw outside it)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __in_opt LPCRECT pClipRect
    );

//------------------------------------------------------------------------
//---- bits used in dwFlags of DTBGOPTS ----
#define DTBG_CLIPRECT           0x00000001  // rcClip has been specified
#define DTBG_DRAWSOLID          0x00000002  // DEPRECATED: draw transparent/alpha images as solid
#define DTBG_OMITBORDER         0x00000004  // don't draw border of part
#define DTBG_OMITCONTENT        0x00000008  // don't draw content area of part
#define DTBG_COMPUTINGREGION    0x00000010  // TRUE if calling to compute region
#define DTBG_MIRRORDC           0x00000020  // assume the hdc is mirrorred and
                                            // flip images as appropriate (currently 
                                            // only supported for bgtype=imagefile)
#define DTBG_NOMIRROR           0x00000040  // don't mirror the output, overrides everything else 
#define DTBG_VALIDBITS          (DTBG_CLIPRECT | \
                                 DTBG_DRAWSOLID | \
                                 DTBG_OMITBORDER | \
                                 DTBG_OMITCONTENT | \
                                 DTBG_COMPUTINGREGION | \
                                 DTBG_MIRRORDC | \
                                 DTBG_NOMIRROR)

typedef struct _DTBGOPTS
{
    DWORD dwSize;           // size of the struct
    DWORD dwFlags;          // which options have been specified
    RECT rcClip;            // clipping rectangle
} DTBGOPTS, *PDTBGOPTS;

//------------------------------------------------------------------------
//  DrawThemeBackgroundEx()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  NOTE: This will be
//                        merged back into DrawThemeBackground() after 
//                        BETA 2.
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pOptions            - ptr to optional params
//------------------------------------------------------------------------
THEMEAPI
DrawThemeBackgroundEx(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __in_opt const DTBGOPTS *pOptions
    );

//---------------------------------------------------------------------------
//----- DrawThemeText() flags ----
#define DTT_GRAYED              0x00000001          // draw a grayed-out string (this is deprecated)
#define DTT_FLAGS2VALIDBITS     (DTT_GRAYED)

//-------------------------------------------------------------------------
//  DrawThemeText()     - draws the text using the theme-specified 
//                        color and font for the "iPartId" and 
//                        "iStateId".  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pszText             - actual text to draw
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  dwTextFlags2        - additional drawing options 
//  pRect               - defines the size/location of the part
//-------------------------------------------------------------------------
THEMEAPI
DrawThemeText(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchText) LPCWSTR pszText,
    int cchText,
    DWORD dwTextFlags,
    DWORD dwTextFlags2,
    LPCRECT pRect
    );


//---------------------------------------------------------------------------
//
// DrawThemeTextEx
//

// Callback function used by DrawTextWithGlow instead of DrawTextW
typedef 
int
(WINAPI *DTT_CALLBACK_PROC)
(
    __in HDC hdc,
    __inout_ecount(cchText) LPWSTR pszText,
    __in int cchText,
    __inout LPRECT prc,
    __in UINT dwFlags,
    __in LPARAM lParam);

//---- bits used in dwFlags of DTTOPTS ----
#define DTT_TEXTCOLOR       (1UL << 0)      // crText has been specified
#define DTT_BORDERCOLOR     (1UL << 1)      // crBorder has been specified
#define DTT_SHADOWCOLOR     (1UL << 2)      // crShadow has been specified
#define DTT_SHADOWTYPE      (1UL << 3)      // iTextShadowType has been specified
#define DTT_SHADOWOFFSET    (1UL << 4)      // ptShadowOffset has been specified
#define DTT_BORDERSIZE      (1UL << 5)      // iBorderSize has been specified
#define DTT_FONTPROP        (1UL << 6)      // iFontPropId has been specified
#define DTT_COLORPROP       (1UL << 7)      // iColorPropId has been specified
#define DTT_STATEID         (1UL << 8)      // IStateId has been specified
#define DTT_CALCRECT        (1UL << 9)      // Use pRect as and in/out parameter
#define DTT_APPLYOVERLAY    (1UL << 10)     // fApplyOverlay has been specified
#define DTT_GLOWSIZE        (1UL << 11)     // iGlowSize has been specified
#define DTT_CALLBACK        (1UL << 12)     // pfnDrawTextCallback has been specified
#define DTT_COMPOSITED      (1UL << 13)     // Draws text with antialiased alpha (needs a DIB section)
#define DTT_VALIDBITS       (DTT_TEXTCOLOR | \
                             DTT_BORDERCOLOR | \
                             DTT_SHADOWCOLOR | \
                             DTT_SHADOWTYPE | \
                             DTT_SHADOWOFFSET | \
                             DTT_BORDERSIZE | \
                             DTT_FONTPROP | \
                             DTT_COLORPROP | \
                             DTT_STATEID | \
                             DTT_CALCRECT | \
                             DTT_APPLYOVERLAY | \
                             DTT_GLOWSIZE | \
                             DTT_COMPOSITED)

typedef struct _DTTOPTS
{
    DWORD             dwSize;              // size of the struct
    DWORD             dwFlags;             // which options have been specified
    COLORREF          crText;              // color to use for text fill
    COLORREF          crBorder;            // color to use for text outline
    COLORREF          crShadow;            // color to use for text shadow
    int               iTextShadowType;     // TST_SINGLE or TST_CONTINUOUS
    POINT             ptShadowOffset;      // where shadow is drawn (relative to text)
    int               iBorderSize;         // Border radius around text
    int               iFontPropId;         // Font property to use for the text instead of TMT_FONT
    int               iColorPropId;        // Color property to use for the text instead of TMT_TEXTCOLOR
    int               iStateId;            // Alternate state id
    BOOL              fApplyOverlay;       // Overlay text on top of any text effect?
    int               iGlowSize;           // Glow radious around text
    DTT_CALLBACK_PROC pfnDrawTextCallback; // Callback for DrawText
    LPARAM            lParam;              // Parameter for callback
} DTTOPTS, *PDTTOPTS; 

THEMEAPI
DrawThemeTextEx(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchText) LPCWSTR pszText,
    int cchText,
    DWORD dwTextFlags,
    __inout LPRECT pRect,
    __in_opt const DTTOPTS *pOptions
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundContentRect()
//                      - gets the size of the content for the theme-defined 
//                        background.  This is usually the area inside
//                        the borders or Margins.  
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pBoundingRect   - the outer RECT of the part being drawn
//      pContentRect    - RECT to receive the content area
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundContentRect(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pBoundingRect,
    __out LPRECT pContentRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundExtent() - calculates the size/location of the theme-
//                               specified background based on the 
//                               "pContentRect".
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pContentRect    - RECT that defines the content area
//      pBoundingRect   - RECT to receive the overall size/location of part
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundExtent(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pContentRect,
    __out LPRECT pExtentRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundRegion()
//                      - computes the region for a regular or partially 
//                        transparent theme-specified background that is 
//                        bound by the specified "pRect".
//                        If the rectangle is empty, sets the HRGN to NULL 
//                        and return S_FALSE.
//
//  hTheme              - theme data handle
//  hdc                 - optional HDC to draw into (DPI scaling)
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pRect               - the RECT used to draw the part
//  pRegion             - receives handle to calculated region
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundRegion(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __out HRGN *pRegion
    );

enum THEMESIZE
{
    TS_MIN,             // minimum size
    TS_TRUE,            // size without stretching
    TS_DRAW             // size that theme mgr will use to draw part
};

//-------------------------------------------------------------------------
//  GetThemePartSize() - returns the specified size of the theme part
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font into & measure against
//  iPartId             - part number to retrieve size for
//  iStateId            - state number (of the part) 
//  prc                 - (optional) rect for part drawing destination
//  eSize               - the type of size to be retreived
//  psz                 - receives the specified size of the part 
//-------------------------------------------------------------------------
THEMEAPI
GetThemePartSize(
    HTHEME hTheme,
    __in_opt HDC hdc,
    int iPartId,
    int iStateId,
    __in_opt LPCRECT prc,
    enum THEMESIZE eSize,
    __out SIZE *psz
    );

//-------------------------------------------------------------------------
//  GetThemeTextExtent() - calculates the size/location of the specified 
//                         text when rendered in the Theme Font. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font & measure into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pszText             - the text to be measured
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  pszBoundingRect     - optional: to control layout of text
//  pszExtentRect       - receives the RECT for text size/location
//-------------------------------------------------------------------------
THEMEAPI
GetThemeTextExtent(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchCharCount) LPCWSTR pszText,
    int cchCharCount,
    DWORD dwTextFlags,
    __in_opt LPCRECT pBoundingRect,
    __out LPRECT pExtentRect
    );

//-------------------------------------------------------------------------
//  GetThemeTextMetrics()
//                      - returns info about the theme-specified font
//                        for the part/state passed in.
//
//  hTheme              - theme data handle
//  hdc                 - optional: HDC for screen context
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  ptm                 - receives the font info
//-------------------------------------------------------------------------
THEMEAPI
GetThemeTextMetrics(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __out TEXTMETRICW *ptm
    );

//-------------------------------------------------------------------------
//----- HitTestThemeBackground, HitTestThemeBackgroundRegion flags ----

//  Theme background segment hit test flag (default). possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTTOP, HTLEFT, HTTOPLEFT, etc:  // hit test succeeded in the the respective theme background segment.
#define HTTB_BACKGROUNDSEG          0x00000000
//  Fixed border hit test option.  possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTBORDER: hit test succeeded in any other background segment
#define HTTB_FIXEDBORDER            0x00000002      // Return code may be either HTCLIENT or HTBORDER. 
//  Caption hit test option.  Possible return values are:
//  HTCAPTION: hit test succeeded in the top, top left, or top right background segments
//  HTNOWHERE or another return code, depending on absence or presence of accompanying flags, resp.
#define HTTB_CAPTION                0x00000004
//  Resizing border hit test flags.  Possible return values are:
//  HTCLIENT: hit test succeeded in middle background segment
//  HTTOP, HTTOPLEFT, HTLEFT, HTRIGHT, etc:    hit test succeeded in the respective system resizing zone
//  HTBORDER: hit test failed in middle segment and resizing zones, but succeeded in a background border segment
#define HTTB_RESIZINGBORDER_LEFT    0x00000010      // Hit test left resizing border, 
#define HTTB_RESIZINGBORDER_TOP     0x00000020      // Hit test top resizing border
#define HTTB_RESIZINGBORDER_RIGHT   0x00000040      // Hit test right resizing border
#define HTTB_RESIZINGBORDER_BOTTOM  0x00000080      // Hit test bottom resizing border
#define HTTB_RESIZINGBORDER         (HTTB_RESIZINGBORDER_LEFT | \
                                     HTTB_RESIZINGBORDER_TOP | \
                                     HTTB_RESIZINGBORDER_RIGHT | \
                                     HTTB_RESIZINGBORDER_BOTTOM)
// Resizing border is specified as a template, not just window edges.
// This option is mutually exclusive with HTTB_SYSTEMSIZINGWIDTH; HTTB_SIZINGTEMPLATE takes precedence  
#define HTTB_SIZINGTEMPLATE         0x00000100
// Use system resizing border width rather than theme content margins.   
// This option is mutually exclusive with HTTB_SIZINGTEMPLATE, which takes precedence.
#define HTTB_SYSTEMSIZINGMARGINS    0x00000200

//-------------------------------------------------------------------------
//  HitTestThemeBackground()
//                      - returns a HitTestCode (a subset of the values 
//                        returned by WM_NCHITTEST) for the point "ptTest" 
//                        within the theme-specified background
//                        (bound by pRect).  "pRect" and "ptTest" should 
//                        both be in the same coordinate system 
//                        (client, screen, etc).
//
//      hTheme          - theme data handle
//      hdc             - HDC to draw into
//      iPartId         - part number to test against
//      iStateId        - state number (of the part) 
//      pRect           - the RECT used to draw the part
//      hrgn            - optional region to use; must be in same coordinates as
//                      -    pRect and pTest.
//      ptTest          - the hit point to be tested
//      dwOptions       - HTTB_xxx constants
//      pwHitTestCode   - receives the returned hit test code - one of:
//  
//                        HTNOWHERE, HTLEFT, HTTOPLEFT, HTBOTTOMLEFT,
//                        HTRIGHT, HTTOPRIGHT, HTBOTTOMRIGHT,
//                        HTTOP, HTBOTTOM, HTCLIENT
//-------------------------------------------------------------------------
THEMEAPI
HitTestThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    DWORD dwOptions,
    LPCRECT pRect,
    HRGN hrgn,
    POINT ptTest,
    __out WORD *pwHitTestCode
    );

//------------------------------------------------------------------------
//  DrawThemeEdge()     - Similar to the DrawEdge() API, but uses part colors
//                        and is high-DPI aware
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pDestRect           - the RECT used to draw the line(s)
//  uEdge               - Same as DrawEdge() API
//  uFlags              - Same as DrawEdge() API
//  pContentRect        - Receives the interior rect if (uFlags & BF_ADJUST)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeEdge(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pDestRect,
    UINT uEdge,
    UINT uFlags,
    __out_opt LPRECT pContentRect
    );

//------------------------------------------------------------------------
//  DrawThemeIcon()     - draws an image within an imagelist based on 
//                        a (possible) theme-defined effect. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pRect               - the RECT to draw the image within
//  himl                - handle to IMAGELIST 
//  iImageIndex         - index into IMAGELIST (which icon to draw)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeIcon(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    HIMAGELIST himl,
    int iImageIndex
    );

//---------------------------------------------------------------------------
//  IsThemePartDefined() - returns TRUE if the theme has defined parameters
//                         for the specified "iPartId" and "iStateId".
//
//  hTheme              - theme data handle
//  iPartId             - part number to find definition for
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemePartDefined(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    );

//---------------------------------------------------------------------------
//  IsThemeBackgroundPartiallyTransparent()
//                      - returns TRUE if the theme specified background for 
//                        the part/state has transparent pieces or 
//                        alpha-blended pieces.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeBackgroundPartiallyTransparent(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    );

//---------------------------------------------------------------------------
//    lower-level theme information services
//---------------------------------------------------------------------------
// The following methods are getter routines for each of the Theme Data types.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Each method also take a "iPropId" param because multiple instances of 
// the same primitive type can be defined in the theme schema.
//-----------------------------------------------------------------------

//-----------------------------------------------------------------------
//  GetThemeColor()     - Get the value for the specified COLOR property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pColor              - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeColor(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out COLORREF *pColor
    );

//-----------------------------------------------------------------------
//  GetThemeMetric()    - Get the value for the specified metric/size
//                        property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn into (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeMetric(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemeString()    - Get the value for the specified string property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pszBuff             - receives the string property value
//  cchMaxBuffChars     - max. number of chars allowed in pszBuff
//-----------------------------------------------------------------------
THEMEAPI
GetThemeString(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out_ecount(cchMaxBuffChars) LPWSTR pszBuff,
    int cchMaxBuffChars
    );

//-----------------------------------------------------------------------
//  GetThemeBool()      - Get the value for the specified BOOL property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pfVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeBool(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out BOOL *pfVal
    );

//-----------------------------------------------------------------------
//  GetThemeInt()       - Get the value for the specified int property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeInt(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemeEnumValue() - Get the value for the specified ENUM property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the enum (cast to int*)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeEnumValue(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemePosition()  - Get the value for the specified position
//                        property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pPoint              - receives the value of the position property
//-----------------------------------------------------------------------
THEMEAPI
GetThemePosition(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out POINT *pPoint
    );

//-----------------------------------------------------------------------
//  GetThemeFont()      - Get the value for the specified font property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn to (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pFont               - receives the value of the LOGFONT property
//                        (scaled for the current logical screen dpi) 
//-----------------------------------------------------------------------
THEMEAPI
GetThemeFont(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __out LOGFONTW *pFont
    );

//-----------------------------------------------------------------------
//  GetThemeRect()      - Get the value for the specified RECT property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pRect               - receives the value of the RECT property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeRect(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out LPRECT pRect
    );

typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//-----------------------------------------------------------------------
//  GetThemeMargins()   - Get the value for the specified MARGINS property
//
//      hTheme          - theme data handle
//      hdc             - (optional) hdc to be used for drawing
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      prc             - RECT for area to be drawn into
//      pMargins        - receives the value of the MARGINS property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeMargins(
    HTHEME hTheme,
    __in_opt HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __in_opt LPCRECT prc,
    __out MARGINS *pMargins
    );

#if WINVER >= 0x0600
#define MAX_INTLIST_COUNT 402
#else
#define MAX_INTLIST_COUNT 10
#endif

typedef struct _INTLIST
{
    int iValueCount;      // number of values in iValues
    int iValues[MAX_INTLIST_COUNT];
} INTLIST, *PINTLIST;

//-----------------------------------------------------------------------
//  GetThemeIntList()   - Get the value for the specified INTLIST struct
//
//      hTheme          - theme data handle
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      pIntList        - receives the value of the INTLIST property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeIntList(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out INTLIST *pIntList
    );

enum PROPERTYORIGIN
{
    PO_STATE,           // property was found in the state section
    PO_PART,            // property was found in the part section
    PO_CLASS,           // property was found in the class section
    PO_GLOBAL,          // property was found in [globals] section
    PO_NOTFOUND         // property was not found
};

//-----------------------------------------------------------------------
//  GetThemePropertyOrigin()
//                      - searches for the specified theme property
//                        and sets "pOrigin" to indicate where it was 
//                        found (or not found)
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pOrigin             - receives the value of the property origin
//-----------------------------------------------------------------------
THEMEAPI
GetThemePropertyOrigin(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out enum PROPERTYORIGIN *pOrigin
    );

//---------------------------------------------------------------------------
//  SetWindowTheme()
//                      - redirects an existing Window to use a different 
//                        section of the current theme information than its 
//                        class normally asks for.
//
//  hwnd                - the handle of the window (cannot be NULL)
//
//  pszSubAppName       - app (group) name to use in place of the calling
//                        app's name.  If NULL, the actual calling app 
//                        name will be used.
//
//  pszSubIdList        - semicolon separated list of class Id names to 
//                        use in place of actual list passed by the 
//                        window's class.  if NULL, the id list from the 
//                        calling class is used.
//---------------------------------------------------------------------------
// The Theme Manager will remember the "pszSubAppName" and the
// "pszSubIdList" associations thru the lifetime of the window (even 
// if themes are subsequently changed).  The window is sent a 
// "WM_THEMECHANGED" msg at the end of this call, so that the new
// theme can be found and applied.
//---------------------------------------------------------------------------
// When "pszSubAppName" or "pszSubIdList" are NULL, the Theme Manager 
// removes the previously remember association.  To turn off theme-ing for 
// the specified window, you can pass an empty string (L"") so it 
// won't match any section entries.
//---------------------------------------------------------------------------
THEMEAPI
SetWindowTheme(
    HWND hwnd,
    LPCWSTR pszSubAppName,
    LPCWSTR pszSubIdList
    );

enum WINDOWTHEMEATTRIBUTETYPE
{
    WTA_NONCLIENT = 1
};

typedef struct _WTA_OPTIONS
{
    DWORD dwFlags;          // values for each style option specified in the bitmask
    DWORD dwMask;           // bitmask for flags that are changing
                            // valid options are: WTNCA_NODRAWCAPTION, WTNCA_NODRAWICON, WTNCA_NOSYSMENU
} WTA_OPTIONS, *PWTA_OPTIONS;

#define WTNCA_NODRAWCAPTION       0x00000001    // don't draw the window caption
#define WTNCA_NODRAWICON          0x00000002    // don't draw the system icon
#define WTNCA_NOSYSMENU           0x00000004    // don't expose the system menu icon functionality
#define WTNCA_NOMIRRORHELP        0x00000008    // don't mirror the question mark, even in RTL layout
#define WTNCA_VALIDBITS           (WTNCA_NODRAWCAPTION | \
                                   WTNCA_NODRAWICON | \
                                   WTNCA_NOSYSMENU | \
                                   WTNCA_NOMIRRORHELP)

THEMEAPI
SetWindowThemeAttribute(
    HWND hwnd,
    enum WINDOWTHEMEATTRIBUTETYPE eAttribute,
    __in_bcount(cbAttribute) PVOID pvAttribute,
    DWORD cbAttribute
    );

__inline HRESULT SetWindowThemeNonClientAttributes(HWND hwnd, DWORD dwMask, DWORD dwAttributes)    
{
    WTA_OPTIONS wta;
    wta.dwFlags = dwAttributes;
    wta.dwMask = dwMask;
    return SetWindowThemeAttribute(hwnd, WTA_NONCLIENT, (void*)&(wta), sizeof(wta));
}


//---------------------------------------------------------------------------
//  GetThemeFilename()  - Get the value for the specified FILENAME property.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pszThemeFileName    - output buffer to receive the filename
//  cchMaxBuffChars     - the size of the return buffer, in chars
//---------------------------------------------------------------------------
THEMEAPI
GetThemeFilename(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out_ecount(cchMaxBuffChars) LPWSTR pszThemeFileName,
    int cchMaxBuffChars
    );

//---------------------------------------------------------------------------
//  GetThemeSysColor()  - Get the value of the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        color from [SysMetrics] section of theme.
//                        if NULL, will return the global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(COLORREF)
GetThemeSysColor(
    HTHEME hTheme,
    int iColorId
    );

//---------------------------------------------------------------------------
//  GetThemeSysColorBrush() 
//                      - Get the brush for the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        brush matching color from [SysMetrics] section of 
//                        theme.  if NULL, will return the brush matching
//                        global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(HBRUSH)
GetThemeSysColorBrush(
    HTHEME hTheme,
    int iColorId
    );

//---------------------------------------------------------------------------
//  GetThemeSysBool()   - Get the boolean value of specified System metric. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        BOOL from [SysMetrics] section of theme.
//                        if NULL, will return the specified system boolean.
//
//  iBoolId             - the TMT_XXX BOOL number (first BOOL
//                        is TMT_FLATMENUS)
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
GetThemeSysBool(
    HTHEME hTheme,
    int iBoolId
    );

//---------------------------------------------------------------------------
//  GetThemeSysSize()   - Get the value of the specified System size metric. 
//                        (scaled for the current logical screen dpi) 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        size from [SysMetrics] section of theme.
//                        if NULL, will return the global system metric.
//
//  iSizeId             - the following values are supported when 
//                        hTheme is non-NULL:
//
//                          SM_CXBORDER       (border width)
//                          SM_CXVSCROLL      (scrollbar width)
//                          SM_CYHSCROLL      (scrollbar height)
//                          SM_CXSIZE         (caption width)
//                          SM_CYSIZE         (caption height)
//                          SM_CXSMSIZE       (small caption width)
//                          SM_CYSMSIZE       (small caption height)
//                          SM_CXMENUSIZE     (menubar width)
//                          SM_CYMENUSIZE     (menubar height)
//                          SM_CXPADDEDBORDER (padded border width)
//
//                        when hTheme is NULL, iSizeId is passed directly
//                        to the GetSystemMetrics() function
//---------------------------------------------------------------------------
THEMEAPI_(int)
GetThemeSysSize(
    HTHEME hTheme,
    int iSizeId
    );

//---------------------------------------------------------------------------
//  GetThemeSysFont()   - Get the LOGFONT for the specified System font. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        font from [SysMetrics] section of theme.
//                        if NULL, will return the specified system font.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//                        (scaled for the current logical screen dpi) 
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysFont(
    HTHEME hTheme,
    int iFontId,
    __out LOGFONTW *plf
    );

//---------------------------------------------------------------------------
//  GetThemeSysString() - Get the value of specified System string metric. 
//
//  hTheme              - the theme data handle (required)
//
//  iStringId           - must be one of the following values:
//
//                          TMT_CSSNAME
//                          TMT_XMLNAME
//
//  pszStringBuff       - the buffer to receive the string value
//
//  cchMaxStringChars   - max. number of chars that pszStringBuff can hold
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysString(
    HTHEME hTheme,
    int iStringId,
    __out_ecount(cchMaxStringChars) LPWSTR pszStringBuff,
    int cchMaxStringChars
    );

//---------------------------------------------------------------------------
//  GetThemeSysInt() - Get the value of specified System int.
//
//  hTheme              - the theme data handle (required)
//
//  iIntId              - must be one of the following values:
//
//                          TMT_DPIX
//                          TMT_DPIY
//                          TMT_MINCOLORDEPTH
//
//  piValue             - ptr to int to receive value
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysInt(
    HTHEME hTheme,
    int iIntId,
    __out int *piValue
    );

//---------------------------------------------------------------------------
//  IsThemeActive()     - can be used to test if a system theme is active
//                        for the current user session.  
//
//                        use the API "IsAppThemed()" to test if a theme is
//                        active for the calling process.
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeActive(
    VOID
    );

//---------------------------------------------------------------------------
//  IsAppThemed()       - returns TRUE if a theme is active and available to
//                        the current process
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsAppThemed(
    VOID
    );

//---------------------------------------------------------------------------
//  GetWindowTheme()    - if window is themed, returns its most recent
//                        HTHEME from OpenThemeData() - otherwise, returns
//                        NULL.
//
//      hwnd            - the window to get the HTHEME of
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
GetWindowTheme(
    HWND hwnd
    );

#define ETDT_DISABLE                    0x00000001
#define ETDT_ENABLE                     0x00000002
#define ETDT_USETABTEXTURE              0x00000004
#define ETDT_USEAEROWIZARDTABTEXTURE    0x00000008

#define ETDT_ENABLETAB              (ETDT_ENABLE | \
                                     ETDT_USETABTEXTURE)
        
#define ETDT_ENABLEAEROWIZARDTAB    (ETDT_ENABLE | \
                                     ETDT_USEAEROWIZARDTABTEXTURE)
                             
#define ETDT_VALIDBITS              (ETDT_DISABLE | \
                                     ETDT_ENABLE | \
                                     ETDT_USETABTEXTURE | \
                                     ETDT_USEAEROWIZARDTABTEXTURE)

//---------------------------------------------------------------------------
//  EnableThemeDialogTexture() 
//
//  - Enables/disables dialog background theme.  This method can be used to 
//    tailor dialog compatibility with child windows and controls that 
//    may or may not coordinate the rendering of their client area backgrounds 
//    with that of their parent dialog in a manner that supports seamless 
//    background texturing.
//
//      hdlg         - the window handle of the target dialog
//      dwFlags      - ETDT_ENABLE to enable the theme-defined dialog background texturing,
//                     ETDT_DISABLE to disable background texturing,
//                     ETDT_ENABLETAB to enable the theme-defined background 
//                          texturing using the Tab texture
//---------------------------------------------------------------------------
THEMEAPI
EnableThemeDialogTexture(
    __in HWND hwnd,
    __in DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  IsThemeDialogTextureEnabled() 
//
//  - Reports whether the dialog supports background texturing.
//
//      hdlg         - the window handle of the target dialog
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeDialogTextureEnabled(
    __in HWND hwnd
    );

//---------------------------------------------------------------------------
//---- flags to control theming within an app ----

#define STAP_ALLOW_NONCLIENT    (1UL << 0)
#define STAP_ALLOW_CONTROLS     (1UL << 1)
#define STAP_ALLOW_WEBCONTENT   (1UL << 2)
#define STAP_VALIDBITS          (STAP_ALLOW_NONCLIENT | \
                                 STAP_ALLOW_CONTROLS | \
                                 STAP_ALLOW_WEBCONTENT)

//---------------------------------------------------------------------------
//  GetThemeAppProperties()
//                      - returns the app property flags that control theming
//---------------------------------------------------------------------------
THEMEAPI_(DWORD)
GetThemeAppProperties(
    VOID
    );

//---------------------------------------------------------------------------
//  SetThemeAppProperties()
//                      - sets the flags that control theming within the app
//
//      dwFlags         - the flag values to be set
//---------------------------------------------------------------------------
THEMEAPI_(void)
SetThemeAppProperties(
    DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  GetCurrentThemeName()
//                      - Get the name of the current theme in-use.  
//                        Optionally, return the ColorScheme name and the 
//                        Size name of the theme.
//
//  pszThemeFileName    - receives the theme path & filename
//  cchMaxNameChars     - max chars allowed in pszNameBuff
//
//  pszColorBuff        - (optional) receives the canonical color scheme name
//                        (not the display name)
//  cchMaxColorChars    - max chars allowed in pszColorBuff
//
//  pszSizeBuff         - (optional) receives the canonical size name 
//                        (not the display name)
//  cchMaxSizeChars     - max chars allowed in pszSizeBuff
//---------------------------------------------------------------------------
THEMEAPI GetCurrentThemeName(
    __out_ecount(cchMaxNameChars) LPWSTR pszThemeFileName,
    int cchMaxNameChars,
    __out_ecount_opt(cchMaxColorChars) LPWSTR pszColorBuff,
    int cchMaxColorChars,
    __out_ecount_opt(cchMaxSizeChars) LPWSTR pszSizeBuff,
    int cchMaxSizeChars
    );

#define SZ_THDOCPROP_DISPLAYNAME    L"DisplayName"
#define SZ_THDOCPROP_CANONICALNAME  L"ThemeName"
#define SZ_THDOCPROP_TOOLTIP        L"ToolTip"
#define SZ_THDOCPROP_AUTHOR         L"author"

THEMEAPI
GetThemeDocumentationProperty(
    LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName,
    __out_ecount(cchMaxValChars) LPWSTR pszValueBuff,
    int cchMaxValChars
    );

//---------------------------------------------------------------------------
//  Theme API Error Handling
//
//      All functions in the Theme API not returning an HRESULT (THEMEAPI_) 
//      use the WIN32 function "SetLastError()" to record any call failures.  
//
//      To retreive the error code of the last failure on the
//      current thread for these type of API's, use the WIN32 function 
//      "GetLastError()".
//
//      All Theme API error codes (HRESULT's and GetLastError() values)
//      should be normal win32 errors which can be formatted into
//      strings using the Win32 API FormatMessage().
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// DrawThemeParentBackground()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//
//  hwnd                - handle of the child control
//
//  hdc                 - hdc of the child control
//
//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//---------------------------------------------------------------------------
THEMEAPI
DrawThemeParentBackground(
    HWND hwnd,
    HDC hdc,
    __in_opt const RECT* prc
    );


#define DTPB_WINDOWDC           0x00000001
#define DTPB_USECTLCOLORSTATIC  0x00000002
#define DTPB_USEERASEBKGND      0x00000004

//---------------------------------------------------------------------------
// DrawThemeParentBackgroundEx()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//                        Sends a WM_ERASEBKGND message followed by a WM_PRINTCLIENT.
//
//  hwnd                - handle of the child control
//
//  hdc                 - hdc of the child control
//
//  dwFlags             - if 0, only returns S_OK if the parent handled 
//                        WM_PRINTCLIENT.
//                      - if DTPB_WINDOWDC is set, hdc is assumed to be a window DC,
//                        not a client DC.
//                      - if DTPB_USEERASEBKGND is set, the function will return S_OK 
//                        without sending a WM_CTLCOLORSTATIC message if the parent 
//                        actually painted on WM_ERASEBKGND.
//                      - if DTPB_CTLCOLORSTATIC is set, the function will send
//                        a WM_CTLCOLORSTATIC message to the parent and use the 
//                        brush if one is provided, else COLOR_BTNFACE.
//
//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//
//  Return value        - S_OK if something was painted, S_FALSE if not.
//---------------------------------------------------------------------------
THEMEAPI
DrawThemeParentBackgroundEx(
    HWND hwnd,
    HDC hdc,
    DWORD dwFlags,
    __in_opt const RECT* prc
    );

//---------------------------------------------------------------------------
//  EnableTheming()     - enables or disables themeing for the current user
//                        in the current and future sessions.
//
//  fEnable             - if FALSE, disable theming & turn themes off.
//                      - if TRUE, enable themeing and, if user previously
//                        had a theme active, make it active now.
//---------------------------------------------------------------------------
THEMEAPI
EnableTheming(
    BOOL fEnable
    );

#define GBF_DIRECT      0x00000001      // direct dereferencing.
#define GBF_COPY        0x00000002      // create a copy of the bitmap
#define GBF_VALIDBITS   (GBF_DIRECT | \
                         GBF_COPY)

#if (_WIN32_WINNT >= 0x0600)

THEMEAPI
GetThemeBitmap(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    ULONG dwFlags,
    __out HBITMAP* phBitmap
    );

//-----------------------------------------------------------------------
//  GetThemeStream() - Get the value for the specified STREAM property
//
//      hTheme      - theme data handle
//      iPartId     - part number 
//      iStateId    - state number of part
//      iPropId     - the property number to get the value for
//      ppvStream   - if non-null receives the value of the STREAM property (not to be freed)
//      pcbStream   - if non-null receives the size of the STREAM property
//      hInst       - NULL when iPropId==TMT_STREAM, HINSTANCE of a loaded msstyles 
//                    file when iPropId==TMT_DISKSTREAM (use GetCurrentThemeName 
//                    and LoadLibraryEx(LOAD_LIBRARY_AS_DATAFILE)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeStream(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out VOID **ppvStream,
    __out_opt DWORD *pcbStream,
    __in_opt HINSTANCE hInst
    );

#endif // #if (_WIN32_WINNT >= 0x0600)


//------------------------------------------------------------------------
//  BufferedPaintInit() - Initialize the Buffered Paint API.
//                        Should be called prior to BeginBufferedPaint,
//                        and should have a matching BufferedPaintUnInit.
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintInit(
    VOID
    );

//------------------------------------------------------------------------
//  BufferedPaintUnInit() - Uninitialize the Buffered Paint API.
//                          Should be called once for each call to BufferedPaintInit,
//                          when calls to BeginBufferedPaint are no longer needed.
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintUnInit(
    VOID
    );

//------------------------------------------------------------------------
//  BeginBufferedPaint() - Begins a buffered paint operation.
//
//    hdcTarget          - Target DC on which the buffer will be painted
//    rcTarget           - Rectangle specifying the area of the target DC to paint to
//    dwFormat           - Format of the buffer (see BP_BUFFERFORMAT)
//    pPaintParams       - Paint operation parameters (see BP_PAINTPARAMS)
//    phBufferedPaint    - Pointer to receive handle to new buffered paint context
//------------------------------------------------------------------------

// HPAINTBUFFER
typedef HANDLE HPAINTBUFFER;  // handle to a buffered paint context


// BP_BUFFERFORMAT
typedef enum _BP_BUFFERFORMAT
{
    BPBF_COMPATIBLEBITMAP,    // Compatible bitmap
    BPBF_DIB,                 // Device-independent bitmap
    BPBF_TOPDOWNDIB,          // Top-down device-independent bitmap
    BPBF_TOPDOWNMONODIB       // Top-down monochrome device-independent bitmap
} BP_BUFFERFORMAT;

#define BPBF_COMPOSITED BPBF_TOPDOWNDIB


// BP_ANIMATIONSTYLE
typedef enum _BP_ANIMATIONSTYLE
{
    BPAS_NONE,                // No animation
    BPAS_LINEAR,              // Linear fade animation
    BPAS_CUBIC,               // Cubic fade animation
    BPAS_SINE                 // Sinusoid fade animation
} BP_ANIMATIONSTYLE;


// BP_ANIMATIONPARAMS
typedef struct _BP_ANIMATIONPARAMS
{
    DWORD               cbSize;
    DWORD               dwFlags; // BPAF_ flags
    BP_ANIMATIONSTYLE   style;
    DWORD               dwDuration;
} BP_ANIMATIONPARAMS, *PBP_ANIMATIONPARAMS;

#define BPPF_ERASE               0x0001 // Empty the buffer during BeginBufferedPaint()
#define BPPF_NOCLIP              0x0002 // Don't apply the target DC's clip region to the double buffer
#define BPPF_NONCLIENT           0x0004 // Using a non-client DC

                                        
// BP_PAINTPARAMS
typedef struct _BP_PAINTPARAMS
{
    DWORD                       cbSize;
    DWORD                       dwFlags; // BPPF_ flags
    const RECT *                prcExclude;
    const BLENDFUNCTION *       pBlendFunction;
} BP_PAINTPARAMS, *PBP_PAINTPARAMS;

THEMEAPI_(HPAINTBUFFER)
BeginBufferedPaint(
    HDC hdcTarget,
    const RECT* prcTarget,
    BP_BUFFERFORMAT dwFormat,
    __in_opt BP_PAINTPARAMS *pPaintParams,
    __out HDC *phdc
    );


//------------------------------------------------------------------------
//  EndBufferedPaint() - Ends a buffered paint operation.
//
//    hBufferedPaint   - handle to buffered paint context
//    fUpdateTarget    - update target DC
//------------------------------------------------------------------------
THEMEAPI
EndBufferedPaint(
    HPAINTBUFFER hBufferedPaint,
    BOOL fUpdateTarget
    );

//------------------------------------------------------------------------
//  GetBufferedPaintTargetRect() - Returns the target rectangle specified during BeginBufferedPaint
//
//    hBufferedPaint             - handle to buffered paint context
//    prc                        - pointer to receive target rectangle
//------------------------------------------------------------------------
THEMEAPI
GetBufferedPaintTargetRect(
    HPAINTBUFFER hBufferedPaint,
    __out RECT *prc
    );

//------------------------------------------------------------------------
//  GetBufferedPaintTargetDC() - Returns the target DC specified during BeginBufferedPaint
//
//    hBufferedPaint           - handle to buffered paint context
//------------------------------------------------------------------------
THEMEAPI_(HDC)
GetBufferedPaintTargetDC(
    HPAINTBUFFER hBufferedPaint
    );

//------------------------------------------------------------------------
//  GetBufferedPaintDC() - Returns the same paint DC returned by BeginBufferedPaint
//
//    hBufferedPaint     - handle to buffered paint context
//------------------------------------------------------------------------
THEMEAPI_(HDC)
GetBufferedPaintDC(
    HPAINTBUFFER hBufferedPaint
    );

//------------------------------------------------------------------------
//  GetBufferedPaintBits() - Obtains a pointer to the buffer bitmap, if the buffer is a DIB
//
//    hBufferedPaint       - handle to buffered paint context
//    ppbBuffer            - pointer to receive pointer to buffer bitmap pixels
//    pcxRow               - pointer to receive width of buffer bitmap, in pixels;
//                           this value may not necessarily be equal to the buffer width
//------------------------------------------------------------------------
THEMEAPI
GetBufferedPaintBits(
    HPAINTBUFFER hBufferedPaint,
    __out RGBQUAD **ppbBuffer,
    __out int *pcxRow
    );

//------------------------------------------------------------------------
//  BufferedPaintClear() - Clears given rectangle to ARGB = {0, 0, 0, 0}
//
//    hBufferedPaint     - handle to buffered paint context
//    prc                - rectangle to clear; NULL specifies entire buffer
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintClear(
    HPAINTBUFFER hBufferedPaint,
    __in_opt const RECT *prc
    );

//------------------------------------------------------------------------
//  BufferedPaintSetAlpha() - Set alpha to given value in given rectangle
//
//    hBufferedPaint        - handle to buffered paint context
//    prc                   - rectangle to set alpha in; NULL specifies entire buffer
//    alpha                 - alpha value to set in the given rectangle
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintSetAlpha(
    HPAINTBUFFER hBufferedPaint,
    __in_opt const RECT *prc,
    BYTE alpha
    );

// Macro for setting the buffer to opaque (alpha = 255)
#define BufferedPaintMakeOpaque(hBufferedPaint, prc) BufferedPaintSetAlpha(hBufferedPaint, prc, 255)

//------------------------------------------------------------------------
//  BufferedPaintStopAllAnimations() - Stop all buffer animations for the given window
//
//    hwnd                           - window on which to stop all animations
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintStopAllAnimations(
    HWND hwnd
    );

typedef HANDLE HANIMATIONBUFFER;  // handle to a buffered paint animation

THEMEAPI_(HANIMATIONBUFFER)
BeginBufferedAnimation(
    HWND hwnd,
    HDC hdcTarget,
    const RECT* prcTarget,
    BP_BUFFERFORMAT dwFormat,
    __in_opt BP_PAINTPARAMS *pPaintParams,
    __in BP_ANIMATIONPARAMS *pAnimationParams,
    __out HDC *phdcFrom,
    __out HDC *phdcTo
    );

THEMEAPI
EndBufferedAnimation(
    HANIMATIONBUFFER hbpAnimation,
    BOOL fUpdateTarget
    );

THEMEAPI_(BOOL)
BufferedPaintRenderAnimation(
    HWND hwnd,
    HDC hdcTarget
    );
    
//----------------------------------------------------------------------------
// Tells if the DWM is running, and composition effects are possible for this 
// process (themes are active). 
// Roughly equivalent to "DwmIsCompositionEnabled() && IsAppthemed()"
//----------------------------------------------------------------------------
THEMEAPI_(BOOL) IsCompositionActive();

//------------------------------------------------------------------------
//  GetThemeTransitionDuration()
//                      - Gets the duration for the specified transition
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateIdFrom        - starting state number of part
//  iStateIdTo          - ending state number of part
//  iPropId             - property id 
//  pdwDuration         - receives the transition duration
//------------------------------------------------------------------------
THEMEAPI
GetThemeTransitionDuration(
    HTHEME hTheme,
    int iPartId,
    int iStateIdFrom,
    int iStateIdTo,
    int iPropId,
    __out DWORD *pdwDuration
    );  

#endif /* _UXTHEME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\usbiodef.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        USBIODEF.H

Abstract:

        Common header file for all USB IOCTLs defined for
        the core stack.  We define them in this single header file
        so that we can maintain backward compatibilty with older
        versions of the stack.


        We divide the IOCTLS supported by the stack as follows:

        kernel IOCTLS:


        user IOCTLS:

            IOCTLS Handled by HCD (PORT) FDO
            IOCTLS Handled by HUB FDO
            IOCTLS Handled by USB (DEVICE) PDO

Environment:

    kernel & user mode

Revision History:


--*/

#ifndef   __USBIODEF_H__
#define   __USBIODEF_H__

/*
    kernel mode IOCTL index values

    The following codes are valid only if passed as in
    the icControlCode parameter for
    IRP_MJ_INTERNAL_DEVICE_CONTROL

*/
#define USB_SUBMIT_URB              0
#define USB_RESET_PORT              1
#define USB_GET_ROOTHUB_PDO         3
#define USB_GET_PORT_STATUS         4
#define USB_ENABLE_PORT             5
#define USB_GET_HUB_COUNT           6
#define USB_CYCLE_PORT              7
#define USB_GET_HUB_NAME            8
#define USB_IDLE_NOTIFICATION       9
#define USB_RECORD_FAILURE          10
#define USB_GET_BUS_INFO            264
#define USB_GET_CONTROLLER_NAME     265
#define USB_GET_BUSGUID_INFO        266
#define USB_GET_PARENT_HUB_INFO     267
#define USB_GET_DEVICE_HANDLE       268
#define USB_GET_DEVICE_HANDLE_EX    269
#define USB_GET_TT_DEVICE_HANDLE    270
#define USB_GET_TOPOLOGY_ADDRESS    271
#define USB_IDLE_NOTIFICATION_EX    272  
#define USB_REQ_GLOBAL_SUSPEND      273
#define USB_REQ_GLOBAL_RESUME       274
#define USB_GET_HUB_CONFIG_INFO     275


/*
    user mode IOCTL index values

    The following codes are valid only if passed as in
    the icControlCode parameter for
    IRP_MJ_DEVICE_CONTROL
    hence, they are callable by user mode applications
*/
#define HCD_GET_STATS_1                     255
#define HCD_DIAGNOSTIC_MODE_ON              256
#define HCD_DIAGNOSTIC_MODE_OFF             257
#define HCD_GET_ROOT_HUB_NAME               258
#define HCD_GET_DRIVERKEY_NAME              265
#define HCD_GET_STATS_2                     266
#define HCD_DISABLE_PORT                    268
#define HCD_ENABLE_PORT                     269
#define HCD_USER_REQUEST                    270
#define HCD_TRACE_READ_REQUEST              275


#define USB_GET_NODE_INFORMATION                    258
#define USB_GET_NODE_CONNECTION_INFORMATION         259
#define USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION     260
#define USB_GET_NODE_CONNECTION_NAME                261
#define USB_DIAG_IGNORE_HUBS_ON                     262
#define USB_DIAG_IGNORE_HUBS_OFF                    263
#define USB_GET_NODE_CONNECTION_DRIVERKEY_NAME      264
#define USB_GET_HUB_CAPABILITIES                    271
#define USB_GET_NODE_CONNECTION_ATTRIBUTES          272
#define USB_HUB_CYCLE_PORT                          273
#define USB_GET_NODE_CONNECTION_INFORMATION_EX      274
#define USB_RESET_HUB                               275
#define USB_GET_HUB_CAPABILITIES_EX                 276
              
/*
USB specific GUIDs
*/


/* f18a0e88-c30c-11d0-8815-00a0c906bed8 */
DEFINE_GUID(GUID_DEVINTERFACE_USB_HUB,    0xf18a0e88, 0xc30c, 0x11d0, 0x88, 0x15, 0x00, \
             0xa0, 0xc9, 0x06, 0xbe, 0xd8);

/* A5DCBF10-6530-11D2-901F-00C04FB951ED */
DEFINE_GUID(GUID_DEVINTERFACE_USB_DEVICE, 0xA5DCBF10L, 0x6530, 0x11D2, 0x90, 0x1F, 0x00, \
             0xC0, 0x4F, 0xB9, 0x51, 0xED);

/* 3ABF6F2D-71C4-462a-8A92-1E6861E6AF27 */
DEFINE_GUID(GUID_DEVINTERFACE_USB_HOST_CONTROLLER, 0x3abf6f2d, 0x71c4, 0x462a, 0x8a, 0x92, 0x1e, \
             0x68, 0x61, 0xe6, 0xaf, 0x27);

/* 4E623B20-CB14-11D1-B331-00A0C959BBD2 */
DEFINE_GUID(GUID_USB_WMI_STD_DATA, 0x4E623B20L, 0xCB14, 0x11D1, 0xB3, 0x31, 0x00,\
             0xA0, 0xC9, 0x59, 0xBB, 0xD2);

/* 4E623B20-CB14-11D1-B331-00A0C959BBD2 */
DEFINE_GUID(GUID_USB_WMI_STD_NOTIFICATION, 0x4E623B20L, 0xCB14, 0x11D1, 0xB3, 0x31, 0x00,\
             0xA0, 0xC9, 0x59, 0xBB, 0xD2);

#if (_WIN32_WINNT >= 0x0600)
/*
    For windows longhorn and later
*/

/* 66C1AA3C-499F-49a0-A9A5-61E2359F6407 */
DEFINE_GUID(GUID_USB_WMI_DEVICE_PERF_INFO, 0x66c1aa3c, 0x499f, 0x49a0, 0xa9, 0xa5, 0x61, 0xe2,\
             0x35, 0x9f, 0x64, 0x7);
             
// {9C179357-DC7A-4f41-B66B-323B9DDCB5B1}
DEFINE_GUID(GUID_USB_WMI_NODE_INFO, 
0x9c179357, 0xdc7a, 0x4f41, 0xb6, 0x6b, 0x32, 0x3b, 0x9d, 0xdc, 0xb5, 0xb1);

// {AD0379E4-72DB-42ed-BA6E-67570479070D}
DEFINE_GUID(GUID_USB_WMI_HUB_DIAGNOSTICS, 
0xad0379e4, 0x72db, 0x42ed, 0xba, 0x6e, 0x67, 0x57, 0x4, 0x79, 0x7, 0xd);

/* 3a61881b-b4e6-4bf9-ae0f-3cd8f394e52f */
DEFINE_GUID(GUID_USB_WMI_TRACING, 
0x3a61881b, 0xb4e6, 0x4bf9, 0xae, 0xf, 0x3c, 0xd8, 0xf3, 0x94, 0xe5, 0x2f);

// {681EB8AA-403D-452c-9F8A-F0616FAC9540}
DEFINE_GUID(GUID_USB_TRANSFER_TRACING, 
0x681eb8aa, 0x403d, 0x452c, 0x9f, 0x8a, 0xf0, 0x61, 0x6f, 0xac, 0x95, 0x40);

// {D5DE77A6-6AE9-425c-B1E2-F5615FD348A9}
DEFINE_GUID(GUID_USB_PERFORMANCE_TRACING, 
0xd5de77a6, 0x6ae9, 0x425c, 0xb1, 0xe2, 0xf5, 0x61, 0x5f, 0xd3, 0x48, 0xa9);

#endif

/*
Obsolete device interface class GUID names.
(use of above GUID_DEVINTERFACE_* names is recommended).
--*/

#define GUID_CLASS_USBHUB               GUID_DEVINTERFACE_USB_HUB
#define GUID_CLASS_USB_DEVICE           GUID_DEVINTERFACE_USB_DEVICE
#define GUID_CLASS_USB_HOST_CONTROLLER  GUID_DEVINTERFACE_USB_HOST_CONTROLLER

#define FILE_DEVICE_USB         FILE_DEVICE_UNKNOWN

/*
    common macro used by IOCTL header files
*/
#define USB_CTL(id)  CTL_CODE(FILE_DEVICE_USB,  \
                                      (id), \
                                      METHOD_BUFFERED,  \
                                      FILE_ANY_ACCESS)

#define USB_KERNEL_CTL(id)  CTL_CODE(FILE_DEVICE_USB,  \
                                      (id), \
                                      METHOD_NEITHER,  \
                                      FILE_ANY_ACCESS)

#define USB_KERNEL_CTL_BUFFERED(id)  CTL_CODE(FILE_DEVICE_USB,  \
                                      (id), \
                                      METHOD_BUFFERED,  \
                                      FILE_ANY_ACCESS)

/*
    structures common to both usbioctl.h and usbdrivr.h
*/


#if (_WIN32_WINNT >= 0x0501)

/*
    used by IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION.
    Available on windows XP and later
*/


typedef
VOID
(*USB_IDLE_CALLBACK)(
    PVOID Context
    );

typedef struct _USB_IDLE_CALLBACK_INFO {
    USB_IDLE_CALLBACK IdleCallback;
    PVOID IdleContext;
} USB_IDLE_CALLBACK_INFO, *PUSB_IDLE_CALLBACK_INFO;

#endif

#endif //__USBIODEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\vdslun.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for vdslun.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __vdslun_h__
#define __vdslun_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vdslun_0000_0000 */
/* [local] */ 

typedef 
enum _VDS_STORAGE_IDENTIFIER_CODE_SET
    {	VDSStorageIdCodeSetReserved	= 0,
	VDSStorageIdCodeSetBinary	= 1,
	VDSStorageIdCodeSetAscii	= 2,
	VDSStorageIdCodeSetUtf8	= 3
    } 	VDS_STORAGE_IDENTIFIER_CODE_SET;

typedef 
enum _VDS_STORAGE_IDENTIFIER_TYPE
    {	VDSStorageIdTypeVendorSpecific	= 0,
	VDSStorageIdTypeVendorId	= 1,
	VDSStorageIdTypeEUI64	= 2,
	VDSStorageIdTypeFCPHName	= 3,
	VDSStorageIdTypePortRelative	= 4,
	VDSStorageIdTypeTargetPortGroup	= 5,
	VDSStorageIdTypeLogicalUnitGroup	= 6,
	VDSStorageIdTypeMD5LogicalUnitIdentifier	= 7,
	VDSStorageIdTypeScsiNameString	= 8
    } 	VDS_STORAGE_IDENTIFIER_TYPE;

typedef 
enum _VDS_STORAGE_BUS_TYPE
    {	VDSBusTypeUnknown	= 0,
	VDSBusTypeScsi	= 0x1,
	VDSBusTypeAtapi	= 0x2,
	VDSBusTypeAta	= 0x3,
	VDSBusType1394	= 0x4,
	VDSBusTypeSsa	= 0x5,
	VDSBusTypeFibre	= 0x6,
	VDSBusTypeUsb	= 0x7,
	VDSBusTypeRAID	= 0x8,
	VDSBusTypeiScsi	= 0x9,
	VDSBusTypeSas	= 0xa,
	VDSBusTypeSata	= 0xb,
	VDSBusTypeSd	= 0xc,
	VDSBusTypeMmc	= 0xd,
	VDSBusTypeMax	= 0xe,
	VDSBusTypeMaxReserved	= 0x7f
    } 	VDS_STORAGE_BUS_TYPE;

typedef struct _VDS_STORAGE_IDENTIFIER
    {
    VDS_STORAGE_IDENTIFIER_CODE_SET m_CodeSet;
    VDS_STORAGE_IDENTIFIER_TYPE m_Type;
    ULONG m_cbIdentifier;
    BYTE *m_rgbIdentifier;
    } 	VDS_STORAGE_IDENTIFIER;

typedef struct _VDS_STORAGE_DEVICE_ID_DESCRIPTOR
    {
    ULONG m_version;
    ULONG m_cIdentifiers;
    VDS_STORAGE_IDENTIFIER *m_rgIdentifiers;
    } 	VDS_STORAGE_DEVICE_ID_DESCRIPTOR;

typedef 
enum _VDS_INTERCONNECT_ADDRESS_TYPE
    {	VDS_IA_UNKNOWN	= 0,
	VDS_IA_FCFS	= 1,
	VDS_IA_FCPH	= 2,
	VDS_IA_FCPH3	= 3,
	VDS_IA_MAC	= 4,
	VDS_IA_SCSI	= 5
    } 	VDS_INTERCONNECT_ADDRESS_TYPE;

typedef struct _VDS_INTERCONNECT
    {
    VDS_INTERCONNECT_ADDRESS_TYPE m_addressType;
    ULONG m_cbPort;
    BYTE *m_pbPort;
    ULONG m_cbAddress;
    BYTE *m_pbAddress;
    } 	VDS_INTERCONNECT;

typedef struct _VDS_LUN_INFORMATION
    {
    ULONG m_version;
    BYTE m_DeviceType;
    BYTE m_DeviceTypeModifier;
    BOOL m_bCommandQueueing;
    VDS_STORAGE_BUS_TYPE m_BusType;
    char *m_szVendorId;
    char *m_szProductId;
    char *m_szProductRevision;
    char *m_szSerialNumber;
    GUID m_diskSignature;
    VDS_STORAGE_DEVICE_ID_DESCRIPTOR m_deviceIdDescriptor;
    ULONG m_cInterconnects;
    VDS_INTERCONNECT *m_rgInterconnects;
    } 	VDS_LUN_INFORMATION;

#define	VER_VDS_LUN_INFORMATION	( 1 )



extern RPC_IF_HANDLE __MIDL_itf_vdslun_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdslun_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Vcr.h ===
/***************************************************************************
 *                                                                         *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY  *
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE    *
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR  *
 *  PURPOSE.                                                               *
 *                                                                         *
 *  Copyright (c) 1993 - 1999 Microsoft Corporation.  All Rights Reserved. *
 *                                                                         *
 * File:  vcr.h                                                            *
 * Title:           VCR-MCI Command Table Include File                     *
 *                                                                         *
 ***************************************************************************/

#ifndef __VCR_H__
#define __VCR_H__

/* string resource base for vcr device type */
#define MCI_VCR_OFFSET                          1280

/* system MCI commands */
#define MCI_LIST                                0x0878
#define MCI_SETAUDIO                            0x0873 
#define MCI_SETVIDEO                            0x0876 
#define MCI_SIGNAL                              0x0875 

/* custom MCI commands for VCRs */
#define MCI_MARK                                (MCI_USER_MESSAGES + 0)
#define MCI_INDEX                               (MCI_USER_MESSAGES + 1)
#define MCI_SETTUNER                            (MCI_USER_MESSAGES + 2)
#define MCI_SETVCR                              (MCI_USER_MESSAGES + 3)
#define MCI_SETTIMECODE                         (MCI_USER_MESSAGES + 4)

/* Test is appplicable to all commands */
#define MCI_TEST                                0x00000020L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH    0x00004001L
#define MCI_VCR_GETDEVCAPS_SEEK_ACCURACY        0x00004002L
#define MCI_VCR_GETDEVCAPS_HAS_CLOCK            0x00004003L
#define MCI_VCR_GETDEVCAPS_CAN_REVERSE          0x00004004L
#define MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS      0x00004005L
#define MCI_VCR_GETDEVCAPS_CAN_TEST             0x00004006L
#define MCI_VCR_GETDEVCAPS_CAN_PREROLL          0x00004007L
#define MCI_VCR_GETDEVCAPS_CAN_PREVIEW          0x00004008L
#define MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES  0x00004009L
#define MCI_VCR_GETDEVCAPS_HAS_TIMECODE         0x0000400AL
#define MCI_VCR_GETDEVCAPS_CAN_FREEZE           0x0000401BL
#define MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE 0x0000401CL

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_VCR_INFO_VERSION                    0x00010000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VCR_PLAY_REVERSE                    0x00010000L
#define MCI_VCR_PLAY_AT                         0x00020000L
#define MCI_VCR_PLAY_SCAN                       0x00040000L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_VCR_RECORD_INITIALIZE               0x00010000L
#define MCI_VCR_RECORD_AT                       0x00020000L
#define MCI_VCR_RECORD_PREVIEW                  0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */
#define MCI_VCR_CUE_INPUT                       0x00010000L
#define MCI_VCR_CUE_OUTPUT                      0x00020000L
#define MCI_VCR_CUE_PREROLL                     0x00040000L
#define MCI_VCR_CUE_REVERSE                     0x00080000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_VCR_SEEK_REVERSE                    0x00010000L
#define MCI_VCR_SEEK_MARK                       0x00020000L
#define MCI_VCR_SEEK_AT                         0x00040000L
                                               
/* flags for dwFlags parameter of MCI_SETTUNER command message */
#define MCI_VCR_SETTUNER_CHANNEL                0x00010000L
#define MCI_VCR_SETTUNER_CHANNEL_UP             0x00020000L
#define MCI_VCR_SETTUNER_CHANNEL_DOWN           0x00040000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_UP        0x00080000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN      0x00100000L
#define MCI_VCR_SETTUNER_NUMBER                 0x00200000L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_VCR_SET_TIME_MODE                   0x00010000L
#define MCI_VCR_SET_POWER                       0x00020000L
#define MCI_VCR_SET_RECORD_FORMAT               0x00040000L
#define MCI_VCR_SET_COUNTER_FORMAT              0x00080000L
#define MCI_VCR_SET_INDEX                       0x00100000L
#define MCI_VCR_SET_ASSEMBLE_RECORD             0x00200000L
#define MCI_VCR_SET_TRACKING                    0x00400000L
#define MCI_VCR_SET_SPEED                       0x00800000L
#define MCI_VCR_SET_TAPE_LENGTH                 0x01000000L
#define MCI_VCR_SET_COUNTER_VALUE               0x02000000L
#define MCI_VCR_SET_CLOCK                       0x04000000L
#define MCI_VCR_SET_PAUSE_TIMEOUT               0x08000000L
#define MCI_VCR_SET_PREROLL_DURATION            0x10000000L
#define MCI_VCR_SET_POSTROLL_DURATION           0x20000000L

/* flags for dwItem parameter of MCI_SETTIMECODE commmand message */
#define MCI_VCR_SETTIMECODE_RECORD              0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VCR_STATUS_FRAME_RATE               0x00004001L /* Frame rate   */
#define MCI_VCR_STATUS_SPEED                    0x00004002L /* Speed        */
#define MCI_VCR_STATUS_MEDIA_TYPE               0x00004003L
#define MCI_VCR_STATUS_RECORD_FORMAT            0x00004004L
#define MCI_VCR_STATUS_PLAY_FORMAT              0x00004005L
#define MCI_VCR_STATUS_AUDIO_SOURCE             0x00004006L
#define MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER      0x00004007L
#define MCI_VCR_STATUS_VIDEO_SOURCE             0x00004008L
#define MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER      0x00004009L
#define MCI_VCR_STATUS_AUDIO_MONITOR            0x0000400AL
#define MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER     0x0000400BL
#define MCI_VCR_STATUS_VIDEO_MONITOR            0x0000400CL
#define MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER     0x0000400DL
#define MCI_VCR_STATUS_INDEX_ON                 0x0000400EL
#define MCI_VCR_STATUS_INDEX                    0x0000400FL
#define MCI_VCR_STATUS_COUNTER_FORMAT           0x00004010L
#define MCI_VCR_STATUS_COUNTER_RESOLUTION       0x00004011L
#define MCI_VCR_STATUS_TIMECODE_TYPE            0x00004012L
#define MCI_VCR_STATUS_COUNTER_VALUE            0x00004013L
#define MCI_VCR_STATUS_TUNER_CHANNEL            0x00004014L
#define MCI_VCR_STATUS_WRITE_PROTECTED          0x00004015L
#define MCI_VCR_STATUS_TIMECODE_RECORD          0x00004016L
#define MCI_VCR_STATUS_VIDEO_RECORD             0x00004017L
#define MCI_VCR_STATUS_AUDIO_RECORD             0x00004018L
#define MCI_VCR_STATUS_TIME_TYPE                0x00004019L
#define MCI_VCR_STATUS_TIME_MODE                0x0000401AL
#define MCI_VCR_STATUS_POWER_ON                 0x0000401BL
#define MCI_VCR_STATUS_CLOCK                    0x0000401CL
#define MCI_VCR_STATUS_ASSEMBLE_RECORD          0x0000401DL
#define MCI_VCR_STATUS_TIMECODE_PRESENT         0x0000401EL
#define MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS   0x0000401FL
#define MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS   0x00004020L
#define MCI_VCR_STATUS_CLOCK_ID                 0x00004021L
#define MCI_VCR_STATUS_PAUSE_TIMEOUT            0x00004022L
#define MCI_VCR_STATUS_PREROLL_DURATION         0x00004023L
#define MCI_VCR_STATUS_POSTROLL_DURATION        0x00004024L
#define MCI_VCR_STATUS_VIDEO                    0x00004025L
#define MCI_VCR_STATUS_AUDIO                    0x00004026L

#define MCI_VCR_STATUS_NUMBER                   0x00080000L

/* flags for dwFlags parameter of MCI_ESCAPE command message */
#define MCI_VCR_ESCAPE_STRING                   0x00000100L

/* flags for dwFlags parameter of MCI_LIST command message */
#define MCI_VCR_LIST_VIDEO_SOURCE               0x00010000L
#define MCI_VCR_LIST_AUDIO_SOURCE               0x00020000L
#define MCI_VCR_LIST_COUNT                      0x00040000L
#define MCI_VCR_LIST_NUMBER                     0x00080000L

/* flags for dwFlags parameter of MCI_MARK command message */
#define MCI_VCR_MARK_WRITE                      0x00010000L
#define MCI_VCR_MARK_ERASE                      0x00020000L

/* flags for dwFlags parameter for MCI_SETAUDIO command message */
#define MCI_VCR_SETAUDIO_RECORD                 0x00010000L
#define MCI_VCR_SETAUDIO_SOURCE                 0x00020000L
#define MCI_VCR_SETAUDIO_MONITOR                0x00040000L
#define MCI_VCR_SETAUDIO_TO                     0x00200000L
#define MCI_VCR_SETAUDIO_NUMBER                 0x00400000L

/* flags for dwFlags parameter for MCI_SETVIDEO command message */
#define MCI_VCR_SETVIDEO_RECORD                 0x00010000L
#define MCI_VCR_SETVIDEO_SOURCE                 0x00020000L
#define MCI_VCR_SETVIDEO_MONITOR                0x00040000L
#define MCI_VCR_SETVIDEO_TO                     0x00100000L
#define MCI_VCR_SETVIDEO_NUMBER                 0x00200000L

/* The following is the function digitalvideo drivers must use 
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the 
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified 
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver 
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_VCR_SIGNAL_POSITION flag was set 
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwUser):(dwPos))

/* Window message for signal notification */
#define MM_MCISIGNAL                            0x3CB

/* flags for dwFlags parameter of MCI_SIGNAL command message */
#define MCI_VCR_SIGNAL_AT                       0x00010000L
#define MCI_VCR_SIGNAL_EVERY                    0x00020000L
#define MCI_VCR_SIGNAL_USERVAL                  0x00040000L
#define MCI_VCR_SIGNAL_CANCEL                   0x00080000L
#define MCI_VCR_SIGNAL_POSITION                 0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_VCR_STEP_FRAMES                     0x00010000L
#define MCI_VCR_STEP_REVERSE                    0x00020000L

/* flags for dwFlags parameter of MCI_FREEZE command message */
#define MCI_VCR_FREEZE_INPUT                    0x00010000L
#define MCI_VCR_FREEZE_OUTPUT                   0x00020000L
#define MCI_VCR_FREEZE_FIELD                    0x00040000L
#define MCI_VCR_FREEZE_FRAME                    0x00080000L

/* flags for dwFlags parameter of MCI_UNFREEZE command message */
#define MCI_VCR_UNFREEZE_INPUT                  0x00010000L
#define MCI_VCR_UNFREEZE_OUTPUT                 0x00020000L

/* string resource values for vcr media types */
#define MCI_VCR_MEDIA_8MM                       (MCI_VCR_OFFSET + 1)
#define MCI_VCR_MEDIA_HI8                       (MCI_VCR_OFFSET + 2)
#define MCI_VCR_MEDIA_VHS                       (MCI_VCR_OFFSET + 3)
#define MCI_VCR_MEDIA_SVHS                      (MCI_VCR_OFFSET + 4)
#define MCI_VCR_MEDIA_BETA                      (MCI_VCR_OFFSET + 5)
#define MCI_VCR_MEDIA_EDBETA                    (MCI_VCR_OFFSET + 6)
#define MCI_VCR_MEDIA_OTHER                     (MCI_VCR_OFFSET + 7)

/* string resource values for vcr play/record formats */
#define MCI_VCR_FORMAT_SP                       (MCI_VCR_OFFSET + 8)
#define MCI_VCR_FORMAT_LP                       (MCI_VCR_OFFSET + 9)
#define MCI_VCR_FORMAT_EP                       (MCI_VCR_OFFSET + 10)
#define MCI_VCR_FORMAT_OTHER                    (MCI_VCR_OFFSET + 11)

/* string resource values for timecode types */
#define MCI_VCR_TIME_TIMECODE                   (MCI_VCR_OFFSET + 12)
#define MCI_VCR_TIME_COUNTER                    (MCI_VCR_OFFSET + 13)
#define MCI_VCR_TIME_DETECT                     (MCI_VCR_OFFSET + 14)

/* string resource values for src types */
#define MCI_VCR_SRC_TYPE_TUNER                  (MCI_VCR_OFFSET + 15)
#define MCI_VCR_SRC_TYPE_LINE                   (MCI_VCR_OFFSET + 16)
#define MCI_VCR_SRC_TYPE_SVIDEO                 (MCI_VCR_OFFSET + 17)
#define MCI_VCR_SRC_TYPE_RGB                    (MCI_VCR_OFFSET + 18)
#define MCI_VCR_SRC_TYPE_AUX                    (MCI_VCR_OFFSET + 19)
#define MCI_VCR_SRC_TYPE_GENERIC                (MCI_VCR_OFFSET + 20)
#define MCI_VCR_SRC_TYPE_MUTE                   (MCI_VCR_OFFSET + 21)
#define MCI_VCR_SRC_TYPE_OUTPUT                 (MCI_VCR_OFFSET + 22)

/* string resource values for vcr counters */
#define MCI_VCR_INDEX_TIMECODE                  (MCI_VCR_OFFSET + 23)         
#define MCI_VCR_INDEX_COUNTER                   (MCI_VCR_OFFSET + 24)   
#define MCI_VCR_INDEX_DATE                      (MCI_VCR_OFFSET + 25)
#define MCI_VCR_INDEX_TIME                      (MCI_VCR_OFFSET + 26)

/* string resources for timecode type and counter resolution */
#define MCI_VCR_COUNTER_RES_SECONDS             (MCI_VCR_OFFSET + 27)            
#define MCI_VCR_COUNTER_RES_FRAMES              (MCI_VCR_OFFSET + 28)

#define MCI_VCR_TIMECODE_TYPE_SMPTE             (MCI_VCR_OFFSET + 29)
#define MCI_VCR_TIMECODE_TYPE_SMPTE_DROP        (MCI_VCR_OFFSET + 30)
#define MCI_VCR_TIMECODE_TYPE_OTHER             (MCI_VCR_OFFSET + 31)
#define MCI_VCR_TIMECODE_TYPE_NONE              (MCI_VCR_OFFSET + 32)

#define MCI_VCR_PLUS                            (MCI_VCR_OFFSET + 33)
#define MCI_VCR_MINUS                           (MCI_VCR_OFFSET + 34)
#define MCI_VCR_RESET                           (MCI_VCR_OFFSET + 35)

#ifndef RC_INVOKED

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_VCR_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
    DWORD   dwMark;
    DWORD   dwAt;
} MCI_VCR_SEEK_PARMS;
typedef MCI_VCR_SEEK_PARMS FAR *LPMCI_VCR_SEEK_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_VCR_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTimeMode;
    DWORD   dwRecordFormat;
    DWORD   dwCounterFormat;
    DWORD   dwIndex;
    DWORD   dwTracking;
    DWORD   dwSpeed;
    DWORD   dwLength;
    DWORD   dwCounter;
    DWORD   dwClock;
    DWORD   dwPauseTimeout;
    DWORD   dwPrerollDuration;
    DWORD   dwPostrollDuration;
} MCI_VCR_SET_PARMS;
typedef MCI_VCR_SET_PARMS FAR *LPMCI_VCR_SET_PARMS;

/* parameter block for MCI_VCR_SETTUNER command message */
typedef struct tagMCI_VCR_SETTUNER_PARMS {
    DWORD   dwCallback;
    DWORD   dwChannel;
    DWORD   dwNumber;
} MCI_VCR_SETTUNER_PARMS;
typedef MCI_VCR_SETTUNER_PARMS FAR *LPMCI_VCR_SETTUNER_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VCR_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VCR_ESCAPE_PARMS;
typedef MCI_VCR_ESCAPE_PARMS FAR *LPMCI_VCR_ESCAPE_PARMS;

/* parameter block for MCI_LIST command message */
typedef struct tagMCI_VCR_LIST_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwNumber;
} MCI_VCR_LIST_PARMS;
typedef MCI_VCR_LIST_PARMS FAR *LPMCI_VCR_LIST_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_VCR_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_RECORD_PARMS;
typedef MCI_VCR_RECORD_PARMS FAR *LPMCI_VCR_RECORD_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VCR_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_PLAY_PARMS;
typedef MCI_VCR_PLAY_PARMS FAR *LPMCI_VCR_PLAY_PARMS;

/* parameter block for MCI_SETAUDIO command message */
typedef struct tagMCI_VCR_SETAUDIO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETAUDIO_PARMS;
typedef MCI_VCR_SETAUDIO_PARMS FAR *LPMCI_VCR_SETAUDIO_PARMS;

/* parameter block for MCI_SIGNAL command message */
typedef struct tagMCI_VCR_SIGNAL_PARMS {
    DWORD   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_VCR_SIGNAL_PARMS;
typedef MCI_VCR_SIGNAL_PARMS FAR * LPMCI_VCR_SIGNAL_PARMS;

/* parameter block for MCI_VCR_STATUS command message */
typedef struct tagMCI_VCR_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    DWORD   dwNumber;
} MCI_VCR_STATUS_PARMS;
typedef MCI_VCR_STATUS_PARMS FAR * LPMCI_VCR_STATUS_PARMS;

/* parameter block for MCI_SETVIDEO command message */
typedef struct tagMCI_VCR_SETVIDEO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETVIDEO_PARMS;
typedef MCI_VCR_SETVIDEO_PARMS FAR *LPMCI_VCR_SETVIDEO_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VCR_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VCR_STEP_PARMS;
typedef MCI_VCR_STEP_PARMS FAR *LPMCI_VCR_STEP_PARMS;

/* parameter block for MCI_CUE command message */
typedef struct tagMCI_VCR_CUE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VCR_CUE_PARMS;
typedef MCI_VCR_CUE_PARMS FAR *LPMCI_VCR_CUE_PARMS;

#endif /* NOT RC_INVOKED */

/* VCR error codes */
#define MCIERR_VCR_CANNOT_OPEN_COMM         (MCIERR_CUSTOM_DRIVER_BASE + 1)
#define MCIERR_VCR_CANNOT_WRITE_COMM        (MCIERR_CUSTOM_DRIVER_BASE + 2)
#define MCIERR_VCR_READ_TIMEOUT             (MCIERR_CUSTOM_DRIVER_BASE + 3)
#define MCIERR_VCR_COMMAND_BUFFER_FULL      (MCIERR_CUSTOM_DRIVER_BASE + 4)
#define MCIERR_VCR_COMMAND_CANCELLED        (MCIERR_CUSTOM_DRIVER_BASE + 5)
#define MCIERR_VCR_POWER_OFF                (MCIERR_CUSTOM_DRIVER_BASE + 6)
#define MCIERR_VCR_COMMAND_FAILED           (MCIERR_CUSTOM_DRIVER_BASE + 7)
#define MCIERR_VCR_SEARCH                   (MCIERR_CUSTOM_DRIVER_BASE + 8)
#define MCIERR_VCR_CONDITION                (MCIERR_CUSTOM_DRIVER_BASE + 9)
#define MCIERR_VCR_CAMERA_MODE              (MCIERR_CUSTOM_DRIVER_BASE + 10)
#define MCIERR_VCR_VCR_MODE                 (MCIERR_CUSTOM_DRIVER_BASE + 11)
#define MCIERR_VCR_COUNTER_TYPE             (MCIERR_CUSTOM_DRIVER_BASE + 12)
#define MCIERR_VCR_TUNER                    (MCIERR_CUSTOM_DRIVER_BASE + 13)
#define MCIERR_VCR_EMERGENCY_STOP           (MCIERR_CUSTOM_DRIVER_BASE + 14)
#define MCIERR_VCR_MEDIA_UNMOUNTED          (MCIERR_CUSTOM_DRIVER_BASE + 15)
#define MCIERR_VCR_REGISTER                 (MCIERR_CUSTOM_DRIVER_BASE + 16)
#define MCIERR_VCR_TRACK_FAILURE            (MCIERR_CUSTOM_DRIVER_BASE + 17)
#define MCIERR_VCR_CUE_FAILED_FLAGS         (MCIERR_CUSTOM_DRIVER_BASE + 18)
#define MCIERR_VCR_ISWRITEPROTECTED         (MCIERR_CUSTOM_DRIVER_BASE + 19)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\VDDSVC.H ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    VDDSVC.H

Abstract:

    Include file contains VDM services provided for installable VDDs.


--*/


/**
 * This file contains VDM services prototype defintions only; their
 * related structures and macros are defined in NT_VDD.H.
 * If we have not included the file yet, include it and set a signal
 * to tell anybody the fact.
**/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _NT_VDD
#include "nt_vdd.h"
#define _NT_VDD
#endif


/** Memory Accessing services **/

#define GetVDMAddress(usSeg, usOff) (((ULONG)usSeg << 4) + (ULONG)usOff)

#define GetVDMPointer(Address, Size, Mode) Sim32GetVDMPointer(\
						Address, Size, Mode)

#define FlushVDMPointer(Address, Size, Buffer, Mode) Sim32FlushVDMPointer(\
					   Address, Size, Buffer, Mode)

#define FreeVDMPointer(Address, Size, Buffer, Mode) Sim32FreeVDMPointer(\
					   Address, Size, Buffer, Mode)

/** interrupt simualtion services **/

#define ICA_MASTER 0
#define ICA_SLAVE  1
#define VDDSimulateInterrupt(ms, line, count) (call_ica_hw_interrupt)(\
						   ms, line, 1)


/** Register manipulation services **/

#ifndef i386

#define	getEAX()	(ULONG)c_getAX()
#define	getAX() 	c_getAX()
#define	getAL() 	c_getAL()
#define getAH()         c_getAH()
#define	getEBX()	(ULONG)c_getBX()
#define	getBX() 	c_getBX()
#define	getBL() 	c_getBL()
#define	getBH() 	c_getBH()
#define	getECX()	(ULONG)c_getCX()
#define	getCX() 	c_getCX()
#define	getCL() 	c_getCL()
#define	getCH() 	c_getCH()
#define	getEDX()	(ULONG)c_getDX()
#define	getDX() 	c_getDX()
#define	getDL() 	c_getDL()
#define	getDH() 	c_getDH()
#define	getESP()	(ULONG)c_getSP()
#define	getSP() 	c_getSP()
#define	getEBP()	(ULONG)c_getBP()
#define	getBP() 	c_getBP()
#define	getESI()	(ULONG)c_getSI()
#define	getSI() 	c_getSI()
#define	getEDI()	(ULONG)c_getDI()
#define	getDI() 	c_getDI()
#define	getEIP()	(ULONG)c_getIP()
#define	getIP() 	c_getIP()
#define	getCS() 	c_getCS()
#define	getSS() 	c_getSS()
#define	getDS() 	c_getDS()
#define	getES() 	c_getES()
#define	getCF() 	c_getCF()
#define	getPF() 	c_getPF()
#define	getAF() 	c_getAF()
#define	getZF() 	c_getZF()
#define	getSF() 	c_getSF()
#define	getIF() 	c_getIF()
#define	getDF() 	c_getDF()
#define	getOF() 	c_getOF()
#define	getMSW()	c_getMSW()

#define	setEAX(value)	c_setAX((WORD)value)
#define	setAX(value)	c_setAX(value)
#define	setAH(value)	c_setAH(value)
#define	setAL(value)	c_setAL(value)
#define	setEBX(value)	c_setBX((WORD)value)
#define	setBX(value)	c_setBX(value)
#define	setBH(value)	c_setBH(value)
#define	setBL(value)	c_setBL(value)
#define	setECX(value)	c_setCX((WORD)value)
#define	setCX(value)	c_setCX(value)
#define	setCH(value)	c_setCH(value)
#define	setCL(value)	c_setCL(value)
#define	setEDX(value)	c_setDX((WORD)value)
#define	setDX(value)	c_setDX(value)
#define	setDH(value)	c_setDH(value)
#define	setDL(value)	c_setDL(value)
#define	setESP(value)	c_setSP((WORD)value)
#define	setSP(value)	c_setSP(value)
#define	setEBP(value)	c_setBP((WORD)value)
#define	setBP(value)	c_setBP(value)
#define	setESI(value)	c_setSI((WORD)value)
#define	setSI(value)	c_setSI(value)
#define	setEDI(value)	c_setDI((WORD)value)
#define	setDI(value)	c_setDI(value)
#define	setEIP(value)	c_setIP((WORD)value)
#define	setIP(value)	c_setIP(value)
#define	setCS(value)	c_setCS(value)
#define	setSS(value)	c_setSS(value)
#define	setDS(value)	c_setDS(value)
#define	setES(value)	c_setES(value)
#define	setCF(value)	c_setCF(value)
#define	setPF(value)	c_setPF(value)
#define	setAF(value)	c_setAF(value)
#define	setZF(value)	c_setZF(value)
#define	setSF(value)	c_setSF(value)
#define	setIF(value)	c_setIF(value)
#define	setDF(value)	c_setDF(value)
#define	setOF(value)	c_setOF(value)
#define	setMSW(value)	c_setMSW(value)

#endif


/** Real function prototype declarations **/


/** interrupt simulation functions **/

VOID
call_ica_hw_interrupt (
 int ms,
 BYTE line,
 int count
 );

#define Sim32FreeVDMPointer(address, size, buffer, mode) TRUE

/** memory address manipulation functions **/

#ifdef i386

#define Sim32GetVDMPointer(address, size, mode) MGetVdmPointer(address,\
                                                               size, mode)
#define Sim32FlushVDMPointer(addess, size, buffer, mode) TRUE

PBYTE
MGetVdmPointer(
 ULONG	 Address,
 ULONG	 Size,
 UCHAR   ProtectedMode
);

#else

PBYTE
Sim32GetVDMPointer(
 ULONG	 Address,
 ULONG   Size,
 UCHAR   ProtectedMode
);

BOOLEAN
Sim32FlushVDMPointer(
 ULONG	 Address,
 USHORT	 Size,
 PBYTE	 Buffer,
 BOOLEAN ProtectedMode
);

#endif


/** Register manipulation functions **/

#ifdef i386
ULONG   getEAX(VOID);
USHORT  getAX(VOID);
UCHAR   getAL(VOID);
UCHAR   getAH(VOID);
ULONG   getEBX(VOID);
USHORT  getBX(VOID);
UCHAR   getBL(VOID);
UCHAR   getBH(VOID);
ULONG   getECX(VOID);
USHORT  getCX(VOID);
UCHAR   getCL(VOID);
UCHAR   getCH(VOID);
ULONG   getEDX(VOID);
USHORT  getDX(VOID);
UCHAR   getDL(VOID);
UCHAR   getDH(VOID);
ULONG   getESP(VOID);
USHORT  getSP(VOID);
ULONG   getEBP(VOID);
USHORT  getBP(VOID);
ULONG   getESI(VOID);
USHORT  getSI(VOID);
ULONG   getEDI(VOID);
USHORT  getDI(VOID);
ULONG   getEIP(VOID);
USHORT  getIP(VOID);
USHORT  getCS(VOID);
USHORT  getSS(VOID);
USHORT  getDS(VOID);
USHORT  getES(VOID);
USHORT  getFS(VOID);
USHORT  getGS(VOID);
ULONG   getCF(VOID);
ULONG   getPF(VOID);
ULONG   getAF(VOID);
ULONG   getZF(VOID);
ULONG   getSF(VOID);
ULONG   getIF(VOID);
ULONG   getDF(VOID);
ULONG   getOF(VOID);
USHORT	getMSW(VOID);

VOID    setEAX(ULONG);
VOID    setAX(USHORT);
VOID    setAH(UCHAR);
VOID    setAL(UCHAR);
VOID    setEBX(ULONG);
VOID    setBX(USHORT);
VOID    setBH(UCHAR);
VOID    setBL(UCHAR);
VOID    setECX(ULONG);
VOID    setCX(USHORT);
VOID    setCH(UCHAR);
VOID    setCL(UCHAR);
VOID    setEDX(ULONG);
VOID    setDX(USHORT);
VOID    setDH(UCHAR);
VOID    setDL(UCHAR);
VOID    setESP(ULONG);
VOID    setSP(USHORT);
VOID    setEBP(ULONG);
VOID    setBP(USHORT);
VOID    setESI(ULONG);
VOID    setSI(USHORT);
VOID    setEDI(ULONG);
VOID    setDI(USHORT);
VOID    setEIP(ULONG);
VOID    setIP(USHORT);
VOID    setCS(USHORT);
VOID    setSS(USHORT);
VOID    setDS(USHORT);
VOID    setES(USHORT);
VOID    setFS(USHORT);
VOID    setGS(USHORT);
VOID    setCF(ULONG);
VOID    setPF(ULONG);
VOID    setAF(ULONG);
VOID    setZF(ULONG);
VOID    setSF(ULONG);
VOID    setIF(ULONG);
VOID    setDF(ULONG);
VOID    setOF(ULONG);
VOID    setMSW(USHORT);


#else

UCHAR c_getAL(VOID);
UCHAR c_getCL(VOID);
UCHAR c_getDL(VOID);
UCHAR c_getBL(VOID);
UCHAR c_getAH(VOID);
UCHAR c_getCH(VOID);
UCHAR c_getDH(VOID);
UCHAR c_getBH(VOID);

USHORT c_getAX(VOID);
USHORT c_getCX(VOID);
USHORT c_getDX(VOID);
USHORT c_getBX(VOID);
USHORT c_getSP(VOID);
USHORT c_getBP(VOID);
USHORT c_getSI(VOID);
USHORT c_getDI(VOID);
USHORT c_getIP(VOID);
USHORT c_getES(VOID);
USHORT c_getCS(VOID);
USHORT c_getSS(VOID);
USHORT c_getDS(VOID);

USHORT c_getMSW(VOID);

ULONG c_getAF(VOID);
ULONG c_getCF(VOID);
ULONG c_getDF(VOID);
ULONG c_getIF(VOID);
ULONG c_getOF(VOID);
ULONG c_getPF(VOID);
ULONG c_getSF(VOID);
ULONG c_getZF(VOID);

VOID c_setAL(UCHAR val);
VOID c_setCL(UCHAR val);
VOID c_setDL(UCHAR val);
VOID c_setBL(UCHAR val);
VOID c_setAH(UCHAR val);
VOID c_setCH(UCHAR val);
VOID c_setDH(UCHAR val);
VOID c_setBH(UCHAR val);

VOID c_setAX(USHORT val);
VOID c_setCX(USHORT val);
VOID c_setDX(USHORT val);
VOID c_setBX(USHORT val);
VOID c_setSP(USHORT val);
VOID c_setBP(USHORT val);
VOID c_setSI(USHORT val);
VOID c_setDI(USHORT val);
VOID c_setIP(USHORT val);

VOID c_setES(USHORT val);
VOID c_setCS(USHORT val);
VOID c_setSS(USHORT val);
VOID c_setDS(USHORT val);

VOID c_setMSW(USHORT val);

VOID c_setAF(ULONG val);
VOID c_setCF(ULONG val);
VOID c_setDF(ULONG val);
VOID c_setIF(ULONG val);
VOID c_setOF(ULONG val);
VOID c_setPF(ULONG val);
VOID c_setSF(ULONG val);
VOID c_setZF(ULONG val);

#endif


/* end of VDDSVC.H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\vdserr.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    vdserr.h

Abstract:

    Constant definitions for the Virtual Disk Service error messages.

    Error code values:
    Added in Windows Server 2003:           0x2400-0x24FF
    Added in Windows Vista:                 0x2500-0x26FF
    Added in VDS 1.1:                       0x2700-0x27FF
    Added in Windows Server "Longhorn":     0x2800-0x28FF

    NOTE:
    If porting over an error code which was added to Server 2003 SP make sure
    the error code's value is in the designated range for Windows Server 2003.
    If the value is not in the designated range make sure it does not conflict
    with any of the already defined errors and if it does change the value
    to the next available Vista value.

Author:

    Kevin Seng   [KSeng]    04/01/05

Revision History:

--*/
#pragma once
// HRESULT codes
//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Windows Server 2003:           0x2400-0x24FF
//
//////////////////////////////////////////////////////////////////////////////
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: VDS_E_NOT_SUPPORTED
//
// MessageText:
//
// The operation is not supported by the object.
//
#define VDS_E_NOT_SUPPORTED              ((HRESULT)0x80042400L)

//
// MessageId: VDS_E_INITIALIZED_FAILED
//
// MessageText:
//
// The service failed to initialize.
//
#define VDS_E_INITIALIZED_FAILED         ((HRESULT)0x80042401L)

//
// MessageId: VDS_E_INITIALIZE_NOT_CALLED
//
// MessageText:
//
// The initialization method was not called.
//
#define VDS_E_INITIALIZE_NOT_CALLED      ((HRESULT)0x80042402L)

//
// MessageId: VDS_E_ALREADY_REGISTERED
//
// MessageText:
//
// The provider is already registered.
//
#define VDS_E_ALREADY_REGISTERED         ((HRESULT)0x80042403L)

//
// MessageId: VDS_E_ANOTHER_CALL_IN_PROGRESS
//
// MessageText:
//
// A concurrent second call is made on an object before the first is completed.
//
#define VDS_E_ANOTHER_CALL_IN_PROGRESS   ((HRESULT)0x80042404L)

//
// MessageId: VDS_E_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object is not found.
//
#define VDS_E_OBJECT_NOT_FOUND           ((HRESULT)0x80042405L)

//
// MessageId: VDS_E_INVALID_SPACE
//
// MessageText:
//
// The specified space is not free or not valid.
//
#define VDS_E_INVALID_SPACE              ((HRESULT)0x80042406L)

//
// MessageId: VDS_E_PARTITION_LIMIT_REACHED
//
// MessageText:
//
// The number of partitions has reached the limit on a disk.
//
#define VDS_E_PARTITION_LIMIT_REACHED    ((HRESULT)0x80042407L)

//
// MessageId: VDS_E_PARTITION_NOT_EMPTY
//
// MessageText:
//
// The extended partition is not empty.
//
#define VDS_E_PARTITION_NOT_EMPTY        ((HRESULT)0x80042408L)

//
// MessageId: VDS_E_OPERATION_PENDING
//
// MessageText:
//
// The operation has not been completed yet.
//
#define VDS_E_OPERATION_PENDING          ((HRESULT)0x80042409L)

//
// MessageId: VDS_E_OPERATION_DENIED
//
// MessageText:
//
// This operation is is not allowed on the current boot, system or pagefile volume.
//
#define VDS_E_OPERATION_DENIED           ((HRESULT)0x8004240AL)

//
// MessageId: VDS_E_OBJECT_DELETED
//
// MessageText:
//
// The object has been deleted.
//
#define VDS_E_OBJECT_DELETED             ((HRESULT)0x8004240BL)

//
// MessageId: VDS_E_CANCEL_TOO_LATE
//
// MessageText:
//
// The operation cannot be cancelled.
//
#define VDS_E_CANCEL_TOO_LATE            ((HRESULT)0x8004240CL)

//
// MessageId: VDS_E_OPERATION_CANCELED
//
// MessageText:
//
// The operation has been cancelled.
//
#define VDS_E_OPERATION_CANCELED         ((HRESULT)0x8004240DL)

//
// MessageId: VDS_E_CANNOT_EXTEND
//
// MessageText:
//
// The volume cannot be extended because the file system does not support it.
//
#define VDS_E_CANNOT_EXTEND              ((HRESULT)0x8004240EL)

//
// MessageId: VDS_E_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough usable space for this operation.
//
#define VDS_E_NOT_ENOUGH_SPACE           ((HRESULT)0x8004240FL)

//
// MessageId: VDS_E_NOT_ENOUGH_DRIVE
//
// MessageText:
//
// Not enough drives are specified to complete this operation.
//
#define VDS_E_NOT_ENOUGH_DRIVE           ((HRESULT)0x80042410L)

//
// MessageId: VDS_E_BAD_COOKIE
//
// MessageText:
//
// The cookie is not found.
//
#define VDS_E_BAD_COOKIE                 ((HRESULT)0x80042411L)

//
// MessageId: VDS_E_NO_MEDIA
//
// MessageText:
//
// There is no media in the device.
//
#define VDS_E_NO_MEDIA                   ((HRESULT)0x80042412L)

//
// MessageId: VDS_E_DEVICE_IN_USE
//
// MessageText:
//
// The device is in use.
//
#define VDS_E_DEVICE_IN_USE              ((HRESULT)0x80042413L)

//
// MessageId: VDS_E_DISK_NOT_EMPTY
//
// MessageText:
//
// The disk is not empty.
//
#define VDS_E_DISK_NOT_EMPTY             ((HRESULT)0x80042414L)

//
// MessageId: VDS_E_INVALID_OPERATION
//
// MessageText:
//
// Invalid operation.
//
#define VDS_E_INVALID_OPERATION          ((HRESULT)0x80042415L)

//
// MessageId: VDS_E_PATH_NOT_FOUND
//
// MessageText:
//
// The path is not found.
//
#define VDS_E_PATH_NOT_FOUND             ((HRESULT)0x80042416L)

//
// MessageId: VDS_E_DISK_NOT_INITIALIZED
//
// MessageText:
//
// The disk is not initialized.
//
#define VDS_E_DISK_NOT_INITIALIZED       ((HRESULT)0x80042417L)

//
// MessageId: VDS_E_NOT_AN_UNALLOCATED_DISK
//
// MessageText:
//
// The disk is not unallocated.
//
#define VDS_E_NOT_AN_UNALLOCATED_DISK    ((HRESULT)0x80042418L)

//
// MessageId: VDS_E_UNRECOVERABLE_ERROR
//
// MessageText:
//
// An unrecoverable error occurred. The service must shut down.
//
#define VDS_E_UNRECOVERABLE_ERROR        ((HRESULT)0x80042419L)

//
// MessageId: VDS_S_DISK_PARTIALLY_CLEANED
//
// MessageText:
//
// The disk is not fully cleaned due to I/O error.
//
#define VDS_S_DISK_PARTIALLY_CLEANED     ((HRESULT)0x0004241AL)

//
// MessageId: VDS_E_DMADMIN_SERVICE_CONNECTION_FAILED
//
// MessageText:
//
// The provider failed to connect to the Logical Disk Management Administrative service.
//
#define VDS_E_DMADMIN_SERVICE_CONNECTION_FAILED ((HRESULT)0x8004241BL)

//
// MessageId: VDS_E_PROVIDER_INITIALIZATION_FAILED
//
// MessageText:
//
// The provider failed to initialize.
//
#define VDS_E_PROVIDER_INITIALIZATION_FAILED ((HRESULT)0x8004241CL)

//
// MessageId: VDS_E_OBJECT_EXISTS
//
// MessageText:
//
// The object already exists.
//
#define VDS_E_OBJECT_EXISTS              ((HRESULT)0x8004241DL)

//
// MessageId: VDS_E_NO_DISKS_FOUND
//
// MessageText:
//
// No disks were found on the target machine.
//
#define VDS_E_NO_DISKS_FOUND             ((HRESULT)0x8004241EL)

//
// MessageId: VDS_E_PROVIDER_CACHE_CORRUPT
//
// MessageText:
//
// The provider's cache has become corrupt.
//
#define VDS_E_PROVIDER_CACHE_CORRUPT     ((HRESULT)0x8004241FL)

//
// MessageId: VDS_E_DMADMIN_METHOD_CALL_FAILED
//
// MessageText:
//
// A method call to the Logical Disk Management Administrative service failed.
//
#define VDS_E_DMADMIN_METHOD_CALL_FAILED ((HRESULT)0x80042420L)

//
// MessageId: VDS_S_PROVIDER_ERROR_LOADING_CACHE
//
// MessageText:
//
// The provider encountered errors while loading the cache. See the NT Event Log for more information.
//
#define VDS_S_PROVIDER_ERROR_LOADING_CACHE ((HRESULT)0x00042421L)

//
// MessageId: VDS_E_PROVIDER_VOL_DEVICE_NAME_NOT_FOUND
//
// MessageText:
//
// The device form of the volume pathname could not be retrieved.
//
#define VDS_E_PROVIDER_VOL_DEVICE_NAME_NOT_FOUND ((HRESULT)0x80042422L)

//
// MessageId: VDS_E_PROVIDER_VOL_OPEN
//
// MessageText:
//
// Failed to open the volume device.
//
#define VDS_E_PROVIDER_VOL_OPEN          ((HRESULT)0x80042423L)

//
// MessageId: VDS_E_DMADMIN_CORRUPT_NOTIFICATION
//
// MessageText:
//
// A corrupt notification was sent from the Logical Disk Manager Administrative service.
//
#define VDS_E_DMADMIN_CORRUPT_NOTIFICATION ((HRESULT)0x80042424L)

//
// MessageId: VDS_E_INCOMPATIBLE_FILE_SYSTEM
//
// MessageText:
//
// The file system is incompatible.
//
#define VDS_E_INCOMPATIBLE_FILE_SYSTEM   ((HRESULT)0x80042425L)

//
// MessageId: VDS_E_INCOMPATIBLE_MEDIA
//
// MessageText:
//
// The media is incompatible.
//
#define VDS_E_INCOMPATIBLE_MEDIA         ((HRESULT)0x80042426L)

//
// MessageId: VDS_E_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//
#define VDS_E_ACCESS_DENIED              ((HRESULT)0x80042427L)

//
// MessageId: VDS_E_MEDIA_WRITE_PROTECTED
//
// MessageText:
//
// The media is write protected.
//
#define VDS_E_MEDIA_WRITE_PROTECTED      ((HRESULT)0x80042428L)

//
// MessageId: VDS_E_BAD_LABEL
//
// MessageText:
//
// The label is illegal.
//
#define VDS_E_BAD_LABEL                  ((HRESULT)0x80042429L)

//
// MessageId: VDS_E_CANT_QUICK_FORMAT
//
// MessageText:
//
// Can not quick format the volume.
//
#define VDS_E_CANT_QUICK_FORMAT          ((HRESULT)0x8004242AL)

//
// MessageId: VDS_E_IO_ERROR
//
// MessageText:
//
// IO error occured during format.
//
#define VDS_E_IO_ERROR                   ((HRESULT)0x8004242BL)

//
// MessageId: VDS_E_VOLUME_TOO_SMALL
//
// MessageText:
//
// The volume size is too small.
//
#define VDS_E_VOLUME_TOO_SMALL           ((HRESULT)0x8004242CL)

//
// MessageId: VDS_E_VOLUME_TOO_BIG
//
// MessageText:
//
// The volume size is too big.
//
#define VDS_E_VOLUME_TOO_BIG             ((HRESULT)0x8004242DL)

//
// MessageId: VDS_E_CLUSTER_SIZE_TOO_SMALL
//
// MessageText:
//
// The cluster size is too small.
//
#define VDS_E_CLUSTER_SIZE_TOO_SMALL     ((HRESULT)0x8004242EL)

//
// MessageId: VDS_E_CLUSTER_SIZE_TOO_BIG
//
// MessageText:
//
// The cluster size is too big.
//
#define VDS_E_CLUSTER_SIZE_TOO_BIG       ((HRESULT)0x8004242FL)

//
// MessageId: VDS_E_CLUSTER_COUNT_BEYOND_32BITS
//
// MessageText:
//
// The number of clusters is too big for 32 bit integer.
//
#define VDS_E_CLUSTER_COUNT_BEYOND_32BITS ((HRESULT)0x80042430L)

//
// MessageId: VDS_E_OBJECT_STATUS_FAILED
//
// MessageText:
//
// The object is in failed status.
//
#define VDS_E_OBJECT_STATUS_FAILED       ((HRESULT)0x80042431L)

//
// MessageId: VDS_E_VOLUME_INCOMPLETE
//
// MessageText:
//
// All extents for the volume could not be found.
//
#define VDS_E_VOLUME_INCOMPLETE          ((HRESULT)0x80042432L)

//
// MessageId: VDS_E_EXTENT_SIZE_LESS_THAN_MIN
//
// MessageText:
//
// The size of the extent is less than the minimum.
//
#define VDS_E_EXTENT_SIZE_LESS_THAN_MIN  ((HRESULT)0x80042433L)

//
// MessageId: VDS_S_UPDATE_BOOTFILE_FAILED
//
// MessageText:
//
// Failed to update the boot configuration data.
//
#define VDS_S_UPDATE_BOOTFILE_FAILED     ((HRESULT)0x00042434L)

//
// MessageId: VDS_S_BOOT_PARTITION_NUMBER_CHANGE
//
// MessageText:
//
// The boot partition's partition number will change as a result of the operation.
//
#define VDS_S_BOOT_PARTITION_NUMBER_CHANGE ((HRESULT)0x00042436L)

//
// MessageId: VDS_E_BOOT_PARTITION_NUMBER_CHANGE
//
// MessageText:
//
// The boot partition's partition number will change as a result of the migration operation.
//
#define VDS_E_BOOT_PARTITION_NUMBER_CHANGE ((HRESULT)0x80042436L)

//
// MessageId: VDS_E_NO_FREE_SPACE
//
// MessageText:
//
// The selected disk does not have enough free space to complete the operation.
//
#define VDS_E_NO_FREE_SPACE              ((HRESULT)0x80042437L)

//
// MessageId: VDS_E_ACTIVE_PARTITION
//
// MessageText:
//
// An active partition was detected on the selected disk, and it is not the active partition used to boot the currently running OS.
//
#define VDS_E_ACTIVE_PARTITION           ((HRESULT)0x80042438L)

//
// MessageId: VDS_E_PARTITION_OF_UNKNOWN_TYPE
//
// MessageText:
//
// Cannot read partition information.
//
#define VDS_E_PARTITION_OF_UNKNOWN_TYPE  ((HRESULT)0x80042439L)

//
// MessageId: VDS_E_LEGACY_VOLUME_FORMAT
//
// MessageText:
//
// A partition with an unknown type was detected on the selected disk.
//
#define VDS_E_LEGACY_VOLUME_FORMAT       ((HRESULT)0x8004243AL)

//
// MessageId: VDS_E_NON_CONTIGUOUS_DATA_PARTITIONS
//
// MessageText:
//
// The selected GPT formatted disk contains a partition which is not of type 'PARTITION_BASIC_DATA_GUID', and is both preceeded and followed by a partition of type 'PARTITION_BASIC_DATA_GUID'.
//
#define VDS_E_NON_CONTIGUOUS_DATA_PARTITIONS ((HRESULT)0x8004243BL)

//
// MessageId: VDS_E_MIGRATE_OPEN_VOLUME
//
// MessageText:
//
// A volume on the selected disk could not be opened.
//
#define VDS_E_MIGRATE_OPEN_VOLUME        ((HRESULT)0x8004243CL)

//
// MessageId: VDS_E_VOLUME_NOT_ONLINE
//
// MessageText:
//
// The volume is not online.
//
#define VDS_E_VOLUME_NOT_ONLINE          ((HRESULT)0x8004243DL)

//
// MessageId: VDS_E_VOLUME_NOT_HEALTHY
//
// MessageText:
//
// The volume is not healthy.
//
#define VDS_E_VOLUME_NOT_HEALTHY         ((HRESULT)0x8004243EL)

//
// MessageId: VDS_E_VOLUME_SPANS_DISKS
//
// MessageText:
//
// The volume spans multiple disks.
//
#define VDS_E_VOLUME_SPANS_DISKS         ((HRESULT)0x8004243FL)

//
// MessageId: VDS_E_REQUIRES_CONTIGUOUS_DISK_SPACE
//
// MessageText:
//
// The volume requires contiguous disk extents.
//
#define VDS_E_REQUIRES_CONTIGUOUS_DISK_SPACE ((HRESULT)0x80042440L)

//
// MessageId: VDS_E_BAD_PROVIDER_DATA
//
// MessageText:
//
// A provider returned bad data.
//
#define VDS_E_BAD_PROVIDER_DATA          ((HRESULT)0x80042441L)

//
// MessageId: VDS_E_PROVIDER_FAILURE
//
// MessageText:
//
// A provider failed to complete an operation.
//
#define VDS_E_PROVIDER_FAILURE           ((HRESULT)0x80042442L)

//
// MessageId: VDS_S_VOLUME_COMPRESS_FAILED
//
// MessageText:
//
// Failed to compress the volume.
//
#define VDS_S_VOLUME_COMPRESS_FAILED     ((HRESULT)0x00042443L)

//
// MessageId: VDS_E_PACK_OFFLINE
//
// MessageText:
//
// The pack is not online.
//
#define VDS_E_PACK_OFFLINE               ((HRESULT)0x80042444L)

//
// MessageId: VDS_E_VOLUME_NOT_A_MIRROR
//
// MessageText:
//
// The volume is not a mirror.
//
#define VDS_E_VOLUME_NOT_A_MIRROR        ((HRESULT)0x80042445L)

//
// MessageId: VDS_E_NO_EXTENTS_FOR_VOLUME
//
// MessageText:
//
// No extents were found for the volume.
//
#define VDS_E_NO_EXTENTS_FOR_VOLUME      ((HRESULT)0x80042446L)

//
// MessageId: VDS_E_DISK_NOT_LOADED_TO_CACHE
//
// MessageText:
//
// The disk failed to load to the cache.
//
#define VDS_E_DISK_NOT_LOADED_TO_CACHE   ((HRESULT)0x80042447L)

//
// MessageId: VDS_E_INTERNAL_ERROR
//
// MessageText:
//
// Check the event log for errors.
//
#define VDS_E_INTERNAL_ERROR             ((HRESULT)0x80042448L)

//
// MessageId: VDS_S_ACCESS_PATH_NOT_DELETED
//
// MessageText:
//
// The access paths on the volume may not be deleted.
//
#define VDS_S_ACCESS_PATH_NOT_DELETED    ((HRESULT)0x00044244L)

//
// MessageId: VDS_E_PROVIDER_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The method call is not supported for the specified provider type.
//
#define VDS_E_PROVIDER_TYPE_NOT_SUPPORTED ((HRESULT)0x8004244AL)

//
// MessageId: VDS_E_DISK_NOT_ONLINE
//
// MessageText:
//
// The disk is not online.
//
#define VDS_E_DISK_NOT_ONLINE            ((HRESULT)0x8004244BL)

//
// MessageId: VDS_E_DISK_IN_USE_BY_VOLUME
//
// MessageText:
//
// The disk is already in use by the volume.
//
#define VDS_E_DISK_IN_USE_BY_VOLUME      ((HRESULT)0x8004244CL)

//
// MessageId: VDS_S_IN_PROGRESS
//
// MessageText:
//
// The asynchronous operation is in progress.
//
#define VDS_S_IN_PROGRESS                ((HRESULT)0x0004244DL)

//
// MessageId: VDS_E_ASYNC_OBJECT_FAILURE
//
// MessageText:
//
// Failure initializing the asynchronous object.
//
#define VDS_E_ASYNC_OBJECT_FAILURE       ((HRESULT)0x8004244EL)

//
// MessageId: VDS_E_VOLUME_NOT_MOUNTED
//
// MessageText:
//
// The volume is not mounted.
//
#define VDS_E_VOLUME_NOT_MOUNTED         ((HRESULT)0x8004244FL)

//
// MessageId: VDS_E_PACK_NOT_FOUND
//
// MessageText:
//
// The pack was not found.
//
#define VDS_E_PACK_NOT_FOUND             ((HRESULT)0x80042450L)

//
// MessageId: VDS_E_IMPORT_SET_INCOMPLETE
//
// MessageText:
//
// Import failed. Attempt to import a subset of the disks in the foreign pack.
//
#define VDS_E_IMPORT_SET_INCOMPLETE      ((HRESULT)0x80042451L)

//
// MessageId: VDS_E_DISK_NOT_IMPORTED
//
// MessageText:
//
// A disk in the import's source pack was not imported.
//
#define VDS_E_DISK_NOT_IMPORTED          ((HRESULT)0x80042452L)

//
// MessageId: VDS_E_OBJECT_OUT_OF_SYNC
//
// MessageText:
//
// The system's information about the object may not be up to date.
//
#define VDS_E_OBJECT_OUT_OF_SYNC         ((HRESULT)0x80042453L)

//
// MessageId: VDS_E_MISSING_DISK
//
// MessageText:
//
// The disk is missing.
//
#define VDS_E_MISSING_DISK               ((HRESULT)0x80042454L)

//
// MessageId: VDS_E_DISK_PNP_REG_CORRUPT
//
// MessageText:
//
// The provider's list of Pnp registered disks has become corrupt.
//
#define VDS_E_DISK_PNP_REG_CORRUPT       ((HRESULT)0x80042455L)

//
// MessageId: VDS_E_LBN_REMAP_ENABLED_FLAG
//
// MessageText:
//
// The provider does not support the LBN REMAP ENABLED volume flag.
//
#define VDS_E_LBN_REMAP_ENABLED_FLAG     ((HRESULT)0x80042456L)

//
// MessageId: VDS_E_NO_DRIVELETTER_FLAG
//
// MessageText:
//
// The provider does not support the NO DRIVELETTER volume flag.
//
#define VDS_E_NO_DRIVELETTER_FLAG        ((HRESULT)0x80042457L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE
//
// MessageText:
//
// REVERT ON CLOSE may only be used with GPT flags HIDDEN, READ ONLY, NO DRIVE LETTER or SHADOW COPY.
//
#define VDS_E_REVERT_ON_CLOSE            ((HRESULT)0x80042458L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE_SET
//
// MessageText:
//
// The REVERT ON CLOSE volume flag is already set for this volume.
//
#define VDS_E_REVERT_ON_CLOSE_SET        ((HRESULT)0x80042459L)

//
// MessageId: VDS_E_IA64_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// Not used! You have mirrored your boot volume on a GPT disk, to an MBR disk. You will not be able to boot your machine from the secondary plex.
//
#define VDS_E_IA64_BOOT_MIRRORED_TO_MBR  ((HRESULT)0x8004245AL)

//
// MessageId: VDS_S_IA64_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// You have mirrored your boot volume on a GPT disk, to an MBR disk. You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_IA64_BOOT_MIRRORED_TO_MBR  ((HRESULT)0x0004245AL)

//
// MessageId: VDS_S_UNABLE_TO_GET_GPT_ATTRIBUTES
//
// MessageText:
//
// Unable to retrieve the GPT attributes for this volume, (hidden, read only and no drive letter).
//
#define VDS_S_UNABLE_TO_GET_GPT_ATTRIBUTES ((HRESULT)0x0004245BL)

//
// MessageId: VDS_E_VOLUME_TEMPORARILY_DISMOUNTED
//
// MessageText:
//
// The volume is temporarily dismounted.
//
#define VDS_E_VOLUME_TEMPORARILY_DISMOUNTED ((HRESULT)0x8004245CL)

//
// MessageId: VDS_E_VOLUME_PERMANENTLY_DISMOUNTED
//
// MessageText:
//
// The volume is permanently dismounted.
//
#define VDS_E_VOLUME_PERMANENTLY_DISMOUNTED ((HRESULT)0x8004245DL)

//
// MessageId: VDS_E_VOLUME_HAS_PATH
//
// MessageText:
//
// The volume still has access path to it.
//
#define VDS_E_VOLUME_HAS_PATH            ((HRESULT)0x8004245EL)

//
// MessageId: VDS_E_TIMEOUT
//
// MessageText:
//
// The operation timed out.
//
#define VDS_E_TIMEOUT                    ((HRESULT)0x8004245FL)

//
// MessageId: VDS_E_REPAIR_VOLUMESTATE
//
// MessageText:
//
// To repair a volume, both the volume and plex must be online, and must not be healthy or rebuilding.
//
#define VDS_E_REPAIR_VOLUMESTATE         ((HRESULT)0x80042460L)

//
// MessageId: VDS_E_LDM_TIMEOUT
//
// MessageText:
//
// The operation timed out in the Logical Disk Manager Administrative service. Retry the operation.
//
#define VDS_E_LDM_TIMEOUT                ((HRESULT)0x80042461L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE_MISMATCH
//
// MessageText:
//
// When clearing volume flags that have been set using revert on close, the same combination of HIDDEN, READ ONLY, NO DRIVE LETTER or SHADOW COPY flags must be passed to both the SetFlags and ClearFlags calls.
//
#define VDS_E_REVERT_ON_CLOSE_MISMATCH   ((HRESULT)0x80042462L)

//
// MessageId: VDS_E_RETRY
//
// MessageText:
//
// The operation failed. Retry the operation.
//
#define VDS_E_RETRY                      ((HRESULT)0x80042463L)

//
// MessageId: VDS_E_ONLINE_PACK_EXISTS
//
// MessageText:
//
// Create pack operation failed. An online pack already exists.
//
#define VDS_E_ONLINE_PACK_EXISTS         ((HRESULT)0x80042464L)

//
// MessageId: VDS_S_EXTEND_FILE_SYSTEM_FAILED
//
// MessageText:
//
// The volume was extended successfully but the file system failed to extend.
//
#define VDS_S_EXTEND_FILE_SYSTEM_FAILED  ((HRESULT)0x00042465L)

//
// MessageId: VDS_E_EXTEND_FILE_SYSTEM_FAILED
//
// MessageText:
//
// The file system failed to extend.
//
#define VDS_E_EXTEND_FILE_SYSTEM_FAILED  ((HRESULT)0x80042466L)

//
// MessageId: VDS_S_MBR_BOOT_MIRRORED_TO_GPT
//
// MessageText:
//
// You have mirrored your boot volume on an MBR disk, to a GPT disk. You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_MBR_BOOT_MIRRORED_TO_GPT   ((HRESULT)0x00042467L)

//
// MessageId: VDS_E_MAX_USABLE_MBR
//
// MessageText:
//
// Only the first 2TB are usable on large MBR disks. Cannot create partitions beyond the 2TB mark, nor convert the disk to dynamic.
//
#define VDS_E_MAX_USABLE_MBR             ((HRESULT)0x80042468L)

//
// MessageId: VDS_S_GPT_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// You have mirrored your boot volume on a GPT disk, to an MBR disk. You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_GPT_BOOT_MIRRORED_TO_MBR   ((HRESULT)0x80042469L)

//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Windows Vista:                 0x2500-0x26FF
//
//////////////////////////////////////////////////////////////////////////////
//
// MessageId: VDS_E_NO_SOFTWARE_PROVIDERS_LOADED
//
// MessageText:
//
// There are no software provders loaded.
//
#define VDS_E_NO_SOFTWARE_PROVIDERS_LOADED ((HRESULT)0x80042500L)

//
// MessageId: VDS_E_DISK_NOT_MISSING
//
// MessageText:
//
// The disk is not missing.
//
#define VDS_E_DISK_NOT_MISSING           ((HRESULT)0x80042501L)

//
// MessageId: VDS_E_NO_VOLUME_LAYOUT
//
// MessageText:
//
// Failed to retrieve the volume's layout. Operations on the volume will fail.
//
#define VDS_E_NO_VOLUME_LAYOUT           ((HRESULT)0x80042502L)

//
// MessageId: VDS_E_CORRUPT_VOLUME_INFO
//
// MessageText:
//
// The volume's driver information is corrupt. Operations on the volume will fail.
//
#define VDS_E_CORRUPT_VOLUME_INFO        ((HRESULT)0x80042503L)

//
// MessageId: VDS_E_INVALID_ENUMERATOR
//
// MessageText:
//
// The enumerator is corrupted.
//
#define VDS_E_INVALID_ENUMERATOR         ((HRESULT)0x80042504L)

//
// MessageId: VDS_E_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// Internal error in the volume management driver.
//
#define VDS_E_DRIVER_INTERNAL_ERROR      ((HRESULT)0x80042505L)

//
// MessageId: VDS_E_VOLUME_INVALID_NAME
//
// MessageText:
//
// The volume name is invalid.
//
#define VDS_E_VOLUME_INVALID_NAME        ((HRESULT)0x80042507L)

//
// MessageId: VDS_S_DISK_IS_MISSING
//
// MessageText:
//
// The disk is missing, not all information could be returned.
//
#define VDS_S_DISK_IS_MISSING            ((HRESULT)0x00042508L)

//
// MessageId: VDS_E_CORRUPT_PARTITION_INFO
//
// MessageText:
//
// The disk's partition information is corrupted.
//
#define VDS_E_CORRUPT_PARTITION_INFO     ((HRESULT)0x80042509L)

//
// MessageId: VDS_S_NONCONFORMANT_PARTITION_INFO
//
// MessageText:
//
// The disk's partition information is does not conform to that expected on a dynamic disk.
//
#define VDS_S_NONCONFORMANT_PARTITION_INFO ((HRESULT)0x0004250AL)

//
// MessageId: VDS_E_CORRUPT_EXTENT_INFO
//
// MessageText:
//
// The disk's extent information is corrupted.
//
#define VDS_E_CORRUPT_EXTENT_INFO        ((HRESULT)0x8004250BL)

//
// MessageId: VDS_E_DUP_EMPTY_PACK_GUID
//
// MessageText:
//
// An empty pack already exists. Release the existing empty pack before creating another empty pack.
//
#define VDS_E_DUP_EMPTY_PACK_GUID        ((HRESULT)0x8004250CL)

//
// MessageId: VDS_E_DRIVER_NO_PACK_NAME
//
// MessageText:
//
// The volume management driver did not return a pack name. Internal driver error.
//
#define VDS_E_DRIVER_NO_PACK_NAME        ((HRESULT)0x8004250DL)

//
// MessageId: VDS_S_SYSTEM_PARTITION
//
// MessageText:
//
// Warning, there was a failure while checking for the system partition.
//
#define VDS_S_SYSTEM_PARTITION           ((HRESULT)0x0004250EL)

//
// MessageId: VDS_E_BAD_PNP_MESSAGE
//
// MessageText:
//
// The PNP service sent a corrupted notification to the provider.
//
#define VDS_E_BAD_PNP_MESSAGE            ((HRESULT)0x8004250FL)

//
// MessageId: VDS_E_NO_PNP_DISK_ARRIVE
//
// MessageText:
//
// No disk arrival notification was received.
//
#define VDS_E_NO_PNP_DISK_ARRIVE         ((HRESULT)0x80042510L)

//
// MessageId: VDS_E_NO_PNP_VOLUME_ARRIVE
//
// MessageText:
//
// No volume arrival notification was received.
//
#define VDS_E_NO_PNP_VOLUME_ARRIVE       ((HRESULT)0x80042511L)

//
// MessageId: VDS_E_NO_PNP_DISK_REMOVE
//
// MessageText:
//
// No disk removal notification was received.
//
#define VDS_E_NO_PNP_DISK_REMOVE         ((HRESULT)0x80042512L)

//
// MessageId: VDS_E_NO_PNP_VOLUME_REMOVE
//
// MessageText:
//
// No volume removal notification was received.
//
#define VDS_E_NO_PNP_VOLUME_REMOVE       ((HRESULT)0x80042513L)

//
// MessageId: VDS_E_PROVIDER_EXITING
//
// MessageText:
//
// The provider is exiting.
//
#define VDS_E_PROVIDER_EXITING           ((HRESULT)0x80042514L)

//
// MessageId: VDS_E_EXTENT_EXCEEDS_DISK_FREE_SPACE
//
// MessageText:
//
// The specified disk extent size exceeds the size of free disk space.
//
#define VDS_E_EXTENT_EXCEEDS_DISK_FREE_SPACE ((HRESULT)0x80042515L)

//
// MessageId: VDS_E_MEMBER_SIZE_INVALID
//
// MessageText:
//
// The size of the plex member is invalid.
//
#define VDS_E_MEMBER_SIZE_INVALID        ((HRESULT)0x80042516L)

//
// MessageId: VDS_S_NO_NOTIFICATION
//
// MessageText:
//
// No volume arrival notification was received. Refresh the Disk Management display.
//
#define VDS_S_NO_NOTIFICATION            ((HRESULT)0x00042517L)

//
// MessageId: VDS_S_DEFAULT_PLEX_MEMBER_IDS
//
// MessageText:
//
// Defaults have been used for the member ids or plex ids.
//
#define VDS_S_DEFAULT_PLEX_MEMBER_IDS    ((HRESULT)0x00042518L)

//
// MessageId: VDS_E_INVALID_DISK
//
// MessageText:
//
// This operation is not allowed on an invalid disk.
//
#define VDS_E_INVALID_DISK               ((HRESULT)0x80042519L)

//
// MessageId: VDS_E_INVALID_PACK
//
// MessageText:
//
// This operation is not allowed on the invalid disk pack.
//
#define VDS_E_INVALID_PACK               ((HRESULT)0x8004251AL)

//
// MessageId: VDS_E_VOLUME_ON_DISK
//
// MessageText:
//
// This operation is not allowed on disks with volumes.
//
#define VDS_E_VOLUME_ON_DISK             ((HRESULT)0x8004251BL)

//
// MessageId: VDS_E_DRIVER_INVALID_PARAM
//
// MessageText:
//
// The driver returned an invalid parameter error.
//
#define VDS_E_DRIVER_INVALID_PARAM       ((HRESULT)0x8004251CL)

//
// MessageId: VDS_E_TARGET_PACK_NOT_EMPTY
//
// MessageText:
//
// The target pack is not empty.
//
#define VDS_E_TARGET_PACK_NOT_EMPTY      ((HRESULT)0x8004251DL)

//
// MessageId: VDS_E_CANNOT_SHRINK
//
// MessageText:
//
// The volume cannot be shrunk because the file system does not support it.
//
#define VDS_E_CANNOT_SHRINK              ((HRESULT)0x8004251EL)

//
// MessageId: VDS_E_MULTIPLE_PACKS
//
// MessageText:
//
// Specified disks are not all from the same pack.
//
#define VDS_E_MULTIPLE_PACKS             ((HRESULT)0x8004251FL)

//
// MessageId: VDS_E_PACK_ONLINE
//
// MessageText:
//
// This operation is not allowed on online packs. The pack must be offline.
//
#define VDS_E_PACK_ONLINE                ((HRESULT)0x80042520L)

//
// MessageId: VDS_E_INVALID_PLEX_COUNT
//
// MessageText:
//
// The plex count for the volume must be non-zero.
//
#define VDS_E_INVALID_PLEX_COUNT         ((HRESULT)0x80042521L)

//
// MessageId: VDS_E_INVALID_MEMBER_COUNT
//
// MessageText:
//
// The member count for the volume must be non-zero.
//
#define VDS_E_INVALID_MEMBER_COUNT       ((HRESULT)0x80042522L)

//
// MessageId: VDS_E_INVALID_PLEX_ORDER
//
// MessageText:
//
// The plex indexes must be monotonically increasing and begin with zero.
//
#define VDS_E_INVALID_PLEX_ORDER         ((HRESULT)0x80042523L)

//
// MessageId: VDS_E_INVALID_MEMBER_ORDER
//
// MessageText:
//
// The member indexes must be monotonically increasing and begin with zero.
//
#define VDS_E_INVALID_MEMBER_ORDER       ((HRESULT)0x80042524L)

//
// MessageId: VDS_E_INVALID_STRIPE_SIZE
//
// MessageText:
//
// The stripe size must be a multiple of 2, between 512 bytes and 1 MB, for stripe and raid5 volumes. The stripe size must be zero for other volume types.
//
#define VDS_E_INVALID_STRIPE_SIZE        ((HRESULT)0x80042525L)

//
// MessageId: VDS_E_INVALID_DISK_COUNT
//
// MessageText:
//
// The number of disks specified is invalid for this operation.
//
#define VDS_E_INVALID_DISK_COUNT         ((HRESULT)0x80042526L)

//
// MessageId: VDS_E_INVALID_EXTENT_COUNT
//
// MessageText:
//
// An invalid number of extents was specified for at least one disk.
//
#define VDS_E_INVALID_EXTENT_COUNT       ((HRESULT)0x80042527L)

//
// MessageId: VDS_E_SOURCE_IS_TARGET_PACK
//
// MessageText:
//
// The source and target packs must be distinct.
//
#define VDS_E_SOURCE_IS_TARGET_PACK      ((HRESULT)0x80042528L)

//
// MessageId: VDS_E_VOLUME_DISK_COUNT_MAX_EXCEEDED
//
// MessageText:
//
// The disk count for the volume exceeds the maximum.
//
#define VDS_E_VOLUME_DISK_COUNT_MAX_EXCEEDED ((HRESULT)0x80042529L)

//
// MessageId: VDS_E_CORRUPT_NOTIFICATION_INFO
//
// MessageText:
//
// The driver's notification info is corrupt.
//
#define VDS_E_CORRUPT_NOTIFICATION_INFO  ((HRESULT)0x8004252AL)

//
// MessageId: VDS_E_INVALID_PLEX_GUID
//
// MessageText:
//
// GUID_NULL is not a valid plex GUID.
//
#define VDS_E_INVALID_PLEX_GUID          ((HRESULT)0x8004252CL)

//
// MessageId: VDS_E_DISK_NOT_FOUND_IN_PACK
//
// MessageText:
//
// The specified disks do not belong to the same pack.
//
#define VDS_E_DISK_NOT_FOUND_IN_PACK     ((HRESULT)0x8004252DL)

//
// MessageId: VDS_E_DUPLICATE_DISK
//
// MessageText:
//
// The same disk was specified more than once.
//
#define VDS_E_DUPLICATE_DISK             ((HRESULT)0x8004252EL)

//
// MessageId: VDS_E_LAST_VALID_DISK
//
// MessageText:
//
// The operation cannot be completed because there is only one valid disk in the pack.
//
#define VDS_E_LAST_VALID_DISK            ((HRESULT)0x8004252FL)

//
// MessageId: VDS_E_INVALID_SECTOR_SIZE
//
// MessageText:
//
// All disks holding extents for a given volume must have the same sector size, and the sector size must be valid.
//
#define VDS_E_INVALID_SECTOR_SIZE        ((HRESULT)0x80042530L)

//
// MessageId: VDS_E_ONE_EXTENT_PER_DISK
//
// MessageText:
//
// This call requires the parameters to specify one extent per disk. A single disk cannot contribute to multiple members or plexes of the same volume.
//
#define VDS_E_ONE_EXTENT_PER_DISK        ((HRESULT)0x80042531L)

//
// MessageId: VDS_E_INVALID_BLOCK_SIZE
//
// MessageText:
//
// Neither the volume stripe size or disk sector size was found to be non-zero.
//
#define VDS_E_INVALID_BLOCK_SIZE         ((HRESULT)0x80042532L)

//
// MessageId: VDS_E_PLEX_SIZE_INVALID
//
// MessageText:
//
// The size of the volume plex is invalid.
//
#define VDS_E_PLEX_SIZE_INVALID          ((HRESULT)0x80042533L)

//
// MessageId: VDS_E_NO_EXTENTS_FOR_PLEX
//
// MessageText:
//
// No extents were found for the plex.
//
#define VDS_E_NO_EXTENTS_FOR_PLEX        ((HRESULT)0x80042534L)

//
// MessageId: VDS_E_INVALID_PLEX_TYPE
//
// MessageText:
//
// The plex type is invalid.
//
#define VDS_E_INVALID_PLEX_TYPE          ((HRESULT)0x80042535L)

//
// MessageId: VDS_E_INVALID_PLEX_BLOCK_SIZE
//
// MessageText:
//
// The plex block size must be non-zero.
//
#define VDS_E_INVALID_PLEX_BLOCK_SIZE    ((HRESULT)0x80042536L)

//
// MessageId: VDS_E_NO_HEALTHY_DISKS
//
// MessageText:
//
// All of the disks involved in the operation are either missing or failed.
//
#define VDS_E_NO_HEALTHY_DISKS           ((HRESULT)0x80042537L)

//
// MessageId: VDS_E_CONFIG_LIMIT
//
// MessageText:
//
// The Logical Disk Manangement database is full, no more volumes or disks may be configured.
//
#define VDS_E_CONFIG_LIMIT               ((HRESULT)0x80042538L)

//
// MessageId: VDS_E_DISK_CONFIGURATION_CORRUPTED
//
// MessageText:
//
// The disk configuration data is corrupted.
//
#define VDS_E_DISK_CONFIGURATION_CORRUPTED ((HRESULT)0x80042539L)

//
// MessageId: VDS_E_DISK_CONFIGURATION_NOT_IN_SYNC
//
// MessageText:
//
// The disk configuration is not insync with the in-memory configuration.
//
#define VDS_E_DISK_CONFIGURATION_NOT_IN_SYNC ((HRESULT)0x8004253AL)

//
// MessageId: VDS_E_DISK_CONFIGURATION_UPDATE_FAILED
//
// MessageText:
//
// One or more disks failed to be updated with the new configuration.
//
#define VDS_E_DISK_CONFIGURATION_UPDATE_FAILED ((HRESULT)0x8004253BL)

//
// MessageId: VDS_E_DISK_DYNAMIC
//
// MessageText:
//
// The disk is already dynamic.
//
#define VDS_E_DISK_DYNAMIC               ((HRESULT)0x8004253CL)

//
// MessageId: VDS_E_DRIVER_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object was not found in the driver cache.
//
#define VDS_E_DRIVER_OBJECT_NOT_FOUND    ((HRESULT)0x8004253DL)

//
// MessageId: VDS_E_PARTITION_NOT_CYLINDER_ALIGNED
//
// MessageText:
//
// The disk layout contains partitions which are not cylinder aligned.
//
#define VDS_E_PARTITION_NOT_CYLINDER_ALIGNED ((HRESULT)0x8004253EL)

//
// MessageId: VDS_E_DISK_LAYOUT_PARTITIONS_TOO_SMALL
//
// MessageText:
//
// The disk layout contains partitions which less than the minimum required size.
//
#define VDS_E_DISK_LAYOUT_PARTITIONS_TOO_SMALL ((HRESULT)0x8004253FL)

//
// MessageId: VDS_E_DISK_IO_FAILING
//
// MessageText:
//
// The IO to the disk is failing.
//
#define VDS_E_DISK_IO_FAILING            ((HRESULT)0x80042540L)

//
// MessageId: VDS_E_DYNAMIC_DISKS_NOT_SUPPORTED
//
// MessageText:
//
// The dynamic disks are not supported by this operating system.
//
#define VDS_E_DYNAMIC_DISKS_NOT_SUPPORTED ((HRESULT)0x80042541L)

//
// MessageId: VDS_E_FAULT_TOLERANT_DISKS_NOT_SUPPORTED
//
// MessageText:
//
// The fault tolerant disks are not supported by this operating system.
//
#define VDS_E_FAULT_TOLERANT_DISKS_NOT_SUPPORTED ((HRESULT)0x80042542L)

//
// MessageId: VDS_E_GPT_ATTRIBUTES_INVALID
//
// MessageText:
//
// Invalid GPT attributes were specified.
//
#define VDS_E_GPT_ATTRIBUTES_INVALID     ((HRESULT)0x80042543L)

//
// MessageId: VDS_E_MEMBER_IS_HEALTHY
//
// MessageText:
//
// The member is not stale or detached.
//
#define VDS_E_MEMBER_IS_HEALTHY          ((HRESULT)0x80042544L)

//
// MessageId: VDS_E_MEMBER_REGENERATING
//
// MessageText:
//
// The member is regenerating.
//
#define VDS_E_MEMBER_REGENERATING        ((HRESULT)0x80042545L)

//
// MessageId: VDS_E_PACK_NAME_INVALID
//
// MessageText:
//
// The pack name is invalid.
//
#define VDS_E_PACK_NAME_INVALID          ((HRESULT)0x80042546L)

//
// MessageId: VDS_E_PLEX_IS_HEALTHY
//
// MessageText:
//
// The plex is not stale or detached.
//
#define VDS_E_PLEX_IS_HEALTHY            ((HRESULT)0x80042547L)

//
// MessageId: VDS_E_PLEX_LAST_ACTIVE
//
// MessageText:
//
// The last healthy plex cannot be removed.
//
#define VDS_E_PLEX_LAST_ACTIVE           ((HRESULT)0x80042548L)

//
// MessageId: VDS_E_PLEX_MISSING
//
// MessageText:
//
// The plex is missing.
//
#define VDS_E_PLEX_MISSING               ((HRESULT)0x80042549L)

//
// MessageId: VDS_E_MEMBER_MISSING
//
// MessageText:
//
// The member is missing.
//
#define VDS_E_MEMBER_MISSING             ((HRESULT)0x8004254AL)

//
// MessageId: VDS_E_PLEX_REGENERATING
//
// MessageText:
//
// The plex is regenerating.
//
#define VDS_E_PLEX_REGENERATING          ((HRESULT)0x8004254BL)

//
// MessageId: VDS_E_UNEXPECTED_DISK_LAYOUT_CHANGE
//
// MessageText:
//
// An unexpected layout change occurred external to the volume manager.
//
#define VDS_E_UNEXPECTED_DISK_LAYOUT_CHANGE ((HRESULT)0x8004254DL)

//
// MessageId: VDS_E_INVALID_VOLUME_LENGTH
//
// MessageText:
//
// The volume length is invalid.
//
#define VDS_E_INVALID_VOLUME_LENGTH      ((HRESULT)0x8004254EL)

//
// MessageId: VDS_E_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE
//
// MessageText:
//
// The volume length is not a multiple of the sector size.
//
#define VDS_E_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE ((HRESULT)0x8004254FL)

//
// MessageId: VDS_E_VOLUME_NOT_RETAINED
//
// MessageText:
//
// The volume does not have a retained partition association.
//
#define VDS_E_VOLUME_NOT_RETAINED        ((HRESULT)0x80042550L)

//
// MessageId: VDS_E_VOLUME_RETAINED
//
// MessageText:
//
// The volume already has a retained partition association.
//
#define VDS_E_VOLUME_RETAINED            ((HRESULT)0x80042551L)

//
// MessageId: VDS_E_ALIGN_BEYOND_FIRST_CYLINDER
//
// MessageText:
//
// The specified alignment is beyond the first cylinder.
//
#define VDS_E_ALIGN_BEYOND_FIRST_CYLINDER ((HRESULT)0x80042553L)

//
// MessageId: VDS_E_ALIGN_NOT_SECTOR_SIZE_MULTIPLE
//
// MessageText:
//
// The specified alignment is not a multiple of the sector size.
//
#define VDS_E_ALIGN_NOT_SECTOR_SIZE_MULTIPLE ((HRESULT)0x80042554L)

//
// MessageId: VDS_E_ALIGN_NOT_ZERO
//
// MessageText:
//
// The specified partition type cannot be created with a non-zero alignment.
//
#define VDS_E_ALIGN_NOT_ZERO             ((HRESULT)0x80042555L)

//
// MessageId: VDS_E_CACHE_CORRUPT
//
// MessageText:
//
// The service's cache has become corrupt.
//
#define VDS_E_CACHE_CORRUPT              ((HRESULT)0x80042556L)

//
// MessageId: VDS_E_CANNOT_CLEAR_VOLUME_FLAG
//
// MessageText:
//
// The specified volume flag cannot be cleared.
//
#define VDS_E_CANNOT_CLEAR_VOLUME_FLAG   ((HRESULT)0x80042557L)

//
// MessageId: VDS_E_DISK_BEING_CLEANED
//
// MessageText:
//
// The operation is not allowed on a disk that is in the process of being cleaned.
//
#define VDS_E_DISK_BEING_CLEANED         ((HRESULT)0x80042558L)

//
// MessageId: VDS_E_DISK_NOT_CONVERTIBLE
//
// MessageText:
//
// The specified disk is not convertible.
//
#define VDS_E_DISK_NOT_CONVERTIBLE       ((HRESULT)0x80042559L)

//
// MessageId: VDS_E_DISK_REMOVEABLE
//
// MessageText:
//
// The operation is not supported on removeable media.
//
#define VDS_E_DISK_REMOVEABLE            ((HRESULT)0x8004255AL)

//
// MessageId: VDS_E_DISK_REMOVEABLE_NOT_EMPTY
//
// MessageText:
//
// The operation is not supported on a non-empty removeable disk.
//
#define VDS_E_DISK_REMOVEABLE_NOT_EMPTY  ((HRESULT)0x8004255BL)

//
// MessageId: VDS_E_DRIVE_LETTER_NOT_FREE
//
// MessageText:
//
// The specified drive letter is not free to be assigned.
//
#define VDS_E_DRIVE_LETTER_NOT_FREE      ((HRESULT)0x8004255CL)

//
// MessageId: VDS_E_EXTEND_MULTIPLE_DISKS_NOT_SUPPORTED
//
// MessageText:
//
// Extending the volume onto multiple disks is not supported by this provider.
//
#define VDS_E_EXTEND_MULTIPLE_DISKS_NOT_SUPPORTED ((HRESULT)0x8004255DL)

//
// MessageId: VDS_E_INVALID_DRIVE_LETTER
//
// MessageText:
//
// The specified drive letter is invalid.
//
#define VDS_E_INVALID_DRIVE_LETTER       ((HRESULT)0x8004255EL)

//
// MessageId: VDS_E_INVALID_DRIVE_LETTER_COUNT
//
// MessageText:
//
// The specified number of drive letters to retrieve is invalid.
//
#define VDS_E_INVALID_DRIVE_LETTER_COUNT ((HRESULT)0x8004255FL)

//
// MessageId: VDS_E_INVALID_FS_FLAG
//
// MessageText:
//
// The specified file system flag is invalid.
//
#define VDS_E_INVALID_FS_FLAG            ((HRESULT)0x80042560L)

//
// MessageId: VDS_E_INVALID_FS_TYPE
//
// MessageText:
//
// The specified file system is invalid.
//
#define VDS_E_INVALID_FS_TYPE            ((HRESULT)0x80042561L)

//
// MessageId: VDS_E_INVALID_OBJECT_TYPE
//
// MessageText:
//
// The specified object type is invalid.
//
#define VDS_E_INVALID_OBJECT_TYPE        ((HRESULT)0x80042562L)

//
// MessageId: VDS_E_INVALID_PARTITION_LAYOUT
//
// MessageText:
//
// The specified partition layout is invalid.
//
#define VDS_E_INVALID_PARTITION_LAYOUT   ((HRESULT)0x80042563L)

//
// MessageId: VDS_E_INVALID_PARTITION_STYLE
//
// MessageText:
//
// The specified disk's partition style is INVALID.  VDS only supports MBR or GPT partition style disks.
//
#define VDS_E_INVALID_PARTITION_STYLE    ((HRESULT)0x80042564L)

//
// MessageId: VDS_E_INVALID_PARTITION_TYPE
//
// MessageText:
//
// The specified partition type is not valid for this operation.
//
#define VDS_E_INVALID_PARTITION_TYPE     ((HRESULT)0x80042565L)

//
// MessageId: VDS_E_INVALID_PROVIDER_CLSID
//
// MessageText:
//
// The specified provider clsid cannot be a NULL GUID.
//
#define VDS_E_INVALID_PROVIDER_CLSID     ((HRESULT)0x80042566L)

//
// MessageId: VDS_E_INVALID_PROVIDER_ID
//
// MessageText:
//
// The specified provider id cannot be a NULL GUID.
//
#define VDS_E_INVALID_PROVIDER_ID        ((HRESULT)0x80042567L)

//
// MessageId: VDS_E_INVALID_PROVIDER_NAME
//
// MessageText:
//
// The specified provider name is invalid.
//
#define VDS_E_INVALID_PROVIDER_NAME      ((HRESULT)0x80042568L)

//
// MessageId: VDS_E_INVALID_PROVIDER_TYPE
//
// MessageText:
//
// The specified provider type is invalid.
//
#define VDS_E_INVALID_PROVIDER_TYPE      ((HRESULT)0x80042569L)

//
// MessageId: VDS_E_INVALID_PROVIDER_VERSION_GUID
//
// MessageText:
//
// The specified provider version GUID cannot be a NULL GUID.
//
#define VDS_E_INVALID_PROVIDER_VERSION_GUID ((HRESULT)0x8004256AL)

//
// MessageId: VDS_E_INVALID_PROVIDER_VERSION_STRING
//
// MessageText:
//
// The specified provider version string is invalid.
//
#define VDS_E_INVALID_PROVIDER_VERSION_STRING ((HRESULT)0x8004256BL)

//
// MessageId: VDS_E_INVALID_QUERY_PROVIDER_FLAG
//
// MessageText:
//
// The specified query provider flag is invalid.
//
#define VDS_E_INVALID_QUERY_PROVIDER_FLAG ((HRESULT)0x8004256CL)

//
// MessageId: VDS_E_INVALID_SERVICE_FLAG
//
// MessageText:
//
// The specified service flag is invalid.
//
#define VDS_E_INVALID_SERVICE_FLAG       ((HRESULT)0x8004256DL)

//
// MessageId: VDS_E_INVALID_VOLUME_FLAG
//
// MessageText:
//
// The specified volume flag is invalid.
//
#define VDS_E_INVALID_VOLUME_FLAG        ((HRESULT)0x8004256EL)

//
// MessageId: VDS_E_PARTITION_NOT_OEM
//
// MessageText:
//
// The operation is not supported on non-OEM partitions.
//
#define VDS_E_PARTITION_NOT_OEM          ((HRESULT)0x8004256FL)

//
// MessageId: VDS_E_PARTITION_PROTECTED
//
// MessageText:
//
// Cannot delete a protected partition without the force protected parameter set.
//
#define VDS_E_PARTITION_PROTECTED        ((HRESULT)0x80042570L)

//
// MessageId: VDS_E_PARTITION_STYLE_MISMATCH
//
// MessageText:
//
// The specified partition style does not match that of the disk.
//
#define VDS_E_PARTITION_STYLE_MISMATCH   ((HRESULT)0x80042571L)

//
// MessageId: VDS_E_PROVIDER_INTERNAL_ERROR
//
// MessageText:
//
// An internal error has occurred in the provider.
//
#define VDS_E_PROVIDER_INTERNAL_ERROR    ((HRESULT)0x80042572L)

//
// MessageId: VDS_E_SHRINK_SIZE_LESS_THAN_MIN
//
// MessageText:
//
// The specified shrink size is less than then minimum shrink size allowed.
//
#define VDS_E_SHRINK_SIZE_LESS_THAN_MIN  ((HRESULT)0x80042573L)

//
// MessageId: VDS_E_SHRINK_SIZE_TOO_BIG
//
// MessageText:
//
// The specified shrink size is too big and will cause the volume to be smaller than the minimum volume size.
//
#define VDS_E_SHRINK_SIZE_TOO_BIG        ((HRESULT)0x80042574L)

//
// MessageId: VDS_E_UNRECOVERABLE_PROVIDER_ERROR
//
// MessageText:
//
// An unrecoverable error occurred in a provider.  The service must be shut down to regain full functionality.
//
#define VDS_E_UNRECOVERABLE_PROVIDER_ERROR ((HRESULT)0x80042575L)

//
// MessageId: VDS_E_VOLUME_HIDDEN
//
// MessageText:
//
// Cannot assign a mount point to a hidden volume.
//
#define VDS_E_VOLUME_HIDDEN              ((HRESULT)0x80042576L)

//
// MessageId: VDS_S_DISMOUNT_FAILED
//
// MessageText:
//
// Failed to dismount the volume after setting the volume flags.
//
#define VDS_S_DISMOUNT_FAILED            ((HRESULT)0x00042577L)

//
// MessageId: VDS_S_REMOUNT_FAILED
//
// MessageText:
//
// Failed to remount the volume after setting the volume flags.
//
#define VDS_S_REMOUNT_FAILED             ((HRESULT)0x00042578L)

//
// MessageId: VDS_E_FLAG_ALREADY_SET
//
// MessageText:
//
// Can't set the specified flag as revert-on-close, because it is already set.
//
#define VDS_E_FLAG_ALREADY_SET           ((HRESULT)0x80042579L)

//
// MessageId: VDS_S_RESYNC_NOTIFICATION_TASK_FAILED
//
// MessageText:
//
// Failure. If the volume is a mirror volume or a raid5 volume, no resynchronization notifications will be sent.
//
#define VDS_S_RESYNC_NOTIFICATION_TASK_FAILED ((HRESULT)0x0004257AL)

//
// MessageId: VDS_E_DISTINCT_VOLUME
//
// MessageText:
//
// The input volume id cannot be the id of the volume that is the target of the operation.
//
#define VDS_E_DISTINCT_VOLUME            ((HRESULT)0x8004257BL)

//
// MessageId: VDS_E_VOLUME_NOT_FOUND_IN_PACK
//
// MessageText:
//
// The specified volumes do not belong to the same pack.
//
#define VDS_E_VOLUME_NOT_FOUND_IN_PACK   ((HRESULT)0x8004257CL)

//
// MessageId: VDS_E_PARTITION_NON_DATA
//
// MessageText:
//
// The specified partition is a not a primary or logical volume.
//
#define VDS_E_PARTITION_NON_DATA         ((HRESULT)0x8004257DL)

//
// MessageId: VDS_E_CRITICAL_PLEX
//
// MessageText:
//
// The specified plex is a the current system or boot plex.
//
#define VDS_E_CRITICAL_PLEX              ((HRESULT)0x8004257EL)

//
// MessageId: VDS_E_VOLUME_SYNCHRONIZING
//
// MessageText:
//
// The operation cannot be completed because the volume is synchronizing.
//
#define VDS_E_VOLUME_SYNCHRONIZING       ((HRESULT)0x8004257FL)

//
// MessageId: VDS_E_VOLUME_REGENERATING
//
// MessageText:
//
// The operation cannot be completed because the volume is regenerating.
//
#define VDS_E_VOLUME_REGENERATING        ((HRESULT)0x80042580L)

//
// MessageId: VDS_S_VSS_FLUSH_AND_HOLD_WRITES
//
// MessageText:
//
// Failed to flush and hold Volume Snapshot Service writes.
//
#define VDS_S_VSS_FLUSH_AND_HOLD_WRITES  ((HRESULT)0x00042581L)

//
// MessageId: VDS_S_VSS_RELEASE_WRITES
//
// MessageText:
//
// Failed to release Volume Snapshot Service writes.
//
#define VDS_S_VSS_RELEASE_WRITES         ((HRESULT)0x00042582L)

//
// MessageId: VDS_S_FS_LOCK
//
// MessageText:
//
// Failed to obtain a file system lock.
//
#define VDS_S_FS_LOCK                    ((HRESULT)0x00042583L)

//
// MessageId: VDS_E_READONLY
//
// MessageText:
//
// The volume is read only.
//
#define VDS_E_READONLY                   ((HRESULT)0x80042584L)

//
// MessageId: VDS_E_INVALID_VOLUME_TYPE
//
// MessageText:
//
// The volume type is invalid for this operation.
//
#define VDS_E_INVALID_VOLUME_TYPE        ((HRESULT)0x80042585L)

//
// MessageId: VDS_E_BAD_BOOT_DISK
//
// MessageText:
//
// The boot disk experienced failures when the driver attempted to online the pack.
//
#define VDS_E_BAD_BOOT_DISK              ((HRESULT)0x80042586L)

//
// MessageId: VDS_E_LOG_UPDATE
//
// MessageText:
//
// The driver failed to update the log on at least one disk.
//
#define VDS_E_LOG_UPDATE                 ((HRESULT)0x80042587L)

//
// MessageId: VDS_E_VOLUME_MIRRORED
//
// MessageText:
//
// This operation is not supported on a mirrored volume.
//
#define VDS_E_VOLUME_MIRRORED            ((HRESULT)0x80042588L)

//
// MessageId: VDS_E_VOLUME_SIMPLE_SPANNED
//
// MessageText:
//
// This operation is only supported on simple or spanned volumes.
//
#define VDS_E_VOLUME_SIMPLE_SPANNED      ((HRESULT)0x80042589L)

//
// MessageId: VDS_E_NO_VALID_LOG_COPIES
//
// MessageText:
//
// This pack has no valid log copies.
//
#define VDS_E_NO_VALID_LOG_COPIES        ((HRESULT)0x8004258AL)

//
// MessageId: VDS_S_PLEX_NOT_LOADED_TO_CACHE
//
// MessageText:
//
// This plex is present in the driver, but has not yet been loaded to the provider cache. A volume modified notification will be sent by the service once the plex has been loaded to the provider cache.
//
#define VDS_S_PLEX_NOT_LOADED_TO_CACHE   ((HRESULT)0x0004258BL)

//
// MessageId: VDS_E_PLEX_NOT_LOADED_TO_CACHE
//
// MessageText:
//
// This plex is present in the driver, but has not yet been loaded to the provider cache. A volume modified notification will be sent by the service once the plex has been loaded to the provider cache.
//
#define VDS_E_PLEX_NOT_LOADED_TO_CACHE   ((HRESULT)0x8004258BL)

//
// MessageId: VDS_E_PARTITION_MSR
//
// MessageText:
//
// This operation is not supported on MSR partitions.
//
#define VDS_E_PARTITION_MSR              ((HRESULT)0x8004258CL)

//
// MessageId: VDS_E_PARTITION_LDM
//
// MessageText:
//
// This operation is not supported on LDM partitions.
//
#define VDS_E_PARTITION_LDM              ((HRESULT)0x8004258DL)

//
// MessageId: VDS_S_WINPE_BOOTENTRY
//
// MessageText:
//
// The boot entries cannot be updated automatically on WinPE. You may need to manually update the boot entry for any installed OSes.
//
#define VDS_S_WINPE_BOOTENTRY            ((HRESULT)0x0004258EL)

//
// MessageId: VDS_E_ALIGN_NOT_A_POWER_OF_TWO
//
// MessageText:
//
// The specified alignment is not a power of two.
//
#define VDS_E_ALIGN_NOT_A_POWER_OF_TWO   ((HRESULT)0x8004258FL)

//
// MessageId: VDS_E_ALIGN_IS_ZERO
//
// MessageText:
//
// The specified alignment is zero.
//
#define VDS_E_ALIGN_IS_ZERO              ((HRESULT)0x80042590L)

//
// MessageId: VDS_E_SHRINK_IN_PROGRESS
//
// MessageText:
//
// A defragmentation or volume shrink operation is already in progress. Only one of these operations can run at a time.
//
#define VDS_E_SHRINK_IN_PROGRESS         ((HRESULT)0x80042591L)

//
// MessageId: VDS_E_CANT_INVALIDATE_FVE
//
// MessageText:
//
// BitLocker encryption on the volume could not be removed.
//
#define VDS_E_CANT_INVALIDATE_FVE        ((HRESULT)0x80042592L)

//
// MessageId: VDS_E_FS_NOT_DETERMINED
//
// MessageText:
//
// The default file system could not be determined.
//
#define VDS_E_FS_NOT_DETERMINED          ((HRESULT)0x80042593L)

//
// MessageId: VDS_E_DISK_NOT_OFFLINE
//
// MessageText:
//
// The disk is online.
//
#define VDS_E_DISK_NOT_OFFLINE           ((HRESULT)0x80042595L)

//
// MessageId: VDS_E_FAILED_TO_ONLINE_DISK
//
// MessageText:
//
// The online operation failed.
//
#define VDS_E_FAILED_TO_ONLINE_DISK      ((HRESULT)0x80042596L)

//
// MessageId: VDS_E_FAILED_TO_OFFLINE_DISK
//
// MessageText:
//
// The offline operation failed.
//
#define VDS_E_FAILED_TO_OFFLINE_DISK     ((HRESULT)0x80042597L)

//
// MessageId: VDS_E_BAD_REVISION_NUMBER
//
// MessageText:
//
// The operation could not be completed because the specified revision number is not supported.
//
#define VDS_E_BAD_REVISION_NUMBER        ((HRESULT)0x80042598L)

//////////////////////////////////////////////////////////////////////////////
//
// Codes added in VDS 1.1:                       0x2700-0x27FF
//
//////////////////////////////////////////////////////////////////////////////
//
// MessageId: VDS_S_NAME_TRUNCATED
//
// MessageText:
//
// The name was accepted but had to be truncated.
//
#define VDS_S_NAME_TRUNCATED             ((HRESULT)0x00042700L)

//
// MessageId: VDS_E_NAME_NOT_UNIQUE
//
// MessageText:
//
// The name is not unique.
//
#define VDS_E_NAME_NOT_UNIQUE            ((HRESULT)0x80042701L)

//
// MessageId: VDS_S_STATUSES_INCOMPLETELY_SET
//
// MessageText:
//
// At least one path status is not set successfully due to a non-fatal error (i.e. the status conflicts with the current load balance policy).
//
#define VDS_S_STATUSES_INCOMPLETELY_SET  ((HRESULT)0x00042702L)

//
// MessageId: VDS_E_ADDRESSES_INCOMPLETELY_SET
//
// MessageText:
//
// At least one portal's tunnel address is not set successfully.
//
#define VDS_E_ADDRESSES_INCOMPLETELY_SET ((HRESULT)0x80042703L)

//
// MessageId: VDS_E_SECURITY_INCOMPLETELY_SET
//
// MessageText:
//
// At least one portal's security settings are not set successfully.
//
#define VDS_E_SECURITY_INCOMPLETELY_SET  ((HRESULT)0x80042705L)

//
// MessageId: VDS_E_TARGET_SPECIFIC_NOT_SUPPORTED
//
// MessageText:
//
// The initiator does not support setting target-specific shared secrets.
//
#define VDS_E_TARGET_SPECIFIC_NOT_SUPPORTED ((HRESULT)0x80042706L)

//
// MessageId: VDS_E_INITIATOR_SPECIFIC_NOT_SUPPORTED
//
// MessageText:
//
// The target does not support setting initiator-specific shared secrets.
//
#define VDS_E_INITIATOR_SPECIFIC_NOT_SUPPORTED ((HRESULT)0x80042707L)

//
// MessageId: VDS_E_ISCSI_LOGIN_FAILED
//
// MessageText:
//
// An iSCSI login session could not be established.
//
#define VDS_E_ISCSI_LOGIN_FAILED         ((HRESULT)0x80042708L)

//
// MessageId: VDS_E_ISCSI_LOGOUT_FAILED
//
// MessageText:
//
// The attempt to log out from the specified iSCSI session failed.
//
#define VDS_E_ISCSI_LOGOUT_FAILED        ((HRESULT)0x80042709L)

//
// MessageId: VDS_E_ISCSI_SESSION_NOT_FOUND
//
// MessageText:
//
// The specified iSCSI session with a connection matching the specified target, target portal, and/or initiator portal could not be found.
//
#define VDS_E_ISCSI_SESSION_NOT_FOUND    ((HRESULT)0x8004270AL)

//
// MessageId: VDS_E_ASSOCIATED_LUNS_EXIST
//
// MessageText:
//
// LUNs are associated with the specified target and must first be deassociated before the target can be deleted.
//
#define VDS_E_ASSOCIATED_LUNS_EXIST      ((HRESULT)0x8004270BL)

//
// MessageId: VDS_E_ASSOCIATED_PORTALS_EXIST
//
// MessageText:
//
// Portals are associated with the specified portal group and must first be deassociated before the portal group can be deleted.
//
#define VDS_E_ASSOCIATED_PORTALS_EXIST   ((HRESULT)0x8004270CL)

//
// MessageId: VDS_E_NO_DISCOVERY_DOMAIN
//
// MessageText:
//
// The initiator does not exist in a iSNS discovery domain.
//
#define VDS_E_NO_DISCOVERY_DOMAIN        ((HRESULT)0x8004270DL)

//
// MessageId: VDS_E_MULTIPLE_DISCOVERY_DOMAINS
//
// MessageText:
//
// The initiator exists in more than one iSNS discovery domain.
//
#define VDS_E_MULTIPLE_DISCOVERY_DOMAINS ((HRESULT)0x8004270EL)

//
// MessageId: VDS_E_NO_DISK_PATHNAME
//
// MessageText:
//
// Failed to retrieve the disk's pathname. Some operations on the disk may fail.
//
#define VDS_E_NO_DISK_PATHNAME           ((HRESULT)0x8004270FL)

//
// MessageId: VDS_E_ISCSI_LOGOUT_INCOMPLETE
//
// MessageText:
//
// At least one session did not logout successfully.
//
#define VDS_E_ISCSI_LOGOUT_INCOMPLETE    ((HRESULT)0x80042710L)

//
// MessageId: VDS_E_NO_VOLUME_PATHNAME
//
// MessageText:
//
// Failed to retrieve the volume's pathname.
//
#define VDS_E_NO_VOLUME_PATHNAME         ((HRESULT)0x80042711L)

//
// MessageId: VDS_E_PROVIDER_CACHE_OUTOFSYNC
//
// MessageText:
//
// The provider's cache is not in-sync with the driver cache.
//
#define VDS_E_PROVIDER_CACHE_OUTOFSYNC   ((HRESULT)0x80042712L)

//
// MessageId: VDS_E_NO_IMPORT_TARGET
//
// MessageText:
//
// No import target was set for this subsystem in the registry.
//
#define VDS_E_NO_IMPORT_TARGET           ((HRESULT)0x80042713L)

//
// MessageId: VDS_S_ALREADY_EXISTS
//
// MessageText:
//
// The object already exists and does not need to be further created or added.
//
#define VDS_S_ALREADY_EXISTS             ((HRESULT)0x00042714L)

//
// MessageId: VDS_S_PROPERTIES_INCOMPLETE
//
// MessageText:
//
// Unable to retrieve all properties for this object. Some attributes may be incomplete or missing.
//
#define VDS_S_PROPERTIES_INCOMPLETE      ((HRESULT)0x00042715L)

//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Windows Server "Longhorn":     0x2800-0x28FF
//
//////////////////////////////////////////////////////////////////////////////
//
// MessageId: VDS_S_ISCSI_SESSION_NOT_FOUND_PERSISTENT_LOGIN_REMOVED
//
// MessageText:
//
// No iSCSI sessions to the target were found, but the persistent login setup to the target was removed.
//
#define VDS_S_ISCSI_SESSION_NOT_FOUND_PERSISTENT_LOGIN_REMOVED ((HRESULT)0x00042800L)

//
// MessageId: VDS_S_ISCSI_PERSISTENT_LOGIN_MAY_NOT_BE_REMOVED
//
// MessageText:
//
// If a persistent login was set up for the target, it may not have been removed. Check the iSCSI Initiator Control Panel to remove it if necessary.
//
#define VDS_S_ISCSI_PERSISTENT_LOGIN_MAY_NOT_BE_REMOVED ((HRESULT)0x00042801L)

//
// MessageId: VDS_S_ISCSI_LOGIN_ALREAD_EXISTS
//
// MessageText:
//
// Login failed because the target is already logged in.
//
#define VDS_S_ISCSI_LOGIN_ALREAD_EXISTS  ((HRESULT)0x00042802L)

//
// MessageId: VDS_E_UNABLE_TO_FIND_BOOT_DISK
//
// MessageText:
//
// A system error occurred while retrieving the boot disk information.
//
#define VDS_E_UNABLE_TO_FIND_BOOT_DISK   ((HRESULT)0x80042803L)

//
// MessageId: VDS_E_INCORRECT_BOOT_VOLUME_EXTENT_INFO
//
// MessageText:
//
// Multiple disk extents reported for the boot volume - system error.
//
#define VDS_E_INCORRECT_BOOT_VOLUME_EXTENT_INFO ((HRESULT)0x80042804L)

//
// MessageId: VDS_E_GET_SAN_POLICY
//
// MessageText:
//
// A driver error was reported when getting the SAN policy.
//
#define VDS_E_GET_SAN_POLICY             ((HRESULT)0x80042805L)

//
// MessageId: VDS_E_SET_SAN_POLICY
//
// MessageText:
//
// A driver error was reported when setting the SAN policy.
//
#define VDS_E_SET_SAN_POLICY             ((HRESULT)0x80042806L)

//
// MessageId: VDS_E_BOOT_DISK
//
// MessageText:
//
// Disk attributes may not be changed on the boot disk.
//
#define VDS_E_BOOT_DISK                  ((HRESULT)0x80042807L)

//
// MessageId: VDS_S_DISK_MOUNT_FAILED
//
// MessageText:
//
// Failed to mount one or more of the volumes on the disk.
//
#define VDS_S_DISK_MOUNT_FAILED          ((HRESULT)0x00042808L)

//
// MessageId: VDS_S_DISK_DISMOUNT_FAILED
//
// MessageText:
//
// Failed to dismount one or more of the volumes on the disk.
//
#define VDS_S_DISK_DISMOUNT_FAILED       ((HRESULT)0x00042809L)

//
// MessageId: VDS_E_DISK_IS_OFFLINE
//
// MessageText:
//
// The operation is not allowed on a disk that is offline.
//
#define VDS_E_DISK_IS_OFFLINE            ((HRESULT)0x8004280AL)

//
// MessageId: VDS_E_DISK_IS_READ_ONLY
//
// MessageText:
//
// The operation is not allowed on a disk that is read only.
//
#define VDS_E_DISK_IS_READ_ONLY          ((HRESULT)0x8004280BL)

//
// MessageId: VDS_E_PAGEFILE_DISK
//
// MessageText:
//
// The operation is not allowed on a disk that contains a pagefile volume.
//
#define VDS_E_PAGEFILE_DISK              ((HRESULT)0x8004280CL)

//
// MessageId: VDS_E_HIBERNATION_FILE_DISK
//
// MessageText:
//
// The operation is not allowed on a disk that contains a hibernation file volume.
//
#define VDS_E_HIBERNATION_FILE_DISK      ((HRESULT)0x8004280DL)

//
// MessageId: VDS_E_CRASHDUMP_DISK
//
// MessageText:
//
// The operation is not allowed on a disk that contains a crashdump file volume.
//
#define VDS_E_CRASHDUMP_DISK             ((HRESULT)0x8004280EL)

//
// MessageId: VDS_E_UNABLE_TO_FIND_SYSTEM_DISK
//
// MessageText:
//
// A system error occurred while retrieving the system disk information.
//
#define VDS_E_UNABLE_TO_FIND_SYSTEM_DISK ((HRESULT)0x8004280FL)

//
// MessageId: VDS_E_INCORRECT_SYSTEM_VOLUME_EXTENT_INFO
//
// MessageText:
//
// Multiple disk extents reported for the system volume - system error.
//
#define VDS_E_INCORRECT_SYSTEM_VOLUME_EXTENT_INFO ((HRESULT)0x80042810L)

//
// MessageId: VDS_E_SYSTEM_DISK
//
// MessageText:
//
// Disk attributes may not be changed on the system disk.
//
#define VDS_E_SYSTEM_DISK                ((HRESULT)0x80042811L)

//
// MessageId: VDS_E_VOLUME_SHRINK_FVE_LOCKED
//
// MessageText:
//
// The volume could not be shrunk because it is locked by BitLocker. Unlock the volume and try again.
//
#define VDS_E_VOLUME_SHRINK_FVE_LOCKED   ((HRESULT)0x80042812L)

//
// MessageId: VDS_E_VOLUME_SHRINK_FVE_CORRUPT
//
// MessageText:
//
// The volume could not be shrunk because it is locked due to a BitLocker error. Use BitLocker tools to recover the volume and try again.
//
#define VDS_E_VOLUME_SHRINK_FVE_CORRUPT  ((HRESULT)0x80042813L)

//
// MessageId: VDS_E_VOLUME_SHRINK_FVE_RECOVERY
//
// MessageText:
//
// The volume could not be shrunk because it is marked for BitLocker recovery. Use BitLocker tools to recover the volume and try again.
//
#define VDS_E_VOLUME_SHRINK_FVE_RECOVERY ((HRESULT)0x80042814L)

//
// MessageId: VDS_E_VOLUME_SHRINK_FVE
//
// MessageText:
//
// The volume could not be shrunk because it is encrypted by BitLocker and Fveapi.dll could not be loaded to determine its status. For this operation to succeed, Fveapi.dll must be available in %SystemRoot%\System32\.
//
#define VDS_E_VOLUME_SHRINK_FVE          ((HRESULT)0x80042815L)

//
// MessageId: VDS_E_SHRINK_OVER_DATA
//
// MessageText:
//
// DiskRAID could not shrink the LUN because the operation would overwrite partitions with user data.
//
#define VDS_E_SHRINK_OVER_DATA           ((HRESULT)0x80042816L)

//
// MessageId: VDS_E_INVALID_SHRINK_SIZE
//
// MessageText:
//
// DiskRAID could not shrink the LUN because the specified size is not a valid size for the LUN.
//
#define VDS_E_INVALID_SHRINK_SIZE        ((HRESULT)0x80042817L)

//
// MessageId: VDS_E_LUN_DISK_MISSING
//
// MessageText:
//
// DiskRAID could not shrink the LUN because a disk associated with the LUN is missing.
//
#define VDS_E_LUN_DISK_MISSING           ((HRESULT)0x80042818L)

//
// MessageId: VDS_E_LUN_DISK_FAILED
//
// MessageText:
//
// DiskRAID could not shrink the LUN because a disk associated with the LUN has failed.
//
#define VDS_E_LUN_DISK_FAILED            ((HRESULT)0x80042819L)

//
// MessageId: VDS_E_LUN_DISK_NOT_READY
//
// MessageText:
//
// DiskRAID could not shrink the LUN because a disk associated with the LUN is not ready.
//
#define VDS_E_LUN_DISK_NOT_READY         ((HRESULT)0x8004281AL)

//
// MessageId: VDS_E_LUN_DISK_NO_MEDIA
//
// MessageText:
//
// DiskRAID could not shrink the LUN because a disk associated with the LUN has no media in it.
//
#define VDS_E_LUN_DISK_NO_MEDIA          ((HRESULT)0x8004281BL)

//
// MessageId: VDS_E_LUN_NOT_READY
//
// MessageText:
//
// DiskRAID could not shrink the LUN because the LUN is not ready.
//
#define VDS_E_LUN_NOT_READY              ((HRESULT)0x8004281CL)

//
// MessageId: VDS_E_LUN_OFFLINE
//
// MessageText:
//
// DiskRAID could not shrink the LUN because the LUN is offline.
//
#define VDS_E_LUN_OFFLINE                ((HRESULT)0x8004281DL)

//
// MessageId: VDS_E_LUN_FAILED
//
// MessageText:
//
// DiskRAID could not shrink the LUN because the LUN has failed.
//
#define VDS_E_LUN_FAILED                 ((HRESULT)0x8004281EL)

//
// MessageId: VDS_E_VOLUME_EXTEND_FVE_LOCKED
//
// MessageText:
//
// The volume could not be extended because it is locked by BitLocker. Unlock the volume and try again.
//
#define VDS_E_VOLUME_EXTEND_FVE_LOCKED   ((HRESULT)0x8004281FL)

//
// MessageId: VDS_E_VOLUME_EXTEND_FVE_CORRUPT
//
// MessageText:
//
// The volume could not be extended because it is locked due to a BitLocker error. Use BitLocker tools to recover the volume and try again.
//
#define VDS_E_VOLUME_EXTEND_FVE_CORRUPT  ((HRESULT)0x80042820L)

//
// MessageId: VDS_E_VOLUME_EXTEND_FVE_RECOVERY
//
// MessageText:
//
// The volume could not be extended because it is marked for BitLocker recovery. Use BitLocker tools to recover the volume and try again.
//
#define VDS_E_VOLUME_EXTEND_FVE_RECOVERY ((HRESULT)0x80042821L)

//
// MessageId: VDS_E_VOLUME_EXTEND_FVE
//
// MessageText:
//
// The volume could not be extended because it is encrypted by BitLocker and Fveapi.dll could not be loaded to determine its status. For this operation to succeed, Fveapi.dll must be available in %SystemRoot%\System32\.
//
#define VDS_E_VOLUME_EXTEND_FVE          ((HRESULT)0x80042822L)

//
// MessageId: VDS_E_SECTOR_SIZE_ERROR
//
// MessageText:
//
// The sector size must be non-zero, a power of 2, and less than the maximum sector size.
//
#define VDS_E_SECTOR_SIZE_ERROR          ((HRESULT)0x80042823L)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\vds.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for vds.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vds_h__
#define __vds_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumVdsObject_FWD_DEFINED__
#define __IEnumVdsObject_FWD_DEFINED__
typedef interface IEnumVdsObject IEnumVdsObject;
#endif 	/* __IEnumVdsObject_FWD_DEFINED__ */


#ifndef __IVdsAsync_FWD_DEFINED__
#define __IVdsAsync_FWD_DEFINED__
typedef interface IVdsAsync IVdsAsync;
#endif 	/* __IVdsAsync_FWD_DEFINED__ */


#ifndef __IVdsAdviseSink_FWD_DEFINED__
#define __IVdsAdviseSink_FWD_DEFINED__
typedef interface IVdsAdviseSink IVdsAdviseSink;
#endif 	/* __IVdsAdviseSink_FWD_DEFINED__ */


#ifndef __IVdsProvider_FWD_DEFINED__
#define __IVdsProvider_FWD_DEFINED__
typedef interface IVdsProvider IVdsProvider;
#endif 	/* __IVdsProvider_FWD_DEFINED__ */


#ifndef __IVdsProviderSupport_FWD_DEFINED__
#define __IVdsProviderSupport_FWD_DEFINED__
typedef interface IVdsProviderSupport IVdsProviderSupport;
#endif 	/* __IVdsProviderSupport_FWD_DEFINED__ */


#ifndef __IVdsSwProvider_FWD_DEFINED__
#define __IVdsSwProvider_FWD_DEFINED__
typedef interface IVdsSwProvider IVdsSwProvider;
#endif 	/* __IVdsSwProvider_FWD_DEFINED__ */


#ifndef __IVdsPack_FWD_DEFINED__
#define __IVdsPack_FWD_DEFINED__
typedef interface IVdsPack IVdsPack;
#endif 	/* __IVdsPack_FWD_DEFINED__ */


#ifndef __IVdsPack2_FWD_DEFINED__
#define __IVdsPack2_FWD_DEFINED__
typedef interface IVdsPack2 IVdsPack2;
#endif 	/* __IVdsPack2_FWD_DEFINED__ */


#ifndef __IVdsDisk_FWD_DEFINED__
#define __IVdsDisk_FWD_DEFINED__
typedef interface IVdsDisk IVdsDisk;
#endif 	/* __IVdsDisk_FWD_DEFINED__ */


#ifndef __IVdsDisk2_FWD_DEFINED__
#define __IVdsDisk2_FWD_DEFINED__
typedef interface IVdsDisk2 IVdsDisk2;
#endif 	/* __IVdsDisk2_FWD_DEFINED__ */


#ifndef __IVdsDiskOnline_FWD_DEFINED__
#define __IVdsDiskOnline_FWD_DEFINED__
typedef interface IVdsDiskOnline IVdsDiskOnline;
#endif 	/* __IVdsDiskOnline_FWD_DEFINED__ */


#ifndef __IVdsAdvancedDisk_FWD_DEFINED__
#define __IVdsAdvancedDisk_FWD_DEFINED__
typedef interface IVdsAdvancedDisk IVdsAdvancedDisk;
#endif 	/* __IVdsAdvancedDisk_FWD_DEFINED__ */


#ifndef __IVdsAdvancedDisk2_FWD_DEFINED__
#define __IVdsAdvancedDisk2_FWD_DEFINED__
typedef interface IVdsAdvancedDisk2 IVdsAdvancedDisk2;
#endif 	/* __IVdsAdvancedDisk2_FWD_DEFINED__ */


#ifndef __IVdsCreatePartitionEx_FWD_DEFINED__
#define __IVdsCreatePartitionEx_FWD_DEFINED__
typedef interface IVdsCreatePartitionEx IVdsCreatePartitionEx;
#endif 	/* __IVdsCreatePartitionEx_FWD_DEFINED__ */


#ifndef __IVdsRemovable_FWD_DEFINED__
#define __IVdsRemovable_FWD_DEFINED__
typedef interface IVdsRemovable IVdsRemovable;
#endif 	/* __IVdsRemovable_FWD_DEFINED__ */


#ifndef __IVdsVolume_FWD_DEFINED__
#define __IVdsVolume_FWD_DEFINED__
typedef interface IVdsVolume IVdsVolume;
#endif 	/* __IVdsVolume_FWD_DEFINED__ */


#ifndef __IVdsVolumeOnline_FWD_DEFINED__
#define __IVdsVolumeOnline_FWD_DEFINED__
typedef interface IVdsVolumeOnline IVdsVolumeOnline;
#endif 	/* __IVdsVolumeOnline_FWD_DEFINED__ */


#ifndef __IVdsVolumePlex_FWD_DEFINED__
#define __IVdsVolumePlex_FWD_DEFINED__
typedef interface IVdsVolumePlex IVdsVolumePlex;
#endif 	/* __IVdsVolumePlex_FWD_DEFINED__ */


#ifndef __IVdsHwProvider_FWD_DEFINED__
#define __IVdsHwProvider_FWD_DEFINED__
typedef interface IVdsHwProvider IVdsHwProvider;
#endif 	/* __IVdsHwProvider_FWD_DEFINED__ */


#ifndef __IVdsHwProviderType_FWD_DEFINED__
#define __IVdsHwProviderType_FWD_DEFINED__
typedef interface IVdsHwProviderType IVdsHwProviderType;
#endif 	/* __IVdsHwProviderType_FWD_DEFINED__ */


#ifndef __IVdsSubSystem_FWD_DEFINED__
#define __IVdsSubSystem_FWD_DEFINED__
typedef interface IVdsSubSystem IVdsSubSystem;
#endif 	/* __IVdsSubSystem_FWD_DEFINED__ */


#ifndef __IVdsSubSystemNaming_FWD_DEFINED__
#define __IVdsSubSystemNaming_FWD_DEFINED__
typedef interface IVdsSubSystemNaming IVdsSubSystemNaming;
#endif 	/* __IVdsSubSystemNaming_FWD_DEFINED__ */


#ifndef __IVdsSubSystemIscsi_FWD_DEFINED__
#define __IVdsSubSystemIscsi_FWD_DEFINED__
typedef interface IVdsSubSystemIscsi IVdsSubSystemIscsi;
#endif 	/* __IVdsSubSystemIscsi_FWD_DEFINED__ */


#ifndef __IVdsControllerPort_FWD_DEFINED__
#define __IVdsControllerPort_FWD_DEFINED__
typedef interface IVdsControllerPort IVdsControllerPort;
#endif 	/* __IVdsControllerPort_FWD_DEFINED__ */


#ifndef __IVdsController_FWD_DEFINED__
#define __IVdsController_FWD_DEFINED__
typedef interface IVdsController IVdsController;
#endif 	/* __IVdsController_FWD_DEFINED__ */


#ifndef __IVdsControllerControllerPort_FWD_DEFINED__
#define __IVdsControllerControllerPort_FWD_DEFINED__
typedef interface IVdsControllerControllerPort IVdsControllerControllerPort;
#endif 	/* __IVdsControllerControllerPort_FWD_DEFINED__ */


#ifndef __IVdsDrive_FWD_DEFINED__
#define __IVdsDrive_FWD_DEFINED__
typedef interface IVdsDrive IVdsDrive;
#endif 	/* __IVdsDrive_FWD_DEFINED__ */


#ifndef __IVdsLun_FWD_DEFINED__
#define __IVdsLun_FWD_DEFINED__
typedef interface IVdsLun IVdsLun;
#endif 	/* __IVdsLun_FWD_DEFINED__ */


#ifndef __IVdsLunNaming_FWD_DEFINED__
#define __IVdsLunNaming_FWD_DEFINED__
typedef interface IVdsLunNaming IVdsLunNaming;
#endif 	/* __IVdsLunNaming_FWD_DEFINED__ */


#ifndef __IVdsLunControllerPorts_FWD_DEFINED__
#define __IVdsLunControllerPorts_FWD_DEFINED__
typedef interface IVdsLunControllerPorts IVdsLunControllerPorts;
#endif 	/* __IVdsLunControllerPorts_FWD_DEFINED__ */


#ifndef __IVdsLunMpio_FWD_DEFINED__
#define __IVdsLunMpio_FWD_DEFINED__
typedef interface IVdsLunMpio IVdsLunMpio;
#endif 	/* __IVdsLunMpio_FWD_DEFINED__ */


#ifndef __IVdsLunIscsi_FWD_DEFINED__
#define __IVdsLunIscsi_FWD_DEFINED__
typedef interface IVdsLunIscsi IVdsLunIscsi;
#endif 	/* __IVdsLunIscsi_FWD_DEFINED__ */


#ifndef __IVdsLunPlex_FWD_DEFINED__
#define __IVdsLunPlex_FWD_DEFINED__
typedef interface IVdsLunPlex IVdsLunPlex;
#endif 	/* __IVdsLunPlex_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortal_FWD_DEFINED__
#define __IVdsIscsiPortal_FWD_DEFINED__
typedef interface IVdsIscsiPortal IVdsIscsiPortal;
#endif 	/* __IVdsIscsiPortal_FWD_DEFINED__ */


#ifndef __IVdsIscsiTarget_FWD_DEFINED__
#define __IVdsIscsiTarget_FWD_DEFINED__
typedef interface IVdsIscsiTarget IVdsIscsiTarget;
#endif 	/* __IVdsIscsiTarget_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortalGroup_FWD_DEFINED__
#define __IVdsIscsiPortalGroup_FWD_DEFINED__
typedef interface IVdsIscsiPortalGroup IVdsIscsiPortalGroup;
#endif 	/* __IVdsIscsiPortalGroup_FWD_DEFINED__ */


#ifndef __IVdsMaintenance_FWD_DEFINED__
#define __IVdsMaintenance_FWD_DEFINED__
typedef interface IVdsMaintenance IVdsMaintenance;
#endif 	/* __IVdsMaintenance_FWD_DEFINED__ */


#ifndef __IVdsServiceLoader_FWD_DEFINED__
#define __IVdsServiceLoader_FWD_DEFINED__
typedef interface IVdsServiceLoader IVdsServiceLoader;
#endif 	/* __IVdsServiceLoader_FWD_DEFINED__ */


#ifndef __IVdsService_FWD_DEFINED__
#define __IVdsService_FWD_DEFINED__
typedef interface IVdsService IVdsService;
#endif 	/* __IVdsService_FWD_DEFINED__ */


#ifndef __IVdsServiceUninstallDisk_FWD_DEFINED__
#define __IVdsServiceUninstallDisk_FWD_DEFINED__
typedef interface IVdsServiceUninstallDisk IVdsServiceUninstallDisk;
#endif 	/* __IVdsServiceUninstallDisk_FWD_DEFINED__ */


#ifndef __IVdsServiceHba_FWD_DEFINED__
#define __IVdsServiceHba_FWD_DEFINED__
typedef interface IVdsServiceHba IVdsServiceHba;
#endif 	/* __IVdsServiceHba_FWD_DEFINED__ */


#ifndef __IVdsServiceIscsi_FWD_DEFINED__
#define __IVdsServiceIscsi_FWD_DEFINED__
typedef interface IVdsServiceIscsi IVdsServiceIscsi;
#endif 	/* __IVdsServiceIscsi_FWD_DEFINED__ */


#ifndef __IVdsServiceInitialization_FWD_DEFINED__
#define __IVdsServiceInitialization_FWD_DEFINED__
typedef interface IVdsServiceInitialization IVdsServiceInitialization;
#endif 	/* __IVdsServiceInitialization_FWD_DEFINED__ */


#ifndef __IVdsHbaPort_FWD_DEFINED__
#define __IVdsHbaPort_FWD_DEFINED__
typedef interface IVdsHbaPort IVdsHbaPort;
#endif 	/* __IVdsHbaPort_FWD_DEFINED__ */


#ifndef __IVdsIscsiInitiatorAdapter_FWD_DEFINED__
#define __IVdsIscsiInitiatorAdapter_FWD_DEFINED__
typedef interface IVdsIscsiInitiatorAdapter IVdsIscsiInitiatorAdapter;
#endif 	/* __IVdsIscsiInitiatorAdapter_FWD_DEFINED__ */


#ifndef __IVdsIscsiInitiatorPortal_FWD_DEFINED__
#define __IVdsIscsiInitiatorPortal_FWD_DEFINED__
typedef interface IVdsIscsiInitiatorPortal IVdsIscsiInitiatorPortal;
#endif 	/* __IVdsIscsiInitiatorPortal_FWD_DEFINED__ */


#ifndef __IVdsDiskPartitionMF_FWD_DEFINED__
#define __IVdsDiskPartitionMF_FWD_DEFINED__
typedef interface IVdsDiskPartitionMF IVdsDiskPartitionMF;
#endif 	/* __IVdsDiskPartitionMF_FWD_DEFINED__ */


#ifndef __IVdsVolumeMF_FWD_DEFINED__
#define __IVdsVolumeMF_FWD_DEFINED__
typedef interface IVdsVolumeMF IVdsVolumeMF;
#endif 	/* __IVdsVolumeMF_FWD_DEFINED__ */


#ifndef __IVdsVolumeMF2_FWD_DEFINED__
#define __IVdsVolumeMF2_FWD_DEFINED__
typedef interface IVdsVolumeMF2 IVdsVolumeMF2;
#endif 	/* __IVdsVolumeMF2_FWD_DEFINED__ */


#ifndef __IVdsVolumeShrink_FWD_DEFINED__
#define __IVdsVolumeShrink_FWD_DEFINED__
typedef interface IVdsVolumeShrink IVdsVolumeShrink;
#endif 	/* __IVdsVolumeShrink_FWD_DEFINED__ */


#ifndef __IVdsSubSystemImportTarget_FWD_DEFINED__
#define __IVdsSubSystemImportTarget_FWD_DEFINED__
typedef interface IVdsSubSystemImportTarget IVdsSubSystemImportTarget;
#endif 	/* __IVdsSubSystemImportTarget_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortalLocal_FWD_DEFINED__
#define __IVdsIscsiPortalLocal_FWD_DEFINED__
typedef interface IVdsIscsiPortalLocal IVdsIscsiPortalLocal;
#endif 	/* __IVdsIscsiPortalLocal_FWD_DEFINED__ */


#ifndef __IVdsServiceSAN_FWD_DEFINED__
#define __IVdsServiceSAN_FWD_DEFINED__
typedef interface IVdsServiceSAN IVdsServiceSAN;
#endif 	/* __IVdsServiceSAN_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "vdserr.h"
#include "vdslun.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vds_0000_0000 */
/* [local] */ 

//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) 2000 Microsoft Corporation.
//
//---------------------------------------------------------------





typedef GUID VDS_OBJECT_ID;

typedef 
enum _VDS_OBJECT_TYPE
    {	VDS_OT_UNKNOWN	= 0,
	VDS_OT_PROVIDER	= 1,
	VDS_OT_PACK	= 10,
	VDS_OT_VOLUME	= 11,
	VDS_OT_VOLUME_PLEX	= 12,
	VDS_OT_DISK	= 13,
	VDS_OT_SUB_SYSTEM	= 30,
	VDS_OT_CONTROLLER	= 31,
	VDS_OT_DRIVE	= 32,
	VDS_OT_LUN	= 33,
	VDS_OT_LUN_PLEX	= 34,
	VDS_OT_PORT	= 35,
	VDS_OT_PORTAL	= 36,
	VDS_OT_TARGET	= 37,
	VDS_OT_PORTAL_GROUP	= 38,
	VDS_OT_HBAPORT	= 90,
	VDS_OT_INIT_ADAPTER	= 91,
	VDS_OT_INIT_PORTAL	= 92,
	VDS_OT_ASYNC	= 100,
	VDS_OT_ENUM	= 101
    } 	VDS_OBJECT_TYPE;

typedef 
enum _VDS_PROVIDER_TYPE
    {	VDS_PT_UNKNOWN	= 0,
	VDS_PT_SOFTWARE	= 1,
	VDS_PT_HARDWARE	= 2
    } 	VDS_PROVIDER_TYPE;

typedef 
enum _VDS_PROVIDER_FLAG
    {	VDS_PF_DYNAMIC	= 0x1,
	VDS_PF_INTERNAL_HARDWARE_PROVIDER	= 0x2,
	VDS_PF_ONE_DISK_ONLY_PER_PACK	= 0x4,
	VDS_PF_ONE_PACK_ONLINE_ONLY	= 0x8,
	VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS	= 0x10,
	VDS_PF_SUPPORT_DYNAMIC	= 0x80000000,
	VDS_PF_SUPPORT_FAULT_TOLERANT	= 0x40000000,
	VDS_PF_SUPPORT_DYNAMIC_1394	= 0x20000000
    } 	VDS_PROVIDER_FLAG;

typedef 
enum _VDS_RECOVER_ACTION
    {	VDS_RA_UNKNOWN	= 0,
	VDS_RA_REFRESH	= 1,
	VDS_RA_RESTART	= 2
    } 	VDS_RECOVER_ACTION;

typedef 
enum _VDS_NOTIFICATION_TARGET_TYPE
    {	VDS_NTT_UNKNOWN	= 0,
	VDS_NTT_PACK	= VDS_OT_PACK,
	VDS_NTT_VOLUME	= VDS_OT_VOLUME,
	VDS_NTT_DISK	= VDS_OT_DISK,
	VDS_NTT_PARTITION	= 60,
	VDS_NTT_DRIVE_LETTER	= 61,
	VDS_NTT_FILE_SYSTEM	= 62,
	VDS_NTT_MOUNT_POINT	= 63,
	VDS_NTT_SUB_SYSTEM	= VDS_OT_SUB_SYSTEM,
	VDS_NTT_CONTROLLER	= VDS_OT_CONTROLLER,
	VDS_NTT_DRIVE	= VDS_OT_DRIVE,
	VDS_NTT_LUN	= VDS_OT_LUN,
	VDS_NTT_PORT	= VDS_OT_PORT,
	VDS_NTT_PORTAL	= VDS_OT_PORTAL,
	VDS_NTT_TARGET	= VDS_OT_TARGET,
	VDS_NTT_PORTAL_GROUP	= VDS_OT_PORTAL_GROUP,
	VDS_NTT_SERVICE	= 200
    } 	VDS_NOTIFICATION_TARGET_TYPE;

#define	VDS_NF_PACK_ARRIVE	( 1 )

#define	VDS_NF_PACK_DEPART	( 2 )

#define	VDS_NF_PACK_MODIFY	( 3 )

#define	VDS_NF_VOLUME_ARRIVE	( 4 )

#define	VDS_NF_VOLUME_DEPART	( 5 )

#define	VDS_NF_VOLUME_MODIFY	( 6 )

#define	VDS_NF_VOLUME_REBUILDING_PROGRESS	( 7 )

#define	VDS_NF_DISK_ARRIVE	( 8 )

#define	VDS_NF_DISK_DEPART	( 9 )

#define	VDS_NF_DISK_MODIFY	( 10 )

#define	VDS_NF_PARTITION_ARRIVE	( 11 )

#define	VDS_NF_PARTITION_DEPART	( 12 )

#define	VDS_NF_PARTITION_MODIFY	( 13 )

#define	VDS_NF_SUB_SYSTEM_ARRIVE	( 101 )

#define	VDS_NF_SUB_SYSTEM_DEPART	( 102 )

#define	VDS_NF_CONTROLLER_ARRIVE	( 103 )

#define	VDS_NF_CONTROLLER_DEPART	( 104 )

#define	VDS_NF_DRIVE_ARRIVE	( 105 )

#define	VDS_NF_DRIVE_DEPART	( 106 )

#define	VDS_NF_DRIVE_MODIFY	( 107 )

#define	VDS_NF_LUN_ARRIVE	( 108 )

#define	VDS_NF_LUN_DEPART	( 109 )

#define	VDS_NF_LUN_MODIFY	( 110 )

#define	VDS_NF_PORT_ARRIVE	( 121 )

#define	VDS_NF_PORT_DEPART	( 122 )

#define	VDS_NF_PORTAL_ARRIVE	( 123 )

#define	VDS_NF_PORTAL_DEPART	( 124 )

#define	VDS_NF_PORTAL_MODIFY	( 125 )

#define	VDS_NF_TARGET_ARRIVE	( 126 )

#define	VDS_NF_TARGET_DEPART	( 127 )

#define	VDS_NF_TARGET_MODIFY	( 128 )

#define	VDS_NF_PORTAL_GROUP_ARRIVE	( 129 )

#define	VDS_NF_PORTAL_GROUP_DEPART	( 130 )

#define	VDS_NF_PORTAL_GROUP_MODIFY	( 131 )

#define	VDS_NF_SUB_SYSTEM_MODIFY	( 151 )

#define	VDS_NF_DRIVE_LETTER_FREE	( 201 )

#define	VDS_NF_DRIVE_LETTER_ASSIGN	( 202 )

#define	VDS_NF_FILE_SYSTEM_MODIFY	( 203 )

#define	VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS	( 204 )

#define	VDS_NF_MOUNT_POINTS_CHANGE	( 205 )

#define	VDS_NF_FILE_SYSTEM_SHRINKING_PROGRESS	( 206 )

#define	VDS_NF_SERVICE_OUT_OF_SYNC	( 301 )

typedef struct _VDS_PACK_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID packId;
    } 	VDS_PACK_NOTIFICATION;

typedef struct _VDS_DISK_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID diskId;
    } 	VDS_DISK_NOTIFICATION;

typedef struct _VDS_VOLUME_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    VDS_OBJECT_ID plexId;
    ULONG ulPercentCompleted;
    } 	VDS_VOLUME_NOTIFICATION;

typedef struct _VDS_PARTITION_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID diskId;
    ULONGLONG ullOffset;
    } 	VDS_PARTITION_NOTIFICATION;

typedef struct _VDS_SERVICE_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_RECOVER_ACTION action;
    } 	VDS_SERVICE_NOTIFICATION;

typedef struct _VDS_DRIVE_LETTER_NOTIFICATION
    {
    ULONG ulEvent;
    WCHAR wcLetter;
    VDS_OBJECT_ID volumeId;
    } 	VDS_DRIVE_LETTER_NOTIFICATION;

typedef struct _VDS_FILE_SYSTEM_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    DWORD dwPercentCompleted;
    } 	VDS_FILE_SYSTEM_NOTIFICATION;

typedef struct _VDS_MOUNT_POINT_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    } 	VDS_MOUNT_POINT_NOTIFICATION;

typedef struct _VDS_SUB_SYSTEM_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID subSystemId;
    } 	VDS_SUB_SYSTEM_NOTIFICATION;

typedef struct _VDS_CONTROLLER_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID controllerId;
    } 	VDS_CONTROLLER_NOTIFICATION;

typedef struct _VDS_DRIVE_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID driveId;
    } 	VDS_DRIVE_NOTIFICATION;

typedef struct _VDS_LUN_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID LunId;
    } 	VDS_LUN_NOTIFICATION;

typedef struct _VDS_PORT_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portId;
    } 	VDS_PORT_NOTIFICATION;

typedef struct _VDS_PORTAL_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portalId;
    } 	VDS_PORTAL_NOTIFICATION;

typedef struct _VDS_TARGET_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID targetId;
    } 	VDS_TARGET_NOTIFICATION;

typedef struct _VDS_PORTAL_GROUP_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portalGroupId;
    } 	VDS_PORTAL_GROUP_NOTIFICATION;

typedef struct _VDS_NOTIFICATION
    {
    VDS_NOTIFICATION_TARGET_TYPE objectType;
    /* [switch_type] */ union 
        {
        VDS_PACK_NOTIFICATION Pack;
        VDS_DISK_NOTIFICATION Disk;
        VDS_VOLUME_NOTIFICATION Volume;
        VDS_PARTITION_NOTIFICATION Partition;
        VDS_DRIVE_LETTER_NOTIFICATION Letter;
        VDS_FILE_SYSTEM_NOTIFICATION FileSystem;
        VDS_MOUNT_POINT_NOTIFICATION MountPoint;
        VDS_SUB_SYSTEM_NOTIFICATION SubSystem;
        VDS_CONTROLLER_NOTIFICATION Controller;
        VDS_DRIVE_NOTIFICATION Drive;
        VDS_LUN_NOTIFICATION Lun;
        VDS_PORT_NOTIFICATION Port;
        VDS_PORTAL_NOTIFICATION Portal;
        VDS_TARGET_NOTIFICATION Target;
        VDS_PORTAL_GROUP_NOTIFICATION PortalGroup;
        VDS_SERVICE_NOTIFICATION Service;
         /* Empty union arm */ 
        } 	;
    } 	VDS_NOTIFICATION;

typedef 
enum _VDS_ASYNC_OUTPUT_TYPE
    {	VDS_ASYNCOUT_UNKNOWN	= 0,
	VDS_ASYNCOUT_CREATEVOLUME	= 1,
	VDS_ASYNCOUT_EXTENDVOLUME	= 2,
	VDS_ASYNCOUT_SHRINKVOLUME	= 3,
	VDS_ASYNCOUT_ADDVOLUMEPLEX	= 4,
	VDS_ASYNCOUT_BREAKVOLUMEPLEX	= 5,
	VDS_ASYNCOUT_REMOVEVOLUMEPLEX	= 6,
	VDS_ASYNCOUT_REPAIRVOLUMEPLEX	= 7,
	VDS_ASYNCOUT_RECOVERPACK	= 8,
	VDS_ASYNCOUT_REPLACEDISK	= 9,
	VDS_ASYNCOUT_CREATEPARTITION	= 10,
	VDS_ASYNCOUT_CLEAN	= 11,
	VDS_ASYNCOUT_CREATELUN	= 50,
	VDS_ASYNCOUT_ADDLUNPLEX	= 52,
	VDS_ASYNCOUT_REMOVELUNPLEX	= 53,
	VDS_ASYNCOUT_EXTENDLUN	= 54,
	VDS_ASYNCOUT_SHRINKLUN	= 55,
	VDS_ASYNCOUT_RECOVERLUN	= 56,
	VDS_ASYNCOUT_LOGINTOTARGET	= 60,
	VDS_ASYNCOUT_LOGOUTFROMTARGET	= 61,
	VDS_ASYNCOUT_CREATETARGET	= 62,
	VDS_ASYNCOUT_CREATEPORTALGROUP	= 63,
	VDS_ASYNCOUT_DELETETARGET	= 64,
	VDS_ASYNCOUT_ADDPORTAL	= 65,
	VDS_ASYNCOUT_REMOVEPORTAL	= 66,
	VDS_ASYNCOUT_DELETEPORTALGROUP	= 67,
	VDS_ASYNCOUT_FORMAT	= 101
    } 	VDS_ASYNC_OUTPUT_TYPE;

typedef struct _VDS_ASYNC_OUTPUT
    {
    VDS_ASYNC_OUTPUT_TYPE type;
    /* [switch_type] */ union 
        {
        struct _cp
            {
            ULONGLONG ullOffset;
            VDS_OBJECT_ID volumeId;
            } 	cp;
        struct _cv
            {
            IUnknown *pVolumeUnk;
            } 	cv;
        struct _bvp
            {
            IUnknown *pVolumeUnk;
            } 	bvp;
        struct _sv
            {
            ULONGLONG ullReclaimedBytes;
            } 	sv;
        struct _cl
            {
            IUnknown *pLunUnk;
            } 	cl;
        struct _ct
            {
            IUnknown *pTargetUnk;
            } 	ct;
        struct _cpg
            {
            IUnknown *pPortalGroupUnk;
            } 	cpg;
         /* Empty union arm */ 
        } 	;
    } 	VDS_ASYNC_OUTPUT;

typedef USHORT VDS_ISCSI_PORTALGROUP_TAG;

typedef 
enum VDS_IPADDRESS_TYPE
    {	VDS_IPT_TEXT	= 0,
	VDS_IPT_IPV4	= 1,
	VDS_IPT_IPV6	= 2,
	VDS_IPT_EMPTY	= 3
    } 	VDS_IPADDRESS_TYPE;

typedef 
enum _VDS_HEALTH
    {	VDS_H_UNKNOWN	= 0,
	VDS_H_HEALTHY	= 1,
	VDS_H_REBUILDING	= 2,
	VDS_H_STALE	= 3,
	VDS_H_FAILING	= 4,
	VDS_H_FAILING_REDUNDANCY	= 5,
	VDS_H_FAILED_REDUNDANCY	= 6,
	VDS_H_FAILED_REDUNDANCY_FAILING	= 7,
	VDS_H_FAILED	= 8
    } 	VDS_HEALTH;

typedef 
enum _VDS_TRANSITION_STATE
    {	VDS_TS_UNKNOWN	= 0,
	VDS_TS_STABLE	= 1,
	VDS_TS_EXTENDING	= 2,
	VDS_TS_SHRINKING	= 3,
	VDS_TS_RECONFIGING	= 4
    } 	VDS_TRANSITION_STATE;

typedef 
enum _VDS_FILE_SYSTEM_TYPE
    {	VDS_FST_UNKNOWN	= 0,
	VDS_FST_RAW	= ( VDS_FST_UNKNOWN + 1 ) ,
	VDS_FST_FAT	= ( VDS_FST_RAW + 1 ) ,
	VDS_FST_FAT32	= ( VDS_FST_FAT + 1 ) ,
	VDS_FST_NTFS	= ( VDS_FST_FAT32 + 1 ) ,
	VDS_FST_CDFS	= ( VDS_FST_NTFS + 1 ) ,
	VDS_FST_UDF	= ( VDS_FST_CDFS + 1 ) 
    } 	VDS_FILE_SYSTEM_TYPE;

typedef 
enum _VDS_HBAPORT_TYPE
    {	VDS_HPT_UNKNOWN	= 1,
	VDS_HPT_OTHER	= 2,
	VDS_HPT_NOTPRESENT	= 3,
	VDS_HPT_NPORT	= 5,
	VDS_HPT_NLPORT	= 6,
	VDS_HPT_FLPORT	= 7,
	VDS_HPT_FPORT	= 8,
	VDS_HPT_EPORT	= 9,
	VDS_HPT_GPORT	= 10,
	VDS_HPT_LPORT	= 20,
	VDS_HPT_PTP	= 21
    } 	VDS_HBAPORT_TYPE;

typedef 
enum _VDS_HBAPORT_STATUS
    {	VDS_HPS_UNKNOWN	= 1,
	VDS_HPS_ONLINE	= 2,
	VDS_HPS_OFFLINE	= 3,
	VDS_HPS_BYPASSED	= 4,
	VDS_HPS_DIAGNOSTICS	= 5,
	VDS_HPS_LINKDOWN	= 6,
	VDS_HPS_ERROR	= 7,
	VDS_HPS_LOOPBACK	= 8
    } 	VDS_HBAPORT_STATUS;

typedef 
enum _VDS_HBAPORT_SPEED_FLAG
    {	VDS_HSF_UNKNOWN	= 0,
	VDS_HSF_1GBIT	= 0x1,
	VDS_HSF_2GBIT	= 0x2,
	VDS_HSF_10GBIT	= 0x4,
	VDS_HSF_4GBIT	= 0x8,
	VDS_HSF_NOT_NEGOTIATED	= ( 1 << 15 ) 
    } 	VDS_HBAPORT_SPEED_FLAG;

typedef 
enum _VDS_PATH_STATUS
    {	VDS_MPS_UNKNOWN	= 0,
	VDS_MPS_ONLINE	= 1,
	VDS_MPS_FAILED	= 5,
	VDS_MPS_STANDBY	= 7
    } 	VDS_PATH_STATUS;

typedef 
enum _VDS_LOADBALANCE_POLICY_ENUM
    {	VDS_LBP_UNKNOWN	= 0,
	VDS_LBP_FAILOVER	= 1,
	VDS_LBP_ROUND_ROBIN	= 2,
	VDS_LBP_ROUND_ROBIN_WITH_SUBSET	= 3,
	VDS_LBP_DYN_LEAST_QUEUE_DEPTH	= 4,
	VDS_LBP_WEIGHTED_PATHS	= 5,
	VDS_LBP_LEAST_BLOCKS	= 6,
	VDS_LBP_VENDOR_SPECIFIC	= 7
    } 	VDS_LOADBALANCE_POLICY_ENUM;

typedef 
enum _VDS_PROVIDER_LBSUPPORT_FLAG
    {	VDS_LBF_FAILOVER	= 0x1,
	VDS_LBF_ROUND_ROBIN	= 0x2,
	VDS_LBF_ROUND_ROBIN_WITH_SUBSET	= 0x4,
	VDS_LBF_DYN_LEAST_QUEUE_DEPTH	= 0x8,
	VDS_LBF_WEIGHTED_PATHS	= 0x10,
	VDS_LBF_LEAST_BLOCKS	= 0x20,
	VDS_LBF_VENDOR_SPECIFIC	= 0x40
    } 	VDS_PROVIDER_LBSUPPORT_FLAG;

typedef 
enum _VDS_VERSION_SUPPORT_FLAG
    {	VDS_VSF_1_0	= 0x1,
	VDS_VSF_1_1	= 0x2
    } 	VDS_VERSION_SUPPORT_FLAG;

typedef 
enum _VDS_HWPROVIDER_TYPE
    {	VDS_HWT_UNKNOWN	= 0,
	VDS_HWT_PCI_RAID	= 1,
	VDS_HWT_FIBRE_CHANNEL	= 2,
	VDS_HWT_ISCSI	= 3
    } 	VDS_HWPROVIDER_TYPE;

typedef 
enum _VDS_ISCSI_LOGIN_TYPE
    {	VDS_ILT_MANUAL	= 0,
	VDS_ILT_PERSISTENT	= 1,
	VDS_ILT_BOOT	= 2
    } 	VDS_ISCSI_LOGIN_TYPE;

typedef 
enum _VDS_ISCSI_AUTH_TYPE
    {	VDS_IAT_NONE	= 0,
	VDS_IAT_CHAP	= 1,
	VDS_IAT_MUTUAL_CHAP	= 2
    } 	VDS_ISCSI_AUTH_TYPE;

typedef 
enum _VDS_ISCSI_IPSEC_FLAG
    {	VDS_IIF_VALID	= 0x1,
	VDS_IIF_IKE	= 0x2,
	VDS_IIF_MAIN_MODE	= 0x4,
	VDS_IIF_AGGRESSIVE_MODE	= 0x8,
	VDS_IIF_PFS_ENABLE	= 0x10,
	VDS_IIF_TRANSPORT_MODE_PREFERRED	= 0x20,
	VDS_IIF_TUNNEL_MODE_PREFERRED	= 0x40
    } 	VDS_ISCSI_IPSEC_FLAG;

typedef 
enum _VDS_ISCSI_LOGIN_FLAG
    {	VDS_ILF_REQUIRE_IPSEC	= 0x1,
	VDS_ILF_MULTIPATH_ENABLED	= 0x2
    } 	VDS_ISCSI_LOGIN_FLAG;

typedef struct _VDS_PATH_ID
    {
    ULONGLONG ullSourceId;
    ULONGLONG ullPathId;
    } 	VDS_PATH_ID;

typedef struct _VDS_WWN
    {
    UCHAR rguchWwn[ 8 ];
    } 	VDS_WWN;

typedef struct _VDS_IPADDRESS
    {
    VDS_IPADDRESS_TYPE type;
    ULONG ipv4Address;
    UCHAR ipv6Address[ 16 ];
    ULONG ulIpv6FlowInfo;
    ULONG ulIpv6ScopeId;
    WCHAR wszTextAddress[ 257 ];
    ULONG ulPort;
    } 	VDS_IPADDRESS;

typedef struct _VDS_ISCSI_IPSEC_KEY
    {
    UCHAR *pKey;
    ULONG ulKeySize;
    } 	VDS_ISCSI_IPSEC_KEY;

typedef struct _VDS_ISCSI_SHARED_SECRET
    {
    UCHAR *pSharedSecret;
    ULONG ulSharedSecretSize;
    } 	VDS_ISCSI_SHARED_SECRET;

typedef struct _VDS_HBAPORT_PROP
    {
    VDS_OBJECT_ID id;
    VDS_WWN wwnNode;
    VDS_WWN wwnPort;
    VDS_HBAPORT_TYPE type;
    VDS_HBAPORT_STATUS status;
    ULONG ulPortSpeed;
    ULONG ulSupportedPortSpeed;
    } 	VDS_HBAPORT_PROP;

typedef struct _VDS_ISCSI_INITIATOR_ADAPTER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    } 	VDS_ISCSI_INITIATOR_ADAPTER_PROP;

typedef struct _VDS_ISCSI_INITIATOR_PORTAL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    ULONG ulPortIndex;
    } 	VDS_ISCSI_INITIATOR_PORTAL_PROP;

typedef struct _VDS_PROVIDER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    GUID guidVersionId;
    LPWSTR pwszVersion;
    VDS_PROVIDER_TYPE type;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    SHORT sRebuildPriority;
    } 	VDS_PROVIDER_PROP;

typedef struct _VDS_PATH_INFO
    {
    VDS_PATH_ID pathId;
    VDS_HWPROVIDER_TYPE type;
    VDS_PATH_STATUS status;
    /* [switch_type] */ union 
        {
        VDS_OBJECT_ID controllerPortId;
        VDS_OBJECT_ID targetPortalId;
         /* Empty union arm */ 
        } 	;
    /* [switch_type] */ union 
        {
        VDS_OBJECT_ID hbaPortId;
        VDS_OBJECT_ID initiatorAdapterId;
         /* Empty union arm */ 
        } 	;
    /* [switch_type] */ union 
        {
        VDS_HBAPORT_PROP *pHbaPortProp;
        VDS_IPADDRESS *pInitiatorPortalIpAddr;
         /* Empty union arm */ 
        } 	;
    } 	VDS_PATH_INFO;

typedef struct _VDS_PATH_POLICY
    {
    VDS_PATH_ID pathId;
    BOOL bPrimaryPath;
    ULONG ulWeight;
    } 	VDS_PATH_POLICY;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumVdsObject_INTERFACE_DEFINED__
#define __IEnumVdsObject_INTERFACE_DEFINED__

/* interface IEnumVdsObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumVdsObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("118610b7-8d94-4030-b5b8-500889788e4e")
    IEnumVdsObject : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) IUnknown **ppObjectArray,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumVdsObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumVdsObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumVdsObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumVdsObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumVdsObject * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) IUnknown **ppObjectArray,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumVdsObject * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumVdsObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumVdsObject * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IEnumVdsObjectVtbl;

    interface IEnumVdsObject
    {
        CONST_VTBL struct IEnumVdsObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumVdsObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumVdsObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumVdsObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumVdsObject_Next(This,celt,ppObjectArray,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppObjectArray,pcFetched) ) 

#define IEnumVdsObject_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumVdsObject_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumVdsObject_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumVdsObject_INTERFACE_DEFINED__ */


#ifndef __IVdsAsync_INTERFACE_DEFINED__
#define __IVdsAsync_INTERFACE_DEFINED__

/* interface IVdsAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5d23b6d-5a55-4492-9889-397a3c2d2dbc")
    IVdsAsync : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Wait( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out VDS_ASYNC_OUTPUT *pAsyncOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out ULONG *pulPercentCompleted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IVdsAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Wait )( 
            IVdsAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out VDS_ASYNC_OUTPUT *pAsyncOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IVdsAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out ULONG *pulPercentCompleted);
        
        END_INTERFACE
    } IVdsAsyncVtbl;

    interface IVdsAsync
    {
        CONST_VTBL struct IVdsAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAsync_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IVdsAsync_Wait(This,pHrResult,pAsyncOut)	\
    ( (This)->lpVtbl -> Wait(This,pHrResult,pAsyncOut) ) 

#define IVdsAsync_QueryStatus(This,pHrResult,pulPercentCompleted)	\
    ( (This)->lpVtbl -> QueryStatus(This,pHrResult,pulPercentCompleted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAsync_INTERFACE_DEFINED__ */


#ifndef __IVdsAdviseSink_INTERFACE_DEFINED__
#define __IVdsAdviseSink_INTERFACE_DEFINED__

/* interface IVdsAdviseSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8326cd1d-cf59-4936-b786-5efc08798e25")
    IVdsAdviseSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnNotify( 
            /* [range][in] */ LONG lNumberOfNotifications,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfNotifications) VDS_NOTIFICATION *pNotificationArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdviseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsAdviseSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsAdviseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsAdviseSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
            IVdsAdviseSink * This,
            /* [range][in] */ LONG lNumberOfNotifications,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfNotifications) VDS_NOTIFICATION *pNotificationArray);
        
        END_INTERFACE
    } IVdsAdviseSinkVtbl;

    interface IVdsAdviseSink
    {
        CONST_VTBL struct IVdsAdviseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdviseSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdviseSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdviseSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdviseSink_OnNotify(This,lNumberOfNotifications,pNotificationArray)	\
    ( (This)->lpVtbl -> OnNotify(This,lNumberOfNotifications,pNotificationArray) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdviseSink_INTERFACE_DEFINED__ */


#ifndef __IVdsProvider_INTERFACE_DEFINED__
#define __IVdsProvider_INTERFACE_DEFINED__

/* interface IVdsProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10c5e575-7984-4e81-a56b-431f5f92ae42")
    IVdsProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PROVIDER_PROP *pProviderProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsProvider * This,
            /* [out] */ __RPC__out VDS_PROVIDER_PROP *pProviderProp);
        
        END_INTERFACE
    } IVdsProviderVtbl;

    interface IVdsProvider
    {
        CONST_VTBL struct IVdsProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProvider_GetProperties(This,pProviderProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pProviderProp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsProviderSupport_INTERFACE_DEFINED__
#define __IVdsProviderSupport_INTERFACE_DEFINED__

/* interface IVdsProviderSupport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProviderSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1732be13-e8f9-4a03-bfbc-5f616aa66ce1")
    IVdsProviderSupport : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVersionSupport( 
            /* [out] */ __RPC__out ULONG *ulVersionSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsProviderSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsProviderSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsProviderSupport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVersionSupport )( 
            IVdsProviderSupport * This,
            /* [out] */ __RPC__out ULONG *ulVersionSupport);
        
        END_INTERFACE
    } IVdsProviderSupportVtbl;

    interface IVdsProviderSupport
    {
        CONST_VTBL struct IVdsProviderSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProviderSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProviderSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProviderSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProviderSupport_GetVersionSupport(This,ulVersionSupport)	\
    ( (This)->lpVtbl -> GetVersionSupport(This,ulVersionSupport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProviderSupport_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0005 */
/* [local] */ 














typedef 
enum _VDS_PACK_STATUS
    {	VDS_PS_UNKNOWN	= 0,
	VDS_PS_ONLINE	= 1,
	VDS_PS_OFFLINE	= 4
    } 	VDS_PACK_STATUS;

typedef 
enum _VDS_PACK_FLAG
    {	VDS_PKF_FOREIGN	= 0x1,
	VDS_PKF_NOQUORUM	= 0x2,
	VDS_PKF_POLICY	= 0x4,
	VDS_PKF_CORRUPTED	= 0x8,
	VDS_PKF_ONLINE_ERROR	= 0x10
    } 	VDS_PACK_FLAG;

typedef 
enum _VDS_DISK_STATUS
    {	VDS_DS_UNKNOWN	= 0,
	VDS_DS_ONLINE	= 1,
	VDS_DS_NOT_READY	= 2,
	VDS_DS_NO_MEDIA	= 3,
	VDS_DS_FAILED	= 5,
	VDS_DS_MISSING	= 6,
	VDS_DS_OFFLINE	= 4
    } 	VDS_DISK_STATUS;

typedef 
enum _VDS_PARTITION_STYLE
    {	VDS_PST_UNKNOWN	= 0,
	VDS_PST_MBR	= 1,
	VDS_PST_GPT	= 2
    } 	VDS_PARTITION_STYLE;

typedef 
enum _VDS_DISK_FLAG
    {	VDS_DF_AUDIO_CD	= 0x1,
	VDS_DF_HOTSPARE	= 0x2,
	VDS_DF_RESERVE_CAPABLE	= 0x4,
	VDS_DF_MASKED	= 0x8,
	VDS_DF_STYLE_CONVERTIBLE	= 0x10,
	VDS_DF_CLUSTERED	= 0x20,
	VDS_DF_READ_ONLY	= 0x40,
	VDS_DF_SYSTEM_DISK	= 0x80,
	VDS_DF_BOOT_DISK	= 0x100,
	VDS_DF_PAGEFILE_DISK	= 0x200,
	VDS_DF_HIBERNATIONFILE_DISK	= 0x400,
	VDS_DF_CRASHDUMP_DISK	= 0x800,
	VDS_DF_HAS_ARC_PATH	= 0x1000,
	VDS_DF_DYNAMIC	= 0x2000
    } 	VDS_DISK_FLAG;

typedef 
enum _VDS_PARTITION_FLAG
    {	VDS_PTF_SYSTEM	= 0x1
    } 	VDS_PARTITION_FLAG;

typedef 
enum _VDS_LUN_RESERVE_MODE
    {	VDS_LRM_NONE	= 0,
	VDS_LRM_EXCLUSIVE_RW	= 1,
	VDS_LRM_EXCLUSIVE_RO	= 2,
	VDS_LRM_SHARED_RO	= 3,
	VDS_LRM_SHARED_RW	= 4
    } 	VDS_LUN_RESERVE_MODE;

typedef 
enum _VDS_VOLUME_STATUS
    {	VDS_VS_UNKNOWN	= 0,
	VDS_VS_ONLINE	= 1,
	VDS_VS_NO_MEDIA	= 3,
	VDS_VS_FAILED	= 5
    } 	VDS_VOLUME_STATUS;

typedef 
enum _VDS_VOLUME_TYPE
    {	VDS_VT_UNKNOWN	= 0,
	VDS_VT_SIMPLE	= 10,
	VDS_VT_SPAN	= 11,
	VDS_VT_STRIPE	= 12,
	VDS_VT_MIRROR	= 13,
	VDS_VT_PARITY	= 14
    } 	VDS_VOLUME_TYPE;

typedef 
enum _VDS_VOLUME_FLAG
    {	VDS_VF_SYSTEM_VOLUME	= 0x1,
	VDS_VF_BOOT_VOLUME	= 0x2,
	VDS_VF_ACTIVE	= 0x4,
	VDS_VF_READONLY	= 0x8,
	VDS_VF_HIDDEN	= 0x10,
	VDS_VF_CAN_EXTEND	= 0x20,
	VDS_VF_CAN_SHRINK	= 0x40,
	VDS_VF_PAGEFILE	= 0x80,
	VDS_VF_HIBERNATION	= 0x100,
	VDS_VF_CRASHDUMP	= 0x200,
	VDS_VF_INSTALLABLE	= 0x400,
	VDS_VF_LBN_REMAP_ENABLED	= 0x800,
	VDS_VF_FORMATTING	= 0x1000,
	VDS_VF_NOT_FORMATTABLE	= 0x2000,
	VDS_VF_NTFS_NOT_SUPPORTED	= 0x4000,
	VDS_VF_FAT32_NOT_SUPPORTED	= 0x8000,
	VDS_VF_FAT_NOT_SUPPORTED	= 0x10000,
	VDS_VF_NO_DEFAULT_DRIVE_LETTER	= 0x20000,
	VDS_VF_PERMANENTLY_DISMOUNTED	= 0x40000,
	VDS_VF_PERMANENT_DISMOUNT_SUPPORTED	= 0x80000,
	VDS_VF_SHADOW_COPY	= 0x100000,
	VDS_VF_FVE_ENABLED	= 0x200000,
	VDS_VF_DIRTY	= 0x400000
    } 	VDS_VOLUME_FLAG;

typedef 
enum _VDS_VOLUME_PLEX_TYPE
    {	VDS_VPT_UNKNOWN	= 0,
	VDS_VPT_SIMPLE	= VDS_VT_SIMPLE,
	VDS_VPT_SPAN	= VDS_VT_SPAN,
	VDS_VPT_STRIPE	= VDS_VT_STRIPE,
	VDS_VPT_PARITY	= VDS_VT_PARITY
    } 	VDS_VOLUME_PLEX_TYPE;

typedef 
enum _VDS_VOLUME_PLEX_STATUS
    {	VDS_VPS_UNKNOWN	= 0,
	VDS_VPS_ONLINE	= 1,
	VDS_VPS_NO_MEDIA	= 3,
	VDS_VPS_FAILED	= 5
    } 	VDS_VOLUME_PLEX_STATUS;

typedef 
enum _VDS_DISK_EXTENT_TYPE
    {	VDS_DET_UNKNOWN	= 0,
	VDS_DET_FREE	= 1,
	VDS_DET_DATA	= 2,
	VDS_DET_OEM	= 3,
	VDS_DET_ESP	= 4,
	VDS_DET_MSR	= 5,
	VDS_DET_LDM	= 6,
	VDS_DET_CLUSTER	= 7,
	VDS_DET_UNUSABLE	= 0x7fff
    } 	VDS_DISK_EXTENT_TYPE;

typedef struct _VDS_PACK_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    VDS_PACK_STATUS status;
    ULONG ulFlags;
    } 	VDS_PACK_PROP;

typedef struct _VDS_PACK_PROP *PVDS_PACK_PROP;

typedef struct _VDS_DISK_PROP
    {
    VDS_OBJECT_ID id;
    VDS_DISK_STATUS status;
    VDS_LUN_RESERVE_MODE ReserveMode;
    VDS_HEALTH health;
    DWORD dwDeviceType;
    DWORD dwMediaType;
    ULONGLONG ullSize;
    ULONG ulBytesPerSector;
    ULONG ulSectorsPerTrack;
    ULONG ulTracksPerCylinder;
    ULONG ulFlags;
    VDS_STORAGE_BUS_TYPE BusType;
    VDS_PARTITION_STYLE PartitionStyle;
    /* [switch_type] */ union 
        {
        DWORD dwSignature;
        GUID DiskGuid;
         /* Empty union arm */ 
        } 	;
    LPWSTR pwszDiskAddress;
    LPWSTR pwszName;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszAdaptorName;
    LPWSTR pwszDevicePath;
    } 	VDS_DISK_PROP;

typedef struct _VDS_DISK_PROP *PVDS_DISK_PROP;

typedef struct _VDS_VOLUME_PROP
    {
    VDS_OBJECT_ID id;
    VDS_VOLUME_TYPE type;
    VDS_VOLUME_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG ullSize;
    ULONG ulFlags;
    VDS_FILE_SYSTEM_TYPE RecommendedFileSystemType;
    LPWSTR pwszName;
    } 	VDS_VOLUME_PROP;

typedef struct _VDS_VOLUME_PROP *PVDS_VOLUME_PROP;

typedef struct _VDS_VOLUME_PLEX_PROP
    {
    VDS_OBJECT_ID id;
    VDS_VOLUME_PLEX_TYPE type;
    VDS_VOLUME_PLEX_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG ullSize;
    ULONG ulStripeSize;
    ULONG ulNumberOfMembers;
    } 	VDS_VOLUME_PLEX_PROP;

typedef struct _VDS_VOLUME_PLEX_PROP *PVDS_VOLUME_PLEX_PROP;

typedef struct _VDS_DISK_EXTENT
    {
    VDS_OBJECT_ID diskId;
    VDS_DISK_EXTENT_TYPE type;
    ULONGLONG ullOffset;
    ULONGLONG ullSize;
    VDS_OBJECT_ID volumeId;
    VDS_OBJECT_ID plexId;
    ULONG memberIdx;
    } 	VDS_DISK_EXTENT;

typedef struct _VDS_DISK_EXTENT *PVDS_DISK_EXTENT;

typedef struct _VDS_INPUT_DISK
    {
    VDS_OBJECT_ID diskId;
    ULONGLONG ullSize;
    VDS_OBJECT_ID plexId;
    ULONG memberIdx;
    } 	VDS_INPUT_DISK;

#define GPT_PARTITION_NAME_LENGTH    36
typedef struct _VDS_PARTITION_INFO_GPT
    {
    GUID partitionType;
    GUID partitionId;
    ULONGLONG attributes;
    WCHAR name[ 36 ];
    } 	VDS_PARTITION_INFO_GPT;

typedef struct _VDS_PARTITION_INFO_MBR
    {
    BYTE partitionType;
    BOOLEAN bootIndicator;
    BOOLEAN recognizedPartition;
    DWORD hiddenSectors;
    } 	VDS_PARTITION_INFO_MBR;

typedef struct _VDS_PARTITION_PROP
    {
    VDS_PARTITION_STYLE PartitionStyle;
    ULONG ulFlags;
    ULONG ulPartitionNumber;
    ULONGLONG ullOffset;
    ULONGLONG ullSize;
    /* [switch_type] */ union 
        {
        VDS_PARTITION_INFO_MBR Mbr;
        VDS_PARTITION_INFO_GPT Gpt;
         /* Empty union arm */ 
        } 	;
    } 	VDS_PARTITION_PROP;

typedef 
enum tag_VDS_PARTITION_STYLE
    {	VDS_PARTITION_STYLE_MBR	= 0,
	VDS_PARTITION_STYLE_GPT	= ( VDS_PARTITION_STYLE_MBR + 1 ) ,
	VDS_PARTITION_STYLE_RAW	= ( VDS_PARTITION_STYLE_GPT + 1 ) 
    } 	__VDS_PARTITION_STYLE;

typedef struct _VDS_PARTITION_INFORMATION_EX
    {
    __VDS_PARTITION_STYLE dwPartitionStyle;
    ULONGLONG ullStartingOffset;
    ULONGLONG ullPartitionLength;
    DWORD dwPartitionNumber;
    BOOLEAN bRewritePartition;
    /* [switch_type] */ union 
        {
        VDS_PARTITION_INFO_MBR Mbr;
        VDS_PARTITION_INFO_GPT Gpt;
        } 	;
    } 	VDS_PARTITION_INFORMATION_EX;

typedef struct _CREATE_PARTITION_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BYTE partitionType;
            BOOLEAN bootIndicator;
            } 	MbrPartInfo;
        struct 
            {
            GUID partitionType;
            GUID partitionId;
            ULONGLONG attributes;
            WCHAR name[ 36 ];
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CREATE_PARTITION_PARAMETERS;

typedef struct _CHANGE_ATTRIBUTES_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BOOLEAN bootIndicator;
            } 	MbrPartInfo;
        struct 
            {
            ULONGLONG attributes;
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CHANGE_ATTRIBUTES_PARAMETERS;

typedef struct _CHANGE_PARTITION_TYPE_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BYTE partitionType;
            } 	MbrPartInfo;
        struct 
            {
            GUID partitionType;
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CHANGE_PARTITION_TYPE_PARAMETERS;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0005_v0_0_s_ifspec;

#ifndef __IVdsSwProvider_INTERFACE_DEFINED__
#define __IVdsSwProvider_INTERFACE_DEFINED__

/* interface IVdsSwProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSwProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9aa58360-ce33-4f92-b658-ed24b14425b8")
    IVdsSwProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPacks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSwProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsSwProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsSwProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsSwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPacks )( 
            IVdsSwProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePack )( 
            IVdsSwProvider * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        END_INTERFACE
    } IVdsSwProviderVtbl;

    interface IVdsSwProvider
    {
        CONST_VTBL struct IVdsSwProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSwProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSwProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSwProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSwProvider_QueryPacks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPacks(This,ppEnum) ) 

#define IVdsSwProvider_CreatePack(This,ppPack)	\
    ( (This)->lpVtbl -> CreatePack(This,ppPack) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSwProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsPack_INTERFACE_DEFINED__
#define __IVdsPack_INTERFACE_DEFINED__

/* interface IVdsPack */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsPack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3b69d7f5-9d94-4648-91ca-79939ba263bf")
    IVdsPack : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PACK_PROP *pPackProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryVolumes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVolume( 
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDisk( 
            /* [in] */ VDS_OBJECT_ID DiskId,
            /* [in] */ VDS_PARTITION_STYLE PartitionStyle,
            /* [in] */ BOOL bAsHotSpare) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MigrateDisks( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_OBJECT_ID *pDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ VDS_OBJECT_ID TargetPack,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQueryOnly,
            /* [size_is][out] */ __RPC__out_ecount_full(lNumberOfDisks) HRESULT *pResults,
            /* [out] */ __RPC__out BOOL *pbRebootNeeded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReplaceDisk( 
            /* [in] */ VDS_OBJECT_ID OldDiskId,
            /* [in] */ VDS_OBJECT_ID NewDiskId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveMissingDisk( 
            /* [in] */ VDS_OBJECT_ID DiskId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recover( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsPackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsPack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsPack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsPack * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsPack * This,
            /* [out] */ __RPC__out VDS_PACK_PROP *pPackProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryVolumes )( 
            IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDisks )( 
            IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVolume )( 
            IVdsPack * This,
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDisk )( 
            IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID DiskId,
            /* [in] */ VDS_PARTITION_STYLE PartitionStyle,
            /* [in] */ BOOL bAsHotSpare);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MigrateDisks )( 
            IVdsPack * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_OBJECT_ID *pDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ VDS_OBJECT_ID TargetPack,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQueryOnly,
            /* [size_is][out] */ __RPC__out_ecount_full(lNumberOfDisks) HRESULT *pResults,
            /* [out] */ __RPC__out BOOL *pbRebootNeeded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReplaceDisk )( 
            IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID OldDiskId,
            /* [in] */ VDS_OBJECT_ID NewDiskId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveMissingDisk )( 
            IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID DiskId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Recover )( 
            IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsPackVtbl;

    interface IVdsPack
    {
        CONST_VTBL struct IVdsPackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsPack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsPack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsPack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsPack_GetProperties(This,pPackProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPackProp) ) 

#define IVdsPack_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsPack_QueryVolumes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryVolumes(This,ppEnum) ) 

#define IVdsPack_QueryDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryDisks(This,ppEnum) ) 

#define IVdsPack_CreateVolume(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ppAsync)	\
    ( (This)->lpVtbl -> CreateVolume(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ppAsync) ) 

#define IVdsPack_AddDisk(This,DiskId,PartitionStyle,bAsHotSpare)	\
    ( (This)->lpVtbl -> AddDisk(This,DiskId,PartitionStyle,bAsHotSpare) ) 

#define IVdsPack_MigrateDisks(This,pDiskArray,lNumberOfDisks,TargetPack,bForce,bQueryOnly,pResults,pbRebootNeeded)	\
    ( (This)->lpVtbl -> MigrateDisks(This,pDiskArray,lNumberOfDisks,TargetPack,bForce,bQueryOnly,pResults,pbRebootNeeded) ) 

#define IVdsPack_ReplaceDisk(This,OldDiskId,NewDiskId,ppAsync)	\
    ( (This)->lpVtbl -> ReplaceDisk(This,OldDiskId,NewDiskId,ppAsync) ) 

#define IVdsPack_RemoveMissingDisk(This,DiskId)	\
    ( (This)->lpVtbl -> RemoveMissingDisk(This,DiskId) ) 

#define IVdsPack_Recover(This,ppAsync)	\
    ( (This)->lpVtbl -> Recover(This,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsPack_INTERFACE_DEFINED__ */


#ifndef __IVdsPack2_INTERFACE_DEFINED__
#define __IVdsPack2_INTERFACE_DEFINED__

/* interface IVdsPack2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsPack2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13B50BFF-290A-47DD-8558-B7C58DB1A71A")
    IVdsPack2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVolume2( 
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [in] */ ULONG ulAlign,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsPack2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsPack2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsPack2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsPack2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVolume2 )( 
            IVdsPack2 * This,
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [in] */ ULONG ulAlign,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsPack2Vtbl;

    interface IVdsPack2
    {
        CONST_VTBL struct IVdsPack2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsPack2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsPack2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsPack2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsPack2_CreateVolume2(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ulAlign,ppAsync)	\
    ( (This)->lpVtbl -> CreateVolume2(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ulAlign,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsPack2_INTERFACE_DEFINED__ */


#ifndef __IVdsDisk_INTERFACE_DEFINED__
#define __IVdsDisk_INTERFACE_DEFINED__

/* interface IVdsDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07e5c822-f00c-47a1-8fce-b244da56fd06")
    IVdsDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_DISK_PROP *pDiskProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentificationData( 
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConvertStyle( 
            /* [in] */ VDS_PARTITION_STYLE NewStyle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsDisk * This,
            /* [out] */ __RPC__out VDS_DISK_PROP *pDiskProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPack )( 
            IVdsDisk * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentificationData )( 
            IVdsDisk * This,
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            IVdsDisk * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ConvertStyle )( 
            IVdsDisk * This,
            /* [in] */ VDS_PARTITION_STYLE NewStyle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IVdsDisk * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            IVdsDisk * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsDiskVtbl;

    interface IVdsDisk
    {
        CONST_VTBL struct IVdsDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDisk_GetProperties(This,pDiskProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pDiskProperties) ) 

#define IVdsDisk_GetPack(This,ppPack)	\
    ( (This)->lpVtbl -> GetPack(This,ppPack) ) 

#define IVdsDisk_GetIdentificationData(This,pLunInfo)	\
    ( (This)->lpVtbl -> GetIdentificationData(This,pLunInfo) ) 

#define IVdsDisk_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsDisk_ConvertStyle(This,NewStyle)	\
    ( (This)->lpVtbl -> ConvertStyle(This,NewStyle) ) 

#define IVdsDisk_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsDisk_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsDisk2_INTERFACE_DEFINED__
#define __IVdsDisk2_INTERFACE_DEFINED__

/* interface IVdsDisk2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDisk2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40F73C8B-687D-4a13-8D96-3D7F2E683936")
    IVdsDisk2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSANMode( 
            /* [in] */ BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDisk2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsDisk2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsDisk2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsDisk2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSANMode )( 
            IVdsDisk2 * This,
            /* [in] */ BOOL bEnable);
        
        END_INTERFACE
    } IVdsDisk2Vtbl;

    interface IVdsDisk2
    {
        CONST_VTBL struct IVdsDisk2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDisk2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDisk2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDisk2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDisk2_SetSANMode(This,bEnable)	\
    ( (This)->lpVtbl -> SetSANMode(This,bEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDisk2_INTERFACE_DEFINED__ */


#ifndef __IVdsDiskOnline_INTERFACE_DEFINED__
#define __IVdsDiskOnline_INTERFACE_DEFINED__

/* interface IVdsDiskOnline */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDiskOnline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("90681B1D-6A7F-48e8-9061-31B7AA125322")
    IVdsDiskOnline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Online( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Offline( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskOnlineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsDiskOnline * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsDiskOnline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsDiskOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Online )( 
            IVdsDiskOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Offline )( 
            IVdsDiskOnline * This);
        
        END_INTERFACE
    } IVdsDiskOnlineVtbl;

    interface IVdsDiskOnline
    {
        CONST_VTBL struct IVdsDiskOnlineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDiskOnline_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDiskOnline_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDiskOnline_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDiskOnline_Online(This)	\
    ( (This)->lpVtbl -> Online(This) ) 

#define IVdsDiskOnline_Offline(This)	\
    ( (This)->lpVtbl -> Offline(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDiskOnline_INTERFACE_DEFINED__ */


#ifndef __IVdsAdvancedDisk_INTERFACE_DEFINED__
#define __IVdsAdvancedDisk_INTERFACE_DEFINED__

/* interface IVdsAdvancedDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdvancedDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e6f6b40-977c-4069-bddd-ac710059f8c0")
    IVdsAdvancedDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionProperties( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_PARTITION_PROP *pPartitionProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPartitions( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPartitions) VDS_PARTITION_PROP **ppPartitionPropArray,
            /* [out] */ __RPC__out LONG *plNumberOfPartitions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeletePartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceProtected) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangeAttributes( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ __RPC__in CHANGE_ATTRIBUTES_PARAMETERS *para) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssignDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out WCHAR *pwcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatPartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clean( 
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceOEM,
            /* [in] */ BOOL bFullClean,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdvancedDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsAdvancedDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsAdvancedDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsAdvancedDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionProperties )( 
            IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_PARTITION_PROP *pPartitionProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPartitions )( 
            IVdsAdvancedDisk * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPartitions) VDS_PARTITION_PROP **ppPartitionPropArray,
            /* [out] */ __RPC__out LONG *plNumberOfPartitions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePartition )( 
            IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeletePartition )( 
            IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceProtected);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ChangeAttributes )( 
            IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ __RPC__in CHANGE_ATTRIBUTES_PARAMETERS *para);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssignDriveLetter )( 
            IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteDriveLetter )( 
            IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDriveLetter )( 
            IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out WCHAR *pwcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatPartition )( 
            IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Clean )( 
            IVdsAdvancedDisk * This,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceOEM,
            /* [in] */ BOOL bFullClean,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsAdvancedDiskVtbl;

    interface IVdsAdvancedDisk
    {
        CONST_VTBL struct IVdsAdvancedDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdvancedDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdvancedDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdvancedDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdvancedDisk_GetPartitionProperties(This,ullOffset,pPartitionProp)	\
    ( (This)->lpVtbl -> GetPartitionProperties(This,ullOffset,pPartitionProp) ) 

#define IVdsAdvancedDisk_QueryPartitions(This,ppPartitionPropArray,plNumberOfPartitions)	\
    ( (This)->lpVtbl -> QueryPartitions(This,ppPartitionPropArray,plNumberOfPartitions) ) 

#define IVdsAdvancedDisk_CreatePartition(This,ullOffset,ullSize,para,ppAsync)	\
    ( (This)->lpVtbl -> CreatePartition(This,ullOffset,ullSize,para,ppAsync) ) 

#define IVdsAdvancedDisk_DeletePartition(This,ullOffset,bForce,bForceProtected)	\
    ( (This)->lpVtbl -> DeletePartition(This,ullOffset,bForce,bForceProtected) ) 

#define IVdsAdvancedDisk_ChangeAttributes(This,ullOffset,para)	\
    ( (This)->lpVtbl -> ChangeAttributes(This,ullOffset,para) ) 

#define IVdsAdvancedDisk_AssignDriveLetter(This,ullOffset,wcLetter)	\
    ( (This)->lpVtbl -> AssignDriveLetter(This,ullOffset,wcLetter) ) 

#define IVdsAdvancedDisk_DeleteDriveLetter(This,ullOffset,wcLetter)	\
    ( (This)->lpVtbl -> DeleteDriveLetter(This,ullOffset,wcLetter) ) 

#define IVdsAdvancedDisk_GetDriveLetter(This,ullOffset,pwcLetter)	\
    ( (This)->lpVtbl -> GetDriveLetter(This,ullOffset,pwcLetter) ) 

#define IVdsAdvancedDisk_FormatPartition(This,ullOffset,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatPartition(This,ullOffset,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#define IVdsAdvancedDisk_Clean(This,bForce,bForceOEM,bFullClean,ppAsync)	\
    ( (This)->lpVtbl -> Clean(This,bForce,bForceOEM,bFullClean,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdvancedDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsAdvancedDisk2_INTERFACE_DEFINED__
#define __IVdsAdvancedDisk2_INTERFACE_DEFINED__

/* interface IVdsAdvancedDisk2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdvancedDisk2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9723f420-9355-42de-ab66-e31bb15beeac")
    IVdsAdvancedDisk2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangePartitionType( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ __RPC__in CHANGE_PARTITION_TYPE_PARAMETERS *para) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdvancedDisk2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsAdvancedDisk2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsAdvancedDisk2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsAdvancedDisk2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ChangePartitionType )( 
            IVdsAdvancedDisk2 * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ __RPC__in CHANGE_PARTITION_TYPE_PARAMETERS *para);
        
        END_INTERFACE
    } IVdsAdvancedDisk2Vtbl;

    interface IVdsAdvancedDisk2
    {
        CONST_VTBL struct IVdsAdvancedDisk2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdvancedDisk2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdvancedDisk2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdvancedDisk2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdvancedDisk2_ChangePartitionType(This,ullOffset,bForce,para)	\
    ( (This)->lpVtbl -> ChangePartitionType(This,ullOffset,bForce,para) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdvancedDisk2_INTERFACE_DEFINED__ */


#ifndef __IVdsCreatePartitionEx_INTERFACE_DEFINED__
#define __IVdsCreatePartitionEx_INTERFACE_DEFINED__

/* interface IVdsCreatePartitionEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsCreatePartitionEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9882f547-cfc3-420b-9750-00dfbec50662")
    IVdsCreatePartitionEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePartitionEx( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ ULONG ulAlign,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsCreatePartitionExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsCreatePartitionEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsCreatePartitionEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsCreatePartitionEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePartitionEx )( 
            IVdsCreatePartitionEx * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ ULONG ulAlign,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsCreatePartitionExVtbl;

    interface IVdsCreatePartitionEx
    {
        CONST_VTBL struct IVdsCreatePartitionExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsCreatePartitionEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsCreatePartitionEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsCreatePartitionEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsCreatePartitionEx_CreatePartitionEx(This,ullOffset,ullSize,ulAlign,para,ppAsync)	\
    ( (This)->lpVtbl -> CreatePartitionEx(This,ullOffset,ullSize,ulAlign,para,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsCreatePartitionEx_INTERFACE_DEFINED__ */


#ifndef __IVdsRemovable_INTERFACE_DEFINED__
#define __IVdsRemovable_INTERFACE_DEFINED__

/* interface IVdsRemovable */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsRemovable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0316560b-5db4-4ed9-bbb5-213436ddc0d9")
    IVdsRemovable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMedia( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Eject( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsRemovableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsRemovable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsRemovable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsRemovable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMedia )( 
            IVdsRemovable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Eject )( 
            IVdsRemovable * This);
        
        END_INTERFACE
    } IVdsRemovableVtbl;

    interface IVdsRemovable
    {
        CONST_VTBL struct IVdsRemovableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsRemovable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsRemovable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsRemovable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsRemovable_QueryMedia(This)	\
    ( (This)->lpVtbl -> QueryMedia(This) ) 

#define IVdsRemovable_Eject(This)	\
    ( (This)->lpVtbl -> Eject(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsRemovable_INTERFACE_DEFINED__ */


#ifndef __IVdsVolume_INTERFACE_DEFINED__
#define __IVdsVolume_INTERFACE_DEFINED__

/* interface IVdsVolume */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88306bb2-e71f-478c-86a2-79da200a0f11")
    IVdsVolume : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_VOLUME_PROP *pVolumeProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPlexes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Extend( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPlex( 
            /* [in] */ VDS_OBJECT_ID VolumeId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BreakPlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BOOL bForce) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ BOOL bRevertOnClose) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsVolume * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsVolume * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsVolume * This,
            /* [out] */ __RPC__out VDS_VOLUME_PROP *pVolumeProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPack )( 
            IVdsVolume * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPlexes )( 
            IVdsVolume * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Extend )( 
            IVdsVolume * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            IVdsVolume * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPlex )( 
            IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID VolumeId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BreakPlex )( 
            IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePlex )( 
            IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IVdsVolume * This,
            /* [in] */ BOOL bForce);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IVdsVolume * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ BOOL bRevertOnClose);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            IVdsVolume * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsVolumeVtbl;

    interface IVdsVolume
    {
        CONST_VTBL struct IVdsVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolume_GetProperties(This,pVolumeProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pVolumeProperties) ) 

#define IVdsVolume_GetPack(This,ppPack)	\
    ( (This)->lpVtbl -> GetPack(This,ppPack) ) 

#define IVdsVolume_QueryPlexes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPlexes(This,ppEnum) ) 

#define IVdsVolume_Extend(This,pInputDiskArray,lNumberOfDisks,ppAsync)	\
    ( (This)->lpVtbl -> Extend(This,pInputDiskArray,lNumberOfDisks,ppAsync) ) 

#define IVdsVolume_Shrink(This,ullNumberOfBytesToRemove,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullNumberOfBytesToRemove,ppAsync) ) 

#define IVdsVolume_AddPlex(This,VolumeId,ppAsync)	\
    ( (This)->lpVtbl -> AddPlex(This,VolumeId,ppAsync) ) 

#define IVdsVolume_BreakPlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> BreakPlex(This,plexId,ppAsync) ) 

#define IVdsVolume_RemovePlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePlex(This,plexId,ppAsync) ) 

#define IVdsVolume_Delete(This,bForce)	\
    ( (This)->lpVtbl -> Delete(This,bForce) ) 

#define IVdsVolume_SetFlags(This,ulFlags,bRevertOnClose)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags,bRevertOnClose) ) 

#define IVdsVolume_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolume_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeOnline_INTERFACE_DEFINED__
#define __IVdsVolumeOnline_INTERFACE_DEFINED__

/* interface IVdsVolumeOnline */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeOnline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BE2275A-B315-4f70-9E44-879B3A2A53F2")
    IVdsVolumeOnline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Online( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeOnlineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsVolumeOnline * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsVolumeOnline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsVolumeOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Online )( 
            IVdsVolumeOnline * This);
        
        END_INTERFACE
    } IVdsVolumeOnlineVtbl;

    interface IVdsVolumeOnline
    {
        CONST_VTBL struct IVdsVolumeOnlineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeOnline_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeOnline_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeOnline_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeOnline_Online(This)	\
    ( (This)->lpVtbl -> Online(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeOnline_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumePlex_INTERFACE_DEFINED__
#define __IVdsVolumePlex_INTERFACE_DEFINED__

/* interface IVdsVolumePlex */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumePlex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4daa0135-e1d1-40f1-aaa5-3cc1e53221c3")
    IVdsVolumePlex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_VOLUME_PLEX_PROP *pPlexProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolume( 
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Repair( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumePlexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsVolumePlex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsVolumePlex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsVolumePlex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsVolumePlex * This,
            /* [out] */ __RPC__out VDS_VOLUME_PLEX_PROP *pPlexProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolume )( 
            IVdsVolumePlex * This,
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            IVdsVolumePlex * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Repair )( 
            IVdsVolumePlex * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumePlexVtbl;

    interface IVdsVolumePlex
    {
        CONST_VTBL struct IVdsVolumePlexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumePlex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumePlex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumePlex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumePlex_GetProperties(This,pPlexProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pPlexProperties) ) 

#define IVdsVolumePlex_GetVolume(This,ppVolume)	\
    ( (This)->lpVtbl -> GetVolume(This,ppVolume) ) 

#define IVdsVolumePlex_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsVolumePlex_Repair(This,pInputDiskArray,lNumberOfDisks,ppAsync)	\
    ( (This)->lpVtbl -> Repair(This,pInputDiskArray,lNumberOfDisks,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumePlex_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0018 */
/* [local] */ 



















typedef 
enum _VDS_SUB_SYSTEM_STATUS
    {	VDS_SSS_UNKNOWN	= 0,
	VDS_SSS_ONLINE	= 1,
	VDS_SSS_NOT_READY	= 2,
	VDS_SSS_OFFLINE	= 4,
	VDS_SSS_FAILED	= 5
    } 	VDS_SUB_SYSTEM_STATUS;

typedef 
enum _VDS_SUB_SYSTEM_FLAG
    {	VDS_SF_LUN_MASKING_CAPABLE	= 0x1,
	VDS_SF_LUN_PLEXING_CAPABLE	= 0x2,
	VDS_SF_LUN_REMAPPING_CAPABLE	= 0x4,
	VDS_SF_DRIVE_EXTENT_CAPABLE	= 0x8,
	VDS_SF_HARDWARE_CHECKSUM_CAPABLE	= 0x10,
	VDS_SF_RADIUS_CAPABLE	= 0x20,
	VDS_SF_READ_BACK_VERIFY_CAPABLE	= 0x40,
	VDS_SF_WRITE_THROUGH_CACHING_CAPABLE	= 0x80,
	VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS	= 0x200,
	VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS	= 0x400,
	VDS_SF_SUPPORTS_SIMPLE_LUNS	= 0x800,
	VDS_SF_SUPPORTS_SPAN_LUNS	= 0x1000,
	VDS_SF_SUPPORTS_STRIPE_LUNS	= 0x2000,
	VDS_SF_SUPPORTS_MIRROR_LUNS	= 0x4000,
	VDS_SF_SUPPORTS_PARITY_LUNS	= 0x8000,
	VDS_SF_SUPPORTS_AUTH_CHAP	= 0x10000,
	VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP	= 0x20000,
	VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG	= 0x40000
    } 	VDS_SUB_SYSTEM_FLAG;

typedef 
enum _VDS_CONTROLLER_STATUS
    {	VDS_CS_UNKNOWN	= 0,
	VDS_CS_ONLINE	= 1,
	VDS_CS_NOT_READY	= 2,
	VDS_CS_OFFLINE	= 4,
	VDS_CS_FAILED	= 5
    } 	VDS_CONTROLLER_STATUS;

typedef 
enum _VDS_PORT_STATUS
    {	VDS_PRS_UNKNOWN	= 0,
	VDS_PRS_ONLINE	= 1,
	VDS_PRS_NOT_READY	= 2,
	VDS_PRS_OFFLINE	= 4,
	VDS_PRS_FAILED	= 5
    } 	VDS_PORT_STATUS;

typedef 
enum _VDS_DRIVE_STATUS
    {	VDS_DRS_UNKNOWN	= 0,
	VDS_DRS_ONLINE	= 1,
	VDS_DRS_NOT_READY	= 2,
	VDS_DRS_OFFLINE	= 4,
	VDS_DRS_FAILED	= 5
    } 	VDS_DRIVE_STATUS;

typedef 
enum _VDS_DRIVE_FLAG
    {	VDS_DRF_HOTSPARE	= 0x1
    } 	VDS_DRIVE_FLAG;

typedef 
enum _VDS_LUN_TYPE
    {	VDS_LT_UNKNOWN	= 0,
	VDS_LT_DEFAULT	= 1,
	VDS_LT_FAULT_TOLERANT	= 2,
	VDS_LT_NON_FAULT_TOLERANT	= 3,
	VDS_LT_SIMPLE	= 10,
	VDS_LT_SPAN	= 11,
	VDS_LT_STRIPE	= 12,
	VDS_LT_MIRROR	= 13,
	VDS_LT_PARITY	= 14
    } 	VDS_LUN_TYPE;

typedef 
enum _VDS_LUN_STATUS
    {	VDS_LS_UNKNOWN	= 0,
	VDS_LS_ONLINE	= 1,
	VDS_LS_NOT_READY	= 2,
	VDS_LS_OFFLINE	= 4,
	VDS_LS_FAILED	= 5
    } 	VDS_LUN_STATUS;

typedef 
enum _VDS_LUN_FLAG
    {	VDS_LF_LBN_REMAP_ENABLED	= 0x1,
	VDS_LF_READ_BACK_VERIFY_ENABLED	= 0x2,
	VDS_LF_WRITE_THROUGH_CACHING_ENABLED	= 0x4,
	VDS_LF_HARDWARE_CHECKSUM_ENABLED	= 0x8
    } 	VDS_LUN_FLAG;

typedef 
enum _VDS_LUN_PLEX_TYPE
    {	VDS_LPT_UNKNOWN	= 0,
	VDS_LPT_SIMPLE	= VDS_LT_SIMPLE,
	VDS_LPT_SPAN	= VDS_LT_SPAN,
	VDS_LPT_STRIPE	= VDS_LT_STRIPE,
	VDS_LPT_PARITY	= VDS_LT_PARITY
    } 	VDS_LUN_PLEX_TYPE;

typedef 
enum _VDS_LUN_PLEX_STATUS
    {	VDS_LPS_UNKNOWN	= 0,
	VDS_LPS_ONLINE	= 1,
	VDS_LPS_NOT_READY	= 2,
	VDS_LPS_OFFLINE	= 4,
	VDS_LPS_FAILED	= 5
    } 	VDS_LUN_PLEX_STATUS;

typedef 
enum _VDS_LUN_PLEX_FLAG
    {	VDS_LPF_LBN_REMAP_ENABLED	= VDS_LF_LBN_REMAP_ENABLED
    } 	VDS_LUN_PLEX_FLAG;

typedef 
enum _VDS_ISCSI_PORTAL_STATUS
    {	VDS_IPS_UNKNOWN	= 0,
	VDS_IPS_ONLINE	= 1,
	VDS_IPS_NOT_READY	= 2,
	VDS_IPS_OFFLINE	= 4,
	VDS_IPS_FAILED	= 5
    } 	VDS_ISCSI_PORTAL_STATUS;

typedef 
enum _VDS_MAINTENANCE_OPERATION
    {	BlinkLight	= 1,
	BeepAlarm	= 2,
	SpinDown	= 3,
	SpinUp	= 4,
	Ping	= 5
    } 	VDS_MAINTENANCE_OPERATION;

typedef struct _VDS_HINTS
    {
    ULONGLONG ullHintMask;
    ULONGLONG ullExpectedMaximumSize;
    ULONG ulOptimalReadSize;
    ULONG ulOptimalReadAlignment;
    ULONG ulOptimalWriteSize;
    ULONG ulOptimalWriteAlignment;
    ULONG ulMaximumDriveCount;
    ULONG ulStripeSize;
    BOOL bFastCrashRecoveryRequired;
    BOOL bMostlyReads;
    BOOL bOptimizeForSequentialReads;
    BOOL bOptimizeForSequentialWrites;
    BOOL bRemapEnabled;
    BOOL bReadBackVerifyEnabled;
    BOOL bWriteThroughCachingEnabled;
    BOOL bHardwareChecksumEnabled;
    BOOL bIsYankable;
    SHORT sRebuildPriority;
    } 	VDS_HINTS;

typedef struct _VDS_HINTS *PVDS_HINTS;

#define	VDS_HINT_FASTCRASHRECOVERYREQUIRED	( 0x1L )

#define	VDS_HINT_MOSTLYREADS	( 0x2L )

#define	VDS_HINT_OPTIMIZEFORSEQUENTIALREADS	( 0x4L )

#define	VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES	( 0x8L )

#define	VDS_HINT_READBACKVERIFYENABLED	( 0x10L )

#define	VDS_HINT_REMAPENABLED	( 0x20L )

#define	VDS_HINT_WRITETHROUGHCACHINGENABLED	( 0x40L )

#define	VDS_HINT_HARDWARECHECKSUMENABLED	( 0x80L )

#define	VDS_HINT_ISYANKABLE	( 0x100L )

typedef struct _VDS_SUB_SYSTEM_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    VDS_SUB_SYSTEM_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfInternalBuses;
    SHORT sMaxNumberOfSlotsEachBus;
    SHORT sMaxNumberOfControllers;
    SHORT sRebuildPriority;
    } 	VDS_SUB_SYSTEM_PROP;

typedef struct _VDS_CONTROLLER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    VDS_CONTROLLER_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfPorts;
    } 	VDS_CONTROLLER_PROP;

typedef struct _VDS_DRIVE_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    VDS_DRIVE_STATUS status;
    VDS_HEALTH health;
    SHORT sInternalBusNumber;
    SHORT sSlotNumber;
    } 	VDS_DRIVE_PROP;

typedef struct _VDS_DRIVE_EXTENT
    {
    VDS_OBJECT_ID id;
    VDS_OBJECT_ID LunId;
    ULONGLONG ullSize;
    BOOL bUsed;
    } 	VDS_DRIVE_EXTENT;

#define VDS_REBUILD_PRIORITY_MIN        0
#define VDS_REBUILD_PRIORITY_MAX        16
typedef struct _VDS_LUN_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    LPWSTR pwszUnmaskingList;
    ULONG ulFlags;
    VDS_LUN_TYPE type;
    VDS_LUN_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    SHORT sRebuildPriority;
    } 	VDS_LUN_PROP;

typedef struct _VDS_LUN_PROP *PVDS_LUN_PROP;

typedef struct _VDS_LUN_PLEX_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    VDS_LUN_PLEX_TYPE type;
    VDS_LUN_PLEX_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONG ulFlags;
    ULONG ulStripeSize;
    SHORT sRebuildPriority;
    } 	VDS_LUN_PLEX_PROP;

typedef struct _VDS_PORT_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    VDS_PORT_STATUS status;
    } 	VDS_PORT_PROP;

typedef struct _VDS_ISCSI_PORTAL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    VDS_ISCSI_PORTAL_STATUS status;
    } 	VDS_ISCSI_PORTAL_PROP;

typedef struct _VDS_ISCSI_TARGET_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszIscsiName;
    LPWSTR pwszFriendlyName;
    BOOL bChapEnabled;
    } 	VDS_ISCSI_TARGET_PROP;

typedef struct _VDS_ISCSI_PORTALGROUP_PROP
    {
    VDS_OBJECT_ID id;
    VDS_ISCSI_PORTALGROUP_TAG tag;
    } 	VDS_ISCSI_PORTALGROUP_PROP;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0018_v0_0_s_ifspec;

#ifndef __IVdsHwProvider_INTERFACE_DEFINED__
#define __IVdsHwProvider_INTERFACE_DEFINED__

/* interface IVdsHwProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d99bdaae-b13a-4178-9fdb-e27f16b4603e")
    IVdsHwProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QuerySubSystems( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsHwProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsHwProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsHwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QuerySubSystems )( 
            IVdsHwProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            IVdsHwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IVdsHwProvider * This);
        
        END_INTERFACE
    } IVdsHwProviderVtbl;

    interface IVdsHwProvider
    {
        CONST_VTBL struct IVdsHwProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProvider_QuerySubSystems(This,ppEnum)	\
    ( (This)->lpVtbl -> QuerySubSystems(This,ppEnum) ) 

#define IVdsHwProvider_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsHwProvider_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderType_INTERFACE_DEFINED__
#define __IVdsHwProviderType_INTERFACE_DEFINED__

/* interface IVdsHwProviderType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3e0f5166-542d-4fc6-947a-012174240b7e")
    IVdsHwProviderType : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderType( 
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsHwProviderType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsHwProviderType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsHwProviderType * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderType )( 
            IVdsHwProviderType * This,
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType);
        
        END_INTERFACE
    } IVdsHwProviderTypeVtbl;

    interface IVdsHwProviderType
    {
        CONST_VTBL struct IVdsHwProviderTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderType_GetProviderType(This,pType)	\
    ( (This)->lpVtbl -> GetProviderType(This,pType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderType_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystem_INTERFACE_DEFINED__
#define __IVdsSubSystem_INTERFACE_DEFINED__

/* interface IVdsSubSystem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6fcee2d3-6d90-4f91-80e2-a5c7caaca9d8")
    IVdsSubSystem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP *pSubSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryControllers( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDrives( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDrive( 
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControllerStatus( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOnlineControllers) VDS_OBJECT_ID *pOnlineControllerIdArray,
            /* [in] */ LONG lNumberOfOnlineControllers,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOfflineControllers) VDS_OBJECT_ID *pOfflineControllerIdArray,
            /* [in] */ LONG lNumberOfOfflineControllers) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLun( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReplaceDrive( 
            /* [in] */ VDS_OBJECT_ID DriveToBeReplaced,
            /* [in] */ VDS_OBJECT_ID ReplacementDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_SUB_SYSTEM_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSize( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsSubSystem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsSubSystem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsSubSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsSubSystem * This,
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP *pSubSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryControllers )( 
            IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryLuns )( 
            IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDrives )( 
            IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDrive )( 
            IVdsSubSystem * This,
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            IVdsSubSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetControllerStatus )( 
            IVdsSubSystem * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOnlineControllers) VDS_OBJECT_ID *pOnlineControllerIdArray,
            /* [in] */ LONG lNumberOfOnlineControllers,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOfflineControllers) VDS_OBJECT_ID *pOfflineControllerIdArray,
            /* [in] */ LONG lNumberOfOfflineControllers);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLun )( 
            IVdsSubSystem * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReplaceDrive )( 
            IVdsSubSystem * This,
            /* [in] */ VDS_OBJECT_ID DriveToBeReplaced,
            /* [in] */ VDS_OBJECT_ID ReplacementDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IVdsSubSystem * This,
            /* [in] */ VDS_SUB_SYSTEM_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSize )( 
            IVdsSubSystem * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsSubSystemVtbl;

    interface IVdsSubSystem
    {
        CONST_VTBL struct IVdsSubSystemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystem_GetProperties(This,pSubSystemProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pSubSystemProp) ) 

#define IVdsSubSystem_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsSubSystem_QueryControllers(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryControllers(This,ppEnum) ) 

#define IVdsSubSystem_QueryLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryLuns(This,ppEnum) ) 

#define IVdsSubSystem_QueryDrives(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryDrives(This,ppEnum) ) 

#define IVdsSubSystem_GetDrive(This,sBusNumber,sSlotNumber,ppDrive)	\
    ( (This)->lpVtbl -> GetDrive(This,sBusNumber,sSlotNumber,ppDrive) ) 

#define IVdsSubSystem_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsSubSystem_SetControllerStatus(This,pOnlineControllerIdArray,lNumberOfOnlineControllers,pOfflineControllerIdArray,lNumberOfOfflineControllers)	\
    ( (This)->lpVtbl -> SetControllerStatus(This,pOnlineControllerIdArray,lNumberOfOnlineControllers,pOfflineControllerIdArray,lNumberOfOfflineControllers) ) 

#define IVdsSubSystem_CreateLun(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints,ppAsync)	\
    ( (This)->lpVtbl -> CreateLun(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints,ppAsync) ) 

#define IVdsSubSystem_ReplaceDrive(This,DriveToBeReplaced,ReplacementDrive)	\
    ( (This)->lpVtbl -> ReplaceDrive(This,DriveToBeReplaced,ReplacementDrive) ) 

#define IVdsSubSystem_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsSubSystem_QueryMaxLunCreateSize(This,type,pDriveIdArray,lNumberOfDrives,pHints,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSize(This,type,pDriveIdArray,lNumberOfDrives,pHints,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystem_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemNaming_INTERFACE_DEFINED__
#define __IVdsSubSystemNaming_INTERFACE_DEFINED__

/* interface IVdsSubSystemNaming */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemNaming;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d70faa3-9cd4-4900-aa20-6981b6aafc75")
    IVdsSubSystemNaming : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in LPWSTR pwszFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemNamingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsSubSystemNaming * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsSubSystemNaming * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsSubSystemNaming * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            IVdsSubSystemNaming * This,
            /* [string][in] */ __RPC__in LPWSTR pwszFriendlyName);
        
        END_INTERFACE
    } IVdsSubSystemNamingVtbl;

    interface IVdsSubSystemNaming
    {
        CONST_VTBL struct IVdsSubSystemNamingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemNaming_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemNaming_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemNaming_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemNaming_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemNaming_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemIscsi_INTERFACE_DEFINED__
#define __IVdsSubSystemIscsi_INTERFACE_DEFINED__

/* interface IVdsSubSystemIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0027346f-40d0-4b45-8cec-5906dc0380c8")
    IVdsSubSystemIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryTargets( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateTarget( 
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszIscsiName,
            /* [string][in] */ __RPC__in LPWSTR pwszFriendlyName,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecGroupPresharedKey( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsSubSystemIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsSubSystemIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsSubSystemIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryTargets )( 
            IVdsSubSystemIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPortals )( 
            IVdsSubSystemIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateTarget )( 
            IVdsSubSystemIscsi * This,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszIscsiName,
            /* [string][in] */ __RPC__in LPWSTR pwszFriendlyName,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecGroupPresharedKey )( 
            IVdsSubSystemIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsSubSystemIscsiVtbl;

    interface IVdsSubSystemIscsi
    {
        CONST_VTBL struct IVdsSubSystemIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemIscsi_QueryTargets(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryTargets(This,ppEnum) ) 

#define IVdsSubSystemIscsi_QueryPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPortals(This,ppEnum) ) 

#define IVdsSubSystemIscsi_CreateTarget(This,pwszIscsiName,pwszFriendlyName,ppAsync)	\
    ( (This)->lpVtbl -> CreateTarget(This,pwszIscsiName,pwszFriendlyName,ppAsync) ) 

#define IVdsSubSystemIscsi_SetIpsecGroupPresharedKey(This,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecGroupPresharedKey(This,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsControllerPort_INTERFACE_DEFINED__
#define __IVdsControllerPort_INTERFACE_DEFINED__

/* interface IVdsControllerPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsControllerPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18691d0d-4e7f-43e8-92e4-cf44beeed11c")
    IVdsControllerPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetController( 
            /* [out] */ __RPC__deref_out_opt IVdsController **ppController) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_PORT_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsControllerPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsControllerPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsControllerPort * This,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetController )( 
            IVdsControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IVdsController **ppController);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            IVdsControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IVdsControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IVdsControllerPort * This,
            /* [in] */ VDS_PORT_STATUS status);
        
        END_INTERFACE
    } IVdsControllerPortVtbl;

    interface IVdsControllerPort
    {
        CONST_VTBL struct IVdsControllerPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsControllerPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsControllerPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsControllerPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsControllerPort_GetProperties(This,pPortProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortProp) ) 

#define IVdsControllerPort_GetController(This,ppController)	\
    ( (This)->lpVtbl -> GetController(This,ppController) ) 

#define IVdsControllerPort_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsControllerPort_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVdsControllerPort_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsControllerPort_INTERFACE_DEFINED__ */


#ifndef __IVdsController_INTERFACE_DEFINED__
#define __IVdsController_INTERFACE_DEFINED__

/* interface IVdsController */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb53d96e-dffb-474a-a078-790d1e2bc082")
    IVdsController : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_CONTROLLER_PROP *pControllerProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPortProperties( 
            /* [in] */ SHORT sPortNumber,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvalidateCache( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_CONTROLLER_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsController * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsController * This,
            /* [out] */ __RPC__out VDS_CONTROLLER_PROP *pControllerProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            IVdsController * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPortProperties )( 
            IVdsController * This,
            /* [in] */ SHORT sPortNumber,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvalidateCache )( 
            IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            IVdsController * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IVdsController * This,
            /* [in] */ VDS_CONTROLLER_STATUS status);
        
        END_INTERFACE
    } IVdsControllerVtbl;

    interface IVdsController
    {
        CONST_VTBL struct IVdsControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsController_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsController_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsController_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsController_GetProperties(This,pControllerProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pControllerProp) ) 

#define IVdsController_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsController_GetPortProperties(This,sPortNumber,pPortProp)	\
    ( (This)->lpVtbl -> GetPortProperties(This,sPortNumber,pPortProp) ) 

#define IVdsController_FlushCache(This)	\
    ( (This)->lpVtbl -> FlushCache(This) ) 

#define IVdsController_InvalidateCache(This)	\
    ( (This)->lpVtbl -> InvalidateCache(This) ) 

#define IVdsController_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVdsController_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsController_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsController_INTERFACE_DEFINED__ */


#ifndef __IVdsControllerControllerPort_INTERFACE_DEFINED__
#define __IVdsControllerControllerPort_INTERFACE_DEFINED__

/* interface IVdsControllerControllerPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsControllerControllerPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca5d735f-6bae-42c0-b30e-f2666045ce71")
    IVdsControllerControllerPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryControllerPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerControllerPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsControllerControllerPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsControllerControllerPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsControllerControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryControllerPorts )( 
            IVdsControllerControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsControllerControllerPortVtbl;

    interface IVdsControllerControllerPort
    {
        CONST_VTBL struct IVdsControllerControllerPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsControllerControllerPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsControllerControllerPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsControllerControllerPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsControllerControllerPort_QueryControllerPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryControllerPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsControllerControllerPort_INTERFACE_DEFINED__ */


#ifndef __IVdsDrive_INTERFACE_DEFINED__
#define __IVdsDrive_INTERFACE_DEFINED__

/* interface IVdsDrive */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDrive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff24efa4-aade-4b6b-898b-eaa6a20887c7")
    IVdsDrive : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_DRIVE_PROP *pDriveProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_DRIVE_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDriveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsDrive * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsDrive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsDrive * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsDrive * This,
            /* [out] */ __RPC__out VDS_DRIVE_PROP *pDriveProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            IVdsDrive * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            IVdsDrive * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IVdsDrive * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            IVdsDrive * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IVdsDrive * This,
            /* [in] */ VDS_DRIVE_STATUS status);
        
        END_INTERFACE
    } IVdsDriveVtbl;

    interface IVdsDrive
    {
        CONST_VTBL struct IVdsDriveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDrive_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDrive_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDrive_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDrive_GetProperties(This,pDriveProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pDriveProp) ) 

#define IVdsDrive_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsDrive_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsDrive_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsDrive_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#define IVdsDrive_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDrive_INTERFACE_DEFINED__ */


#ifndef __IVdsLun_INTERFACE_DEFINED__
#define __IVdsLun_INTERFACE_DEFINED__

/* interface IVdsLun */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLun;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3540a9c7-e60f-4111-a840-8bba6c2c83d8")
    IVdsLun : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_LUN_PROP *pLunProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentificationData( 
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryActiveControllers( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Extend( 
            /* [in] */ ULONGLONG ullNumberOfBytesToAdd,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPlexes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPlex( 
            /* [in] */ VDS_OBJECT_ID lunId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recover( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMask( 
            /* [string][in] */ __RPC__in LPWSTR pwszUnmaskingList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateControllers( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllers) VDS_OBJECT_ID *pActiveControllerIdArray,
            /* [in] */ LONG lNumberOfActiveControllers,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllers) VDS_OBJECT_ID *pInactiveControllerIdArray,
            /* [in] */ LONG lNumberOfInactiveControllers) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints( 
            /* [out] */ __RPC__out VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints( 
            /* [in] */ __RPC__in VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_LUN_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunExtendSize( 
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__out ULONGLONG *pullMaxBytesToBeAdded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsLun * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsLun * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsLun * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsLun * This,
            /* [out] */ __RPC__out VDS_LUN_PROP *pLunProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentificationData )( 
            IVdsLun * This,
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryActiveControllers )( 
            IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Extend )( 
            IVdsLun * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToAdd,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            IVdsLun * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPlexes )( 
            IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPlex )( 
            IVdsLun * This,
            /* [in] */ VDS_OBJECT_ID lunId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePlex )( 
            IVdsLun * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Recover )( 
            IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMask )( 
            IVdsLun * This,
            /* [string][in] */ __RPC__in LPWSTR pwszUnmaskingList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IVdsLun * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateControllers )( 
            IVdsLun * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllers) VDS_OBJECT_ID *pActiveControllerIdArray,
            /* [in] */ LONG lNumberOfActiveControllers,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllers) VDS_OBJECT_ID *pInactiveControllerIdArray,
            /* [in] */ LONG lNumberOfInactiveControllers);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints )( 
            IVdsLun * This,
            /* [out] */ __RPC__out VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints )( 
            IVdsLun * This,
            /* [in] */ __RPC__in VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IVdsLun * This,
            /* [in] */ VDS_LUN_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunExtendSize )( 
            IVdsLun * This,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__out ULONGLONG *pullMaxBytesToBeAdded);
        
        END_INTERFACE
    } IVdsLunVtbl;

    interface IVdsLun
    {
        CONST_VTBL struct IVdsLunVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLun_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLun_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLun_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLun_GetProperties(This,pLunProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pLunProp) ) 

#define IVdsLun_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsLun_GetIdentificationData(This,pLunInfo)	\
    ( (This)->lpVtbl -> GetIdentificationData(This,pLunInfo) ) 

#define IVdsLun_QueryActiveControllers(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryActiveControllers(This,ppEnum) ) 

#define IVdsLun_Extend(This,ullNumberOfBytesToAdd,pDriveIdArray,lNumberOfDrives,ppAsync)	\
    ( (This)->lpVtbl -> Extend(This,ullNumberOfBytesToAdd,pDriveIdArray,lNumberOfDrives,ppAsync) ) 

#define IVdsLun_Shrink(This,ullNumberOfBytesToRemove,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullNumberOfBytesToRemove,ppAsync) ) 

#define IVdsLun_QueryPlexes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPlexes(This,ppEnum) ) 

#define IVdsLun_AddPlex(This,lunId,ppAsync)	\
    ( (This)->lpVtbl -> AddPlex(This,lunId,ppAsync) ) 

#define IVdsLun_RemovePlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePlex(This,plexId,ppAsync) ) 

#define IVdsLun_Recover(This,ppAsync)	\
    ( (This)->lpVtbl -> Recover(This,ppAsync) ) 

#define IVdsLun_SetMask(This,pwszUnmaskingList)	\
    ( (This)->lpVtbl -> SetMask(This,pwszUnmaskingList) ) 

#define IVdsLun_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#define IVdsLun_AssociateControllers(This,pActiveControllerIdArray,lNumberOfActiveControllers,pInactiveControllerIdArray,lNumberOfInactiveControllers)	\
    ( (This)->lpVtbl -> AssociateControllers(This,pActiveControllerIdArray,lNumberOfActiveControllers,pInactiveControllerIdArray,lNumberOfInactiveControllers) ) 

#define IVdsLun_QueryHints(This,pHints)	\
    ( (This)->lpVtbl -> QueryHints(This,pHints) ) 

#define IVdsLun_ApplyHints(This,pHints)	\
    ( (This)->lpVtbl -> ApplyHints(This,pHints) ) 

#define IVdsLun_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsLun_QueryMaxLunExtendSize(This,pDriveIdArray,lNumberOfDrives,pullMaxBytesToBeAdded)	\
    ( (This)->lpVtbl -> QueryMaxLunExtendSize(This,pDriveIdArray,lNumberOfDrives,pullMaxBytesToBeAdded) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLun_INTERFACE_DEFINED__ */


#ifndef __IVdsLunNaming_INTERFACE_DEFINED__
#define __IVdsLunNaming_INTERFACE_DEFINED__

/* interface IVdsLunNaming */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunNaming;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("907504cb-6b4e-4d88-a34d-17ba661fbb06")
    IVdsLunNaming : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in LPWSTR pwszFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunNamingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsLunNaming * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsLunNaming * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsLunNaming * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            IVdsLunNaming * This,
            /* [string][in] */ __RPC__in LPWSTR pwszFriendlyName);
        
        END_INTERFACE
    } IVdsLunNamingVtbl;

    interface IVdsLunNaming
    {
        CONST_VTBL struct IVdsLunNamingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunNaming_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunNaming_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunNaming_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunNaming_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunNaming_INTERFACE_DEFINED__ */


#ifndef __IVdsLunControllerPorts_INTERFACE_DEFINED__
#define __IVdsLunControllerPorts_INTERFACE_DEFINED__

/* interface IVdsLunControllerPorts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunControllerPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("451fe266-da6d-406a-bb60-82e534f85aeb")
    IVdsLunControllerPorts : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateControllerPorts( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllerPorts) VDS_OBJECT_ID *pActiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfActiveControllerPorts,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllerPorts) VDS_OBJECT_ID *pInactiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfInactiveControllerPorts) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryActiveControllerPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunControllerPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsLunControllerPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsLunControllerPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsLunControllerPorts * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateControllerPorts )( 
            IVdsLunControllerPorts * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllerPorts) VDS_OBJECT_ID *pActiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfActiveControllerPorts,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllerPorts) VDS_OBJECT_ID *pInactiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfInactiveControllerPorts);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryActiveControllerPorts )( 
            IVdsLunControllerPorts * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsLunControllerPortsVtbl;

    interface IVdsLunControllerPorts
    {
        CONST_VTBL struct IVdsLunControllerPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunControllerPorts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunControllerPorts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunControllerPorts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunControllerPorts_AssociateControllerPorts(This,pActiveControllerPortIdArray,lNumberOfActiveControllerPorts,pInactiveControllerPortIdArray,lNumberOfInactiveControllerPorts)	\
    ( (This)->lpVtbl -> AssociateControllerPorts(This,pActiveControllerPortIdArray,lNumberOfActiveControllerPorts,pInactiveControllerPortIdArray,lNumberOfInactiveControllerPorts) ) 

#define IVdsLunControllerPorts_QueryActiveControllerPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryActiveControllerPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunControllerPorts_INTERFACE_DEFINED__ */


#ifndef __IVdsLunMpio_INTERFACE_DEFINED__
#define __IVdsLunMpio_INTERFACE_DEFINED__

/* interface IVdsLunMpio */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunMpio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c5fbae3-333a-48a1-a982-33c15788cde3")
    IVdsLunMpio : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_INFO **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLoadBalancePolicy( 
            /* [out] */ __RPC__out VDS_LOADBALANCE_POLICY_ENUM *pPolicy,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_POLICY **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLoadBalancePolicy( 
            /* [in] */ VDS_LOADBALANCE_POLICY_ENUM policy,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfPaths) VDS_PATH_POLICY *pPaths,
            /* [in] */ LONG lNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSupportedLbPolicies( 
            /* [out] */ __RPC__out ULONG *pulLbFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunMpioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsLunMpio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsLunMpio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsLunMpio * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPathInfo )( 
            IVdsLunMpio * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_INFO **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLoadBalancePolicy )( 
            IVdsLunMpio * This,
            /* [out] */ __RPC__out VDS_LOADBALANCE_POLICY_ENUM *pPolicy,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_POLICY **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLoadBalancePolicy )( 
            IVdsLunMpio * This,
            /* [in] */ VDS_LOADBALANCE_POLICY_ENUM policy,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfPaths) VDS_PATH_POLICY *pPaths,
            /* [in] */ LONG lNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSupportedLbPolicies )( 
            IVdsLunMpio * This,
            /* [out] */ __RPC__out ULONG *pulLbFlags);
        
        END_INTERFACE
    } IVdsLunMpioVtbl;

    interface IVdsLunMpio
    {
        CONST_VTBL struct IVdsLunMpioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunMpio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunMpio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunMpio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunMpio_GetPathInfo(This,ppPaths,plNumberOfPaths)	\
    ( (This)->lpVtbl -> GetPathInfo(This,ppPaths,plNumberOfPaths) ) 

#define IVdsLunMpio_GetLoadBalancePolicy(This,pPolicy,ppPaths,plNumberOfPaths)	\
    ( (This)->lpVtbl -> GetLoadBalancePolicy(This,pPolicy,ppPaths,plNumberOfPaths) ) 

#define IVdsLunMpio_SetLoadBalancePolicy(This,policy,pPaths,lNumberOfPaths)	\
    ( (This)->lpVtbl -> SetLoadBalancePolicy(This,policy,pPaths,lNumberOfPaths) ) 

#define IVdsLunMpio_GetSupportedLbPolicies(This,pulLbFlags)	\
    ( (This)->lpVtbl -> GetSupportedLbPolicies(This,pulLbFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunMpio_INTERFACE_DEFINED__ */


#ifndef __IVdsLunIscsi_INTERFACE_DEFINED__
#define __IVdsLunIscsi_INTERFACE_DEFINED__

/* interface IVdsLunIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d7c1e64-b59b-45ae-b86a-2c2cc6a42067")
    IVdsLunIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateTargets( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfTargets) VDS_OBJECT_ID *pTargetIdArray,
            /* [in] */ LONG lNumberOfTargets) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedTargets( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsLunIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsLunIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsLunIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateTargets )( 
            IVdsLunIscsi * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfTargets) VDS_OBJECT_ID *pTargetIdArray,
            /* [in] */ LONG lNumberOfTargets);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedTargets )( 
            IVdsLunIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsLunIscsiVtbl;

    interface IVdsLunIscsi
    {
        CONST_VTBL struct IVdsLunIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunIscsi_AssociateTargets(This,pTargetIdArray,lNumberOfTargets)	\
    ( (This)->lpVtbl -> AssociateTargets(This,pTargetIdArray,lNumberOfTargets) ) 

#define IVdsLunIscsi_QueryAssociatedTargets(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedTargets(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsLunPlex_INTERFACE_DEFINED__
#define __IVdsLunPlex_INTERFACE_DEFINED__

/* interface IVdsLunPlex */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunPlex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0ee1a790-5d2e-4abb-8c99-c481e8be2138")
    IVdsLunPlex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_LUN_PLEX_PROP *pPlexProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLun( 
            /* [out] */ __RPC__deref_out_opt IVdsLun **ppLun) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints( 
            /* [out] */ __RPC__out VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints( 
            /* [in] */ __RPC__in VDS_HINTS *pHints) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunPlexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsLunPlex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsLunPlex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsLunPlex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsLunPlex * This,
            /* [out] */ __RPC__out VDS_LUN_PLEX_PROP *pPlexProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLun )( 
            IVdsLunPlex * This,
            /* [out] */ __RPC__deref_out_opt IVdsLun **ppLun);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            IVdsLunPlex * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints )( 
            IVdsLunPlex * This,
            /* [out] */ __RPC__out VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints )( 
            IVdsLunPlex * This,
            /* [in] */ __RPC__in VDS_HINTS *pHints);
        
        END_INTERFACE
    } IVdsLunPlexVtbl;

    interface IVdsLunPlex
    {
        CONST_VTBL struct IVdsLunPlexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunPlex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunPlex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunPlex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunPlex_GetProperties(This,pPlexProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPlexProp) ) 

#define IVdsLunPlex_GetLun(This,ppLun)	\
    ( (This)->lpVtbl -> GetLun(This,ppLun) ) 

#define IVdsLunPlex_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsLunPlex_QueryHints(This,pHints)	\
    ( (This)->lpVtbl -> QueryHints(This,pHints) ) 

#define IVdsLunPlex_ApplyHints(This,pHints)	\
    ( (This)->lpVtbl -> ApplyHints(This,pHints) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunPlex_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortal_INTERFACE_DEFINED__
#define __IVdsIscsiPortal_INTERFACE_DEFINED__

/* interface IVdsIscsiPortal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7fa1499d-ec85-4a8a-a47b-ff69201fcd34")
    IVdsIscsiPortal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_PORTAL_PROP *pPortalProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedPortalGroups( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_ISCSI_PORTAL_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecTunnelAddress( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIpsecSecurity( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurity( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsIscsiPortal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsIscsiPortal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsIscsiPortal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsIscsiPortal * This,
            /* [out] */ __RPC__out VDS_ISCSI_PORTAL_PROP *pPortalProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            IVdsIscsiPortal * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedPortalGroups )( 
            IVdsIscsiPortal * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IVdsIscsiPortal * This,
            /* [in] */ VDS_ISCSI_PORTAL_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecTunnelAddress )( 
            IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIpsecSecurity )( 
            IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurity )( 
            IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiPortalVtbl;

    interface IVdsIscsiPortal
    {
        CONST_VTBL struct IVdsIscsiPortalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortal_GetProperties(This,pPortalProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortalProp) ) 

#define IVdsIscsiPortal_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsIscsiPortal_QueryAssociatedPortalGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedPortalGroups(This,ppEnum) ) 

#define IVdsIscsiPortal_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsIscsiPortal_SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsIscsiPortal_GetIpsecSecurity(This,pInitiatorPortalAddress,pullSecurityFlags)	\
    ( (This)->lpVtbl -> GetIpsecSecurity(This,pInitiatorPortalAddress,pullSecurityFlags) ) 

#define IVdsIscsiPortal_SetIpsecSecurity(This,pInitiatorPortalAddress,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurity(This,pInitiatorPortalAddress,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortal_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiTarget_INTERFACE_DEFINED__
#define __IVdsIscsiTarget_INTERFACE_DEFINED__

/* interface IVdsIscsiTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa8f5055-83e5-4bcc-aa73-19851a36a849")
    IVdsIscsiTarget : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_TARGET_PROP *pTargetProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPortalGroups( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePortalGroup( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in LPWSTR pwszFriendlyName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSharedSecret( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszInitiatorName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RememberInitiatorSharedSecret( 
            /* [string][in] */ __RPC__in LPWSTR pwszInitiatorName,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConnectedInitiators( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfInitiators) LPWSTR **pppwszInitiatorList,
            /* [out] */ __RPC__out LONG *plNumberOfInitiators) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsIscsiTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsIscsiTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsIscsiTarget * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsIscsiTarget * This,
            /* [out] */ __RPC__out VDS_ISCSI_TARGET_PROP *pTargetProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPortalGroups )( 
            IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePortalGroup )( 
            IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            IVdsIscsiTarget * This,
            /* [string][in] */ __RPC__in LPWSTR pwszFriendlyName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSharedSecret )( 
            IVdsIscsiTarget * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszInitiatorName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RememberInitiatorSharedSecret )( 
            IVdsIscsiTarget * This,
            /* [string][in] */ __RPC__in LPWSTR pwszInitiatorName,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConnectedInitiators )( 
            IVdsIscsiTarget * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfInitiators) LPWSTR **pppwszInitiatorList,
            /* [out] */ __RPC__out LONG *plNumberOfInitiators);
        
        END_INTERFACE
    } IVdsIscsiTargetVtbl;

    interface IVdsIscsiTarget
    {
        CONST_VTBL struct IVdsIscsiTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiTarget_GetProperties(This,pTargetProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pTargetProp) ) 

#define IVdsIscsiTarget_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsIscsiTarget_QueryPortalGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPortalGroups(This,ppEnum) ) 

#define IVdsIscsiTarget_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsIscsiTarget_CreatePortalGroup(This,ppAsync)	\
    ( (This)->lpVtbl -> CreatePortalGroup(This,ppAsync) ) 

#define IVdsIscsiTarget_Delete(This,ppAsync)	\
    ( (This)->lpVtbl -> Delete(This,ppAsync) ) 

#define IVdsIscsiTarget_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#define IVdsIscsiTarget_SetSharedSecret(This,pTargetSharedSecret,pwszInitiatorName)	\
    ( (This)->lpVtbl -> SetSharedSecret(This,pTargetSharedSecret,pwszInitiatorName) ) 

#define IVdsIscsiTarget_RememberInitiatorSharedSecret(This,pwszInitiatorName,pInitiatorSharedSecret)	\
    ( (This)->lpVtbl -> RememberInitiatorSharedSecret(This,pwszInitiatorName,pInitiatorSharedSecret) ) 

#define IVdsIscsiTarget_GetConnectedInitiators(This,pppwszInitiatorList,plNumberOfInitiators)	\
    ( (This)->lpVtbl -> GetConnectedInitiators(This,pppwszInitiatorList,plNumberOfInitiators) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiTarget_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortalGroup_INTERFACE_DEFINED__
#define __IVdsIscsiPortalGroup_INTERFACE_DEFINED__

/* interface IVdsIscsiPortalGroup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortalGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fef5f89d-a3dd-4b36-bf28-e7dde045c593")
    IVdsIscsiPortalGroup : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_PORTALGROUP_PROP *pPortalGroupProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTarget( 
            /* [out] */ __RPC__deref_out_opt IVdsIscsiTarget **ppTarget) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPortal( 
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePortal( 
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsIscsiPortalGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsIscsiPortalGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsIscsiPortalGroup * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__out VDS_ISCSI_PORTALGROUP_PROP *pPortalGroupProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTarget )( 
            IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IVdsIscsiTarget **ppTarget);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedPortals )( 
            IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPortal )( 
            IVdsIscsiPortalGroup * This,
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePortal )( 
            IVdsIscsiPortalGroup * This,
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsIscsiPortalGroupVtbl;

    interface IVdsIscsiPortalGroup
    {
        CONST_VTBL struct IVdsIscsiPortalGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortalGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortalGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortalGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortalGroup_GetProperties(This,pPortalGroupProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortalGroupProp) ) 

#define IVdsIscsiPortalGroup_GetTarget(This,ppTarget)	\
    ( (This)->lpVtbl -> GetTarget(This,ppTarget) ) 

#define IVdsIscsiPortalGroup_QueryAssociatedPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedPortals(This,ppEnum) ) 

#define IVdsIscsiPortalGroup_AddPortal(This,portalId,ppAsync)	\
    ( (This)->lpVtbl -> AddPortal(This,portalId,ppAsync) ) 

#define IVdsIscsiPortalGroup_RemovePortal(This,portalId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePortal(This,portalId,ppAsync) ) 

#define IVdsIscsiPortalGroup_Delete(This,ppAsync)	\
    ( (This)->lpVtbl -> Delete(This,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortalGroup_INTERFACE_DEFINED__ */


#ifndef __IVdsMaintenance_INTERFACE_DEFINED__
#define __IVdsMaintenance_INTERFACE_DEFINED__

/* interface IVdsMaintenance */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsMaintenance;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("daebeef3-8523-47ed-a2b9-05cecce2a1ae")
    IVdsMaintenance : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StopMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PulseMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation,
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsMaintenanceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsMaintenance * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsMaintenance * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsMaintenance * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartMaintenance )( 
            IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StopMaintenance )( 
            IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PulseMaintenance )( 
            IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IVdsMaintenanceVtbl;

    interface IVdsMaintenance
    {
        CONST_VTBL struct IVdsMaintenanceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsMaintenance_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsMaintenance_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsMaintenance_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsMaintenance_StartMaintenance(This,operation)	\
    ( (This)->lpVtbl -> StartMaintenance(This,operation) ) 

#define IVdsMaintenance_StopMaintenance(This,operation)	\
    ( (This)->lpVtbl -> StopMaintenance(This,operation) ) 

#define IVdsMaintenance_PulseMaintenance(This,operation,ulCount)	\
    ( (This)->lpVtbl -> PulseMaintenance(This,operation,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsMaintenance_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0037 */
/* [local] */ 

















// {9C38ED61-D565-4728-AEEE-C80952F0ECDE}
DEFINE_GUID(CLSID_VdsLoader, 
 0X9C38ED61,0xD565,0x4728,0xAE,0xEE,0xC8,0x09,0x52,0xF0,0xEC,0xDE);

// {7D1933CB-86F6-4A98-8628-01BE94C9A575}
DEFINE_GUID(CLSID_VdsService, 
 0x7D1933CB,0x86F6,0x4A98,0x86,0x28,0x01,0xBE,0x94,0xC9,0xA5,0x75);

#define	MAX_FS_NAME_SIZE	( 8 )

#define	MAX_FS_FORMAT_SUPPORT_NAME_SIZE	( 32 )

#define	MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE	( 32 )

typedef 
enum _VDS_SERVICE_FLAG
    {	VDS_SVF_SUPPORT_DYNAMIC	= 0x1,
	VDS_SVF_SUPPORT_FAULT_TOLERANT	= 0x2,
	VDS_SVF_SUPPORT_GPT	= 0x4,
	VDS_SVF_SUPPORT_DYNAMIC_1394	= 0x8,
	VDS_SVF_CLUSTER_SERVICE_CONFIGURED	= 0x10,
	VDS_SVF_AUTO_MOUNT_OFF	= 0x20,
	VDS_SVF_OS_UNINSTALL_VALID	= 0x40,
	VDS_SVF_EFI	= 0x80
    } 	VDS_SERVICE_FLAG;

typedef struct _VDS_SERVICE_PROP
    {
    LPWSTR pwszVersion;
    ULONG ulFlags;
    } 	VDS_SERVICE_PROP;

typedef 
enum _VDS_SAN_POLICY
    {	VDS_SP_UNKNOWN	= 0,
	VDS_SP_ONLINE	= 0x1,
	VDS_SP_OFFLINE_SHARED	= 0x2,
	VDS_SP_OFFLINE	= 0x3
    } 	VDS_SAN_POLICY;

typedef struct VDS_REPARSE_POINT_PROP
    {
    VDS_OBJECT_ID SourceVolumeId;
    LPWSTR pwszPath;
    } 	VDS_REPARSE_POINT_PROP;

typedef struct VDS_REPARSE_POINT_PROP *PVDS_REPARSE_POINT_PROP;

typedef 
enum _VDS_DRIVE_LETTER_FLAG
    {	VDS_DLF_NON_PERSISTENT	= 0x1
    } 	VDS_DRIVE_LETTER_FLAG;

typedef struct _VDS_DRIVE_LETTER_PROP
    {
    WCHAR wcLetter;
    VDS_OBJECT_ID volumeId;
    ULONG ulFlags;
    BOOL bUsed;
    } 	VDS_DRIVE_LETTER_PROP;

typedef struct _VDS_DRIVE_LETTER_PROP *PVDS_DRIVE_LETTER_PROP;

typedef 
enum _VDS_FILE_SYSTEM_FLAG
    {	VDS_FSF_SUPPORT_FORMAT	= 0x1,
	VDS_FSF_SUPPORT_QUICK_FORMAT	= 0x2,
	VDS_FSF_SUPPORT_COMPRESS	= 0x4,
	VDS_FSF_SUPPORT_SPECIFY_LABEL	= 0x8,
	VDS_FSF_SUPPORT_MOUNT_POINT	= 0x10,
	VDS_FSF_SUPPORT_REMOVABLE_MEDIA	= 0x20,
	VDS_FSF_SUPPORT_EXTEND	= 0x40,
	VDS_FSF_ALLOCATION_UNIT_512	= 0x10000,
	VDS_FSF_ALLOCATION_UNIT_1K	= 0x20000,
	VDS_FSF_ALLOCATION_UNIT_2K	= 0x40000,
	VDS_FSF_ALLOCATION_UNIT_4K	= 0x80000,
	VDS_FSF_ALLOCATION_UNIT_8K	= 0x100000,
	VDS_FSF_ALLOCATION_UNIT_16K	= 0x200000,
	VDS_FSF_ALLOCATION_UNIT_32K	= 0x400000,
	VDS_FSF_ALLOCATION_UNIT_64K	= 0x800000,
	VDS_FSF_ALLOCATION_UNIT_128K	= 0x1000000,
	VDS_FSF_ALLOCATION_UNIT_256K	= 0x2000000
    } 	VDS_FILE_SYSTEM_FLAG;

typedef struct _VDS_FILE_SYSTEM_TYPE_PROP
    {
    VDS_FILE_SYSTEM_TYPE type;
    WCHAR wszName[ 8 ];
    ULONG ulFlags;
    ULONG ulCompressionFlags;
    ULONG ulMaxLableLength;
    LPWSTR pwszIllegalLabelCharSet;
    } 	VDS_FILE_SYSTEM_TYPE_PROP;

typedef struct _VDS_FILE_SYSTEM_TYPE_PROP *PVDS_FILE_SYSTEM_TYPE_PROP;

typedef 
enum _VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG
    {	VDS_FSS_DEFAULT	= 0x1,
	VDS_FSS_PREVIOUS_REVISION	= 0x2,
	VDS_FSS_RECOMMENDED	= 0x4
    } 	VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG;

typedef struct _VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP
    {
    ULONG ulFlags;
    USHORT usRevision;
    ULONG ulDefaultUnitAllocationSize;
    ULONG rgulAllowedUnitAllocationSizes[ 32 ];
    WCHAR wszName[ 32 ];
    } 	VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP;

typedef struct _VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP *PVDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP;

typedef 
enum _VDS_FILE_SYSTEM_PROP_FLAG
    {	VDS_FPF_COMPRESSED	= 0x1
    } 	VDS_FILE_SYSTEM_PROP_FLAG;

typedef struct _VDS_FILE_SYSTEM_PROP
    {
    VDS_FILE_SYSTEM_TYPE type;
    VDS_OBJECT_ID volumeId;
    ULONG ulFlags;
    ULONGLONG ullTotalAllocationUnits;
    ULONGLONG ullAvailableAllocationUnits;
    ULONG ulAllocationUnitSize;
    LPWSTR pwszLabel;
    } 	VDS_FILE_SYSTEM_PROP;

typedef struct _VDS_FILE_SYSTEM_PROP *PVDS_FILE_SYSTEM_PROP;

typedef 
enum _VDS_QUERY_PROVIDER_FLAG
    {	VDS_QUERY_SOFTWARE_PROVIDERS	= 0x1,
	VDS_QUERY_HARDWARE_PROVIDERS	= 0x2
    } 	VDS_QUERY_PROVIDER_FLAG;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0037_v0_0_s_ifspec;

#ifndef __IVdsServiceLoader_INTERFACE_DEFINED__
#define __IVdsServiceLoader_INTERFACE_DEFINED__

/* interface IVdsServiceLoader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceLoader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e0393303-90d4-4a97-ab71-e9b671ee2729")
    IVdsServiceLoader : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadService( 
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszMachineName,
            /* [out] */ __RPC__deref_out_opt IVdsService **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceLoaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsServiceLoader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsServiceLoader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsServiceLoader * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoadService )( 
            IVdsServiceLoader * This,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszMachineName,
            /* [out] */ __RPC__deref_out_opt IVdsService **ppService);
        
        END_INTERFACE
    } IVdsServiceLoaderVtbl;

    interface IVdsServiceLoader
    {
        CONST_VTBL struct IVdsServiceLoaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceLoader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceLoader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceLoader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceLoader_LoadService(This,pwszMachineName,ppService)	\
    ( (This)->lpVtbl -> LoadService(This,pwszMachineName,ppService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceLoader_INTERFACE_DEFINED__ */


#ifndef __IVdsService_INTERFACE_DEFINED__
#define __IVdsService_INTERFACE_DEFINED__

/* interface IVdsService */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0818a8ef-9ba9-40d8-a6f9-e22833cc771e")
    IVdsService : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsServiceReady( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForServiceReady( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_SERVICE_PROP *pServiceProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryProviders( 
            /* [in] */ DWORD masks,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaskedDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryUnallocatedDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ VDS_OBJECT_ID ObjectId,
            /* [in] */ VDS_OBJECT_TYPE type,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppObjectUnk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDriveLetters( 
            /* [in] */ WCHAR wcFirstLetter,
            /* [in] */ DWORD count,
            /* [size_is][out] */ __RPC__out_ecount_full(count) VDS_DRIVE_LETTER_PROP *pDriveLetterPropArray) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryFileSystemTypes( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_TYPE_PROP **ppFileSystemTypeProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CleanupObsoleteMountPoints( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IVdsAdviseSink *pSink,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reboot( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsServiceReady )( 
            IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForServiceReady )( 
            IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsService * This,
            /* [out] */ __RPC__out VDS_SERVICE_PROP *pServiceProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryProviders )( 
            IVdsService * This,
            /* [in] */ DWORD masks,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaskedDisks )( 
            IVdsService * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryUnallocatedDisks )( 
            IVdsService * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IVdsService * This,
            /* [in] */ VDS_OBJECT_ID ObjectId,
            /* [in] */ VDS_OBJECT_TYPE type,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppObjectUnk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDriveLetters )( 
            IVdsService * This,
            /* [in] */ WCHAR wcFirstLetter,
            /* [in] */ DWORD count,
            /* [size_is][out] */ __RPC__out_ecount_full(count) VDS_DRIVE_LETTER_PROP *pDriveLetterPropArray);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryFileSystemTypes )( 
            IVdsService * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_TYPE_PROP **ppFileSystemTypeProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CleanupObsoleteMountPoints )( 
            IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IVdsService * This,
            /* [in] */ __RPC__in_opt IVdsAdviseSink *pSink,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IVdsService * This,
            /* [in] */ DWORD dwCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reboot )( 
            IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IVdsService * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            IVdsService * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsServiceVtbl;

    interface IVdsService
    {
        CONST_VTBL struct IVdsServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsService_IsServiceReady(This)	\
    ( (This)->lpVtbl -> IsServiceReady(This) ) 

#define IVdsService_WaitForServiceReady(This)	\
    ( (This)->lpVtbl -> WaitForServiceReady(This) ) 

#define IVdsService_GetProperties(This,pServiceProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pServiceProp) ) 

#define IVdsService_QueryProviders(This,masks,ppEnum)	\
    ( (This)->lpVtbl -> QueryProviders(This,masks,ppEnum) ) 

#define IVdsService_QueryMaskedDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryMaskedDisks(This,ppEnum) ) 

#define IVdsService_QueryUnallocatedDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryUnallocatedDisks(This,ppEnum) ) 

#define IVdsService_GetObject(This,ObjectId,type,ppObjectUnk)	\
    ( (This)->lpVtbl -> GetObject(This,ObjectId,type,ppObjectUnk) ) 

#define IVdsService_QueryDriveLetters(This,wcFirstLetter,count,pDriveLetterPropArray)	\
    ( (This)->lpVtbl -> QueryDriveLetters(This,wcFirstLetter,count,pDriveLetterPropArray) ) 

#define IVdsService_QueryFileSystemTypes(This,ppFileSystemTypeProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryFileSystemTypes(This,ppFileSystemTypeProps,plNumberOfFileSystems) ) 

#define IVdsService_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsService_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IVdsService_CleanupObsoleteMountPoints(This)	\
    ( (This)->lpVtbl -> CleanupObsoleteMountPoints(This) ) 

#define IVdsService_Advise(This,pSink,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pSink,pdwCookie) ) 

#define IVdsService_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IVdsService_Reboot(This)	\
    ( (This)->lpVtbl -> Reboot(This) ) 

#define IVdsService_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsService_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsService_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceUninstallDisk_INTERFACE_DEFINED__
#define __IVdsServiceUninstallDisk_INTERFACE_DEFINED__

/* interface IVdsServiceUninstallDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceUninstallDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6B22DA8-F903-4be7-B492-C09D875AC9DA")
    IVdsServiceUninstallDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDiskIdFromLunInfo( 
            /* [in] */ __RPC__in VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out VDS_OBJECT_ID *pDiskId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UninstallDisks( 
            /* [size_is][in] */ __RPC__in_ecount_full(ulCount) VDS_OBJECT_ID *pDiskIdArray,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOLEAN bForce,
            /* [out] */ __RPC__out BOOLEAN *pbReboot,
            /* [size_is][out] */ __RPC__out_ecount_full(ulCount) HRESULT *pResults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceUninstallDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsServiceUninstallDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsServiceUninstallDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsServiceUninstallDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDiskIdFromLunInfo )( 
            IVdsServiceUninstallDisk * This,
            /* [in] */ __RPC__in VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out VDS_OBJECT_ID *pDiskId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UninstallDisks )( 
            IVdsServiceUninstallDisk * This,
            /* [size_is][in] */ __RPC__in_ecount_full(ulCount) VDS_OBJECT_ID *pDiskIdArray,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOLEAN bForce,
            /* [out] */ __RPC__out BOOLEAN *pbReboot,
            /* [size_is][out] */ __RPC__out_ecount_full(ulCount) HRESULT *pResults);
        
        END_INTERFACE
    } IVdsServiceUninstallDiskVtbl;

    interface IVdsServiceUninstallDisk
    {
        CONST_VTBL struct IVdsServiceUninstallDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceUninstallDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceUninstallDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceUninstallDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceUninstallDisk_GetDiskIdFromLunInfo(This,pLunInfo,pDiskId)	\
    ( (This)->lpVtbl -> GetDiskIdFromLunInfo(This,pLunInfo,pDiskId) ) 

#define IVdsServiceUninstallDisk_UninstallDisks(This,pDiskIdArray,ulCount,bForce,pbReboot,pResults)	\
    ( (This)->lpVtbl -> UninstallDisks(This,pDiskIdArray,ulCount,bForce,pbReboot,pResults) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceUninstallDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceHba_INTERFACE_DEFINED__
#define __IVdsServiceHba_INTERFACE_DEFINED__

/* interface IVdsServiceHba */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceHba;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0ac13689-3134-47c6-a17c-4669216801be")
    IVdsServiceHba : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHbaPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceHbaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsServiceHba * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsServiceHba * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsServiceHba * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHbaPorts )( 
            IVdsServiceHba * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsServiceHbaVtbl;

    interface IVdsServiceHba
    {
        CONST_VTBL struct IVdsServiceHbaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceHba_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceHba_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceHba_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceHba_QueryHbaPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryHbaPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceHba_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceIscsi_INTERFACE_DEFINED__
#define __IVdsServiceIscsi_INTERFACE_DEFINED__

/* interface IVdsServiceIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14fbe036-3ed7-4e10-90e9-a5ff991aff01")
    IVdsServiceIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitiatorName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryInitiatorAdapters( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecGroupPresharedKey( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllIpsecTunnelAddresses( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInitiatorSharedSecret( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret,
            /* [in] */ VDS_OBJECT_ID targetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RememberTargetSharedSecret( 
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsServiceIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsServiceIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsServiceIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInitiatorName )( 
            IVdsServiceIscsi * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryInitiatorAdapters )( 
            IVdsServiceIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecGroupPresharedKey )( 
            IVdsServiceIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllIpsecTunnelAddresses )( 
            IVdsServiceIscsi * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllIpsecSecurity )( 
            IVdsServiceIscsi * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInitiatorSharedSecret )( 
            IVdsServiceIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret,
            /* [in] */ VDS_OBJECT_ID targetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RememberTargetSharedSecret )( 
            IVdsServiceIscsi * This,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret);
        
        END_INTERFACE
    } IVdsServiceIscsiVtbl;

    interface IVdsServiceIscsi
    {
        CONST_VTBL struct IVdsServiceIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceIscsi_GetInitiatorName(This,ppwszIscsiName)	\
    ( (This)->lpVtbl -> GetInitiatorName(This,ppwszIscsiName) ) 

#define IVdsServiceIscsi_QueryInitiatorAdapters(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryInitiatorAdapters(This,ppEnum) ) 

#define IVdsServiceIscsi_SetIpsecGroupPresharedKey(This,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecGroupPresharedKey(This,pIpsecKey) ) 

#define IVdsServiceIscsi_SetAllIpsecTunnelAddresses(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetAllIpsecTunnelAddresses(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsServiceIscsi_SetAllIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetAllIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey) ) 

#define IVdsServiceIscsi_SetInitiatorSharedSecret(This,pInitiatorSharedSecret,targetId)	\
    ( (This)->lpVtbl -> SetInitiatorSharedSecret(This,pInitiatorSharedSecret,targetId) ) 

#define IVdsServiceIscsi_RememberTargetSharedSecret(This,targetId,pTargetSharedSecret)	\
    ( (This)->lpVtbl -> RememberTargetSharedSecret(This,targetId,pTargetSharedSecret) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceInitialization_INTERFACE_DEFINED__
#define __IVdsServiceInitialization_INTERFACE_DEFINED__

/* interface IVdsServiceInitialization */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceInitialization;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4afc3636-db01-4052-80c3-03bbcb8d3c69")
    IVdsServiceInitialization : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszMachineName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceInitializationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsServiceInitialization * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsServiceInitialization * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsServiceInitialization * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IVdsServiceInitialization * This,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszMachineName);
        
        END_INTERFACE
    } IVdsServiceInitializationVtbl;

    interface IVdsServiceInitialization
    {
        CONST_VTBL struct IVdsServiceInitializationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceInitialization_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceInitialization_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceInitialization_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceInitialization_Initialize(This,pwszMachineName)	\
    ( (This)->lpVtbl -> Initialize(This,pwszMachineName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceInitialization_INTERFACE_DEFINED__ */


#ifndef __IVdsHbaPort_INTERFACE_DEFINED__
#define __IVdsHbaPort_INTERFACE_DEFINED__

/* interface IVdsHbaPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHbaPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2abd757f-2851-4997-9a13-47d2a885d6ca")
    IVdsHbaPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_HBAPORT_PROP *pHbaPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllPathStatuses( 
            /* [in] */ VDS_PATH_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHbaPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsHbaPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsHbaPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsHbaPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsHbaPort * This,
            /* [out] */ __RPC__out VDS_HBAPORT_PROP *pHbaPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllPathStatuses )( 
            IVdsHbaPort * This,
            /* [in] */ VDS_PATH_STATUS status);
        
        END_INTERFACE
    } IVdsHbaPortVtbl;

    interface IVdsHbaPort
    {
        CONST_VTBL struct IVdsHbaPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHbaPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHbaPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHbaPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHbaPort_GetProperties(This,pHbaPortProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pHbaPortProp) ) 

#define IVdsHbaPort_SetAllPathStatuses(This,status)	\
    ( (This)->lpVtbl -> SetAllPathStatuses(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHbaPort_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__
#define __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__

/* interface IVdsIscsiInitiatorAdapter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiInitiatorAdapter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b07fedd4-1682-4440-9189-a39b55194dc5")
    IVdsIscsiInitiatorAdapter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_ADAPTER_PROP *pInitiatorAdapterProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryInitiatorPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoginToTarget( 
            /* [in] */ VDS_ISCSI_LOGIN_TYPE loginType,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ VDS_OBJECT_ID initiatorPortalId,
            /* [in] */ ULONG ulLoginFlags,
            /* [in] */ BOOL bHeaderDigest,
            /* [in] */ BOOL bDataDigest,
            /* [in] */ VDS_ISCSI_AUTH_TYPE authType,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogoutFromTarget( 
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiInitiatorAdapterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsIscsiInitiatorAdapter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsIscsiInitiatorAdapter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsIscsiInitiatorAdapter * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsIscsiInitiatorAdapter * This,
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_ADAPTER_PROP *pInitiatorAdapterProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryInitiatorPortals )( 
            IVdsIscsiInitiatorAdapter * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoginToTarget )( 
            IVdsIscsiInitiatorAdapter * This,
            /* [in] */ VDS_ISCSI_LOGIN_TYPE loginType,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ VDS_OBJECT_ID initiatorPortalId,
            /* [in] */ ULONG ulLoginFlags,
            /* [in] */ BOOL bHeaderDigest,
            /* [in] */ BOOL bDataDigest,
            /* [in] */ VDS_ISCSI_AUTH_TYPE authType,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogoutFromTarget )( 
            IVdsIscsiInitiatorAdapter * This,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsIscsiInitiatorAdapterVtbl;

    interface IVdsIscsiInitiatorAdapter
    {
        CONST_VTBL struct IVdsIscsiInitiatorAdapterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiInitiatorAdapter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiInitiatorAdapter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiInitiatorAdapter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiInitiatorAdapter_GetProperties(This,pInitiatorAdapterProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pInitiatorAdapterProp) ) 

#define IVdsIscsiInitiatorAdapter_QueryInitiatorPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryInitiatorPortals(This,ppEnum) ) 

#define IVdsIscsiInitiatorAdapter_LoginToTarget(This,loginType,targetId,targetPortalId,initiatorPortalId,ulLoginFlags,bHeaderDigest,bDataDigest,authType,ppAsync)	\
    ( (This)->lpVtbl -> LoginToTarget(This,loginType,targetId,targetPortalId,initiatorPortalId,ulLoginFlags,bHeaderDigest,bDataDigest,authType,ppAsync) ) 

#define IVdsIscsiInitiatorAdapter_LogoutFromTarget(This,targetId,ppAsync)	\
    ( (This)->lpVtbl -> LogoutFromTarget(This,targetId,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__
#define __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__

/* interface IVdsIscsiInitiatorPortal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiInitiatorPortal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38a0a9ab-7cc8-4693-ac07-1f28bd03c3da")
    IVdsIscsiInitiatorPortal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_PORTAL_PROP *pInitiatorPortalProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitiatorAdapter( 
            /* [out] */ __RPC__deref_out_opt IVdsIscsiInitiatorAdapter **ppInitiatorAdapter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecTunnelAddress( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiInitiatorPortalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsIscsiInitiatorPortal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsIscsiInitiatorPortal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsIscsiInitiatorPortal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IVdsIscsiInitiatorPortal * This,
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_PORTAL_PROP *pInitiatorPortalProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInitiatorAdapter )( 
            IVdsIscsiInitiatorPortal * This,
            /* [out] */ __RPC__deref_out_opt IVdsIscsiInitiatorAdapter **ppInitiatorAdapter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecTunnelAddress )( 
            IVdsIscsiInitiatorPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIpsecSecurity )( 
            IVdsIscsiInitiatorPortal * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurity )( 
            IVdsIscsiInitiatorPortal * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiInitiatorPortalVtbl;

    interface IVdsIscsiInitiatorPortal
    {
        CONST_VTBL struct IVdsIscsiInitiatorPortalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiInitiatorPortal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiInitiatorPortal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiInitiatorPortal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiInitiatorPortal_GetProperties(This,pInitiatorPortalProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pInitiatorPortalProp) ) 

#define IVdsIscsiInitiatorPortal_GetInitiatorAdapter(This,ppInitiatorAdapter)	\
    ( (This)->lpVtbl -> GetInitiatorAdapter(This,ppInitiatorAdapter) ) 

#define IVdsIscsiInitiatorPortal_SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsIscsiInitiatorPortal_GetIpsecSecurity(This,targetPortalId,pullSecurityFlags)	\
    ( (This)->lpVtbl -> GetIpsecSecurity(This,targetPortalId,pullSecurityFlags) ) 

#define IVdsIscsiInitiatorPortal_SetIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__ */


#ifndef __IVdsDiskPartitionMF_INTERFACE_DEFINED__
#define __IVdsDiskPartitionMF_INTERFACE_DEFINED__

/* interface IVdsDiskPartitionMF */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDiskPartitionMF;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("538684e0-ba3d-4bc0-aca9-164aff85c2a9")
    IVdsDiskPartitionMF : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionFileSystemProperties( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionFileSystemTypeName( 
            /* [in] */ ULONGLONG ullOffset,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPartitionFileSystemFormatSupport( 
            /* [in] */ ULONGLONG ullOffset,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatPartitionEx( 
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskPartitionMFVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsDiskPartitionMF * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsDiskPartitionMF * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsDiskPartitionMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFileSystemProperties )( 
            IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFileSystemTypeName )( 
            IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPartitionFileSystemFormatSupport )( 
            IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatPartitionEx )( 
            IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsDiskPartitionMFVtbl;

    interface IVdsDiskPartitionMF
    {
        CONST_VTBL struct IVdsDiskPartitionMFVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDiskPartitionMF_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDiskPartitionMF_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDiskPartitionMF_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDiskPartitionMF_GetPartitionFileSystemProperties(This,ullOffset,pFileSystemProp)	\
    ( (This)->lpVtbl -> GetPartitionFileSystemProperties(This,ullOffset,pFileSystemProp) ) 

#define IVdsDiskPartitionMF_GetPartitionFileSystemTypeName(This,ullOffset,ppwszFileSystemTypeName)	\
    ( (This)->lpVtbl -> GetPartitionFileSystemTypeName(This,ullOffset,ppwszFileSystemTypeName) ) 

#define IVdsDiskPartitionMF_QueryPartitionFileSystemFormatSupport(This,ullOffset,ppFileSystemSupportProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryPartitionFileSystemFormatSupport(This,ullOffset,ppFileSystemSupportProps,plNumberOfFileSystems) ) 

#define IVdsDiskPartitionMF_FormatPartitionEx(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatPartitionEx(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDiskPartitionMF_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeMF_INTERFACE_DEFINED__
#define __IVdsVolumeMF_INTERFACE_DEFINED__

/* interface IVdsVolumeMF */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeMF;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ee2d5ded-6236-4169-931d-b9778ce03dc6")
    IVdsVolumeMF : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFileSystemProperties( 
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Format( 
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddAccessPath( 
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAccessPaths( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfAccessPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out LONG *plNumberOfAccessPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryReparsePoints( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfReparsePointProps) VDS_REPARSE_POINT_PROP **ppReparsePointProps,
            /* [out] */ __RPC__out LONG *plNumberOfReparsePointProps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAccessPath( 
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath,
            /* [in] */ BOOL bForce) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Mount( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Dismount( 
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bPermanent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFileSystemFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFileSystemFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeMFVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsVolumeMF * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsVolumeMF * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsVolumeMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFileSystemProperties )( 
            IVdsVolumeMF * This,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Format )( 
            IVdsVolumeMF * This,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddAccessPath )( 
            IVdsVolumeMF * This,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAccessPaths )( 
            IVdsVolumeMF * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfAccessPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out LONG *plNumberOfAccessPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryReparsePoints )( 
            IVdsVolumeMF * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfReparsePointProps) VDS_REPARSE_POINT_PROP **ppReparsePointProps,
            /* [out] */ __RPC__out LONG *plNumberOfReparsePointProps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteAccessPath )( 
            IVdsVolumeMF * This,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath,
            /* [in] */ BOOL bForce);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Mount )( 
            IVdsVolumeMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Dismount )( 
            IVdsVolumeMF * This,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bPermanent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFileSystemFlags )( 
            IVdsVolumeMF * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFileSystemFlags )( 
            IVdsVolumeMF * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsVolumeMFVtbl;

    interface IVdsVolumeMF
    {
        CONST_VTBL struct IVdsVolumeMFVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeMF_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeMF_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeMF_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeMF_GetFileSystemProperties(This,pFileSystemProp)	\
    ( (This)->lpVtbl -> GetFileSystemProperties(This,pFileSystemProp) ) 

#define IVdsVolumeMF_Format(This,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> Format(This,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#define IVdsVolumeMF_AddAccessPath(This,pwszPath)	\
    ( (This)->lpVtbl -> AddAccessPath(This,pwszPath) ) 

#define IVdsVolumeMF_QueryAccessPaths(This,pwszPathArray,plNumberOfAccessPaths)	\
    ( (This)->lpVtbl -> QueryAccessPaths(This,pwszPathArray,plNumberOfAccessPaths) ) 

#define IVdsVolumeMF_QueryReparsePoints(This,ppReparsePointProps,plNumberOfReparsePointProps)	\
    ( (This)->lpVtbl -> QueryReparsePoints(This,ppReparsePointProps,plNumberOfReparsePointProps) ) 

#define IVdsVolumeMF_DeleteAccessPath(This,pwszPath,bForce)	\
    ( (This)->lpVtbl -> DeleteAccessPath(This,pwszPath,bForce) ) 

#define IVdsVolumeMF_Mount(This)	\
    ( (This)->lpVtbl -> Mount(This) ) 

#define IVdsVolumeMF_Dismount(This,bForce,bPermanent)	\
    ( (This)->lpVtbl -> Dismount(This,bForce,bPermanent) ) 

#define IVdsVolumeMF_SetFileSystemFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFileSystemFlags(This,ulFlags) ) 

#define IVdsVolumeMF_ClearFileSystemFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFileSystemFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeMF_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeMF2_INTERFACE_DEFINED__
#define __IVdsVolumeMF2_INTERFACE_DEFINED__

/* interface IVdsVolumeMF2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeMF2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4dbcee9a-6343-4651-b85f-5e75d74d983c")
    IVdsVolumeMF2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFileSystemTypeName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryFileSystemFormatSupport( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatEx( 
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeMF2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsVolumeMF2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsVolumeMF2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsVolumeMF2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFileSystemTypeName )( 
            IVdsVolumeMF2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryFileSystemFormatSupport )( 
            IVdsVolumeMF2 * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatEx )( 
            IVdsVolumeMF2 * This,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumeMF2Vtbl;

    interface IVdsVolumeMF2
    {
        CONST_VTBL struct IVdsVolumeMF2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeMF2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeMF2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeMF2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeMF2_GetFileSystemTypeName(This,ppwszFileSystemTypeName)	\
    ( (This)->lpVtbl -> GetFileSystemTypeName(This,ppwszFileSystemTypeName) ) 

#define IVdsVolumeMF2_QueryFileSystemFormatSupport(This,ppFileSystemSupportProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryFileSystemFormatSupport(This,ppFileSystemSupportProps,plNumberOfFileSystems) ) 

#define IVdsVolumeMF2_FormatEx(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatEx(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeMF2_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeShrink_INTERFACE_DEFINED__
#define __IVdsVolumeShrink_INTERFACE_DEFINED__

/* interface IVdsVolumeShrink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeShrink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d68168c9-82a2-4f85-b6e9-74707c49a58f")
    IVdsVolumeShrink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxReclaimableBytes( 
            /* [out] */ __RPC__out ULONGLONG *pullMaxNumberOfReclaimableBytes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullDesiredNumberOfReclaimableBytes,
            /* [in] */ ULONGLONG ullMinNumberOfReclaimableBytes,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeShrinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsVolumeShrink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsVolumeShrink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsVolumeShrink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxReclaimableBytes )( 
            IVdsVolumeShrink * This,
            /* [out] */ __RPC__out ULONGLONG *pullMaxNumberOfReclaimableBytes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            IVdsVolumeShrink * This,
            /* [in] */ ULONGLONG ullDesiredNumberOfReclaimableBytes,
            /* [in] */ ULONGLONG ullMinNumberOfReclaimableBytes,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumeShrinkVtbl;

    interface IVdsVolumeShrink
    {
        CONST_VTBL struct IVdsVolumeShrinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeShrink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeShrink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeShrink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeShrink_QueryMaxReclaimableBytes(This,pullMaxNumberOfReclaimableBytes)	\
    ( (This)->lpVtbl -> QueryMaxReclaimableBytes(This,pullMaxNumberOfReclaimableBytes) ) 

#define IVdsVolumeShrink_Shrink(This,ullDesiredNumberOfReclaimableBytes,ullMinNumberOfReclaimableBytes,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullDesiredNumberOfReclaimableBytes,ullMinNumberOfReclaimableBytes,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeShrink_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemImportTarget_INTERFACE_DEFINED__
#define __IVdsSubSystemImportTarget_INTERFACE_DEFINED__

/* interface IVdsSubSystemImportTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemImportTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83bfb87f-43fb-4903-baa6-127f01029eec")
    IVdsSubSystemImportTarget : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImportTarget( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetImportTarget( 
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszIscsiName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemImportTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsSubSystemImportTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsSubSystemImportTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsSubSystemImportTarget * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetImportTarget )( 
            IVdsSubSystemImportTarget * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetImportTarget )( 
            IVdsSubSystemImportTarget * This,
            /* [string][unique][in] */ __RPC__in_opt LPWSTR pwszIscsiName);
        
        END_INTERFACE
    } IVdsSubSystemImportTargetVtbl;

    interface IVdsSubSystemImportTarget
    {
        CONST_VTBL struct IVdsSubSystemImportTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemImportTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemImportTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemImportTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemImportTarget_GetImportTarget(This,ppwszIscsiName)	\
    ( (This)->lpVtbl -> GetImportTarget(This,ppwszIscsiName) ) 

#define IVdsSubSystemImportTarget_SetImportTarget(This,pwszIscsiName)	\
    ( (This)->lpVtbl -> SetImportTarget(This,pwszIscsiName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemImportTarget_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortalLocal_INTERFACE_DEFINED__
#define __IVdsIscsiPortalLocal_INTERFACE_DEFINED__

/* interface IVdsIscsiPortalLocal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortalLocal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad837c28-52c1-421d-bf04-fae7da665396")
    IVdsIscsiPortalLocal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurityLocal( 
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalLocalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsIscsiPortalLocal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsIscsiPortalLocal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsIscsiPortalLocal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurityLocal )( 
            IVdsIscsiPortalLocal * This,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiPortalLocalVtbl;

    interface IVdsIscsiPortalLocal
    {
        CONST_VTBL struct IVdsIscsiPortalLocalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortalLocal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortalLocal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortalLocal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortalLocal_SetIpsecSecurityLocal(This,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurityLocal(This,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortalLocal_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceSAN_INTERFACE_DEFINED__
#define __IVdsServiceSAN_INTERFACE_DEFINED__

/* interface IVdsServiceSAN */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceSAN;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FC5D23E8-A88B-41a5-8DE0-2D2F73C5A630")
    IVdsServiceSAN : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSANPolicy( 
            /* [out] */ __RPC__out VDS_SAN_POLICY *pSanPolicy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSANPolicy( 
            /* [in] */ VDS_SAN_POLICY SanPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceSANVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVdsServiceSAN * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVdsServiceSAN * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVdsServiceSAN * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSANPolicy )( 
            IVdsServiceSAN * This,
            /* [out] */ __RPC__out VDS_SAN_POLICY *pSanPolicy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSANPolicy )( 
            IVdsServiceSAN * This,
            /* [in] */ VDS_SAN_POLICY SanPolicy);
        
        END_INTERFACE
    } IVdsServiceSANVtbl;

    interface IVdsServiceSAN
    {
        CONST_VTBL struct IVdsServiceSANVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceSAN_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceSAN_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceSAN_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceSAN_GetSANPolicy(This,pSanPolicy)	\
    ( (This)->lpVtbl -> GetSANPolicy(This,pSanPolicy) ) 

#define IVdsServiceSAN_SetSANPolicy(This,SanPolicy)	\
    ( (This)->lpVtbl -> SetSANPolicy(This,SanPolicy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceSAN_INTER