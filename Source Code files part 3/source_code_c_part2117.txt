c);
			var.ChangeType(VT_BSTR);
			return dc << "\n\t cyVal = " << var.bstrVal;
		}

	case VT_R4:
		return dc << "\n\t fltVal = " << pSrc->fltVal;

	case VT_R8:
		return dc << "\n\t dblVal = " << pSrc->dblVal;

	case VT_DATE:
		{
			COleVariant var(varSrc);
			var.ChangeType(VT_BSTR);
			return dc << "\n\t date = " << var.bstrVal;
		}

	case VT_BSTR:
		return dc << "\n\t bstrVal = " << pSrc->bstrVal;

	case VT_ERROR:
		return dc << "\n\t scode = " << pSrc->scode;

	case VT_DISPATCH:
	case VT_UNKNOWN:
		return dc << "\n\t punkVal = " << pSrc->punkVal;

	case VT_EMPTY:
	case VT_NULL:
		return dc;

	default:
		ASSERT(FALSE);
		return dc;
	}
}
#endif // _DEBUG

CArchive& AFXAPI operator<<(CArchive& ar, COleVariant varSrc)
{
	LPCVARIANT pSrc = (LPCVARIANT)varSrc;

	ar << pSrc->vt;

	// No support for VT_BYREF & VT_ARRAY
	if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
		return ar;

	switch (pSrc->vt)
	{
	case VT_BOOL:
		return ar << (WORD)V_BOOL(pSrc);

	case VT_I1:
		return ar << pSrc->cVal;

	case VT_UI1:
		return ar << pSrc->bVal;

	case VT_I2:
		return ar << pSrc->iVal;

	case VT_UI2:
		return ar << pSrc->uiVal;

	case VT_I4:
		return ar << pSrc->lVal;

	case VT_UI4:
		return ar << pSrc->ulVal;

	case VT_I8:
		return ar << pSrc->llVal;

	case VT_UI8:
		return ar << pSrc->ullVal;

	case VT_CY:
		ar << pSrc->cyVal.Lo;
		return ar << pSrc->cyVal.Hi;

	case VT_R4:
		return ar << pSrc->fltVal;

	case VT_R8:
		return ar << pSrc->dblVal;

	case VT_DATE:
		return ar << pSrc->date;

	case VT_BSTR:
		{
			DWORD nLen = SysStringByteLen(pSrc->bstrVal);
			ar << nLen;
			if (nLen > 0)
				ar.Write(pSrc->bstrVal, nLen * sizeof(BYTE));

			return ar;
		}

	case VT_ERROR:
		return ar << pSrc->scode;

	case VT_DISPATCH:
	case VT_UNKNOWN:
		{
			LPPERSISTSTREAM pPersistStream;
			CArchiveStream stm(&ar);

			// QI for IPersistStream or IPeristStreamInit
			SCODE sc = pSrc->punkVal->QueryInterface(
				IID_IPersistStream, (void**)&pPersistStream);
#ifndef _AFX_NO_OCC_SUPPORT
			if (FAILED(sc))
				sc = pSrc->punkVal->QueryInterface(
					IID_IPersistStreamInit, (void**)&pPersistStream);
#endif
			AfxCheckError(sc);

			TRY
			{
				// Get and archive the CLSID (GUID)
				CLSID clsid;
				AfxCheckError(pPersistStream->GetClassID(&clsid));
				ar << clsid.Data1;
				ar << clsid.Data2;
				ar << clsid.Data3;
				ar.Write(&clsid.Data4[0], sizeof clsid.Data4);

				// Always assume object is dirty
				AfxCheckError(pPersistStream->Save(&stm, TRUE));
			}
			CATCH_ALL(e)
			{
				pPersistStream->Release();
				THROW_LAST();
			}
			END_CATCH_ALL
			pPersistStream->Release();
		}
		return ar;

	case VT_EMPTY:
	case VT_NULL:
		// do nothing
		return ar;

	default:
		ASSERT(FALSE);
		return ar;
	}
}

CArchive& AFXAPI operator>>(CArchive& ar, COleVariant& varSrc)
{
	LPVARIANT pSrc = &varSrc;

	// Free up current data if necessary
	if (pSrc->vt != VT_EMPTY)
		VariantClear(pSrc);
	ar >> pSrc->vt;

	// No support for VT_BYREF & VT_ARRAY
	if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
		return ar;

	switch (pSrc->vt)
	{
	case VT_BOOL:
		return ar >> (WORD&)V_BOOL(pSrc);

	case VT_I1:
		return ar >> pSrc->cVal;

	case VT_UI1:
		return ar >> pSrc->bVal;

	case VT_I2:
		return ar >> pSrc->iVal;

	case VT_UI2:
		return ar >> pSrc->uiVal;

	case VT_I4:
		return ar >> pSrc->lVal;

	case VT_UI4:
		return ar >> pSrc->ulVal;

	case VT_I8:
		return ar >> pSrc->llVal;

	case VT_UI8:
		return ar >> pSrc->ullVal;

	case VT_CY:
		ar >> pSrc->cyVal.Lo;
		return ar >> pSrc->cyVal.Hi;

	case VT_R4:
		return ar >> pSrc->fltVal;

	case VT_R8:
		return ar >> pSrc->dblVal;

	case VT_DATE:
		return ar >> pSrc->date;

	case VT_BSTR:
		{
			DWORD nLen;
			ar >> nLen;
			if (nLen > 0)
			{
				pSrc->bstrVal = SysAllocStringByteLen(NULL, nLen);
				if (pSrc->bstrVal == NULL)
					AfxThrowMemoryException();
				ar.EnsureRead(pSrc->bstrVal, nLen * sizeof(BYTE));
			}
			else
				pSrc->bstrVal = NULL;

			return ar;
		}
		break;

	case VT_ERROR:
		return ar >> pSrc->scode;

	case VT_DISPATCH:
	case VT_UNKNOWN:
		{
			LPPERSISTSTREAM pPersistStream = NULL;
			CArchiveStream stm(&ar);

			// Retrieve the CLSID (GUID) and create an instance
			CLSID clsid;
			ar >> clsid.Data1;
			ar >> clsid.Data2;
			ar >> clsid.Data3;
			ar.EnsureRead(&clsid.Data4[0], sizeof clsid.Data4);

			// Create the object
			SCODE sc = CoCreateInstance(clsid, NULL, CLSCTX_ALL | CLSCTX_REMOTE_SERVER,
				pSrc->vt == VT_UNKNOWN ? IID_IUnknown : IID_IDispatch,
				(void**)&pSrc->punkVal);
			if (sc == E_INVALIDARG)
			{
				// may not support CLSCTX_REMOTE_SERVER, so try without
				sc = CoCreateInstance(clsid, NULL,
					CLSCTX_ALL & ~CLSCTX_REMOTE_SERVER,
					pSrc->vt == VT_UNKNOWN ? IID_IUnknown : IID_IDispatch,
					(void**)&pSrc->punkVal);
			}
			AfxCheckError(sc);

			TRY
			{
				// QI for IPersistStream or IPeristStreamInit
				sc = pSrc->punkVal->QueryInterface(
					IID_IPersistStream, (void**)&pPersistStream);
#ifndef _AFX_NO_OCC_SUPPORT
				if (FAILED(sc))
					sc = pSrc->punkVal->QueryInterface(
						IID_IPersistStreamInit, (void**)&pPersistStream);
#endif
				AfxCheckError(sc);

				// Always assumes object is dirty
				AfxCheckError(pPersistStream->Load(&stm));
			}
			CATCH_ALL(e)
			{
				// Clean up
				if (pPersistStream != NULL)
					pPersistStream->Release();

				pSrc->punkVal->Release();
				THROW_LAST();
			}
			END_CATCH_ALL

			pPersistStream->Release();
		}
		return ar;

	case VT_EMPTY:
	case VT_NULL:
		// do nothing
		return ar;

	default:
		ASSERT(FALSE);
		return ar;
	}
}


//////////////////////////////////////////////////////////////////////////////
// CComBSTR support

#ifdef __ATLBASE_H__

CArchive& AFXAPI operator<<(CArchive& ar, CComBSTR string)
{
	ar << (DWORD)string.Length();
	if( string.Length() > 0 )
		ar.Write(string.m_str, string.Length()*sizeof(OLECHAR));
	return ar;
}

CArchive& AFXAPI operator>>(CArchive& ar, CComBSTR& string)
{
	DWORD length;
	ar >> length;
	if( length > 0 )
	{
		BSTR temp = string.Detach();
		SysReAllocStringLen( &temp, NULL, length );
		ar.EnsureRead(temp, length*sizeof(OLECHAR));
		string.Attach( temp );
	}
	else
		string.Empty();
	return ar;
}

#endif // __ATLBASE_H__

/////////////////////////////////////////////////////////////////////////////
// COleVariant Helpers
template <> void AFXAPI CopyElements<COleVariant> (COleVariant* pDest, const COleVariant* pSrc, INT_PTR nCount)
{
	ENSURE_ARG(nCount == 0 || pDest != NULL && pSrc != NULL);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(COleVariant)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(COleVariant)));

	for (; nCount--; ++pDest, ++pSrc)
		*pDest = *pSrc;
}

template <> void AFXAPI SerializeElements<COleVariant> (CArchive& ar, COleVariant* pElements, INT_PTR nCount)
{
	ENSURE_ARG(nCount == 0 || pElements != NULL);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(COleVariant)));

	if (ar.IsStoring())
	{
		for (; nCount--; ++pElements)
			ar << *pElements;
	}
	else
	{
		for (; nCount--; ++pElements)
			ar >> *pElements;
	}
}

#ifdef _DEBUG
template <> void AFXAPI DumpElements<COleVariant> (CDumpContext& dc, const COleVariant* pElements, INT_PTR nCount)
{
	ENSURE_ARG(nCount == 0 || pElements != NULL);
	for (; nCount--; ++pElements)
		dc << *pElements;
}
#endif // _DEBUG

template<> UINT AFXAPI HashKey<const struct tagVARIANT&> (const struct tagVARIANT& var)
{
	switch (var.vt)
	{
	case VT_EMPTY:
	case VT_NULL:
		return 0;
	case VT_I2:
		return HashKey<DWORD>((DWORD)var.iVal);
	case VT_I4:
		return HashKey<DWORD>((DWORD)var.lVal);
	case VT_R4:
		return (UINT)(var.fltVal / 16);
	case VT_R8:
	case VT_CY:
		return (UINT)(var.dblVal / 16);
	case VT_BOOL:
		return HashKey<DWORD>((DWORD)V_BOOL(&var));
	case VT_ERROR:
		return HashKey<DWORD>((DWORD)var.scode);
	case VT_DATE:
		return (UINT)(var.date / 16);
	case VT_BSTR:
		return HashKey<LPCOLESTR>(var.bstrVal);
	case VT_DISPATCH:
	case VT_UNKNOWN:
#ifdef _WIN64
		return HashKey<DWORD_PTR>((DWORD_PTR)var.punkVal);
#else
		return HashKey<DWORD>((DWORD)(DWORD_PTR)var.punkVal);
#endif
	default:
		// No support for VT_BYREF, VT_ARRAY, VT_VARIANT, VT_DECIMAL, & VT_UI1
		ASSERT(FALSE);

		// Fall through
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// COleCurrency class (internally currency is 8-byte int scaled by 10,000)

COleCurrency::COleCurrency(long nUnits, long nFractionalUnits)
{
	SetCurrency(nUnits, nFractionalUnits);
	SetStatus(valid);
}

const COleCurrency& COleCurrency::operator=(CURRENCY cySrc)
{
	m_cur = cySrc;
	SetStatus(valid);
	return *this;
}

const COleCurrency& COleCurrency::operator=(const COleCurrency& curSrc)
{
	m_cur = curSrc.m_cur;
	m_status = curSrc.m_status;
	return *this;
}

const COleCurrency& COleCurrency::operator=(const VARIANT& varSrc)
{
	if (varSrc.vt != VT_CY)
	{
		TRY
		{
			COleVariant varTemp(varSrc);
			varTemp.ChangeType(VT_CY);
			m_cur = varTemp.cyVal;
			SetStatus(valid);
		}
		// Catch COleException from ChangeType, but not CMemoryException
		CATCH(COleException, e)
		{
			// Not able to convert VARIANT to CURRENCY
		 m_cur.int64 = 0;
			SetStatus(invalid);
			DELETE_EXCEPTION(e);
		}
		END_CATCH
	}
	else
	{
		m_cur = varSrc.cyVal;
		SetStatus(valid);
	}

	return *this;
}

BOOL COleCurrency::operator<(const COleCurrency& cur) const
{
	ASSERT(GetStatus() == valid);
	ASSERT(cur.GetStatus() == valid);

   return(m_cur.int64 < cur.m_cur.int64);
}

BOOL COleCurrency::operator>(const COleCurrency& cur) const
{
	ASSERT(GetStatus() == valid);
	ASSERT(cur.GetStatus() == valid);

   return(m_cur.int64 > cur.m_cur.int64);
}

BOOL COleCurrency::operator<=(const COleCurrency& cur) const
{
	ASSERT(GetStatus() == valid);
	ASSERT(cur.GetStatus() == valid);

   return(m_cur.int64 <= cur.m_cur.int64);
}

BOOL COleCurrency::operator>=(const COleCurrency& cur) const
{
	ASSERT(GetStatus() == valid);
	ASSERT(cur.GetStatus() == valid);

   return(m_cur.int64 >= cur.m_cur.int64);
}

COleCurrency COleCurrency::operator+(const COleCurrency& cur) const
{
	COleCurrency curResult;

	// If either operand Null, result Null
	if (GetStatus() == null || cur.GetStatus() == null)
	{
		curResult.SetStatus(null);
		return curResult;
	}

	// If either operand Invalid, result Invalid
	if (GetStatus() == invalid || cur.GetStatus() == invalid)
	{
		curResult.SetStatus(invalid);
		return curResult;
	}

	// Add separate CURRENCY components
   curResult.m_cur.int64 = m_cur.int64+cur.m_cur.int64;

	// Overflow if operands same sign and result sign different
	if (!((m_cur.Hi ^ cur.m_cur.Hi) & 0x80000000) &&
		((m_cur.Hi ^ curResult.m_cur.Hi) & 0x80000000))
	{
		curResult.SetStatus(invalid);
	}

	return curResult;
}

COleCurrency COleCurrency::operator-(const COleCurrency& cur) const
{
	COleCurrency curResult;

	// If either operand Null, result Null
	if (GetStatus() == null || cur.GetStatus() == null)
	{
		curResult.SetStatus(null);
		return curResult;
	}

	// If either operand Invalid, result Invalid
	if (GetStatus() == invalid || cur.GetStatus() == invalid)
	{
		curResult.SetStatus(invalid);
		return curResult;
	}

	// Subtract separate CURRENCY components
   curResult.m_cur.int64 = m_cur.int64-cur.m_cur.int64;

	// Overflow if operands not same sign and result not same sign
	if (((m_cur.Hi ^ cur.m_cur.Hi) & 0x80000000) &&
		((m_cur.Hi ^ curResult.m_cur.Hi) & 0x80000000))
	{
		curResult.SetStatus(invalid);
	}

	return curResult;
}

COleCurrency COleCurrency::operator-() const
{
	// If operand not Valid, just return
	if (!GetStatus() == valid)
		return *this;

	COleCurrency curResult;

	// Negating MIN_CURRENCY,will set invalid
   if (m_cur.int64 == _I64_MIN)
	{
		curResult.SetStatus(invalid);
	}

   curResult.m_cur.int64 = -m_cur.int64;

	return curResult;
}

COleCurrency COleCurrency::operator*(long nOperand) const
{
	// If operand not Valid, just return
	if (GetStatus() != valid)
		return *this;

	COleCurrency curResult(m_cur);

	// Return now if one operand is 0 (optimization)
   if ((m_cur.int64 == 0) || (nOperand == 0))
	{
		curResult.m_cur.int64 = 0;
		return curResult;
	}

   ULONGLONG nAbsCur;  // |m_cur.int64|
	ULONG nAbsOp;  // |nOperand|
   ULONGLONG nTempHi;  // Product of nAbsOp and high-order 32 bits of nAbsCur
   ULONGLONG nTempLo;  // Product of nAbsOp and low-order 32 bits of nAbsCur
   ULONGLONG nTempProduct;  // Sum of both partial products
   bool bProductNegative;
   bool bOverflow;

   if( (nOperand^m_cur.Hi)&0x80000000 )
   {
	  bProductNegative = true;
   }
   else
   {
	  bProductNegative = false;
   }
   bOverflow = false;

	// Compute absolute values.
   nAbsCur = (m_cur.int64 < 0) ? -m_cur.int64 : m_cur.int64;
	nAbsOp = labs(nOperand);

   // Compute the high-order partial product
   nTempHi = (nAbsCur>>32)*nAbsOp;
   if( nTempHi > (ULONGLONG( LONG_MAX )+1) )
   {
	  // High-order multiplication overflowed
	  bOverflow = true;
   }
   else
   {
	  // Compute the low-order partial product.  Since nAbsOp is no larger 
	  // than 2**31, this multiplication can't overflow.
	  nTempLo = ULONGLONG( ULONG( nAbsCur ) )*nAbsOp;

	  // Sum the two partial products
	  nTempProduct = nTempLo+(nTempHi<<32);
	  if( nTempProduct < nTempLo )
	  {
		 // The sum overflowed the 64-bit result
		 bOverflow = true;
	  }
	  else
	  {
		 // At this point, nTempProduct may be still be out of range of a 
		 // positive signed 64-bit integer, but we do know that we haven't 
		 // overflowed out of our unsigned 64-bit integer variable.  
		 // If nTempProduct is greater than _I64_MAX, it will appear to be
		 // a negative signed 64-bit integer, so our result will appear to
		 // have the wrong sign.  The special case of nTempProduct == 
		 // -_I64_MIN works correctly, since negating that number is a NOP.
		 // That will

		 // Try to give the result the correct sign.
		 if( bProductNegative )
		 {
			curResult.m_cur.int64 = -LONGLONG( nTempProduct );
			// Possible cases:
			//   a) nTempProduct <= _I64_MAX: No problem.
			//   b) nTempProduct > -_I64_MIN: The result of the negation will 
			//      be positive, which will fail our check for the correct
			//      sign (which we'll do below).
			//   c) nTempProduct == -I64_MIN: The result of the negation will
			//      be _I64_MIN, which is the correct result.
		 }
		 else
		 {
			curResult.m_cur.int64 = nTempProduct;
			// Possible cases:
			//   a) nTempProduct <= _I64_MAX: No problem.
			//   b) nTempProduct > _I64_MAX: The result of the signed result
			//      will be negative, which will fail our check for the 
			//      correct sign (which we'll do below).
		 }
		 if( (curResult.m_cur.Hi^m_cur.Hi^nOperand)&0x80000000 )
		 {
			// The sign of the result isn't what we wanted, so there must have
			// been an overflow.
			bOverflow = true;
		 }
	  }
   }

   if( bOverflow )
   {
	  curResult.SetStatus( invalid );
	  if( bProductNegative )
	  {
		 curResult.m_cur.int64 = _I64_MIN;
	  }
	  else
	  {
		 curResult.m_cur.int64 = _I64_MAX;
	  }
   }

	return curResult;
}

COleCurrency COleCurrency::operator/(long nOperand) const
{
	// If operand not Valid, just return
	if (!GetStatus() == valid)
		return *this;

	COleCurrency curResult;

	// Check for divide by 0
	if (nOperand == 0)
	{
		curResult.SetStatus(invalid);

		// Set to maximum negative value
	  curResult.m_cur.int64 = _I64_MIN;

		return curResult;
	}

   // Check for MIN_CURRENCY/-1
   if ((nOperand == -1) && (m_cur.int64 == _I64_MIN))
   {
	  curResult.SetStatus(invalid);

	  curResult.m_cur.int64 = _I64_MAX;

	  return curResult;
   }

   curResult.m_cur.int64 = m_cur.int64/nOperand;

	return curResult;
}

void COleCurrency::SetCurrency(long nUnits, long nFractionalUnits)
{
	COleCurrency curUnits;              // Initializes to 0
	COleCurrency curFractionalUnits;    // Initializes to 0

	// Set temp currency value to Units (need to multiply by 10,000)
	curUnits.m_cur.Lo = (DWORD)labs(nUnits);
	curUnits = curUnits * 10000;
	if (nUnits < 0)
		curUnits = -curUnits;

	curFractionalUnits.m_cur.Lo = (DWORD)labs(nFractionalUnits);
	if (nFractionalUnits < 0)
		curFractionalUnits = -curFractionalUnits;

	// Now add together Units and FractionalUnits
	*this = curUnits + curFractionalUnits;

	SetStatus(valid);
}

BOOL COleCurrency::ParseCurrency(LPCTSTR lpszCurrency,
	DWORD dwFlags,  LCID lcid)
{
	SCODE sc;
	if ( FAILED(sc = VarCyFromStr(const_cast<LPOLESTR>(CStringW(lpszCurrency).GetString()),
		lcid, dwFlags, &m_cur)))
	{
		if (sc == DISP_E_TYPEMISMATCH)
		{
			// Can't convert string to CURRENCY, set 0 & invalid
		 m_cur.int64 = 0;
			SetStatus(invalid);
			return FALSE;
		}
		else if (sc == DISP_E_OVERFLOW)
		{
			// Can't convert string to CURRENCY, set max neg & invalid
		 m_cur.int64 = _I64_MIN;
			SetStatus(invalid);
			return FALSE;
		}
		else
		{
			TRACE(traceOle, 0, "\nCOleCurrency VarCyFromStr call failed.\n\t");
			if (sc == E_OUTOFMEMORY)
				AfxThrowMemoryException();
			else
				AfxThrowOleException(sc);
		}
	}

	SetStatus(valid);
	return TRUE;
}

CString COleCurrency::Format(DWORD dwFlags, LCID lcid) const
{
	CString strCur;

	// If null, return empty string
	if (GetStatus() == null)
		return strCur;

	// If invalid, return Currency resource string
	if (GetStatus() == invalid)
	{
		ENSURE(strCur.LoadString(AFX_IDS_INVALID_CURRENCY));
		return strCur;
	}

	COleVariant var;
	// Don't need to trap error. Should not fail due to type mismatch
	AfxCheckError(VarBstrFromCy(m_cur, lcid, dwFlags, &V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTR(&var);
}


// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleCurrency curSrc)
{
	dc << "\nCOleCurrency Object:";
	dc << "\n\tm_status = " << (long)curSrc.m_status;

	return dc << "\n\tCurrency Hi = " << curSrc.m_cur.Hi << ", Lo = " << curSrc.m_cur.Lo;
}
#endif // _DEBUG

CArchive& AFXAPI operator<<(CArchive& ar, COleCurrency curSrc)
{
	ar << (long)curSrc.m_status;
	ar << curSrc.m_cur.Hi;
	return ar << curSrc.m_cur.Lo;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleCurrency& curSrc)
{
	ar >> (long&)curSrc.m_status;
	ar >> curSrc.m_cur.Hi;
	return ar >> curSrc.m_cur.Lo;
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTime dateSrc)
{
	dc << "\nCOleDateTime Object:";
	dc << "\n\tm_status = " << (long)dateSrc.m_status;

	COleVariant var(dateSrc);
	var.ChangeType(VT_BSTR);

	return dc << "\n\tdate = " << var.bstrVal;
}
#endif // _DEBUG

CArchive& AFXAPI operator<<(CArchive& ar, COleDateTime dateSrc)
{
	ar << (long)dateSrc.m_status;
	return ar << dateSrc.m_dt;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTime& dateSrc)
{
	ar >> (long&)dateSrc.m_status;
	return ar >> dateSrc.m_dt;
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTimeSpan dateSpanSrc)
{
	dc << "\nCOleDateTimeSpan Object:";
	dc << "\n\tm_status = " << (long)dateSpanSrc.m_status;
	COleVariant var(dateSpanSrc.m_span);
	var.ChangeType(VT_BSTR);

	return dc << "\n\tdateSpan = " << var.bstrVal;
}
#endif // _DEBUG

CArchive& AFXAPI operator<<(CArchive& ar, COleDateTimeSpan dateSpanSrc)
{
	ar << (long)dateSpanSrc.m_status;
	return ar << dateSpanSrc.m_span;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTimeSpan& dateSpanSrc)
{
	ar >> (long&)dateSpanSrc.m_status;
	return ar >> dateSpanSrc.m_span;
}

/////////////////////////////////////////////////////////////////////////////
// COleSafeArray class

COleSafeArray::COleSafeArray(const SAFEARRAY& saSrc, VARTYPE vtSrc)
{
	AfxSafeArrayInit(this);
	vt = (VARTYPE)(vtSrc | VT_ARRAY);
	AfxCheckError(::SafeArrayCopy((LPSAFEARRAY)&saSrc, &parray));
	m_dwDims = GetDim();
	m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(LPCSAFEARRAY pSrc, VARTYPE vtSrc)
{
	AfxSafeArrayInit(this);
	vt = (VARTYPE)(vtSrc | VT_ARRAY);
	AfxCheckError(::SafeArrayCopy((LPSAFEARRAY)pSrc, &parray));
	m_dwDims = GetDim();
	m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(const COleSafeArray& saSrc)
{
	AfxSafeArrayInit(this);
	*this = saSrc;
	m_dwDims = GetDim();
	m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(const VARIANT& varSrc)
{
	AfxSafeArrayInit(this);
	*this = varSrc;
	m_dwDims = GetDim();
	m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(const COleVariant& varSrc)
{
	AfxSafeArrayInit(this);
	*this = varSrc;
	m_dwDims = GetDim();
	m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(LPCVARIANT pSrc)
{
	AfxSafeArrayInit(this);
	*this = pSrc;
	m_dwDims = GetDim();
	m_dwElementSize = GetElemSize();
}

// Operations
void COleSafeArray::Attach(VARIANT& varSrc)
{
	ASSERT(varSrc.vt & VT_ARRAY);
	
	if(!(varSrc.vt & VT_ARRAY))
		AfxThrowInvalidArgException();		
		
	// Free up previous safe array if necessary
	Clear();

	// give control of data to COleSafeArray 
	Checked::memcpy_s(this, sizeof(VARIANT), &varSrc, sizeof(varSrc));
	varSrc.vt = VT_EMPTY;
}

VARIANT COleSafeArray::Detach()
{
	VARIANT varResult = *this;
	vt = VT_EMPTY;
	return varResult;
}

void COleSafeArray::GetByteArray(CByteArray& bytes)
{
	LPVOID pSrc;
	LPVOID pDest;
	HRESULT hResult;
	ULONG nDim;
	LONG iLowerBound;
	LONG iUpperBound;
	LONG nElements;
	ULONG nBytes;

	ASSERT( V_ISARRAY(this) );

	hResult = ::SafeArrayAccessData(V_ARRAY(this), &pSrc);
	AfxCheckError(hResult);

	nDim = ::SafeArrayGetDim(V_ARRAY(this));
	ASSERT( (nDim == 0) || (nDim == 1) );

	if (nDim == 1)
	{
		::SafeArrayGetLBound(V_ARRAY(this), 1, &iLowerBound);
		::SafeArrayGetUBound(V_ARRAY(this), 1, &iUpperBound);
		nElements = (iUpperBound-iLowerBound)+1;
		nBytes = nElements*::SafeArrayGetElemsize(V_ARRAY(this));
		bytes.SetSize( nBytes );
		pDest = bytes.GetData();
		Checked::memcpy_s(pDest, nBytes, pSrc, nBytes);
	}
	else
	{
		bytes.SetSize(0);
	}

	::SafeArrayUnaccessData(V_ARRAY(this));
}

// Assignment operators
COleSafeArray& COleSafeArray::operator=(const COleSafeArray& saSrc)
{
	ASSERT(saSrc.vt & VT_ARRAY);

	if(!(saSrc.vt & VT_ARRAY))
		AfxThrowInvalidArgException();		

	AfxCheckError(::VariantCopy(this, (LPVARIANT)&saSrc));
	return *this;
}

COleSafeArray& COleSafeArray::operator=(const VARIANT& varSrc)
{
	ASSERT(varSrc.vt & VT_ARRAY);

	if(!(varSrc.vt & VT_ARRAY))
		AfxThrowInvalidArgException();		

	AfxCheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
	return *this;
}

COleSafeArray& COleSafeArray::operator=(LPCVARIANT pSrc)
{
	ASSERT(pSrc->vt & VT_ARRAY);

	if(!(pSrc->vt & VT_ARRAY))
		AfxThrowInvalidArgException();		

	AfxCheckError(::VariantCopy(this, (LPVARIANT)pSrc));
	return *this;
}

COleSafeArray& COleSafeArray::operator=(const COleVariant& varSrc)
{
	ASSERT(varSrc.vt & VT_ARRAY);

	if(!(varSrc.vt & VT_ARRAY))
		AfxThrowInvalidArgException();		

	AfxCheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
	return *this;
}

// Comparison operators
BOOL COleSafeArray::operator==(const SAFEARRAY& saSrc) const
{
	return _AfxCompareSafeArrays(parray, (LPSAFEARRAY)&saSrc);
}

BOOL COleSafeArray::operator==(LPCSAFEARRAY pSrc) const
{
	return _AfxCompareSafeArrays(parray, (LPSAFEARRAY)pSrc);
}

BOOL COleSafeArray::operator==(const COleSafeArray& saSrc) const
{
	if (vt != saSrc.vt)
		return FALSE;

	return _AfxCompareSafeArrays(parray, saSrc.parray);
}

BOOL COleSafeArray::operator==(const VARIANT& varSrc) const
{
	if (vt != varSrc.vt)
		return FALSE;

	return _AfxCompareSafeArrays(parray, varSrc.parray);
}

BOOL COleSafeArray::operator==(LPCVARIANT pSrc) const
{
	if (vt != pSrc->vt)
		return FALSE;

	return _AfxCompareSafeArrays(parray, pSrc->parray);
}

BOOL COleSafeArray::operator==(const COleVariant& varSrc) const
{
	if (vt != varSrc.vt)
		return FALSE;

	return _AfxCompareSafeArrays(parray, varSrc.parray);
}

#ifdef _DEBUG
void _AfxDumpSafeArrayElement(CDumpContext& dc, COleSafeArray& saSrc,
   long* piIndices)
{
   BYTE* pbData;

#pragma warning(push)
#pragma warning(disable:4068)
#pragma prefast(push)
#pragma prefast(disable:255, "alloca simple and efficient here, no need for __try in debug code")
   pbData = (BYTE*)_alloca( saSrc.GetElemSize() );
#pragma prefast(pop)
#pragma warning(pop)

   saSrc.GetElement(piIndices, pbData);
   switch(saSrc.vt&(~VT_ARRAY))
   {
   case VT_BOOL:
	  dc << *((VARIANT_BOOL*)pbData);
	  break;

   case VT_I1:
	  dc << *((char*)pbData);
	  break;

   case VT_I2:
	  dc << *((short*)pbData);
	  break;

   case VT_I4:
	  dc << *((long*)pbData);
	  break;

   case VT_I8:
	  dc << *((LONGLONG*)pbData);
	  break;

   case VT_UI1:
	  dc << *((BYTE*)pbData);
	  break;

   case VT_UI2:
	  dc << *((WORD*)pbData);
	  break;

   case VT_UI4:
	  dc << *((DWORD*)pbData);
	  break;

   case VT_UI8:
	  dc << *((ULONGLONG*)pbData);
	  break;

   case VT_R4:
	  dc << *((float*)pbData);
	  break;

   case VT_R8:
	  dc << *((double*)pbData);
	  break;

   case VT_CY:
	  {
		 COleVariant var;

		 var.vt = VT_CY;
		 var.cyVal = *((CY*)pbData);
		 var.ChangeType(VT_BSTR);
		 dc << var.bstrVal;
	  }
	  break;

   case VT_DATE:
	  {
		 COleVariant var;
		 var.vt = VT_DATE;
		 var.date = *((DATE*)pbData);
		 var.ChangeType(VT_BSTR);
		 dc << var.bstrVal;
	  }

   case VT_BSTR:
	  dc << *((BSTR*)pbData);
	  break;

   case VT_ERROR:
	  dc << *((SCODE*)pbData);
	  break;

   case VT_DISPATCH:
   case VT_UNKNOWN:
	  dc << *((IUnknown**)pbData);
	  break;

   case VT_VARIANT:
	  {
		 COleVariant var;

		 var = *((VARIANT*)pbData);
		 dc << var;
	  }
	  break;

   default:
	  ASSERT(FALSE);
	  break;
   }
}

CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleSafeArray& saSrc)
{
   long iDimension;
   long nDimensions;
   long* piLBounds;
   long* piUBounds;
   long* piIndices;
   BOOL bWrapped;

   dc << "\nCOleSafeArray Object:";
   dc << "\n\tvt = " << saSrc.vt;
   dc << "\n\tbounds:";

   nDimensions = saSrc.GetDim();
   if (nDimensions > (LONG_MAX / sizeof(long)))
   {
	   AfxThrowMemoryException();
   }

#pragma warning(push)
#pragma warning(disable:4068)
#pragma prefast(push)
#pragma prefast(disable:255, "alloca simple and efficient here, no need for __try in debug code")
   piLBounds = (long*)_alloca( nDimensions*sizeof( long ) );
   piUBounds = (long*)_alloca( nDimensions*sizeof( long ) );
   piIndices = (long*)_alloca( nDimensions*sizeof( long ) );
#pragma prefast(pop)
#pragma warning(pop)
   // Dump the bounds
   for( iDimension = 0; iDimension < nDimensions; iDimension++ )
   {
	  saSrc.GetLBound( iDimension+1, &piLBounds[iDimension] );
	  saSrc.GetUBound( iDimension+1, &piUBounds[iDimension] );
	  dc << "\n\t(" << piLBounds[iDimension] << ", " <<
		 piUBounds[iDimension] << ")";
   }

   if( dc.GetDepth() > 0 )
   {
	  // Dump the contents of the array.
	  for( iDimension = 0; iDimension < nDimensions; iDimension++ )
	  {
		 piIndices[iDimension] = piLBounds[iDimension];
	  }

	  while( piIndices[0] <= piUBounds[0] )
	  {
		 dc << "\n\t";
		 for( iDimension = 0; iDimension < nDimensions; iDimension++ )
		 {
			dc << "[" << piIndices[iDimension] << "]";
		 }
		 dc << " = ";

		 // Dump the value of the element
		 _AfxDumpSafeArrayElement(dc, saSrc, piIndices);

		 // Increment the rightmost index, with wraparound and carry logic
		 iDimension = nDimensions-1;
		 bWrapped = TRUE;
		 do
		 {
			bWrapped = FALSE;
			piIndices[iDimension]++;
			if( piIndices[iDimension] > piUBounds[iDimension] )
			{
			   if( iDimension > 0 )
			   {
				  // We've overstepped the bounds of this dimension, so wrap
				  // around to the lower bound and make sure to increment the
				  // next dimension to the left.
				  bWrapped = TRUE;
				  piIndices[iDimension] = piLBounds[iDimension];
				  iDimension--;
			   }
			}
		 } while( bWrapped && (iDimension >= 0) );
	  }
   }

   return dc;
}
#endif // _DEBUG

void COleSafeArray::CreateOneDim(VARTYPE vtSrc, DWORD dwElements,
	const void* pvSrcData, long nLBound)
{
	ENSURE(dwElements > 0);
	
	if(!(dwElements > 0))
		AfxThrowInvalidArgException();
			
	// Setup the bounds and create the array
	SAFEARRAYBOUND rgsabound;
	rgsabound.cElements = dwElements;
	rgsabound.lLbound = nLBound;
	Create(vtSrc, 1, &rgsabound);

	// Copy over the data if neccessary
	if (pvSrcData != NULL)
	{
		void* pvDestData;
		AccessData(&pvDestData);
           
		 
		unsigned __int64 tmp_64=static_cast<unsigned __int64>(GetElemSize()) * static_cast<unsigned __int64>(dwElements);
	     
		ENSURE(tmp_64<=INT_MAX); //no overflow ENSURE  
	    

		Checked::memcpy_s(pvDestData, static_cast<size_t>(tmp_64), 
			pvSrcData, static_cast<size_t>(tmp_64));
		UnaccessData();
	}
}

DWORD COleSafeArray::GetOneDimSize()
{
	ENSURE(GetDim() == 1);

	long nUBound, nLBound;

	GetUBound(1, &nUBound);
	GetLBound(1, &nLBound);

	return nUBound + 1 - nLBound;
}

void COleSafeArray::ResizeOneDim(DWORD dwElements)
{
	ASSERT(GetDim() == 1);

	if(!(GetDim() == 1))
		AfxThrowInvalidArgException();

	SAFEARRAYBOUND rgsabound;

	rgsabound.cElements = dwElements;
	rgsabound.lLbound = 0;

	Redim(&rgsabound);
}

void COleSafeArray::Create(VARTYPE vtSrc, DWORD dwDims, DWORD* rgElements)
{
	ASSERT(rgElements != NULL);

	if(rgElements == NULL)
		AfxThrowInvalidArgException();
		
	// Allocate and fill proxy array of bounds (with lower bound of zero)
	SAFEARRAYBOUND* rgsaBounds = new SAFEARRAYBOUND[dwDims];

	for (DWORD dwIndex = 0; dwIndex < dwDims; dwIndex++)
	{
		// Assume lower bound is 0 and fill in element count
		rgsaBounds[dwIndex].lLbound = 0;	
		rgsaBounds[dwIndex].cElements = rgElements[dwIndex];
	}

	TRY
	{
		Create(vtSrc, dwDims, rgsaBounds);
	}
	CATCH_ALL(e)
	{
		// Must free up memory
		delete[] rgsaBounds;
		THROW_LAST();
	}
	END_CATCH_ALL

	delete[] rgsaBounds;
}

void COleSafeArray::Create(VARTYPE vtSrc, DWORD dwDims, SAFEARRAYBOUND* rgsabound)
{
	ASSERT(dwDims > 0);
	ASSERT(rgsabound != NULL);

	// Validate the VARTYPE for SafeArrayCreate call
	ASSERT(!(vtSrc & VT_ARRAY));
	ASSERT(!(vtSrc & VT_BYREF));
	ASSERT(!(vtSrc & VT_VECTOR));
	ASSERT(vtSrc != VT_EMPTY);
	ASSERT(vtSrc != VT_NULL);
	
	if(dwDims == 0 			|| 
		rgsabound == NULL 	|| 
		(vtSrc & VT_ARRAY) 	|| 
		(vtSrc & VT_BYREF) 	|| 
		(vtSrc & VT_VECTOR) 	|| 
		vtSrc == VT_EMPTY 	|| 
		vtSrc == VT_NULL)
	{
		AfxThrowInvalidArgException();
	}
		
	// Free up old safe array if necessary
	Clear();

	parray = ::SafeArrayCreate(vtSrc, dwDims, rgsabound);

	if (parray == NULL)
		AfxThrowMemoryException();

	vt = unsigned short(vtSrc | VT_ARRAY);
	m_dwDims = dwDims;
	m_dwElementSize = GetElemSize();
}

void COleSafeArray::AccessData(void** ppvData)
{
	AfxCheckError(::SafeArrayAccessData(parray, ppvData));
}

void COleSafeArray::UnaccessData()
{
	AfxCheckError(::SafeArrayUnaccessData(parray));
}

void COleSafeArray::AllocData()
{
	AfxCheckError(::SafeArrayAllocData(parray));
}

void COleSafeArray::AllocDescriptor(DWORD dwDims)
{
	AfxCheckError(::SafeArrayAllocDescriptor(dwDims, &parray));
}

void COleSafeArray::Copy(LPSAFEARRAY* ppsa)
{
	AfxCheckError(::SafeArrayCopy(parray, ppsa));
}

void COleSafeArray::GetLBound(DWORD dwDim, long* pLbound)
{
	AfxCheckError(::SafeArrayGetLBound(parray, dwDim, pLbound));
}

void COleSafeArray::GetUBound(DWORD dwDim, long* pUbound)
{
	AfxCheckError(::SafeArrayGetUBound(parray, dwDim, pUbound));
}

void COleSafeArray::GetElement(long* rgIndices, void* pvData)
{
	AfxCheckError(::SafeArrayGetElement(parray, rgIndices, pvData));
}

void COleSafeArray::PtrOfIndex(long* rgIndices, void** ppvData)
{
	AfxCheckError(::SafeArrayPtrOfIndex(parray, rgIndices, ppvData));
}

void COleSafeArray::PutElement(long* rgIndices, void* pvData)
{
	AfxCheckError(::SafeArrayPutElement(parray, rgIndices, pvData));
}

void COleSafeArray::Redim(SAFEARRAYBOUND* psaboundNew)
{
	AfxCheckError(::SafeArrayRedim(parray, psaboundNew));
}

void COleSafeArray::Lock()
{
	AfxCheckError(::SafeArrayLock(parray));
}

void COleSafeArray::Unlock()
{
	AfxCheckError(::SafeArrayUnlock(parray));
}

void COleSafeArray::Destroy()
{
	AfxCheckError(::SafeArrayDestroy(parray));
	// The underlying SafeArray object was destroyed, so we need to detach the object to void operating on it anymore.
	// We don't care the destroyed object, so we can just simply call Detach after ::SafeArrayDestroy to set vt to VT_EMPTY.
	Detach();
}

void COleSafeArray::DestroyData()
{
	AfxCheckError(::SafeArrayDestroyData(parray));
}

void COleSafeArray::DestroyDescriptor()
{
	AfxCheckError(::SafeArrayDestroyDescriptor(parray));
}

///////////////////////////////////////////////////////////////////////////////
// COleSafeArray Helpers
void AFXAPI AfxSafeArrayInit(COleSafeArray* psa)
{
	if(psa != NULL)
		memset(psa, 0, sizeof(*psa));
}

/////////////////////////////////////////////////////////////////////////////
// Simple field formatting to text item - see dlgdata.cpp for base types

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleDateTime& value)
{
	ENSURE_ARG(pDX != NULL);
	pDX->PrepareEditCtrl(nIDC);
   HWND hWndCtrl;
   pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		CString strTemp;

		::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
		strTemp.ReleaseBuffer();

		if (!value.ParseDateTime(strTemp))  // throws exception
		{
			// Can't convert string to datetime
			AfxMessageBox(AFX_IDP_PARSE_DATETIME);
			pDX->Fail();    // throws exception
		}
	}
	else
	{
		CString strTemp = value.Format();
		AfxSetWindowText(hWndCtrl, strTemp);
	}
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, FILETIME& value)
{
	ENSURE_ARG(pDX != NULL);
	COleDateTime dt;
	SYSTEMTIME st;

	pDX->PrepareEditCtrl(nIDC);
   HWND hWndCtrl;
   pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		CString strTemp;

		::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
		strTemp.ReleaseBuffer();

		if (!dt.ParseDateTime(strTemp))  // throws exception
		{
			// Can't convert string to datetime
			AfxMessageBox(AFX_IDP_PARSE_DATETIME);
			pDX->Fail();    // throws exception
		}
		dt.GetAsSystemTime(st);
		SystemTimeToFileTime(&st, &value);
	}
	else
	{
		FileTimeToSystemTime(&value, &st);
		dt.SetDateTime(st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
		CString strTemp = dt.Format();
		AfxSetWindowText(hWndCtrl, strTemp);
	}
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleCurrency& value)
{
	pDX->PrepareEditCtrl(nIDC);
   HWND hWndCtrl;
   pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		CString strTemp;

		::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
		strTemp.ReleaseBuffer();

		if (!value.ParseCurrency(strTemp))  // throws exception
		{
			// Can't convert string to currency
			AfxMessageBox(AFX_IDP_PARSE_CURRENCY);
			pDX->Fail();    // throws exception
		}
	}
	else
	{
		CString strTemp = value.Format();
		AfxSetWindowText(hWndCtrl, strTemp);
	}
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DECIMAL& value)
{
	pDX->PrepareEditCtrl(nIDC);
   HWND hWndCtrl;
   pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		CString strTemp;

		::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
		strTemp.ReleaseBuffer();

		BSTR bstr;
		HRESULT hResult;

		bstr = strTemp.AllocSysString();
		hResult = VarDecFromStr(bstr, ::GetThreadLocale(), 0, &value);
		::SysFreeString(bstr);
		if (FAILED(hResult))
		{
			AfxMessageBox(AFX_IDP_PARSE_REAL);
			pDX->Fail();
		}
	}
	else
	{
		BSTR bstr;
		HRESULT hResult;

		hResult = VarBstrFromDec(&value, ::GetThreadLocale(), 0, &bstr);
		if (FAILED(hResult))
		{
			TRACE(traceOle, 0, "Warning: invalid DECIMAL number for control ID %d.\n", pDX->m_idLastControl);
			return;
		}

		CString strText(bstr);
		::SysFreeString(bstr);
		AfxSetWindowText(hWndCtrl, strText);
	}
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, GUID& value)
{
	pDX->PrepareEditCtrl(nIDC);
   HWND hWndCtrl;
   pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		CString strTemp;

		::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
		strTemp.ReleaseBuffer();

		HRESULT hResult;

		hResult = CLSIDFromString(const_cast<LPOLESTR>(CStringW(strTemp).GetString()), &value);
		if (FAILED(hResult))
		{
			AfxMessageBox(AFX_IDP_PARSE_GUID);
			pDX->Fail();
		}
	}
	else
	{
		OLECHAR szGUID[64];

		StringFromGUID2(value, szGUID, 64);
		AfxSetWindowText(hWndCtrl, CFixedStringT<CString, 64>(szGUID));
	}
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\plex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

// Collection support


#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CPlex

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT_PTR nMax, UINT_PTR cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	if (nMax == 0 || cbElement == 0)
	{
		AfxThrowInvalidArgException();
	}

	CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
			// may throw exception
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
	CPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleui2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// more User interface for COleClientItem

/////////////////////////////////////////////////////////////////////////////
// OLE Object Verb Menu helpers

// simple wrapper for OleUIAddVerbMenu API

void AFXAPI AfxOleSetEditMenu(COleClientItem* pItem, CMenu* pMenu,
	UINT iMenuItem, UINT nIDVerbMin, UINT nIDVerbMax, UINT nIDConvert)
{
	ASSERT_VALID(pMenu);
	if (pItem != NULL)
		ASSERT_VALID(pItem);

	HMENU hmenuDummy;
	if (!::OleUIAddVerbMenu(pItem != NULL ? pItem->m_lpObject : NULL,
		NULL, pMenu->GetSafeHmenu(), iMenuItem,
		nIDVerbMin, nIDVerbMax, nIDConvert != 0, nIDConvert, &hmenuDummy))
	{
		// turn gray popup into gray disabled normal menu item
		TCHAR szBuffer[256];
		pMenu->GetMenuString(iMenuItem, szBuffer, _countof(szBuffer), MF_BYPOSITION);
		pMenu->DeleteMenu(iMenuItem, MF_BYPOSITION);
		pMenu->InsertMenu(
			iMenuItem, MF_BYPOSITION|MF_STRING|MF_GRAYED|MF_DISABLED,
			nIDVerbMin, szBuffer);
	}
}

/////////////////////////////////////////////////////////////////////////////
// UI message handlers

void COleDocument::OnUpdatePasteMenu(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(COleClientItem::CanPaste());
}

void COleDocument::OnUpdatePasteLinkMenu(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(COleClientItem::CanPasteLink());
}

void COleDocument::OnUpdateEditLinksMenu(CCmdUI* pCmdUI)
{
	POSITION pos = GetStartPosition();
	COleClientItem* pItem;
	while ((pItem = GetNextClientItem(pos)) != NULL)
	{
		if (pItem->GetType() == OT_LINK)
		{
			// we found a link!
			pCmdUI->Enable(TRUE);
			return;
		}
	}
	pCmdUI->Enable(FALSE);      // no links today
}

void COleDocument::OnEditLinks()
{
	ASSERT_VALID(this);

	COleLinksDialog dlg(this, GetRoutingView_());
	dlg.DoModal();
}

void COleDocument::OnEditConvert()
{
	ASSERT_VALID(this);

	// get selected item
	COleClientItem* pItem = GetPrimarySelectedItem(GetRoutingView_());
	if (pItem == NULL)
		return;

	// do conversion dialog & convert for that item
	COleConvertDialog dlg(pItem);
	if (dlg.DoModal() == IDOK)
		dlg.DoConvert(pItem);
}

void COleDocument::OnUpdateEditChangeIcon(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);

	pCmdUI->Enable(GetPrimarySelectedItem(GetRoutingView_()) != NULL);
}

void COleDocument::OnEditChangeIcon()
{
	ASSERT_VALID(this);

	// get selected item
	COleClientItem* pItem = GetPrimarySelectedItem(GetRoutingView_());
	if (pItem == NULL)
		return;

	// do conversion dialog & convert for that item
	COleChangeIconDialog dlg(pItem);
	if (dlg.DoModal() == IDOK)
		dlg.DoChangeIcon(pItem);
}

void COleDocument::OnUpdateObjectVerbMenu(CCmdUI* pCmdUI)
{
	if (pCmdUI->m_pMenu == NULL || pCmdUI->m_pParentMenu == NULL)
	{
		// not a menu or is on sub-menu (don't recurse)
		pCmdUI->ContinueRouting();
		return;
	}

	// check for single selection
	COleClientItem* pItem = GetPrimarySelectedItem(GetRoutingView_());
	if (pItem == NULL || pItem->GetType() == OT_STATIC)
	{
		// no selection, or is 'static' item
		pCmdUI->Enable(FALSE);
	}

	// only include Convert... if there is a handler for ID_OLE_EDIT_CONVERT
	UINT nConvertID = ID_OLE_EDIT_CONVERT;
	AFX_CMDHANDLERINFO info;
	if (!OnCmdMsg(ID_OLE_EDIT_CONVERT, CN_COMMAND, NULL, &info))
		nConvertID = 0;

	// update the menu
	AfxOleSetEditMenu(GetPrimarySelectedItem(GetRoutingView_()),
		pCmdUI->m_pMenu, pCmdUI->m_nIndex,
		ID_OLE_VERB_FIRST, ID_OLE_VERB_LAST, nConvertID);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\sockcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <stddef.h>



#define new DEBUG_NEW

#define _afxSockThreadState AfxGetModuleThreadState()
#define _AFX_SOCK_THREAD_STATE AFX_MODULE_THREAD_STATE

#pragma comment(lib, "wsock32.lib")

/////////////////////////////////////////////////////////////////////////////
// socket state cleanup

_AFX_SOCK_STATE::~_AFX_SOCK_STATE()
{
	if (m_pfnSockTerm != NULL)
		m_pfnSockTerm();
}

/////////////////////////////////////////////////////////////////////////////
// sockets globals and implementation helpers

void AFXAPI AfxSocketTerm()
{
	_AFX_SOCK_STATE* pState = _afxSockState.GetData();
	if (pState->m_hInstSOCK != NULL)
	{
		if (pState->m_pfnSockTerm != NULL)
			WSACleanup();
		FreeLibrary(pState->m_hInstSOCK);// handle of WSOCK32.DLL
		pState->m_hInstSOCK = NULL;
	}
}

#ifndef _AFXDLL
BOOL AFXAPI AfxSocketInit(WSADATA* lpwsaData)
#else
BOOL AFXAPI _AfxSocketInit(WSADATA* lpwsaData)
#endif
{
	_AFX_SOCK_STATE* pState = _afxSockState.GetData();
	if (pState->m_pfnSockTerm == NULL)
	{
		// initialize Winsock library
		WSADATA wsaData;
		if (lpwsaData == NULL)
			lpwsaData = &wsaData;

		WORD wVersionRequested = MAKEWORD(1, 1);
		int nResult = WSAStartup(wVersionRequested, lpwsaData);
		if (nResult != 0)
			return FALSE;

		if (LOBYTE(lpwsaData->wVersion) != 1 || HIBYTE(lpwsaData->wVersion) != 1)
		{
			WSACleanup();
			WSASetLastError (WSAVERNOTSUPPORTED);
			return FALSE;
		}

		// setup for termination of sockets
		pState->m_pfnSockTerm = &AfxSocketTerm;
	}

#ifndef _AFXDLL
	//BLOCK: setup maps and lists specific to socket state
	{
		_AFX_SOCK_THREAD_STATE* pThreadState = _afxSockThreadState;
		if (pThreadState->m_pmapSocketHandle == NULL)
			pThreadState->m_pmapSocketHandle = new CMapPtrToPtr;
		if (pThreadState->m_pmapDeadSockets == NULL)
			pThreadState->m_pmapDeadSockets = new CMapPtrToPtr;
		if (pThreadState->m_plistSocketNotifications == NULL)
			pThreadState->m_plistSocketNotifications = new CPtrList;
	}
#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket Construction

CAsyncSocket::CAsyncSocket()
{
	m_hSocket = INVALID_SOCKET;
}

BOOL CAsyncSocket::Create(UINT nSocketPort, int nSocketType,
	long lEvent, LPCTSTR lpszSocketAddress)
{
	if (Socket(nSocketType, lEvent))
	{
		if (Bind(nSocketPort,lpszSocketAddress))
			return TRUE;
		int nResult = GetLastError();
		Close();
		WSASetLastError(nResult);
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket Attributes

BOOL CAsyncSocket::Attach(SOCKET hSocket, long lEvent)
{
	ASSERT(hSocket != INVALID_SOCKET); 

	if (hSocket == INVALID_SOCKET)
	{
		WSASetLastError (WSA_INVALID_HANDLE);
		return FALSE;
	}

	m_hSocket = hSocket;
	CAsyncSocket::AttachHandle(hSocket, this);

	return AsyncSelect(lEvent);
}

SOCKET CAsyncSocket::Detach()
{
	SOCKET hSocket = m_hSocket;
	if (AsyncSelect(0))
	{
		CAsyncSocket::KillSocket(hSocket, this);
		m_hSocket = INVALID_SOCKET;
		return hSocket;
	}
	return INVALID_SOCKET;
}

BOOL CAsyncSocket::GetPeerName(CString& rPeerAddress, UINT& rPeerPort)
{
	SOCKADDR_IN sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetPeerName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		rPeerPort = ntohs(sockAddr.sin_port);
		rPeerAddress = inet_ntoa(sockAddr.sin_addr);
	}
	return bResult;
}

BOOL CAsyncSocket::GetSockName(CString& rSocketAddress, UINT& rSocketPort)
{
	SOCKADDR_IN sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetSockName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		rSocketPort = ntohs(sockAddr.sin_port);
		rSocketAddress = inet_ntoa(sockAddr.sin_addr);
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CAscynSocket Operations

BOOL CAsyncSocket::Accept(CAsyncSocket& rConnectedSocket,
	SOCKADDR* lpSockAddr, int* lpSockAddrLen)
{
	ASSERT(rConnectedSocket.m_hSocket == INVALID_SOCKET);
	ASSERT(CAsyncSocket::FromHandle(INVALID_SOCKET) == NULL);

	CAsyncSocket::AttachHandle(INVALID_SOCKET, &rConnectedSocket);
	if (CAsyncSocket::FromHandle(INVALID_SOCKET) == NULL)
	{
		// AttachHandle Call has failed
		return FALSE;
	}

	SOCKET hTemp = accept(m_hSocket, lpSockAddr, lpSockAddrLen);	

	if (hTemp == INVALID_SOCKET)
	{
		DWORD dwProblem = GetLastError();
		CAsyncSocket::DetachHandle(rConnectedSocket.m_hSocket, FALSE);
		rConnectedSocket.m_hSocket = INVALID_SOCKET;
		SetLastError(dwProblem);
	}
	else if (CAsyncSocket::FromHandle(INVALID_SOCKET) != NULL)
	{
		rConnectedSocket.m_hSocket = hTemp;
		CAsyncSocket::DetachHandle(INVALID_SOCKET, FALSE);
		CAsyncSocket::AttachHandle(hTemp, &rConnectedSocket);
	}

	return (hTemp != INVALID_SOCKET);
}

BOOL CAsyncSocket::Bind(UINT nSocketPort, LPCTSTR lpszSocketAddress)
{
	USES_CONVERSION_EX;

	SOCKADDR_IN sockAddr;
	memset(&sockAddr,0,sizeof(sockAddr));

	LPSTR lpszAscii;
	if (lpszSocketAddress != NULL)
	{
		lpszAscii = T2A_EX((LPTSTR)lpszSocketAddress, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (lpszAscii == NULL)
		{
			// OUT OF MEMORY
			WSASetLastError(ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}
	}
	else
	{
		lpszAscii = NULL;
	}

	sockAddr.sin_family = AF_INET;

	if (lpszAscii == NULL)
		sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	else
	{
		DWORD lResult = inet_addr(lpszAscii);
		if (lResult == INADDR_NONE)
		{
			WSASetLastError(WSAEINVAL);
			return FALSE;
		}
		sockAddr.sin_addr.s_addr = lResult;
	}

	sockAddr.sin_port = htons((u_short)nSocketPort);

	return Bind((SOCKADDR*)&sockAddr, sizeof(sockAddr));
}

void CAsyncSocket::Close()
{
	if (m_hSocket != INVALID_SOCKET)
	{
		VERIFY(SOCKET_ERROR != closesocket(m_hSocket));
		CAsyncSocket::KillSocket(m_hSocket, this);
		m_hSocket = INVALID_SOCKET;
	}
}

BOOL CAsyncSocket::Connect(LPCTSTR lpszHostAddress, UINT nHostPort)
{
	USES_CONVERSION_EX;

	ASSERT(lpszHostAddress != NULL);

	if (lpszHostAddress == NULL)
	{
		WSASetLastError (WSAEINVAL);
		return FALSE;
	}

	SOCKADDR_IN sockAddr;
	memset(&sockAddr,0,sizeof(sockAddr));

	LPSTR lpszAscii = T2A_EX((LPTSTR)lpszHostAddress, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if (lpszAscii == NULL)
	{
		WSASetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
	}

	sockAddr.sin_family = AF_INET;
	sockAddr.sin_addr.s_addr = inet_addr(lpszAscii);

	if (sockAddr.sin_addr.s_addr == INADDR_NONE)
	{
		LPHOSTENT lphost;
		lphost = gethostbyname(lpszAscii);
		if (lphost != NULL)
			sockAddr.sin_addr.s_addr = ((LPIN_ADDR)lphost->h_addr)->s_addr;
		else
		{
			WSASetLastError(WSAEINVAL);
			return FALSE;
		}
	}

	sockAddr.sin_port = htons((u_short)nHostPort);

	return Connect((SOCKADDR*)&sockAddr, sizeof(sockAddr));
}

int CAsyncSocket::Receive(void* lpBuf, int nBufLen, int nFlags)
{
	return recv(m_hSocket, (LPSTR)lpBuf, nBufLen, nFlags);
}

int CAsyncSocket::ReceiveFrom(void* lpBuf, int nBufLen, CString& rSocketAddress, UINT& rSocketPort, int nFlags)
{
	SOCKADDR_IN sockAddr;

	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	int nResult = ReceiveFrom(lpBuf, nBufLen, (SOCKADDR*)&sockAddr, &nSockAddrLen, nFlags);
	if(nResult != SOCKET_ERROR)
	{
		rSocketPort = ntohs(sockAddr.sin_port);
		rSocketAddress = inet_ntoa(sockAddr.sin_addr);
	}
	return nResult;
}

int CAsyncSocket::Send(const void* lpBuf, int nBufLen, int nFlags)
{
	return send(m_hSocket, (LPSTR)lpBuf, nBufLen, nFlags);
}

int CAsyncSocket::SendTo(const void* lpBuf, int nBufLen, UINT nHostPort, LPCTSTR lpszHostAddress, int nFlags)
{
	USES_CONVERSION_EX;

	SOCKADDR_IN sockAddr;

	memset(&sockAddr,0,sizeof(sockAddr));

	LPSTR lpszAscii;
	if (lpszHostAddress != NULL)
	{
		lpszAscii = T2A_EX((LPTSTR)lpszHostAddress, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (lpszAscii == NULL)
		{
			// OUT OF MEMORY
			WSASetLastError(ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}	
	}
	else
	{
		lpszAscii = NULL;
	}

	sockAddr.sin_family = AF_INET;

	if (lpszAscii == NULL)
		sockAddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
	else
	{
		sockAddr.sin_addr.s_addr = inet_addr(lpszAscii);
		if (sockAddr.sin_addr.s_addr == INADDR_NONE)
		{
			LPHOSTENT lphost;
			lphost = gethostbyname(lpszAscii);
			if (lphost != NULL)
				sockAddr.sin_addr.s_addr = ((LPIN_ADDR)lphost->h_addr)->s_addr;
			else
			{
				WSASetLastError(WSAEINVAL);
				return SOCKET_ERROR;
			}
		}
	}

	sockAddr.sin_port = htons((u_short)nHostPort);

	return SendTo(lpBuf, nBufLen, (SOCKADDR*)&sockAddr, sizeof(sockAddr), nFlags);
}

BOOL CAsyncSocket::AsyncSelect(long lEvent)
{
	ASSERT(m_hSocket != INVALID_SOCKET);

	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;
	ASSERT(pState->m_hSocketWindow != NULL);

	return WSAAsyncSelect(m_hSocket, pState->m_hSocketWindow,
		WM_SOCKET_NOTIFY, lEvent) != SOCKET_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket Overridable callbacks

void CAsyncSocket::OnReceive(int /*nErrorCode*/)
{
}

void CAsyncSocket::OnSend(int /*nErrorCode*/)
{
}

void CAsyncSocket::OnOutOfBandData(int /*nErrorCode*/)
{
}

void CAsyncSocket::OnAccept(int /*nErrorCode*/)
{
}

void CAsyncSocket::OnConnect(int /*nErrorCode*/)
{
}

void CAsyncSocket::OnClose(int /*nErrorCode*/)
{
}

/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket Implementation

CAsyncSocket::~CAsyncSocket()
{
	AFX_BEGIN_DESTRUCTOR

		if (m_hSocket != INVALID_SOCKET)
			Close();

	AFX_END_DESTRUCTOR
}

CAsyncSocket* PASCAL CAsyncSocket::LookupHandle(SOCKET hSocket, BOOL bDead)
{
	CAsyncSocket* pSocket;
	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;
	if (!bDead)
	{
		pSocket = (CAsyncSocket*)
			pState->m_pmapSocketHandle->GetValueAt((void*)hSocket);
		if (pSocket != NULL)
			return pSocket;
	}
	else
	{
		pSocket = (CAsyncSocket*)
			pState->m_pmapDeadSockets->GetValueAt((void*)hSocket);
		if (pSocket != NULL)
			return pSocket;
	}
	return NULL;
}

void PASCAL CAsyncSocket::AttachHandle(
	SOCKET hSocket, CAsyncSocket* pSocket, BOOL bDead)
{
	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;

	BOOL bEnable = AfxEnableMemoryTracking(FALSE);

	TRY 
	{
		if (!bDead)
		{
			ASSERT(CAsyncSocket::LookupHandle(hSocket, bDead) == NULL);
			if (pState->m_pmapSocketHandle->IsEmpty())
			{
				ASSERT(pState->m_pmapDeadSockets->IsEmpty());
				ASSERT(pState->m_hSocketWindow == NULL);

				CSocketWnd* pWnd = new CSocketWnd;
				pWnd->m_hWnd = NULL;

				if (!pWnd->CreateEx(0, AfxRegisterWndClass(0),
					_T("Socket Notification Sink"),
					WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL))
				{
					TRACE(traceSocket, 0, "Warning: unable to create socket notify window!\n");
					delete pWnd;
					AfxThrowResourceException();
				}

				ASSERT(pWnd->m_hWnd != NULL);
				ASSERT(CWnd::FromHandlePermanent(pWnd->m_hWnd) == pWnd);
				pState->m_hSocketWindow = pWnd->m_hWnd;
			}
			pState->m_pmapSocketHandle->SetAt((void*)hSocket, pSocket);
		}
		else
		{
			void* pvCount;
			INT_PTR nCount;
			if (pState->m_pmapDeadSockets->Lookup((void*)hSocket, pvCount))
			{
				nCount = (INT_PTR)pvCount;
				nCount++;
			}
			else
				nCount = 1;
			pState->m_pmapDeadSockets->SetAt((void*)hSocket, (void*)nCount);
		}
	}
	CATCH_ALL (e) 
	{ 
		AfxEnableMemoryTracking(bEnable); 
		THROW_LAST(); 
	} 
	END_CATCH_ALL

	AfxEnableMemoryTracking(bEnable);
}

void PASCAL CAsyncSocket::DetachHandle(SOCKET hSocket, BOOL bDead)
{
	ASSERT(CAsyncSocket::LookupHandle(hSocket, bDead) != NULL);

	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;
	if (!bDead)
	{
		pState->m_pmapSocketHandle->RemoveKey((void*)hSocket);
		if (pState->m_pmapSocketHandle->IsEmpty())
		{
			ASSERT(pState->m_hSocketWindow != NULL);
			CWnd* pWnd =
				CWnd::FromHandlePermanent(pState->m_hSocketWindow);
			ASSERT_VALID(pWnd);

			if (pWnd != NULL)
			{
				pWnd->DestroyWindow();
				delete pWnd;
			}

			pState->m_hSocketWindow = NULL;

			pState->m_pmapDeadSockets->RemoveAll();

			while (!pState->m_plistSocketNotifications->IsEmpty())
				delete pState->m_plistSocketNotifications->RemoveHead();
		}
	}
	else
	{
		void* pvCount;
		INT_PTR nCount;
		if (pState->m_pmapDeadSockets->Lookup((void*)hSocket, pvCount))
		{
			nCount = (INT_PTR)pvCount;
			nCount--;
			if (nCount == 0)
				pState->m_pmapDeadSockets->RemoveKey((void*)hSocket);
			else
				pState->m_pmapDeadSockets->SetAt((void*)hSocket, (void*)nCount);
		}
	}
}

void PASCAL CAsyncSocket::KillSocket(SOCKET hSocket, CAsyncSocket* pSocket)
{
	ASSERT(CAsyncSocket::LookupHandle(hSocket, FALSE) != NULL);

	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;

	CAsyncSocket::DetachHandle(hSocket, FALSE);
	if (pState->m_hSocketWindow != NULL)
	{
		::PostMessage(pState->m_hSocketWindow, WM_SOCKET_DEAD,
			(WPARAM)hSocket, 0L);
		CAsyncSocket::AttachHandle(hSocket, pSocket, TRUE);
	}
}

void PASCAL CAsyncSocket::DoCallBack(WPARAM wParam, LPARAM lParam)
{
	if (wParam == 0 && lParam == 0)
		return;

	// Has the socket be closed - lookup in dead handle list
	CAsyncSocket* pSocket = CAsyncSocket::LookupHandle((SOCKET)wParam, TRUE);

	// If yes ignore message
	if (pSocket != NULL)
		return;

	pSocket = CAsyncSocket::LookupHandle((SOCKET)wParam, FALSE);
	if (pSocket == NULL)
	{
		// Must be in the middle of an Accept call
		pSocket = CAsyncSocket::LookupHandle(INVALID_SOCKET, FALSE);
		ASSERT(pSocket != NULL);

		if(pSocket == NULL)
			return;
			
		pSocket->m_hSocket = (SOCKET)wParam;
		CAsyncSocket::DetachHandle(INVALID_SOCKET, FALSE);
		CAsyncSocket::AttachHandle(pSocket->m_hSocket, pSocket, FALSE);
	}

	int nErrorCode = WSAGETSELECTERROR(lParam);
	switch (WSAGETSELECTEVENT(lParam))
	{
	case FD_READ:
		{
			fd_set fds;
			int nReady;
			timeval timeout;

			timeout.tv_sec = 0;
			timeout.tv_usec = 0;

			FD_ZERO(&fds);
			FD_SET(pSocket->m_hSocket, &fds);
			nReady = select(0, &fds, NULL, NULL, &timeout);
			if (nReady == SOCKET_ERROR)
				nErrorCode = WSAGetLastError();
			if ((nReady == 1) || (nErrorCode != 0))
				pSocket->OnReceive(nErrorCode);
		}
		break;
	case FD_WRITE:
		pSocket->OnSend(nErrorCode);
		break;
	case FD_OOB:
		pSocket->OnOutOfBandData(nErrorCode);
		break;
	case FD_ACCEPT:
		pSocket->OnAccept(nErrorCode);
		break;
	case FD_CONNECT:
		pSocket->OnConnect(nErrorCode);
		break;
	case FD_CLOSE:
		pSocket->OnClose(nErrorCode);
		break;
	}
}

BOOL CAsyncSocket::Socket(int nSocketType, long lEvent,
	int nProtocolType, int nAddressFormat)
{
	ASSERT(m_hSocket == INVALID_SOCKET);

	m_hSocket = socket(nAddressFormat,nSocketType,nProtocolType);
	if (m_hSocket != INVALID_SOCKET)
	{
		CAsyncSocket::AttachHandle(m_hSocket, this, FALSE);
		return AsyncSelect(lEvent);
	}
	return FALSE;
}

#ifdef _DEBUG
void CAsyncSocket::AssertValid() const
{
	CObject::AssertValid();
	ASSERT(m_hSocket == INVALID_SOCKET || CAsyncSocket::FromHandle(m_hSocket) != NULL);
}

void CAsyncSocket::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_hSocket = ";
	if (m_hSocket == INVALID_SOCKET)
		dc << "INVALID_SOCKET\n";
	else
		dc << (void*)m_hSocket << "\n";
}
#endif //_DEBUG

int CAsyncSocket::ReceiveFromHelper(void* lpBuf, int nBufLen, SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags)
{
	return recvfrom(m_hSocket, (LPSTR)lpBuf, nBufLen, nFlags, lpSockAddr, lpSockAddrLen);
}

int CAsyncSocket::SendToHelper(const void* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags)
{
	return sendto(m_hSocket, (LPSTR)lpBuf, nBufLen, nFlags, lpSockAddr, nSockAddrLen);
}

BOOL CAsyncSocket::ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen)
{
	return connect(m_hSocket, lpSockAddr, nSockAddrLen) != SOCKET_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
// CSocket Construction

CSocket::CSocket()
{
	m_pbBlocking = NULL;
	m_nConnectError = -1;
	m_nTimeOut = 2000;
}

/////////////////////////////////////////////////////////////////////////////
// CSocket Operations

void CSocket::CancelBlockingCall()
{
	if (m_pbBlocking != NULL)
	{
		*m_pbBlocking = FALSE;
		m_pbBlocking = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSocket Overridable callbacks

BOOL CSocket::OnMessagePending()
{
	MSG msg;
	if (::PeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_REMOVE))
	{
		::DispatchMessage(&msg);
		return FALSE;   // usually return TRUE, but OnIdle usually causes WM_PAINTs
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CSocket Implementation

CSocket::~CSocket()
{
	AFX_BEGIN_DESTRUCTOR

		if (m_hSocket != INVALID_SOCKET)
			Close();

	AFX_END_DESTRUCTOR
}

BOOL CSocket::Accept(CAsyncSocket& rConnectedSocket, SOCKADDR* lpSockAddr, int* lpSockAddrLen)
{
	if (m_pbBlocking != NULL)
	{
		WSASetLastError(WSAEINPROGRESS);
		return FALSE;
	}
	while (!CAsyncSocket::Accept(rConnectedSocket, lpSockAddr, lpSockAddrLen))
	{
		if (GetLastError() == WSAEWOULDBLOCK)
		{
			if (!PumpMessages(FD_ACCEPT))
				return FALSE;
		}
		else
			return FALSE;
	}
	return TRUE;
}

void CSocket::Close()
{
	if (m_hSocket != INVALID_SOCKET)
	{
		CancelBlockingCall();

		VERIFY(AsyncSelect(0));
		CAsyncSocket::Close();
		m_hSocket = INVALID_SOCKET;
	}
}

int CSocket::Receive(void* lpBuf, int nBufLen, int nFlags)
{
	if (m_pbBlocking != NULL)
	{
		WSASetLastError(WSAEINPROGRESS);
		return  FALSE;
	}
	int nResult;
	while ((nResult = CAsyncSocket::Receive(lpBuf, nBufLen, nFlags)) == SOCKET_ERROR)
	{
		if (GetLastError() == WSAEWOULDBLOCK)
		{
			if (!PumpMessages(FD_READ))
				return SOCKET_ERROR;
		}
		else
			return SOCKET_ERROR;
	}
	return nResult;
}

int CSocket::Send(const void* lpBuf, int nBufLen, int nFlags)
{
	if (m_pbBlocking != NULL)
	{
		WSASetLastError(WSAEINPROGRESS);
		return  FALSE;
	}

	int nLeft, nWritten;
	PBYTE pBuf = (PBYTE)lpBuf;
	nLeft = nBufLen;

	while (nLeft > 0)
	{
		nWritten = SendChunk(pBuf, nLeft, nFlags);
		if (nWritten == SOCKET_ERROR)
			return nWritten;

		nLeft -= nWritten;
		pBuf += nWritten;
	}
	return nBufLen - nLeft;
}

int CSocket::SendChunk(const void* lpBuf, int nBufLen, int nFlags)
{
	int nResult;
	while ((nResult = CAsyncSocket::Send(lpBuf, nBufLen, nFlags)) == SOCKET_ERROR)
	{
		if (GetLastError() == WSAEWOULDBLOCK)
		{
			if (!PumpMessages(FD_WRITE))
				return SOCKET_ERROR;
		}
		else
			return SOCKET_ERROR;
	}
	return nResult;
}

BOOL CSocket::ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen)
{
	if (m_pbBlocking != NULL)
	{
		WSASetLastError(WSAEINPROGRESS);
		return  FALSE;
	}

	m_nConnectError = -1;

	if (!CAsyncSocket::ConnectHelper(lpSockAddr, nSockAddrLen))
	{
		if (GetLastError() == WSAEWOULDBLOCK)
		{
			while (PumpMessages(FD_CONNECT))
			{
				if (m_nConnectError != -1)
				{
					WSASetLastError(m_nConnectError);
					return (m_nConnectError == 0);
				}
			}
		}
		return FALSE;
	}
	return TRUE;
}

int CSocket::ReceiveFromHelper(void* lpBuf, int nBufLen, SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags)
{
	if (m_pbBlocking != NULL)
	{
		WSASetLastError(WSAEINPROGRESS);
		return  FALSE;
	}
	int nResult;
	while ((nResult = CAsyncSocket::ReceiveFromHelper(lpBuf, nBufLen, lpSockAddr, lpSockAddrLen, nFlags)) == SOCKET_ERROR)
	{
		if (GetLastError() == WSAEWOULDBLOCK)
		{
			if (!PumpMessages(FD_READ))
				return SOCKET_ERROR;
		}
		else
			return SOCKET_ERROR;
	}
	return nResult;
}

int CSocket::SendToHelper(const void* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags)
{
	if (m_pbBlocking != NULL)
	{
		WSASetLastError(WSAEINPROGRESS);
		return SOCKET_ERROR;
	}
	int nResult;
	while ((nResult = CAsyncSocket::SendToHelper(lpBuf, nBufLen, lpSockAddr, nSockAddrLen, nFlags)) == SOCKET_ERROR)
	{
		if (GetLastError() == WSAEWOULDBLOCK)
		{
			if (!PumpMessages(FD_WRITE))
				return SOCKET_ERROR;
		}
		else
			return SOCKET_ERROR;
	}
	return nResult;
}

int PASCAL CSocket::ProcessAuxQueue()
{
	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;

	if (pState->m_plistSocketNotifications->IsEmpty())
		return 0;

	int nCount = 0;
	while(!pState->m_plistSocketNotifications->IsEmpty())
	{
		nCount++;

		MSG* pMsg = (MSG*)pState->m_plistSocketNotifications->RemoveHead();
		ASSERT(pMsg != NULL);
		if (pMsg->message == WM_SOCKET_NOTIFY)
		{
			CAsyncSocket::DoCallBack(pMsg->wParam, pMsg->lParam);
		}
		else
		{
			ASSERT(CAsyncSocket::LookupHandle((SOCKET)pMsg->wParam, TRUE) != NULL);
			CAsyncSocket::DetachHandle((SOCKET)pMsg->wParam, TRUE);
		}
		delete pMsg;
	}
	return nCount;
}

void PASCAL CSocket::AuxQueueAdd(UINT message, WPARAM wParam, LPARAM lParam)
{
	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;

	MSG* pMsg = new MSG;
	pMsg->message = message;
	pMsg->wParam = wParam;
	pMsg->lParam = lParam;
	pState->m_plistSocketNotifications->AddTail(pMsg);
}

BOOL CSocket::PumpMessages(UINT uStopFlag)
{
	// The same socket better not be blocking in more than one place.
	ASSERT(m_pbBlocking == NULL);

	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;

	ASSERT(pState->m_hSocketWindow != NULL);

	BOOL bBlocking = TRUE;
	m_pbBlocking = &bBlocking;
	CWinThread* pThread = AfxGetThread();

	// This is not a timeout in the WinSock sense, but more
	// like a WM_KICKIDLE to keep message pumping alive
	UINT_PTR nTimerID = ::SetTimer(pState->m_hSocketWindow, 1, m_nTimeOut, NULL);

	if (nTimerID == 0)
		AfxThrowResourceException();

	BOOL bPeek = TRUE;

	while (bBlocking)
	{
		TRY
		{
			MSG msg;
			if (::PeekMessage(&msg, pState->m_hSocketWindow,
				WM_SOCKET_NOTIFY, WM_SOCKET_DEAD, PM_REMOVE))
			{
				if (msg.message == WM_SOCKET_NOTIFY && (SOCKET)msg.wParam == m_hSocket)
				{
					if (WSAGETSELECTEVENT(msg.lParam) == FD_CLOSE)
					{
						break;
					}
					if (WSAGETSELECTEVENT(msg.lParam) == uStopFlag)
					{
						if (uStopFlag == FD_CONNECT)
							m_nConnectError = WSAGETSELECTERROR(msg.lParam);
						break;
					}
				}
				if (msg.wParam != 0 || msg.lParam != 0)
					CSocket::AuxQueueAdd(msg.message, msg.wParam, msg.lParam);

				bPeek = TRUE;
			}
			else if (::PeekMessage(&msg, pState->m_hSocketWindow,
						WM_TIMER, WM_TIMER, PM_REMOVE))
			{
			break;
			}

			if (bPeek && ::PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
			{
				if (OnMessagePending())
				{
					// allow user-interface updates
					ASSERT(pThread);
					pThread->OnIdle(-1);
				}
				else
				{
					bPeek = FALSE;
				}
			}
			else
			{
				// no work to do -- allow CPU to sleep
				WaitMessage();
				bPeek = TRUE;
			}
		}
		CATCH_ALL(e)
		{
			TRACE(traceSocket, 0, "Error: caught exception in PumpMessage - continuing.\n");
			DELETE_EXCEPTION(e);
			bPeek = TRUE;
		}
		END_CATCH_ALL
	}

	::KillTimer(pState->m_hSocketWindow, nTimerID);

	if (!bBlocking)
	{
		WSASetLastError(WSAEINTR);
		return FALSE;
	}
	m_pbBlocking = NULL;

	::PostMessage(pState->m_hSocketWindow, WM_SOCKET_NOTIFY, 0, 0);

	return TRUE;
}

#ifdef _DEBUG
void CSocket::AssertValid() const
{
	CAsyncSocket::AssertValid();
}

void CSocket::Dump(CDumpContext& dc) const
{
	CAsyncSocket::Dump(dc);
	dc << "m_pbBlocking = " << m_pbBlocking <<"\n";
	dc << "m_nConnectError = " << m_nConnectError <<"\n";
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CSocketFile Construction

CSocketFile::CSocketFile(CSocket* pSocket, BOOL bArchiveCompatible)
{
	m_pSocket = pSocket;
	m_bArchiveCompatible = bArchiveCompatible;

#ifdef _DEBUG
	ASSERT(m_pSocket != NULL);
	ASSERT(m_pSocket->m_hSocket != INVALID_SOCKET);

	int nType = 0;
	int nTypeLen = sizeof(int);
	ASSERT(m_pSocket->GetSockOpt(SO_TYPE,&nType,&nTypeLen));
	ASSERT(nType == SOCK_STREAM);
#endif // _DEBUG

	if (pSocket == NULL)
	{
		AfxThrowInvalidArgException();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSocketFile Implementation

CSocketFile::~CSocketFile()
{
}

UINT CSocketFile::Read(void* lpBuf, UINT nCount)
{
	ENSURE(m_pSocket != NULL);

	if (lpBuf == NULL)
	{
		AfxThrowInvalidArgException();
	}

	int nRead;

	if (!m_bArchiveCompatible)
	{
		int nLeft = nCount;
		PBYTE pBuf = (PBYTE)lpBuf;

		while(nLeft > 0)
		{
			nRead = m_pSocket->Receive(pBuf, nLeft);
			if (nRead == SOCKET_ERROR)
			{
				int nError = m_pSocket->GetLastError();
				AfxThrowFileException(CFileException::genericException, nError);
			}
			else if (nRead == 0)
			{
				return nCount - nLeft;
			}

			nLeft -= nRead;
			pBuf += nRead;
		}
		return nCount - nLeft;
	}

	nRead = m_pSocket->Receive(lpBuf, nCount, 0);
	if (nRead == SOCKET_ERROR)
	{
		int nError = m_pSocket->GetLastError();
		AfxThrowFileException(CFileException::genericException, nError);
	}
	return nRead;
}

void CSocketFile::Write(const void* lpBuf, UINT nCount)
{
	ENSURE(m_pSocket!=NULL);
	
	if (lpBuf == NULL)
	{
		AfxThrowInvalidArgException();
	}

	int nWritten = m_pSocket->Send(lpBuf, nCount);
	if (nWritten == SOCKET_ERROR)
	{
		int nError = m_pSocket->GetLastError();
		AfxThrowFileException(CFileException::genericException, nError);
	}
}

void CSocketFile::Close()
{
	m_pSocket = NULL;
}

BOOL CSocketFile::Open(
	LPCTSTR /*lpszFileName*/, UINT /*nOpenFlags*/, CFileException* /*pError*/)
{
	AfxThrowNotSupportedException();
}

CFile* CSocketFile::Duplicate() const
{
	AfxThrowNotSupportedException();
}

ULONGLONG CSocketFile::GetPosition() const
{
	AfxThrowNotSupportedException();
}

ULONGLONG CSocketFile::Seek(LONGLONG lOff, UINT nFrom)
{
	if (lOff != 0L || nFrom != current)
		TRACE(traceSocket, 0, "Warning - Attempt made to seek on a CSocketFile\n");
	return 0;
}

void CSocketFile::SetLength(ULONGLONG /*dwNewLen*/)
{
	AfxThrowNotSupportedException();
}

ULONGLONG CSocketFile::GetLength() const
{
	AfxThrowNotSupportedException();
}

void CSocketFile::LockRange(ULONGLONG /*dwPos*/, ULONGLONG /*dwCount*/)
{
	AfxThrowNotSupportedException();
}

void CSocketFile::UnlockRange(ULONGLONG /*dwPos*/, ULONGLONG /*dwCount*/)
{
	AfxThrowNotSupportedException();
}

void CSocketFile::Flush()
{
}

void CSocketFile::Abort()
{
	AfxThrowNotSupportedException();
}

UINT CSocketFile::GetBufferPtr(UINT nCommand, UINT /*nCount*/, 
	void** /*ppBufStart*/, void** /*ppBufMax*/)
{
	ASSERT(nCommand == bufferCheck);
	UNUSED(nCommand);

	return bufferBlocking;
}

#ifdef _DEBUG
void CSocketFile::AssertValid() const
{
	CFile::AssertValid();
	if (m_pSocket != NULL)
		ASSERT_VALID(m_pSocket);
}

void CSocketFile::Dump(CDumpContext& dc) const
{
	CFile::Dump(dc);
	if (dc.GetDepth() > 0)
	{
		if (m_pSocket != NULL)
			dc << "with no socket\n";
		else
			dc << "with socket: " << m_pSocket;
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSocketWnd implementation

CSocketWnd::CSocketWnd()
{
}

LRESULT CSocketWnd::OnSocketNotify(WPARAM wParam, LPARAM lParam)
{
	CSocket::AuxQueueAdd(WM_SOCKET_NOTIFY, wParam, lParam);
	CSocket::ProcessAuxQueue();
	return 0L;
}

LRESULT CSocketWnd::OnSocketDead(WPARAM wParam, LPARAM lParam)
{
	CSocket::AuxQueueAdd(WM_SOCKET_DEAD, wParam, lParam);
	CSocket::ProcessAuxQueue();
	return 0L;
}

/////////////////////////////////////////////////////////////////////////////
// Message table implementation

BEGIN_MESSAGE_MAP(CSocketWnd, CWnd)
	//{{AFX_MSG_MAP(CWnd)
	ON_MESSAGE(WM_SOCKET_NOTIFY, &CSocketWnd::OnSocketNotify)
	ON_MESSAGE(WM_SOCKET_DEAD, &CSocketWnd::OnSocketDead)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

#define _AFXSOCK_INLINE
#include "afxsock.inl"
#undef _AFXSOCK_INLINE

#endif


IMPLEMENT_DYNAMIC(CAsyncSocket, CObject)
IMPLEMENT_DYNAMIC(CSocket, CAsyncSocket)
IMPLEMENT_DYNAMIC(CSocketFile, CFile)

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_SOCK_STATE, _afxSockState)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\rawdllmainproxy.c ===
/* This is a part of the Microsoft Foundation Classes C++ library.
 * Copyright (C) Microsoft Corporation
 * All rights reserved.
 *
 * This source code is only intended as a supplement to the
 * Microsoft Foundation Classes Reference and related
 * electronic documentation provided with the library.
 * See these sources for detailed information regarding the
 * Microsoft Foundation Classes product.
 */

#include <windows.h>

/* _RawDllMainProxy is used to correctly call RawDllMain (defined in dllmodul.cpp).
 * We need to call RawDllMain only when the user does not provide his/her own DllMain.
 * _RawDllMainProxy will check the value of _pActualRawDllMain: such function pointer
 * will point to RawDllMain only if dllmodul.obj is pulled in by the linker (and this
 * usually happens if the user define the _USRDLL macro). If dllmodul.obj is not pulled
 * in, _pActualRawDllMain (being a communal) will be NULL, so _RawDllMainProxy will
 * simply return.
 */

#ifndef _AFX_DLLMODULE_HELPER

extern IMAGE_DOS_HEADER __ImageBase;

/***
*BOOL _ValidateImageBase
*
*Purpose:
*       Check if a PE image is located at a potential image base address.
*
*Entry:
*       pImageBase - pointer to potential PE image in memory
*
*Return:
*       TRUE    PE image validated at pImageBase
*       FALSE   PE image not found
*
*******************************************************************************/

static BOOL __cdecl _ValidateImageBase(
	PBYTE pImageBase
	)
{
	PIMAGE_DOS_HEADER      pDOSHeader;
	PIMAGE_NT_HEADERS      pNTHeader;
	PIMAGE_OPTIONAL_HEADER pOptHeader;

	pDOSHeader = (PIMAGE_DOS_HEADER)pImageBase;
	if (pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE)
	{
		return FALSE;
	}

	pNTHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDOSHeader + pDOSHeader->e_lfanew);
	if (pNTHeader->Signature != IMAGE_NT_SIGNATURE)
	{
		return FALSE;
	}

	pOptHeader = (PIMAGE_OPTIONAL_HEADER)&pNTHeader->OptionalHeader;
	if (pOptHeader->Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)
	{
		return FALSE;
	}

	return TRUE;
}

/***
*PIMAGE_SECTION_HEADER _FindPESection
*
*Purpose:
*       Given an RVA (Relative Virtual Address, the offset from the Image Base
*       for a PE image), determine which PE section, if any, includes that RVA.
*
*Entry:
*       pImageBase - pointer to PE image in memory
*       rva - RVA whose enclosing section is to be found
*
*Return:
*       NULL     RVA is not part by any section in the PE image
*       non-NULL Pointer to IMAGE_SECTION_HEADER describing the section holding
*                the RVA
*
*******************************************************************************/

static PIMAGE_SECTION_HEADER __cdecl _FindPESection(
	PBYTE     pImageBase,
	DWORD_PTR rva
	)
{
	PIMAGE_NT_HEADERS     pNTHeader;
	PIMAGE_SECTION_HEADER pSection;
	unsigned int          iSection;

	pNTHeader =
		(PIMAGE_NT_HEADERS)
		(pImageBase + ((PIMAGE_DOS_HEADER)pImageBase)->e_lfanew);

	//
	// Find the section holding the desired address.  We make no assumptions
	// here about the sort order of the section descriptors (though they
	// always appear to be sorted by ascending section RVA).
	//
	for (iSection = 0, pSection = IMAGE_FIRST_SECTION(pNTHeader);
		iSection < pNTHeader->FileHeader.NumberOfSections;
		++iSection, ++pSection)
	{
		if (rva >= pSection->VirtualAddress &&
			rva <  pSection->VirtualAddress + pSection->Misc.VirtualSize)
		{
			//
			// Section found
			//
			return pSection;
		}
	}

	//
	// Section not found
	//
	return NULL;
}

/***
*BOOL _IsNonwritableInCurrentImage
*
*Purpose:
*       Check if an address is located within the current PE image (the one
*       starting at __ImageBase), that it is in a proper section of the image,
*       and that section is not marked writable.  This routine must be
*       statically linked, not imported from the CRT DLL, so the correct
*       __ImageBase is found.
*
*Entry:
*       pTarget - address to check
*
*Return:
*       0        Address is either not in current image, not in a section, or
*                in a writable section.
*       non-0    Address is in a non-writable section of the current image.
*
*******************************************************************************/

static BOOL __cdecl _IsNonwritableInCurrentImage(
	PBYTE pTarget
	)
{
	PBYTE                 pImageBase;
	DWORD_PTR             rvaTarget;
	PIMAGE_SECTION_HEADER pSection;

	pImageBase = (PBYTE)&__ImageBase;

	__try {
		//
		// Make sure __ImageBase does address a PE image.  This is likely an
		// unnecessary check, since we should be running from a normal image,
		// but it is fast, this routine is rarely called, and the normal call
		// is for security purposes.  If we don't have a PE image, return
		// failure.
		//
		if (!_ValidateImageBase(pImageBase))
		{
			return FALSE;
		}

		//
		// Convert the targetaddress to a Relative Virtual Address (RVA) within
		// the image, and find the corresponding PE section.  Return failure if
		// the target address is not found within the current image.
		//
		rvaTarget = pTarget - pImageBase;
		pSection = _FindPESection(pImageBase, rvaTarget);
		if (pSection == NULL)
		{
			return FALSE;
		}

		//
		// Check the section characteristics to see if the target address is
		// located within a writable section, returning a failure if yes.
		//
		return (pSection->Characteristics & IMAGE_SCN_MEM_WRITE) == 0;
	}
	__except (GetExceptionCode() == STATUS_ACCESS_VIOLATION)
	{
		//
		// Just return failure if the PE image is corrupted in any way that
		// triggers an AV.
		//
		return FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// make sure we call RawDllMain only if the user has not defined its own DllMain

BOOL WINAPI _RawDllMainProxy(HINSTANCE, DWORD dwReason, LPVOID);

#pragma warning(push)
#pragma warning(disable:4132)
/* _pActualRawDllMain is a communal, and it's really treated as a const pointer */
BOOL (WINAPI * const _pActualRawDllMain)(HINSTANCE , DWORD , LPVOID);
#pragma warning(pop)

BOOL (WINAPI * const _pRawDllMain)(HINSTANCE , DWORD , LPVOID) = &_RawDllMainProxy;

BOOL WINAPI _RawDllMainProxy(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
#ifndef _AFXDLL
	hInstance;
	dwReason;
	lpReserved;
#else
	if (_pActualRawDllMain != NULL)
	{
		if (!_IsNonwritableInCurrentImage((PBYTE)&_pActualRawDllMain))
		{
			/* _pActualRawDllMain cannot be in a R/W section */
#ifdef _DEBUG
			MessageBoxA(NULL,
				"_pActualRawDllMain cannot be in a R/W section",
				"Microsoft Foundation Classes C++ Library",
				MB_TASKMODAL | MB_ICONHAND| MB_OK | MB_SETFOREGROUND);
#endif
			return FALSE;
		}
		return (*_pActualRawDllMain)(hInstance, dwReason, lpReserved);
	}
#endif //_AFXDLL
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

#endif // !_AFX_DLLMODULE_HELPER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleunk.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

typedef void (*PFNMFCM_ReleaseManagedReferences)(IUnknown*);

/////////////////////////////////////////////////////////////////////////////
// Debug helpers

#ifdef _DEBUG
// Helper for converting IID into useful string.  Only for debugging.
CString AFXAPI AfxGetIIDString(REFIID iid)
{
	USES_CONVERSION;

	TCHAR szIID[100];
	szIID[0]			= NULL;
	DWORD dwSize		= sizeof(szIID);
	HKEY hKey			= NULL;
	LPOLESTR pszGUID	= NULL;

	ENSURE(SUCCEEDED(StringFromCLSID(iid, &pszGUID)));
	ENSURE(pszGUID);
	CString strGUID(pszGUID);
	// Attempt to find it in the Interfaces section
	if ((-1 != _stprintf_s(szIID,_countof(szIID), _T("Interface\\%s"), strGUID.GetString()))
	    && (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szIID, 0, KEY_READ, &hKey)))
	{
		RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE)szIID, &dwSize);
		RegCloseKey(hKey);
	}
	// Attempt to find it in the CLSID section
	else
	{
		if ((-1 != _stprintf_s(szIID,_countof(szIID), _T("CLSID\\%s"), strGUID.GetString()))
		    && (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szIID, 0, KEY_READ, &hKey)))
		{
			RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE)szIID, &dwSize);
			RegCloseKey(hKey);
		}
		else
		{
			_tcscpy_s(szIID, _countof(szIID), strGUID.GetString());
		}
	}
	CoTaskMemFree(pszGUID);

	CString strIID = szIID;
	return strIID;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// Component object model helpers

/////////////////////////////////////////////////////////////////////////////
// IUnknown client helpers

LPUNKNOWN AFXAPI _AfxQueryInterface(LPUNKNOWN lpUnknown, REFIID iid)
{
	ASSERT(lpUnknown != NULL);

	LPUNKNOWN lpW = NULL;
	if (lpUnknown->QueryInterface(iid, (LPLP)&lpW) != S_OK)
		return NULL;

	return lpW;
}

DWORD AFXAPI _AfxRelease(LPUNKNOWN* lplpUnknown)
{
	ASSERT(lplpUnknown != NULL);
	if (*lplpUnknown != NULL)
	{
		DWORD dwRef = (*lplpUnknown)->Release();
		*lplpUnknown = NULL;
		return dwRef;
	}
	return 0;
}


void AFXAPI _AfxReleaseManagedRefs(LPUNKNOWN lpUnk)
{
	ASSERT(lpUnk != NULL);

#ifdef _DEBUG
	#ifdef _UNICODE
		const TCHAR szModuleName[] = _T("mfcm") _T(_MFC_FILENAME_VER) _T("ud.dll");
	#else
		const TCHAR szModuleName[] = _T("mfcm") _T(_MFC_FILENAME_VER) _T("d.dll");
	#endif
#else
	#ifdef _UNICODE
		const TCHAR szModuleName[] = _T("mfcm") _T(_MFC_FILENAME_VER) _T("u.dll");
	#else
		const TCHAR szModuleName[] = _T("mfcm") _T(_MFC_FILENAME_VER) _T(".dll");
	#endif
#endif

	HMODULE hModule = GetModuleHandle( szModuleName );
	if( NULL != hModule )
	{
		PFNMFCM_ReleaseManagedReferences pfnMFCM_ReleaseManagedReferences = NULL;
		pfnMFCM_ReleaseManagedReferences = (PFNMFCM_ReleaseManagedReferences)GetProcAddress(
																						hModule,
																						"AfxmReleaseManagedReferences");

		if( NULL != pfnMFCM_ReleaseManagedReferences )
		{
			pfnMFCM_ReleaseManagedReferences( lpUnk );
		}
	}
}

#define GetInterfacePtr(pTarget, pEntry) \
	((LPUNKNOWN)((BYTE*)pTarget + pEntry->nOffset))

#define GetAggregatePtr(pTarget, pEntry) \
	(*(LPUNKNOWN*)((BYTE*)pTarget + pEntry->nOffset))

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget interface map implementation

// support for aggregation
class CInnerUnknown : public IUnknown
{
public:
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
};

// calling this function enables an object to be aggregatable
void CCmdTarget::EnableAggregation()
{
	// construct an CInnerUnknown just to get to the vtable
	CInnerUnknown innerUnknown;

	// copy the vtable & make sure initialized
	ASSERT(sizeof(m_xInnerUnknown) == sizeof(CInnerUnknown));
	m_xInnerUnknown = *(DWORD_PTR*)&innerUnknown;
}

DWORD CCmdTarget::ExternalAddRef()
{
	// delegate to controlling unknown if aggregated
	if (m_pOuterUnknown != NULL)
		return m_pOuterUnknown->AddRef();

	return InternalAddRef();
}

DWORD CCmdTarget::InternalRelease()
{
	ASSERT(GetInterfaceMap() != NULL);

	if (m_dwRef == 0)
		return 0;

	LONG lResult = InterlockedDecrement(&m_dwRef);
	if (lResult == 0)
	{
		AFX_MANAGE_STATE(m_pModuleState);
		OnFinalRelease();
	}
	return lResult;
}

DWORD CCmdTarget::ExternalRelease()
{
	// delegate to controlling unknown if aggregated
	if (m_pOuterUnknown != NULL)
		return m_pOuterUnknown->Release();

	return InternalRelease();
}

// special QueryInterface used in implementation (does not AddRef)
LPUNKNOWN CCmdTarget::GetInterface(const void* iid)
{
	// allow general hook first chance
	LPUNKNOWN lpUnkHook;
	if ((lpUnkHook = GetInterfaceHook(iid)) != NULL)
	{
#ifdef _DEBUG
		if (IsTracingEnabled(traceOle, 1))
		{
			CString strIID = AfxGetIIDString(*(IID*)(iid));
			TRACE(traceOle, 1, _T("QueryInterface(%s) succeeded\n"), strIID);
		}
#endif
		return lpUnkHook;
	}

	const AFX_INTERFACEMAP* pMap = GetInterfaceMap();
	ASSERT(pMap != NULL);
	DWORD lData1 = ((IID*)iid)->Data1;

	// IUnknown is a special case since nobody really implements *only* it!
	BOOL bUnknown = ((DWORD*)&IID_IUnknown)[0] == lData1 &&
		((DWORD*)iid)[1] == ((DWORD*)&IID_IUnknown)[1] &&
		((DWORD*)iid)[2] == ((DWORD*)&IID_IUnknown)[2] &&
		((DWORD*)iid)[3] == ((DWORD*)&IID_IUnknown)[3];
	if (bUnknown)
	{
		do
		{
			const AFX_INTERFACEMAP_ENTRY* pEntry = pMap->pEntry;
			ASSERT(pEntry != NULL);
			while (pEntry->piid != NULL)
			{
				// check INTERFACE_ENTRY macro
				LPUNKNOWN lpUnk = GetInterfacePtr(this, pEntry);

				// check vtable pointer (can be NULL)
				if (*(DWORD*)lpUnk != 0)
				{
#ifdef _DEBUG
					if (IsTracingEnabled(traceOle, 1))
					{
						CString strIID = AfxGetIIDString(*(IID*)(iid));
						TRACE(traceOle, 1, _T("QueryInterface(%s) succeeded\n"), strIID);
					}
#endif
					return lpUnk;
				}

				// entry did not match -- keep looking
				++pEntry;
			}
#ifdef _AFXDLL
			if (pMap->pfnGetBaseMap == NULL)
				break;
			pMap = (*pMap->pfnGetBaseMap)();
		} while (1);
#else
		} while ((pMap = pMap->pBaseMap) != NULL);
#endif

#ifdef _DEBUG
		if (IsTracingEnabled(traceOle, 1))
		{
			CString strIID = AfxGetIIDString(*(IID*)(iid));
			TRACE(traceOle, 1, _T("QueryInterface(%s) failed\n"), strIID);
		}
#endif
		// interface ID not found, fail the call
		return NULL;
	}

	// otherwise, walk the interface map to find the matching IID
	do
	{
		const AFX_INTERFACEMAP_ENTRY* pEntry = pMap->pEntry;
		ASSERT(pEntry != NULL);
		while (pEntry->piid != NULL)
		{
			if (((DWORD*)pEntry->piid)[0] == lData1 &&
				((DWORD*)pEntry->piid)[1] == ((DWORD*)iid)[1] &&
				((DWORD*)pEntry->piid)[2] == ((DWORD*)iid)[2] &&
				((DWORD*)pEntry->piid)[3] == ((DWORD*)iid)[3])
			{
				// check INTERFACE_ENTRY macro
				LPUNKNOWN lpUnk = GetInterfacePtr(this, pEntry);

				// check vtable pointer (can be NULL)
				if (*(DWORD*)lpUnk != 0)
				{
#ifdef _DEBUG
					if (IsTracingEnabled(traceOle, 1))
					{
						CString strIID = AfxGetIIDString(*(IID*)(iid));
						TRACE(traceOle, 1, _T("QueryInterface(%s) succeeded\n"), strIID);
					}
#endif
					return lpUnk;
				}
			}

			// entry did not match -- keep looking
			++pEntry;
		}
#ifdef _AFXDLL
		if (pMap->pfnGetBaseMap == NULL)
			break;
		pMap = (*pMap->pfnGetBaseMap)();
	} while (1);
#else
	} while ((pMap = pMap->pBaseMap) != NULL);
#endif

#ifdef _DEBUG
	if (IsTracingEnabled(traceOle, 1))
	{
		CString strIID = AfxGetIIDString(*(IID*)(iid));
		TRACE(traceOle, 1, _T("QueryInterface(%s) failed\n"), strIID);
	}
#endif
	// interface ID not found, fail the call
	return NULL;
}

LPUNKNOWN CCmdTarget::QueryAggregates(const void* iid)
{
	const AFX_INTERFACEMAP* pMap = GetInterfaceMap();
	ASSERT(pMap != NULL);

	// walk the Interface map to call aggregates
	do
	{
		const AFX_INTERFACEMAP_ENTRY* pEntry = pMap->pEntry;
		// skip non-aggregate entries
		ASSERT(pEntry != NULL);
		while (pEntry->piid != NULL)
			++pEntry;

		// call QueryInterface for each aggregate entry
		while (pEntry->nOffset != (size_t)-1)
		{
			LPUNKNOWN lpQuery = GetAggregatePtr(this, pEntry);
			// it is ok to have aggregate but not created yet
			if (lpQuery != NULL)
			{
				LPUNKNOWN lpUnk = NULL;
				if (lpQuery->QueryInterface(*(IID*)iid, (LPLP)&lpUnk)
					== S_OK && lpUnk != NULL)
				{
					// QueryInterface successful...
					return lpUnk;
				}
			}

			// entry did not match -- keep looking
			++pEntry;
		}
#ifdef _AFXDLL
		if (pMap->pfnGetBaseMap == NULL)
			break;
		pMap = (*pMap->pfnGetBaseMap)();
	} while (1);
#else
	} while ((pMap = pMap->pBaseMap) != NULL);
#endif

	// interface ID not found, fail the call
	return NULL;
}

// real implementation of QueryInterface
DWORD CCmdTarget::InternalQueryInterface(const void* iid, LPVOID* ppvObj)
{
	// check local interfaces
	if ((*ppvObj = GetInterface(iid)) != NULL)
	{
		// interface was found -- add a reference
		ExternalAddRef();
		return S_OK;
	}

	// check aggregates
	if ((*ppvObj = QueryAggregates(iid)) != NULL)
		return S_OK;

	// interface ID not found, fail the call
	return (DWORD)E_NOINTERFACE;
}

// QueryInterface that is exported to normal clients
DWORD CCmdTarget::ExternalQueryInterface(const void* iid,
	LPVOID* ppvObj)
{
	// delegate to controlling unknown if aggregated
	if (m_pOuterUnknown != NULL)
	{
		HRESULT hRes = m_pOuterUnknown->QueryInterface(*(IID*)iid, ppvObj);
#ifdef _DEBUG
		if (IsTracingEnabled(traceOle, 1))
		{
			CString strIID = AfxGetIIDString(*(IID*)(iid));
			if (SUCCEEDED(hRes))
				TRACE(traceOle, 1, _T("QueryInterface(%s) succeeded\n"), strIID);
			else
				TRACE(traceOle, 1, _T("QueryInterface(%s) failed\n"), strIID);
		}
#endif
		return hRes;
	}

	return InternalQueryInterface(iid, ppvObj);
}

/////////////////////////////////////////////////////////////////////////////
// Inner IUnknown implementation (for aggregation)

STDMETHODIMP_(ULONG) CInnerUnknown::AddRef()
{
	METHOD_PROLOGUE_(CCmdTarget, InnerUnknown)
	return pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) CInnerUnknown::Release()
{
	METHOD_PROLOGUE(CCmdTarget, InnerUnknown)
	return pThis->InternalRelease();
}

STDMETHODIMP CInnerUnknown::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_(CCmdTarget, InnerUnknown)

	if (iid == IID_IUnknown)
	{
		// QueryInterface on inner IUnknown for IID_IUnknown must
		//  return inner IUnknown.
		pThis->InternalAddRef();
		*ppvObj = this;
		return S_OK;
	}
	return pThis->InternalQueryInterface(&iid, ppvObj);
}

/////////////////////////////////////////////////////////////////////////////
// other helper functions

// ExternalDisconnect is used to remove RPC connections in destructors.  This
//  insures that no RPC calls will go to the object after it has been
//  deleted.
void CCmdTarget::ExternalDisconnect()
{
	if (m_dwRef == 0)   // already in disconnected state?
		return;

	// get IUnknown pointer for the object
	LPUNKNOWN lpUnknown = (LPUNKNOWN)GetInterface(&IID_IUnknown);
	ASSERT(lpUnknown != NULL);

	// disconnect the object
	InterlockedIncrement(&m_dwRef);  // protect object from destruction
	CoDisconnectObject(lpUnknown, 0);
	m_dwRef = 0;    // now in disconnected state
}

// GetControllingUnknown is used when creating aggregate objects,
//  usually from OnCreateAggregates.  The outer, or controlling, unknown
//  is one of the parameters to CoCreateInstance and other OLE creation
//  functions which support aggregation.
LPUNKNOWN CCmdTarget::GetControllingUnknown()
{
	if (m_pOuterUnknown != NULL)
		return m_pOuterUnknown; // aggregate of m_pOuterUnknown

	LPUNKNOWN lpUnknown = (LPUNKNOWN)GetInterface(&IID_IUnknown);
	return lpUnknown;   // return our own IUnknown implementation
}

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

// expand inlines for OLE general APIs
#define _AFXDISP_INLINE
#include "afxole.inl"

#endif //!_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\oleverb.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#ifndef _AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Signature for verb functions

typedef BOOL (AFX_MSG_CALL CCmdTarget::*AFX_PVERBFN)(LPMSG, HWND, LPCRECT);

/////////////////////////////////////////////////////////////////////////////
// CEnumOleVerb - enumerator for OLEVERB

class CEnumOleVerb : public CEnumArray
{
public:
	CEnumOleVerb(const void* pvEnum, UINT nSize) :
		CEnumArray(sizeof(OLEVERB), pvEnum, nSize, TRUE) {}
	~CEnumOleVerb();

protected:
	virtual BOOL OnNext(void* pv);

	DECLARE_INTERFACE_MAP()
};

BEGIN_INTERFACE_MAP(CEnumOleVerb, CEnumArray)
	INTERFACE_PART(CEnumOleVerb, IID_IEnumOLEVERB, EnumVOID)
END_INTERFACE_MAP()

CEnumOleVerb::~CEnumOleVerb()
{
	if (m_pClonedFrom == NULL)
	{
		UINT iVerb;
		LPOLEVERB lpVerb = (LPOLEVERB)(void*)m_pvEnum;
		for (iVerb = 0; iVerb < m_nSize; iVerb++)
			CoTaskMemFree(lpVerb[iVerb].lpszVerbName);
	}
	// destructor will free the actual array (if it was not a clone)
}

BOOL CEnumOleVerb::OnNext(void* pv)
{
	if (!CEnumArray::OnNext(pv))
		return FALSE;

	// outgoing OLEVERB requires the verb name to be copied
	//  (the caller has responsibility to free it)

	LPOLEVERB lpVerb = (LPOLEVERB)pv;
	if (lpVerb->lpszVerbName != NULL)
	{
		lpVerb->lpszVerbName = AtlAllocTaskOleString(lpVerb->lpszVerbName);
		if (lpVerb->lpszVerbName == NULL)
			AfxThrowMemoryException();
	}
	// otherwise, copying worked...
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget::EnumOleVerbs - implementation for IOleObject::EnumVerbs

BOOL CCmdTarget::EnumOleVerbs(LPENUMOLEVERB* ppenumOleVerb)
{
	ENSURE_ARG(ppenumOleVerb != NULL);
	LPOLEVERB lpVerbList = NULL;
	LPOLEVERB lpVerbListNew;
	LPOLEVERB lpVerb;
	long nVerbs = 0;
	long nAlloc = 0;
	CString strVerbName;

	// walk the chain of message maps
	const AFX_MSGMAP* pMessageMap;
	const AFX_MSGMAP_ENTRY* lpEntry;
 
	for (pMessageMap = GetMessageMap(); pMessageMap->pfnGetBaseMap != NULL;
		 pMessageMap = pMessageMap->pfnGetBaseMap())
	{
		// find all verb entries in the map that have non-negative IDs
		lpEntry = pMessageMap->lpEntries;
		while ((lpEntry = AfxFindMessageEntry(lpEntry, 0xC002, 0, 1)) != NULL)
		{
			ASSERT(lpEntry != NULL);

			if (nVerbs == nAlloc)
			{
				// not enough space for new item -- allocate more
				lpVerbListNew = new OLEVERB[nVerbs + 10];
				nAlloc += 10;
				if(lpVerbList)
				{
					Checked::memcpy_s(lpVerbListNew, (size_t)((nVerbs + 10)*sizeof(OLEVERB)), 
						lpVerbList, (size_t)(nVerbs*sizeof(OLEVERB)));
					delete [] lpVerbList;
				}	
				lpVerbList = lpVerbListNew;
			}

			// get the string for this item
			if (!strVerbName.LoadString((UINT)lpEntry->nSig))
				strVerbName = _T("<unknown verb>");     // LoadString failed
			ASSERT(strVerbName.GetLength() > 0);

			// add this item to the list
			ASSERT(nVerbs < nAlloc);
			lpVerb = &lpVerbList[nVerbs];
			lpVerb->lVerb = nVerbs;
			lpVerb->lpszVerbName = AtlAllocTaskOleString(strVerbName);
			lpVerb->fuFlags = 0;
			lpVerb->grfAttribs = OLEVERBATTRIB_ONCONTAINERMENU;
			++nVerbs;
			++lpEntry;
		}
	}

	if (nVerbs > 0)
	{
		// create and return the IEnumOLEVERB object
		CEnumOleVerb* pEnum = new CEnumOleVerb(lpVerbList, (UINT)nVerbs);
		*ppenumOleVerb = (IEnumOLEVERB*)&pEnum->m_xEnumVOID;
	}
	else
	{
		// no verbs: return NULL
		*ppenumOleVerb = NULL;
	}

	return (nVerbs > 0);
}

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget::DoOleVerb - implementation for IOleObject::DoVerb

BOOL CCmdTarget::DoOleVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent,
	LPCRECT lpRect)
{
	const AFX_MSGMAP* pMessageMap;
	const AFX_MSGMAP_ENTRY* lpEntry = NULL;
	long i = -1;

	for (pMessageMap = GetMessageMap(); pMessageMap->pfnGetBaseMap != NULL && lpEntry == NULL;
		 pMessageMap = pMessageMap->pfnGetBaseMap())
	{
		if (iVerb < 0)  // Standard verb (negative index)
		{
			lpEntry = AfxFindMessageEntry(pMessageMap->lpEntries, 0xC002, 0,
				(UINT)iVerb);
		}
		else            // Non-standard verb (non-negative index)
		{
			lpEntry = pMessageMap->lpEntries;
			while (((lpEntry = AfxFindMessageEntry(lpEntry, 0xC002, 0, 1)) !=
					NULL) && (++i < iVerb))
			{
				++lpEntry;
			}
			ASSERT((lpEntry == NULL) || (i == iVerb));
		}
	}

	if (lpEntry == NULL)
		return FALSE;

	AFX_PVERBFN pfn = (AFX_PVERBFN)(lpEntry->pfn);
	if (!(this->*pfn)(lpMsg, hWndParent, lpRect))
		THROW (new COleException);

	return TRUE;
}

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\sockimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: must include AFXDB.H first

#pragma once

#undef AFX_DATA
#define AFX_DATA AFX_NET_DATA

/////////////////////////////////////////////////////////////////////////////
// _AFX_SOCK_STATE

#undef AFX_DATA
#define AFX_DATA

class _AFX_SOCK_STATE : public CNoTrackObject
{
public:
	DWORD m_dwReserved1;    // reserved for version 4.1 only
	HINSTANCE m_hInstSOCK;      // handle of WSOCK32.DLL
	void (AFXAPI *m_pfnSockTerm)(void); // set once initialized
	virtual ~_AFX_SOCK_STATE();
};

EXTERN_PROCESS_LOCAL(_AFX_SOCK_STATE, _afxSockState)

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\stdafx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _AFXDLL
// The following symbol used to force inclusion of this module for _AFXDLL
#ifdef _X86_
extern "C" { int _afxForceSTDAFX; }
#else
extern "C" { int __afxForceSTDAFX; }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\sockexp.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"


#define new DEBUG_NEW

#pragma comment(lib, "wsock32.lib")

BOOL AFXAPI _AfxSocketInit(WSADATA* lpwsaData);

BOOL AFXAPI AfxSocketInit(WSADATA* lpwsaData)
{
	// Reference the start up function to pull in wsock32.dll
	// This is to prevent problems with delay loading wsock32.dll from mfc*.dll
	// WSAStartup should never be NULL
	if (WSAStartup != NULL)
		return _AfxSocketInit(lpwsaData);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// STDAFX.H is the header that includes the standard includes that are used
//  for most of the project.  These are compiled into a pre-compiled header

#include <winsdkver.h>

#undef _WIN32_WINNT
#define _WIN32_WINNT _WIN32_WINNT_MAXVER

#include <sdkddkver.h>

// turn off warnings for /W4 (just for MFC implementation)
#ifndef ALL_WARNINGS
#pragma warning(disable: 4073)  // disable warning about using init_seg
#pragma warning(disable: 4702)  // unreachable code
#endif

// MFC inline constructors (including compiler generated) can get deep
#pragma inline_depth(16)

#ifdef _AFX_DEVBUILD
	#define AFX_IMPL_DATA AFX_DATA_EXPORT
#else
	#define AFX_IMPL_DATA
#endif

#ifdef _AFX_MFCS  // Building the static component of the DLL version.  Import stuff from MFC*.dll
#include <afxv_dll.h>
#else  // Building the DLL itself
// override default values for data import/export when building MFC DLLs
#ifdef _AFX_CORE_IMPL
	#define AFX_CORE_DATA   AFX_IMPL_DATA
	#define AFX_CORE_DATADEF
#endif

#ifdef _AFX_OLE_IMPL
	#define AFX_OLE_DATA    AFX_IMPL_DATA
	#define AFX_OLE_DATADEF
#endif

#ifdef _AFX_DB_IMPL
	#define AFX_DB_DATA     AFX_IMPL_DATA
	#define AFX_DB_DATADEF
#endif

#ifdef _AFX_NET_IMPL
	#define AFX_NET_DATA    AFX_IMPL_DATA
	#define AFX_NET_DATADEF
#endif
#endif

#define _AFX_NOFORCE_LIBS
#define _AFX_FULLTYPEINFO
#define VC_EXTRALEAN
#define NO_ANSIUNI_ONLY
#define _MFC_OVERRIDES_NEW

#define AFX_COMDAT __declspec(selectany)

// core headers
#include "afx.h"
#include "afxplex_.h"
#include "atlbase.h"
#include "afxcoll.h"
#include "afxtempl.h"

// public headers
#include "afxwin.h"
#include "afxdlgs.h"
#include "afxext.h"

#ifndef _AFX_NO_OLE_SUPPORT
	#ifndef _OLE2_H_
		#include <ole2.h>
	#endif

#include <winspool.h>

// for the release version, MFC internally can use the more efficient
//  method of directly accessing CRuntimeClass objects.
#ifndef _DEBUG
#undef RUNTIME_CLASS
#define RUNTIME_CLASS(class_name) _RUNTIME_CLASS(class_name)
#endif

// include OLE dialog/helper APIs
#ifndef _OLEDLG_H_
	#include <oledlg.h>
#endif

#include <winreg.h>
	#include "afxcom_.h"
#include "afxole.h"
#include "afxdtctl.h"
#include "afxocc.h"
#include "afxthemehelper.h"

#include "afxdocob.h"

#ifndef _AFX_NO_DAO_SUPPORT
	#include "afxdao.h"
#endif

	#include "afxodlgs.h"
#endif

#ifndef _AFX_NO_OCX_SUPPORT
	#include "afxctl.h"
#endif
#ifndef _AFX_NO_DB_SUPPORT
	#include "afxdb.h"
#endif
#ifndef _AFX_NO_SYNC_SUPPORT
	#include "afxmt.h"
#endif
#ifndef _AFX_NO_INET_SUPPORT
	#include "afxinet.h"
#endif

// private headers as well
#include "afxpriv.h"
#include "afximpl.h"
#include "winhand_.h"
#ifndef _AFX_NO_OLE_SUPPORT
	#include "oleimpl2.h"
#endif
#ifndef _AFX_NO_OCX_SUPPORT
	#include "ctlimpl.h"
#endif
#ifndef _AFX_NO_DB_SUPPORT
	#include "dbimpl.h"
#endif
#ifndef _AFX_NO_DAO_SUPPORT
	#include "daoimpl.h"
#endif
#ifndef _AFX_NO_SOCKET_SUPPORT
	#ifndef _WINSOCKAPI_
		#include <winsock.h>
	#endif
	#include "sockimpl.h"
	#include "afxsock.h"
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
	#include "afxcmn.h"
	#include "afxcview.h"
#endif
#ifndef _AFX_NO_RICHEDIT_SUPPORT
	#include "afxrich.h"
#endif
#include "afxhtml.h"
#ifndef _AFX_NO_DHTML_SUPPORT
	#include "afxdhtml.h"
#endif

#if (0x0600 <= WINVER) && defined(_UNICODE)
	#include "afxtaskdialog.h"
#endif 

#include <winreg.h>
#include <winnls.h>
#include <stddef.h>
#include <limits.h>
#include <malloc.h>
#include <new.h>
#include <eh.h>

#undef AfxWndProc

// implementation uses _AFX_PACKING as well
#ifdef _AFX_PACKING
#ifndef ALL_WARNINGS
#pragma warning(disable: 4103)
#endif
#pragma pack(_AFX_PACKING)
#endif

// special exception handling just for MFC library implementation

// MFC does not rely on auto-delete semantics of the TRY..CATCH macros,
//  therefore those macros are mapped to something closer to the native
//  C++ exception handling mechanism when building MFC itself.

#undef TRY
#define TRY { try {

#undef CATCH
#define CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); UNUSED(e);

#undef AND_CATCH
#define AND_CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); UNUSED(e);

#undef CATCH_ALL
#define CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); UNUSED(e);

#undef AND_CATCH_ALL
#define AND_CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); UNUSED(e);

#undef END_TRY
#define END_TRY } catch (CException* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); e->Delete(); } }

#undef THROW_LAST
#define THROW_LAST() throw

// Because of the above definitions of TRY...CATCH it is necessary to
//  explicitly delete exception objects at the catch site.

#define DELETE_EXCEPTION(e) do { if(e) { e->Delete(); } } while (0)
#define NO_CPP_EXCEPTION(expr)


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ThemeHelper.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CThemeHelper
void* CThemeHelper::GetProc(LPCSTR szProc, void* pfnFail)
{
	static HMODULE hThemeDll = AfxCtxLoadLibraryW(L"UxTheme.dll");

	void* pRet = pfnFail;
	if (hThemeDll != NULL)
	{
		void *pFunc = GetProcAddress(hThemeDll, szProc);
		if(pFunc!=NULL)
		{
			pRet=pFunc;
		}
	}
	return pRet;
}

BOOL CThemeHelper::IsAppThemedFail()
{
	return FALSE;
}


HTHEME CThemeHelper::OpenThemeDataFail(HWND , LPCWSTR )
{
	return NULL;
}


HRESULT CThemeHelper::CloseThemeDataFail(HTHEME)
{
	return E_FAIL;
}


HRESULT CThemeHelper::DrawThemeBackgroundFail(HTHEME, HDC, int, int, const RECT *, const RECT *)
{
	return E_FAIL;
}


HRESULT CThemeHelper::GetThemePartSizeFail(HTHEME, HDC, int, int, RECT *, enum THEMESIZE, SIZE *)
{
	return E_FAIL;
}


BOOL CThemeHelper::IsThemeBackgroundPartiallyTransparentFail(HTHEME , int , int )
{
	return FALSE;
}

HRESULT CThemeHelper::DrawThemeParentBackgroundFail(HWND , HDC , RECT *)
{
	return E_FAIL;
}

BOOL CThemeHelper::IsThemePartDefinedFail(HTHEME , int , int )
{
	return FALSE;
}

BOOL CThemeHelper::IsAppThemed()
{
	static PFNISAPPTHEMED pfnIsAppThemed = (PFNISAPPTHEMED)GetProc("IsAppThemed", IsAppThemedFail);
	return (*pfnIsAppThemed)();
}

HTHEME CThemeHelper::OpenThemeData(HWND hwnd, LPCWSTR pszClassList)
{
	static PFNOPENTHEMEDATA pfnOpenThemeData = (PFNOPENTHEMEDATA)GetProc("OpenThemeData", OpenThemeDataFail);
	return (*pfnOpenThemeData)(hwnd, pszClassList);
}

HRESULT CThemeHelper::CloseThemeData(HTHEME hTheme)
{
	static PFNCLOSETHEMEDATA pfnCloseThemeData = (PFNCLOSETHEMEDATA)GetProc("CloseThemeData", CloseThemeDataFail);
	return (*pfnCloseThemeData)(hTheme);
}

HRESULT CThemeHelper::DrawThemeBackground(HTHEME hTheme, HDC hdc, 
	int nPartId, int nStateId, const RECT *pRect, const RECT *pClipRect)
{
	static PFNDRAWTHEMEBACKGROUND pfnDrawThemeBackground = 
		(PFNDRAWTHEMEBACKGROUND)GetProc("DrawThemeBackground", DrawThemeBackgroundFail);
	return (*pfnDrawThemeBackground)(hTheme, hdc, nPartId, nStateId, pRect, pClipRect);
}

HRESULT CThemeHelper::GetThemePartSize(HTHEME hTheme, HDC hdc, 
	int nPartId, int nStateId, RECT * pRect, enum THEMESIZE eSize, SIZE *psz)
{
	static PFNGETTHEMEPARTSIZE pfnGetThemePartSize = 
		(PFNGETTHEMEPARTSIZE)GetProc("GetThemePartSize", GetThemePartSizeFail);
	return (*pfnGetThemePartSize)(hTheme, hdc, nPartId, nStateId, pRect, eSize, psz);
}

BOOL CThemeHelper::IsThemeBackgroundPartiallyTransparent(HTHEME hTheme, int nPartId, int nStateId)
{
	static PFNISTHEMEBACKGROUNDPARTIALLYTRANSPARENT pfnIsThemeBackgroundPartiallyTransparent =
		(PFNISTHEMEBACKGROUNDPARTIALLYTRANSPARENT)GetProc("IsThemeBackgroundPartiallyTransparent", 
															IsThemeBackgroundPartiallyTransparentFail);
	return (*pfnIsThemeBackgroundPartiallyTransparent)(hTheme, nPartId, nStateId);
}

HRESULT CThemeHelper::DrawThemeParentBackground(HWND hwnd, HDC hdc, RECT *prc)
{
	static PFNDRAWTHEMEPARENTBACKGROUND pfnDrawThemeParentBackground =
		(PFNDRAWTHEMEPARENTBACKGROUND)GetProc("DrawThemeParentBackground", DrawThemeParentBackgroundFail);
	return (*pfnDrawThemeParentBackground)(hwnd, hdc, prc);
}

BOOL CThemeHelper::IsThemePartDefined(HTHEME hTheme, int nPartId, int nStateId)
{
	static PFNISTHEMEPARTDEFINED pfnIsThemePartDefined =
		(PFNISTHEMEPARTDEFINED)GetProc("IsThemePartDefined", IsThemePartDefinedFail);
	return (*pfnIsThemePartDefined)(hTheme, nPartId, nStateId);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\timecore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, CTime time)
{
	char psz[32];
	psz[0] = '\0';

	__time64_t tmp = time.GetTime();
	errno_t err = _ctime64_s(psz, sizeof(psz), &tmp);

	if ((err != 0) || (psz[0] == '\0') || (time.GetTime() == 0))
	{
		return dc << "CTime(invalid #" << time.GetTime() << ")";
	}

	// format it
	return dc << "CTime(\"" << psz << "\")";
}
#endif

CArchive& CTime::Serialize64(CArchive& ar)
{
	if (ar.IsStoring())
		return ar << (__int64) m_time;
	else
		return ar >> (__int64) m_time;
}
const __int32 cTime64Mark = INT_MIN + 10;
CArchive& AFXAPI operator <<(CArchive& ar, CTime time)
{
	// This version serializes 32 bits of invalid time and after 64 bits
	// time64. New code will support both 64 serialization and 32/64 deserialization.
	__time64_t ttime = time.GetTime();
	ar << (DWORD)cTime64Mark;	
	return ar << (__int64) ttime;
}

CArchive& AFXAPI operator >>(CArchive& ar, CTime& rtime)
{
	//his version  support both 32 and 64 deserialization.
	//If the first 32 bits are cTime64Mark (which is invalid time32 value), then
	//The next 64 bits are read to form time64 value, else, it must be a legacy (VC6-7.1) time32 value.
	__time32_t timeOld;
	CArchive& retRef = ar >> (DWORD&) timeOld;
	if (static_cast<__int32>(timeOld)==cTime64Mark)
	{
		__time64_t t64;
		ar >> (__int64) t64;
		rtime = t64;
	} else
	{
	rtime = __time64_t(timeOld);
	}
	return retRef;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSpan - relative time

#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, CTimeSpan timeSpan)
{
	return dc << "CTimeSpan(" << timeSpan.GetDays() << " days, " <<
		 timeSpan.GetHours() << " hours, " <<
		 timeSpan.GetMinutes() << " minutes and " <<
		 timeSpan.GetSeconds() << " seconds)";
}
#endif

CArchive& CTimeSpan::Serialize64(CArchive& ar)
{
	if (ar.IsStoring())
		return ar << (__int64) m_timeSpan;
	else
		return ar >> (__int64) m_timeSpan;
}

CArchive& AFXAPI operator <<(CArchive& ar, CTimeSpan timeSpan)
{
	// this version serializes only 32 bits
	__time64_t timespan = timeSpan.GetTimeSpan();
	ASSERT( timespan <= UINT_MAX);
	if( timespan > UINT_MAX)
		AfxThrowInvalidArgException();
	time_t timeConverted = (time_t)timespan;
	return ar << (DWORD) timeConverted;
}

CArchive& AFXAPI operator >>(CArchive& ar, CTimeSpan& rtimeSpan)
{
	// this version serializes only 32 bits
	__time32_t timeOld;
	CArchive& retRef = ar >> (DWORD&) timeOld;
	rtimeSpan = __time64_t(timeOld);
	return retRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\thrdcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <process.h>    // for _beginthreadex and _endthreadex
#include <ddeml.h>  // for MSGF_DDEMGR



BOOL AFXAPI AfxInternalPumpMessage();
LRESULT AFXAPI AfxInternalProcessWndProcException(CException*, const MSG* pMsg);
BOOL AfxInternalPreTranslateMessage(MSG* pMsg);
BOOL AfxInternalIsIdleMessage(MSG* pMsg);

/////////////////////////////////////////////////////////////////////////////
// Thread entry point

#ifdef _MT

struct _AFX_THREAD_STARTUP
{
	// following are "in" parameters to thread startup
	_AFX_THREAD_STATE* pThreadState;    // thread state of parent thread
	CWinThread* pThread;    // CWinThread for new thread
	DWORD dwCreateFlags;    // thread creation flags
	_PNH pfnNewHandler;     // new handler for new thread

	HANDLE hEvent;          // event triggered after success/non-success
	HANDLE hEvent2;         // event triggered after thread is resumed

	// strictly "out" -- set after hEvent is triggered
	BOOL bError;    // TRUE if error during startup
};

UINT APIENTRY _AfxThreadEntry(void* pParam)
{
	_AFX_THREAD_STARTUP* pStartup = (_AFX_THREAD_STARTUP*)pParam;
	ASSERT(pStartup != NULL);
	ASSERT(pStartup->pThreadState != NULL);
	ASSERT(pStartup->pThread != NULL);
	ASSERT(pStartup->hEvent != NULL);
	ASSERT(!pStartup->bError);

	CWinThread* pThread = pStartup->pThread;
	CWnd threadWnd;
	TRY
	{
		// inherit parent's module state
		_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
		pThreadState->m_pModuleState = pStartup->pThreadState->m_pModuleState;

		// set current thread pointer for AfxGetThread
		AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
		pThread->m_pModuleState = pModuleState;
		AFX_MODULE_THREAD_STATE* pState = pModuleState->m_thread;
		pState->m_pCurrentWinThread = pThread;

		// forced initialization of the thread
		AfxInitThread();

		// thread inherits app's main window if not already set
		CWinApp* pApp = AfxGetApp();
		if (pApp != NULL && 
			pThread->m_pMainWnd == NULL && pApp->m_pMainWnd->GetSafeHwnd() != NULL)
		{
			// just attach the HWND
			threadWnd.Attach(pApp->m_pMainWnd->m_hWnd);
			pThread->m_pMainWnd = &threadWnd;
		}
	}
	CATCH_ALL(e)
	{
		// Note: DELETE_EXCEPTION(e) not required.

		// exception happened during thread initialization!!
		TRACE(traceAppMsg, 0, "Warning: Error during thread initialization!\n");

		// set error flag and allow the creating thread to notice the error
		threadWnd.Detach();
		pStartup->bError = TRUE;
		VERIFY(::SetEvent(pStartup->hEvent));
		AfxEndThread((UINT)-1, FALSE);
		ASSERT(FALSE);  // unreachable
	}
	END_CATCH_ALL

	// pStartup is invlaid after the following
	// SetEvent (but hEvent2 is valid)
	HANDLE hEvent2 = pStartup->hEvent2;

	// allow the creating thread to return from CWinThread::CreateThread
	VERIFY(::SetEvent(pStartup->hEvent));

	// wait for thread to be resumed
	VERIFY(::WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
	::CloseHandle(hEvent2);

	// first -- check for simple worker thread
	DWORD nResult = 0;
	if (pThread->m_pfnThreadProc != NULL)
	{
		nResult = (*pThread->m_pfnThreadProc)(pThread->m_pThreadParams);
		ASSERT_VALID(pThread);
	}
	// else -- check for thread with message loop
	else if (!pThread->InitInstance())
	{
		ASSERT_VALID(pThread);
		nResult = pThread->ExitInstance();
	}
	else
	{
		// will stop after PostQuitMessage called
		ASSERT_VALID(pThread);
		nResult = pThread->Run();
	}

	// cleanup and shutdown the thread
	threadWnd.Detach();
	AfxEndThread(nResult);

	return 0;   // not reached
}

#endif //_MT

CWinThread* AFXAPI AfxGetThread()
{
	// check for current thread in module thread state
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	CWinThread* pThread = pState->m_pCurrentWinThread;
	return pThread;
}

MSG* AFXAPI AfxGetCurrentMessage()
{
  _AFX_THREAD_STATE* pState = AfxGetThreadState();
  ASSERT(pState);
  return &(pState->m_msgCur);
}

BOOL AFXAPI AfxInternalPumpMessage()
{
	_AFX_THREAD_STATE *pState = AfxGetThreadState();

	if (!::GetMessage(&(pState->m_msgCur), NULL, NULL, NULL))
	{
#ifdef _DEBUG
		TRACE(traceAppMsg, 1, "CWinThread::PumpMessage - Received WM_QUIT.\n");
			pState->m_nDisablePumpCount++; // application must die
#endif
		// Note: prevents calling message loop things in 'ExitInstance'
		// will never be decremented
		return FALSE;
	}

#ifdef _DEBUG
  if (pState->m_nDisablePumpCount != 0)
	{
	  TRACE(traceAppMsg, 0, "Error: CWinThread::PumpMessage called when not permitted.\n");
	  ASSERT(FALSE);
	}
#endif

#ifdef _DEBUG
	_AfxTraceMsg(_T("PumpMessage"), &(pState->m_msgCur));
#endif

  // process this message

	if (pState->m_msgCur.message != WM_KICKIDLE && !AfxPreTranslateMessage(&(pState->m_msgCur)))
	{
		::TranslateMessage(&(pState->m_msgCur));
		::DispatchMessage(&(pState->m_msgCur));
	}
  return TRUE;
}

BOOL AFXAPI AfxPumpMessage()
{
  CWinThread *pThread = AfxGetThread();
  if( pThread )
	return pThread->PumpMessage();
  else
	return AfxInternalPumpMessage();
}

LRESULT AFXAPI AfxInternalProcessWndProcException(CException*, const MSG* pMsg)
{
  if (pMsg->message == WM_CREATE)
	{
	  return -1;  // just fail
	}
  else if (pMsg->message == WM_PAINT)
	{
	  // force validation of window to prevent getting WM_PAINT again
	  ValidateRect(pMsg->hwnd, NULL);
	  return 0;
	}
  return 0;   // sensible default for rest of commands
}

LRESULT AFXAPI AfxProcessWndProcException(CException* e, const MSG* pMsg)
{
  CWinThread *pThread = AfxGetThread();
  if( pThread )
	return pThread->ProcessWndProcException( e, pMsg );
  else
	return AfxInternalProcessWndProcException( e, pMsg );
}

BOOL AfxInternalPreTranslateMessage(MSG* pMsg)
{
//	ASSERT_VALID(this);

	CWinThread *pThread = AfxGetThread();
	if( pThread )
	{
		// if this is a thread-message, short-circuit this function
		if (pMsg->hwnd == NULL && pThread->DispatchThreadMessageEx(pMsg))
			return TRUE;
	}

	// walk from target to main window
	CWnd* pMainWnd = AfxGetMainWnd();
	if (CWnd::WalkPreTranslateTree(pMainWnd->GetSafeHwnd(), pMsg))
		return TRUE;

	// in case of modeless dialogs, last chance route through main
	//   window's accelerator table
	if (pMainWnd != NULL)
	{
		 CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);
		 if (pWnd->GetTopLevelParent() != pMainWnd)
			return pMainWnd->PreTranslateMessage(pMsg);
	}

	return FALSE;   // no special processing
}

BOOL __cdecl AfxPreTranslateMessage(MSG* pMsg)
{
  CWinThread *pThread = AfxGetThread();
  if( pThread )
	return pThread->PreTranslateMessage( pMsg );
  else
	return AfxInternalPreTranslateMessage( pMsg );
}

BOOL AfxInternalIsIdleMessage(MSG* pMsg)
{
	// Return FALSE if the message just dispatched should _not_
	// cause OnIdle to be run.  Messages which do not usually
	// affect the state of the user interface and happen very
	// often are checked for.

	// redundant WM_MOUSEMOVE and WM_NCMOUSEMOVE
	if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE)
	{
		// mouse move at same position as last mouse move?
	  _AFX_THREAD_STATE *pState = AfxGetThreadState();
		if (pState->m_ptCursorLast == pMsg->pt && pMsg->message == pState->m_nMsgLast)
			return FALSE;

		pState->m_ptCursorLast = pMsg->pt;  // remember for next time
		pState->m_nMsgLast = pMsg->message;
		return TRUE;
	}

	// WM_PAINT and WM_SYSTIMER (caret blink)
	return pMsg->message != WM_PAINT && pMsg->message != 0x0118;
}

BOOL __cdecl AfxIsIdleMessage(MSG* pMsg)
{
  CWinThread *pThread = AfxGetThread();
  if( pThread )
	return pThread->IsIdleMessage( pMsg );
  else
	return AfxInternalIsIdleMessage( pMsg );
}

CWinThread* AFXAPI AfxBeginThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam,
	int nPriority, UINT nStackSize, DWORD dwCreateFlags,
	LPSECURITY_ATTRIBUTES lpSecurityAttrs)
{
#ifndef _MT
	pfnThreadProc;
	pParam;
	nPriority;
	nStackSize;
	dwCreateFlags;
	lpSecurityAttrs;

	return NULL;
#else
	ASSERT(pfnThreadProc != NULL);

	CWinThread* pThread = DEBUG_NEW CWinThread(pfnThreadProc, pParam);
	ASSERT_VALID(pThread);

	if (!pThread->CreateThread(dwCreateFlags|CREATE_SUSPENDED, nStackSize,
		lpSecurityAttrs))
	{
		pThread->Delete();
		return NULL;
	}
	VERIFY(pThread->SetThreadPriority(nPriority));
	if (!(dwCreateFlags & CREATE_SUSPENDED))
		VERIFY(pThread->ResumeThread() != (DWORD)-1);

	return pThread;
#endif //!_MT)
}

CWinThread* AFXAPI AfxBeginThread(CRuntimeClass* pThreadClass,
	int nPriority, UINT nStackSize, DWORD dwCreateFlags,
	LPSECURITY_ATTRIBUTES lpSecurityAttrs)
{
#ifndef _MT
	pThreadClass;
	nPriority;
	nStackSize;
	dwCreateFlags;
	lpSecurityAttrs;

	return NULL;
#else
	ASSERT(pThreadClass != NULL);
	ASSERT(pThreadClass->IsDerivedFrom(RUNTIME_CLASS(CWinThread)));

	CWinThread* pThread = (CWinThread*)pThreadClass->CreateObject();
	if (pThread == NULL)
		AfxThrowMemoryException();
	ASSERT_VALID(pThread);

	pThread->m_pThreadParams = NULL;
	if (!pThread->CreateThread(dwCreateFlags|CREATE_SUSPENDED, nStackSize,
		lpSecurityAttrs))
	{
		pThread->Delete();
		return NULL;
	}
	VERIFY(pThread->SetThreadPriority(nPriority));
	if (!(dwCreateFlags & CREATE_SUSPENDED))
	{
		ENSURE(pThread->ResumeThread() != (DWORD)-1);
	}

	return pThread;
#endif //!_MT
}

void AFXAPI AfxEndThread(UINT nExitCode, BOOL bDelete)
{
#ifndef _MT
	nExitCode;
	bDelete;
#else
	// remove current CWinThread object from memory
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	CWinThread* pThread = pState->m_pCurrentWinThread;
	if (pThread != NULL)
	{
		ASSERT_VALID(pThread);
		ASSERT(pThread != AfxGetApp());

		// cleanup OLE if required
		if (pThread->m_lpfnOleTermOrFreeLib != NULL)
			(*pThread->m_lpfnOleTermOrFreeLib)(TRUE, FALSE);

		if (bDelete)
			pThread->Delete();
		pState->m_pCurrentWinThread = NULL;
	}

	// allow cleanup of any thread local objects
	AfxTermThread();

	// allow C-runtime to cleanup, and exit the thread
	_endthreadex(nExitCode);
#endif //!_MT
}

/////////////////////////////////////////////////////////////////////////////
// Global functions for thread initialization and thread cleanup

LRESULT CALLBACK _AfxMsgFilterHook(int code, WPARAM wParam, LPARAM lParam);

void AFXAPI AfxInitThread()
{
	if (!afxContextIsDLL)
	{
		// set message filter proc
		_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
		ASSERT(pThreadState->m_hHookOldMsgFilter == NULL);
		pThreadState->m_hHookOldMsgFilter = ::SetWindowsHookEx(WH_MSGFILTER,
			_AfxMsgFilterHook, NULL, ::GetCurrentThreadId());
	}
}

extern CThreadSlotData* _afxThreadData;
void AFXAPI AfxTermThread(HINSTANCE hInstTerm)
{
	try
	{
#ifdef _DEBUG
		// check for missing AfxLockTempMap calls
		if (AfxGetModuleThreadState()->m_nTempMapLock != 0)
		{
			TRACE(traceAppMsg, 0, "Warning: Temp map lock count non-zero (%ld).\n",
				AfxGetModuleThreadState()->m_nTempMapLock);
		}
#endif
		AfxLockTempMaps();
		AfxUnlockTempMaps(-1);
	}
	catch( CException* e )
	{
		e->Delete();
	}

	try
	{
		// cleanup thread local tooltip window
		if (hInstTerm == NULL)
		{
			AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();
			if ((pModuleThreadState != NULL) &&
				(pModuleThreadState->m_pToolTip != NULL))
			{
				pModuleThreadState->m_pToolTip->DestroyWindow();
				delete pModuleThreadState->m_pToolTip;
				pModuleThreadState->m_pToolTip=NULL;
			}
		}
	}
	catch( CException* e )
	{
		e->Delete();
	}

	try
	{
		// cleanup the rest of the thread local data
		if (_afxThreadData != NULL)
			_afxThreadData->DeleteValues(hInstTerm, FALSE);
	}
	catch( CException* e )
	{
		e->Delete();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWinThread construction


CWinThread::CWinThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam)
{
	m_pfnThreadProc = pfnThreadProc;
	m_pThreadParams = pParam;

	CommonConstruct();
}

CWinThread::CWinThread()
{
	m_pThreadParams = NULL;
	m_pfnThreadProc = NULL;

	CommonConstruct();
}

void CWinThread::CommonConstruct()
{
	m_pMainWnd = NULL;
	m_pActiveWnd = NULL;

	// no HTHREAD until it is created
	m_hThread = NULL;
	m_nThreadID = 0;

	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	// initialize message pump
#ifdef _DEBUG
	pState->m_nDisablePumpCount = 0;
#endif
	pState->m_msgCur.message = WM_NULL;
	pState->m_nMsgLast = WM_NULL;
	::GetCursorPos(&(pState->m_ptCursorLast));

	// most threads are deleted when not needed
	m_bAutoDelete = TRUE;

	// initialize OLE state
	m_pMessageFilter = NULL;
	m_lpfnOleTermOrFreeLib = NULL;
}


CWinThread::~CWinThread()
{
	// free thread object
	if (m_hThread != NULL)
		CloseHandle(m_hThread);

	// cleanup module state
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	if (pState->m_pCurrentWinThread == this)
		pState->m_pCurrentWinThread = NULL;
}


BOOL CWinThread::CreateThread(DWORD dwCreateFlags, UINT nStackSize,
	LPSECURITY_ATTRIBUTES lpSecurityAttrs)
{
#ifndef _MT
	dwCreateFlags;
	nStackSize;
	lpSecurityAttrs;

	return FALSE;
#else
	ENSURE(m_hThread == NULL);  // already created?

	// setup startup structure for thread initialization
	_AFX_THREAD_STARTUP startup; memset(&startup, 0, sizeof(startup));
	startup.pThreadState = AfxGetThreadState();
	startup.pThread = this;
	startup.hEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	startup.hEvent2 = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	startup.dwCreateFlags = dwCreateFlags;
	if (startup.hEvent == NULL || startup.hEvent2 == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: CreateEvent failed in CWinThread::CreateThread.\n");
		if (startup.hEvent != NULL)
			::CloseHandle(startup.hEvent);
		if (startup.hEvent2 != NULL)
			::CloseHandle(startup.hEvent2);
		return FALSE;
	}

	// create the thread (it may or may not start to run)
	m_hThread = (HANDLE)(ULONG_PTR)_beginthreadex(lpSecurityAttrs, nStackSize,  
		&_AfxThreadEntry, &startup, dwCreateFlags | CREATE_SUSPENDED, (UINT*)&m_nThreadID);
	if (m_hThread == NULL)
	{
		::CloseHandle(startup.hEvent);
		::CloseHandle(startup.hEvent2);
		return FALSE;
	}

	// start the thread just for MFC initialization
	VERIFY(ResumeThread() != (DWORD)-1);
	VERIFY(::WaitForSingleObject(startup.hEvent, INFINITE) == WAIT_OBJECT_0);
	::CloseHandle(startup.hEvent);

	// if created suspended, suspend it until resume thread wakes it up
	if (dwCreateFlags & CREATE_SUSPENDED)
		VERIFY(::SuspendThread(m_hThread) != (DWORD)-1);

	// if error during startup, shut things down
	if (startup.bError)
	{
		VERIFY(::WaitForSingleObject(m_hThread, INFINITE) == WAIT_OBJECT_0);
		::CloseHandle(m_hThread);
		m_hThread = NULL;
		::CloseHandle(startup.hEvent2);
		return FALSE;
	}

	// allow thread to continue, once resumed (it may already be resumed)
	VERIFY(::SetEvent(startup.hEvent2));
	return TRUE;
#endif //!_MT
}

void CWinThread::Delete()
{
	// delete thread if it is auto-deleting
	if (m_bAutoDelete)
		delete this;
}

/////////////////////////////////////////////////////////////////////////////
// CWinThread default implementation

BOOL CWinThread::InitInstance()
{
	ASSERT_VALID(this);

	return FALSE;   // by default don't enter run loop
}

// main running routine until thread exits
int CWinThread::Run()
{
	ASSERT_VALID(this);
	_AFX_THREAD_STATE* pState = AfxGetThreadState();

	// for tracking the idle time state
	BOOL bIdle = TRUE;
	LONG lIdleCount = 0;

	// acquire and dispatch messages until a WM_QUIT message is received.
	for (;;)
	{
		// phase1: check to see if we can do idle work
		while (bIdle &&
			!::PeekMessage(&(pState->m_msgCur), NULL, NULL, NULL, PM_NOREMOVE))
		{
			// call OnIdle while in bIdle state
			if (!OnIdle(lIdleCount++))
				bIdle = FALSE; // assume "no idle" state
		}

		// phase2: pump messages while available
		do
		{
			// pump message, but quit on WM_QUIT
			if (!PumpMessage())
				return ExitInstance();

			// reset "no idle" state after pumping "normal" message
			//if (IsIdleMessage(&m_msgCur))
			if (IsIdleMessage(&(pState->m_msgCur)))
			{
				bIdle = TRUE;
				lIdleCount = 0;
			}

		} while (::PeekMessage(&(pState->m_msgCur), NULL, NULL, NULL, PM_NOREMOVE));
	}
}

BOOL CWinThread::IsIdleMessage(MSG* pMsg)
{
	return AfxInternalIsIdleMessage(pMsg);
}

int CWinThread::ExitInstance()
{
	ASSERT_VALID(this);
	ASSERT(AfxGetApp() != this);
	int nResult = (int)AfxGetCurrentMessage()->wParam;  // returns the value from PostQuitMessage
	return nResult;
}

BOOL CWinThread::OnIdle(LONG lCount)
{
	ASSERT_VALID(this);

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	// check MFC's allocator (before idle)
	if (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_CHECK_ALWAYS_DF)
		ASSERT(AfxCheckMemory());
#endif

	if (lCount <= 0)
	{
		// send WM_IDLEUPDATECMDUI to the main window
		CWnd* pMainWnd = m_pMainWnd;
		if (pMainWnd != NULL && pMainWnd->m_hWnd != NULL &&
			pMainWnd->IsWindowVisible())
		{
			AfxCallWndProc(pMainWnd, pMainWnd->m_hWnd,
				WM_IDLEUPDATECMDUI, (WPARAM)TRUE, 0);
			pMainWnd->SendMessageToDescendants(WM_IDLEUPDATECMDUI,
				(WPARAM)TRUE, 0, TRUE, TRUE);
		}
		// send WM_IDLEUPDATECMDUI to all frame windows
		AFX_MODULE_THREAD_STATE* pState = _AFX_CMDTARGET_GETSTATE()->m_thread;
		CFrameWnd* pFrameWnd = pState->m_frameList;
		while (pFrameWnd != NULL)
		{
			if (pFrameWnd->m_hWnd != NULL && pFrameWnd != pMainWnd)
			{
				if (pFrameWnd->m_nShowDelay == SW_HIDE)
					pFrameWnd->ShowWindow(pFrameWnd->m_nShowDelay);
				if (pFrameWnd->IsWindowVisible() ||
					pFrameWnd->m_nShowDelay >= 0)
				{
					AfxCallWndProc(pFrameWnd, pFrameWnd->m_hWnd,
						WM_IDLEUPDATECMDUI, (WPARAM)TRUE, 0);
					pFrameWnd->SendMessageToDescendants(WM_IDLEUPDATECMDUI,
						(WPARAM)TRUE, 0, TRUE, TRUE);
				}
				if (pFrameWnd->m_nShowDelay > SW_HIDE)
					pFrameWnd->ShowWindow(pFrameWnd->m_nShowDelay);
				pFrameWnd->m_nShowDelay = -1;
			}
			pFrameWnd = pFrameWnd->m_pNextFrameWnd;
		}
	}
	else if (lCount >= 0)
	{
		AFX_MODULE_THREAD_STATE* pState = _AFX_CMDTARGET_GETSTATE()->m_thread;
		if (pState->m_nTempMapLock == 0)
		{
			// free temp maps, OLE DLLs, etc.
			AfxLockTempMaps();
			AfxUnlockTempMaps();
		}
	}

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	// check MFC's allocator (after idle)
	if (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_CHECK_ALWAYS_DF)
		ASSERT(AfxCheckMemory());
#endif

	return lCount < 1;  // nothing more to do if lCount >= 1
}

void CWinThread::DispatchThreadMessage(MSG* pMsg)
{
	DispatchThreadMessageEx(pMsg);
}

BOOL CWinThread::DispatchThreadMessageEx(MSG* pMsg)
{
	const AFX_MSGMAP* pMessageMap; pMessageMap = GetMessageMap();
	const AFX_MSGMAP_ENTRY* lpEntry;

	for (/* pMessageMap already init'ed */; pMessageMap->pfnGetBaseMap != NULL;
		pMessageMap = (*pMessageMap->pfnGetBaseMap)())
	{
		// Note: catch not so common but fatal mistake!!
		//      BEGIN_MESSAGE_MAP(CMyThread, CMyThread)

		ASSERT(pMessageMap != (*pMessageMap->pfnGetBaseMap)());
		if (pMsg->message < 0xC000)
		{
			// constant window message
			if ((lpEntry = AfxFindMessageEntry(pMessageMap->lpEntries,
				pMsg->message, 0, 0)) != NULL)
				goto LDispatch;
		}
		else
		{
			// registered windows message
			lpEntry = pMessageMap->lpEntries;
			while ((lpEntry = AfxFindMessageEntry(lpEntry, 0xC000, 0, 0)) != NULL)
			{
				UINT* pnID = (UINT*)(lpEntry->nSig);
				ASSERT(*pnID >= 0xC000);
					// must be successfully registered
				if (*pnID == pMsg->message)
					goto LDispatch;
				lpEntry++;      // keep looking past this one
			}
		}
	}
	return FALSE;

LDispatch:
	union MessageMapFunctions mmf;
	mmf.pfn = lpEntry->pfn;

	// always posted, so return value is meaningless

	(this->*mmf.pfn_THREAD)(pMsg->wParam, pMsg->lParam);
	return TRUE;
}

BOOL CWinThread::PreTranslateMessage(MSG* pMsg)
{
	ASSERT_VALID(this);
	return AfxInternalPreTranslateMessage( pMsg );
}

LRESULT CWinThread::ProcessWndProcException(CException* e, const MSG* pMsg)
{
  return AfxInternalProcessWndProcException( e, pMsg );
}

/////////////////////////////////////////////////////////////////////////////
// Message Filter processing (WH_MSGFILTER)

LRESULT CALLBACK _AfxMsgFilterHook(int code, WPARAM wParam, LPARAM lParam)
{
	CWinThread* pThread;
	if (afxContextIsDLL || (code < 0 && code != MSGF_DDEMGR) ||
		(pThread = AfxGetThread()) == NULL)
	{
		return ::CallNextHookEx(_afxThreadState->m_hHookOldMsgFilter,
			code, wParam, lParam);
	}
	ASSERT(pThread != NULL);
	return (LRESULT)pThread->ProcessMessageFilter(code, (LPMSG)lParam);
}

AFX_STATIC BOOL AFXAPI IsHelpKey(LPMSG lpMsg)
	// return TRUE only for non-repeat F1 keydowns.
{
	return lpMsg->message == WM_KEYDOWN &&
		   lpMsg->wParam == VK_F1 &&
		   !(HIWORD(lpMsg->lParam) & KF_REPEAT) &&
		   GetKeyState(VK_SHIFT) >= 0 &&
		   GetKeyState(VK_CONTROL) >= 0 &&
		   GetKeyState(VK_MENU) >= 0;
}

AFX_STATIC inline BOOL IsEnterKey(LPMSG lpMsg)
	{ return lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_RETURN; }

AFX_STATIC inline BOOL IsButtonUp(LPMSG lpMsg)
	{ return lpMsg->message == WM_LBUTTONUP; }

BOOL CWinThread::ProcessMessageFilter(int code, LPMSG lpMsg)
{
	if (lpMsg == NULL)
		return FALSE;   // not handled

	CFrameWnd* pTopFrameWnd;
	CWnd* pMainWnd;
	CWnd* pMsgWnd;
	switch (code)
	{
	case MSGF_DDEMGR:
		// Unlike other WH_MSGFILTER codes, MSGF_DDEMGR should
		//  never call the next hook.
		// By returning FALSE, the message will be dispatched
		//  instead (the default behavior).
		return FALSE;

	case MSGF_MENU:
		pMsgWnd = CWnd::FromHandle(lpMsg->hwnd);
		if (pMsgWnd != NULL)
		{
			pTopFrameWnd = pMsgWnd->GetTopLevelFrame();
			if (pTopFrameWnd != NULL && pTopFrameWnd->IsTracking() &&
				pTopFrameWnd->m_bHelpMode)
			{
				pMainWnd = AfxGetMainWnd();
				if ((m_pMainWnd != NULL) && (IsEnterKey(lpMsg) || IsButtonUp(lpMsg)))
				{
					pMainWnd->SendMessage(WM_COMMAND, ID_HELP);
					return TRUE;
				}
			}
		}
		// fall through...

	case MSGF_DIALOGBOX:    // handles message boxes as well.
		pMainWnd = AfxGetMainWnd();
		if (code == MSGF_DIALOGBOX && m_pActiveWnd != NULL &&
			lpMsg->message >= WM_KEYFIRST && lpMsg->message <= WM_KEYLAST)
		{
			// need to translate messages for the in-place container
			_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
            ENSURE(pThreadState);

			if (pThreadState->m_bInMsgFilter)
				return FALSE;
			pThreadState->m_bInMsgFilter = TRUE;    // avoid reentering this code
			MSG msg = *lpMsg;
			if (m_pActiveWnd->IsWindowEnabled() && PreTranslateMessage(&msg))
			{
				pThreadState->m_bInMsgFilter = FALSE;
				return TRUE;
			}
			pThreadState->m_bInMsgFilter = FALSE;    // ok again
		}
		break;
	}

	return FALSE;   // default to not handled
}

/////////////////////////////////////////////////////////////////////////////
// Access to m_pMainWnd & m_pActiveWnd

CWnd* CWinThread::GetMainWnd()
{
	if (m_pActiveWnd != NULL)
		return m_pActiveWnd;    // probably in-place active

	// when not inplace active, just return main window
	if (m_pMainWnd != NULL)
		return m_pMainWnd;

	return CWnd::GetActiveWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CWinThread implementation helpers

BOOL CWinThread::PumpMessage()
{
  return AfxInternalPumpMessage();
}

/////////////////////////////////////////////////////////////////////////////
// CWinThread diagnostics

#ifdef _DEBUG
void CWinThread::AssertValid() const
{
	CCmdTarget::AssertValid();
}

void CWinThread::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);
	_AFX_THREAD_STATE *pState = AfxGetThreadState();

	dc << "m_pThreadParams = " << m_pThreadParams;
	dc << "\nm_pfnThreadProc = " << (void*)m_pfnThreadProc;
	dc << "\nm_bAutoDelete = " << m_bAutoDelete;
	dc << "\nm_hThread = " << (void*)m_hThread;
	dc << "\nm_nThreadID = " << m_nThreadID;
	dc << "\nm_nDisablePumpCount = " << pState->m_nDisablePumpCount;
	if (AfxGetThread() == this)
		dc << "\nm_pMainWnd = " << m_pMainWnd;

	dc << "\nm_msgCur = {";
	dc << "\n\thwnd = " << (void*)pState->m_msgCur.hwnd;
	dc << "\n\tmessage = " << (UINT)pState->m_msgCur.message;
	dc << "\n\twParam = " << (UINT)pState->m_msgCur.wParam;
	dc << "\n\tlParam = " << (void*)pState->m_msgCur.lParam;
	dc << "\n\ttime = " << pState->m_msgCur.time;
	dc << "\n\tpt = " << CPoint(pState->m_msgCur.pt);
	dc << "\n}";

	dc << "\nm_pThreadParams = " << m_pThreadParams;
	dc << "\nm_pfnThreadProc = " << (void*)m_pfnThreadProc;
	dc << "\nm_ptCursorLast = " << pState->m_ptCursorLast;
	dc << "\nm_nMsgLast = " << pState->m_nMsgLast;

	dc << "\n";
}
#endif


IMPLEMENT_DYNAMIC(CWinThread, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\tooltip.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CToolTipCtrl

//MFC now enforces characters limit when updateing tooltip text.
//This is to prevent buffer overrun in GetText.
const size_t MAX_TIP_TEXT_LENGTH = 1024;

BEGIN_MESSAGE_MAP(CToolTipCtrl, CWnd)
	//{{AFX_MSG_MAP(CToolTipCtrl)
	ON_MESSAGE(WM_DISABLEMODAL, &CToolTipCtrl::OnDisableModal)
	ON_MESSAGE(TTM_WINDOWFROMPOINT, &CToolTipCtrl::OnWindowFromPoint)
	ON_MESSAGE(TTM_ADDTOOL, &CToolTipCtrl::OnAddTool)
	ON_WM_ENABLE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CToolTipCtrl::CToolTipCtrl()
{
}

BOOL CToolTipCtrl::Create(CWnd* pParentWnd, DWORD dwStyle /* = 0 */)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_BAR_REG));

	BOOL bResult = CWnd::CreateEx(NULL, TOOLTIPS_CLASS, NULL,
		WS_POPUP | dwStyle, // force WS_POPUP
		CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
		pParentWnd->GetSafeHwnd(), NULL, NULL);

	if (bResult)
		SetOwner(pParentWnd);
	return bResult;
}

BOOL CToolTipCtrl::CreateEx(CWnd* pParentWnd, DWORD dwStyle /* = 0 */,
	DWORD dwExStyle /* = 0 */)
{
	return Create(pParentWnd, dwStyle) &&
		ModifyStyleEx(0, dwExStyle);
}


CToolTipCtrl::~CToolTipCtrl()
{
	DestroyWindow();
}

BOOL CToolTipCtrl::DestroyToolTipCtrl()
{
#ifdef _AFXDLL
	BOOL bDestroy = (AfxGetModuleState() == m_pModuleState);
#else
	BOOL bDestroy = TRUE;
#endif

	if (bDestroy)
	{
		DestroyWindow();
		delete this;
	}
	return bDestroy;
}

LRESULT CToolTipCtrl::OnAddTool(WPARAM wParam, LPARAM lParam)
{
	TOOLINFO ti = *(LPTOOLINFO)lParam;
	if ((ti.hinst == NULL) && (ti.lpszText != LPSTR_TEXTCALLBACK)
		&& (ti.lpszText != NULL))
	{
		void* pv;
		if (!m_mapString.Lookup(ti.lpszText, pv))
			m_mapString.SetAt(ti.lpszText, NULL);
		// set lpszText to point to the permanent memory associated
		// with the CString
		LPCTSTR lpszText = NULL;
		VERIFY(m_mapString.LookupKey(ti.lpszText, lpszText));
		ti.lpszText = const_cast<LPTSTR>(lpszText);
	}
	return DefWindowProc(TTM_ADDTOOL, wParam, (LPARAM)&ti);
}

LRESULT CToolTipCtrl::OnDisableModal(WPARAM, LPARAM)
{
	SendMessage(TTM_ACTIVATE, FALSE);
	return FALSE;
}

void CToolTipCtrl::OnEnable(BOOL bEnable)
{
	SendMessage(TTM_ACTIVATE, bEnable);
}

LRESULT CToolTipCtrl::OnWindowFromPoint(WPARAM, LPARAM lParam)
{
	ASSERT(lParam != NULL);

	// the default implementation of tooltips just calls WindowFromPoint
	// which does not work for certain kinds of combo boxes
	CPoint pt = *(POINT*)lParam;
	HWND hWnd = ::WindowFromPoint(pt);
	if (hWnd == NULL)
		return 0;

	// try to hit combobox instead of edit control for CBS_DROPDOWN styles
	HWND hWndTemp = ::GetParent(hWnd);
	if (hWndTemp != NULL && _AfxIsComboBoxControl(hWndTemp, CBS_DROPDOWN))
		return (LRESULT)hWndTemp;

	// handle special case of disabled child windows
	::ScreenToClient(hWnd, &pt);
	hWndTemp = _AfxChildWindowFromPoint(hWnd, pt);
	if (hWndTemp != NULL && !::IsWindowEnabled(hWndTemp))
		return (LRESULT)hWndTemp;

	return (LRESULT)hWnd;
}

BOOL CToolTipCtrl::AddTool(CWnd* pWnd, LPCTSTR lpszText, LPCRECT lpRectTool,
	UINT_PTR nIDTool)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pWnd != NULL);
	ASSERT(lpszText != NULL);
	// the toolrect and toolid must both be zero or both valid
	ASSERT((lpRectTool != NULL && nIDTool != 0) ||
		   (lpRectTool == NULL) && (nIDTool == 0));

	TOOLINFO ti;
	FillInToolInfo(ti, pWnd, nIDTool);
	if (lpRectTool != NULL)
	{
		Checked::memcpy_s(&ti.rect, sizeof(RECT), lpRectTool, sizeof(RECT));
	}

	ti.lpszText = (LPTSTR)lpszText;
	return (BOOL) ::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)&ti);
}

BOOL CToolTipCtrl::AddTool(CWnd* pWnd, UINT nIDText, LPCRECT lpRectTool,
	UINT_PTR nIDTool)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(nIDText != 0);
	ASSERT(pWnd != NULL);
	// the toolrect and toolid must both be zero or both valid
	ASSERT((lpRectTool != NULL && nIDTool != 0) ||
		   (lpRectTool == NULL) && (nIDTool == 0));

	TOOLINFO ti;
	FillInToolInfo(ti, pWnd, nIDTool);
	if (lpRectTool != NULL)
	{
		Checked::memcpy_s(&ti.rect, sizeof(RECT), lpRectTool, sizeof(RECT));
	}

	ti.hinst = AfxFindResourceHandle(MAKEINTRESOURCE((nIDText>>4)+1),
		RT_STRING);
	ASSERT(ti.hinst != NULL);
	ti.lpszText = (LPTSTR)MAKEINTRESOURCE(nIDText);
	return (BOOL) ::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)&ti);
}

void CToolTipCtrl::DelTool(CWnd* pWnd, UINT_PTR nIDTool)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pWnd != NULL);

	TOOLINFO ti;
	FillInToolInfo(ti, pWnd, nIDTool);
	::SendMessage(m_hWnd, TTM_DELTOOL, 0, (LPARAM)&ti);
}

void CToolTipCtrl::GetText(CString& str, CWnd* pWnd, UINT_PTR nIDTool) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pWnd != NULL);

	TOOLINFO ti;
	FillInToolInfo(ti, pWnd, nIDTool);
	//Dogtag to detect buffer overruns in TTM_GETTEXT (Cannot query for text len).
	const TCHAR _OverrunDetector[] = _T("M\0FC");
	ti.lpszText = str.GetBuffer(MAX_TIP_TEXT_LENGTH + _countof(_OverrunDetector) );
	memset(ti.lpszText,0,MAX_TIP_TEXT_LENGTH*sizeof(TCHAR));
	Checked::memcpy_s(ti.lpszText + MAX_TIP_TEXT_LENGTH, sizeof(_OverrunDetector), 
		_OverrunDetector,sizeof(_OverrunDetector));
	::SendMessage(m_hWnd, TTM_GETTEXT, 0, (LPARAM)&ti);	
	ENSURE_THROW(memcmp(_OverrunDetector,ti.lpszText + MAX_TIP_TEXT_LENGTH,sizeof(_OverrunDetector)) == 0,::AfxThrowMemoryException());
	str.ReleaseBuffer();
}

BOOL CToolTipCtrl::GetToolInfo(CToolInfo& ToolInfo, CWnd* pWnd,
	UINT_PTR nIDTool) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pWnd != NULL);

	FillInToolInfo(ToolInfo, pWnd, nIDTool);
	ToolInfo.lpszText = ToolInfo.szText;
	return (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, (LPARAM)&ToolInfo);
}

BOOL CToolTipCtrl::HitTest(CWnd* pWnd, CPoint pt, LPTOOLINFO lpToolInfo) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pWnd != NULL);
	ASSERT(lpToolInfo != NULL);

	TTHITTESTINFO hti;
	memset(&hti, 0, sizeof(hti));
	hti.ti.cbSize = sizeof(AFX_OLDTOOLINFO);
	hti.hwnd = pWnd->GetSafeHwnd();
	hti.pt.x = pt.x;
	hti.pt.y = pt.y;

	if ((BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)&hti))
	{
		Checked::memcpy_s(lpToolInfo, sizeof(TOOLINFO), &hti.ti, sizeof(AFX_OLDTOOLINFO));
		return TRUE;
	}

	return FALSE;
}

void CToolTipCtrl::SetToolRect(CWnd* pWnd, UINT_PTR nIDTool, LPCRECT lpRect)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pWnd != NULL);
	ASSERT(nIDTool != 0);

	TOOLINFO ti;
	FillInToolInfo(ti, pWnd, nIDTool);
	Checked::memcpy_s(&ti.rect, sizeof(RECT), lpRect, sizeof(RECT));
	::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);
}

void CToolTipCtrl::UpdateTipText(LPCTSTR lpszText, CWnd* pWnd, UINT_PTR nIDTool)
{
	ENSURE(::IsWindow(m_hWnd));
	ENSURE_ARG(pWnd != NULL);	
	
	if(lpszText != LPSTR_TEXTCALLBACK)
	{
		ENSURE_ARG(_tcslen(lpszText) <= MAX_TIP_TEXT_LENGTH);	
	}
	
	TOOLINFO ti;
	FillInToolInfo(ti, pWnd, nIDTool);
	ti.lpszText = (LPTSTR)lpszText;
	::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
}

void CToolTipCtrl::UpdateTipText(UINT nIDText, CWnd* pWnd, UINT_PTR nIDTool)
{
	ASSERT(nIDText != 0);

	CString str;
	ENSURE(str.LoadString(nIDText));
	UpdateTipText(str, pWnd, nIDTool);
}

/////////////////////////////////////////////////////////////////////////////
// CToolTipCtrl Implementation

void CToolTipCtrl::FillInToolInfo(TOOLINFO& ti, CWnd* pWnd, UINT_PTR nIDTool) const
{
	memset(&ti, 0, sizeof(AFX_OLDTOOLINFO));
	ti.cbSize = sizeof(AFX_OLDTOOLINFO);
	HWND hwnd = pWnd->GetSafeHwnd();
	if (nIDTool == 0)
	{
		ti.hwnd = ::GetParent(hwnd);
		ti.uFlags = TTF_IDISHWND;
		ti.uId = (UINT_PTR)hwnd;
	}
	else
	{
		ti.hwnd = hwnd;
		ti.uFlags = 0;
		ti.uId = nIDTool;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWnd tooltip support

BOOL CWnd::_EnableToolTips(BOOL bEnable, UINT nFlag)
{
	ASSERT(nFlag == WF_TOOLTIPS || nFlag == WF_TRACKINGTOOLTIPS);

	AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();
	CToolTipCtrl* pToolTip = pModuleThreadState->m_pToolTip;

	if (!bEnable)
	{
		// nothing to do if tooltips not enabled
		if (!(m_nFlags & nFlag))
			return TRUE;

		// cancel tooltip if this window is active
		if (pModuleThreadState->m_pLastHit == this)
			CancelToolTips(TRUE);

		// remove "dead-area" toolbar
		if (pToolTip->GetSafeHwnd() != NULL)
		{
			TOOLINFO ti; memset(&ti, 0, sizeof(TOOLINFO));
			ti.cbSize = sizeof(AFX_OLDTOOLINFO);
			ti.uFlags = TTF_IDISHWND;
			ti.hwnd = m_hWnd;
			ti.uId = (UINT_PTR)m_hWnd;
			pToolTip->SendMessage(TTM_DELTOOL, 0, (LPARAM)&ti);
		}

		// success
		m_nFlags &= ~nFlag;
		return TRUE;
	}

	// if already enabled for tooltips, nothing to do
	if (!(m_nFlags & nFlag))
	{
		// success
		AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();
		pModuleState->m_pfnFilterToolTipMessage = &CWnd::_FilterToolTipMessage;
		m_nFlags |= nFlag;
	}
	return TRUE;
}

BOOL CWnd::EnableToolTips(BOOL bEnable)
{
	return _EnableToolTips(bEnable, WF_TOOLTIPS);
}

BOOL CWnd::EnableTrackingToolTips(BOOL bEnable)
{
	return _EnableToolTips(bEnable, WF_TRACKINGTOOLTIPS);
}

AFX_STATIC void AFXAPI _AfxRelayToolTipMessage(CToolTipCtrl* pToolTip, MSG* pMsg)
{
	// transate the message based on TTM_WINDOWFROMPOINT
	MSG msg = *pMsg;
	msg.hwnd = (HWND)pToolTip->SendMessage(TTM_WINDOWFROMPOINT, 0, (LPARAM)&msg.pt);
	CPoint pt = pMsg->pt;
	if (msg.message >= WM_MOUSEFIRST && msg.message <= AFX_WM_MOUSELAST)
		::ScreenToClient(msg.hwnd, &pt);
	msg.lParam = MAKELONG(pt.x, pt.y);

	// relay mouse event before deleting old tool
	pToolTip->SendMessage(TTM_RELAYEVENT, 0, (LPARAM)&msg);
}

void PASCAL CWnd::_FilterToolTipMessage(MSG* pMsg, CWnd* pWnd)
{
	pWnd->FilterToolTipMessage(pMsg);
}

void CWnd::FilterToolTipMessage(MSG* pMsg)
{
	// this CWnd has tooltips enabled
	UINT message = pMsg->message;
	if ((message == WM_MOUSEMOVE || message == WM_NCMOUSEMOVE ||
		 message == WM_LBUTTONUP || message == WM_RBUTTONUP ||
		 message == WM_MBUTTONUP) &&
		(GetKeyState(VK_LBUTTON) >= 0 && GetKeyState(VK_RBUTTON) >= 0 &&
		 GetKeyState(VK_MBUTTON) >= 0))
	{
		AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();

		// make sure that tooltips are not already being handled
		CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);
		while (pWnd != NULL && !(pWnd->m_nFlags & (WF_TOOLTIPS|WF_TRACKINGTOOLTIPS)))
		{
			pWnd = pWnd->GetParent();
		}
		if (pWnd != this)
		{
			if (pWnd == NULL)
			{
				// tooltips not enabled on this CWnd, clear last state data
				pModuleThreadState->m_pLastHit = NULL;
				pModuleThreadState->m_nLastHit = static_cast<INT_PTR>(-1);
			}
			return;
		}

		CToolTipCtrl* pToolTip = pModuleThreadState->m_pToolTip;
		CWnd* pOwner = GetParentOwner();
		if (pToolTip != NULL && pToolTip->GetOwner() != pOwner)
		{
			pToolTip->DestroyWindow();
			delete pToolTip;
			pModuleThreadState->m_pToolTip = NULL;
			pToolTip = NULL;
		}
		if (pToolTip == NULL)
		{
			pToolTip = new CToolTipCtrl;
			if (!pToolTip->Create(pOwner, TTS_ALWAYSTIP))
			{
				delete pToolTip;
				return;
			}
			pToolTip->SendMessage(TTM_ACTIVATE, FALSE);
			pModuleThreadState->m_pToolTip = pToolTip;
		}

		ASSERT_VALID(pToolTip);
		ASSERT(::IsWindow(pToolTip->m_hWnd));

		TOOLINFO ti; memset(&ti, 0, sizeof(TOOLINFO));

		// determine which tool was hit
		CPoint point = pMsg->pt;
		::ScreenToClient(m_hWnd, &point);
		TOOLINFO tiHit; memset(&tiHit, 0, sizeof(TOOLINFO));
		tiHit.cbSize = sizeof(AFX_OLDTOOLINFO);
		INT_PTR nHit = OnToolHitTest(point, &tiHit);

		// build new toolinfo and if different than current, register it
		CWnd* pHitWnd = nHit == -1 ? NULL : this;
		if (pModuleThreadState->m_nLastHit != nHit || pModuleThreadState->m_pLastHit != pHitWnd)
		{
			if (nHit != -1)
			{
				// add new tool and activate the tip
				ti = tiHit;
				ti.uFlags &= ~(TTF_NOTBUTTON|TTF_ALWAYSTIP);
				if (m_nFlags & WF_TRACKINGTOOLTIPS)
					ti.uFlags |= TTF_TRACK;
				VERIFY(pToolTip->SendMessage(TTM_ADDTOOL, 0, (LPARAM)&ti));
				if ((tiHit.uFlags & TTF_ALWAYSTIP) || IsTopParentActive())
				{
					// allow the tooltip to popup when it should
					pToolTip->SendMessage(TTM_ACTIVATE, TRUE);
					if (m_nFlags & WF_TRACKINGTOOLTIPS)
						pToolTip->SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);

					// bring the tooltip window above other popup windows
					::SetWindowPos(pToolTip->m_hWnd, HWND_TOP, 0, 0, 0, 0,
						SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE|SWP_NOOWNERZORDER);
				}
			}
			else
			{
				pToolTip->SendMessage(TTM_ACTIVATE, FALSE);
			}

			// relay mouse event before deleting old tool
			_AfxRelayToolTipMessage(pToolTip, pMsg);

			// now safe to delete the old tool
			if (pModuleThreadState->m_pLastInfo != NULL &&
					pModuleThreadState->m_pLastInfo->cbSize >= sizeof(AFX_OLDTOOLINFO))
				pToolTip->SendMessage(TTM_DELTOOL, 0, (LPARAM)pModuleThreadState->m_pLastInfo);

			pModuleThreadState->m_pLastHit = pHitWnd;
			pModuleThreadState->m_nLastHit = nHit;
			if (pModuleThreadState->m_pLastInfo == NULL)
			{
				pModuleThreadState->m_pLastInfo = new TOOLINFO;
				memset(pModuleThreadState->m_pLastInfo, 0, sizeof(TOOLINFO));
			}
			*pModuleThreadState->m_pLastInfo = tiHit;
		}
		else
		{
			if (m_nFlags & WF_TRACKINGTOOLTIPS)
			{
				POINT pt;

				::GetCursorPos( &pt );
				pToolTip->SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(pt.x, pt.y));
			}
			else
			{
				// relay mouse events through the tooltip
				if (nHit != -1)
					_AfxRelayToolTipMessage(pToolTip, pMsg);
			}
		}

		if ((tiHit.lpszText != LPSTR_TEXTCALLBACK) && (tiHit.hinst == 0))
			free(tiHit.lpszText);
	}
	else if (m_nFlags & (WF_TOOLTIPS|WF_TRACKINGTOOLTIPS))
	{
		// make sure that tooltips are not already being handled
		CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);
		while (pWnd != NULL && pWnd != this && !(pWnd->m_nFlags & (WF_TOOLTIPS|WF_TRACKINGTOOLTIPS)))
			pWnd = pWnd->GetParent();
		if (pWnd != this)
			return;

		BOOL bKeys = (message >= WM_KEYFIRST && message <= WM_KEYLAST) ||
			(message >= WM_SYSKEYFIRST && message <= WM_SYSKEYLAST);
		if ((m_nFlags & WF_TRACKINGTOOLTIPS) == 0 &&
			(bKeys ||
			 (message == WM_LBUTTONDOWN || message == WM_LBUTTONDBLCLK) ||
			 (message == WM_RBUTTONDOWN || message == WM_RBUTTONDBLCLK) ||
			 (message == WM_MBUTTONDOWN || message == WM_MBUTTONDBLCLK) ||
			 (message == WM_NCLBUTTONDOWN || message == WM_NCLBUTTONDBLCLK) ||
			 (message == WM_NCRBUTTONDOWN || message == WM_NCRBUTTONDBLCLK) ||
			 (message == WM_NCMBUTTONDOWN || message == WM_NCMBUTTONDBLCLK)))
		{
			CWnd::CancelToolTips(bKeys);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(CToolTipCtrl, CWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\strcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixalloc.h"
#include <afxtempl.h>
#include "sal.h"


// MFC-enabled compilation. Use MFC memory management and exceptions;
// also, use MFC module state.

LPWSTR AFXAPI AfxA2WHelper(_Out_z_cap_(nChars) LPWSTR lpw, _In_z_ LPCSTR lpa, _In_ int nChars)
{
	return AtlA2WHelper(lpw, lpa, nChars,CP_ACP);
}

LPSTR AFXAPI AfxW2AHelper(_Out_z_cap_(nChars) LPSTR lpa, _In_z_ LPCWSTR lpw, _In_ int nChars)
{
	return AtlW2AHelper(lpa, lpw, nChars, CP_ACP);
}

///////////////////////////////////////////////////////////////////////////////
// CComBSTR support for template collections

template<> UINT AFXAPI HashKey<CComBSTR> (CComBSTR key)
{
	// hash key to UINT value by pseudorandomizing transform
	// (algorithm copied from STL string hash in xfunctional)
	UINT uHashVal = 2166136261U;
	UINT uFirst = 0;
	UINT uLast = (UINT)wcslen(key);
	UINT uStride = 1 + uLast / 10;

	for(; uFirst < uLast; uFirst += uStride)
	{
		uHashVal = 16777619U * uHashVal ^ (UINT)key[uFirst];
	}

	return(uHashVal);
}

template<>
void AFXAPI SerializeElements<CComBSTR> (CArchive& ar, CComBSTR* pElements, INT_PTR nCount)
{
	SerializeElementsInsertExtract(ar, pElements, nCount);
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key)
{
	ENSURE_ARG(AfxIsValidString(key));

	// hash key to UINT value by pseudorandomizing transform
	// (algorithm copied from STL string hash in xfunctional)
	UINT uHashVal = 2166136261U;
	UINT uFirst = 0;
	UINT uLast = (UINT)wcslen(key);
	UINT uStride = 1 + uLast / 10;

	for(; uFirst < uLast; uFirst += uStride)
	{
		uHashVal = 16777619U * uHashVal ^ (UINT)key[uFirst];
	}

	return(uHashVal);
}

template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key)
{
	ENSURE_ARG(AfxIsValidString(key));

	// hash key to UINT value by pseudorandomizing transform
	// (algorithm copied from STL string hash in xfunctional)
	UINT uHashVal = 2166136261U;
	UINT uFirst = 0;
	UINT uLast = (UINT)strlen(key);
	UINT uStride = 1 + uLast / 10;

	for(; uFirst < uLast; uFirst += uStride)
	{
		uHashVal = 16777619U * uHashVal ^ (UINT)key[uFirst];
	}

	return(uHashVal);
}

template<>
void AFXAPI SerializeElements< CStringA >(CArchive& ar, CStringA* pElements, INT_PTR nCount)
{
	SerializeElementsInsertExtract(ar, pElements, nCount);
}

template<>
void AFXAPI SerializeElements< CStringW >(CArchive& ar, CStringW* pElements, INT_PTR nCount)
{
	SerializeElementsInsertExtract(ar, pElements, nCount);
}

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

class CAfxStringMgr :
	public IAtlStringMgr
{
public:
	CAfxStringMgr()
	{
		m_nil.SetManager( this );
	}

// IAtlStringMgr
public:
	virtual CStringData* Allocate( int nChars, int nCharSize ) throw();
	virtual void Free( CStringData* pData ) throw();
	virtual CStringData* Reallocate( CStringData* pData, int nChars, int nCharSize ) throw();
	virtual CStringData* GetNilString() throw();
	virtual IAtlStringMgr* Clone() throw();

protected:
	CNilStringData m_nil;
};

CAfxStringMgr afxStringManager;

IAtlStringMgr* AFXAPI AfxGetStringManager()
{
	return &afxStringManager;
}

CStringData* CAfxStringMgr::Allocate( int nChars, int nCharSize ) throw()
{
	size_t nTotalSize;
	CStringData* pData;
	size_t nDataBytes;

	ASSERT(nCharSize > 0);
	
	if(nChars < 0)
	{
		ASSERT(FALSE);
		return NULL;
	}
	
	nDataBytes = (nChars+1)*nCharSize;
	nTotalSize = sizeof( CStringData )+nDataBytes;
	pData = (CStringData*)malloc( nTotalSize );
	if (pData == NULL)
		return NULL;
	pData->pStringMgr = this;
	pData->nRefs = 1;
	pData->nAllocLength = nChars;
	pData->nDataLength = 0;

	return pData;
}

void CAfxStringMgr::Free( CStringData* pData ) throw()
{
	free(pData);
}

CStringData* CAfxStringMgr::Reallocate( CStringData* pData, int nChars, int nCharSize ) throw()
{
	CStringData* pNewData;
	size_t nTotalSize;
	size_t nDataBytes;
	
	ASSERT(nCharSize > 0);
	
	if(nChars < 0)
	{
		ASSERT(FALSE);
		return NULL;
	}
	
	nDataBytes = (nChars+1)*nCharSize;
	nTotalSize = sizeof( CStringData )+nDataBytes;
	pNewData = (CStringData*)realloc( pData, nTotalSize );
	if( pNewData == NULL )
	{
		return NULL;
	}
	pNewData->nAllocLength = nChars;

	return pNewData;
}


CStringData* CAfxStringMgr::GetNilString() throw()
{
	m_nil.AddRef();
	return &m_nil;
}

IAtlStringMgr* CAfxStringMgr::Clone() throw()
{
	return this;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\validadd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



// AfxIsValidString() returns TRUE if the passed pointer
// references a string of at least the given length in characters.
// A length of -1 (the default parameter) means that the string
// buffer's minimum length isn't known, and the function will
// return TRUE no matter how long the string is. The memory
// used by the string can be read-only.

BOOL AFXAPI AfxIsValidString(LPCWSTR psz, int nLength /* = -1 */)
{
	return ATL::AtlIsValidString(psz, nLength);
}

// As above, but for ANSI strings.

BOOL AFXAPI AfxIsValidString(LPCSTR psz, int nLength /* = -1 */)
{
	return ATL::AtlIsValidString(psz, nLength);
}

// AfxIsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const.

BOOL AFXAPI AfxIsValidAddress(const void* p, UINT_PTR nBytes,
	BOOL bReadWrite /* = TRUE */)
{
	return ATL::AtlIsValidAddress(p, nBytes, bReadWrite);
}

// AfxIsValidAtom() returns TRUE if the passed parameter is 
// a valid local or global atom.

BOOL AfxIsValidAtom(ATOM nAtom)
{
	TCHAR sBuffer[256];
	if (GetAtomName(nAtom, sBuffer, _countof(sBuffer)))
	{
		return TRUE;
	}
	DWORD dwError = GetLastError();
	if (dwError == ERROR_INSUFFICIENT_BUFFER || dwError == ERROR_MORE_DATA)
	{
		return TRUE;
	}
	if (GlobalGetAtomName(nAtom, sBuffer, _countof(sBuffer)))
	{
		return TRUE;
	}
	dwError = GetLastError();
	if (dwError == ERROR_INSUFFICIENT_BUFFER || dwError == ERROR_MORE_DATA)
	{
		return TRUE;
	}
	return FALSE;
}

// AfxIsValidAddress() returns TRUE if the passed parameter is 
// a valid representation of a local or a global atom within a LPCTSTR.

BOOL AfxIsValidAtom(LPCTSTR psz)
{
	return HIWORD(psz) == 0L && AfxIsValidAtom(ATOM(LOWORD(psz)));
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewcmn.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CListView

BEGIN_MESSAGE_MAP(CListView, CCtrlView)
	//{{AFX_MSG_MAP(CListView)
	ON_WM_NCDESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CListView::PreCreateWindow(CREATESTRUCT& cs)
{
	return CCtrlView::PreCreateWindow(cs);
}

void CListView::DrawItem(LPDRAWITEMSTRUCT)
{
	ASSERT(FALSE);
}

BOOL CListView::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	if (message != WM_DRAWITEM)
		return CCtrlView::OnChildNotify(message, wParam, lParam, pResult);

	ASSERT(pResult == NULL);       // no return value expected
	UNUSED(pResult); // unused in release builds

	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
}

void CListView::RemoveImageList(int nImageList)
{
	HIMAGELIST h = (HIMAGELIST)SendMessage(LVM_GETIMAGELIST,
		(WPARAM)nImageList);
	if (CImageList::FromHandlePermanent(h) != NULL)
		SendMessage(LVM_SETIMAGELIST, (WPARAM)nImageList, NULL);
}

void CListView::OnNcDestroy()
{
	RemoveImageList(LVSIL_NORMAL);
	RemoveImageList(LVSIL_SMALL);
	RemoveImageList(LVSIL_STATE);

	CCtrlView::OnNcDestroy();
}

/////////////////////////////////////////////////////////////////////////////
// CTreeView

BEGIN_MESSAGE_MAP(CTreeView, CCtrlView)
	//{{AFX_MSG_MAP(CTreeView)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CTreeView::PreCreateWindow(CREATESTRUCT& cs)
{
	return CCtrlView::PreCreateWindow(cs);
}

void CTreeView::RemoveImageList(int nImageList)
{
	HIMAGELIST h = (HIMAGELIST)SendMessage(TVM_GETIMAGELIST,
		(WPARAM)nImageList);
	if (CImageList::FromHandlePermanent(h) != NULL)
		SendMessage(TVM_SETIMAGELIST, (WPARAM)nImageList, NULL);
}

void CTreeView::OnDestroy()
{
	RemoveImageList(LVSIL_NORMAL);
	RemoveImageList(LVSIL_STATE);

	CCtrlView::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_ENABLE_INLINES

#define _AFXCVIEW_INLINE
#include "afxcview.inl"

#endif //_AFX_ENABLE_INLINES


IMPLEMENT_DYNCREATE(CListView, CCtrlView)
IMPLEMENT_DYNCREATE(CTreeView, CCtrlView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\trckrect.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CRectTracker global state

// various GDI objects we need to draw
AFX_STATIC_DATA HCURSOR _afxCursors[10] = { 0, };
AFX_STATIC_DATA HBRUSH _afxHatchBrush = 0;
AFX_STATIC_DATA HPEN _afxBlackDottedPen = 0;
AFX_STATIC_DATA int _afxHandleSize = 0;

void AFX_CDECL AfxTrackerTerm()
{
	AfxDeleteObject((HGDIOBJ*)&_afxHatchBrush);
	AfxDeleteObject((HGDIOBJ*)&_afxBlackDottedPen);
}
char _afxTrackerTerm = 0;

// the struct below is used to determine the qualities of a particular handle
struct AFX_HANDLEINFO
{
	size_t nOffsetX;    // offset within RECT for X coordinate
	size_t nOffsetY;    // offset within RECT for Y coordinate
	int nCenterX;       // adjust X by Width()/2 * this number
	int nCenterY;       // adjust Y by Height()/2 * this number
	int nHandleX;       // adjust X by handle size * this number
	int nHandleY;       // adjust Y by handle size * this number
	int nInvertX;       // handle converts to this when X inverted
	int nInvertY;       // handle converts to this when Y inverted
};

// this array describes all 8 handles (clock-wise)
AFX_STATIC_DATA const AFX_HANDLEINFO _afxHandleInfo[] =
{
	// corner handles (top-left, top-right, bottom-right, bottom-left
	{ offsetof(RECT, left), offsetof(RECT, top),        0, 0,  0,  0, 1, 3 },
	{ offsetof(RECT, right), offsetof(RECT, top),       0, 0, -1,  0, 0, 2 },
	{ offsetof(RECT, right), offsetof(RECT, bottom),    0, 0, -1, -1, 3, 1 },
	{ offsetof(RECT, left), offsetof(RECT, bottom),     0, 0,  0, -1, 2, 0 },

	// side handles (top, right, bottom, left)
	{ offsetof(RECT, left), offsetof(RECT, top),        1, 0,  0,  0, 4, 6 },
	{ offsetof(RECT, right), offsetof(RECT, top),       0, 1, -1,  0, 7, 5 },
	{ offsetof(RECT, left), offsetof(RECT, bottom),     1, 0,  0, -1, 6, 4 },
	{ offsetof(RECT, left), offsetof(RECT, top),        0, 1,  0,  0, 5, 7 }
};

// the struct below gives us information on the layout of a RECT struct and
//  the relationship between its members
struct AFX_RECTINFO
{
	size_t nOffsetAcross;   // offset of opposite point (ie. left->right)
	int nSignAcross;        // sign relative to that point (ie. add/subtract)
};

// this array is indexed by the offset of the RECT member / sizeof(int)
AFX_STATIC_DATA const AFX_RECTINFO _afxRectInfo[] =
{
	{ offsetof(RECT, right), +1 },
	{ offsetof(RECT, bottom), +1 },
	{ offsetof(RECT, left), -1 },
	{ offsetof(RECT, top), -1 },
};

/////////////////////////////////////////////////////////////////////////////
// CRectTracker intitialization

CRectTracker::CRectTracker(LPCRECT lpSrcRect, UINT nStyle)
{
	ASSERT(AfxIsValidAddress(lpSrcRect, sizeof(RECT), FALSE));

	Construct();
	m_rect.CopyRect(lpSrcRect);
	m_nStyle = nStyle;
}

void CRectTracker::Construct()
{
	// do one-time initialization if necessary
	AfxLockGlobals(CRIT_RECTTRACKER);
	static BOOL bInitialized;
	if (!bInitialized)
	{


		// sanity checks for assumptions we make in the code
		ASSERT(sizeof(((RECT*)NULL)->left) == sizeof(int));
		ASSERT(offsetof(RECT, top) > offsetof(RECT, left));
		ASSERT(offsetof(RECT, right) > offsetof(RECT, top));
		ASSERT(offsetof(RECT, bottom) > offsetof(RECT, right));

		if (_afxHatchBrush == NULL)
		{
			// create the hatch pattern + bitmap
			WORD hatchPattern[8];
			WORD wPattern = 0x1111;
			for (int i = 0; i < 4; i++)
			{
				hatchPattern[i] = wPattern;
				hatchPattern[i+4] = wPattern;
				wPattern <<= 1;
			}
			HBITMAP hatchBitmap = CreateBitmap(8, 8, 1, 1, hatchPattern);
			if (hatchBitmap == NULL)
			{
				AfxUnlockGlobals(CRIT_RECTTRACKER);
				AfxThrowResourceException();
			}

			// create black hatched brush
			_afxHatchBrush = CreatePatternBrush(hatchBitmap);
			DeleteObject(hatchBitmap);
			if (_afxHatchBrush == NULL)
			{
				AfxUnlockGlobals(CRIT_RECTTRACKER);
				AfxThrowResourceException();
			}
		}

		if (_afxBlackDottedPen == NULL)
		{
			// create black dotted pen
			_afxBlackDottedPen = CreatePen(PS_DOT, 0, RGB(0, 0, 0));
			if (_afxBlackDottedPen == NULL)
			{
				AfxUnlockGlobals(CRIT_RECTTRACKER);
				AfxThrowResourceException();
			}
		}

		// Note: all track cursors must live in same module
		HINSTANCE hInst = AfxFindResourceHandle(
			ATL_MAKEINTRESOURCE(AFX_IDC_TRACK4WAY), ATL_RT_GROUP_CURSOR);

		// initialize the cursor array
		_afxCursors[0] = ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(AFX_IDC_TRACKNWSE));
		_afxCursors[1] = ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(AFX_IDC_TRACKNESW));
		_afxCursors[2] = _afxCursors[0];
		_afxCursors[3] = _afxCursors[1];
		_afxCursors[4] = ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(AFX_IDC_TRACKNS));
		_afxCursors[5] = ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(AFX_IDC_TRACKWE));
		_afxCursors[6] = _afxCursors[4];
		_afxCursors[7] = _afxCursors[5];
		_afxCursors[8] = ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(AFX_IDC_TRACK4WAY));
		_afxCursors[9] = ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(AFX_IDC_MOVE4WAY));

		// get default handle size from Windows profile setting
		static const TCHAR szWindows[] = _T("windows");
		static const TCHAR szInplaceBorderWidth[] =
			_T("oleinplaceborderwidth");
		_afxHandleSize = GetProfileInt(szWindows, szInplaceBorderWidth, 4);
		bInitialized = TRUE;
	}
	if (!_afxTrackerTerm)
		_afxTrackerTerm = (char)!atexit(&AfxTrackerTerm);
	AfxUnlockGlobals(CRIT_RECTTRACKER);

	m_nStyle = 0;
	m_nHandleSize = _afxHandleSize;
	m_sizeMin.cy = m_sizeMin.cx = m_nHandleSize*2;

	m_rectLast.SetRectEmpty();
	m_sizeLast.cx = m_sizeLast.cy = 0;
	m_bErase = FALSE;
	m_bFinalErase =  FALSE;
}

CRectTracker::~CRectTracker()
{
}

/////////////////////////////////////////////////////////////////////////////
// CRectTracker operations

void CRectTracker::Draw(CDC* pDC) const
{
	// set initial DC state
	VERIFY(pDC->SaveDC() != 0);
	pDC->SetMapMode(MM_TEXT);
	pDC->SetViewportOrg(0, 0);
	pDC->SetWindowOrg(0, 0);

	// get normalized rectangle
	CRect rect = m_rect;
	rect.NormalizeRect();

	CPen* pOldPen = NULL;
	CBrush* pOldBrush = NULL;
	CGdiObject* pTemp;
	int nOldROP;

	// draw lines
	if ((m_nStyle & (dottedLine|solidLine)) != 0)
	{
		if (m_nStyle & dottedLine)
			pOldPen = pDC->SelectObject(CPen::FromHandle(_afxBlackDottedPen));
		else
			pOldPen = (CPen*)pDC->SelectStockObject(BLACK_PEN);
		pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
		nOldROP = pDC->SetROP2(R2_COPYPEN);
		rect.InflateRect(+1, +1);   // borders are one pixel outside
		pDC->Rectangle(rect.left, rect.top, rect.right, rect.bottom);
		pDC->SetROP2(nOldROP);
	}

	// if hatchBrush is going to be used, need to unrealize it
	if ((m_nStyle & (hatchInside|hatchedBorder)) != 0)
		UnrealizeObject(_afxHatchBrush);

	// hatch inside
	if ((m_nStyle & hatchInside) != 0)
	{
		pTemp = pDC->SelectStockObject(NULL_PEN);
		if (pOldPen == NULL)
			pOldPen = (CPen*)pTemp;
		pTemp = pDC->SelectObject(CBrush::FromHandle(_afxHatchBrush));
		if (pOldBrush == NULL)
			pOldBrush = (CBrush*)pTemp;
		pDC->SetBkMode(TRANSPARENT);
		nOldROP = pDC->SetROP2(R2_MASKNOTPEN);
		pDC->Rectangle(rect.left+1, rect.top+1, rect.right, rect.bottom);
		pDC->SetROP2(nOldROP);
	}

	// draw hatched border
	if ((m_nStyle & hatchedBorder) != 0)
	{
		pTemp = pDC->SelectObject(CBrush::FromHandle(_afxHatchBrush));
		if (pOldBrush == NULL)
			pOldBrush = (CBrush*)pTemp;
		pDC->SetBkMode(OPAQUE);
		CRect rectTrue;
		GetTrueRect(&rectTrue);
		pDC->PatBlt(rectTrue.left, rectTrue.top, rectTrue.Width(),
			rect.top-rectTrue.top, 0x000F0001 /* Pn */);
		pDC->PatBlt(rectTrue.left, rect.bottom,
			rectTrue.Width(), rectTrue.bottom-rect.bottom, 0x000F0001 /* Pn */);
		pDC->PatBlt(rectTrue.left, rect.top, rect.left-rectTrue.left,
			rect.Height(), 0x000F0001 /* Pn */);
		pDC->PatBlt(rect.right, rect.top, rectTrue.right-rect.right,
			rect.Height(), 0x000F0001 /* Pn */);
	}

	// draw resize handles
	if ((m_nStyle & (resizeInside|resizeOutside)) != 0)
	{
		UINT mask = GetHandleMask();
		for (int i = 0; i < 8; ++i)
		{
			if (mask & (1<<i))
			{
				GetHandleRect((TrackerHit)i, &rect);
				pDC->FillSolidRect(rect, RGB(0, 0, 0));
			}
		}
	}

	// cleanup pDC state
	if (pOldPen != NULL)
		pDC->SelectObject(pOldPen);
	if (pOldBrush != NULL)
		pDC->SelectObject(pOldBrush);
	VERIFY(pDC->RestoreDC(-1));
}

BOOL CRectTracker::SetCursor(CWnd* pWnd, UINT nHitTest) const
{
	// trackers should only be in client area
	if (nHitTest != HTCLIENT)
		return FALSE;

	// convert cursor position to client co-ordinates
	CPoint point;
	GetCursorPos(&point);
	pWnd->ScreenToClient(&point);

	// do hittest and normalize hit
	int nHandle = HitTestHandles(point);
	if (nHandle < 0)
		return FALSE;

	// need to normalize the hittest such that we get proper cursors
	nHandle = NormalizeHit(nHandle);

	// handle special case of hitting area between handles
	//  (logically the same -- handled as a move -- but different cursor)
	if (nHandle == hitMiddle && !m_rect.PtInRect(point))
	{
		// only for trackers with hatchedBorder (ie. in-place resizing)
		if (m_nStyle & hatchedBorder)
			nHandle = (TrackerHit)9;
	}

	ENSURE(nHandle < _countof(_afxCursors));
	::SetCursor(_afxCursors[nHandle]);
	return TRUE;
}

int CRectTracker::HitTest(CPoint point) const
{
	TrackerHit hitResult = hitNothing;

	CRect rectTrue;
	GetTrueRect(&rectTrue);
	ASSERT(rectTrue.left <= rectTrue.right);
	ASSERT(rectTrue.top <= rectTrue.bottom);
	if (rectTrue.PtInRect(point))
	{
		if ((m_nStyle & (resizeInside|resizeOutside)) != 0)
			hitResult = (TrackerHit)HitTestHandles(point);
		else
			hitResult = hitMiddle;
	}
	return hitResult;
}

int CRectTracker::NormalizeHit(int nHandle) const
{
	ENSURE(nHandle <= 8 && nHandle >= -1);
	if (nHandle == hitMiddle || nHandle == hitNothing)
		return nHandle;
	ENSURE(0 <= nHandle && nHandle < _countof(_afxHandleInfo));
	const AFX_HANDLEINFO* pHandleInfo = &_afxHandleInfo[nHandle];
	if (m_rect.Width() < 0)
	{
		nHandle = (TrackerHit)pHandleInfo->nInvertX;
		ENSURE(0 <= nHandle && nHandle < _countof(_afxHandleInfo));
		pHandleInfo = &_afxHandleInfo[nHandle];
	}
	if (m_rect.Height() < 0)
		nHandle = (TrackerHit)pHandleInfo->nInvertY;
	return nHandle;
}

BOOL CRectTracker::Track(CWnd* pWnd, CPoint point, BOOL bAllowInvert,
	CWnd* pWndClipTo)
{
	// perform hit testing on the handles
	int nHandle = HitTestHandles(point);
	if (nHandle < 0)
	{
		// didn't hit a handle, so just return FALSE
		return FALSE;
	}

	// otherwise, call helper function to do the tracking
	m_bAllowInvert = bAllowInvert;
	return TrackHandle(nHandle, pWnd, point, pWndClipTo);
}

BOOL CRectTracker::TrackRubberBand(CWnd* pWnd, CPoint point, BOOL bAllowInvert)
{
	// simply call helper function to track from bottom right handle
	m_bAllowInvert = bAllowInvert;
	m_rect.SetRect(point.x, point.y, point.x, point.y);
	return TrackHandle(hitBottomRight, pWnd, point, NULL);
}

void CRectTracker::DrawTrackerRect(
	LPCRECT lpRect, CWnd* pWndClipTo, CDC* pDC, CWnd* pWnd)
{
	// first, normalize the rectangle for drawing
	CRect rect = *lpRect;
	rect.NormalizeRect();

	// convert to client coordinates
	if (pWndClipTo != NULL)
	{
		pWnd->ClientToScreen(&rect);
		pWndClipTo->ScreenToClient(&rect);
	}

	CSize size(0, 0);
	if (!m_bFinalErase)
	{
		// otherwise, size depends on the style
		if (m_nStyle & hatchedBorder)
		{
			size.cx = size.cy = max(1, GetHandleSize(rect)-1);
			rect.InflateRect(size);
		}
		else
		{
			size.cx = AFX_CX_BORDER;
			size.cy = AFX_CY_BORDER;
		}
	}

	// and draw it
	if (m_bFinalErase || !m_bErase)
		pDC->DrawDragRect(rect, size, m_rectLast, m_sizeLast);

	// remember last rectangles
	m_rectLast = rect;
	m_sizeLast = size;
}

void CRectTracker::AdjustRect(int nHandle, LPRECT)
{
	if (nHandle == hitMiddle)
		return;

	// convert the handle into locations within m_rect
	int *px, *py;
	GetModifyPointers(nHandle, &px, &py, NULL, NULL);

	// enforce minimum width
	int nNewWidth = m_rect.Width();
	int nAbsWidth = m_bAllowInvert ? abs(nNewWidth) : nNewWidth;
	if (px != NULL && nAbsWidth < m_sizeMin.cx)
	{
		nNewWidth = nAbsWidth != 0 ? nNewWidth / nAbsWidth : 1;
		ptrdiff_t iRectInfo = (int*)px - (int*)&m_rect;
		ENSURE(0 <= iRectInfo && iRectInfo < _countof(_afxRectInfo));
		const AFX_RECTINFO* pRectInfo = &_afxRectInfo[iRectInfo];
		*px = *(int*)((BYTE*)&m_rect + pRectInfo->nOffsetAcross) +
			nNewWidth * m_sizeMin.cx * -pRectInfo->nSignAcross;
	}

	// enforce minimum height
	int nNewHeight = m_rect.Height();
	int nAbsHeight = m_bAllowInvert ? abs(nNewHeight) : nNewHeight;
	if (py != NULL && nAbsHeight < m_sizeMin.cy)
	{
		nNewHeight = nAbsHeight != 0 ? nNewHeight / nAbsHeight : 1;
		ptrdiff_t iRectInfo = (int*)py - (int*)&m_rect;
		ENSURE(0 <= iRectInfo && iRectInfo < _countof(_afxRectInfo));
		const AFX_RECTINFO* pRectInfo = &_afxRectInfo[iRectInfo];
		*py = *(int*)((BYTE*)&m_rect + pRectInfo->nOffsetAcross) +
			nNewHeight * m_sizeMin.cy * -pRectInfo->nSignAcross;
	}
}

void CRectTracker::GetTrueRect(LPRECT lpTrueRect) const
{
	ASSERT(AfxIsValidAddress(lpTrueRect, sizeof(RECT)));

	CRect rect = m_rect;
	rect.NormalizeRect();
	int nInflateBy = 0;
	if ((m_nStyle & (resizeOutside|hatchedBorder)) != 0)
		nInflateBy += GetHandleSize() - 1;
	if ((m_nStyle & (solidLine|dottedLine)) != 0)
		++nInflateBy;
	rect.InflateRect(nInflateBy, nInflateBy);
	*lpTrueRect = rect;
}

void CRectTracker::OnChangedRect(const CRect& /*rectOld*/)
{
	// no default implementation, useful for derived classes
}

/////////////////////////////////////////////////////////////////////////////
// CRectTracker implementation helpers

void CRectTracker::GetHandleRect(int nHandle, CRect* pHandleRect) const
{
	ASSERT(nHandle < 8);

	// get normalized rectangle of the tracker
	CRect rectT = m_rect;
	rectT.NormalizeRect();
	if ((m_nStyle & (solidLine|dottedLine)) != 0)
		rectT.InflateRect(+1, +1);

	// since the rectangle itself was normalized, we also have to invert the
	//  resize handles.
	nHandle = NormalizeHit(nHandle);

	// handle case of resize handles outside the tracker
	int size = GetHandleSize();
	if (m_nStyle & resizeOutside)
		rectT.InflateRect(size-1, size-1);

	// calculate position of the resize handle
	int nWidth = rectT.Width();
	int nHeight = rectT.Height();
	CRect rect;
	const AFX_HANDLEINFO* pHandleInfo = &_afxHandleInfo[nHandle];
	rect.left = *(int*)((BYTE*)&rectT + pHandleInfo->nOffsetX);
	rect.top = *(int*)((BYTE*)&rectT + pHandleInfo->nOffsetY);
	rect.left += size * pHandleInfo->nHandleX;
	rect.top += size * pHandleInfo->nHandleY;
	rect.left += pHandleInfo->nCenterX * (nWidth - size) / 2;
	rect.top += pHandleInfo->nCenterY * (nHeight - size) / 2;
	rect.right = rect.left + size;
	rect.bottom = rect.top + size;

	*pHandleRect = rect;
}

int CRectTracker::GetHandleSize(LPCRECT lpRect) const
{
	if (lpRect == NULL)
		lpRect = &m_rect;

	int size = m_nHandleSize;
	if (!(m_nStyle & resizeOutside))
	{
		// make sure size is small enough for the size of the rect
		int sizeMax = min(abs(lpRect->right - lpRect->left),
			abs(lpRect->bottom - lpRect->top));
		if (size * 2 > sizeMax)
			size = sizeMax / 2;
	}
	return size;
}

int CRectTracker::HitTestHandles(CPoint point) const
{
	CRect rect;
	UINT mask = GetHandleMask();

	// see if hit anywhere inside the tracker
	GetTrueRect(&rect);
	if (!rect.PtInRect(point))
		return hitNothing;  // totally missed

	// see if we hit a handle
	for (int i = 0; i < 8; ++i)
	{
		if (mask & (1<<i))
		{
			GetHandleRect((TrackerHit)i, &rect);
			if (rect.PtInRect(point))
				return (TrackerHit)i;
		}
	}

	// last of all, check for non-hit outside of object, between resize handles
	if ((m_nStyle & hatchedBorder) == 0)
	{
		CRect rect = m_rect;
		rect.NormalizeRect();
		if ((m_nStyle & dottedLine|solidLine) != 0)
			rect.InflateRect(+1, +1);
		if (!rect.PtInRect(point))
			return hitNothing;  // must have been between resize handles
	}
	return hitMiddle;   // no handle hit, but hit object (or object border)
}

BOOL CRectTracker::TrackHandle(int nHandle, CWnd* pWnd, CPoint point,
	CWnd* pWndClipTo)
{
	ASSERT(nHandle >= 0);
	ASSERT(nHandle <= 8);   // handle 8 is inside the rect

	// don't handle if capture already set
	if (::GetCapture() != NULL)
		return FALSE;

	AfxLockTempMaps();  // protect maps while looping

	ASSERT(!m_bFinalErase);

	// save original width & height in pixels
	int nWidth = m_rect.Width();
	int nHeight = m_rect.Height();

	// set capture to the window which received this message
	pWnd->SetCapture();
	ASSERT(pWnd == CWnd::GetCapture());
	pWnd->UpdateWindow();
	if (pWndClipTo != NULL)
		pWndClipTo->UpdateWindow();
	CRect rectSave = m_rect;

	// find out what x/y coords we are supposed to modify
	int *px, *py;
	int xDiff, yDiff;
	GetModifyPointers(nHandle, &px, &py, &xDiff, &yDiff);
	xDiff = point.x - xDiff;
	yDiff = point.y - yDiff;

	// get DC for drawing
	CDC* pDrawDC;
	if (pWndClipTo != NULL)
	{
		// clip to arbitrary window by using adjusted Window DC
		pDrawDC = pWndClipTo->GetDCEx(NULL, DCX_CACHE);
	}
	else
	{
		// otherwise, just use normal DC
		pDrawDC = pWnd->GetDC();
	}
	ENSURE_VALID(pDrawDC);

	CRect rectOld;
	BOOL bMoved = FALSE;

	// get messages until capture lost or cancelled/accepted
	for (;;)
	{
		MSG msg;
		VERIFY(::GetMessage(&msg, NULL, 0, 0));

		if (CWnd::GetCapture() != pWnd)
			break;

		switch (msg.message)
		{
		// handle movement/accept messages
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			rectOld = m_rect;
			// handle resize cases (and part of move)
			if (px != NULL)
				*px = GET_X_LPARAM(msg.lParam) - xDiff;
			if (py != NULL)
				*py = GET_Y_LPARAM(msg.lParam) - yDiff;

			// handle move case
			if (nHandle == hitMiddle)
			{
				m_rect.right = m_rect.left + nWidth;
				m_rect.bottom = m_rect.top + nHeight;
			}
			// allow caller to adjust the rectangle if necessary
			AdjustRect(nHandle, &m_rect);

			// only redraw and callback if the rect actually changed!
			m_bFinalErase = (msg.message == WM_LBUTTONUP);
			if (!rectOld.EqualRect(&m_rect) || m_bFinalErase)
			{
				if (bMoved)
				{
					m_bErase = TRUE;
					DrawTrackerRect(&rectOld, pWndClipTo, pDrawDC, pWnd);
				}
				OnChangedRect(rectOld);
				if (msg.message != WM_LBUTTONUP)
					bMoved = TRUE;
			}
			if (m_bFinalErase)
				goto ExitLoop;

			if (!rectOld.EqualRect(&m_rect))
			{
				m_bErase = FALSE;
				DrawTrackerRect(&m_rect, pWndClipTo, pDrawDC, pWnd);
			}
			break;

		// handle cancel messages
		case WM_KEYDOWN:
			if (msg.wParam != VK_ESCAPE)
				break;
		case WM_RBUTTONDOWN:
			if (bMoved)
			{
				m_bErase = m_bFinalErase = TRUE;
				DrawTrackerRect(&m_rect, pWndClipTo, pDrawDC, pWnd);
			}
			m_rect = rectSave;
			goto ExitLoop;

		// just dispatch rest of the messages
		default:
			DispatchMessage(&msg);
			break;
		}
	}

ExitLoop:
	if (pWndClipTo != NULL)
		pWndClipTo->ReleaseDC(pDrawDC);
	else
		pWnd->ReleaseDC(pDrawDC);
	ReleaseCapture();

	AfxUnlockTempMaps(FALSE);

	// restore rect in case bMoved is still FALSE
	if (!bMoved)
		m_rect = rectSave;
	m_bFinalErase = FALSE;
	m_bErase = FALSE;

	// return TRUE only if rect has changed
	return !rectSave.EqualRect(&m_rect);
}

void CRectTracker::GetModifyPointers(
	int nHandle, int** ppx, int** ppy, int* px, int* py)
{
	ENSURE(nHandle >= 0);
	ENSURE(nHandle <= 8);

	if (nHandle == hitMiddle)
		nHandle = hitTopLeft;   // same as hitting top-left

	*ppx = NULL;
	*ppy = NULL;

	// fill in the part of the rect that this handle modifies
	//  (Note: handles that map to themselves along a given axis when that
	//   axis is inverted don't modify the value on that axis)

	const AFX_HANDLEINFO* pHandleInfo = &_afxHandleInfo[nHandle];
	if (pHandleInfo->nInvertX != nHandle)
	{
		*ppx = (int*)((BYTE*)&m_rect + pHandleInfo->nOffsetX);
		if (px != NULL)
			*px = **ppx;
	}
	else
	{
		// middle handle on X axis
		if (px != NULL)
			*px = m_rect.left + abs(m_rect.Width()) / 2;
	}
	if (pHandleInfo->nInvertY != nHandle)
	{
		*ppy = (int*)((BYTE*)&m_rect + pHandleInfo->nOffsetY);
		if (py != NULL)
			*py = **ppy;
	}
	else
	{
		// middle handle on Y axis
		if (py != NULL)
			*py = m_rect.top + abs(m_rect.Height()) / 2;
	}
}

UINT CRectTracker::GetHandleMask() const
{
	UINT mask = 0x0F;   // always have 4 corner handles
	int size = m_nHandleSize*3;
	if (abs(m_rect.Width()) - size > 4)
		mask |= 0x50;
	if (abs(m_rect.Height()) - size > 4)
		mask |= 0xA0;
	return mask;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewedit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <ctype.h>



/////////////////////////////////////////////////////////////////////////////
// CEditView

#define new DEBUG_NEW

UINT _afxMsgFindReplace = ::RegisterWindowMessage(FINDMSGSTRING);

#ifdef _UNICODE

AFX_STATIC_DATA HFONT _afxUnicodeFont = 0;

void AFX_CDECL AfxEditviewTerm()
{
	AfxDeleteObject((HGDIOBJ*)&_afxUnicodeFont);
}
char _afxEditviewTerm = 0;

#endif //_UNICODE

BEGIN_MESSAGE_MAP(CEditView, CCtrlView)
	//{{AFX_MSG_MAP(CEditView)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, &CEditView::OnUpdateNeedSel)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, &CEditView::OnUpdateNeedClip)
	ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, &CEditView::OnUpdateNeedText)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, &CEditView::OnUpdateEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, &CEditView::OnUpdateNeedText)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REPLACE, &CEditView::OnUpdateNeedText)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REPEAT, &CEditView::OnUpdateNeedFind)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, &CEditView::OnUpdateNeedSel)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, &CEditView::OnUpdateNeedSel)
	ON_CONTROL_REFLECT_EX(EN_CHANGE, &CEditView::OnEditChange)
	ON_WM_CREATE()
	ON_MESSAGE(WM_SETFONT, &CEditView::OnSetFont)
	ON_COMMAND(ID_EDIT_CUT, &CEditView::OnEditCut)
	ON_COMMAND(ID_EDIT_COPY, &CEditView::OnEditCopy)
	ON_COMMAND(ID_EDIT_PASTE, &CEditView::OnEditPaste)
	ON_COMMAND(ID_EDIT_CLEAR, &CEditView::OnEditClear)
	ON_COMMAND(ID_EDIT_UNDO, &CEditView::OnEditUndo)
	ON_COMMAND(ID_EDIT_SELECT_ALL, &CEditView::OnEditSelectAll)
	ON_COMMAND(ID_EDIT_FIND, &CEditView::OnEditFind)
	ON_COMMAND(ID_EDIT_REPLACE, &CEditView::OnEditReplace)
	ON_COMMAND(ID_EDIT_REPEAT, &CEditView::OnEditRepeat)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	// Special registered message for Find and Replace
	ON_REGISTERED_MESSAGE(_afxMsgFindReplace, &CEditView::OnFindReplaceCmd)
	// Standard Print commands (print only - not preview)
	ON_COMMAND(ID_FILE_PRINT, &CCtrlView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CCtrlView::OnFilePrint)
END_MESSAGE_MAP()

const AFX_DATADEF DWORD CEditView::dwStyleDefault =
	AFX_WS_DEFAULT_VIEW |
	WS_HSCROLL | WS_VSCROLL |
	ES_AUTOHSCROLL | ES_AUTOVSCROLL |
	ES_MULTILINE | ES_NOHIDESEL;

// Arbitrary max size. Otherwise, default max size would be too small(32K).
const AFX_DATADEF UINT CEditView::nMaxSize = 1024U*1024U-1;

/////////////////////////////////////////////////////////////////////////////
// _AFX_EDIT_STATE

_AFX_EDIT_STATE::_AFX_EDIT_STATE()
{
	// Note: it is only necessary to initialize non-zero data.

	bNext = TRUE;
}

_AFX_EDIT_STATE::~_AFX_EDIT_STATE()
{
}

EXTERN_PROCESS_LOCAL(_AFX_EDIT_STATE, _afxEditState)

/////////////////////////////////////////////////////////////////////////////
// CEditView construction/destruction

// pass a NULL style because dwStyleDefault stays for backward compatibility
CEditView::CEditView() : CCtrlView(_T("EDIT"), NULL)
{
	m_nTabStops = 8*4;  // default 8 character positions
	m_hPrinterFont = NULL;
	m_hMirrorFont = NULL;
	m_pShadowBuffer = NULL;
	m_nShadowSize = 0;
}

CEditView::~CEditView()
{
	ASSERT(m_hWnd == NULL);
#ifdef _UNICODE
	ASSERT(m_pShadowBuffer == NULL);
#else
	ASSERT(m_pShadowBuffer == NULL || _AfxGetComCtlVersion() >= VERSION_6);
#endif
	delete[] m_pShadowBuffer;
}

BOOL CEditView::PreCreateWindow(CREATESTRUCT& cs)
{
	m_dwDefaultStyle = dwStyleDefault;
	return CCtrlView::PreCreateWindow(cs);
}

int CEditView::OnCreate(LPCREATESTRUCT lpcs)
{
	if (CCtrlView::OnCreate(lpcs) != 0)
		return -1;

#ifdef _UNICODE
	AfxLockGlobals(CRIT_EDITVIEW);
	if (_afxUnicodeFont == NULL)
	{
		// get unicode font same size as system font
		HFONT hSystemFont = (HFONT)GetStockObject(SYSTEM_FONT);
		LOGFONT systemFont;
		VERIFY(::GetObject(hSystemFont, sizeof(LOGFONT), (void*)&systemFont));

		// default size and facename, but allow customization
		LOGFONT logFont; memset(&logFont, 0, sizeof(LOGFONT));
		logFont.lfHeight = systemFont.lfHeight;
		logFont.lfWeight = systemFont.lfWeight;
		logFont.lfCharSet = DEFAULT_CHARSET;
		Checked::tcscpy_s(logFont.lfFaceName, _countof(logFont.lfFaceName), _T("Lucida Sans Unicode"));
		AfxCustomLogFont(AFX_IDS_UNICODE_FONT, &logFont);

		// attempt to create the font
		_afxUnicodeFont = ::CreateFontIndirect(&logFont);
		if (_afxUnicodeFont == NULL)
			TRACE(traceAppMsg, 0, _T("Unable to create unicode font '%s'.\n"), logFont.lfFaceName);
	}
	if (!_afxEditviewTerm)
		_afxEditviewTerm = (char)!atexit(&AfxEditviewTerm);
	AfxUnlockGlobals(CRIT_EDITVIEW);

	// set unicode font instead of using system font
	if (_afxUnicodeFont != NULL)
		SendMessage(WM_SETFONT, (WPARAM)_afxUnicodeFont);
#endif

	// Set arbitrary max size. Otherwise, default max size would be too small(32K).
	// Call SetLimitText() in OnCreate() to set your own max size.
	// Refer to documentation for EM_LIMITTEXT for max sizes for your target OS.
	GetEditCtrl().LimitText(nMaxSize);
	GetEditCtrl().SetTabStops(m_nTabStops);

	return 0;
}

void CEditView::OnDestroy()
{
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	pEditState->pFindReplaceDlg = NULL;

	CView::OnDestroy();
}

// EDIT controls always turn off WS_BORDER and draw it themselves
void CEditView::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	ENSURE_ARG(lpClientRect!=NULL);	
	if (nAdjustType != 0)
	{
		// default behavior for in-place editing handles scrollbars
		DWORD dwStyle = GetStyle();
		if (dwStyle & WS_VSCROLL)
			lpClientRect->right += afxData.cxVScroll - AFX_CX_BORDER;
		if (dwStyle & WS_HSCROLL)
			lpClientRect->bottom += afxData.cyHScroll - AFX_CY_BORDER;
		return;
	}

	::AdjustWindowRectEx(lpClientRect, GetStyle() | WS_BORDER, FALSE,
		GetExStyle() & ~(WS_EX_CLIENTEDGE));
}

/////////////////////////////////////////////////////////////////////////////
// CEditView document like functions

void CEditView::DeleteContents()
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);
	SetWindowText(NULL);
	ASSERT_VALID(this);
}

void CEditView::Serialize(CArchive& ar)
	// Read and write CEditView object to archive, with length prefix.
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);
	if (ar.IsStoring())
	{
		UINT nLen = GetBufferLength();
		ar << (DWORD)nLen;
		WriteToArchive(ar);
	}
	else
	{
		DWORD dwLen;
		ar >> dwLen;
		if (dwLen > GetEditCtrl().GetLimitText())
			// Larger than edit control limit. Call SetLimitText() to set your own max size.
			// Refer to documentation for EM_LIMITTEXT for max sizes for your target OS.
			AfxThrowArchiveException(CArchiveException::badIndex);
		UINT nLen = (UINT)dwLen;
		ReadFromArchive(ar, nLen);
	}
	ASSERT_VALID(this);
}

void CEditView::ReadFromArchive(CArchive& ar, UINT nLen)
	// Read certain amount of text from the file, assume at least nLen
	// characters (not bytes) are in the file.
{
	ASSERT_VALID(this);

	LPVOID hText = LocalAlloc(LMEM_MOVEABLE, static_cast<UINT>(::ATL::AtlMultiplyThrow(static_cast<UINT>(nLen+1),static_cast<UINT>(sizeof(TCHAR)))));
	if (hText == NULL)
		AfxThrowMemoryException();

	LPTSTR lpszText = (LPTSTR)LocalLock(hText);
	ASSERT(lpszText != NULL);
	if (ar.Read(lpszText, nLen*sizeof(TCHAR)) != nLen*sizeof(TCHAR))
	{
		LocalUnlock(hText);
		LocalFree(hText);
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
	// Replace the editing edit buffer with the newly loaded data
	lpszText[nLen] = '\0';

	
#ifndef _UNICODE
	if (_AfxGetComCtlVersion() >= VERSION_6)
	{
		// set the text with SetWindowText, then free
		BOOL bResult = ::SetWindowText(m_hWnd, lpszText);
		LocalUnlock(hText);
		LocalFree(hText);

		// make sure that SetWindowText was successful
		if (!bResult || ::GetWindowTextLength(m_hWnd) < (int)nLen)
			AfxThrowMemoryException();

		// remove old shadow buffer
		delete[] m_pShadowBuffer;
		m_pShadowBuffer = NULL;
		m_nShadowSize = 0;

		ASSERT_VALID(this);
		return;
	}
#endif

	LocalUnlock(hText);
	HLOCAL hOldText = GetEditCtrl().GetHandle();
	ASSERT(hOldText != NULL);
	LocalFree(hOldText);
	GetEditCtrl().SetHandle((HLOCAL)hText);
	Invalidate();
	ASSERT_VALID(this);
}

void CEditView::WriteToArchive(CArchive& ar)
	// Write just the text to an archive, no length prefix.
{
	ASSERT_VALID(this);
	LPCTSTR lpszText = LockBuffer();
	ASSERT(lpszText != NULL);
	UINT nLen = GetBufferLength();
	TRY
	{
		ar.Write(lpszText, nLen*sizeof(TCHAR));
	}
	CATCH_ALL(e)
	{
		UnlockBuffer();
		THROW_LAST();
	}
	END_CATCH_ALL
	UnlockBuffer();
	ASSERT_VALID(this);
}

void CEditView::SerializeRaw(CArchive& ar)
	// Read/Write object as stand-alone file.
{
	ASSERT_VALID(this);
	if (ar.IsStoring())
	{
		WriteToArchive(ar);
	}
	else
	{
		CFile* pFile = ar.GetFile();
		ASSERT(pFile->GetPosition() == 0);
		ULONGLONG nFileSize = pFile->GetLength();
		if (nFileSize/sizeof(TCHAR) > GetEditCtrl().GetLimitText())
		{
			// Larger than edit control limit. Call SetLimitText() to set your own max size.
			// Refer to documentation for EM_LIMITTEXT for max sizes for your target OS.
			AfxMessageBox(AFX_IDP_FILE_TOO_LARGE);
			AfxThrowUserException();
		}
		// ReadFromArchive takes the number of characters as argument
		ReadFromArchive(ar, (UINT)nFileSize/sizeof(TCHAR));
	}
	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// CEditView Printing Helpers

AFX_STATIC UINT AFXAPI _AfxEndOfLine(LPCTSTR lpszText, UINT nLen, UINT nIndex)
{
	ASSERT(AfxIsValidAddress(lpszText, nLen, FALSE));
	ENSURE_ARG(lpszText!=NULL);
	LPCTSTR lpsz = lpszText + nIndex;
	LPCTSTR lpszStop = lpszText + nLen;
	while (lpsz < lpszStop && *lpsz != '\r')
		++lpsz;
	return int(lpsz - lpszText);
}

AFX_STATIC UINT AFXAPI _AfxNextLine(LPCTSTR lpszText, UINT nLen, UINT nIndex)
{
	ASSERT(AfxIsValidAddress(lpszText, nLen, FALSE));
	ENSURE_ARG(lpszText!=NULL);
	LPCTSTR lpsz = lpszText + nIndex;
	LPCTSTR lpszStop = lpszText + nLen;
	while (lpsz < lpszStop && *lpsz == '\r')
		++lpsz;
	if (lpsz < lpszStop && *lpsz == '\n')
		++lpsz;
	return int(lpsz - lpszText);
}

AFX_STATIC UINT AFXAPI
_AfxClipLine(CDC* pDC, int aCharWidths[256], int cxLine, int nTabStop,
	LPCTSTR lpszText, UINT nIndex, UINT nIndexEnd)
{
	ENSURE_VALID(pDC);
	ASSERT(nIndex < nIndexEnd);
	ASSERT(AfxIsValidAddress(lpszText, nIndexEnd, FALSE));
	ENSURE_ARG(lpszText!=NULL);
	TEXTMETRIC tm;
	::GetTextMetrics(pDC->m_hDC, &tm);

	// make an initial guess on the number of characters that will fit
	int cx = 0;
	LPCTSTR lpszStart = lpszText + nIndex;
	LPCTSTR lpszStop = lpszText + nIndexEnd;
	LPCTSTR lpsz = lpszStart;
	while (lpsz < lpszStop)
	{
		if (*lpsz == '\t')
			cx += nTabStop - (cx % nTabStop);
		else
		{
#ifdef _UNICODE
			if (*lpsz <= 0xFF)
				cx += aCharWidths[(BYTE)*lpsz];
			else
				cx += tm.tmAveCharWidth;
#else //_UNICODE
			if (_afxDBCS && _istlead(*lpsz))
			{
				++lpsz;
				cx += tm.tmAveCharWidth;
			}
			else
				cx += aCharWidths[(BYTE)*lpsz];
#endif //!_UNICODE
		}
		++lpsz;
		if (cx > cxLine)
			break;
	}

	// adjust for errors in the guess
	cx = pDC->GetTabbedTextExtent(lpszStart, int(lpsz-lpszStart), 1, &nTabStop).cx;
	if (cx > cxLine)
	{
		// remove characters until it fits
		do
		{
			ASSERT(lpsz != lpszStart);
			if (_afxDBCS)
				lpsz = _tcsdec(lpszStart, lpsz);
			else
				--lpsz;
			cx = pDC->GetTabbedTextExtent(lpszStart, int(lpsz-lpszStart), 1, &nTabStop).cx;
		} while (cx > cxLine);
	}
	else if (cx < cxLine)
	{
		// add characters until it doesn't fit
		while (lpsz < lpszStop)
		{
			lpsz = _tcsinc(lpsz);
			ASSERT(lpsz <= lpszStop);
			cx = pDC->GetTabbedTextExtent(lpszStart, int(lpsz-lpszStart), 1, &nTabStop).cx;
			if (cx > cxLine)
			{
				if (_afxDBCS)
					lpsz = _tcsdec(lpszStart, lpsz);
				else
					--lpsz;
				break;
			}
		}
	}

	// return index of character just past the last that would fit
	return int(lpsz - lpszText);
}

/////////////////////////////////////////////////////////////////////////////
// CEditView Printing support

BOOL CEditView::OnPreparePrinting(CPrintInfo* pInfo)
{
	return DoPreparePrinting(pInfo);
}

void CEditView::OnBeginPrinting(CDC* pDC, CPrintInfo*)
{
	ENSURE_VALID(this);
	ENSURE_VALID(pDC);
	// initialize page start vector
	ASSERT(m_aPageStart.GetSize() == 0);
	m_aPageStart.Add(0);
	ASSERT(m_aPageStart.GetSize() > 0);

	if (m_hPrinterFont == NULL)
	{
		// get current screen font object metrics
		CFont* pFont = GetFont();
		LOGFONT lf;
		LOGFONT lfSys;
		if (pFont == NULL)
			return;
		VERIFY(pFont->GetObject(sizeof(LOGFONT), &lf));
		VERIFY(::GetObject(::GetStockObject(SYSTEM_FONT), sizeof(LOGFONT),
			&lfSys));
		if (::AfxInvariantStrICmp((LPCTSTR)lf.lfFaceName, (LPCTSTR)lfSys.lfFaceName) == 0)
			return;

		// map to printer font metrics
		HDC hDCFrom = ::GetDC(NULL);
		lf.lfHeight = ::MulDiv(lf.lfHeight, pDC->GetDeviceCaps(LOGPIXELSY),
			::GetDeviceCaps(hDCFrom, LOGPIXELSY));
		lf.lfWidth = ::MulDiv(lf.lfWidth, pDC->GetDeviceCaps(LOGPIXELSX),
			::GetDeviceCaps(hDCFrom, LOGPIXELSX));
		::ReleaseDC(NULL, hDCFrom);

		// create it, if it fails we just use the printer's default.
		m_hMirrorFont = ::CreateFontIndirect(&lf);
		m_hPrinterFont = m_hMirrorFont;
	}
	ASSERT_VALID(this);
}

BOOL CEditView::PaginateTo(CDC* pDC, CPrintInfo* pInfo)
	// attempts pagination to pInfo->m_nCurPage, TRUE == success
{
	ENSURE_VALID(this);
	ENSURE_VALID(pDC);

	CRect rectSave = pInfo->m_rectDraw;
	UINT nPageSave = pInfo->m_nCurPage;
	ASSERT(nPageSave > 1);
	ASSERT(nPageSave >= (UINT)m_aPageStart.GetSize());
	VERIFY(pDC->SaveDC() != 0);
	pDC->IntersectClipRect(0, 0, 0, 0);
	pInfo->m_nCurPage = (int)m_aPageStart.GetSize();
	while (pInfo->m_nCurPage < nPageSave)
	{
		ASSERT(pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize());
		OnPrepareDC(pDC, pInfo);
		ASSERT(pInfo->m_bContinuePrinting);
		pInfo->m_rectDraw.SetRect(0, 0,
			pDC->GetDeviceCaps(HORZRES), pDC->GetDeviceCaps(VERTRES));
		pDC->DPtoLP(&pInfo->m_rectDraw);
		OnPrint(pDC, pInfo);
		if (pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize())
			break;
		++pInfo->m_nCurPage;
	}
	BOOL bResult = pInfo->m_nCurPage == nPageSave;
	pDC->RestoreDC(-1);
	pInfo->m_nCurPage = nPageSave;
	pInfo->m_rectDraw = rectSave;
	ASSERT_VALID(this);
	return bResult;
}

void CEditView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT(pInfo != NULL);  // overriding OnPaint -- never get this.

	if (pInfo->m_nCurPage > (UINT)m_aPageStart.GetSize() &&
		!PaginateTo(pDC, pInfo))
	{
		// can't paginate to that page, thus cannot print it.
		pInfo->m_bContinuePrinting = FALSE;
	}
	ASSERT_VALID(this);
}

UINT CEditView::PrintInsideRect(CDC* pDC, RECT& rectLayout,
	UINT nIndexStart, UINT nIndexStop)
	// worker function for laying out text in a rectangle.
{
	ASSERT_VALID(this);
	ENSURE_ARG(pDC != NULL);
	ASSERT_VALID(pDC);
	BOOL bWordWrap = (GetStyle() & ES_AUTOHSCROLL) == 0;

	// get buffer and real starting and ending postions
	UINT nLen = GetBufferLength();
	if (nIndexStart >= nLen)
		return nLen;
	LPCTSTR lpszText = LockBuffer();
	if (nIndexStop > nLen)
		nIndexStop = nLen;
	ASSERT(nIndexStart < nLen);

	// calculate text & tab metrics
	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);
	int cyChar = tm.tmHeight + tm.tmExternalLeading;
	int nTabStop = m_nTabStops *
		pDC->GetTabbedTextExtent(_T("\t"), 1, 0, NULL).cx / 8 / 4;
	int aCharWidths[256];
	pDC->GetCharWidth(0, 255, aCharWidths);

	int y = rectLayout.top;
	UINT cx = rectLayout.right - rectLayout.left;
	UINT nIndex = nIndexStart;

	VERIFY(pDC->SaveDC() != 0);
	BOOL bLayoutOnly = pDC->IntersectClipRect(&rectLayout) == NULLREGION;

	do
	{
		UINT nIndexEnd = _AfxEndOfLine(lpszText, nIndexStop, nIndex);
		if (nIndex == nIndexEnd)
		{
			y += cyChar;
		}
		else if (bWordWrap)
		{
			// word-wrap printing
			do
			{
				UINT nIndexWrap = _AfxClipLine(pDC, aCharWidths,
					cx, nTabStop, lpszText, nIndex, nIndexEnd);
				UINT nIndexWord = nIndexWrap;
				if (nIndexWord != nIndexEnd)
				{
					while (nIndexWord > nIndex &&
					  !_istspace(static_cast<_TUCHAR>(lpszText[nIndexWord])))
					{
						nIndexWord--;
					}
					if (nIndexWord == nIndex)
						nIndexWord = nIndexWrap;
				}
				CRect rect(rectLayout.left, y, rectLayout.right, y+cyChar);
				if (!bLayoutOnly && pDC->RectVisible(rect))
				{
					pDC->TabbedTextOut(rect.left, y,
						(LPCTSTR)(lpszText+nIndex), nIndexWord-nIndex, 1,
						&nTabStop, rect.left);
				}
				y += cyChar;
				nIndex = nIndexWord;
				while (nIndex < nIndexEnd && _istspace(static_cast<_TUCHAR>(lpszText[nIndex])))
					nIndex++;
			} while (nIndex < nIndexEnd && y+cyChar <= rectLayout.bottom);

			nIndexEnd = nIndex;
		}
		else
		{
			// non-word wrap printing (much easier and faster)
			CRect rect(rectLayout.left, y, rectLayout.right, y+cyChar);
			if (!bLayoutOnly && pDC->RectVisible(rect))
			{
				UINT nIndexClip = _AfxClipLine(pDC, aCharWidths, cx, nTabStop,
					lpszText, nIndex, nIndexEnd);
				if (nIndexClip < nIndexEnd)
				{
					if (_istlead(*(lpszText+nIndexClip)))
						nIndexClip++;
					nIndexClip++;
				}
				pDC->TabbedTextOut(rect.left, y,
					(LPCTSTR)(lpszText+nIndex), nIndexClip-nIndex, 1,
					&nTabStop, rect.left);
			}
			y += cyChar;
		}
		nIndex = _AfxNextLine(lpszText, nIndexStop, nIndexEnd);
	}
	while (nIndex < nIndexStop && y+cyChar <= rectLayout.bottom);

	pDC->RestoreDC(-1);
	UnlockBuffer();
	ASSERT_VALID(this);

	rectLayout.bottom = y;
	return nIndex;
}

void CEditView::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
	ASSERT_VALID(this);
	ENSURE_ARG(pDC != NULL);
	ASSERT_VALID(pDC);
	ENSURE_ARG(pInfo != NULL);
	ENSURE(pInfo->m_bContinuePrinting);

	CFont* pOldFont = NULL;
	if (m_hPrinterFont != NULL)
		pOldFont = pDC->SelectObject(CFont::FromHandle(m_hPrinterFont));
	pDC->SetBkMode(TRANSPARENT);

	UINT nPage = pInfo->m_nCurPage;
	ASSERT(nPage <= (UINT)m_aPageStart.GetSize());
	UINT nIndex = m_aPageStart[nPage-1];

	// print as much as possible in the current page.
	nIndex = PrintInsideRect(pDC, pInfo->m_rectDraw, nIndex, GetBufferLength());

	if (pOldFont != NULL)
		pDC->SelectObject(pOldFont);

	// update pagination information for page just printed
	if (nPage == (UINT)m_aPageStart.GetSize())
	{
		if (nIndex < GetBufferLength())
			m_aPageStart.Add(nIndex);
	}
	else
	{
		ASSERT(nPage+1 <= (UINT)m_aPageStart.GetSize());
		ASSERT(nIndex == m_aPageStart[nPage+1-1]);
	}
}

void CEditView::OnEndPrinting(CDC*, CPrintInfo*)
{
	ASSERT_VALID(this);

	m_aPageStart.RemoveAll();
	if (m_hMirrorFont != NULL && m_hPrinterFont == m_hMirrorFont)
	{
		AfxDeleteObject((HGDIOBJ*)&m_hMirrorFont);
		m_hPrinterFont = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CEditView commands

void CEditView::OnUpdateNeedSel(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ENSURE_ARG(pCmdUI != NULL);
	int nStartChar, nEndChar;
	GetEditCtrl().GetSel(nStartChar, nEndChar);
	pCmdUI->Enable(nStartChar != nEndChar);
	ASSERT_VALID(this);
}

void CEditView::OnUpdateNeedClip(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ENSURE_ARG(pCmdUI != NULL);
	pCmdUI->Enable(::IsClipboardFormatAvailable(CF_TEXT));
	ASSERT_VALID(this);
}

void CEditView::OnUpdateNeedText(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ENSURE_ARG(pCmdUI != NULL);
	pCmdUI->Enable(GetWindowTextLength() != 0);
	ASSERT_VALID(this);
}

void CEditView::OnUpdateNeedFind(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ENSURE_ARG(pCmdUI != NULL);
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	pCmdUI->Enable(GetWindowTextLength() != 0 &&
		!pEditState->strFind.IsEmpty());
	ASSERT_VALID(this);
}

void CEditView::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ENSURE_ARG(pCmdUI != NULL);
	pCmdUI->Enable(GetEditCtrl().CanUndo());
	ASSERT_VALID(this);
}

BOOL CEditView::OnEditChange()
{
	ASSERT_VALID(this);
	GetDocument()->SetModifiedFlag();
	ASSERT_VALID(this);

	return FALSE;   // continue routing
}

void CEditView::OnEditCut()
{
	ASSERT_VALID(this);
	GetEditCtrl().Cut();
	ASSERT_VALID(this);
}

void CEditView::OnEditCopy()
{
	ASSERT_VALID(this);
	GetEditCtrl().Copy();
	ASSERT_VALID(this);
}

void CEditView::OnEditPaste()
{
	ASSERT_VALID(this);
	GetEditCtrl().Paste();
	ASSERT_VALID(this);
}

void CEditView::OnEditClear()
{
	ASSERT_VALID(this);
	GetEditCtrl().Clear();
	ASSERT_VALID(this);
}

void CEditView::OnEditUndo()
{
	ASSERT_VALID(this);
	GetEditCtrl().Undo();
	ASSERT_VALID(this);
}

void CEditView::OnEditSelectAll()
{
	ASSERT_VALID(this);
	GetEditCtrl().SetSel(0, -1);
	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// CEditView Font Handling

LRESULT CEditView::OnSetFont(WPARAM, LPARAM)
{
	ASSERT_VALID(this);
	Default();
	GetEditCtrl().SetTabStops(m_nTabStops);
	ASSERT_VALID(this);
	return 0;
}

void CEditView::SetPrinterFont(CFont* pFont)
{
	ASSERT_VALID(this);
	m_hPrinterFont = pFont != NULL ? (HFONT)pFont->GetSafeHandle() : NULL;
	ASSERT_VALID(this);
}

CFont* CEditView::GetPrinterFont() const
{
	ASSERT_VALID(this);
	return CFont::FromHandle(m_hPrinterFont);
}

/////////////////////////////////////////////////////////////////////////////
// CEditView attributes

LPCTSTR CEditView::LockBuffer() const
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);
	
#ifndef _UNICODE
	if (_AfxGetComCtlVersion() >= VERSION_6)
	{
		// with commctrl6, it is necessary to maintain a shadow buffer
		//  it is only updated when the control contents have been changed.
		if (m_pShadowBuffer == NULL || GetEditCtrl().GetModify())
		{
			ASSERT(m_pShadowBuffer != NULL || m_nShadowSize == 0);
			UINT nSize = GetWindowTextLength()+1;
			if (nSize > m_nShadowSize)
			{
				// need more room for shadow buffer
				CEditView* pThis = (CEditView*)this;
				delete[] m_pShadowBuffer;
				pThis->m_pShadowBuffer = NULL;
				pThis->m_nShadowSize = 0;
				pThis->m_pShadowBuffer = new TCHAR[nSize];
				pThis->m_nShadowSize = nSize;
			}

			// update the shadow buffer with GetWindowText
			ASSERT(m_nShadowSize >= nSize);
			ASSERT(m_pShadowBuffer != NULL);
			GetWindowText(m_pShadowBuffer, nSize);

			// turn off edit control's modify bit
			GetEditCtrl().SetModify(FALSE);
		}
		return m_pShadowBuffer;
	}
#endif

	// else -- running under non-subset Win32 system
	HLOCAL hLocal = GetEditCtrl().GetHandle();
	ASSERT(hLocal != NULL);
	LPCTSTR lpszText = (LPCTSTR)LocalLock(hLocal);
	ASSERT(lpszText != NULL);
	ASSERT_VALID(this);
	return lpszText;
}

void CEditView::UnlockBuffer() const
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);

#ifndef _UNICODE
	if (_AfxGetComCtlVersion() >= VERSION_6)
		return;
#endif

	HLOCAL hLocal = GetEditCtrl().GetHandle();
	ASSERT(hLocal != NULL);
	LocalUnlock(hLocal);
}

// this function returns the length in characters
UINT CEditView::GetBufferLength() const
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);
	LPCTSTR lpszText = LockBuffer();
	UINT nLen = lstrlen(lpszText);
	UnlockBuffer();
	return nLen;
}

void CEditView::GetSelectedText(CString& strResult) const
{
	ASSERT_VALID(this);
	int nStartChar, nEndChar;
	GetEditCtrl().GetSel(nStartChar, nEndChar);
	ASSERT((UINT)nEndChar <= GetBufferLength());
	LPCTSTR lpszText = ((CEditView*)this)->LockBuffer();
	UINT nLen = _AfxEndOfLine(lpszText, nEndChar, nStartChar) - nStartChar;
	Checked::memcpy_s(strResult.GetBuffer(nLen), nLen*sizeof(TCHAR), 
		lpszText + nStartChar, nLen * sizeof(TCHAR));
	strResult.ReleaseBuffer(nLen);
	UnlockBuffer();
	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// CEditView Find & Replace

void CEditView::OnEditFind()
{
	ASSERT_VALID(this);
	OnEditFindReplace(TRUE);
	ASSERT_VALID(this);
}

void CEditView::OnEditReplace()
{
	ASSERT_VALID(this);
	OnEditFindReplace(FALSE);
	ASSERT_VALID(this);
}

void CEditView::OnEditRepeat()
{
	ASSERT_VALID(this);
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	if (!FindText(pEditState->strFind,
		pEditState->bNext,
		pEditState->bCase))
	{
		OnTextNotFound(pEditState->strFind);
	}
	ASSERT_VALID(this);
}

void CEditView::OnEditFindReplace(BOOL bFindOnly)
{
	ASSERT_VALID(this);
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	if (pEditState->pFindReplaceDlg != NULL)
	{
		if (pEditState->bFindOnly == bFindOnly)
		{
			pEditState->pFindReplaceDlg->SetActiveWindow();
			pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
			return;
		}
		ASSERT(pEditState->bFindOnly != bFindOnly);
		pEditState->pFindReplaceDlg->SendMessage(WM_CLOSE);
		ASSERT(pEditState->pFindReplaceDlg == NULL);
		ASSERT_VALID(this);
	}

	CString strFind;
	GetSelectedText(strFind);
	if (strFind.IsEmpty())
		strFind = pEditState->strFind;
	CString strReplace = pEditState->strReplace;
	pEditState->pFindReplaceDlg = new CFindReplaceDialog;
	ASSERT(pEditState->pFindReplaceDlg != NULL);
	DWORD dwFlags = FR_HIDEWHOLEWORD;
	if (pEditState->bNext)
		dwFlags |= FR_DOWN;
	if (pEditState->bCase)
		dwFlags |= FR_MATCHCASE;
	if (!pEditState->pFindReplaceDlg->Create(bFindOnly, strFind,
		strReplace, dwFlags, this))
	{
		pEditState->pFindReplaceDlg = NULL;
		ASSERT_VALID(this);
		return;
	}

	pEditState->pFindReplaceDlg->SetActiveWindow();
	pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
	ASSERT(pEditState->pFindReplaceDlg != NULL);
	pEditState->bFindOnly = bFindOnly;
	ASSERT_VALID(this);
}

void CEditView::OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase)
{
	ASSERT_VALID(this);
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	pEditState->strFind = lpszFind;
	pEditState->bCase = bCase;
	pEditState->bNext = bNext;

	if (!FindText(pEditState->strFind, bNext, bCase))
		OnTextNotFound(pEditState->strFind);
	ASSERT_VALID(this);
}

void CEditView::OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
	LPCTSTR lpszReplace)
{
	ASSERT_VALID(this);
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	pEditState->strFind = lpszFind;
	pEditState->strReplace = lpszReplace;
	pEditState->bCase = bCase;
	pEditState->bNext = bNext;

	if (!InitializeReplace())
		return;

	GetEditCtrl().ReplaceSel(pEditState->strReplace);
	FindText(pEditState->strFind, bNext, bCase);
	ASSERT_VALID(this);
}

void CEditView::OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bCase)
{
	ASSERT_VALID(this);
	DWORD startPos = GetEditCtrl().GetSel();
	GetEditCtrl().SetSel(0);
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	pEditState->strFind = lpszFind;
	pEditState->strReplace = lpszReplace;
	pEditState->bCase = bCase;
	pEditState->bNext = TRUE;

	if (!InitializeReplace() &&
		!SameAsSelected(pEditState->strFind, pEditState->bCase))
	{
		// initial find was not successful
		return;
	}

	do
	{
		GetEditCtrl().ReplaceSel(pEditState->strReplace);
	} while (FindText(pEditState->strFind, 1, bCase));
	GetEditCtrl().SetSel(startPos);

	ASSERT_VALID(this);
}

BOOL CEditView::InitializeReplace()
	// helper to do find first if no selection
{
	ASSERT_VALID(this);

	_AFX_EDIT_STATE* pEditState = _afxEditState;

	// do find next if no selection
	int nStartChar, nEndChar;
	GetEditCtrl().GetSel(nStartChar, nEndChar);
	if (nStartChar == nEndChar)
	{
		if (!FindText(pEditState->strFind, pEditState->bNext,
			pEditState->bCase))
		{
			// text not found
			OnTextNotFound(pEditState->strFind);
		}
		return FALSE;
	}

	if (!SameAsSelected(pEditState->strFind, pEditState->bCase))
	{
		if (!FindText(pEditState->strFind, pEditState->bNext,
			pEditState->bCase))
		{
			// text not found
			OnTextNotFound(pEditState->strFind);
		}
		return FALSE;
	}

	ASSERT_VALID(this);
	return TRUE;
}

LRESULT CEditView::OnFindReplaceCmd(WPARAM, LPARAM lParam)
{
	ASSERT_VALID(this);

	_AFX_EDIT_STATE* pEditState = _afxEditState;
	CFindReplaceDialog* pDialog = CFindReplaceDialog::GetNotifier(lParam);
	ASSERT(pDialog != NULL);
	ASSERT(pDialog == pEditState->pFindReplaceDlg);
	if (pDialog->IsTerminating())
	{
		pEditState->pFindReplaceDlg = NULL;
	}
	else if (pDialog->FindNext())
	{
		OnFindNext(pDialog->GetFindString(),
			pDialog->SearchDown(), pDialog->MatchCase());
	}
	else if (pDialog->ReplaceCurrent())
	{
		ASSERT(!pEditState->bFindOnly);
		OnReplaceSel(pDialog->GetFindString(),
			pDialog->SearchDown(), pDialog->MatchCase(),
			pDialog->GetReplaceString());
	}
	else if (pDialog->ReplaceAll())
	{
		ASSERT(!pEditState->bFindOnly);
		OnReplaceAll(pDialog->GetFindString(), pDialog->GetReplaceString(),
			pDialog->MatchCase());
	}
	ASSERT_VALID(this);
	return 0;
}

typedef int (WINAPI* AFX_COMPARE_PROC)(LPCTSTR str1, LPCTSTR str2);

BOOL CEditView::SameAsSelected(LPCTSTR lpszCompare, BOOL bCase)
{
	// check length first
	size_t nLen = lstrlen(lpszCompare);
	int nStartChar, nEndChar;
	GetEditCtrl().GetSel(nStartChar, nEndChar);
	if (nLen != (size_t)(nEndChar - nStartChar))
		return FALSE;

	// length is the same, check contents
	CString strSelect;
	GetSelectedText(strSelect);
	return (bCase && lstrcmp(lpszCompare, strSelect) == 0) ||
		(!bCase && lstrcmpi(lpszCompare, strSelect) == 0);
}

BOOL CEditView::FindText(LPCTSTR lpszFind, BOOL bNext, BOOL bCase)
{
	ASSERT_VALID(this);
	ASSERT(lpszFind != NULL);
	ASSERT(*lpszFind != '\0');

	UINT nLen = GetBufferLength();
	int nStartChar, nEndChar;
	GetEditCtrl().GetSel(nStartChar, nEndChar);
	UINT nStart = nStartChar;
	int iDir = bNext ? +1 : -1;

	// can't find a match before the first character
	if (nStart == 0 && iDir < 0)
		return FALSE;

	CWaitCursor wait;
	LPCTSTR lpszText = LockBuffer();

	if (iDir < 0)
	{
		// always go back one for search backwards
		nStart -= int((lpszText+nStart) -
			_tcsdec(lpszText, lpszText+nStart));
	}
	else if (nStartChar != nEndChar && SameAsSelected(lpszFind, bCase))
	{
		// easy to go backward/forward with SBCS
		if (_istlead(lpszText[nStart]))
			nStart++;
		nStart += iDir;
	}

	// handle search with nStart past end of buffer
	UINT nLenFind = lstrlen(lpszFind);
	if (nStart+nLenFind-1 >= nLen)
	{
		if (iDir < 0 && nLen >= nLenFind)
		{
			if (_afxDBCS)
			{
				// walk back to previous character n times
				nStart = nLen;
				int n = nLenFind;
				while (n--)
				{
					nStart -= int((lpszText+nStart) -
						_tcsdec(lpszText, lpszText+nStart));
				}
			}
			else
			{
				// single-byte character set is easy and fast
				nStart = nLen - nLenFind;
			}
			ASSERT(nStart+nLenFind-1 <= nLen);
		}
		else
		{
			UnlockBuffer();
			return FALSE;
		}
	}

	// start the search at nStart
	LPCTSTR lpsz = lpszText + nStart;
	AFX_COMPARE_PROC pfnCompare = bCase ? lstrcmp : lstrcmpi;

	if (_afxDBCS)
	{
		// double-byte string search
		LPCTSTR lpszStop;
		if (iDir > 0)
		{
			// start at current and find _first_ occurrance
			lpszStop = lpszText + nLen - nLenFind + 1;
		}
		else
		{
			// start at top and find _last_ occurrance
			lpszStop = lpsz;
			lpsz = lpszText;
		}

		LPCTSTR lpszFound = NULL;
		while (lpsz <= lpszStop)
		{
			if (!bCase || (*lpsz == *lpszFind &&
				(!_istlead(*lpsz) || lpsz[1] == lpszFind[1])))
			{
				LPTSTR lpch = (LPTSTR)(lpsz + nLenFind);
				TCHAR chSave = *lpch;
				*lpch = '\0';
				int nResult = (*pfnCompare)(lpsz, lpszFind);
				*lpch = chSave;
				if (nResult == 0)
				{
					lpszFound = lpsz;
					if (iDir > 0)
						break;
				}
			}
			lpsz = _tcsinc(lpsz);
		}
		UnlockBuffer();

		if (lpszFound != NULL)
		{
			int n = (int)(lpszFound - lpszText);
			GetEditCtrl().SetSel(n, n+nLenFind);
			return TRUE;
		}
	}
	else
	{
		// single-byte string search
		UINT nCompare;
		if (iDir < 0)
			nCompare = (UINT)(lpsz - lpszText) + 1;
		else
			nCompare = nLen - (UINT)(lpsz - lpszText) - nLenFind + 1;

		while (nCompare > 0)
		{
			ASSERT(lpsz >= lpszText);
			ASSERT(lpsz+nLenFind-1 <= lpszText+nLen-1);

			LPSTR lpch = (LPSTR)(lpsz + nLenFind);
			char chSave = *lpch;
			*lpch = '\0';
			int nResult = (*pfnCompare)(lpsz, lpszFind);
			*lpch = chSave;
			if (nResult == 0)
			{
				UnlockBuffer();
				int n = (int)(lpsz - lpszText);
				GetEditCtrl().SetSel(n, n+nLenFind);
				ASSERT_VALID(this);
				return TRUE;
			}

			// restore character at end of search
			*lpch = chSave;

			// move on to next substring
			nCompare--;
			lpsz += iDir;
		}
		UnlockBuffer();
	}

	ASSERT_VALID(this);
	return FALSE;
}

void CEditView::OnTextNotFound(LPCTSTR)
{
	ASSERT_VALID(this);
	MessageBeep(0);
}

/////////////////////////////////////////////////////////////////////////////
// CEditView Tab Stops

void CEditView::SetTabStops(int nTabStops)
{
	ASSERT_VALID(this);
	m_nTabStops = nTabStops;
	GetEditCtrl().SetTabStops(m_nTabStops);
	Invalidate();
	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// CEditView diagnostics

#ifdef _DEBUG
void CEditView::AssertValid() const
{
	CCtrlView::AssertValid();
	ASSERT_VALID(&m_aPageStart);
	if (m_hPrinterFont != NULL)
		ASSERT_VALID(CFont::FromHandle(m_hPrinterFont));
	if (m_hMirrorFont != NULL)
		ASSERT_VALID(CFont::FromHandle(m_hMirrorFont));
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	if (pEditState->pFindReplaceDlg != NULL)
		ASSERT_VALID(pEditState->pFindReplaceDlg);
}

void CEditView::Dump(CDumpContext& dc) const
{
	CCtrlView::Dump(dc);

	dc << "m_nTabStops = " << m_nTabStops;
	if (m_hPrinterFont != NULL)
		dc << "\nm_hPrinterFont " << m_hPrinterFont;
	if (m_hMirrorFont != NULL)
		dc << "\nm_hMirrorFont " << m_hMirrorFont;
	dc << "\nm_aPageStart: " << &m_aPageStart;
	dc << "\nstatic member data:";
	_AFX_EDIT_STATE* pEditState = _afxEditState;
	if (pEditState->pFindReplaceDlg != NULL)
	{
		dc << "\npFindReplaceDlg = "
			<< (void*)pEditState->pFindReplaceDlg;
		dc << "\nbFindOnly = " << pEditState->bFindOnly;
	}
	dc << "\nstrFind = " << pEditState->strFind;
	dc << "\nstrReplace = " << pEditState->strReplace;
	dc << "\nbCase = " << pEditState->bCase;
	dc << "\nbNext = " << pEditState->bNext;

	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNCREATE(CEditView, CCtrlView)

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_EDIT_STATE, _afxEditState)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewform.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CFormView, CScrollView)
	//{{AFX_MSG_MAP(CFormView)
	ON_WM_SETFOCUS()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
#ifndef _AFX_NO_OCC_SUPPORT
	ON_MESSAGE(WM_INITDIALOG, &CFormView::HandleInitDialog)
#endif
END_MESSAGE_MAP()

CFormView::CFormView(LPCTSTR lpszTemplateName)
{
	m_lpszTemplateName = lpszTemplateName;
	m_pCreateContext = NULL;
	m_hWndFocus = NULL;     // focus window is unknown
#ifndef _AFX_NO_OCC_SUPPORT
	m_pOccDialogInfo = NULL;
	m_pCreatedOccDialogInfo = NULL;
#endif
	EnableActiveAccessibility();
}

CFormView::CFormView(UINT nIDTemplate)
{
	ASSERT_VALID_IDR(nIDTemplate);
	m_lpszTemplateName = MAKEINTRESOURCE(nIDTemplate);
	m_pCreateContext = NULL;
	m_hWndFocus = NULL;     // focus window is unknown
#ifndef _AFX_NO_OCC_SUPPORT
	m_pOccDialogInfo = NULL;
	m_pCreatedOccDialogInfo = NULL;
#endif
	EnableActiveAccessibility();
}

CFormView::~CFormView()
{
	AFX_BEGIN_DESTRUCTOR

#ifndef _AFX_NO_OCC_SUPPORT
		if (m_pCreatedOccDialogInfo != NULL)
		{
			COccManager* pOccManager = afxOccManager;
			if (pOccManager != NULL)
			{
				pOccManager->PostCreateDialog(m_pCreatedOccDialogInfo);
			}
			delete m_pCreatedOccDialogInfo;
			m_pCreatedOccDialogInfo = NULL;
			m_pOccDialogInfo = NULL;
		}
#endif

	AFX_END_DESTRUCTOR
}

// virtual override of CWnd::Create
BOOL CFormView::Create(LPCTSTR /*lpszClassName*/, LPCTSTR /*lpszWindowName*/,
	DWORD dwRequestedStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
	CCreateContext* pContext)
{
	ASSERT(pParentWnd != NULL);
	ASSERT(m_lpszTemplateName != NULL);

	m_pCreateContext = pContext;    // save state for later OnCreate

#ifdef _DEBUG
	// dialog template must exist and be invisible with WS_CHILD set
	if (!_AfxCheckDialogTemplate(m_lpszTemplateName, TRUE))
	{
		ASSERT(FALSE);          // invalid dialog template name
		PostNcDestroy();        // cleanup if Create fails too soon
		return FALSE;
	}
#endif //_DEBUG

	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));
	AfxDeferRegisterClass(AFX_WNDCOMMCTLSNEW_REG);

	// call PreCreateWindow to get prefered extended style
	CREATESTRUCT cs; memset(&cs, 0, sizeof(CREATESTRUCT));
	if (dwRequestedStyle == 0)
		dwRequestedStyle = AFX_WS_DEFAULT_VIEW;
	cs.style = dwRequestedStyle;
	if (!PreCreateWindow(cs))
		return FALSE;

	// create a modeless dialog
	if (!CreateDlg(m_lpszTemplateName, pParentWnd))
		return FALSE;

	m_pCreateContext = NULL;

	// we use the style from the template - but make sure that
	//  the WS_BORDER bit is correct
	// the WS_BORDER bit will be whatever is in dwRequestedStyle
	ModifyStyle(WS_BORDER|WS_CAPTION, cs.style & (WS_BORDER|WS_CAPTION));
	ModifyStyleEx(WS_EX_CLIENTEDGE, cs.dwExStyle & WS_EX_CLIENTEDGE);

	SetDlgCtrlID(nID);

	CRect rectTemplate;
	GetWindowRect(rectTemplate);
	SetScrollSizes(MM_TEXT, rectTemplate.Size());

	// initialize controls etc
	if (!ExecuteDlgInit(m_lpszTemplateName))
		return FALSE;

	// force the size requested
	SetWindowPos(NULL, rect.left, rect.top,
		rect.right - rect.left, rect.bottom - rect.top,
		SWP_NOZORDER|SWP_NOACTIVATE);

	// make visible if requested
	if (dwRequestedStyle & WS_VISIBLE)
		ShowWindow(SW_NORMAL);

	return TRUE;
}

void CFormView::OnInitialUpdate()
{
	ASSERT_VALID(this);

	if (!UpdateData(FALSE))
		TRACE(traceAppMsg, 0, "UpdateData failed during formview initial update.\n");

	CScrollView::OnInitialUpdate();
}

int CFormView::OnCreate(LPCREATESTRUCT lpcs)
{
	// since we can't get the create context parameter passed in
	//  through CreateDialog, we use a temporary member variable
	lpcs->lpCreateParams = (LPVOID)m_pCreateContext;
	return CScrollView::OnCreate(lpcs);
}

void CFormView::OnActivateView(
	BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
	if (SaveFocusControl())
		return;     // don't call base class when focus is already set

	CView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

void CFormView::OnActivateFrame(UINT nState, CFrameWnd* /*pFrameWnd*/)
{
	if (nState == WA_INACTIVE)
		SaveFocusControl();     // save focus when frame loses activation
}

BOOL CFormView::SaveFocusControl()
{
	// save focus window if focus is on this window's controls
	HWND hWndFocus = ::GetFocus();
	if (hWndFocus != NULL && ::IsChild(m_hWnd, hWndFocus))
	{
		m_hWndFocus = hWndFocus;
		return TRUE;
	}
	return FALSE;
}

void CFormView::OnSetFocus(CWnd*)
{
	if (!::IsWindow(m_hWndFocus) || !::IsChild(m_hWnd, m_hWndFocus))
	{
		// invalid or unknown focus window... let windows handle it
		m_hWndFocus = NULL;
		Default();
		return;
	}
	// otherwise, set focus to the last known focus window
	::SetFocus(m_hWndFocus);
}

BOOL CFormView::PreTranslateMessage(MSG* pMsg)
{
	ASSERT(pMsg != NULL);
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);

	// allow tooltip messages to be filtered
	if (CView::PreTranslateMessage(pMsg))
		return TRUE;

	// don't translate dialog messages when in Shift+F1 help mode
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	if (pFrameWnd != NULL && pFrameWnd->m_bHelpMode)
		return FALSE;

	// since 'IsDialogMessage' will eat frame window accelerators,
	//   we call all frame windows' PreTranslateMessage first
	pFrameWnd = GetParentFrame();   // start with first parent frame
	while (pFrameWnd != NULL)
	{
		// allow owner & frames to translate before IsDialogMessage does
		if (pFrameWnd->PreTranslateMessage(pMsg))
			return TRUE;

		// try parent frames until there are no parent frames
		pFrameWnd = pFrameWnd->GetParentFrame();
	}

	// don't call IsDialogMessage if form is empty
	if (::GetWindow(m_hWnd, GW_CHILD) == NULL)
		return FALSE;

	// filter both messages to dialog and from children
	return PreTranslateInput(pMsg);
}

void CFormView::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);

	PaintWindowlessControls(pDC);
#ifdef _DEBUG
	if (pDC->IsPrinting())
		TRACE(traceAppMsg, 0, "Warning: CFormView does not support printing.\n");
#endif

	UNUSED(pDC);     // unused in release build
}

#ifndef _AFX_NO_OCC_SUPPORT

LRESULT CFormView::HandleInitDialog(WPARAM, LPARAM)
{
	Default();  // allow default to initialize first (common dialogs/etc)

	// create OLE controls
	COccManager* pOccManager = afxOccManager;
	if ((pOccManager != NULL) && (m_pOccDialogInfo != NULL))
	{
		if (!pOccManager->CreateDlgControls(this, m_lpszTemplateName,
			m_pOccDialogInfo))
		{
			TRACE(traceAppMsg, 0, "Warning: CreateDlgControls failed during form view init.\n");
			return FALSE;
		}
	}

	return FALSE;   // don't set focus until later
}

BOOL CFormView::SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo)
{
	m_pOccDialogInfo = pOccDialogInfo;
	return TRUE;
}

_AFX_OCC_DIALOG_INFO* CFormView::GetOccDialogInfo()
{
#ifndef _AFX_NO_OCC_SUPPORT
    if (m_pOccDialogInfo == NULL && m_lpszTemplateName != NULL)
    {
        LPCDLGTEMPLATE lpDialogTemplate = NULL;
        HINSTANCE hInst = AfxFindResourceHandle(m_lpszTemplateName, RT_DIALOG);
        HRSRC hResource = ::FindResource(hInst, m_lpszTemplateName, RT_DIALOG);
        HGLOBAL hTemplate = LoadResource(hInst, hResource);
        if (hTemplate != NULL)
        {
            lpDialogTemplate = (LPCDLGTEMPLATE)LockResource(hTemplate);
            if (lpDialogTemplate != NULL)
            {
                COccManager* pOccManager = afxOccManager;
                if (pOccManager != NULL)
                {
                    _AFX_OCC_DIALOG_INFO *pOccDialogInfo = new _AFX_OCC_DIALOG_INFO;
                    lpDialogTemplate = pOccManager->PreCreateDialog(pOccDialogInfo,
                        lpDialogTemplate);
                    m_pOccDialogInfo = pOccDialogInfo;
                    if(m_pCreatedOccDialogInfo != NULL )
                    {
                        pOccManager->PostCreateDialog(m_pCreatedOccDialogInfo);
                        delete m_pCreatedOccDialogInfo;
                    }
                    m_pCreatedOccDialogInfo = pOccDialogInfo;
                }
            }
        }
        
    }
#endif
    return m_pOccDialogInfo;	
}

#endif //!_AFX_NO_OCC_SUPPORT

//////////////////////////////////////////////////////////////////////////
// CFormView diagnostics

#ifdef _DEBUG
void CFormView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

	dc << "m_lpszTemplateName = ";
	if (IS_INTRESOURCE(m_lpszTemplateName))
		dc << (int)LOWORD((DWORD_PTR)m_lpszTemplateName);
	else
		dc << m_lpszTemplateName;

	dc << "\n";
}

void CFormView::AssertValid() const
{
	CView::AssertValid();
}
#endif


IMPLEMENT_DYNAMIC(CFormView, CScrollView)

//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewoled.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxoledb.h>



#define new DEBUG_NEW

class _AfxUINT128
{
public:
	_AfxUINT128()
	{
	}
	_AfxUINT128( ULONGLONG n ) :
		nLo( n ),
		nHi( 0 )
	{
	}
	_AfxUINT128& operator<<=( UINT n )
	{
		if( n < 64 )
		{
			nHi <<= n;
			nHi |= nLo>>(64-n);
			nLo <<= n;
		}
		else
		{
			nHi = nLo<<(n-64);
			nLo = 0;
		}

		return( *this );
	}
	_AfxUINT128& operator>>=( UINT n )
	{
		if( n < 64 )
		{
			nLo >>= n;
			nLo |= nHi<<(64-n);
			nHi >>= n;
		}
		else
		{
			nLo = nHi>>(n-64);
			nHi = 0;
		}

		return( *this );
	}
	_AfxUINT128& operator++( int )
	{
		nLo++;
		if( nLo == 0 )
		{
			nHi++;
		}

		return( *this );
	}

public:
	ULONGLONG nLo;
	ULONGLONG nHi;
};

static bool operator!=( const _AfxUINT128& a, const _AfxUINT128& b )
{
	return( (a.nHi != b.nHi) || (a.nLo != b.nLo) );
}

static bool operator>=( const _AfxUINT128& a, const _AfxUINT128& b )
{
	if( a.nHi < b.nHi )
	{
		return( false );
	}
	else if( a.nHi > b.nHi )
	{
		return( true );
	}
	else
	{
		return( a.nLo >= b.nLo );
	}
}

static _AfxUINT128 operator+( const _AfxUINT128& a, const _AfxUINT128& b )
{
	_AfxUINT128 s;

	s.nLo = a.nLo+b.nLo;
	s.nHi = a.nHi+b.nHi;
	if( s.nLo < a.nLo )
	{
		s.nHi++;
	}

	return( s );
}

static _AfxUINT128 operator-( const _AfxUINT128& a, const _AfxUINT128& b )
{
	_AfxUINT128 d;

	d.nLo = a.nLo-b.nLo;
	d.nHi = a.nHi-b.nHi;
	if( d.nLo > a.nLo )
	{
		d.nHi--;
	}

	return( d );
}

static _AfxUINT128 operator*( const _AfxUINT128& a, ULONG b )
{
	_AfxUINT128 p;
	_AfxUINT128 nTemp;

	p = ULONGLONG( ULONG( a.nLo ) )*b;

	nTemp = (a.nLo>>32)*b;
	nTemp <<= 32;
	p = p+nTemp;

	nTemp = ULONGLONG( ULONG( a.nHi ) )*b;
	nTemp <<= 64;
	p = p+nTemp;

	nTemp = (a.nHi>>32)*b;
	nTemp <<= 96;
	p = p+nTemp;

	return( p );
}

static _AfxUINT128 operator/( const _AfxUINT128& a, const _AfxUINT128& b )
{
	_AfxUINT128 q;
	_AfxUINT128 a_;
	_AfxUINT128 b_;

	q = 0;

	a_ = a;
	b_ = b;
	while( !(b_.nHi&(1i64<<63)) )
	{
		b_ <<= 1;
	}

	while( b_ >= b )
	{
		q <<= 1;
		if( a_ >= b_ )
		{
			q++;
			a_ = a_-b_;
		}
		b_ >>= 1;
	}

	return( q );
}

static _AfxUINT128 operator%( const _AfxUINT128& a, const _AfxUINT128& b )
{
	_AfxUINT128 q;
	_AfxUINT128 a_;
	_AfxUINT128 b_;

	q = 0;

	a_ = a;
	b_ = b;
	while( !(b_.nHi&(1i64<<63)) )
	{
		b_ <<= 1;
	}

	while( b_ >= b )
	{
		q <<= 1;
		if( a_ >= b_ )
		{
			q++;
			a_ = a_-b_;
		}
		b_ >>= 1;
	}

	return( a_ );
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DB_NUMERIC& value)
{
	ENSURE_ARG(pDX!=NULL);
	HWND hWndCtrl;

	pDX->PrepareEditCtrl(nIDC);
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		CString strText;
		int nLength;
		_AfxUINT128 nValue;
		NUMPARSE parse;
		HRESULT hResult;
		LPBYTE pbDigit;
		int iDigit;

		nLength = ::GetWindowTextLength(hWndCtrl);
		::GetWindowText(hWndCtrl, strText.GetBufferSetLength(nLength), nLength+1);
		strText.ReleaseBuffer();

		ATL::CTempBuffer< BYTE > pbDigits(nLength);
		parse.cDig = nLength;
		parse.dwInFlags = NUMPRS_STD&~NUMPRS_HEX_OCT;
		parse.dwOutFlags = 0;
		parse.cchUsed = 0;
		parse.nBaseShift = 0;
		parse.nPwr10 = 0;
		hResult = VarParseNumFromStr(const_cast<LPOLESTR>(CStringW(strText).GetString()),
			::GetThreadLocale(), NUMPRS_STD&~NUMPRS_HEX_OCT, &parse, pbDigits);
		if (FAILED(hResult))
		{
			pDX->Fail();
		}
		if (parse.nPwr10 <= 0)
		{
			if (parse.nPwr10 < -38)
				pDX->Fail();
			value.scale = BYTE( -parse.nPwr10 );
		}
		else
		{
			if ((parse.nPwr10+parse.cDig) > 38)
				pDX->Fail();
			value.scale = 0;
		}
		value.precision = BYTE(parse.cDig+max(parse.nPwr10, 0));
		if (parse.dwOutFlags&NUMPRS_NEG)
		{
			value.sign = 0;
		}
		else
		{
			value.sign = 1;
		}

		nValue = 0;

		pbDigit = pbDigits;
		for (iDigit = 0; iDigit < parse.cDig; iDigit++)
		{
			nValue = nValue*10;
			nValue = nValue+*pbDigit;
			pbDigit++;
		}

		for (iDigit = 0; iDigit < parse.nPwr10; iDigit++)
		{
			nValue = nValue*10;
		}
		*(UNALIGNED ULONGLONG*)&value.val[0] = nValue.nLo;
		*(UNALIGNED ULONGLONG*)&value.val[8] = nValue.nHi;
	}
	else
	{
		TCHAR szText[41];  // 38 digits+sign+decimal+null
		_AfxUINT128 n;
		LPTSTR pszText;
		ULONG iDigit;

		ASSERT( value.precision <= 38 );
		n.nLo = *(UNALIGNED ULONGLONG*)&value.val[0];
		n.nHi = *(UNALIGNED ULONGLONG*)&value.val[8];

		szText[40] = _T( '\0' );
		pszText = &szText[40];
		iDigit = 0;
		while( (n != 0) || (iDigit <= value.scale) )
		{
			_AfxUINT128 nRemainder;

			if( (iDigit == value.scale) && (iDigit != 0) )
			{
				pszText--;
				*pszText = _T( '.' );
			}
			nRemainder = n%10;
			n = n/10;
			ASSERT( nRemainder.nHi == 0 );
			ASSERT( nRemainder.nLo < 10 );
			pszText--;
			*pszText = TCHAR( nRemainder.nLo+_T( '0' ) );
			iDigit++;
		}
		if( pszText == &szText[40] )
		{
			pszText--;
			*pszText = _T( '0' );
		}
		if( value.sign == 0 )
		{
			pszText--;
			*pszText = _T( '-' );
		}

		AfxSetWindowText(hWndCtrl, pszText);
	}
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DBDATE& value)
{
	ENSURE_ARG(pDX!=NULL);
	COleDateTime date;
	pDX->PrepareEditCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		CString strTemp;

		::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
		strTemp.ReleaseBuffer();

		if (!date.ParseDateTime(strTemp))  // throws exception
		{
			// Can't convert string to datetime
			AfxMessageBox(AFX_IDP_PARSE_DATE);
			pDX->Fail();    // throws exception
		}

		value.year = short(date.GetYear());
		value.month = USHORT(date.GetMonth());
		value.day = USHORT(date.GetDay());
	}
	else
	{
		date.SetDate(value.year, value.month, value.day);
		CString strTemp = date.Format();
		AfxSetWindowText(hWndCtrl, strTemp);
	}
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DBTIME& value)
{
	ENSURE_ARG(pDX!=NULL);
	COleDateTime date;
	pDX->PrepareEditCtrl(nIDC);
	HWND hWndCtrl;
	pDX->m_pDlgWnd->GetDlgItem(nIDC, &hWndCtrl);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		CString strTemp;

		::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
		strTemp.ReleaseBuffer();

		if (!date.ParseDateTime(strTemp, VAR_TIMEVALUEONLY))  // throws exception
		{
			// Can't convert string to datetime
			AfxMessageBox(AFX_IDP_PARSE_TIME);
			pDX->Fail();    // throws exception
		}

		value.hour = USHORT(date.GetHour());
		value.minute = USHORT(date.GetMinute());
		value.second = USHORT(date.GetSecond());
	}
	else
	{
		date.SetTime(value.hour, value.minute, value.second);
		CString strTemp = date.Format();
		AfxSetWindowText(hWndCtrl, strTemp);
	}
}

void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, DBDATE& value)
{
	ENSURE_ARG(pDX!=NULL);
	SYSTEMTIME st;

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CDateTimeCtrl* pWnd = (CDateTimeCtrl*) CWnd::FromHandle(hWndCtrl);
	ENSURE(pWnd!=NULL);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetTime(&st);
		value.year = st.wYear;
		value.month = st.wMonth;
		value.day = st.wDay;
	}
	else
	{
		st.wYear = value.year;
		st.wMonth = value.month;
		st.wDayOfWeek = 0;
		st.wDay = value.day;
		st.wHour = 0;
		st.wMinute = 0;
		st.wSecond = 0;
		st.wMilliseconds = 0;
		pWnd->SetTime(&st);
	}
}

void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, DBTIME& value)
{
	ENSURE_ARG(pDX!=NULL);
	SYSTEMTIME st;

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CDateTimeCtrl* pWnd = (CDateTimeCtrl*) CWnd::FromHandle(hWndCtrl);
	ENSURE(pWnd!=NULL);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetTime(&st);
		value.hour = st.wHour;
		value.minute = st.wMinute;
		value.second = st.wSecond;
	}
	else
	{
		::GetSystemTime(&st);
		st.wHour = value.hour;
		st.wMinute = value.minute;
		st.wSecond = value.second;
		st.wMilliseconds = 0;
		pWnd->SetTime(&st);
	}
}

void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC,
	DBDATE& value)
{
	ENSURE_ARG(pDX!=NULL);
	SYSTEMTIME st;

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CMonthCalCtrl* pWnd = (CMonthCalCtrl*) CWnd::FromHandle(hWndCtrl);
	ENSURE(pWnd!=NULL);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetCurSel(&st);
		value.year = st.wYear;
		value.month = st.wMonth;
		value.day = st.wDay;
	}
	else
	{
		st.wYear = value.year;
		st.wMonth = value.month;
		st.wDay = value.day;
		st.wDayOfWeek = 0;
		st.wHour = 0;
		st.wMinute = 0;
		st.wSecond = 0;
		st.wMilliseconds = 0;
		pWnd->SetCurSel(&st);
	}
}


/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(COleDBRecordView, CFormView)
	//{{AFX_MSG_MAP(COleDBRecordView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
	ON_COMMAND_EX(ID_RECORD_FIRST, &COleDBRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_FIRST, &COleDBRecordView::OnUpdateRecordFirst)
	ON_COMMAND_EX(ID_RECORD_PREV, &COleDBRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_PREV, &COleDBRecordView::OnUpdateRecordPrev)
	ON_COMMAND_EX(ID_RECORD_NEXT, &COleDBRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_NEXT, &COleDBRecordView::OnUpdateRecordNext)
	ON_COMMAND_EX(ID_RECORD_LAST, &COleDBRecordView::OnMove)
	ON_UPDATE_COMMAND_UI(ID_RECORD_LAST, &COleDBRecordView::OnUpdateRecordLast)
END_MESSAGE_MAP()

void COleDBRecordView::OnInitialUpdate()
{
	CFormView::OnInitialUpdate();
}

BOOL COleDBRecordView::OnMove(UINT nIDMoveCommand)
{
	CRowset<>* pSet = OnGetRowset();

	if (!UpdateData())
		return TRUE;
	pSet->SetData(0);

	HRESULT hr = E_UNEXPECTED;
	switch (nIDMoveCommand)
	{
		case ID_RECORD_PREV:
			hr = pSet->MovePrev();
			if (hr != S_OK)
				m_bOnFirstRecord = TRUE;
			else
				m_bOnLastRecord  = FALSE;
			break;

		case ID_RECORD_FIRST:
			hr = pSet->MoveFirst();
			if (hr == S_OK)
			{
				m_bOnFirstRecord = TRUE;
				m_bOnLastRecord  = FALSE;
			}
			break;

		case ID_RECORD_NEXT:
			hr = pSet->MoveNext();
			if (hr == S_OK)
				m_bOnFirstRecord = FALSE;
			else
				m_bOnLastRecord  = TRUE;
			break;

		case ID_RECORD_LAST:
			hr = pSet->MoveLast();
			if (hr == S_OK)
			{
				m_bOnFirstRecord = FALSE;
				m_bOnLastRecord  = TRUE;
			}
			break;

		default:
			// Unexpected case value
			ASSERT(FALSE);
	}

	if (hr != S_OK)
		return FALSE;

	// Show results of move operation
	UpdateData(FALSE);
	return TRUE;
}

void COleDBRecordView::OnUpdateRecordFirst(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(!m_bOnFirstRecord);
}

void COleDBRecordView::OnUpdateRecordPrev(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(!m_bOnFirstRecord);
}

void COleDBRecordView::OnUpdateRecordNext(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(!m_bOnLastRecord);
}

void COleDBRecordView::OnUpdateRecordLast(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(!m_bOnLastRecord);
}

//////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(COleDBRecordView, CFormView)

//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewprev.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



BOOL CALLBACK _AfxPreviewCloseProc(CFrameWnd* pFrameWnd);

/////////////////////////////////////////////////////////////////////////////
// CPrintPreviewState helper structure

CPrintPreviewState::CPrintPreviewState()
{
	// set defaults
	nIDMainPane = AFX_IDW_PANE_FIRST;
	dwStates = AFX_CONTROLBAR_MASK(AFX_IDW_STATUS_BAR);
						// status bar visible if available
	lpfnCloseProc = _AfxPreviewCloseProc;
						// set frame hook so closing the frame window
						//  when in preview state will just end the mode
	hMenu = NULL;
	pViewActiveOld = NULL;
	hAccelTable = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CView's OnPrintPreview.  Here to force linkage

void CView::OnFilePrintPreview()
{
	// In derived classes, implement special window handling here
	// Be sure to Unhook Frame Window close if hooked.

	// must not create this on the frame.  Must outlive this function
	CPrintPreviewState* pState = new CPrintPreviewState;

	TRY
	{
		// DoPrintPreview's return value does not necessarily indicate that
		// Print preview succeeded or failed, but rather what actions are necessary
		// at this point.  If DoPrintPreview returns TRUE, it means that
		// OnEndPrintPreview will be (or has already been) called and the
		// pState structure will be/has been deleted.
		// If DoPrintPreview returns FALSE, it means that OnEndPrintPreview
		// WILL NOT be called and that cleanup, including deleting pState
		// must be done here.

		if (!DoPrintPreview(AFX_IDD_PREVIEW_TOOLBAR, this,
								RUNTIME_CLASS(CPreviewView), pState))
		{
			// In derived classes, reverse special window handling here for
			// Preview failure case

			TRACE(traceAppMsg, 0, "Error: DoPrintPreview failed.\n");
			AfxMessageBox(AFX_IDP_COMMAND_FAILURE);
			delete pState;      // preview failed to initialize, delete State now
		}
	}
	CATCH_ALL(e)
	{
		delete pState;
		THROW_LAST();
	}
	END_CATCH_ALL
}

BOOL CView::DoPrintPreview(UINT nIDResource, CView* pPrintView,
	CRuntimeClass* pPreviewViewClass, CPrintPreviewState* pState)
{
	ASSERT_VALID_IDR(nIDResource);
	ASSERT_VALID(pPrintView);
	ASSERT(pPreviewViewClass != NULL);
	ASSERT(pPreviewViewClass->IsDerivedFrom(RUNTIME_CLASS(CPreviewView)));
	ASSERT(pState != NULL);

	CWnd* pMainWnd = GetParentFrame();
	if (DYNAMIC_DOWNCAST(CFrameWnd, pMainWnd) == NULL)
	{
		// if it's not a frame, we'll try the main window
		pMainWnd = AfxGetMainWnd();
	}

	CFrameWnd* pParent = STATIC_DOWNCAST(CFrameWnd, pMainWnd);
	ASSERT_VALID(pParent);

	CCreateContext context;
	context.m_pCurrentFrame = pParent;
	context.m_pCurrentDoc = GetDocument();
	context.m_pLastView = this;

	// Create the preview view object
	CPreviewView* pView = (CPreviewView*)pPreviewViewClass->CreateObject();
	if (pView == NULL)
	{
		TRACE(traceAppMsg, 0, "Error: Failed to create preview view.\n");
		return FALSE;
	}
	ASSERT_KINDOF(CPreviewView, pView);
	pView->m_pPreviewState = pState;        // save pointer

	pParent->OnSetPreviewMode(TRUE, pState);    // Take over Frame Window

	// Create the toolbar from the dialog resource
	pView->m_pToolBar = new CDialogBar;

	CFrameWnd *pParentFrame = pParent->GetActiveFrame();
	ASSERT(pParentFrame);

	COleIPFrameWnd *pInPlaceFrame = DYNAMIC_DOWNCAST(COleIPFrameWnd, pParentFrame);
	if (pInPlaceFrame) 
	{
		CDocument *pViewDoc = GetDocument();
		COleServerDoc *pDoc = DYNAMIC_DOWNCAST(COleServerDoc, pViewDoc);
		if (!pDoc)
		{
			pParent->OnSetPreviewMode(FALSE, pState);   // restore Frame Window
			delete pView->m_pToolBar;       // not autodestruct yet
			pView->m_pToolBar = NULL;
			pView->m_pPreviewState = NULL;  // do not delete state structure
			delete pView;
			return FALSE;
		}

		CFrameWnd *pFrame = (CFrameWnd*)pInPlaceFrame->GetDocFrame();
		if (!pFrame)
			pFrame = pInPlaceFrame->GetMainFrame();
		ASSERT(pFrame != NULL);

		// hide existing toolbars.
		pDoc->OnDocWindowActivate(FALSE);

		if ( pFrame && pView->m_pToolBar->Create(pFrame,
			ATL_MAKEINTRESOURCE(nIDResource),CBRS_TOP, AFX_IDW_PREVIEW_BAR) )
		{   
			// automatic cleanup
			pView->m_pToolBar->m_bAutoDelete = TRUE;

			// Tell the toolbar where to route command messages
			pView->m_pToolBar->SetInPlaceOwner(pInPlaceFrame);

			// now, merge the print preview toolbar into the
			// appropriate frame which would be the document
			// frame for an mdi container or the app frame for
			// an sdi container.
			CRect rcBorder;
			BOOL bFrame = FALSE;
			CComPtr<IOleInPlaceUIWindow> spIPUIWindow;

			if (FAILED(pInPlaceFrame->GetInPlaceDocFrame(&spIPUIWindow)))
			{
				pInPlaceFrame->GetInPlaceFrame(&spIPUIWindow);
				bFrame = TRUE;
			}
			ASSERT(spIPUIWindow);
			if (spIPUIWindow)
			{
				spIPUIWindow->GetBorder(rcBorder);
				pDoc->OnResizeBorder(rcBorder, spIPUIWindow, bFrame);
			}
			pInPlaceFrame->SetPreviewMode(TRUE);
		}
		else
		{
			TRACE(traceAppMsg, 0, "Error: Preview could not create toolbar dialog.\n");
			pParent->OnSetPreviewMode(FALSE, pState);   // restore Frame Window
			delete pView->m_pToolBar;       // not autodestruct yet
			pView->m_pToolBar = NULL;
			pView->m_pPreviewState = NULL;  // do not delete state structure
			delete pView;
			return FALSE;
		}
	}
	else
	{
		if (!pView->m_pToolBar->Create(pParent, ATL_MAKEINTRESOURCE(nIDResource),
		CBRS_TOP, AFX_IDW_PREVIEW_BAR))
		{
			TRACE(traceAppMsg, 0, "Error: Preview could not create toolbar dialog.\n");
			pParent->OnSetPreviewMode(FALSE, pState);   // restore Frame Window
			delete pView->m_pToolBar;       // not autodestruct yet
			pView->m_pToolBar = NULL;
			pView->m_pPreviewState = NULL;  // do not delete state structure
			delete pView;
			return FALSE;
		}
		pView->m_pToolBar->m_bAutoDelete = TRUE;    // automatic cleanup
	}

	// Create the preview view as a child of the App Main Window.  This
	// is a sibling of this view if this is an SDI app.  This is NOT a sibling
	// if this is an MDI app.

	if (!pView->Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
		CRect(0,0,0,0), pParent, AFX_IDW_PANE_FIRST, &context))
	{
		TRACE(traceAppMsg, 0, "Error: couldn't create preview view for frame.\n");
		pParent->OnSetPreviewMode(FALSE, pState);   // restore Frame Window
		pView->m_pPreviewState = NULL;  // do not delete state structure
		delete pView;
		return FALSE;
	}

	// Preview window shown now
	pState->pViewActiveOld = pParent->GetActiveView();
	CView* pActiveView = pParent->GetActiveFrame()->GetActiveView();

	if (pActiveView != NULL)
		pActiveView->OnActivateView(FALSE, pActiveView, pActiveView);

	if (!pView->SetPrintView(pPrintView))
	{
		pView->OnPreviewClose();
		return TRUE;            // signal that OnEndPrintPreview was called
	}

	pParent->SetActiveView(pView);  // set active view - even for MDI

	pView->m_pToolBar->SendMessage(WM_IDLEUPDATECMDUI, (WPARAM)TRUE);
	pParent->RecalcLayout();            // position and size everything
	pParent->UpdateWindow();

	return TRUE;
}

BOOL CALLBACK _AfxPreviewCloseProc(CFrameWnd* pFrameWnd)
{
	ASSERT_VALID(pFrameWnd);
	CPreviewView* pView = (CPreviewView*) pFrameWnd->GetDlgItem(AFX_IDW_PANE_FIRST);
	ASSERT_KINDOF(CPreviewView, pView);

	pView->OnPreviewClose();
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Preview View

BEGIN_MESSAGE_MAP(CPreviewView, CScrollView)
	//{{AFX_MSG_MAP(CPreviewView)
	ON_WM_SIZE()        // overriding CScrollView
	ON_WM_CREATE()

	ON_COMMAND(AFX_ID_PREVIEW_CLOSE, &CPreviewView::OnPreviewClose)
	ON_COMMAND(AFX_ID_PREVIEW_NUMPAGE, &CPreviewView::OnNumPageChange)
	ON_COMMAND(AFX_ID_PREVIEW_NEXT, &CPreviewView::OnNextPage)
	ON_COMMAND(AFX_ID_PREVIEW_PREV, &CPreviewView::OnPrevPage)
	ON_COMMAND(AFX_ID_PREVIEW_PRINT, &CPreviewView::OnPreviewPrint)
	ON_COMMAND(AFX_ID_PREVIEW_ZOOMIN, &CPreviewView::OnZoomIn)
	ON_COMMAND(AFX_ID_PREVIEW_ZOOMOUT, &CPreviewView::OnZoomOut)

	ON_UPDATE_COMMAND_UI(AFX_ID_PREVIEW_NUMPAGE, &CPreviewView::OnUpdateNumPageChange)
	ON_UPDATE_COMMAND_UI(AFX_ID_PREVIEW_NEXT, &CPreviewView::OnUpdateNextPage)
	ON_UPDATE_COMMAND_UI(AFX_ID_PREVIEW_PREV, &CPreviewView::OnUpdatePrevPage)
	ON_UPDATE_COMMAND_UI(AFX_ID_PREVIEW_ZOOMIN, &CPreviewView::OnUpdateZoomIn)
	ON_UPDATE_COMMAND_UI(AFX_ID_PREVIEW_ZOOMOUT, &CPreviewView::OnUpdateZoomOut)

	ON_WM_VSCROLL()
	ON_WM_HSCROLL()
	ON_WM_LBUTTONDOWN()
	ON_WM_ERASEBKGND()
	ON_WM_SETCURSOR()
	//}}AFX_MSG_MAP

END_MESSAGE_MAP()

CPreviewView::CPreviewView()
{
	m_pToolBar = NULL;
	m_pPrintView = NULL;
	m_pOrigView = NULL;
	m_pPreviewInfo = NULL;
	m_pPreviewDC = NULL;
	m_pPreviewState = NULL;
	m_hMagnifyCursor = NULL;
	m_bPageNumDisplayed = FALSE;
	m_nZoomState = _AFX_ZOOM_OUT;

	// default to pointing to embedded array.  Allows for 2 pages
	m_pPageInfo = m_pageInfoArray;
	m_nMaxPages = 2;

	// initialize CScrollView members
	m_bCenter = TRUE;                   // Center Zoomed output in Scrollview
	m_nMapMode = MM_TEXT;
}

CPreviewView::PAGE_INFO::PAGE_INFO()
{
}

CPreviewView::~CPreviewView()
{
	m_dcPrint.Detach();         // print DC is deleted by CPrintInfo destructor

	delete m_pPreviewInfo;      // get rid of preview info
	delete m_pPreviewState;     // Get rid of preview state
	delete m_pPreviewDC;        // Get rid of preview DC object

	if (m_hMagnifyCursor != NULL)
	{
		// make sure that m_hMagnifyCursor isn't the current cursor when we destroy it
		::SetCursor(::LoadCursor(NULL, IDC_ARROW));
		DestroyCursor(m_hMagnifyCursor);
	}
}

int CPreviewView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	int retVal = CView::OnCreate(lpCreateStruct);
	if (retVal == -1)
		return -1;      // if -1 bag out

	CCreateContext* pContext = (CCreateContext*)lpCreateStruct->lpCreateParams;

	m_pOrigView = pContext->m_pLastView;
	ASSERT(m_pOrigView != NULL);
	ASSERT_KINDOF(CView, m_pOrigView);

	return retVal;
}

BOOL CPreviewView::SetPrintView(CView* pPrintView)
{
	ASSERT_VALID(pPrintView);

	m_pPrintView = pPrintView;

	// allocate preview info
	m_pPreviewInfo = new CPrintInfo;
	m_pPreviewInfo->m_pPD->SetHelpID(AFX_IDD_PRINTSETUP);
	m_pPreviewInfo->m_pPD->m_pd.Flags |= PD_PRINTSETUP;
	m_pPreviewInfo->m_pPD->m_pd.Flags &= ~PD_RETURNDC;

	m_pPreviewInfo->m_bPreview = TRUE;  // signal that this is preview
	ASSERT(m_pPreviewInfo->m_pPD != NULL);

	m_pPreviewDC = new CPreviewDC;      // must be created before any
										// possible error returns

	if (!m_pPrintView->OnPreparePrinting(m_pPreviewInfo))
		return FALSE;

#ifdef _DEBUG
	if (m_pPreviewInfo->m_pPD->m_pd.hDC == NULL)
	{
		TRACE(traceAppMsg, 0, "Error: hDC not set for printing --\n");
		TRACE(traceAppMsg, 0, "\tDid you remember to call DoPreparePrinting?\n");
		ASSERT(FALSE);      // common mistake gets trapped here
	}
#endif //_DEBUG

	m_dcPrint.Attach(m_pPreviewInfo->m_pPD->m_pd.hDC);
	m_pPreviewDC->SetAttribDC(m_pPreviewInfo->m_pPD->m_pd.hDC);
	m_pPreviewDC->m_bPrinting = TRUE;
	m_dcPrint.m_bPrinting = TRUE;

	m_dcPrint.SaveDC();     // Save pristine state of DC

	HDC hDC = ::GetDC(m_hWnd);
	m_pPreviewDC->SetOutputDC(hDC);
	m_pPrintView->OnBeginPrinting(m_pPreviewDC, m_pPreviewInfo);
	m_pPreviewDC->ReleaseOutputDC();
	::ReleaseDC(m_hWnd, hDC);

	m_dcPrint.RestoreDC(-1);    // restore to untouched state

	// Get Pixels per inch from Printer
	m_sizePrinterPPI.cx = m_dcPrint.GetDeviceCaps(LOGPIXELSX);
	m_sizePrinterPPI.cy = m_dcPrint.GetDeviceCaps(LOGPIXELSY);

	m_nPages = m_pPreviewInfo->m_nNumPreviewPages;
	if (m_nPages == 0)
		m_nPages = 1;
	else if (m_nPages > m_nMaxPages)
		m_nPages = m_nMaxPages;     // Sanity Check!

	m_nZoomOutPages = m_nPages;

	SetScrollSizes(MM_TEXT, CSize(1, 1));   // initialize mapping mode only

	if (m_pPreviewInfo->GetMaxPage() < 0x8000 &&
		m_pPreviewInfo->GetMaxPage() - m_pPreviewInfo->GetMinPage() <= 32767U)
	{
		SCROLLINFO info;
		info.fMask = SIF_PAGE|SIF_RANGE;
		info.nMin = m_pPreviewInfo->GetMinPage();
		info.nMax = m_pPreviewInfo->GetMaxPage();
		info.nPage = 1;
		if (!SetScrollInfo(SB_VERT, &info, FALSE))
			SetScrollRange(SB_VERT, info.nMin, info.nMax, FALSE);
	}
	else
		ShowScrollBar(SB_VERT, FALSE);      // if no range specified, or too
											// large don't show

	SetCurrentPage(m_pPreviewInfo->m_nCurPage, TRUE);
	return TRUE;
}

void CPreviewView::OnSize(UINT nType, int cx, int cy)
{
	// CScrollView handles everything if zoomed in.
	if (m_nZoomState == _AFX_ZOOM_OUT)
	{
		// Force recalc of scale ratios on next draw
		for (UINT i = 0; i < m_nMaxPages; i++)
			m_pPageInfo[i].sizeScaleRatio.cx = 0;           // zero scale ratios

		CView::OnSize(nType, cx, cy);       // No scroll functionality
	}
	else
	{
		// adjust scroll size to size of page
		m_pageDev.cx = cx;
		m_pageDev.cy = cy;
		m_lineDev.cx = cx / 10;
		m_lineDev.cy = cy / 10;
		CScrollView::OnSize(nType, cx, cy);
	}
}

void CPreviewView::OnActivateView(BOOL bActivate, CView*, CView*)
{
	if (bActivate)
	{
		CWnd* pFocusWnd = GetFocus();
		if (pFocusWnd == NULL ||
			(m_pToolBar != NULL && IsWindow(m_pToolBar->m_hWnd)))
		{
			if (!m_pToolBar->IsChild(pFocusWnd))
			{
				// focus is not already on a toolbar button - set it to one
				m_pToolBar->GetDlgItem(AFX_ID_PREVIEW_PRINT)->SetFocus();
			}
		}
	}
}

void CPreviewView::OnPreviewClose()
{
	CWnd* pMainWnd = GetParentFrame();
	if (DYNAMIC_DOWNCAST(CFrameWnd, pMainWnd) == NULL)
	{
		// if it's not a frame, we'll try the main window
		pMainWnd = AfxGetMainWnd();
	}

	CFrameWnd* pParent = DYNAMIC_DOWNCAST(CFrameWnd, pMainWnd);
	ASSERT_VALID(pParent);

	while (m_pToolBar && m_pToolBar->m_pInPlaceOwner)
	{
		COleIPFrameWnd *pInPlaceFrame = DYNAMIC_DOWNCAST(COleIPFrameWnd, pParent);
		if (!pInPlaceFrame)
			break;

		CDocument *pViewDoc = GetDocument();
		if (!pViewDoc)
			break;
		// in place items must have a server document.
		COleServerDoc *pDoc = DYNAMIC_DOWNCAST(COleServerDoc, pViewDoc);
		if (!pDoc)
			break;
		// destroy our toolbar
		m_pToolBar->DestroyWindow();
		m_pToolBar = NULL;
		pInPlaceFrame->SetPreviewMode(FALSE);
		// restore toolbars
		pDoc->OnDocWindowActivate(TRUE);
		break;
	}
	if (m_pToolBar)
		m_pToolBar->DestroyWindow();

	m_pToolBar = NULL;

	m_pPreviewInfo->m_nCurPage = m_nCurrentPage;
	m_pOrigView->OnEndPrintPreview(m_pPreviewDC, m_pPreviewInfo,
									CPoint(0, 0), this);
}

#define PREVIEW_MARGIN  8
#define PREVIEW_PAGEGAP 8

// Return is actually the fraction cx/cy. Simply using CSize for convenience
CSize CPreviewView::CalcScaleRatio(CSize screenSize, CSize actualSize)
{
	// Test ratio based on vertical dimension to see if it is the one to use
	int nNum = screenSize.cy;
	int nDen = actualSize.cy;

	// If scaled width too large, choose width as primary dimension
	if (MulDiv(actualSize.cx, nNum, nDen) > screenSize.cx)
	{
		// wrong ratio--base on width
		nNum = screenSize.cx;
		nDen = actualSize.cx;
	}
	CSize ratio(nNum, nDen);
	return ratio;
}

// Position Page...
// Generate a Screen MM_TEXT rectangle to enclose each page.  Dimensions
// of the rectangle must be 1 pixel Above and Left of the top/left corner
// of the page and the rectangle width and height must be THREE pixels
// larger than page in order to provide the correct placement of the
// two pixel border.
//
// This routine is called once for each page with the preview DC set up for
// that page

void CPreviewView::PositionPage(UINT nPage)
{
	CSize windowSize = CalcPageDisplaySize();

	VERIFY(m_dcPrint.Escape(GETPHYSPAGESIZE, 0, NULL,
			(LPVOID)&m_pPageInfo[nPage].sizeUnscaled));

	CSize* pSize = &m_pPageInfo[nPage].sizeUnscaled;

	// Convert page size to screen coordinates
	pSize->cx = MulDiv(pSize->cx, afxData.cxPixelsPerInch, m_sizePrinterPPI.cx);
	pSize->cy = MulDiv(pSize->cy, afxData.cyPixelsPerInch, m_sizePrinterPPI.cy);

	m_pPageInfo[nPage].sizeZoomOutRatio = CalcScaleRatio(windowSize, *pSize);

	SetScaledSize(nPage);
}

CSize CPreviewView::CalcPageDisplaySize()
	// calculate the current page size
	//  set 'm_nSecondPageOffset' to start of second page
	// return size of current page less margins
{
	CSize windowSize, scrollSize;
	GetTrueClientSize(windowSize, scrollSize);

	// subtract out vertical scrollbar if zoomed out and page range is known
	// and there is more than one page.
	if (m_nZoomState == _AFX_ZOOM_OUT && (m_pPreviewInfo->GetMaxPage() != 0xffff) &&
		(m_pPreviewInfo->GetMaxPage() - m_pPreviewInfo->GetMinPage() != 0))
		windowSize.cx -= scrollSize.cx;

	m_nSecondPageOffset = (windowSize.cx - PREVIEW_MARGIN) / 2;

	windowSize.cx = (m_nPages == 2) ? (windowSize.cx - 3*PREVIEW_MARGIN) / 2 :
									windowSize.cx - 2*PREVIEW_MARGIN;

	windowSize.cy -= 2*PREVIEW_MARGIN;
	return windowSize;
}

void CPreviewView::SetScaledSize(UINT nPage)
{
	CSize* pSize = &m_pPageInfo[nPage].sizeUnscaled;
	CSize* pRatio = &m_pPageInfo[nPage].sizeScaleRatio;
	CSize* pZoomOutRatio = &m_pPageInfo[nPage].sizeZoomOutRatio;
	CSize windowSize = CalcPageDisplaySize();
	BOOL bPaperLarger = pZoomOutRatio->cx < pZoomOutRatio->cy;
		// whether the paper is larger than the screen, or vice versa

	switch (m_nZoomState)
	{
	case _AFX_ZOOM_OUT:
		*pRatio = *pZoomOutRatio;
		break;

	case _AFX_ZOOM_MIDDLE:
		// the middle zoom state is a ratio between cx/cy and
		// 1/1 (or cy/cy).  It is, therefore:
		//
		// (cx + cy)/2
		// -----------
		//     cy
		//
		// if the paper is larger than the screen, or
		//
		// (3*cx - cy)/2
		// -------------
		//      cy
		//
		// if the paper is smaller than the screen.
		if (bPaperLarger)
		{
			pRatio->cy = pZoomOutRatio->cy;
			pRatio->cx = (pZoomOutRatio->cx + pRatio->cy) / 2;
		}
		else
		{
			pRatio->cy = pZoomOutRatio->cy;
			pRatio->cx = (3*pZoomOutRatio->cx - pRatio->cy) / 2;
		}
		break;

	case _AFX_ZOOM_IN:
		if (bPaperLarger)
			pRatio->cx = pRatio->cy = 1;
		else
		{
			// if the paper is smaller than the screen space we're displaying
			// it in, then using a ratio of 1/1 will result in a smaller image
			// on the screen, not a larger one. To get a larger image in this
			// case we double the zoom out ratio.
			pRatio->cy = pZoomOutRatio->cy;
			pRatio->cx = 2*pZoomOutRatio->cx - pZoomOutRatio->cy;
		}
		break;

	default:
		ASSERT(FALSE);
	}

	// Convert to scaled size
	CSize scaledSize;
	scaledSize.cx = MulDiv(pSize->cx, pRatio->cx, pRatio->cy);
	scaledSize.cy = MulDiv(pSize->cy, pRatio->cx, pRatio->cy);

	CRect* pRect = &m_pPageInfo[nPage].rectScreen;
	pRect->SetRect(PREVIEW_MARGIN, PREVIEW_MARGIN,
				   scaledSize.cx + PREVIEW_MARGIN + 3,
				   scaledSize.cy + PREVIEW_MARGIN + 3);

	if (m_nZoomState == _AFX_ZOOM_OUT)
	{
		pRect->OffsetRect((windowSize.cx - pRect->Size().cx) / 2 - 1,
						  (windowSize.cy - pRect->Size().cy) / 2 - 1);

		if (nPage == 1)
			pRect->OffsetRect(m_nSecondPageOffset, 0);
	}
	else
	{
		// set up scroll size

		SetScrollSizes(MM_TEXT, pRect->Size() +
				CSize(PREVIEW_MARGIN * 2, PREVIEW_MARGIN * 2), windowSize);
	}
}

// Only use the PrepareDC from CScrollView if we are zoomed in
void CPreviewView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
	ASSERT_VALID(pDC);
	if (m_nZoomState == _AFX_ZOOM_OUT)
		CView::OnPrepareDC(pDC, pInfo);
	else if (m_pPageInfo[0].sizeScaleRatio.cx != 0)
		CScrollView::OnPrepareDC(pDC, pInfo);
}

BOOL CPreviewView::OnEraseBkgnd(CDC* pDC)
{
	ASSERT_VALID(pDC);

	// Fill background with APPWORKSPACE
	CBrush backBrush(GetSysColor(COLOR_APPWORKSPACE));
	CBrush* pOldBrush = pDC->SelectObject(&backBrush);
	CRect rect;
	pDC->GetClipBox(&rect);     // Erase the area needed

	pDC->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATCOPY);
	pDC->SelectObject(pOldBrush);
	return TRUE;
}

void CPreviewView::OnDraw(CDC* pDC)
{
	ASSERT_VALID(pDC);

	// don't do anything if not fully initialized
	if (m_pPrintView == NULL || m_dcPrint.m_hDC == NULL)
		return;

	CPoint ViewportOrg = pDC->GetViewportOrg();

	CPen rectPen;
	rectPen.CreatePen(PS_SOLID, 2, GetSysColor(COLOR_WINDOWFRAME));
	CPen shadowPen;
	shadowPen.CreatePen(PS_SOLID, 3, GetSysColor(COLOR_BTNSHADOW));

	m_pPreviewInfo->m_bContinuePrinting = TRUE;     // do this once each paint

	for (UINT nPage = 0; nPage < m_nPages; nPage++)
	{
		int nSavedState = m_dcPrint.SaveDC();       // Save pristine state of DC

		// Use paint DC for print preview output
		m_pPreviewDC->SetOutputDC(pDC->GetSafeHdc());

		m_pPreviewInfo->m_nCurPage = m_nCurrentPage + nPage;

		// Only call PrepareDC if within page range, otherwise use default
		// rect to draw page rectangle
		if (m_nCurrentPage + nPage >= m_nCurrentPage && 
		    m_nCurrentPage + nPage >= nPage && 
		    m_nCurrentPage + nPage <= m_pPreviewInfo->GetMaxPage())
		{
			m_pPrintView->OnPrepareDC(m_pPreviewDC, m_pPreviewInfo);
		}

		// Set up drawing rect to entire page (in logical coordinates)
		m_pPreviewInfo->m_rectDraw.SetRect(0, 0,
			m_pPreviewDC->GetDeviceCaps(HORZRES),
			m_pPreviewDC->GetDeviceCaps(VERTRES));
		m_pPreviewDC->DPtoLP(&m_pPreviewInfo->m_rectDraw);

		// Draw empty page on screen

		pDC->SaveDC();          // save the output dc state

		CSize* pRatio = &m_pPageInfo[nPage].sizeScaleRatio;
		CRect* pRect = &m_pPageInfo[nPage].rectScreen;

		if (pRatio->cx == 0)
		{   // page position has not been determined
			PositionPage(nPage);    // compute page position
			if (m_nZoomState != _AFX_ZOOM_OUT)
			{
				ViewportOrg = -GetDeviceScrollPosition();
				if (m_bCenter)
				{
					CRect rect;
					GetClientRect(&rect);
					// if client area is larger than total device size,
					// override scroll positions to place origin such that
					// output is centered in the window
					if (m_totalDev.cx < rect.Width())
						ViewportOrg.x = (rect.Width() - m_totalDev.cx) / 2;
					if (m_totalDev.cy < rect.Height())
						ViewportOrg.y = (rect.Height() - m_totalDev.cy) / 2;
				}
			}
		}

		pDC->SetMapMode(MM_TEXT);   // Page Rectangle is in screen device coords
		pDC->SetViewportOrg(ViewportOrg);
		pDC->SetWindowOrg(0, 0);

		pDC->SelectStockObject(HOLLOW_BRUSH);
		pDC->SelectObject(&rectPen);
		pDC->Rectangle(pRect);

		pDC->SelectObject(&shadowPen);

		pDC->MoveTo(pRect->right + 1, pRect->top + 3);
		pDC->LineTo(pRect->right + 1, pRect->bottom + 1);
		pDC->MoveTo(pRect->left + 3, pRect->bottom + 1);
		pDC->LineTo(pRect->right + 1, pRect->bottom + 1);

		// erase background to white (most paper is white)
		CRect rectFill = *pRect;
		rectFill.left += 1;
		rectFill.top += 1;
		rectFill.right -= 2;
		rectFill.bottom -= 2;
		::FillRect(pDC->m_hDC, rectFill, (HBRUSH)GetStockObject(WHITE_BRUSH));

		pDC->RestoreDC(-1);     // restore to synchronized state

		if (!m_pPreviewInfo->m_bContinuePrinting ||
				m_nCurrentPage + nPage > m_pPreviewInfo->GetMaxPage())
		{
			m_pPreviewDC->ReleaseOutputDC();
			m_dcPrint.RestoreDC(nSavedState);   // restore to untouched state

			// if the first page is not displayable, back up one page
			// but never go below 1
			if (nPage == 0 && m_nCurrentPage > 1)
				SetCurrentPage(m_nCurrentPage - 1, TRUE);
			break;
		}

		// Display page number
		OnDisplayPageNumber(m_nCurrentPage, nPage + 1);

		// Set scale ratio for this page
		m_pPreviewDC->SetScaleRatio(pRatio->cx, pRatio->cy);

		CSize PrintOffset;
		VERIFY(m_pPreviewDC->Escape(GETPRINTINGOFFSET, 0, NULL, (LPVOID)&PrintOffset));
		m_pPreviewDC->PrinterDPtoScreenDP((LPPOINT)&PrintOffset);
		PrintOffset += (CSize)pRect->TopLeft();
		PrintOffset += CSize(1, 1);
		PrintOffset += (CSize)ViewportOrg;  // For Scrolling

		m_pPreviewDC->SetTopLeftOffset(PrintOffset);

		m_pPreviewDC->ClipToPage();
		m_pPrintView->OnPrint(m_pPreviewDC, m_pPreviewInfo);

		m_pPreviewDC->ReleaseOutputDC();

		m_dcPrint.RestoreDC(nSavedState);   // restore to untouched state

	}

	rectPen.DeleteObject();
	shadowPen.DeleteObject();
}

void CPreviewView::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (m_nZoomState != _AFX_ZOOM_OUT)
		CScrollView::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CPreviewView::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (m_nZoomState != _AFX_ZOOM_OUT)
	{
		CScrollView::OnVScroll(nSBCode, nPos, pScrollBar);
		return;
	}

	switch (nSBCode)
	{
	case SB_BOTTOM:
		SetCurrentPage(m_pPreviewInfo->GetMaxPage(), TRUE);
		break;

	case SB_TOP:
		SetCurrentPage(m_pPreviewInfo->GetMinPage(), TRUE);
		break;

	case SB_PAGEDOWN:
		SetCurrentPage(m_nCurrentPage +
			(m_pPreviewInfo->GetMaxPage() - m_pPreviewInfo->GetMinPage() + 9) / 10, TRUE);
		break;

	case SB_PAGEUP:
		SetCurrentPage(m_nCurrentPage -
			(m_pPreviewInfo->GetMaxPage() - m_pPreviewInfo->GetMinPage() + 9) / 10, TRUE);
		break;

	case SB_LINEDOWN:
		SetCurrentPage(m_nCurrentPage + 1, TRUE);
		break;

	case SB_LINEUP:
		SetCurrentPage(m_nCurrentPage - 1, TRUE);
		break;

	case SB_THUMBPOSITION:
		SetCurrentPage(nPos, TRUE);
		break;
	}
}

void CPreviewView::OnNumPageChange()
{
	ASSERT(m_nPages == 1 || m_nPages == 2);
	m_nPages = 3 - m_nPages;    // Toggle between 1 and 2
	AfxGetApp()->m_nNumPreviewPages = m_nPages;
	m_nZoomOutPages = m_nPages;

	// Just do this to set the status correctly and invalidate
	SetCurrentPage(m_nCurrentPage, TRUE);
}

void CPreviewView::OnNextPage()
{
	SetCurrentPage(m_nCurrentPage + 1, TRUE);
}

void CPreviewView::OnPrevPage()
{
	SetCurrentPage(m_nCurrentPage - 1, TRUE);
}

void CPreviewView::OnPreviewPrint()
{
	// cause print (can be overridden by catching the command)
	CFrameWnd *pOrigFrame = m_pOrigView->EnsureParentFrame();

	OnPreviewClose();
	CWinThread *pThread = AfxGetThread();
	ASSERT( pThread );
	CWnd *pMainWnd = pThread->m_pMainWnd;
	ASSERT_VALID(pMainWnd);

	COleIPFrameWnd *pInPlaceFrame = DYNAMIC_DOWNCAST(COleIPFrameWnd, pOrigFrame);
	if (pInPlaceFrame)
	{
		pInPlaceFrame->SendMessage(WM_COMMAND, ID_FILE_PRINT);
	}
	else
	{
		// ensure we print the correct frame
		pOrigFrame->SendMessage(WM_COMMAND, ID_FILE_PRINT);
	}
}

// Finds page pointed to and convert to 1:1 screen device units
BOOL CPreviewView::FindPageRect(CPoint& point, UINT& nPage)
{
	if (m_nZoomState != _AFX_ZOOM_OUT)
		point += (CSize)GetDeviceScrollPosition();

	CRect rectClient;
	this->GetClientRect(&rectClient);

	for (nPage = 0; nPage < m_nPages; nPage++)
	{
		CRect rectScreen(m_pPageInfo[nPage].rectScreen);
		/* When zoom state is not _AFX_ZOOM_OUT, only one page can be displayed. 
		   Two-page is available only on state _AFX_ZOOM_OUT 
		   
		   When zoom state is not _AFX_ZOOM_OUT, the rectScreen need to be adjusted for point testing */
		if (m_nZoomState != _AFX_ZOOM_OUT)
		{
			int nDeltaX = (rectClient.Size().cx - rectScreen.Size().cx - 2 * PREVIEW_MARGIN) / 2 - 1;
			int nDeltaY = (rectClient.Size().cy - rectScreen.Size().cy - 2 * PREVIEW_MARGIN) / 2 - 1;

			// When delta is less than 0, don't need to change the value.
			nDeltaX = nDeltaX < 0 ? 0 : nDeltaX;
			nDeltaY = nDeltaY < 0 ? 0 : nDeltaY;
			rectScreen.OffsetRect(nDeltaX, nDeltaY);
		}
		if (rectScreen.PtInRect(point))
		{
			// adjust point for page position
			point -= (CSize)m_pPageInfo[nPage].rectScreen.TopLeft();

			// convert to 1:1
			point.x = MulDiv(point.x, m_pPageInfo[nPage].sizeScaleRatio.cy,
									m_pPageInfo[nPage].sizeScaleRatio.cx);
			point.y = MulDiv(point.y, m_pPageInfo[nPage].sizeScaleRatio.cy,
									m_pPageInfo[nPage].sizeScaleRatio.cx);
			return TRUE;
		}
	}
	return FALSE;
}


void CPreviewView::OnLButtonDown(UINT, CPoint point)
{
	UINT nPage;
	if (!FindPageRect(point, nPage))
		return;                         // Didn't click on a page

	// Set new zoom state
	SetZoomState((m_nZoomState == _AFX_ZOOM_IN) ? _AFX_ZOOM_OUT : m_nZoomState + 1,
								nPage, point);
}

void CPreviewView::SetZoomState(UINT nNewState, UINT nPage, CPoint point)
{
	if (m_nZoomState != nNewState)
	{
		m_nZoomState = nNewState;
		DoZoom(nPage, point);
	}
}

void CPreviewView::OnZoomIn()
{
	if (m_nZoomState != _AFX_ZOOM_IN)
		SetZoomState(m_nZoomState + 1, 0, CPoint(0, 0));
}

void CPreviewView::OnZoomOut()
{
	if (m_nZoomState != _AFX_ZOOM_OUT)
		SetZoomState(m_nZoomState - 1, 0, CPoint(0, 0));
}

// Actual zoom code.
void CPreviewView::DoZoom(UINT nPage, CPoint point)
{
	if (m_nZoomState == _AFX_ZOOM_OUT)
	{
		// taking over scroll bars
		m_nPages = m_nZoomOutPages;
		ShowScrollBar(SB_HORZ, FALSE);      //hide the horizontal bar

		BOOL bShowBar = m_pPreviewInfo->GetMaxPage() < 0x8000 &&
			m_pPreviewInfo->GetMaxPage() -
			m_pPreviewInfo->GetMinPage() <= 32767U;

		ShowScrollBar(SB_VERT, bShowBar);       //Show the vertical bar

		if (bShowBar)
		{
			SCROLLINFO info;
			info.fMask = SIF_PAGE|SIF_RANGE;
			info.nMin = m_pPreviewInfo->GetMinPage();
			info.nMax = m_pPreviewInfo->GetMaxPage();
			info.nPage = 1;
			if (!SetScrollInfo(SB_VERT, &info, FALSE))
				SetScrollRange(SB_VERT, info.nMin, info.nMax, FALSE);
		}

		SetCurrentPage(m_nCurrentPage, TRUE);
	}
	else
	{
		m_nPages = 1;       // only one page in zoomed states

		m_pPageInfo[0].sizeZoomOutRatio = m_pPageInfo[nPage].sizeZoomOutRatio;
		m_pPageInfo[0].sizeUnscaled = m_pPageInfo[nPage].sizeUnscaled;

		// Sets the printer page
		SetCurrentPage(m_nCurrentPage + nPage, FALSE);

		SetScaledSize(0);

		CSize* pRatio = &m_pPageInfo[nPage].sizeScaleRatio;

		// convert Hit Point from screen 1:1
		point.x = MulDiv(point.x, pRatio->cx, pRatio->cy);
		point.y = MulDiv(point.y, pRatio->cx, pRatio->cy);

		// Adjust point for page position
		point += (CSize)m_pPageInfo[0].rectScreen.TopLeft();

		// Scroll to center
		CenterOnPoint(point);
	}
}

void CPreviewView::SetCurrentPage(UINT nPage, BOOL bClearRatios)
{
	m_nCurrentPage = nPage;
	if (m_nCurrentPage > m_pPreviewInfo->GetMaxPage())
		m_nCurrentPage = m_pPreviewInfo->GetMaxPage();
	if (m_nCurrentPage < m_pPreviewInfo->GetMinPage())
		m_nCurrentPage = m_pPreviewInfo->GetMinPage();


	if (m_nZoomState == _AFX_ZOOM_OUT)
		SetScrollPos(SB_VERT, m_nCurrentPage);

	if (bClearRatios)
	{
		// Force Recalc of layout
		for (UINT i = 0; i < m_nMaxPages; i++)
			m_pPageInfo[i].sizeScaleRatio.cx = 0;           // zero scale ratios
	}

	Invalidate(TRUE);
}

void CPreviewView::OnDisplayPageNumber(UINT nPage, UINT nPagesDisplayed)
{
	UINT nEndPage = nPage + nPagesDisplayed - 1;

	CWinThread *pThread = AfxGetThread();
	ASSERT(pThread);
	CFrameWnd* pParent = (CFrameWnd*)pThread->m_pMainWnd;
	ASSERT_VALID(pParent);
	ASSERT_KINDOF(CFrameWnd, pParent);

	int nSubString = (nPagesDisplayed == 1) ? 0 : 1;

	CString s;
	BOOL bOK = AfxExtractSubString(s, m_pPreviewInfo->m_strPageDesc, nSubString);
	if (bOK)
	{
		TCHAR szBuf[80];
		int nResult;

		if (nSubString == 0)
        	{
			nResult = _stprintf_s(szBuf, _countof(szBuf), s, nPage);
        	}
		else
        	{
			nResult = _stprintf_s(szBuf, _countof(szBuf), s, nPage, nEndPage);

        	}

		if( nResult > 0 )
		{
			pParent->SendMessage(WM_SETMESSAGESTRING, 0, (LPARAM)(LPVOID)szBuf);
		}
		else
		{
			bOK = FALSE;
		}
	}

	if(!bOK)
	{
		TRACE(traceAppMsg, 0, "Malformed Page Description string. Could not get string %d.\n",
			nSubString);
	}
}


void CPreviewView::OnUpdateNumPageChange(CCmdUI* pCmdUI)
{
	// set text of button to opposite of current state
	CString text;
	UINT nPages = m_nZoomState == _AFX_ZOOM_OUT ? m_nPages : m_nZoomOutPages;
	ENSURE(text.LoadString(nPages == 1 ? AFX_IDS_TWOPAGE : AFX_IDS_ONEPAGE));
	pCmdUI->SetText(text);

	// enable it only if valid to display another page and not zoomed
	pCmdUI->Enable(m_nZoomState == _AFX_ZOOM_OUT && m_nMaxPages != 1 &&
		(m_pPreviewInfo->GetMaxPage() > 1 || m_nPages > 1));
}

void CPreviewView::OnUpdateNextPage(CCmdUI* pCmdUI)
{
	// enable if not showing last page
	pCmdUI->Enable(m_nCurrentPage+m_nPages-1 < m_pPreviewInfo->GetMaxPage());
}

void CPreviewView::OnUpdatePrevPage(CCmdUI* pCmdUI)
{
	// enable if not showing First page
	pCmdUI->Enable(m_nCurrentPage > m_pPreviewInfo->GetMinPage());
}

void CPreviewView::OnUpdateZoomIn(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(m_nZoomState != _AFX_ZOOM_IN);
}

void CPreviewView::OnUpdateZoomOut(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(m_nZoomState != _AFX_ZOOM_OUT);
}

BOOL CPreviewView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (nHitTest != HTCLIENT)
		return CScrollView::OnSetCursor(pWnd, nHitTest, message);

	CPoint point;
	::GetCursorPos(&point);
	ScreenToClient(&point);     // client coordinates of mouse position

	UINT nPage;
	if (m_nZoomState != _AFX_ZOOM_IN && FindPageRect(point, nPage))
	{                       // On a page and not zoomed all the way in
		if (m_hMagnifyCursor == NULL)
		{
			HINSTANCE hInst = AfxFindResourceHandle(
				ATL_MAKEINTRESOURCE(AFX_IDC_MAGNIFY), ATL_RT_GROUP_CURSOR);
			m_hMagnifyCursor = ::LoadCursorW(hInst,
				ATL_MAKEINTRESOURCEW(AFX_IDC_MAGNIFY));
		}
		::SetCursor(m_hMagnifyCursor);
	}
	else
	{
		::SetCursor(::LoadCursor(NULL, IDC_ARROW));
	}
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CPreviewView diagnostics

#ifdef _DEBUG
void CPreviewView::AssertValid() const
{
	CView::AssertValid();
	ASSERT_VALID(&m_dcPrint);
	if (m_pPreviewDC != NULL)
		ASSERT_VALID(m_pPreviewDC);

	switch (m_nZoomState)
	{
	case _AFX_ZOOM_OUT:
	case _AFX_ZOOM_IN:
	case _AFX_ZOOM_MIDDLE:
		break;
	default:
		ASSERT(FALSE); // unknown zoom state
	}

	switch (m_nMapMode)
	{
	case MM_TEXT:
	case MM_LOMETRIC:
	case MM_HIMETRIC:
	case MM_LOENGLISH:
	case MM_HIENGLISH:
	case MM_TWIPS:
	case MM_ISOTROPIC:
	case MM_ANISOTROPIC:
		break;
	default:
		ASSERT(FALSE); // unknown mapping mode
	}
}

void CPreviewView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

	dc << "m_pPrintView = " << m_pPrintView;
	dc << "\nm_pOrigView = " << m_pOrigView;
	dc << "\nm_bPageNumDisplayed = " << m_bPageNumDisplayed;
	dc << "\nm_bCenter = " << m_bCenter;
	dc << "\nm_nPages = " << m_nPages;
	dc << "\nm_nCurrentPage " << m_nCurrentPage;
	dc << "\nm_nSecondPageOffset " << m_nSecondPageOffset;
	dc << "\nm_nMaxPages = " << m_nMaxPages;
	dc << "\nm_sizePrinterPPI = " << m_sizePrinterPPI;
	dc << "\nm_ptCenterPoint = " << m_ptCenterPoint;
	dc << "\nm_nZoomState = ";
	switch (m_nZoomState)
	{
	case _AFX_ZOOM_OUT:
		dc << "_AFX_ZOOM_OUT";
		break;
	case _AFX_ZOOM_IN:
		dc << "_AFX_ZOOM_IN";
		break;
	case _AFX_ZOOM_MIDDLE:
		dc << "_AFX_ZOOM_MIDDLE";
		break;
	default:
		dc << "*unknown*";
		break;
	}
	dc << "\nm_nMapMode = ";
	switch (m_nMapMode)
	{
	case MM_TEXT:
		dc << "MM_TEXT";
		break;
	case MM_LOMETRIC:
		dc << "MM_LOMETRIC";
		break;
	case MM_HIMETRIC:
		dc << "MM_HIMETRIC";
		break;
	case MM_LOENGLISH:
		dc << "MM_LOENGLISH";
		break;
	case MM_HIENGLISH:
		dc << "MM_HIENGLISH";
		break;
	case MM_TWIPS:
		dc << "MM_TWIPS";
		break;
	case MM_ISOTROPIC:
		dc << "MM_ISOTROPIC";
		break;
	case MM_ANISOTROPIC:
		dc << "MM_ANISOTROPIC";
		break;
	default:
		dc << "*unknown*";
		break;
	}
	dc << "\nm_dcPrint = " << &m_dcPrint;
	dc << "\nm_pPreviewDC = " << m_pPreviewDC;

	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNCREATE(CPreviewView, CScrollView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// CView

BEGIN_MESSAGE_MAP(CView, CWnd)
	//{{AFX_MSG_MAP(CView)
	ON_WM_PAINT()
	ON_WM_MOUSEACTIVATE()
	ON_WM_CREATE()
	ON_WM_DESTROY()

	// Standard commands for split pane
	ON_COMMAND_EX(ID_WINDOW_SPLIT, &CView::OnSplitCmd)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_SPLIT, &CView::OnUpdateSplitCmd)

	// Standard commands for next pane
	ON_UPDATE_COMMAND_UI(ID_NEXT_PANE, &CView::OnUpdateNextPaneMenu)
	ON_COMMAND_EX(ID_NEXT_PANE, &CView::OnNextPaneCmd)
	ON_UPDATE_COMMAND_UI(ID_PREV_PANE, &CView::OnUpdateNextPaneMenu)
	ON_COMMAND_EX(ID_PREV_PANE, &CView::OnNextPaneCmd)

	// special command for Initial Update
	ON_MESSAGE_VOID(WM_INITIALUPDATE, CView::OnInitialUpdate)

	ON_MESSAGE(WM_PRINTCLIENT, &CView::OnPrintClient)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CView construction/destruction

CView::CView()
{
	m_pDocument = NULL;
	m_bInitialRedraw = FALSE;
}

CView::~CView()
{
	AFX_BEGIN_DESTRUCTOR

		// If we're the current routing view, pop the routing view stack
		_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
		while (pThreadState->m_pRoutingView == this)
			pThreadState->m_pPushRoutingView->Pop();

		if (m_pDocument != NULL)
			m_pDocument->RemoveView(this);

	AFX_END_DESTRUCTOR
}

/////////////////////////////////////////////////////////////////////////////
// CView second phase construction - bind to document

BOOL CView::PreCreateWindow(CREATESTRUCT & cs)
{
	ASSERT(cs.style & WS_CHILD);

	if (cs.lpszClass == NULL)
	{
		VERIFY(AfxDeferRegisterClass(AFX_WNDFRAMEORVIEW_REG));
		cs.lpszClass = _afxWndFrameOrView;  // COLOR_WINDOW background
	}

	if (cs.style & WS_BORDER)
	{
		cs.dwExStyle |= WS_EX_CLIENTEDGE;
		cs.style &= ~WS_BORDER;
	}

	return TRUE;
}

int CView::OnCreate(LPCREATESTRUCT lpcs)
{
	if (CWnd::OnCreate(lpcs) == -1)
		return -1;

	// if ok, wire in the current document
	ASSERT(m_pDocument == NULL);
	CCreateContext* pContext = (CCreateContext*)lpcs->lpCreateParams;

	// A view should be created in a given context!
	if (pContext != NULL && pContext->m_pCurrentDoc != NULL)
	{
		pContext->m_pCurrentDoc->AddView(this);
		ASSERT(m_pDocument != NULL);
	}
	else
	{
		TRACE(traceAppMsg, 0, "Warning: Creating a pane with no CDocument.\n");
	}

	return 0;   // ok
}

void CView::OnDestroy()
{
	CFrameWnd* pFrame = GetParentFrame();
	if (pFrame != NULL && pFrame->GetActiveView() == this)
		pFrame->SetActiveView(NULL);    // deactivate during death
	CWnd::OnDestroy();
}

// self destruction
void CView::PostNcDestroy()
{
	// default for views is to allocate them on the heap
	//  the default post-cleanup is to 'delete this'.
	//  never explicitly call 'delete' on a view
	delete this;
}

void CView::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	ENSURE_ARG(lpClientRect != NULL);
	if (nAdjustType != 0)
	{
		// allow for special client-edge style
		::AdjustWindowRectEx(lpClientRect, 0, FALSE, GetExStyle());

		// default behavior for in-place editing handles scrollbars
		DWORD dwStyle = GetStyle();
		if (dwStyle & WS_VSCROLL)
		{
			int nAdjust = afxData.cxVScroll;
			if (dwStyle & WS_BORDER)
				nAdjust -= AFX_CX_BORDER;
			lpClientRect->right += nAdjust;
		}
		if (dwStyle & WS_HSCROLL)
		{
			int nAdjust = afxData.cyHScroll;
			if (dwStyle & WS_BORDER)
				nAdjust -= AFX_CY_BORDER;
			lpClientRect->bottom += nAdjust;
		}
		return;
	}

	// call default to place borders outside of client rect
	CWnd::CalcWindowRect(lpClientRect, nAdjustType);
}

/////////////////////////////////////////////////////////////////////////////
// Command routing

BOOL CView::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// first pump through pane
	if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// then pump through document
	if (m_pDocument != NULL)
	{
		// special state for saving view before routing to document
		CPushRoutingView push(this);
		return m_pDocument->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CView drawing support

void CView::OnPaint()
{
	// standard paint routine
	CPaintDC dc(this);
	OnPrepareDC(&dc);
	OnDraw(&dc);
}

void CView::OnInitialUpdate()
{
	OnUpdate(NULL, 0, NULL);        // initial update
}

void CView::OnUpdate(CView* pSender, LPARAM /*lHint*/, CObject* /*pHint*/)
{
	ASSERT(pSender != this);
	UNUSED(pSender);     // unused in release builds

	// invalidate the entire pane, erase background too
	Invalidate(TRUE);
}

void CView::OnPrint(CDC* pDC, CPrintInfo*)
{
	ASSERT_VALID(pDC);

	// Override and set printing variables based on page number
	OnDraw(pDC);                    // Call Draw
}

void CView::OnDraw(CDC*)
{
}

LRESULT CView::OnPrintClient(WPARAM wp, LPARAM lp)
{
	DWORD dwFlags = (DWORD)lp;

	if (dwFlags & PRF_ERASEBKGND)
	{
		SendMessage(WM_ERASEBKGND, wp);
	}

	if (dwFlags & PRF_CLIENT)
	{
		CDC* pDC = CDC::FromHandle((HDC)wp);
		ASSERT_VALID(pDC);

		OnDraw(pDC);
	}

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CView selection support

BOOL CView::IsSelected(const CObject* pDocItem) const
{
	ASSERT_VALID(pDocItem);
	UNUSED(pDocItem);    // unused in release builds

	return FALSE;   // not implemented, so not selected
}

void CView::OnActivateView(BOOL bActivate, CView* pActivateView, CView*)
{
	UNUSED(pActivateView);   // unused in release builds

	if (bActivate)
	{
		ASSERT(pActivateView == this);

		// take the focus if this frame/view/pane is now active
		if (IsTopParentActive())
			SetFocus();
	}
}

void CView::OnActivateFrame(UINT /*nState*/, CFrameWnd* /*pFrameWnd*/)
{
}

int CView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	int nResult = CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
	if (nResult == MA_NOACTIVATE || nResult == MA_NOACTIVATEANDEAT)
		return nResult;   // frame does not want to activate

	CFrameWnd* pParentFrame = GetParentFrame();
	if (pParentFrame != NULL)
	{
		// eat it if this will cause activation
		ASSERT(pParentFrame == pDesktopWnd || pDesktopWnd->IsChild(pParentFrame));

		// either re-activate the current view, or set this view to be active
		CView* pView = pParentFrame->GetActiveView();
		HWND hWndFocus = ::GetFocus();
		if (pView == this &&
			m_hWnd != hWndFocus && !::IsChild(m_hWnd, hWndFocus))
		{
			// re-activate this view
			OnActivateView(TRUE, this, this);
		}
		else
		{
			// activate this view
			pParentFrame->SetActiveView(this);
		}
	}
	return nResult;
}

/////////////////////////////////////////////////////////////////////////////
// CView scrolling support

BOOL CView::OnScroll(UINT /*nScrollCode*/, UINT /*nPos*/, BOOL /*bDoScroll*/)
{
	return FALSE;
}

BOOL CView::OnScrollBy(CSize /*sizeScroll*/, BOOL /*bDoScroll*/)
{
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CView drag/drop support

DROPEFFECT CView::OnDragScroll(DWORD /*dwKeyState*/, CPoint /*point*/)
{
#ifndef _AFX_NO_OLE_SUPPORT
	return DROPEFFECT_SCROLL; // this means do the default
#else
	return 0;
#endif
}

DROPEFFECT CView::OnDragEnter(COleDataObject* /*pDataObject*/,
	DWORD /*dwKeyState*/, CPoint /*point*/)
{
	return 0;   // DROPEFFECT_NONE
}

DROPEFFECT CView::OnDragOver(COleDataObject* /*pDataObject*/,
	DWORD /*dwKeyState*/, CPoint /*point*/)
{
	return 0;   // DROPEFFECT_NONE
}

BOOL CView::OnDrop(COleDataObject* /*pDataObject*/,
	DROPEFFECT /*dropEffect*/, CPoint /*point*/)
{
	return FALSE;
}

DROPEFFECT CView::OnDropEx(COleDataObject* /*pDataObject*/,
	DROPEFFECT /*dropEffect*/, DROPEFFECT /*dropEffectList*/, CPoint /*point*/)
{
	return (DROPEFFECT)-1;  // not implemented
}

void CView::OnDragLeave()
{
}

/////////////////////////////////////////////////////////////////////////////
// CView splitting commands

CSplitterWnd* PASCAL
CView::GetParentSplitter(const CWnd* pWnd, BOOL bAnyState)
{
	ENSURE_VALID(pWnd);
	CSplitterWnd* pSplitter = (CSplitterWnd*)pWnd->GetParent();
	if (!pSplitter->IsKindOf(RUNTIME_CLASS(CSplitterWnd)))
		return NULL;        // not a splitter
	if (!bAnyState)
	{
		// ignore splitters in minimized (iconic) windows
		while ((pWnd = pWnd->GetParent()) != NULL)
			if (pWnd->IsIconic())
				return NULL;
	}
	return pSplitter;
}

CScrollBar* CView::GetScrollBarCtrl(int nBar) const
{
	ASSERT(nBar == SB_HORZ || nBar == SB_VERT);
	if (GetStyle() & ((nBar == SB_HORZ) ? WS_HSCROLL : WS_VSCROLL))
	{
		// it has a regular windows style scrollbar (no control)
		return NULL;
	}

	CWnd* pParent = GetParentSplitter(this, TRUE);
	if (pParent == NULL)
		return NULL;            // no splitter

	UINT nID = _AfxGetDlgCtrlID(m_hWnd);
	if (nID < AFX_IDW_PANE_FIRST || nID > AFX_IDW_PANE_LAST)
		return NULL;            // not a standard pane ID

	// appropriate PANE id - look for sibling (splitter, or just frame)
	UINT nIDScroll;
	if (nBar == SB_HORZ)
		nIDScroll = AFX_IDW_HSCROLL_FIRST + (nID - AFX_IDW_PANE_FIRST) % 16;
	else
		nIDScroll = AFX_IDW_VSCROLL_FIRST + (nID - AFX_IDW_PANE_FIRST) / 16;

	// return shared scroll bars that are immediate children of splitter
	return (CScrollBar*)pParent->GetDlgItem(nIDScroll);
}


void CView::OnUpdateSplitCmd(CCmdUI* pCmdUI)
{
	ENSURE_ARG(pCmdUI != NULL);
	CSplitterWnd* pSplitter = GetParentSplitter(this, FALSE);
	pCmdUI->Enable(pSplitter != NULL && !pSplitter->IsTracking());
}

BOOL CView::OnSplitCmd(UINT)
{
	CSplitterWnd* pSplitter = GetParentSplitter(this, FALSE);
	if (pSplitter == NULL)
		return FALSE;

	ASSERT(!pSplitter->IsTracking());
	pSplitter->DoKeyboardSplit();
	return TRUE;    // attempted at least
}

void CView::OnUpdateNextPaneMenu(CCmdUI* pCmdUI)
{
	ASSERT(pCmdUI->m_nID == ID_NEXT_PANE ||
		pCmdUI->m_nID == ID_PREV_PANE);
	CSplitterWnd* pSplitter = GetParentSplitter(this, FALSE);
	pCmdUI->Enable(pSplitter != NULL &&
		pSplitter->CanActivateNext(pCmdUI->m_nID == ID_PREV_PANE));
}

BOOL CView::OnNextPaneCmd(UINT nID)
{
	CSplitterWnd* pSplitter = GetParentSplitter(this, FALSE);
	if (pSplitter == NULL)
		return FALSE;

	ASSERT(nID == ID_NEXT_PANE || nID == ID_PREV_PANE);
	pSplitter->ActivateNext(nID == ID_PREV_PANE);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Printing support virtual functions (others in viewpr.cpp)

void CView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
	ASSERT_VALID(pDC);
	UNUSED(pDC); // unused in release builds

	// Default to one page printing if doc length not known
	if (pInfo != NULL)
		pInfo->m_bContinuePrinting =
			(pInfo->GetMaxPage() != 0xffff || (pInfo->m_nCurPage == 1));
}

BOOL CView::OnPreparePrinting(CPrintInfo*)
{
	// Do print DC initialization here
	// override and call DoPreparePrinting (in viewprnt.cpp)

	return TRUE;
}

void CView::OnBeginPrinting(CDC* pDC, CPrintInfo*)
{
	ASSERT_VALID(pDC);
	UNUSED(pDC);     // unused in release builds

	// Do printing initialization here
}

void CView::OnEndPrinting(CDC* pDC, CPrintInfo*)
{
	ASSERT_VALID(pDC);
	UNUSED(pDC);     // unused in release builds

	// Do printing cleanup here
}

// OnEndPrintPreview is here for swap tuning reasons
//  (see viewprev.cpp for complete preview mode implementation)
void CView::OnEndPrintPreview(CDC* pDC, CPrintInfo* pInfo,
			POINT, CPreviewView* pView)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pView);

	if (pView->m_pPrintView != NULL)
		pView->m_pPrintView->OnEndPrinting(pDC, pInfo);

	CWnd* pMainWnd = GetParentFrame();
	if (DYNAMIC_DOWNCAST(CFrameWnd, pMainWnd) == NULL)
	{
		// if it's not a frame, we'll try the main window
		pMainWnd = AfxGetMainWnd();
	}

	CFrameWnd* pParent = STATIC_DOWNCAST(CFrameWnd, pMainWnd);
	ASSERT_VALID(pParent);

	// restore the old main window
	pParent->OnSetPreviewMode(FALSE, pView->m_pPreviewState);

	// Force active view back to old one
	pParent->SetActiveView(pView->m_pPreviewState->pViewActiveOld);
	if (pParent != GetParentFrame())
		OnActivateView(TRUE, this, this);   // re-activate view in real frame
	pView->DestroyWindow();     // destroy preview view
			// C++ object will be deleted in PostNcDestroy

	// restore main frame layout and idle message
	pParent->RecalcLayout();
	pParent->SendMessage(WM_SETMESSAGESTRING, (WPARAM)AFX_IDS_IDLEMESSAGE, 0L);
	pParent->UpdateWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CView diagnostics

#ifdef _DEBUG
void CView::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);

	if (m_pDocument != NULL)
		dc << "with document: " << m_pDocument;
	else
		dc << "with no document\n";
}

void CView::AssertValid() const
{
	CWnd::AssertValid();
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CCtrlView

BEGIN_MESSAGE_MAP(CCtrlView, CView)
	ON_WM_PAINT()
	ON_MESSAGE(WM_PRINTCLIENT, &CCtrlView::OnPrintClient)
END_MESSAGE_MAP()

CCtrlView::~CCtrlView()
{
}

CCtrlView::CCtrlView(LPCTSTR lpszClass, DWORD dwStyle)
{
	m_strClass = lpszClass;
	m_dwDefaultStyle = dwStyle;
}

BOOL CCtrlView::PreCreateWindow(CREATESTRUCT& cs)
{
	ASSERT(cs.lpszClass == NULL);
	cs.lpszClass = m_strClass;

	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));
	AfxDeferRegisterClass(AFX_WNDCOMMCTLSNEW_REG);

	// map default CView style to default style
	// WS_BORDER is insignificant
	if ((cs.style | WS_BORDER) == AFX_WS_DEFAULT_VIEW)
		cs.style = m_dwDefaultStyle & (cs.style | ~WS_BORDER);

	return CView::PreCreateWindow(cs);
}

void CCtrlView::OnDraw(CDC*)
{
	ASSERT(FALSE);
}

void CCtrlView::OnPaint()
{
	// this is done to avoid CView::OnPaint
	Default();
}

LRESULT CCtrlView::OnPrintClient(WPARAM /*wp*/, LPARAM /*lp*/)
{
	return Default();
}

/////////////////////////////////////////////////////////////////////////////
// CCtrlView diagnostics

#ifdef _DEBUG
void CCtrlView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
	dc << "\nClass Name: " << m_strClass;
	dc << "\nDefault Style: ";
	dc.DumpAsHex(m_dwDefaultStyle);
}

void CCtrlView::AssertValid() const
{
	CWnd::AssertValid();
	ASSERT(!m_strClass.IsEmpty());
}
#endif //_DEBUG


// IMPLEMENT_DYNAMIC for CView is in wincore.cpp for .OBJ granularity reasons

IMPLEMENT_DYNAMIC(CSplitterWnd, CWnd)   // for swap tuning
IMPLEMENT_DYNAMIC(CCtrlView, CView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewprnt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Printing Dialog

class CPrintingDialog : public CDialog
{
public:
	//{{AFX_DATA(CPrintingDialog)
	enum { IDD = AFX_IDD_PRINTDLG };
	//}}AFX_DATA
	CPrintingDialog::CPrintingDialog(CWnd* pParent)
		{
			Create(CPrintingDialog::IDD, pParent);      // modeless !
			_afxWinState->m_bUserAbort = FALSE;
		}
	virtual ~CPrintingDialog() { }

	virtual BOOL OnInitDialog();
	virtual void OnCancel();
};

BOOL CALLBACK _AfxAbortProc(HDC, int)
{
	_AFX_WIN_STATE* pWinState = _afxWinState;
	MSG msg;
	while (!pWinState->m_bUserAbort &&
		::PeekMessage(&msg, NULL, NULL, NULL, PM_NOREMOVE))
	{
		if( !AfxPumpMessage() )
			return FALSE;   // terminate if WM_QUIT received
	}
	return !pWinState->m_bUserAbort;
}

BOOL CPrintingDialog::OnInitDialog()
{
	SetWindowText(AfxGetAppName());
	CenterWindow();
	return CDialog::OnInitDialog();
}

void CPrintingDialog::OnCancel()
{
	_afxWinState->m_bUserAbort = TRUE;  // flag that user aborted print
	CDialog::OnCancel();
}

/////////////////////////////////////////////////////////////////////////////
// CView printing commands

BOOL CView::DoPreparePrinting(CPrintInfo* pInfo)
{
	ASSERT(pInfo != NULL);
	ASSERT(pInfo->m_pPD != NULL);

	if (pInfo->m_pPD->m_pd.nMinPage > pInfo->m_pPD->m_pd.nMaxPage)
		pInfo->m_pPD->m_pd.nMaxPage = pInfo->m_pPD->m_pd.nMinPage;

	// don't prompt the user if we're doing print preview, printing directly,
	// or printing via IPrint and have been instructed not to ask

	CWinApp* pApp = AfxGetApp();
	if (pInfo->m_bPreview || pInfo->m_bDirect ||
		(pInfo->m_bDocObject && !(pInfo->m_dwFlags & PRINTFLAG_PROMPTUSER)))
	{
		if (pInfo->m_pPD->m_pd.hDC == NULL)
		{
			// if no printer set then, get default printer DC and create DC without calling
			//   print dialog.
			if (!pApp->GetPrinterDeviceDefaults(&pInfo->m_pPD->m_pd))
			{
				// bring up dialog to alert the user they need to install a printer.
				if (!pInfo->m_bDocObject || (pInfo->m_dwFlags & PRINTFLAG_MAYBOTHERUSER))
					if (pApp->DoPrintDialog(pInfo->m_pPD) != IDOK)
						return FALSE;
			}

			if (pInfo->m_pPD->m_pd.hDC == NULL)
			{
				// call CreatePrinterDC if DC was not created by above
				if (pInfo->m_pPD->CreatePrinterDC() == NULL)
					return FALSE;
			}
		}

		// set up From and To page range from Min and Max
		pInfo->m_pPD->m_pd.nFromPage = (WORD)pInfo->GetMinPage();
		pInfo->m_pPD->m_pd.nToPage = (WORD)pInfo->GetMaxPage();
	}
	else
	{
		// otherwise, bring up the print dialog and allow user to change things
		// preset From-To range same as Min-Max range
		pInfo->m_pPD->m_pd.nFromPage = (WORD)pInfo->GetMinPage();
		pInfo->m_pPD->m_pd.nToPage = (WORD)pInfo->GetMaxPage();

		if (pApp->DoPrintDialog(pInfo->m_pPD) != IDOK)
			return FALSE;       // do not print
	}

	ASSERT(pInfo->m_pPD != NULL);
	ASSERT(pInfo->m_pPD->m_pd.hDC != NULL);
	if (pInfo->m_pPD->m_pd.hDC == NULL)
		return FALSE;

	pInfo->m_nNumPreviewPages = pApp->m_nNumPreviewPages;
	ENSURE(pInfo->m_strPageDesc.LoadString(AFX_IDS_PREVIEWPAGEDESC));
	return TRUE;
}

void CView::OnFilePrint()
{
	// get default print info
	CPrintInfo printInfo;
	ASSERT(printInfo.m_pPD != NULL);    // must be set

	if (LOWORD(GetCurrentMessage()->wParam) == ID_FILE_PRINT_DIRECT)
	{
		CCommandLineInfo* pCmdInfo = AfxGetApp()->m_pCmdInfo;

		if (pCmdInfo != NULL)
		{
			if (pCmdInfo->m_nShellCommand == CCommandLineInfo::FilePrintTo)
			{
				printInfo.m_pPD->m_pd.hDC = ::CreateDC(pCmdInfo->m_strDriverName,
					pCmdInfo->m_strPrinterName, pCmdInfo->m_strPortName, NULL);
				if (printInfo.m_pPD->m_pd.hDC == NULL)
				{
					AfxMessageBox(AFX_IDP_FAILED_TO_START_PRINT);
					return;
				}
			}
		}

		printInfo.m_bDirect = TRUE;
	}

	if (OnPreparePrinting(&printInfo))
	{
		// hDC must be set (did you remember to call DoPreparePrinting?)
		ASSERT(printInfo.m_pPD->m_pd.hDC != NULL);

		// gather file to print to if print-to-file selected
		CString strOutput;
		if (printInfo.m_pPD->m_pd.Flags & PD_PRINTTOFILE && !printInfo.m_bDocObject)
		{
			// construct CFileDialog for browsing
			CString strDef(MAKEINTRESOURCE(AFX_IDS_PRINTDEFAULTEXT));
			CString strPrintDef(MAKEINTRESOURCE(AFX_IDS_PRINTDEFAULT));
			CString strFilter(MAKEINTRESOURCE(AFX_IDS_PRINTFILTER));
			CString strCaption(MAKEINTRESOURCE(AFX_IDS_PRINTCAPTION));
			CFileDialog dlg(FALSE, strDef, strPrintDef,
				OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT, strFilter, NULL, 0);
			dlg.m_ofn.lpstrTitle = strCaption;

			if (dlg.DoModal() != IDOK)
				return;

			// set output device to resulting path name
			strOutput = dlg.GetPathName();
		}

		// set up document info and start the document printing process
		CString strTitle;
		CDocument* pDoc = GetDocument();
		if (pDoc != NULL)
			strTitle = pDoc->GetTitle();
		else
			EnsureParentFrame()->GetWindowText(strTitle);
		DOCINFO docInfo;
		memset(&docInfo, 0, sizeof(DOCINFO));
		docInfo.cbSize = sizeof(DOCINFO);
		docInfo.lpszDocName = strTitle;
		CString strPortName;
		if (strOutput.IsEmpty())
		{
			docInfo.lpszOutput = NULL;
			strPortName = printInfo.m_pPD->GetPortName();
		}
		else
		{
			docInfo.lpszOutput = strOutput;
			AfxGetFileTitle(strOutput,
				strPortName.GetBuffer(_MAX_PATH), _MAX_PATH);
		}

		// setup the printing DC
		CDC dcPrint;
		if (!printInfo.m_bDocObject)
		{
			dcPrint.Attach(printInfo.m_pPD->m_pd.hDC);  // attach printer dc
			dcPrint.m_bPrinting = TRUE;
		}
		OnBeginPrinting(&dcPrint, &printInfo);

		if (!printInfo.m_bDocObject)
			dcPrint.SetAbortProc(_AfxAbortProc);

		// disable main window while printing & init printing status dialog
		// Store the Handle of the Window in a temp so that it can be enabled 
		// once the printing is finished
		CWnd * hwndTemp = AfxGetMainWnd();
		hwndTemp->EnableWindow(FALSE);
		CPrintingDialog dlgPrintStatus(this);

		CString strTemp;
		dlgPrintStatus.SetDlgItemText(AFX_IDC_PRINT_DOCNAME, strTitle);
		dlgPrintStatus.SetDlgItemText(AFX_IDC_PRINT_PRINTERNAME,
			printInfo.m_pPD->GetDeviceName());
		dlgPrintStatus.SetDlgItemText(AFX_IDC_PRINT_PORTNAME, strPortName);
		dlgPrintStatus.ShowWindow(SW_SHOW);
		dlgPrintStatus.UpdateWindow();

		// start document printing process
		if (!printInfo.m_bDocObject)
		{
			printInfo.m_nJobNumber = dcPrint.StartDoc(&docInfo);
			if (printInfo.m_nJobNumber == SP_ERROR)
			{
				// enable main window before proceeding
				hwndTemp->EnableWindow(TRUE);

				// cleanup and show error message
				OnEndPrinting(&dcPrint, &printInfo);
				dlgPrintStatus.DestroyWindow();
				dcPrint.Detach();   // will be cleaned up by CPrintInfo destructor
				AfxMessageBox(AFX_IDP_FAILED_TO_START_PRINT);
				return;
			}
		}

		// Guarantee values are in the valid range
		UINT nEndPage = printInfo.GetToPage();
		UINT nStartPage = printInfo.GetFromPage();

		if (nEndPage < printInfo.GetMinPage())
			nEndPage = printInfo.GetMinPage();
		if (nEndPage > printInfo.GetMaxPage())
			nEndPage = printInfo.GetMaxPage();

		if (nStartPage < printInfo.GetMinPage())
			nStartPage = printInfo.GetMinPage();
		if (nStartPage > printInfo.GetMaxPage())
			nStartPage = printInfo.GetMaxPage();

		int nStep = (nEndPage >= nStartPage) ? 1 : -1;
		nEndPage = (nEndPage == 0xffff) ? 0xffff : nEndPage + nStep;

		VERIFY(strTemp.LoadString(AFX_IDS_PRINTPAGENUM));

		// If it's a doc object, we don't loop page-by-page
		// because doc objects don't support that kind of levity.

		BOOL bError = FALSE;
		if (printInfo.m_bDocObject)
		{
			OnPrepareDC(&dcPrint, &printInfo);
			OnPrint(&dcPrint, &printInfo);
		}
		else
		{
			// begin page printing loop
			for (printInfo.m_nCurPage = nStartPage;
				printInfo.m_nCurPage != nEndPage; printInfo.m_nCurPage += nStep)
			{
				OnPrepareDC(&dcPrint, &printInfo);

				// check for end of print
				if (!printInfo.m_bContinuePrinting)
					break;

				// write current page
				TCHAR szBuf[80];
				ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(szBuf, _countof(szBuf), _countof(szBuf) - 1, strTemp, printInfo.m_nCurPage));
				
				dlgPrintStatus.SetDlgItemText(AFX_IDC_PRINT_PAGENUM, szBuf);

				// set up drawing rect to entire page (in logical coordinates)
				printInfo.m_rectDraw.SetRect(0, 0,
					dcPrint.GetDeviceCaps(HORZRES),
					dcPrint.GetDeviceCaps(VERTRES));
				dcPrint.DPtoLP(&printInfo.m_rectDraw);

				// attempt to start the current page
				if (dcPrint.StartPage() < 0)
				{
					bError = TRUE;
					break;
				}

				// must call OnPrepareDC on newer versions of Windows because
				// StartPage now resets the device attributes.
				OnPrepareDC(&dcPrint, &printInfo);

				ASSERT(printInfo.m_bContinuePrinting);

				// page successfully started, so now render the page
				OnPrint(&dcPrint, &printInfo);
				if ((nStep > 0) && // pages are printed in ascending order
					(nEndPage > printInfo.GetMaxPage() + nStep)) // out off pages
				{
					// OnPrint may have set the last page
					// because the end of the document was reached.
					// The loop must not continue with the next iteration.
					nEndPage = printInfo.GetMaxPage() + nStep; 
				}

				// If the user restarts the job when it's spooling, all 
				// subsequent calls to EndPage returns < 0. The first time
				// GetLastError returns ERROR_PRINT_CANCELLED
				if (dcPrint.EndPage() < 0 && (GetLastError()!= ERROR_SUCCESS))
				{
					HANDLE hPrinter;
					if (!OpenPrinter(LPTSTR(printInfo.m_pPD->GetDeviceName().GetBuffer()), &hPrinter, NULL))
					{
						bError = TRUE;
						break;
					}

					DWORD cBytesNeeded;
					if(!GetJob(hPrinter,printInfo.m_nJobNumber,1,NULL,0,&cBytesNeeded))
					{
						if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
						{
						   bError = TRUE;
						   break;
						}
					}

					JOB_INFO_1 *pJobInfo; 					
					if((pJobInfo = (JOB_INFO_1 *)malloc(cBytesNeeded))== NULL)
					{
						bError = TRUE;
						break;
					}

					DWORD cBytesUsed;

					BOOL bRet = GetJob(hPrinter,printInfo.m_nJobNumber,1,LPBYTE(pJobInfo),cBytesNeeded,&cBytesUsed);

					DWORD dwJobStatus = pJobInfo->Status;

					free(pJobInfo);
					pJobInfo = NULL;

					// if job status is restart, just continue
					if(!bRet || !(dwJobStatus & JOB_STATUS_RESTART) )
					{
						bError = TRUE;
						break;
					}
				}

				if(!_AfxAbortProc(dcPrint.m_hDC, 0))
				{		
					bError = TRUE;
					break;
				}
			}
		}

		// cleanup document printing process
		if (!printInfo.m_bDocObject)
		{
			if (!bError)
				dcPrint.EndDoc();
			else
				dcPrint.AbortDoc();
		}

		hwndTemp->EnableWindow();    // enable main window

		OnEndPrinting(&dcPrint, &printInfo);    // clean up after printing
		dlgPrintStatus.DestroyWindow();

		dcPrint.Detach();   // will be cleaned up by CPrintInfo destructor
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPrintInfo helper structure

CPrintInfo::CPrintInfo()
{
	m_pPD = new CPrintDialog(FALSE, PD_ALLPAGES | PD_USEDEVMODECOPIES |
		PD_NOSELECTION);

	ASSERT(m_pPD->m_pd.hDC == NULL);

	SetMinPage(1);              // one based page numbers
	SetMaxPage(0xffff);         // unknown how many pages

	m_nCurPage = 1;
	m_nJobNumber = SP_ERROR;

	m_lpUserData = NULL;        // Initialize to no user data
	m_bPreview = FALSE;         // initialize to not preview
	m_bDirect = FALSE;          // initialize to not direct
	m_bDocObject = FALSE;       // initialize to not IPrint
	m_bContinuePrinting = TRUE; // Assume it is OK to print

	m_dwFlags = 0;
	m_nOffsetPage = 0;
}

CPrintInfo::~CPrintInfo()
{
	if (m_pPD != NULL && m_pPD->m_pd.hDC != NULL)
	{
		::DeleteDC(m_pPD->m_pd.hDC);
		m_pPD->m_pd.hDC = NULL;
	}
	delete m_pPD;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewrich.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CReObject

class CReObject : public _reobject
{
public:
	CReObject();
	CReObject(CRichEditCntrItem* pItem);
	~CReObject();
};

CReObject::CReObject()
{
	cbStruct = sizeof(REOBJECT);
	memset(&cbStruct+1, 0, sizeof(*this)-sizeof(cbStruct));
}

CReObject::CReObject(CRichEditCntrItem* pItem)
{
	ASSERT(pItem != NULL);
	cbStruct = sizeof(REOBJECT);

	pItem->GetClassID(&clsid);
	poleobj = pItem->m_lpObject;
	pstg = pItem->m_lpStorage;
	polesite = pItem->m_lpClientSite;
	ASSERT(poleobj != NULL);
	ASSERT(pstg != NULL);
	ASSERT(polesite != NULL);
	poleobj->AddRef();
	pstg->AddRef();
	polesite->AddRef();

	sizel.cx = sizel.cy = 0; // let richedit determine initial size
	dvaspect = pItem->GetDrawAspect();
	dwFlags = REO_RESIZABLE;
	dwUser = 0;
}

CReObject::~CReObject()
{
	if (poleobj != NULL)
		poleobj->Release();
	if (pstg != NULL)
		pstg->Release();
	if (polesite != NULL)
		polesite->Release();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView

UINT _afxMsgFindReplace2 = ::RegisterWindowMessage(FINDMSGSTRING);

BEGIN_MESSAGE_MAP(CRichEditView, CCtrlView)
	//{{AFX_MSG_MAP(CRichEditView)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, &CRichEditView::OnUpdateNeedSel)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, &CRichEditView::OnUpdateNeedClip)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, &CRichEditView::OnUpdateNeedText)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REPEAT, &CRichEditView::OnUpdateNeedFind)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, &CRichEditView::OnUpdateEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, &CRichEditView::OnUpdateEditRedo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_SPECIAL, &CRichEditView::OnUpdateEditPasteSpecial)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_PROPERTIES, &CRichEditView::OnUpdateEditProperties)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, &CRichEditView::OnUpdateNeedSel)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, &CRichEditView::OnUpdateNeedSel)
	ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, &CRichEditView::OnUpdateNeedText)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REPLACE, &CRichEditView::OnUpdateNeedText)
	ON_COMMAND(ID_EDIT_CUT, &CRichEditView::OnEditCut)
	ON_COMMAND(ID_EDIT_COPY, &CRichEditView::OnEditCopy)
	ON_COMMAND(ID_EDIT_PASTE, &CRichEditView::OnEditPaste)
	ON_COMMAND(ID_EDIT_CLEAR, &CRichEditView::OnEditClear)
	ON_COMMAND(ID_EDIT_UNDO, &CRichEditView::OnEditUndo)
	ON_COMMAND(ID_EDIT_REDO, &CRichEditView::OnEditRedo)
	ON_COMMAND(ID_EDIT_SELECT_ALL, &CRichEditView::OnEditSelectAll)
	ON_COMMAND(ID_EDIT_FIND, &CRichEditView::OnEditFind)
	ON_COMMAND(ID_EDIT_REPLACE, &CRichEditView::OnEditReplace)
	ON_COMMAND(ID_EDIT_REPEAT, &CRichEditView::OnEditRepeat)
	ON_COMMAND(ID_EDIT_PASTE_SPECIAL, &CRichEditView::OnEditPasteSpecial)
	ON_COMMAND(ID_OLE_EDIT_PROPERTIES, &CRichEditView::OnEditProperties)
	ON_COMMAND(ID_OLE_INSERT_NEW, &CRichEditView::OnInsertObject)
	ON_COMMAND(ID_FORMAT_FONT, &CRichEditView::OnFormatFont)
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_NOTIFY_REFLECT(EN_SELCHANGE, &CRichEditView::OnSelChange)
	ON_REGISTERED_MESSAGE(_afxMsgFindReplace2, &CRichEditView::OnFindReplaceCmd)
END_MESSAGE_MAP()

// richedit buffer limit -- let's set it at 16M
AFX_DATADEF ULONG CRichEditView::lMaxSize = 0xffffff;

/////////////////////////////////////////////////////////////////////////////
// CRichEditView construction/destruction

CRichEditView::CRichEditView() : CCtrlView(RICHEDIT_CLASS,
	AFX_WS_DEFAULT_VIEW | WS_HSCROLL | WS_VSCROLL | ES_AUTOHSCROLL |
	ES_AUTOVSCROLL | ES_MULTILINE | ES_NOHIDESEL | ES_SAVESEL | 
	ES_SELECTIONBAR)
{
	m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
	m_lpRichEditOle = NULL;
	m_nBulletIndent = 720; // 1/2 inch
	m_nWordWrap = WrapToWindow;
	m_nPasteType = 0;
	SetPaperSize(CSize(8*1440+720, 11*1440));
	SetMargins(CRect(0,0,0,0));
	m_charformat.cbSize = sizeof(CHARFORMAT2);
	m_paraformat.cbSize = sizeof(PARAFORMAT2);
	m_bFirstSearch = FALSE;
	m_bChangeFindRange = FALSE;
}

BOOL CRichEditView::PreCreateWindow(CREATESTRUCT& cs)
{
	if (!AfxInitRichEdit2())
		return FALSE;
	CCtrlView::PreCreateWindow(cs);
	cs.lpszName = _T("");

	cs.cx = cs.cy = 100; // necessary to avoid bug with ES_SELECTIONBAR and zero for cx and cy
	cs.style |= WS_CLIPSIBLINGS;

	return TRUE;
}

int CRichEditView::OnCreate(LPCREATESTRUCT lpcs)
{
	if (CCtrlView::OnCreate(lpcs) != 0)
		return -1;
	GetRichEditCtrl().LimitText(lMaxSize);
	GetRichEditCtrl().SetEventMask(ENM_SELCHANGE | ENM_CHANGE | ENM_SCROLL);
	VERIFY(GetRichEditCtrl().SetOLECallback(&m_xRichEditOleCallback));
	m_lpRichEditOle = GetRichEditCtrl().GetIRichEditOle();
	DragAcceptFiles();
	GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
	WrapChanged();
	ASSERT(m_lpRichEditOle != NULL);
	return 0;
}

void CRichEditView::OnInitialUpdate()
{
	CCtrlView::OnInitialUpdate();
	m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView document like functions

void CRichEditView::DeleteContents()
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);
	SetWindowText(_T(""));
	GetRichEditCtrl().EmptyUndoBuffer();
	m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
	ASSERT_VALID(this);
}

void CRichEditView::WrapChanged()
{
	CWaitCursor wait;
	CRichEditCtrl& ctrl = GetRichEditCtrl();
	if (m_nWordWrap == WrapNone)
		ctrl.SetTargetDevice(NULL, 1);
	else if (m_nWordWrap == WrapToWindow)
		ctrl.SetTargetDevice(NULL, 0);
	else if (m_nWordWrap == WrapToTargetDevice) // wrap to ruler
	{
		AfxGetApp()->CreatePrinterDC(m_dcTarget);
		if (m_dcTarget.m_hDC == NULL)
			m_dcTarget.CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
		ctrl.SetTargetDevice(m_dcTarget, GetPrintWidth());
	}
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView serialization support

class _afxRichEditCookie
{
public:
	CArchive& m_ar;
	DWORD m_dwError;
	_afxRichEditCookie(CArchive& ar) : m_ar(ar) {m_dwError=0;}
};

void CRichEditView::Serialize(CArchive& ar)
	// Read and write CRichEditView object to archive, with length prefix.
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);
	Stream(ar, FALSE);
	ASSERT_VALID(this);
}

void CRichEditView::Stream(CArchive& ar, BOOL bSelection)
{
	EDITSTREAM es = {0, 0, EditStreamCallBack};
	_afxRichEditCookie cookie(ar);
	es.dwCookie = (DWORD_PTR)&cookie;
	CRichEditDoc *pDocument=GetDocument();
	ENSURE(pDocument);
	int nFormat = pDocument->GetStreamFormat();
	if (bSelection)
		nFormat |= SFF_SELECTION;
	if (ar.IsStoring())
		GetRichEditCtrl().StreamOut(nFormat, es);
	else
	{
		GetRichEditCtrl().StreamIn(nFormat, es);
		Invalidate();
	}
	if (cookie.m_dwError != 0)
		AfxThrowFileException(cookie.m_dwError);
}

// return 0 for no error, otherwise return error code
DWORD CALLBACK CRichEditView::EditStreamCallBack(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
	_afxRichEditCookie* pCookie = (_afxRichEditCookie*)dwCookie;
	CArchive& ar = pCookie->m_ar;
	ar.Flush();
	DWORD dw = 0;
	*pcb = cb;
	TRY
	{
		if (ar.IsStoring())
			ar.GetFile()->Write(pbBuff, cb);
		else
			*pcb = ar.GetFile()->Read(pbBuff, cb);
	}
	CATCH(CFileException, e)
	{
		*pcb = 0;
		pCookie->m_dwError = (DWORD)e->m_cause;
		dw = 1;
		DELETE_EXCEPTION(e);
	}
	AND_CATCH_ALL(e)
	{
		*pcb = 0;
		pCookie->m_dwError = (DWORD)CFileException::genericException;
		dw = 1;
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL
	return dw;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView Printing support

void CRichEditView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo*)
{
	ASSERT_VALID(this);
//  ASSERT_VALID(pDC);
	// initialize page start vector
	ASSERT(m_aPageStart.GetSize() == 0);
	m_aPageStart.Add(0);
	ASSERT(m_aPageStart.GetSize() > 0);
	GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

	ASSERT_VALID(this);
}

BOOL CRichEditView::PaginateTo(CDC* pDC, CPrintInfo* pInfo)
	// attempts pagination to pInfo->m_nCurPage, TRUE == success
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CRect rectSave = pInfo->m_rectDraw;
	UINT nPageSave = pInfo->m_nCurPage;
	ASSERT(nPageSave > 1);
	ASSERT(nPageSave >= (UINT)m_aPageStart.GetSize());
	VERIFY(pDC->SaveDC() != 0);
	pDC->IntersectClipRect(0, 0, 0, 0);
	pInfo->m_nCurPage = (int)m_aPageStart.GetSize();
	while (pInfo->m_nCurPage < nPageSave)
	{
		ASSERT(pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize());
		OnPrepareDC(pDC, pInfo);
		ASSERT(pInfo->m_bContinuePrinting);
		pInfo->m_rectDraw.SetRect(0, 0,
			pDC->GetDeviceCaps(HORZRES), pDC->GetDeviceCaps(VERTRES));
		pDC->DPtoLP(&pInfo->m_rectDraw);
		OnPrint(pDC, pInfo);
		if (pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize())
			break;
		++pInfo->m_nCurPage;
	}
	BOOL bResult = pInfo->m_nCurPage == nPageSave;
	pDC->RestoreDC(-1);
	pInfo->m_nCurPage = nPageSave;
	pInfo->m_rectDraw = rectSave;
	ASSERT_VALID(this);
	return bResult;
}

void CRichEditView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT(pInfo != NULL);  // overriding OnPaint -- never get this.

	pDC->SetMapMode(MM_TEXT);

	if (pInfo->m_nCurPage > (UINT)m_aPageStart.GetSize() &&
		!PaginateTo(pDC, pInfo))
	{
		// can't paginate to that page, thus cannot print it.
		pInfo->m_bContinuePrinting = FALSE;
	}
	ASSERT_VALID(this);
}

long CRichEditView::PrintPage(CDC* pDC, long nIndexStart, long nIndexStop)
	// worker function for laying out text in a rectangle.
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	FORMATRANGE fr;

	// offset by printing offset
	pDC->SetViewportOrg(-pDC->GetDeviceCaps(PHYSICALOFFSETX),
		-pDC->GetDeviceCaps(PHYSICALOFFSETY));
	// adjust DC because richedit doesn't do things like MFC
	if (::GetDeviceCaps(pDC->m_hDC, TECHNOLOGY) != DT_METAFILE && pDC->m_hAttribDC != NULL)
	{
		::ScaleWindowExtEx(pDC->m_hDC,
			::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX),
			::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSX),
			::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY),
			::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSY), NULL);
	}

	fr.hdcTarget = pDC->m_hAttribDC;
	fr.hdc = pDC->m_hDC;
	fr.rcPage = GetPageRect();
	fr.rc = GetPrintRect();

	fr.chrg.cpMin = nIndexStart;
	fr.chrg.cpMax = nIndexStop;
	long lRes = GetRichEditCtrl().FormatRange(&fr,TRUE);
	return lRes;
}

long CRichEditView::PrintInsideRect(CDC* pDC, RECT& rectLayout,
	long nIndexStart, long nIndexStop, BOOL bOutput)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	FORMATRANGE fr;

	// adjust DC because richedit doesn't do things like MFC
	if (::GetDeviceCaps(pDC->m_hDC, TECHNOLOGY) != DT_METAFILE && pDC->m_hAttribDC != NULL)
	{
		::ScaleWindowExtEx(pDC->m_hDC,
			::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX),
			::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSX),
			::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY),
			::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSY), NULL);
	}

	fr.hdcTarget = pDC->m_hAttribDC;
	fr.hdc = pDC->m_hDC;
	// convert rect to twips
	fr.rcPage = rectLayout;
	fr.rc = rectLayout;

	fr.chrg.cpMin = nIndexStart;
	fr.chrg.cpMax = nIndexStop;
	GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache
	// if bOutput is FALSE, we only measure
	long lres = GetRichEditCtrl().FormatRange(&fr, bOutput);
	GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

	rectLayout = fr.rc;
	return lres;
}

void CRichEditView::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT(pInfo != NULL);
	ASSERT(pInfo->m_bContinuePrinting);

	UINT nPage = pInfo->m_nCurPage;
	ASSERT(nPage <= (UINT)m_aPageStart.GetSize());
	long nIndex = (long) m_aPageStart[nPage-1];

	// print as much as possible in the current page.
	nIndex = PrintPage(pDC, nIndex, 0xFFFFFFFF);

	if (nIndex >= GetTextLengthEx(GTL_PRECISE | GTL_NUMCHARS))
	{
		TRACE(traceAppMsg, 0, "End of Document\n");
		pInfo->SetMaxPage(nPage);
	}

	// update pagination information for page just printed
	if (nPage == (UINT)m_aPageStart.GetSize())
	{
		if (nIndex < GetTextLengthEx(GTL_PRECISE | GTL_NUMCHARS))
			m_aPageStart.Add(nIndex);
	}
	else
	{
		ASSERT(nPage+1 <= (UINT)m_aPageStart.GetSize());
		ASSERT(nIndex == (long)m_aPageStart[nPage+1-1]);
	}
}


void CRichEditView::OnEndPrinting(CDC*, CPrintInfo*)
{
	ASSERT_VALID(this);
	GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache
	m_aPageStart.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView::XRichEditOleCallback

BEGIN_INTERFACE_MAP(CRichEditView, CCtrlView)
	// we use IID_IUnknown because richedit doesn't define an IID
	INTERFACE_PART(CRichEditView, IID_IUnknown, RichEditOleCallback)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CRichEditView::XRichEditOleCallback::AddRef()
{
	METHOD_PROLOGUE_EX_(CRichEditView, RichEditOleCallback)
	return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) CRichEditView::XRichEditOleCallback::Release()
{
	METHOD_PROLOGUE_EX_(CRichEditView, RichEditOleCallback)
	return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(CRichEditView, RichEditOleCallback)
	return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::GetNewStorage(LPSTORAGE* ppstg)
{
	METHOD_PROLOGUE_EX_(CRichEditView, RichEditOleCallback)

	// Create a flat storage and steal it from the client item
	// the client item is only used for creating the storage
	COleClientItem item;
	item.GetItemStorageFlat();
	*ppstg = item.m_lpStorage;
	HRESULT hRes = E_OUTOFMEMORY;
	if (item.m_lpStorage != NULL)
	{
		item.m_lpStorage = NULL;
		hRes = S_OK;
	}
	pThis->GetDocument()->InvalidateObjectCache();
	return hRes;
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::GetInPlaceContext(
	LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
	LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
	METHOD_PROLOGUE_EX(CRichEditView, RichEditOleCallback)
	return pThis->GetWindowContext(lplpFrame, lplpDoc, lpFrameInfo);
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::ShowContainerUI(BOOL fShow)
{
	METHOD_PROLOGUE_EX(CRichEditView, RichEditOleCallback)
	return pThis->ShowContainerUI(fShow);
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::QueryInsertObject(
	LPCLSID /*lpclsid*/, LPSTORAGE /*pstg*/, LONG /*cp*/)
{
	METHOD_PROLOGUE_EX(CRichEditView, RichEditOleCallback)
	pThis->GetDocument()->InvalidateObjectCache();
	return S_OK;
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::DeleteObject(LPOLEOBJECT /*lpoleobj*/)
{
	METHOD_PROLOGUE_EX_(CRichEditView, RichEditOleCallback)
	pThis->GetDocument()->InvalidateObjectCache();
	return S_OK;
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::QueryAcceptData(
	LPDATAOBJECT lpdataobj, CLIPFORMAT* lpcfFormat, DWORD reco,
	BOOL fReally, HGLOBAL hMetaPict)
{
	METHOD_PROLOGUE_EX(CRichEditView, RichEditOleCallback)
	return pThis->QueryAcceptData(lpdataobj, lpcfFormat, reco,
		fReally, hMetaPict);
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::ContextSensitiveHelp(BOOL /*fEnterMode*/)
{
	return E_NOTIMPL;
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::GetClipboardData(
	CHARRANGE* lpchrg, DWORD reco, LPDATAOBJECT* lplpdataobj)
{
	METHOD_PROLOGUE_EX(CRichEditView, RichEditOleCallback)
	LPDATAOBJECT lpOrigDataObject = NULL;

	// get richedit's data object
	if (FAILED(pThis->m_lpRichEditOle->GetClipboardData(lpchrg, reco,
		&lpOrigDataObject)))
	{
		return E_NOTIMPL;
	}

	// allow changes
	HRESULT hRes = pThis->GetClipboardData(lpchrg, reco, lpOrigDataObject,
		lplpdataobj);

	// if changed then free original object
	if (SUCCEEDED(hRes))
	{
		if (lpOrigDataObject!=NULL)
			lpOrigDataObject->Release();
		return hRes;
	}
	else
	{
		// use richedit's data object
		*lplpdataobj = lpOrigDataObject;
		return S_OK;
	}
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::GetDragDropEffect(
	BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
	if (!fDrag) // allowable dest effects
	{
		DWORD dwEffect;
		// check for force link
		if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
			dwEffect = DROPEFFECT_LINK;
		// check for force copy
		else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
			dwEffect = DROPEFFECT_COPY;
		// check for force move
		else if ((grfKeyState & MK_ALT) == MK_ALT)
			dwEffect = DROPEFFECT_MOVE;
		// default -- recommended action is move
		else
			dwEffect = DROPEFFECT_MOVE;
		if (dwEffect & *pdwEffect) // make sure allowed type
			*pdwEffect = dwEffect;
	}
	return S_OK;
}

STDMETHODIMP CRichEditView::XRichEditOleCallback::GetContextMenu(
	WORD seltype, LPOLEOBJECT lpoleobj, CHARRANGE* lpchrg,
	HMENU* lphmenu)
{
	METHOD_PROLOGUE_EX(CRichEditView, RichEditOleCallback)
	HMENU hMenu = pThis->GetContextMenu(seltype, lpoleobj, lpchrg);
	if (hMenu == NULL)
		return E_NOTIMPL;
	*lphmenu = hMenu;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView command helpers

void CRichEditView::OnCharEffect(DWORD dwMask, DWORD dwEffect)
{
	GetCharFormatSelection();
	if (m_charformat.dwMask & dwMask) // selection is all the same
		m_charformat.dwEffects ^= dwEffect;
	else
		m_charformat.dwEffects |= dwEffect;
	m_charformat.dwMask = dwMask;
	SetCharFormat(m_charformat);
}

void CRichEditView::OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect)
{
	GetCharFormatSelection();
	pCmdUI->SetCheck((m_charformat.dwMask & dwMask) ?
		((m_charformat.dwEffects & dwEffect) ? 1 : 0) : 2);
}

void CRichEditView::OnParaAlign(WORD wAlign)
{
	GetParaFormatSelection();
	m_paraformat.dwMask = PFM_ALIGNMENT;
	m_paraformat.wAlignment = wAlign;
	SetParaFormat(m_paraformat);
}

void CRichEditView::OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign)
{
	GetParaFormatSelection();
	// disable if no word wrap since alignment is meaningless
	pCmdUI->Enable( (m_nWordWrap == WrapNone) ?
		FALSE : TRUE);
	pCmdUI->SetCheck( (m_paraformat.dwMask & PFM_ALIGNMENT) ?
		((m_paraformat.wAlignment == wAlign) ? 1 : 0) : 2);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView commands

void CRichEditView::OnUpdateNeedSel(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	long nStartChar, nEndChar;
	GetRichEditCtrl().GetSel(nStartChar, nEndChar);
	pCmdUI->Enable(nStartChar != nEndChar);
	ASSERT_VALID(this);
}

void CRichEditView::OnUpdateNeedClip(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	pCmdUI->Enable(CanPaste());
}

void CRichEditView::OnUpdateNeedText(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	pCmdUI->Enable(GetTextLength() != 0);
}

void CRichEditView::OnUpdateNeedFind(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	pCmdUI->Enable(GetTextLength() != 0 &&
		!pEditState->strFind.IsEmpty());
}

void CRichEditView::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	pCmdUI->Enable(GetRichEditCtrl().CanUndo());
}

void CRichEditView::OnUpdateEditRedo(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	pCmdUI->Enable(GetRichEditCtrl().CanRedo());
}

void CRichEditView::OnEditCut()
{
	ASSERT_VALID(this);
	GetRichEditCtrl().Cut();
}

void CRichEditView::OnEditCopy()
{
	ASSERT_VALID(this);
	GetRichEditCtrl().Copy();
}

void CRichEditView::OnEditPaste()
{
	ASSERT_VALID(this);
	m_nPasteType = 0;
	GetRichEditCtrl().Paste();
}

void CRichEditView::OnEditClear()
{
	ASSERT_VALID(this);
	GetRichEditCtrl().Clear();
}

void CRichEditView::OnEditUndo()
{
	ASSERT_VALID(this);
	GetRichEditCtrl().Undo();
	m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

void CRichEditView::OnEditRedo()
{
	ASSERT_VALID(this);
	GetRichEditCtrl().Redo();
	m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

void CRichEditView::OnEditSelectAll()
{
	ASSERT_VALID(this);
	GetRichEditCtrl().SetSel(0, -1);
}

void CRichEditView::OnEditFind()
{
	ASSERT_VALID(this);
	OnEditFindReplace(TRUE);
}

void CRichEditView::OnEditReplace()
{
	ASSERT_VALID(this);
	OnEditFindReplace(FALSE);
}

void CRichEditView::OnEditRepeat()
{
	ASSERT_VALID(this);
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	if (!FindText(pEditState))
		TextNotFound(pEditState->strFind);
}

void CRichEditView::OnCancelEditCntr()
{
	m_lpRichEditOle->InPlaceDeactivate();
}

void CRichEditView::OnInsertObject()
{
	// Invoke the standard Insert Object dialog box to obtain information
	COleInsertDialog dlg;
	if (dlg.DoModal() != IDOK)
		return;

	CWaitCursor wait;

	CRichEditCntrItem* pItem = NULL;
	TRY
	{
		// create item from dialog results
		pItem = GetDocument()->CreateClientItem();
		pItem->m_bLock = TRUE;
		if (!dlg.CreateItem(pItem))
		{
			pItem->m_bLock = FALSE;
			AfxThrowMemoryException();  // any exception will do
		}

		HRESULT hr = InsertItem(pItem);
		pItem->UpdateItemType();

		pItem->m_bLock = FALSE;

		if (hr != NOERROR)
			AfxThrowOleException(hr);

		// if insert new object -- initially show the object
		if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE);
	}
	END_CATCH
}

void CRichEditView::OnSelChange(NMHDR* pNMHDR, LRESULT* pResult)
{
	ASSERT(pNMHDR->code == EN_SELCHANGE);
	UNUSED(pNMHDR); // not used in release builds

	m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
	*pResult = 0;
}

void CRichEditView::OnDestroy()
{
	// close Find/Replace dialog if this is the last CRichEditView
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	if (pEditState && pEditState->pFindReplaceDlg)
	{
		CWinApp* pApp = AfxGetApp();

		// no doc manager - no templates
		if (pApp->m_pDocManager != NULL)
		{
			// walk all templates
			CDocTemplate* pTemplate;
			POSITION pos = pApp->m_pDocManager->GetFirstDocTemplatePosition();
			while (pos != NULL)
			{
				pTemplate = pApp->m_pDocManager->GetNextDocTemplate(pos);
				ASSERT(pTemplate);

				// walk all documents in the template
				POSITION pos2 = pTemplate->GetFirstDocPosition();
				while (pos2)
				{
					CDocument* pDoc = pTemplate->GetNextDoc(pos2);
					ASSERT(pDoc);

					// walk all views in the document
					POSITION pos3 = pDoc->GetFirstViewPosition();
					while (pos3 != NULL)
					{
						CView* pView = pDoc->GetNextView(pos3);
						ASSERT(pView);
						// if we find another CRichEditView, skip code that closes find dialog
						if (pView->IsKindOf(RUNTIME_CLASS(CRichEditView)) && pView != this && ::IsWindow(pView->GetSafeHwnd()))
							goto FoundRichEditView;
					}
				}
			}
		}

		if (::IsWindow(pEditState->pFindReplaceDlg->m_hWnd))
			pEditState->pFindReplaceDlg->SendMessage(WM_CLOSE);
		pEditState->pFindReplaceDlg = NULL;
	}

FoundRichEditView:

	if (m_lpRichEditOle != NULL)
		m_lpRichEditOle->Release();
	CCtrlView::OnDestroy();
}

void CRichEditView::OnEditProperties()
{
	ASSERT(m_lpRichEditOle != NULL);
	CRichEditCntrItem* pSelection = GetSelectedItem();

	// make sure item is in sync with richedit's item
	CReObject reo;
	m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
		REO_GETOBJ_NO_INTERFACES);

	pSelection->SyncToRichEditObject(reo);
	COlePropertiesDialog dlg(pSelection);
	dlg.DoModal();
}

void CRichEditView::OnUpdateEditProperties(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(GetSelectedItem() != NULL);
}

void CRichEditView::OnCharBold()
{
	OnCharEffect(CFM_BOLD, CFE_BOLD);
}

void CRichEditView::OnUpdateCharBold(CCmdUI* pCmdUI)
{
	OnUpdateCharEffect(pCmdUI, CFM_BOLD, CFE_BOLD);
}

void CRichEditView::OnCharItalic()
{
	OnCharEffect(CFM_ITALIC, CFE_ITALIC);
}

void CRichEditView::OnUpdateCharItalic(CCmdUI* pCmdUI)
{
	OnUpdateCharEffect(pCmdUI, CFM_ITALIC, CFE_ITALIC);
}

void CRichEditView::OnCharUnderline()
{
	OnCharEffect(CFM_UNDERLINE, CFE_UNDERLINE);
}

void CRichEditView::OnUpdateCharUnderline(CCmdUI* pCmdUI)
{
	OnUpdateCharEffect(pCmdUI, CFM_UNDERLINE, CFE_UNDERLINE);
}

void CRichEditView::OnParaCenter()
{
	OnParaAlign(PFA_CENTER);
}

void CRichEditView::OnUpdateParaCenter(CCmdUI* pCmdUI)
{
	OnUpdateParaAlign(pCmdUI, PFA_CENTER);
}

void CRichEditView::OnParaLeft()
{
	OnParaAlign(PFA_LEFT);
}

void CRichEditView::OnUpdateParaLeft(CCmdUI* pCmdUI)
{
	OnUpdateParaAlign(pCmdUI, PFA_LEFT);
}

void CRichEditView::OnParaRight()
{
	OnParaAlign(PFA_RIGHT);
}

void CRichEditView::OnUpdateParaRight(CCmdUI* pCmdUI)
{
	OnUpdateParaAlign(pCmdUI, PFA_RIGHT);
}

void CRichEditView::OnBullet()
{
	GetParaFormatSelection();
	if (m_paraformat.dwMask & PFM_NUMBERING && m_paraformat.wNumbering == PFN_BULLET)
	{
		m_paraformat.wNumbering = 0;
		m_paraformat.dxOffset = 0;
		m_paraformat.dxStartIndent = 0;
		m_paraformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;
	}
	else
	{
		m_paraformat.wNumbering = PFN_BULLET;
		m_paraformat.dwMask = PFM_NUMBERING;
		if (m_paraformat.dxOffset == 0)
		{
			m_paraformat.dxOffset = m_nBulletIndent;
			m_paraformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;
		}
	}
	SetParaFormat(m_paraformat);
}

void CRichEditView::OnUpdateBullet(CCmdUI* pCmdUI)
{
	GetParaFormatSelection();
	pCmdUI->SetCheck( (m_paraformat.dwMask & PFM_NUMBERING) ? ((m_paraformat.wNumbering & PFN_BULLET) ? 1 : 0) : 2);
}

void CRichEditView::OnFormatFont()
{
	GetCharFormatSelection();
	CFontDialog dlg(m_charformat, CF_BOTH|CF_NOOEMFONTS);
	if (dlg.DoModal() == IDOK)
	{
		dlg.GetCharFormat(m_charformat);
		SetCharFormat(m_charformat);
	}
}

void CRichEditView::OnColorPick(COLORREF cr)
{
	GetCharFormatSelection();
	m_charformat.dwMask = CFM_COLOR;
	m_charformat.dwEffects = NULL;
	m_charformat.crTextColor = cr;
	SetCharFormat(m_charformat);
}

void CRichEditView::OnColorDefault()
{
	GetCharFormatSelection();
	m_charformat.dwMask = CFM_COLOR;
	m_charformat.dwEffects = CFE_AUTOCOLOR;
	SetCharFormat(m_charformat);
}

void CRichEditView::OnEditPasteSpecial()
{
	COlePasteSpecialDialog dlg;
	dlg.AddStandardFormats();
	dlg.AddFormat(_oleData.cfRichTextFormat, TYMED_HGLOBAL, AFX_IDS_RTF_FORMAT, FALSE, FALSE);
	dlg.AddFormat(CF_TEXT, TYMED_HGLOBAL, AFX_IDS_TEXT_FORMAT, FALSE, FALSE);

	if (dlg.DoModal() != IDOK)
		return;

	DVASPECT dv = dlg.GetDrawAspect();
	HMETAFILE hMF = (HMETAFILE)dlg.GetIconicMetafile();
	CLIPFORMAT cf =
		dlg.m_ps.arrPasteEntries[dlg.m_ps.nSelectedIndex].fmtetc.cfFormat;

	CWaitCursor wait;
	SetCapture();

	// we set the target type so that QueryAcceptData know what to paste
	m_nPasteType = dlg.GetSelectionType();
	GetRichEditCtrl().PasteSpecial(cf, dv, hMF);
	m_nPasteType = 0;

	ReleaseCapture();
}

void CRichEditView::OnUpdateEditPasteSpecial(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(CanPaste());
}

void CRichEditView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_F10 && GetKeyState(VK_SHIFT) < 0)
	{
		CRect rect;
		GetClientRect(rect);
		CPoint pt = rect.CenterPoint();
		SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
	}
	else
		CCtrlView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CRichEditView::OnDropFiles(HDROP hDropInfo)
{
	TCHAR szFileName[_MAX_PATH];
	UINT nFileCount = ::DragQueryFile(hDropInfo, 0xFFFFFFFF, NULL, 0);
	ASSERT(nFileCount != 0);
	CHARRANGE cr;
	GetRichEditCtrl().GetSel(cr);
	int nMin = cr.cpMin;
	for (UINT i=0;i<nFileCount;i++)
	{
		::DragQueryFile(hDropInfo, i, szFileName, _MAX_PATH);
		InsertFileAsObject(szFileName);
		GetRichEditCtrl().GetSel(cr);
		cr.cpMin = cr.cpMax;
		GetRichEditCtrl().SetSel(cr);
		UpdateWindow();
	}
	cr.cpMin = nMin;
	GetRichEditCtrl().SetSel(cr);
	::DragFinish(hDropInfo);
}

void CRichEditView::OnDevModeChange(_In_z_ LPTSTR /*lpDeviceName*/)
{
	// WM_DEVMODECHANGE forwarded by the main window of the app
	CDC dc;
	AfxGetApp()->CreatePrinterDC(dc);
	OnPrinterChanged(dc);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView attributes

BOOL AFX_CDECL CRichEditView::IsRichEditFormat(CLIPFORMAT cf)
{
	return ((cf == _oleData.cfRichTextFormat) ||
		(cf == _oleData.cfRichTextAndObjects) || (cf == CF_TEXT));
}

BOOL CRichEditView::CanPaste() const
{
	return (CountClipboardFormats() != 0) &&
		(IsClipboardFormatAvailable(CF_TEXT) ||
		IsClipboardFormatAvailable(_oleData.cfRichTextFormat) ||
		IsClipboardFormatAvailable(_oleData.cfEmbedSource) ||
		IsClipboardFormatAvailable(_oleData.cfEmbeddedObject) ||
		IsClipboardFormatAvailable(_oleData.cfFileName) ||
		IsClipboardFormatAvailable(_oleData.cfFileNameW) ||
		IsClipboardFormatAvailable(CF_METAFILEPICT) ||
		IsClipboardFormatAvailable(CF_DIB) ||
		IsClipboardFormatAvailable(CF_BITMAP) ||
		GetRichEditCtrl().CanPaste());
}

CHARFORMAT2& CRichEditView::GetCharFormatSelection()
{
	if (m_bSyncCharFormat)
	{
		GetRichEditCtrl().GetSelectionCharFormat(m_charformat);
		m_bSyncCharFormat = FALSE;
	}
	return m_charformat;
}

PARAFORMAT2& CRichEditView::GetParaFormatSelection()
{
	if (m_bSyncParaFormat)
	{
		GetRichEditCtrl().GetParaFormat(m_paraformat);
		m_bSyncParaFormat = FALSE;
	}
	return m_paraformat;
}

void CRichEditView::SetCharFormat(CHARFORMAT2 cf)
{
	CWaitCursor wait;
	GetRichEditCtrl().SetSelectionCharFormat(cf);
	m_bSyncCharFormat = TRUE;
}

BOOL CRichEditView::SetParaFormat(PARAFORMAT2& pf)
{
	BOOL bRetVal;
	CWaitCursor wait;
	bRetVal = GetRichEditCtrl().SetParaFormat(pf);
	m_bSyncParaFormat = TRUE;
	return bRetVal;
}

CRichEditCntrItem* CRichEditView::GetSelectedItem() const
{
	ASSERT(m_lpRichEditOle != NULL);
	CRichEditDoc* pDoc = GetDocument();
	CRichEditCntrItem* pItem = NULL;

	CReObject reo;
	HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
		REO_GETOBJ_ALL_INTERFACES);
	//reo's interfaces are all in UNICODE
	if (GetScode(hr) == S_OK)
	{
		pItem = pDoc->LookupItem(reo.poleobj);
		if (pItem == NULL)
			pItem = pDoc->CreateClientItem(&reo);
		ASSERT(pItem != NULL);
	}
	return pItem;
}

CRichEditCntrItem* CRichEditView::GetInPlaceActiveItem() const
{
	ASSERT(m_lpRichEditOle != NULL);
	CRichEditDoc* pDoc = GetDocument();
	CRichEditCntrItem* pItem = NULL;

	CReObject reo;
	HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
		REO_GETOBJ_ALL_INTERFACES);
	//reo's interfaces are all in UNICODE
	if (GetScode(hr) == S_OK && (reo.dwFlags & REO_INPLACEACTIVE))
	{
		pItem = pDoc->LookupItem(reo.poleobj);
		if (pItem == NULL)
			pItem = pDoc->CreateClientItem(&reo);
		ASSERT(pItem != NULL);
	}
	return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView operations
HRESULT CRichEditView::InsertItem(CRichEditCntrItem* pItem)
{
	ASSERT(m_lpRichEditOle != NULL);
	CReObject reo(pItem);
	reo.cp = REO_CP_SELECTION;

	HRESULT hr = m_lpRichEditOle->InsertObject(&reo);

	CHARRANGE cr;
	GetRichEditCtrl().GetSel(cr);
	cr.cpMin = cr.cpMax -1;
	GetRichEditCtrl().SetSel(cr);
	return hr;
}

void CRichEditView::InsertFileAsObject(LPCTSTR lpszFileName)
{
	CString str = lpszFileName;
	CWaitCursor wait;
	CRichEditCntrItem* pItem = NULL;
	TRY
	{
		// create item from dialog results
		pItem = GetDocument()->CreateClientItem();
		pItem->m_bLock = TRUE;
		if (!pItem->CreateFromFile(str))
			AfxThrowMemoryException();  // any exception will do
		pItem->UpdateLink();
		InsertItem(pItem);
		pItem->m_bLock = FALSE;
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			pItem->m_bLock = FALSE;
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
	}
	END_CATCH
}

void CRichEditView::DoPaste(COleDataObject& dataobj, CLIPFORMAT cf, HMETAFILEPICT hMetaPict)
{
	CWaitCursor wait;

	CRichEditCntrItem* pItem = NULL;
	TRY
	{
		// create item from dialog results
		pItem = GetDocument()->CreateClientItem();
		pItem->m_bLock = TRUE;

		if (m_nPasteType == COlePasteSpecialDialog::pasteLink)      // paste link
		{
			if (!pItem->CreateLinkFromData(&dataobj))
				AfxThrowMemoryException();  // any exception will do
		}
		else if (m_nPasteType == COlePasteSpecialDialog::pasteNormal)
		{
			if (!pItem->CreateFromData(&dataobj))
				AfxThrowMemoryException();      // any exception will do
		}
		else if (m_nPasteType == COlePasteSpecialDialog::pasteStatic)
		{
			if (!pItem->CreateStaticFromData(&dataobj))
				AfxThrowMemoryException();      // any exception will do
		}
		else
		{
			// paste embedded
			if (!pItem->CreateFromData(&dataobj) &&
				!pItem->CreateStaticFromData(&dataobj))
			{
				AfxThrowMemoryException();      // any exception will do
			}
		}

		if (cf == 0)
		{
			// copy the current iconic representation
			FORMATETC fmtetc;
			fmtetc.cfFormat = CF_METAFILEPICT;
			fmtetc.dwAspect = DVASPECT_ICON;
			fmtetc.ptd = NULL;
			fmtetc.tymed = TYMED_MFPICT;
			fmtetc.lindex = 1;
			HGLOBAL hObj = dataobj.GetGlobalData(CF_METAFILEPICT, &fmtetc);
			if (hObj != NULL)
			{
				pItem->SetIconicMetafile(hObj);
				// the following code is an easy way to free a metafile pict
				STGMEDIUM stgMed;
				memset(&stgMed, 0, sizeof(stgMed));
				stgMed.tymed = TYMED_MFPICT;
				stgMed.hGlobal = hObj;
				ReleaseStgMedium(&stgMed);
			}

			// set the current drawing aspect
			hObj = dataobj.GetGlobalData((CLIPFORMAT)_oleData.cfObjectDescriptor);
			if (hObj != NULL)
			{
				ASSERT(hObj != NULL);
				// got CF_OBJECTDESCRIPTOR ok.  Lock it down and extract size.
				LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hObj);
				ASSERT(pObjDesc != NULL);
				((COleClientItem*)pItem)->SetDrawAspect((DVASPECT)pObjDesc->dwDrawAspect);
				GlobalUnlock(hObj);
				GlobalFree(hObj);
			}
		}
		else
		{
			if (hMetaPict != NULL)
			{
				pItem->SetIconicMetafile(hMetaPict);
				((COleClientItem*)pItem)->SetDrawAspect(DVASPECT_ICON);
			}
			else
				((COleClientItem*)pItem)->SetDrawAspect(DVASPECT_CONTENT);
		}


		HRESULT hr = InsertItem(pItem);
		pItem->UpdateItemType();

		pItem->m_bLock = FALSE;

		if (hr != NOERROR)
			AfxThrowOleException(hr);

	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			pItem->m_bLock = FALSE;
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
	}
	END_CATCH
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView virtuals

void CRichEditView::OnPrinterChanged(const CDC& dcPrinter)
{
	// this is typically called by the view when it gets a WM_DEVMODECHANGE
	// also called during page setup
	CSize size;
	if (dcPrinter.m_hDC != NULL)
	{
		// this will fill in the page size
		size.cx = MulDiv(dcPrinter.GetDeviceCaps(PHYSICALWIDTH), 1440,
			dcPrinter.GetDeviceCaps(LOGPIXELSX));
		size.cy = MulDiv(dcPrinter.GetDeviceCaps(PHYSICALHEIGHT), 1440,
			dcPrinter.GetDeviceCaps(LOGPIXELSY));
	}
	else
		size = CSize(8*1440+720, 11*1440); // 8.5" by 11"
	if (GetPaperSize() != size)
	{
		SetPaperSize(size);
		if (m_nWordWrap == WrapToTargetDevice) //wrap to ruler
			WrapChanged();
	}
}

BOOL CRichEditView::OnPasteNativeObject(LPSTORAGE)
{
	// use this function to pull out native data from an embedded object
	// one would typically do this by create a COleStreamFile and attaching it
	// to an archive
	return FALSE;
}

HMENU CRichEditView::GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* )
{
	return NULL;
}

HRESULT CRichEditView::GetClipboardData(CHARRANGE* /*lpchrg*/, DWORD /*reco*/,
	LPDATAOBJECT /*lpRichDataObj*/, LPDATAOBJECT* /*lplpdataobj*/)
{
	return E_NOTIMPL;
}

HRESULT CRichEditView::QueryAcceptData(LPDATAOBJECT lpdataobj,
	CLIPFORMAT* lpcfFormat, DWORD /*dwReco*/, BOOL bReally, HGLOBAL hMetaPict)
{
	ASSERT(lpcfFormat != NULL);
	if (!bReally) // not actually pasting
		return S_OK;
	// if direct pasting a particular native format allow it
	if (IsRichEditFormat(*lpcfFormat))
		return S_OK;

	COleDataObject dataobj;
	dataobj.Attach(lpdataobj, FALSE);
	// if format is 0, then force particular formats if available
	if (*lpcfFormat == 0 && (m_nPasteType == 0))
	{
		if (dataobj.IsDataAvailable((CLIPFORMAT)_oleData.cfRichTextAndObjects)) // native avail, let richedit do as it wants
			return S_OK;
		else if (dataobj.IsDataAvailable((CLIPFORMAT)_oleData.cfRichTextFormat))
		{
			*lpcfFormat = (CLIPFORMAT)_oleData.cfRichTextFormat;
			return S_OK;
		}
		else if (dataobj.IsDataAvailable(CF_TEXT))
		{
			*lpcfFormat = CF_TEXT;
			return S_OK;
		}
	}
	// paste OLE formats

	DoPaste(dataobj, *lpcfFormat, hMetaPict);
	return S_FALSE;
}

HRESULT CRichEditView::GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
	LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
	CRichEditCntrItem* pItem = GetSelectedItem();
	if (pItem == NULL)
		return E_FAIL;
	pItem->m_pView = this;
	HRESULT hr = pItem->GetWindowContext(lplpFrame, lplpDoc, lpFrameInfo);
	pItem->m_pView = NULL;
	return hr;
}

HRESULT CRichEditView::ShowContainerUI(BOOL b)
{
	CRichEditCntrItem* pItem = GetSelectedItem();
	if (pItem == NULL)
		return E_FAIL;
	if (b)
		pItem->m_pView = this;
	HRESULT hr = pItem->ShowContainerUI(b);
	if (FAILED(hr) || !b)
		pItem->m_pView = NULL;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRichEditView Find & Replace

void CRichEditView::AdjustDialogPosition(CDialog* pDlg)
{
	ASSERT(pDlg != NULL);
	long lStart, lEnd;
	GetRichEditCtrl().GetSel(lStart, lEnd);
	CPoint point = GetRichEditCtrl().GetCharPos(lStart);
	ClientToScreen(&point);
	CRect rectDlg;
	pDlg->GetWindowRect(&rectDlg);
	if (rectDlg.PtInRect(point))
	{
		if (point.y > rectDlg.Height())
			rectDlg.OffsetRect(0, point.y - rectDlg.bottom - 20);
		else
		{
			int nVertExt = GetSystemMetrics(SM_CYSCREEN);
			if (point.y + rectDlg.Height() < nVertExt)
				rectDlg.OffsetRect(0, 40 + point.y - rectDlg.top);
		}
		pDlg->MoveWindow(&rectDlg);
	}
}

void CRichEditView::OnEditFindReplace(BOOL bFindOnly)
{
	ASSERT_VALID(this);
	m_bFirstSearch = TRUE;
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	if (pEditState->pFindReplaceDlg != NULL)
	{
		if (pEditState->bFindOnly == bFindOnly)
		{
			pEditState->pFindReplaceDlg->SetActiveWindow();
			pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
			return;
		}
		else
		{
			ASSERT(pEditState->bFindOnly != bFindOnly);
			pEditState->pFindReplaceDlg->SendMessage(WM_CLOSE);
			ASSERT(pEditState->pFindReplaceDlg == NULL);
			ASSERT_VALID(this);
		}
	}
	CString strFind = GetRichEditCtrl().GetSelText();
	// if selection is empty or spans multiple lines use old find text
	if (strFind.IsEmpty() || (strFind.FindOneOf(_T("\n\r")) != -1))
		strFind = pEditState->strFind;
	CString strReplace = pEditState->strReplace;
	pEditState->pFindReplaceDlg = new CFindReplaceDialog;
	ASSERT(pEditState->pFindReplaceDlg != NULL);
	DWORD dwFlags = NULL;
	if (pEditState->bNext)
		dwFlags |= FR_DOWN;
	if (pEditState->bCase)
		dwFlags |= FR_MATCHCASE;
	if (pEditState->bWord)
		dwFlags |= FR_WHOLEWORD;

	if (!pEditState->pFindReplaceDlg->Create(bFindOnly, strFind,
		strReplace, dwFlags, this))
	{
		pEditState->pFindReplaceDlg = NULL;
		ASSERT_VALID(this);
		return;
	}
	ASSERT(pEditState->pFindReplaceDlg != NULL);
	pEditState->bFindOnly = bFindOnly;
	pEditState->pFindReplaceDlg->SetActiveWindow();
	pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
	ASSERT_VALID(this);
}

void CRichEditView::OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord)
{
	ASSERT_VALID(this);

	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	pEditState->strFind = lpszFind;
	pEditState->bCase = bCase;
	pEditState->bWord = bWord;
	pEditState->bNext = bNext;

	if (!FindText(pEditState))
		TextNotFound(pEditState->strFind);
	else
		AdjustDialogPosition(pEditState->pFindReplaceDlg);
	ASSERT_VALID(this);
}

void CRichEditView::OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
	BOOL bWord, LPCTSTR lpszReplace)
{
	ASSERT_VALID(this);
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	pEditState->strFind = lpszFind;
	pEditState->strReplace = lpszReplace;
	pEditState->bCase = bCase;
	pEditState->bWord = bWord;
	pEditState->bNext = bNext;

	if (!SameAsSelected(pEditState->strFind, pEditState->bCase, pEditState->bWord))
	{
		if (!FindText(pEditState))
			TextNotFound(pEditState->strFind);
		else
			AdjustDialogPosition(pEditState->pFindReplaceDlg);
		return;
	}

	GetRichEditCtrl().ReplaceSel(pEditState->strReplace);
	if (!FindText(pEditState))
		TextNotFound(pEditState->strFind);
	else
		AdjustDialogPosition(pEditState->pFindReplaceDlg);
	ASSERT_VALID(this);
}

void CRichEditView::OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bCase, BOOL bWord)
{
	ASSERT_VALID(this);
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	pEditState->strFind = lpszFind;
	pEditState->strReplace = lpszReplace;
	pEditState->bCase = bCase;
	pEditState->bWord = bWord;
	pEditState->bNext = TRUE;

	CWaitCursor wait;
	// no selection or different than what looking for
	if (!SameAsSelected(pEditState->strFind, pEditState->bCase, pEditState->bWord))
	{
		if (!FindText(pEditState))
		{
			TextNotFound(pEditState->strFind);
			return;
		}
	}

	GetRichEditCtrl().HideSelection(TRUE, FALSE);
	do
	{
		GetRichEditCtrl().ReplaceSel(pEditState->strReplace);
	} while (FindTextSimple(pEditState));
	TextNotFound(pEditState->strFind);
	GetRichEditCtrl().HideSelection(FALSE, FALSE);

	ASSERT_VALID(this);
}

LRESULT CRichEditView::OnFindReplaceCmd(WPARAM, LPARAM lParam)
{
	ASSERT_VALID(this);
	CFindReplaceDialog* pDialog = CFindReplaceDialog::GetNotifier(lParam);
	ASSERT(pDialog != NULL);
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	ASSERT(pDialog == pEditState->pFindReplaceDlg);
	if (pDialog->IsTerminating())
		pEditState->pFindReplaceDlg = NULL;
	else if (pDialog->FindNext())
	{
		OnFindNext(pDialog->GetFindString(), pDialog->SearchDown(),
			pDialog->MatchCase(), pDialog->MatchWholeWord());
	}
	else if (pDialog->ReplaceCurrent())
	{
		ASSERT(!pEditState->bFindOnly);
		OnReplaceSel(pDialog->GetFindString(),
			pDialog->SearchDown(), pDialog->MatchCase(), pDialog->MatchWholeWord(),
			pDialog->GetReplaceString());
	}
	else if (pDialog->ReplaceAll())
	{
		ASSERT(!pEditState->bFindOnly);
		OnReplaceAll(pDialog->GetFindString(), pDialog->GetReplaceString(),
			pDialog->MatchCase(), pDialog->MatchWholeWord());
	}
	ASSERT_VALID(this);
	return 0;
}

BOOL CRichEditView::SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL /*bWord*/)
{
	// check length first
	size_t nLen = lstrlen(lpszCompare);
	long lStartChar, lEndChar;
	GetRichEditCtrl().GetSel(lStartChar, lEndChar);
	if (nLen != (size_t)(lEndChar - lStartChar))
		return FALSE;

	// length is the same, check contents
	CString strSelect = GetRichEditCtrl().GetSelText();
	return (bCase && lstrcmp(lpszCompare, strSelect) == 0) ||
		(!bCase && lstrcmpi(lpszCompare, strSelect) == 0);
}

BOOL CRichEditView::FindText(_AFX_RICHEDIT_STATE* pEditState)
{
	ASSERT(pEditState != NULL);
	return FindText(pEditState->strFind, pEditState->bCase, pEditState->bWord, pEditState->bNext);
}

BOOL CRichEditView::FindText(LPCTSTR lpszFind, BOOL bCase, BOOL bWord, BOOL bNext /* = TRUE */)
{
	ASSERT_VALID(this);
	CWaitCursor wait;
	return FindTextSimple(lpszFind, bCase, bWord, bNext);
}

BOOL CRichEditView::FindTextSimple(_AFX_RICHEDIT_STATE* pEditState)
{
	ASSERT(pEditState != NULL);
	return FindTextSimple(pEditState->strFind, pEditState->bCase, pEditState->bWord, pEditState->bNext);
}

BOOL CRichEditView::FindTextSimple(LPCTSTR lpszFind, BOOL bCase, BOOL bWord, BOOL bNext /* = TRUE */)
{
	ASSERT(lpszFind != NULL);
	FINDTEXTEX ft;

	GetRichEditCtrl().GetSel(ft.chrg);
	if (m_bFirstSearch)
	{
		if (bNext)
			m_lInitialSearchPos = ft.chrg.cpMin;
		else
			m_lInitialSearchPos = ft.chrg.cpMax;
		m_bFirstSearch = FALSE;
		m_bChangeFindRange = FALSE;
	}

	// lpstrText should be const
	ft.lpstrText = (LPTSTR) lpszFind;

	if (ft.chrg.cpMin != ft.chrg.cpMax) // i.e. there is a selection
	{
		if (bNext)
		{
			// won't wraparound backwards
			ft.chrg.cpMin = min(ft.chrg.cpMin + 1, GetTextLength());
		}
		else
		{
			// won't wraparound backwards
			ft.chrg.cpMin = max(ft.chrg.cpMin - 1, 0);
		}
	}

	DWORD dwFlags = bCase ? FR_MATCHCASE : 0;
	dwFlags |= bWord ? FR_WHOLEWORD : 0;

	if (bNext)
	{
		ft.chrg.cpMax = GetTextLength();

		dwFlags |= FR_DOWN;
		ASSERT(ft.chrg.cpMax >= ft.chrg.cpMin);
	}
	else
	{
		ft.chrg.cpMax = 0;

		dwFlags &= ~FR_DOWN;
		ASSERT(ft.chrg.cpMax <= ft.chrg.cpMin);
	}

	// if we find the text return TRUE
	if (FindAndSelect(dwFlags, ft) != -1)
	{
		m_bChangeFindRange = TRUE;
		return TRUE;
	}
	// if the original starting point was not the beginning of the buffer
	// and we haven't already been here
	else if (!m_bChangeFindRange)
	{
		m_bChangeFindRange = TRUE;
		if (bNext)
		{
			ft.chrg.cpMin = 0;
			ft.chrg.cpMax = min(m_lInitialSearchPos + CString(lpszFind).GetLength(), GetTextLength());
			m_lInitialSearchPos = 0;
		}
		else
		{
			ft.chrg.cpMin = GetTextLength();
			ft.chrg.cpMax = max(m_lInitialSearchPos - CString(lpszFind).GetLength(), 0);
			m_lInitialSearchPos = GetTextLength();
		}
		return FindAndSelect(dwFlags, ft) != -1;
	}
	// not found
	else
		return FALSE;
}

long CRichEditView::FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft)
{
	long index = GetRichEditCtrl().FindText(dwFlags, &ft);
	if (index != -1) // i.e. we found something
		GetRichEditCtrl().SetSel(ft.chrgText);
	return index;
}

void CRichEditView::TextNotFound(LPCTSTR lpszFind)
{
	ASSERT_VALID(this);
	m_bFirstSearch = TRUE;
	OnTextNotFound(lpszFind);
}

void CRichEditView::OnTextNotFound(LPCTSTR)
{
	MessageBeep(MB_ICONHAND);
}

void CRichEditView::OnActivateView(BOOL bActivate, CView* pActivateView,
								   CView* pDeactiveView)
{
	// need to set owner of Find/Replace dialog
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	if (pEditState && pEditState->pFindReplaceDlg && pActivateView == this)
		pEditState->pFindReplaceDlg->m_fr.hwndOwner = m_hWnd;

	return CCtrlView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditView diagnostics

#ifdef _DEBUG
void CRichEditView::AssertValid() const
{
	CCtrlView::AssertValid();
	ASSERT_VALID(&m_aPageStart);
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	if (pEditState->pFindReplaceDlg != NULL)
		ASSERT_VALID(pEditState->pFindReplaceDlg);
}

void CRichEditView::Dump(CDumpContext& dc) const
{
	CCtrlView::Dump(dc);
	AFX_DUMP1(dc, "\nm_aPageStart ", &m_aPageStart);
	AFX_DUMP0(dc, "\n Static Member Data:");
	_AFX_RICHEDIT_STATE* pEditState = _afxRichEditState;
	if (pEditState->pFindReplaceDlg != NULL)
	{
		AFX_DUMP1(dc, "\npFindReplaceDlg = ",
			(void*)pEditState->pFindReplaceDlg);
		AFX_DUMP1(dc, "\nbFindOnly = ", pEditState->bFindOnly);
	}
	AFX_DUMP1(dc, "\nstrFind = ", pEditState->strFind);
	AFX_DUMP1(dc, "\nstrReplace = ", pEditState->strReplace);
	AFX_DUMP1(dc, "\nbCase = ", pEditState->bCase);
	AFX_DUMP1(dc, "\nbWord = ", pEditState->bWord);
	AFX_DUMP1(dc, "\nbNext = ", pEditState->bNext);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CRichEditView::IsSelected(const CObject* pDocItem) const
{
	return (pDocItem == GetSelectedItem());
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditDoc

CRichEditDoc::CRichEditDoc()
{
	m_bRTF = TRUE;
	m_bUpdateObjectCache = FALSE;
	ASSERT_VALID(this);
}

CRichEditView* CRichEditDoc::GetView() const
{
	// find the first view - if there are no views
	// we must return NULL

	POSITION pos = GetFirstViewPosition();
	if (pos == NULL)
		return NULL;

	// find the first view that is a CRichEditView

	CView* pView;
	while (pos != NULL)
	{
		pView = GetNextView(pos);
		if (pView->IsKindOf(RUNTIME_CLASS(CRichEditView)))
			return (CRichEditView*) pView;
	}

	// can't find one--return NULL

	return NULL;
}

BOOL CRichEditDoc::IsModified()
{
	CRichEditView* pView = GetView();
	if (pView == NULL)
	{
		return FALSE;
	}

	return pView->GetRichEditCtrl().GetModify();
}

void CRichEditDoc::SetModifiedFlag(BOOL bModified)
{
	CRichEditView* pView = GetView();
	if (pView == NULL)
	{
		return;
	}

	pView->GetRichEditCtrl().SetModify(bModified);
	ASSERT(!!pView->GetRichEditCtrl().GetModify() == !!bModified);
}

COleClientItem* CRichEditDoc::GetInPlaceActiveItem(CWnd* pWnd)
{
	if (pWnd->IsKindOf(RUNTIME_CLASS(CRichEditView)))
	{
		CRichEditView* pView = (CRichEditView*)pWnd;
		return pView->GetInPlaceActiveItem();
	}

	return NULL;
}

void CRichEditDoc::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
	// we call CDocument and not COleServerDoc because we don't want to do the
	// SetHostNames stuff here.  The richedit will do it. And we tell the richedit
	// in SetTitle
	CDocument::SetPathName(lpszPathName, bAddToMRU);
}

void CRichEditDoc::SetTitle(LPCTSTR lpszTitle)
{
	COleServerDoc::SetTitle(lpszTitle);
	CRichEditView *pView = GetView();
	ASSERT(pView != NULL);
	ASSERT(pView->m_lpRichEditOle != NULL);
	CStringA strAppName(AfxGetAppName()), strTitle(lpszTitle);
	pView->m_lpRichEditOle->SetHostNames(strAppName.GetString(), 
		strTitle.GetString());
}

CRichEditCntrItem* CRichEditDoc::LookupItem(LPOLEOBJECT lpobj) const
{
	POSITION pos = COleServerDoc::GetStartPosition();
	CRichEditCntrItem* pItem;
	while (pos != NULL)
	{
		pItem = (CRichEditCntrItem*) COleServerDoc::GetNextItem(pos);
		// delete item is right type and not under construction
		if (pItem->IsKindOf(RUNTIME_CLASS(CRichEditCntrItem)) &&
			pItem->m_lpObject == lpobj)
		{
			return pItem;
		}
	}
	return NULL;
}

CRichEditCntrItem* CRichEditDoc::CreateClientItem(REOBJECT* preo) const
{
	// cast away constness of this
	return new CRichEditCntrItem(preo, (CRichEditDoc*)this);
	// a derived class typically needs  to return its own item of a class
	// derived from CRichEditCntrItem
}

void CRichEditDoc::MarkItemsClear() const
{
	POSITION pos = COleServerDoc::GetStartPosition();
	CRichEditCntrItem* pItem;
	while (pos != NULL)
	{
		pItem = (CRichEditCntrItem*) COleServerDoc::GetNextItem(pos);
		// Mark item as not in use unless under construction (i.e. m_lpObject == NULL)
		if (pItem->IsKindOf(RUNTIME_CLASS(CRichEditCntrItem)))
			pItem->Mark(pItem->m_lpObject == NULL);
	}
}

void CRichEditDoc::DeleteUnmarkedItems() const
{
	POSITION pos = COleServerDoc::GetStartPosition();
	CRichEditCntrItem* pItem;
	while (pos != NULL)
	{
		pItem = (CRichEditCntrItem*) COleServerDoc::GetNextItem(pos);
		// Mark item as not in use unless under construction (i.e. m_lpObject == NULL)
		if (pItem->IsKindOf(RUNTIME_CLASS(CRichEditCntrItem)) && !pItem->IsMarked())
			delete pItem;
	}
}

POSITION CRichEditDoc::GetStartPosition() const
{
	if (m_bUpdateObjectCache)
		((CRichEditDoc*)this)->UpdateObjectCache(); //cast away const
	return COleServerDoc::GetStartPosition();
}

void CRichEditDoc::UpdateObjectCache()
{
	CRichEditView* pView = GetView();
	CRichEditCntrItem* pItem;
	if (pView != NULL)
	{
		ASSERT(pView->m_lpRichEditOle != NULL);
		MarkItemsClear();
		long i,nCount = pView->m_lpRichEditOle->GetObjectCount();
		for (i=0;i<nCount;i++)
		{
			CReObject reo; // needs to be in here so destructor called to release interfaces
			HRESULT hr = pView->m_lpRichEditOle->GetObject(i, &reo, REO_GETOBJ_ALL_INTERFACES);
			//reo interfaces are UNICODE
			ASSERT(SUCCEEDED(hr));
			if (GetScode(hr) == S_OK)
			{
				pItem = LookupItem(reo.poleobj);
				if (pItem == NULL)
				{
					pItem = ((CRichEditDoc*)this)->CreateClientItem(&reo);
					pItem->UpdateItemType();
				}
				ASSERT(pItem != NULL);
				pItem->Mark(TRUE);
			}
		}
		DeleteUnmarkedItems();
	}
	m_bUpdateObjectCache = FALSE;
}
/////////////////////////////////////////////////////////////////////////////
// CRichEditDoc Attributes

COleClientItem* CRichEditDoc::GetPrimarySelectedItem(CView* pView)
{
	if (pView->IsKindOf(RUNTIME_CLASS(CRichEditView)))
		return ((CRichEditView*)pView)->GetSelectedItem();
	else
		return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditDoc Operations

void CRichEditDoc::DeleteContents()
{
	COleServerDoc::DeleteContents();
	CWaitCursor wait;
	CRichEditView *pView = GetView();
	if (pView != NULL)
	{
		pView->DeleteContents();
		pView->GetRichEditCtrl().SetModify(FALSE);
		ASSERT(!pView->GetRichEditCtrl().GetModify());
	}
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditDoc serialization

void CRichEditDoc::Serialize(CArchive& ar)
{
	CRichEditView *pView = GetView();
	if (pView != NULL)
		pView->Serialize(ar);
	// we don't call the base class COleServerDoc::Serialize
	// because we don't want the client items serialized
	// the client items are handled directly by the RichEdit control
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditDoc diagnostics

#ifdef _DEBUG
void CRichEditDoc::AssertValid() const
{
	COleServerDoc::AssertValid();
}

void CRichEditDoc::Dump(CDumpContext& dc) const
{
	COleServerDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CRichEditDoc commands

void CRichEditDoc::PreCloseFrame(CFrameWnd* pFrameArg)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pFrameArg);

	// turn off redraw so the user doesn't see the deactivation happening
	BOOL bSetRedraw = FALSE;
	if (pFrameArg->GetStyle() & WS_VISIBLE)
	{
		pFrameArg->SendMessage(WM_SETREDRAW, (WPARAM)FALSE);
		bSetRedraw = TRUE;
	}

	CRichEditView* pView = GetView();
	if (pView != NULL)
	{
		// deactivate any inplace active items on this frame
		pView->m_lpRichEditOle->InPlaceDeactivate();
	}

	POSITION pos = GetStartPosition();
	CRichEditCntrItem* pItem;
	while (pos != NULL)
	{
		pItem = (CRichEditCntrItem*) GetNextClientItem(pos);
		if (pItem == NULL)
			break;
		ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CRichEditCntrItem)));
		pItem->Close();
	}

	// turn redraw back on
	if (bSetRedraw)
		pFrameArg->SendMessage(WM_SETREDRAW, (WPARAM)TRUE);
}

void CRichEditDoc::UpdateModifiedFlag()
{
	// don't do anything here
	// let the richedit handle all of this
}

COleServerItem* CRichEditDoc::OnGetEmbeddedItem()
{
	ASSERT(FALSE);
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditCntrItem implementation

CRichEditCntrItem::CRichEditCntrItem(REOBJECT *preo, CRichEditDoc* pContainer)
	: COleClientItem(pContainer)
{
	m_bMark = FALSE;
	m_bLock = FALSE;
	if (preo != NULL)
	{
		ASSERT(preo->poleobj != NULL);
		ASSERT(preo->pstg != NULL);
		ASSERT(preo->polesite != NULL);
		m_lpObject = preo->poleobj;
		m_lpStorage = preo->pstg;
		m_lpClientSite = preo->polesite;
		m_lpObject->AddRef();
		m_lpStorage->AddRef();
		m_lpClientSite->AddRef();
	}
	else
	{
		m_lpObject = NULL;
		m_lpStorage = NULL;
		m_lpClientSite = NULL;
	}
}

CRichEditCntrItem::~CRichEditCntrItem()
{
	if (m_lpClientSite != NULL)
		m_lpClientSite->Release();
}

void CRichEditCntrItem::OnDeactivateUI(BOOL bUndoable)
{
	CView* pView = GetActiveView();
	if (pView != NULL)
	{
		pView->EnsureParentFrame()->SendMessage(WM_SETMESSAGESTRING,
			(WPARAM)AFX_IDS_IDLEMESSAGE);
	}
	COleClientItem::OnDeactivateUI(bUndoable);
}

HRESULT CRichEditCntrItem::ShowContainerUI(BOOL b)
{
	if (!CanActivate())
		return E_NOTIMPL;
	if (b)
	{
		OnDeactivateUI(FALSE);
		OnDeactivate();
	}
	else
	{
		OnActivate();
		OnActivateUI();
	}
	return S_OK;
}

BOOL CRichEditCntrItem::OnChangeItemPosition(const CRect& /*rectPos*/)
{
	ASSERT_VALID(this);

	// richedit handles this
	return FALSE;
}

BOOL CRichEditCntrItem::CanActivate()
{
	// Editing in-place while the server itself is being edited in-place
	//  does not work and is not supported.  So, disable in-place
	//  activation in this case.
	COleServerDoc* pDoc = DYNAMIC_DOWNCAST(COleServerDoc, GetDocument());
	if (pDoc != NULL && pDoc->IsInPlaceActive())
		return FALSE;

	// otherwise, rely on default behavior
	return COleClientItem::CanActivate();
}

HRESULT CRichEditCntrItem::GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
	LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
	CRect rc1,rc2;
	if (!CanActivate())
		return E_NOTIMPL;
	return m_xOleIPSite.GetWindowContext(lplpFrame, lplpDoc, &rc1, &rc2, lpFrameInfo);
}

BOOL CRichEditCntrItem::ConvertTo(REFCLSID clsidNew)
{
	LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
	LPOLESTR lpOleStr;
	HRESULT hRes = OleRegGetUserType(clsidNew, USERCLASSTYPE_FULL, &lpOleStr);
	if( FAILED(hRes) )
		return FALSE;
	CStringA str(lpOleStr);
	hRes = preole->ConvertObject(REO_IOB_SELECTION, clsidNew, str.GetString());
	CoTaskMemFree(lpOleStr);
	return (SUCCEEDED(hRes));
}

BOOL CRichEditCntrItem::ActivateAs(LPCTSTR, REFCLSID clsidOld,
	REFCLSID clsidNew)
{
	LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
	HRESULT hRes = preole->ActivateAs(clsidOld, clsidNew);
	return (SUCCEEDED(hRes));
}

void CRichEditCntrItem::SetDrawAspect(DVASPECT nDrawAspect)
{
	LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
	preole->SetDvaspect(REO_IOB_SELECTION, nDrawAspect);
	COleClientItem::SetDrawAspect(nDrawAspect);
}

void CRichEditCntrItem::SyncToRichEditObject(REOBJECT& reo)
{
	COleClientItem::SetDrawAspect((DVASPECT)reo.dvaspect);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEditCntrItem diagnostics

#ifdef _DEBUG
void CRichEditCntrItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CRichEditCntrItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////

LPOLECLIENTSITE CRichEditCntrItem::GetClientSite()
{
	if (m_lpClientSite == NULL)
	{
		CRichEditDoc* pDoc = DYNAMIC_DOWNCAST(CRichEditDoc, GetDocument());
		CRichEditView* pView = DYNAMIC_DOWNCAST(CRichEditView, pDoc->GetView());
		ENSURE(pView);
		ENSURE(pView->m_lpRichEditOle != NULL);
		HRESULT hr = pView->m_lpRichEditOle->GetClientSite(&m_lpClientSite);
		if (hr != S_OK)
		{
			AfxThrowOleException(hr);
		}
	}
	ASSERT(m_lpClientSite != NULL);
	return m_lpClientSite;
}

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_ENABLE_INLINES

#define _AFXRICH_INLINE
#include "afxrich.inl"

#endif //_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////


IMPLEMENT_SERIAL(CRichEditCntrItem, COleClientItem, 0)
IMPLEMENT_DYNAMIC(CRichEditDoc, COleServerDoc)
IMPLEMENT_DYNCREATE(CRichEditView, CCtrlView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewhtml.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include <exdispid.h>
#include <mshtmcid.h>	// CMDSETID_Forms3 definition
#include <mshtmhst.h>	// IDM_menu item definitions
#include <mshtml.h>

#ifdef _DEBUG
#define new DEBUG_NEW


#endif

/////////////////////////////////////////////////////////////////////////////
// CHtmlView

BEGIN_MESSAGE_MAP(CHtmlView, CFormView)
	//{{AFX_MSG_MAP(CHtmlView)
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_DESTROY()
	ON_COMMAND(ID_EDIT_COPY, &CHtmlView::OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, &CHtmlView::OnUpdateEditCopy)
	ON_COMMAND(ID_EDIT_CUT, &CHtmlView::OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, &CHtmlView::OnUpdateEditCut)
	ON_COMMAND(ID_EDIT_PASTE, &CHtmlView::OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, &CHtmlView::OnUpdateEditPaste)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, &CHtmlView::OnFilePrint)
END_MESSAGE_MAP()

BEGIN_EVENTSINK_MAP(CHtmlView, CFormView)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_STATUSTEXTCHANGE, OnStatusTextChange, VTS_BSTR)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_PROGRESSCHANGE, OnProgressChange, VTS_I4 VTS_I4)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_COMMANDSTATECHANGE, OnCommandStateChange, VTS_I4 VTS_BOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_DOWNLOADBEGIN, OnDownloadBegin, VTS_NONE)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_DOWNLOADCOMPLETE, OnDownloadComplete, VTS_NONE)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_TITLECHANGE, OnTitleChange, VTS_BSTR)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_NAVIGATECOMPLETE2, NavigateComplete2, VTS_DISPATCH VTS_PVARIANT)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_BEFORENAVIGATE2, BeforeNavigate2, VTS_DISPATCH VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PBOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_PROPERTYCHANGE, OnPropertyChange, VTS_BSTR)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_NEWWINDOW2, OnNewWindow2, VTS_PDISPATCH VTS_PBOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_DOCUMENTCOMPLETE, DocumentComplete, VTS_DISPATCH VTS_PVARIANT)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_NAVIGATEERROR, NavigateError, VTS_DISPATCH VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PBOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_ONQUIT, OnQuit, VTS_NONE)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_ONVISIBLE, OnVisible, VTS_BOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_ONTOOLBAR, OnToolBar, VTS_BOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_ONMENUBAR, OnMenuBar, VTS_BOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_ONSTATUSBAR, OnStatusBar, VTS_BOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_ONFULLSCREEN, OnFullScreen, VTS_BOOL)
	ON_EVENT(CHtmlView, AFX_IDW_PANE_FIRST, DISPID_ONTHEATERMODE, OnTheaterMode, VTS_BOOL)
END_EVENTSINK_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHtmlView construction/destruction

CHtmlView::CHtmlView()
	: CFormView((LPCTSTR) NULL)
{
}

CHtmlView::~CHtmlView()
{
}

BOOL CHtmlView::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style |= WS_CLIPCHILDREN;

	return CFormView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlView drawing

void CHtmlView::OnDraw(CDC* /* pDC */)
{
	// this class should never do its own drawing;
	// the browser control should handle everything

	ASSERT(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlView printing

void CHtmlView::OnFilePrint()
{
	// get the HTMLDocument

	if (m_pBrowserApp != NULL)
	{		
		CComPtr<IDispatch> spDisp;
		m_pBrowserApp->get_Document(&spDisp);
		if (spDisp != NULL)
		{
			// the control will handle all printing UI

			CComQIPtr<IOleCommandTarget> spTarget = spDisp;
			if (spTarget != NULL)
				spTarget->Exec(NULL, OLECMDID_PRINT, 0, NULL, NULL);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlView diagnostics

#ifdef _DEBUG
void CHtmlView::AssertValid() const
{
	CFormView::AssertValid();
}

void CHtmlView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHtmlView message handlers

void CHtmlView::OnDestroy()
{
}

void CHtmlView::OnSize(UINT nType, int cx, int cy)
{
	CFormView::OnSize(nType, cx, cy);

	if (::IsWindow(m_wndBrowser.m_hWnd))
	{
		// need to push non-client borders out of the client area
		CRect rect;
		GetClientRect(rect);
		::AdjustWindowRectEx(rect,
			m_wndBrowser.GetStyle(), FALSE, WS_EX_CLIENTEDGE);
		m_wndBrowser.SetWindowPos(NULL, rect.left, rect.top,
			rect.Width(), rect.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
	}
}

void CHtmlView::OnPaint()
{
	Default();
}

void CHtmlView::OnDrawIconicThumbnailOrLivePreview(CDC& dc, CRect rect, CSize szRequiredThumbnailSize, BOOL bIsThumbnail, BOOL& bAlphaChannelSet)
{
	UNREFERENCED_PARAMETER(szRequiredThumbnailSize);
	UNREFERENCED_PARAMETER(bIsThumbnail);
	UNREFERENCED_PARAMETER(bAlphaChannelSet);

	ASSERT_VALID(&dc);
	OleDraw(GetHtmlDocument(), DVASPECT_CONTENT, dc.GetSafeHdc(), rect);
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlView operations

#pragma warning(disable:4100)

class CHtmlControlSite : public COleControlSite
{
public:
	CHtmlControlSite(COleControlContainer* pParentWnd);
	~CHtmlControlSite();

	CHtmlView* GetView() const;

	BEGIN_INTERFACE_PART(DocHostUIHandler, IDocHostUIHandler)
		STDMETHOD(ShowContextMenu)(DWORD, LPPOINT, LPUNKNOWN, LPDISPATCH);
		STDMETHOD(GetHostInfo)(DOCHOSTUIINFO*);
		STDMETHOD(ShowUI)(DWORD, LPOLEINPLACEACTIVEOBJECT,
			LPOLECOMMANDTARGET, LPOLEINPLACEFRAME, LPOLEINPLACEUIWINDOW);
		STDMETHOD(HideUI)(void);
		STDMETHOD(UpdateUI)(void);
		STDMETHOD(EnableModeless)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG, const GUID*, DWORD);
		STDMETHOD(GetOptionKeyPath)(OLECHAR **, DWORD);
		STDMETHOD(GetDropTarget)(LPDROPTARGET, LPDROPTARGET*);
		STDMETHOD(GetExternal)(LPDISPATCH*);
		STDMETHOD(TranslateUrl)(DWORD, OLECHAR*, OLECHAR **);
		STDMETHOD(FilterDataObject)(LPDATAOBJECT , LPDATAOBJECT*);
	END_INTERFACE_PART(DocHostUIHandler)

	DECLARE_INTERFACE_MAP()
};

BEGIN_INTERFACE_MAP(CHtmlControlSite, COleControlSite)
	INTERFACE_PART(CHtmlControlSite, IID_IDocHostUIHandler, DocHostUIHandler)
END_INTERFACE_MAP()

CHtmlControlSite::CHtmlControlSite(COleControlContainer* pContainer)
: COleControlSite(pContainer)
{
}

CHtmlControlSite::~CHtmlControlSite()
{
}

inline CHtmlView* CHtmlControlSite::GetView() const
{
	return STATIC_DOWNCAST(CHtmlView, m_pCtrlCont->m_pWnd);
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::GetExternal(LPDISPATCH *lppDispatch)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)

	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnGetExternal(lppDispatch);
}

HRESULT CHtmlView::OnGetExternal(LPDISPATCH*)
{
	// default tells control we don't have an external
	return S_FALSE;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::ShowContextMenu(
	DWORD dwID, LPPOINT ppt, LPUNKNOWN pcmdtReserved, LPDISPATCH pdispReserved)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)

	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnShowContextMenu(dwID, ppt, pcmdtReserved, pdispReserved);
}

HRESULT CHtmlView::OnShowContextMenu(DWORD, LPPOINT, LPUNKNOWN, LPDISPATCH)
{
	// default tells control that we didn't show a menu,
	// and the control should show the menu

	return S_FALSE;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::GetHostInfo(
	DOCHOSTUIINFO *pInfo)
{
	METHOD_PROLOGUE_EX(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnGetHostInfo(pInfo);
}

HRESULT CHtmlView::OnGetHostInfo(DOCHOSTUIINFO*)
{
	// default indicates we don't have info
	return S_OK;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::ShowUI(
	DWORD dwID, LPOLEINPLACEACTIVEOBJECT pActiveObject,
	LPOLECOMMANDTARGET pCommandTarget, LPOLEINPLACEFRAME pFrame,
	LPOLEINPLACEUIWINDOW pDoc)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)

	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc);
}

HRESULT CHtmlView::OnShowUI(DWORD, LPOLEINPLACEACTIVEOBJECT,
	LPOLECOMMANDTARGET, LPOLEINPLACEFRAME, LPOLEINPLACEUIWINDOW)
{
	// default means we don't have any UI, and control should show its UI

	return S_FALSE;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::HideUI(void)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)

	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnHideUI();
}

HRESULT CHtmlView::OnHideUI()
{
	// we don't have UI by default, so just pretend we hid it
	return S_OK;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::UpdateUI(void)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)

	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnUpdateUI();
}

HRESULT CHtmlView::OnUpdateUI()
{
	// we don't have UI by default, so just pretend we updated it
	return S_OK;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::EnableModeless(BOOL fEnable)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnEnableModeless(fEnable);
}

HRESULT CHtmlView::OnEnableModeless(BOOL)
{
	// we don't have any UI by default, so pretend we updated it
	return S_OK;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::OnDocWindowActivate(BOOL fActivate)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnDocWindowActivate(fActivate);
}

HRESULT CHtmlView::OnDocWindowActivate(BOOL)
{
	// we don't have any UI by default, so pretend we updated it
	return S_OK;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::OnFrameWindowActivate(
	BOOL fActivate)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnFrameWindowActivate(fActivate);
}

HRESULT CHtmlView::OnFrameWindowActivate(BOOL)
{
	// we don't have any UI by default, so pretend we updated it
	return S_OK;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::ResizeBorder(
	LPCRECT prcBorder, LPOLEINPLACEUIWINDOW pUIWindow, BOOL fFrameWindow)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnResizeBorder(prcBorder, pUIWindow, fFrameWindow);
}

HRESULT CHtmlView::OnResizeBorder(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL)
{
	// we don't have any UI by default, so pretend we updated it
	return S_OK;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::TranslateAccelerator(
	LPMSG lpMsg, const GUID* pguidCmdGroup, DWORD nCmdID)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnTranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
}

HRESULT CHtmlView::OnTranslateAccelerator(LPMSG, const GUID*, DWORD)
{
	// no translation here
	return S_FALSE;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::GetOptionKeyPath(
	LPOLESTR* pchKey, DWORD dwReserved)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnGetOptionKeyPath(pchKey, dwReserved);
}

HRESULT CHtmlView::OnGetOptionKeyPath(LPOLESTR*, DWORD)	
{
	// no replacement option key
	return S_FALSE;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::GetDropTarget(
	LPDROPTARGET pDropTarget, LPDROPTARGET* ppDropTarget)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnGetDropTarget(pDropTarget, ppDropTarget);
}

HRESULT CHtmlView::OnGetDropTarget(LPDROPTARGET, LPDROPTARGET*)
{
	// no additional drop target
	return S_FALSE;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::TranslateUrl(
	DWORD dwTranslate, OLECHAR* pchURLIn, OLECHAR** ppchURLOut)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnTranslateUrl(dwTranslate, pchURLIn, ppchURLOut);
}

HRESULT CHtmlView::OnTranslateUrl(DWORD, OLECHAR*, OLECHAR**)
{
	// no translation happens by default
	return S_FALSE;
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::FilterDataObject(
	LPDATAOBJECT pDataObject, LPDATAOBJECT* ppDataObject)
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	CHtmlView* pView = pThis->GetView();
	ASSERT_VALID(pView);
	if (pView == NULL)
	{
		return E_FAIL;
	}
	return pView->OnFilterDataObject(pDataObject, ppDataObject);
}

HRESULT CHtmlView::OnFilterDataObject(LPDATAOBJECT pDataObject,
									LPDATAOBJECT* ppDataObject)
{
	// no data objects by default
	return S_FALSE;
}

STDMETHODIMP_(ULONG) CHtmlControlSite::XDocHostUIHandler::AddRef()
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CHtmlControlSite::XDocHostUIHandler::Release()
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	return pThis->ExternalRelease();
}

STDMETHODIMP CHtmlControlSite::XDocHostUIHandler::QueryInterface(
		  REFIID iid, LPVOID far* ppvObj)     
{
	METHOD_PROLOGUE_EX_(CHtmlControlSite, DocHostUIHandler)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

BOOL CHtmlView::CreateControlSite(COleControlContainer* pContainer, 
   COleControlSite** ppSite, UINT /* nID */, REFCLSID /* clsid */)
{
	ASSERT(ppSite != NULL);
	*ppSite = new CHtmlControlSite(pContainer);
	return TRUE;
}

BOOL CHtmlView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
						DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
						UINT nID, CCreateContext* pContext)
{
	// create the view window itself
	m_pCreateContext = pContext;
	if (!CView::Create(lpszClassName, lpszWindowName,
				dwStyle, rect, pParentWnd,  nID, pContext))
	{
		return FALSE;
	}

	// assure that control containment is on
	AfxEnableControlContainer();

	RECT rectClient;
	GetClientRect(&rectClient);

	// create the control window
	// AFX_IDW_PANE_FIRST is a safe but arbitrary ID
	if (!m_wndBrowser.CreateControl(CLSID_WebBrowser, lpszWindowName,
				WS_VISIBLE | WS_CHILD, rectClient, this, AFX_IDW_PANE_FIRST))
	{
		DestroyWindow();
		return FALSE;
	}

	// cache the dispinterface
	LPUNKNOWN lpUnk = m_wndBrowser.GetControlUnknown();
	HRESULT hr = lpUnk->QueryInterface(IID_IWebBrowser2, (void**) &m_pBrowserApp);
	if (!SUCCEEDED(hr))
	{
		m_pBrowserApp = NULL;
		m_wndBrowser.DestroyWindow();
		DestroyWindow();
		return FALSE;
	}

	return TRUE;
}

BOOL CHtmlView::PreTranslateMessage(MSG* pMsg) 
{
	ASSERT(pMsg != NULL);
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);

	// allow tooltip messages to be filtered (skip CFormView)
	if (CView::PreTranslateMessage(pMsg))
		return TRUE;

	// don't translate dialog messages when in Shift+F1 help mode
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	if (pFrameWnd != NULL && pFrameWnd->m_bHelpMode)
		return FALSE;

	// call all frame windows' PreTranslateMessage first
	pFrameWnd = GetParentFrame();   // start with first parent frame
	while (pFrameWnd != NULL)
	{
		// allow owner & frames to translate
		if (pFrameWnd->PreTranslateMessage(pMsg))
			return TRUE;

		// try parent frames until there are no parent frames
		pFrameWnd = pFrameWnd->GetParentFrame();
	}

	// check if the browser control wants to handle the message
	BOOL bRet = FALSE;
	if(m_pBrowserApp != NULL)
	{
		CComQIPtr<IOleInPlaceActiveObject> spInPlace = m_pBrowserApp;
		if (spInPlace)
			bRet = (spInPlace->TranslateAccelerator(pMsg) == S_OK) ? TRUE : FALSE;
	}

	return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlView properties

CString CHtmlView::GetType() const
{
	ASSERT(m_pBrowserApp != NULL);

	CComBSTR bstr;
	HRESULT hr = m_pBrowserApp->get_Type(&bstr);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return CString();
	}
		
	CString retVal(bstr);
	return retVal;
}

long CHtmlView::GetLeft() const
{
	ASSERT(m_pBrowserApp != NULL);

	long result;
	HRESULT hr = m_pBrowserApp->get_Left(&result);
	if(FAILED(hr))
		AfxThrowUserException();
	
	return result;
}


long CHtmlView::GetTop() const
{
	ASSERT(m_pBrowserApp != NULL);
	long result;
	HRESULT hr = m_pBrowserApp->get_Top(&result);
	if(FAILED(hr))
		AfxThrowUserException();
	
	return result;
}

int CHtmlView::GetToolBar() const
{
	ASSERT(m_pBrowserApp != NULL);
	int result;
	HRESULT hr = m_pBrowserApp->get_ToolBar(&result);
	if(FAILED(hr))
		AfxThrowUserException();
	
	return result;
}

long CHtmlView::GetHeight() const
{
	ASSERT(m_pBrowserApp != NULL);
	long result;
	HRESULT hr = m_pBrowserApp->get_Height(&result);
	if(FAILED(hr))
		AfxThrowUserException();
	
	return result;
}

long CHtmlView::GetWidth() const
{
	ASSERT(m_pBrowserApp != NULL);
	long result;
	HRESULT hr = m_pBrowserApp->get_Width(&result);
	if(FAILED(hr))
		AfxThrowUserException();
	
	return result;
}

BOOL CHtmlView::GetVisible() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_Visible(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
		
	return result;
}

CString CHtmlView::GetLocationName() const
{
	ASSERT(m_pBrowserApp != NULL);

	CComBSTR bstr;
	HRESULT hr = m_pBrowserApp->get_LocationName(&bstr);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return CString();
	}

	CString retVal(bstr);
	return retVal;
}

CString CHtmlView::GetLocationURL() const
{
	ASSERT(m_pBrowserApp != NULL);

	CComBSTR bstr;
	HRESULT hr = m_pBrowserApp->get_LocationURL(&bstr);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return CString();
	}
	
	CString retVal(bstr);
	return retVal;
}

BOOL CHtmlView::GetBusy() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_Busy(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return result;
}

READYSTATE CHtmlView::GetReadyState() const
{
	ASSERT(m_pBrowserApp != NULL);

	READYSTATE result;
	HRESULT hr = m_pBrowserApp->get_ReadyState(&result);
	if(FAILED(hr))
		AfxThrowUserException();
		
	return result;
}

BOOL CHtmlView::GetOffline() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_Offline(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return result;
}

BOOL CHtmlView::GetSilent() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_Silent(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	return result;
}

LPDISPATCH CHtmlView::GetApplication() const
{
	ASSERT(m_pBrowserApp != NULL);

	LPDISPATCH result;
	HRESULT hr = m_pBrowserApp->get_Application(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return NULL;
	}
	
	return result;
}


LPDISPATCH CHtmlView::GetParentBrowser() const
{
	ASSERT(m_pBrowserApp != NULL);

	LPDISPATCH result;
	HRESULT hr = m_pBrowserApp->get_Parent(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return NULL;
	}
	
	return result;
}

LPDISPATCH CHtmlView::GetContainer() const
{
	ASSERT(m_pBrowserApp != NULL);

	LPDISPATCH result;
	HRESULT hr = m_pBrowserApp->get_Container(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return NULL;
	}
	
	return result;
}

LPDISPATCH CHtmlView::GetHtmlDocument() const
{
	ASSERT(m_pBrowserApp != NULL);

	LPDISPATCH result;
	HRESULT hr = m_pBrowserApp->get_Document(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return NULL;
	}
	
	return result;
}

BOOL CHtmlView::GetTopLevelContainer() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	m_pBrowserApp->get_TopLevelContainer(&result);
	return result;
}

BOOL CHtmlView::GetMenuBar() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_MenuBar(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	return result;
}

BOOL CHtmlView::GetFullScreen() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_FullScreen(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	return result;
}

BOOL CHtmlView::GetStatusBar() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_StatusBar(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	return result;
}

OLECMDF CHtmlView::QueryStatusWB(OLECMDID cmdID) const
{
	ASSERT(m_pBrowserApp != NULL);

	OLECMDF result;
	HRESULT hr = m_pBrowserApp->QueryStatusWB(cmdID, &result);
	if(FAILED(hr))
		AfxThrowUserException();
		
	return result;
}

void CHtmlView::ExecWB(OLECMDID cmdID, OLECMDEXECOPT cmdexecopt,
	VARIANT* pvaIn, VARIANT* pvaOut)
{
	ASSERT(m_pBrowserApp != NULL);

	m_pBrowserApp->ExecWB(cmdID, cmdexecopt, pvaIn, pvaOut);
}

HRESULT CHtmlView::ExecFormsCommand(DWORD dwCommandID,
	VARIANT* pVarIn, VARIANT* pVarOut)
{
	ENSURE(m_pBrowserApp != NULL);
	HRESULT hr = E_FAIL;
	CComPtr<IDispatch> spDispDocument;
	m_pBrowserApp->get_Document(&spDispDocument);
	CComQIPtr<IHTMLDocument2> spDoc = spDispDocument;
	if (spDoc != NULL)
	{
		CComQIPtr<IOleCommandTarget> spCmdTarget = spDoc;
		if (spCmdTarget != NULL)
			hr = spCmdTarget->Exec(&CMDSETID_Forms3, dwCommandID,
				OLECMDEXECOPT_DONTPROMPTUSER, pVarIn, pVarOut);
	}

	return hr;
}

HRESULT CHtmlView::QueryFormsCommand(DWORD dwCommandID,
	BOOL* pbSupported, BOOL* pbEnabled, BOOL* pbChecked)
{
	ENSURE(m_pBrowserApp!=NULL);
	HRESULT hr = E_FAIL;

	CComPtr<IDispatch> spDispDocument;
	m_pBrowserApp->get_Document(&spDispDocument);
	CComQIPtr<IHTMLDocument2> spDoc = spDispDocument;	
	if (spDoc != NULL)
	{
		CComQIPtr<IOleCommandTarget> spCmdTarget = spDoc;
		if (spCmdTarget != NULL)
		{
			OLECMD cmdInfo;
			cmdInfo.cmdID = dwCommandID;
			cmdInfo.cmdf = 0;

			hr = spCmdTarget->QueryStatus(&CMDSETID_Forms3, 1, &cmdInfo, NULL);

			if (SUCCEEDED(hr))
			{
				if (pbSupported != NULL)
					*pbSupported = (cmdInfo.cmdf & OLECMDF_SUPPORTED) ? TRUE : FALSE;
				if (pbEnabled != NULL)
					*pbEnabled = (cmdInfo.cmdf & OLECMDF_ENABLED) ? TRUE : FALSE;
				if (pbChecked != NULL)
					*pbChecked = (cmdInfo.cmdf & OLECMDF_LATCHED) ? TRUE : FALSE;
			}
		}
	}

	return hr;
}

BOOL CHtmlView::GetRegisterAsBrowser() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_RegisterAsBrowser(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	return result;
}

BOOL CHtmlView::GetRegisterAsDropTarget() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_RegisterAsDropTarget(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	return result;
}

BOOL CHtmlView::GetTheaterMode() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_TheaterMode(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	return result;
}

BOOL CHtmlView::GetAddressBar() const
{
	ASSERT(m_pBrowserApp != NULL);

	VARIANT_BOOL result;
	HRESULT hr = m_pBrowserApp->get_AddressBar(&result);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlView operations

BOOL CHtmlView::GetSource(CString& refString)
{
	ENSURE(m_pBrowserApp != NULL);	

	BOOL bRetVal = FALSE;
	
	CComPtr<IDispatch> spDisp; 
	m_pBrowserApp->get_Document(&spDisp);
	if (spDisp != NULL)
	{
		HGLOBAL hMemory;
		hMemory = GlobalAlloc(GMEM_MOVEABLE, 0);
		if (hMemory != NULL)
		{
			CComQIPtr<IPersistStreamInit> spPersistStream = spDisp;
			if (spPersistStream != NULL)
			{
				CComPtr<IStream> spStream;
				if (SUCCEEDED(CreateStreamOnHGlobal(hMemory, TRUE, &spStream)))
				{
					spPersistStream->Save(spStream, FALSE);

					STATSTG statStg;
					spStream->Stat(&statStg, STATFLAG_NONAME);

					LPCSTR pstr = static_cast<LPCSTR>(GlobalLock(hMemory));
					if (pstr != NULL)
					{
						// Stream is expected to be ANSI (CP-ACP). CString constructor
						// will convert implicitly, and truncate to correct length.

						bRetVal = TRUE;
						TRY
						{
							refString = CString(pstr, statStg.cbSize.LowPart);
						}
						CATCH_ALL(e)
						{
							bRetVal = FALSE;
							DELETE_EXCEPTION(e);
						}
						END_CATCH_ALL

						if (bRetVal == FALSE)
							GlobalFree(hMemory);
						else
							GlobalUnlock(hMemory);
					}
					else
					{
						GlobalFree(hMemory);
					}
				}
				else
				{
					GlobalFree(hMemory);
				}
			}
			else
			{
				GlobalFree(hMemory);
			}
		}
	}

	return bRetVal;
}

BOOL CHtmlView::LoadFromResource(LPCTSTR lpszResource)
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	ASSERT(hInstance != NULL);

	CString strResourceURL;
	BOOL bRetVal = TRUE;
	LPTSTR lpszModule = new TCHAR[_MAX_PATH];

	if (GetModuleFileName(hInstance, lpszModule, _MAX_PATH))
	{
		strResourceURL.Format(_T("res://%s/%s"), lpszModule, lpszResource);
		Navigate(strResourceURL, 0, 0, 0);
	}
	else
		bRetVal = FALSE;

	delete [] lpszModule;
	return bRetVal;
}

BOOL CHtmlView::LoadFromResource(UINT nRes)
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	ASSERT(hInstance != NULL);

	CString strResourceURL;
	BOOL bRetVal = TRUE;
	LPTSTR lpszModule = new TCHAR[_MAX_PATH];

	if (GetModuleFileName(hInstance, lpszModule, _MAX_PATH))
	{
		strResourceURL.Format(_T("res://%s/%d"), lpszModule, nRes);
		Navigate(strResourceURL, 0, 0, 0);
	}
	else
		bRetVal = FALSE;

	delete [] lpszModule;
	return bRetVal;
}

void CHtmlView::Navigate(LPCTSTR lpszURL, DWORD dwFlags /* = 0 */,
	LPCTSTR lpszTargetFrameName /* = NULL */ ,
	LPCTSTR lpszHeaders /* = NULL */, LPVOID lpvPostData /* = NULL */,
	DWORD dwPostDataLen /* = 0 */)
{
	CString strURL(lpszURL);
	CComBSTR bstrURL;
	bstrURL.Attach(strURL.AllocSysString());

	COleSafeArray vPostData;
	if (lpvPostData != NULL)
	{
		if (dwPostDataLen == 0)
			dwPostDataLen = lstrlen((LPCTSTR) lpvPostData);

		vPostData.CreateOneDim(VT_UI1, dwPostDataLen, lpvPostData);
	}

	m_pBrowserApp->Navigate(bstrURL,
		COleVariant((long) dwFlags, VT_I4),
		COleVariant(lpszTargetFrameName, VT_BSTR),
		vPostData,
		COleVariant(lpszHeaders, VT_BSTR));
}

void CHtmlView::Navigate2(LPITEMIDLIST pIDL, DWORD dwFlags /* = 0 */,
	LPCTSTR lpszTargetFrameName /* = NULL */)
{
	ASSERT(m_pBrowserApp != NULL);

	COleVariant vPIDL(pIDL);
	COleVariant empty;

	m_pBrowserApp->Navigate2(vPIDL,
		COleVariant((long) dwFlags, VT_I4),
		COleVariant(lpszTargetFrameName, VT_BSTR),
		empty, empty);
}

void CHtmlView::Navigate2(LPCTSTR lpszURL, DWORD dwFlags /* = 0 */,
	LPCTSTR lpszTargetFrameName /* = NULL */,
	LPCTSTR lpszHeaders /* = NULL */,
	LPVOID lpvPostData /* = NULL */, DWORD dwPostDataLen /* = 0 */)
{
	ASSERT(m_pBrowserApp != NULL);

	COleSafeArray vPostData;
	if (lpvPostData != NULL)
	{
		if (dwPostDataLen == 0)
			dwPostDataLen = lstrlen((LPCTSTR) lpvPostData);

		vPostData.CreateOneDim(VT_UI1, dwPostDataLen, lpvPostData);
	}

	COleVariant vURL(lpszURL, VT_BSTR);
	COleVariant vHeaders(lpszHeaders, VT_BSTR);
	COleVariant vTargetFrameName(lpszTargetFrameName, VT_BSTR);
	COleVariant vFlags((long) dwFlags, VT_I4);

	m_pBrowserApp->Navigate2(vURL,
		vFlags, vTargetFrameName, vPostData, vHeaders);
}

void CHtmlView::Navigate2(LPCTSTR lpszURL, DWORD dwFlags,
	CByteArray& baPostData, LPCTSTR lpszTargetFrameName /* = NULL */,
	LPCTSTR lpszHeaders /* = NULL */)
{
	ASSERT(m_pBrowserApp != NULL);

	COleVariant vPostData = baPostData;
	COleVariant vURL(lpszURL, VT_BSTR);
	COleVariant vHeaders(lpszHeaders, VT_BSTR);
	COleVariant vTargetFrameName(lpszTargetFrameName, VT_BSTR);
	COleVariant vFlags((long) dwFlags, VT_I4);

	ASSERT(m_pBrowserApp != NULL);

	m_pBrowserApp->Navigate2(vURL, vFlags, vTargetFrameName,
		vPostData, vHeaders);
}

void CHtmlView::PutProperty(LPCTSTR lpszProperty, const VARIANT& vtValue)
{
	ASSERT(m_pBrowserApp != NULL);

	CString strProp(lpszProperty);
	BSTR bstrProp = strProp.AllocSysString();
	m_pBrowserApp->PutProperty(bstrProp, vtValue);
	::SysFreeString(bstrProp);
}

BOOL CHtmlView::GetProperty(LPCTSTR lpszProperty, CString& strValue)
{
	ASSERT(m_pBrowserApp != NULL);

	CString strProperty(lpszProperty);
	BSTR bstrProperty = strProperty.AllocSysString();

	BOOL bResult = FALSE;
	VARIANT vReturn;
	vReturn.vt = VT_BSTR;
	vReturn.bstrVal = NULL;
	HRESULT hr = m_pBrowserApp->GetProperty(bstrProperty, &vReturn);

	if (SUCCEEDED(hr))
	{
		strValue = CString(vReturn.bstrVal);
		bResult = TRUE;
	}

	::SysFreeString(bstrProperty);
	return bResult;
}

COleVariant CHtmlView::GetProperty(LPCTSTR lpszProperty)
{
	COleVariant result;

	static BYTE parms[] =
		VTS_BSTR;
	m_wndBrowser.InvokeHelper(0x12f, DISPATCH_METHOD,
		VT_VARIANT, (void*)&result, parms, lpszProperty);

	return result;
}

CString CHtmlView::GetFullName() const
{
	ASSERT(m_pBrowserApp != NULL);

	CComBSTR bstr;
	HRESULT hr = m_pBrowserApp->get_FullName(&bstr);
	if(FAILED(hr))
	{
		ASSERT(FALSE);
		return CString();
	}
	
	CString retVal(bstr);
	return retVal;
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlView event reflectors

void CHtmlView::NavigateComplete2(LPDISPATCH /* pDisp */, VARIANT* URL)
{
	ASSERT(V_VT(URL) == VT_BSTR);

	CString str(V_BSTR(URL));
	OnNavigateComplete2(str);
}

void CHtmlView::BeforeNavigate2(LPDISPATCH /* pDisp */, VARIANT* URL,
		VARIANT* Flags, VARIANT* TargetFrameName,
		VARIANT* PostData, VARIANT* Headers, VARIANT_BOOL* Cancel) 
{
	ASSERT(V_VT(URL) == VT_BSTR);
	ASSERT(V_VT(TargetFrameName) == VT_BSTR);
	ASSERT(V_VT(PostData) == (VT_VARIANT | VT_BYREF));
	ASSERT(V_VT(Headers) == VT_BSTR);
	ASSERT(Cancel != NULL);

	VARIANT* vtPostedData = V_VARIANTREF(PostData);
	CByteArray array;
	if (V_VT(vtPostedData) & VT_ARRAY)
	{
		// must be a vector of bytes
		ASSERT(vtPostedData->parray->cDims == 1 && vtPostedData->parray->cbElements == 1);

		vtPostedData->vt |= VT_UI1;
		COleSafeArray safe(vtPostedData);

		DWORD dwSize = safe.GetOneDimSize();
		LPVOID pVoid;
		safe.AccessData(&pVoid);

		array.SetSize(dwSize);
		LPBYTE lpByte = array.GetData();

		Checked::memcpy_s(lpByte, dwSize, pVoid, dwSize);
		safe.UnaccessData();
	}
	// make real parameters out of the notification

	CString strTargetFrameName(V_BSTR(TargetFrameName));
	CString strURL(V_BSTR(URL));
	CString strHeaders(V_BSTR(Headers));
	DWORD nFlags = V_I4(Flags);


	BOOL bCancel = FALSE;
	// notify the user's class
	OnBeforeNavigate2(strURL, nFlags, strTargetFrameName,
		array, strHeaders, &bCancel);

	if (bCancel)
		*Cancel = AFX_OLE_TRUE;
	else
		*Cancel = AFX_OLE_FALSE;
}

void CHtmlView::DocumentComplete(LPDISPATCH pDisp, VARIANT* URL)
{
	UNUSED_ALWAYS(pDisp);
	ASSERT(V_VT(URL) == VT_BSTR);

	CString str(V_BSTR(URL));
	OnDocumentComplete(str);
}

void CHtmlView::NavigateError(LPDISPATCH pDisp, VARIANT* pvURL,
	VARIANT* pvFrame, VARIANT* pvStatusCode, VARIANT_BOOL* pvbCancel)
{
	UNUSED_ALWAYS(pDisp);
	ASSERT(pvURL != NULL);
	ASSERT(pvFrame != NULL);
	ASSERT(pvStatusCode != NULL);
	ASSERT(pvbCancel != NULL);
	ASSERT(V_VT(pvURL) == VT_BSTR);
	ASSERT(V_VT(pvFrame) == VT_BSTR);

	CString strURL(V_BSTR(pvURL));
	CString strFrame(V_BSTR(pvFrame));
	DWORD dwError = V_I4(pvStatusCode);

	BOOL bCancel = FALSE;
	// notify the user's class
	OnNavigateError(strURL, strFrame, dwError, &bCancel);

	if (pvbCancel)
		*pvbCancel = bCancel ? AFX_OLE_TRUE : AFX_OLE_FALSE;
}

void CHtmlView::OnEditCopy() 
{
	ExecFormsCommand(IDM_COPY, NULL, NULL);
	return;
}

void CHtmlView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	BOOL bEnabled = FALSE;

	// Since input variables aren't touched for failure case of
	// QueryCommand(), we can ignore return value.
	QueryFormsCommand(IDM_COPY, NULL, &bEnabled, NULL);
	pCmdUI->Enable(bEnabled);
}

void CHtmlView::OnEditCut() 
{
	ExecFormsCommand(IDM_CUT, NULL, NULL);
	return;
}

void CHtmlView::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
	BOOL bEnabled = FALSE;

	// Since input variables aren't touched for failure case of
	// QueryCommand(), we can ignore return value.
	QueryFormsCommand(IDM_CUT, NULL, &bEnabled, NULL);
	pCmdUI->Enable(bEnabled);
}

void CHtmlView::OnEditPaste() 
{
	ExecFormsCommand(IDM_PASTE, NULL, NULL);
	return;
}

void CHtmlView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
	BOOL bEnabled = FALSE;

	// Since input variables aren't touched for failure case of
	// QueryCommand(), we can ignore return value.
	QueryFormsCommand(IDM_PASTE, NULL, &bEnabled, NULL);
	pCmdUI->Enable(bEnabled);
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlView Events

void CHtmlView::OnProgressChange(long lProgress, long lProgressMax)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(lProgress);
	UNUSED_ALWAYS(lProgressMax);
}

void CHtmlView::OnCommandStateChange(long lCommand, BOOL bEnable)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(lCommand);
	UNUSED_ALWAYS(bEnable);
}

void CHtmlView::OnDownloadBegin()
{
	// user will override to handle this notification
}

void CHtmlView::OnDownloadComplete()
{
	// user will override to handle this notification
}

void CHtmlView::OnTitleChange(LPCTSTR lpszText)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(lpszText);
}

void CHtmlView::OnPropertyChange(LPCTSTR lpszProperty)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(lpszProperty);
}

void CHtmlView::OnNewWindow2(LPDISPATCH* ppDisp, BOOL* bCancel)
{
	// default to continuing
	*bCancel = FALSE;

	// user will override to handle this notification
	UNUSED_ALWAYS(ppDisp);
}

void CHtmlView::OnDocumentComplete(LPCTSTR lpszURL)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(lpszURL);
}

void CHtmlView::OnQuit()
{
	// user will override to handle this notification
}

void CHtmlView::OnVisible(BOOL bVisible)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(bVisible);
}

void CHtmlView::OnToolBar(BOOL bToolBar)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(bToolBar);
}

void CHtmlView::OnMenuBar(BOOL bMenuBar)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(bMenuBar);
}

void CHtmlView::OnStatusBar(BOOL bStatusBar)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(bStatusBar);
}

void CHtmlView::OnFullScreen(BOOL bFullScreen)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(bFullScreen);
}

void CHtmlView::OnTheaterMode(BOOL bTheaterMode)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(bTheaterMode);
}

void CHtmlView::OnNavigateComplete2(LPCTSTR lpszURL)
{
	// user will override to handle this notification
	UNUSED_ALWAYS(lpszURL);
}

void CHtmlView::OnBeforeNavigate2(LPCTSTR lpszURL, DWORD nFlags,
	LPCTSTR lpszTargetFrameName, CByteArray& baPostData,
	LPCTSTR lpszHeaders, BOOL* bCancel)
{
	// default to continuing
	*bCancel = FALSE;

	// user will override to handle this notification
	UNUSED_ALWAYS(lpszURL);
	UNUSED_ALWAYS(nFlags);
	UNUSED_ALWAYS(lpszTargetFrameName);
	UNUSED_ALWAYS(baPostData);
	UNUSED_ALWAYS(lpszHeaders);
}

void CHtmlView::OnStatusTextChange(LPCTSTR pszText)
{
	// try to set the status bar text via the frame

	CFrameWnd* pFrame = GetParentFrame();
	if (pFrame != NULL)
		pFrame->SetMessageText(pszText);
}

void CHtmlView::OnNavigateError(LPCTSTR lpszURL, LPCTSTR lpszFrame, DWORD dwError, BOOL *pbCancel)
{
	// default to continuing
	*pbCancel = FALSE;

	// user will override to handle this notification
	UNUSED_ALWAYS(lpszURL);
	UNUSED_ALWAYS(lpszFrame);

	TRACE(traceHtml, 0, "OnNavigateError called with status scode = 0x%X\n", dwError);
}

extern "C" void _AfxHtmlEditCtrlFakeEntry()
{
	ASSERT( FALSE );
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlEditCtrl
CHtmlEditCtrl::CHtmlEditCtrl()
{
}

CHtmlEditCtrl::~CHtmlEditCtrl()
{
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlEditCtrl message handlers
BEGIN_EVENTSINK_MAP(CHtmlEditCtrl, CWnd)
	ON_EVENT_REFLECT(CHtmlEditCtrl, 252 /* NavigateComplete2 */, _OnNavigateComplete2, VTS_DISPATCH VTS_PVARIANT)
END_EVENTSINK_MAP()

void CHtmlEditCtrl::_OnNavigateComplete2(LPDISPATCH pDisp, VARIANT FAR* URL)
{
	SetDesignMode(TRUE);
}


BOOL CHtmlEditCtrl::GetDHtmlDocument(IHTMLDocument2 **ppDocument) const
{
	if(ppDocument == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}
	
	*ppDocument = NULL;
	
	CHtmlEditCtrl *pThis = const_cast<CHtmlEditCtrl*>(this);
	CComQIPtr<IWebBrowser2> pBrowserApp = pThis->GetControlUnknown();
	ASSERT(pBrowserApp != NULL);
	if (pBrowserApp)
	{
		CComPtr<IDispatch> spDispDocument;
		HRESULT hr = pBrowserApp->get_Document(&spDispDocument);
		if (SUCCEEDED(hr) && spDispDocument)
		{
			return S_OK == spDispDocument->QueryInterface(ppDocument) ? TRUE : FALSE;
		}
	}
	return FALSE;
}

BOOL CHtmlEditCtrl::Create(LPCTSTR lpszWindowName, DWORD /*dwStyle*/, const RECT& rect, CWnd* pParentWnd,
						   int nID, CCreateContext *pContext) 
{
	BOOL bRet = FALSE;
	// create the control window

	AfxEnableControlContainer();
	if (CreateControl(CLSID_WebBrowser, lpszWindowName,
				WS_VISIBLE | WS_CHILD, rect, pParentWnd, nID))
	{
		// in order to put the webbrowser in design mode, you must
		// first load a document into it. "about:blank" seems to
		// be the safest thing to load for a good starting point.
		CComQIPtr<IWebBrowser2> pBrowserApp = GetControlUnknown();
		ASSERT(pBrowserApp);
		if (pBrowserApp)
		{
			CComVariant vEmpty;
			LPCTSTR szDoc = GetStartDocument();
			if (szDoc)
			{
				CComBSTR bstrStart(szDoc);
				if (S_OK == pBrowserApp->Navigate(bstrStart, 
													&vEmpty,
													&vEmpty,
													&vEmpty,
													&vEmpty))
				{
					bRet = TRUE;
				}
			}
			else
				bRet = TRUE;

		}
	}

	if (!bRet)
		DestroyWindow();
	return bRet;
}

LPCTSTR CHtmlEditCtrl::GetStartDocument()
{
	LPCTSTR szDefaultDoc = _T("about:blank");
	return szDefaultDoc;
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlEditView
BEGIN_MESSAGE_MAP(CHtmlEditView, CFormView)
	ON_COMMAND(ID_FILE_PRINT, &CHtmlEditView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CHtmlEditView::OnFilePrint)
	ON_WM_PAINT()
	ON_WM_SIZE()
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////
// CHtmlEditView

void CHtmlEditView::OnPaint()
{
	Default();
}

CHtmlEditView::CHtmlEditView()
{
}

CHtmlEditView::~CHtmlEditView()
{
}

LPCTSTR CHtmlEditView::GetStartDocument()
{
	LPCTSTR szDefaultUrl = _T("about:blank");
	return szDefaultUrl;
}

BOOL CHtmlEditView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
	DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
	CCreateContext* pContext) 
{
	// create the view window itself
	if (!CHtmlView::Create(lpszClassName, lpszWindowName,
				dwStyle, rect, pParentWnd,	nID, pContext))
	{
		return FALSE;
	}
	LPCTSTR szDoc = GetStartDocument();
	if (szDoc)
		Navigate(szDoc);
	return TRUE;
}

BOOL CHtmlEditView::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// if it's not something we're intersted in, let it go to the base
	if (nCode < (int)CN_UPDATE_COMMAND_UI)
		return CHtmlView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

	// check for command availability
	BOOL bHasExecFunc = FALSE;
	UINT uiElemType = AFX_UI_ELEMTYPE_NORMAL;
	UINT dhtmlCmdID = GetDHtmlCommandMapping(nID, bHasExecFunc, uiElemType);
	if (dhtmlCmdID == AFX_INVALID_DHTML_CMD_ID)
	{
		// No mapping for this command. Use normal routing
		return CHtmlView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
	}

	long nStatus = QueryStatus(dhtmlCmdID);

	if (nCode == CN_UPDATE_COMMAND_UI)
	{
		// just checking status
		CCmdUI *pUI = static_cast<CCmdUI*>(pExtra);
		if (pUI)
		{
			if(!(nStatus & OLECMDF_LATCHED || nStatus & OLECMDF_ENABLED))
			{
				pUI->Enable(FALSE);
				if (uiElemType & AFX_UI_ELEMTYPE_CHECBOX)
				{
					if (nStatus & OLECMDF_LATCHED)
						pUI->SetCheck(TRUE);
					else
						pUI->SetCheck(FALSE);
				}
				else if (uiElemType & AFX_UI_ELEMTYPE_RADIO)
				{
					if (nStatus & OLECMDF_LATCHED)
						pUI->SetRadio(TRUE);
					else
						pUI->SetRadio(FALSE);
				}

			}
			else
			{
				pUI->Enable(TRUE); // enable
				// check to see if we need to do any other state
				// stuff
				if (uiElemType & AFX_UI_ELEMTYPE_CHECBOX)
				{
					if (nStatus & OLECMDF_LATCHED)
						pUI->SetCheck(TRUE);
					else
						pUI->SetCheck(FALSE);
				}
				else if (uiElemType & AFX_UI_ELEMTYPE_RADIO)
				{
					if (nStatus & OLECMDF_LATCHED)
						pUI->SetRadio(TRUE);
					else
						pUI->SetRadio(FALSE);
				}
			}
			return TRUE;
		}
		return FALSE;
	}

	// querystatus for this DHTML command to make sure it is enabled
	if(!(nStatus & OLECMDF_LATCHED || nStatus & OLECMDF_ENABLED))
	{

		// trying to execute a disabled command
		TRACE(traceHtml, 0, "Not executing disabled dhtml editing command %d", dhtmlCmdID);
		return TRUE;
	}

	if (bHasExecFunc)
	{
		return ExecHandler(nID);		
	}

	return S_OK == ExecCommand(dhtmlCmdID, OLECMDEXECOPT_DODEFAULT, NULL, NULL) ? TRUE : FALSE;
}

BOOL CHtmlEditView::GetDHtmlDocument(IHTMLDocument2 **ppDocument) const
{
	CComPtr<IDispatch> spDispDocument;
	if (!ppDocument)
		return FALSE;
	*ppDocument = NULL;

	HRESULT hr = m_pBrowserApp->get_Document(&spDispDocument);
	if (SUCCEEDED(hr) && spDispDocument)
	{
		return S_OK == spDispDocument->QueryInterface(ppDocument) ? TRUE : FALSE;
	}

	return FALSE;
}

void CHtmlEditView::OnNavigateComplete2(LPCTSTR strURL)
{
	SetDesignMode(TRUE);
}

BOOL CHtmlEditView::OnPreparePrinting(CPrintInfo* pInfo)
{
	return TRUE;
}

UINT CHtmlEditView::GetDHtmlCommandMapping(UINT nIDWindowsCommand, BOOL& bHasExecFunc, UINT& uiElemType)
{
	uiElemType = AFX_UI_ELEMTYPE_NORMAL;
	bHasExecFunc = FALSE;
	return AFX_INVALID_DHTML_CMD_ID;
}

BOOL CHtmlEditView::ExecHandler(UINT nCmdID)
{
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CHtmlEditView diagnostics

#ifdef _DEBUG
void CHtmlEditView::AssertValid() const
{
	CFormView::AssertValid();
}

void CHtmlEditView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

CHtmlEditDoc::CHtmlEditDoc()
{
}

CHtmlEditDoc::~CHtmlEditDoc()
{
}

CHtmlEditView* CHtmlEditDoc::GetView() const
{
	CHtmlEditView* pHtmlView = NULL;

	POSITION pos = GetFirstViewPosition();
	while (pos != NULL)
	{
		CView* pView = GetNextView(pos);
		pHtmlView = DYNAMIC_DOWNCAST(CHtmlEditView, pView);
		if (pHtmlView != NULL)
			break;
	}

	return pHtmlView;
}

void CHtmlEditDoc::DeleteContents()
{
	CHtmlEditView* pView = GetView();
	if (pView)
	{
		pView->NewDocument();
		pView->Navigate(pView->GetStartDocument());
	}
}

BOOL CHtmlEditDoc::IsModified()
{
	CHtmlEditView* pView = GetView();

	if (pView)
	{
		return (pView->GetIsDirty() != S_FALSE);
	}

	return FALSE;
}

BOOL CHtmlEditDoc::OpenURL(LPCTSTR lpszURL)
{
	BOOL bRet = FALSE;
	CHtmlEditView* pView = GetView();
	if (pView != NULL && lpszURL != NULL && *lpszURL != '\0')
	{
		pView->Navigate(lpszURL);
		bRet = TRUE;
	}

	return bRet;
}

BOOL CHtmlEditDoc::OnOpenDocument(LPCTSTR lpszFileName)
{
	BOOL bRet = FALSE;
	CHtmlEditView* pView = GetView();
	if (pView != NULL)
	{
		pView->Navigate(lpszFileName);
		SetTitle(lpszFileName);
		bRet = TRUE;
	}

	OnDocumentEvent(onAfterNewDocument);
	return bRet;
}

BOOL CHtmlEditDoc::OnSaveDocument(LPCTSTR lpszFileName)
{
	BOOL bRet = FALSE;
	CHtmlEditView *pView = GetView();
	if (pView != NULL)
	{
		CFile file;
		if (file.Open(lpszFileName, CFile::modeCreate|CFile::modeWrite))
		{
			CArchive ar(&file, CArchive::store);
			CArchiveStream as(&ar);
			CComPtr<IHTMLDocument2> spHTMLDocument;
			CComQIPtr<IPersistStreamInit> spPSI;
			pView->GetDHtmlDocument(&spHTMLDocument);
			if (spHTMLDocument)
			{
				spPSI = spHTMLDocument;
				if (spPSI)
				{
					if (S_OK == spPSI->Save((IStream*)&as, TRUE))
					{
						SetModifiedFlag(FALSE);
						bRet = TRUE;
					}
				}
			}
		}
	}
	return bRet;
}

BOOL CHtmlEditDoc::OnNewDocument()
{
#ifdef _DEBUG
	if(IsModified())
		TRACE(traceAppMsg, 0, "Warning: OnNewDocument replaces an unsaved document.\n");
#endif

	DeleteContents(); // we want CHtmlEditDoc's DeleteContents to be called here
	m_strPathName.Empty();      // no path name yet
	SetModifiedFlag(FALSE);     // make clean

	OnDocumentEvent(onAfterNewDocument);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CHtmlEditDoc diagnostics

#ifdef _DEBUG
void CHtmlEditDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CHtmlEditDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

// expand inlines for Html functions
#define _AFXHTML_INLINE
#include "afxhtml.inl"

#endif //!_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////
// Pre-startup code


IMPLEMENT_DYNCREATE(CHtmlView, CFormView)
IMPLEMENT_DYNCREATE(CHtmlEditView, CHtmlView)
IMPLEMENT_DYNAMIC(CHtmlEditDoc, CDocument)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\viewscrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <atlimage.h>


#define AFX_CX_ANCHOR_BITMAP	32
#define AFX_CY_ANCHOR_BITMAP	32

#ifndef SM_MOUSEWHEELPRESENT
#define SM_MOUSEWHEELPRESENT 75
#endif

#ifndef SPI_GETWHEELSCROLLLINES
#define SPI_GETWHEELSCROLLLINES  104
#endif

/////////////////////////////////////////////////////////////////////////////
// CScrollView

BEGIN_MESSAGE_MAP(CScrollView, CView)
	//{{AFX_MSG_MAP(CScrollView)
	ON_WM_SIZE()
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_MOUSEWHEEL()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_MBUTTONDOWN, &CScrollView::HandleMButtonDown)
	ON_MESSAGE(WM_PRINTCLIENT, &CScrollView::OnPrintClient)
END_MESSAGE_MAP()

// Special mapping modes just for CScrollView implementation
#define MM_NONE             0
#define MM_SCALETOFIT       (-1)
	// standard GDI mapping modes are > 0

extern BOOL _afxGotScrollLines; // defined in wincore.cpp

UINT PASCAL _AfxGetMouseScrollLines()
{
	static UINT uCachedScrollLines;

	// if we've already got it and we're not refreshing,
	// return what we've already got

	if (_afxGotScrollLines)
		return uCachedScrollLines;

	// see if we can find the mouse window

	_afxGotScrollLines = TRUE;

	static UINT msgGetScrollLines;
	static WORD nRegisteredMessage;

	// couldn't use the window -- try system settings
	uCachedScrollLines = 3; // reasonable default
	::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &uCachedScrollLines, 0);

	return uCachedScrollLines;
}

/////////////////////////////////////////////////////////////////////////////
//

#define ID_TIMER_TRACKING	0xE000

class _AFX_MOUSEANCHORWND : public CWnd
{
private:
   using CWnd::Create;

public:
	_AFX_MOUSEANCHORWND(CPoint& ptAnchor);
	~_AFX_MOUSEANCHORWND();

	BOOL Create(CScrollView* pParent);
	void SetBitmap(UINT nID);

	CRect m_rectDrag;
	CPoint m_ptAnchor;
	BOOL m_bQuitTracking;
	UINT m_nAnchorID;
	HCURSOR m_hAnchorCursor;

	virtual BOOL PreTranslateMessage(MSG* pMsg);

	afx_msg void OnPaint();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(_AFX_MOUSEANCHORWND, CWnd)
	ON_WM_PAINT()
	ON_WM_TIMER()
END_MESSAGE_MAP()

_AFX_MOUSEANCHORWND::_AFX_MOUSEANCHORWND(CPoint& ptAnchor)
: m_ptAnchor(ptAnchor), m_bQuitTracking(FALSE)
{
}

_AFX_MOUSEANCHORWND::~_AFX_MOUSEANCHORWND()
{
}

BOOL _AFX_MOUSEANCHORWND::PreTranslateMessage(MSG* pMsg)
{
	ENSURE_ARG(pMsg != NULL);
	BOOL bRetVal = FALSE;

	switch (pMsg->message)
	{
	// any of these messages cause us to quit scrolling
	case WM_MOUSEWHEEL:
	case WM_KEYDOWN:
	case WM_CHAR:
	case WM_KEYUP:
	case WM_SYSKEYDOWN:
	case WM_SYSKEYUP:
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_MBUTTONDOWN:
		m_bQuitTracking = TRUE;
		bRetVal = TRUE;
		break;

	// Button up message depend on the position of cursor
	// This enables the user to click and drag for a quick pan.
	case WM_MBUTTONUP:
		{
			CPoint pt(pMsg->lParam);
			ClientToScreen(&pt);
			if (!PtInRect(&m_rectDrag, pt))
				m_bQuitTracking = TRUE;
			bRetVal = TRUE;
		}
		break;
	}

	return bRetVal;
}

void _AFX_MOUSEANCHORWND::OnTimer(UINT_PTR nIDEvent)
{
	ASSERT(nIDEvent == ID_TIMER_TRACKING);
	UNUSED(nIDEvent);

	int nCursor = -1;

	CPoint ptNow;
	GetCursorPos(&ptNow);

	CRect rectClient;
	GetWindowRect(&rectClient);

	// decide where the relative position of the cursor is
	// pick a cursor that points where we're going
	nCursor = 0;

	// if vertical scrolling allowed, consider vertical
	// directions for the cursor we'll show
	if (m_nAnchorID == AFX_IDC_MOUSE_ORG_HV || m_nAnchorID == AFX_IDC_MOUSE_ORG_VERT)
	{
		if (ptNow.y < rectClient.top)
			nCursor = AFX_IDC_MOUSE_PAN_N;
		else if (ptNow.y > rectClient.bottom)
			nCursor = AFX_IDC_MOUSE_PAN_S;
	}

	// if horizontal scrolling allowed, cosider horizontal
	// directions for the cursor, too. Only consider diagonal
	// if we can scroll both ways.
	if (m_nAnchorID == AFX_IDC_MOUSE_ORG_HV || m_nAnchorID == AFX_IDC_MOUSE_ORG_HORZ)
	{
		if (ptNow.x < rectClient.left)
		{
			if (nCursor == 0)
				nCursor = AFX_IDC_MOUSE_PAN_W;
			else if (m_nAnchorID == AFX_IDC_MOUSE_ORG_HV)
				nCursor--;
		}
		else if (ptNow.x > rectClient.right)
		{
			if (nCursor == 0)
				nCursor = AFX_IDC_MOUSE_PAN_E;
			else if (m_nAnchorID == AFX_IDC_MOUSE_ORG_HV)
				nCursor++;
		}
	}

	if (m_bQuitTracking)
	{
		// Someone knows we should stop playing with the mouse
		// kill the timer, quit capturing the mouse, clear the cursor,
		// destroy the window, and make sure that CScrollView knows the
		// window isn't valid anymore.

		KillTimer(ID_TIMER_TRACKING);
		ReleaseCapture();
		SetCursor(NULL);
		CScrollView* pView = (CScrollView*) GetOwner();
		DestroyWindow();
		delete pView->m_pAnchorWindow;
		pView->m_pAnchorWindow = NULL;
	}
	else if (nCursor == 0)
	{
		// The cursor is over the anchor window; use a cursor that
		// looks like the anchor bitmap.
		SetCursor(m_hAnchorCursor);
	}
	else
	{
		// We're still actively tracking, so we need to find a cursor and
		// set it up.

		HINSTANCE hInst = AfxFindResourceHandle(ATL_MAKEINTRESOURCE(nCursor),
			ATL_RT_GROUP_CURSOR);
		HICON hCursor = ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(nCursor));
		ASSERT(hCursor != NULL);
		SetCursor(hCursor);

		// ask the view how much to scroll this time
		CSize sizeDistance; // = ptNow - rectClient.CenterPoint();

		if (ptNow.x > rectClient.right)
			sizeDistance.cx = ptNow.x - rectClient.right;
		else if (ptNow.x < rectClient.left)
			sizeDistance.cx = ptNow.x - rectClient.left;
		else
			sizeDistance.cx = 0;

		if (ptNow.y > rectClient.bottom)
			sizeDistance.cy = ptNow.y - rectClient.bottom;
		else if (ptNow.y < rectClient.top)
			sizeDistance.cy = ptNow.y - rectClient.top;
		else
			sizeDistance.cy = 0;

		CScrollView* pView = (CScrollView*) GetOwner();

		CSize sizeToScroll = pView->GetWheelScrollDistance(sizeDistance,
			m_nAnchorID == AFX_IDC_MOUSE_ORG_HV || m_nAnchorID == AFX_IDC_MOUSE_ORG_HORZ,
			m_nAnchorID == AFX_IDC_MOUSE_ORG_HV || m_nAnchorID == AFX_IDC_MOUSE_ORG_VERT );

		// hide ourselves to minimize flicker
		ShowWindow(SW_HIDE);

		CWnd* pViewParent = pView->GetParent();
		CSplitterWnd* pSplitter = DYNAMIC_DOWNCAST(CSplitterWnd, pViewParent);

		// if it is in a splitter, then we need to handle it accordingly
		if (pSplitter == NULL)
		{
			// scroll the view
			pView->OnScrollBy(sizeToScroll, TRUE);
		}
		else
		{
			// ask the splitter to scroll
			pSplitter->DoScrollBy(pView, sizeToScroll, TRUE);
		}	

		// restore ourselves and repaint
		// SetFocus();
		UpdateWindow();

		// move ourselves back (since we're a child, we scroll too!)
		SetWindowPos(&CWnd::wndTop,
			m_ptAnchor.x - AFX_CX_ANCHOR_BITMAP/2,
			m_ptAnchor.y - AFX_CY_ANCHOR_BITMAP/2, 0, 0,
			SWP_NOACTIVATE | SWP_NOSIZE | SWP_SHOWWINDOW);
	}
}

void _AFX_MOUSEANCHORWND::SetBitmap(UINT nID)
{
	HINSTANCE hInst = AfxFindResourceHandle(ATL_MAKEINTRESOURCE(nID), ATL_RT_GROUP_CURSOR);
	ASSERT(hInst != NULL);
	m_hAnchorCursor = ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(nID));
	m_nAnchorID = nID;
}

BOOL _AFX_MOUSEANCHORWND::Create(CScrollView* pParent)
{
	ENSURE_VALID(pParent);
	ASSERT_KINDOF(CScrollView, pParent);

	pParent->ClientToScreen(&m_ptAnchor);

	m_rectDrag.top = m_ptAnchor.y - GetSystemMetrics(SM_CYDOUBLECLK);
	m_rectDrag.bottom = m_ptAnchor.y + GetSystemMetrics(SM_CYDOUBLECLK);
	m_rectDrag.left = m_ptAnchor.x - GetSystemMetrics(SM_CXDOUBLECLK);
	m_rectDrag.right = m_ptAnchor.x + GetSystemMetrics(SM_CXDOUBLECLK);

	BOOL bRetVal = 
		CreateEx(WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
			AfxRegisterWndClass(CS_SAVEBITS),
			NULL,
			WS_POPUP,
			m_ptAnchor.x - AFX_CX_ANCHOR_BITMAP/2,
			m_ptAnchor.y - AFX_CY_ANCHOR_BITMAP/2,
			AFX_CX_ANCHOR_BITMAP, AFX_CY_ANCHOR_BITMAP,
			NULL, NULL);
	SetOwner(pParent);

	if (bRetVal)
	{
		// set window's region for round effect
		CRgn rgn;
		rgn.CreateEllipticRgn(0, 0, AFX_CX_ANCHOR_BITMAP, AFX_CY_ANCHOR_BITMAP);
		SetWindowRgn(rgn, TRUE);

		// fire timer ever 50ms
		SetCapture();
		SetTimer(ID_TIMER_TRACKING, 50, NULL);
	}
#ifdef _DEBUG
	else
	{
		DWORD dwLastError = GetLastError();
		TRACE(traceAppMsg, 0, "Failed to create mouse anchor window! Last error is 0x%8.8X\n",
			dwLastError);
	}
#endif

	return bRetVal;
}

void _AFX_MOUSEANCHORWND::OnPaint()
{
	CPaintDC dc(this);
	CRect rect;
	GetClientRect(&rect);

	// shrink a pixel in every dimension for border
	rect.DeflateRect(1, 1, 1, 1);
	dc.Ellipse(rect);

	// draw anchor shape
	dc.DrawIcon(0, 0, m_hAnchorCursor);
}

/////////////////////////////////////////////////////////////////////////////
// CScrollView construction/destruction

CScrollView::CScrollView()
{
	m_pAnchorWindow = NULL;
	m_nMapMode = MM_NONE;

	m_totalLog.cx = m_totalLog.cy = 0;
	m_totalDev.cx = m_totalDev.cy = 0;
	m_pageDev.cx  = m_pageDev.cy  = 0;
	m_lineDev.cx  = m_lineDev.cy  = 0;

	m_bCenter = FALSE;
	m_bInsideUpdate = FALSE;
}

CScrollView::~CScrollView()
{
	if (m_pAnchorWindow != NULL)
		m_pAnchorWindow->DestroyWindow();
	delete m_pAnchorWindow;
}

/////////////////////////////////////////////////////////////////////////////
// CScrollView painting

void CScrollView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
	ASSERT_VALID(pDC);

	if (m_bInitialRedraw)
	{
		return;
	}

#ifdef _DEBUG
	if (m_nMapMode == MM_NONE)
	{
		TRACE(traceAppMsg, 0, "Error: must call SetScrollSizes() or SetScaleToFitSize()");
		TRACE(traceAppMsg, 0, "\tbefore painting scroll view.\n");
		ASSERT(FALSE);
		return;
	}
#endif //_DEBUG
	ASSERT(m_totalDev.cx >= 0 && m_totalDev.cy >= 0);
	switch (m_nMapMode)
	{
	case MM_SCALETOFIT:
		pDC->SetMapMode(MM_ANISOTROPIC);
		pDC->SetWindowExt(m_totalLog);  // window is in logical coordinates
		pDC->SetViewportExt(m_totalDev);
		if (m_totalDev.cx == 0 || m_totalDev.cy == 0)
			TRACE(traceAppMsg, 0, "Warning: CScrollView scaled to nothing.\n");
		break;

	default:
		ASSERT(m_nMapMode > 0);
		pDC->SetMapMode(m_nMapMode);
		break;
	}

	CPoint ptVpOrg(0, 0);       // assume no shift for printing
	if (!pDC->IsPrinting())
	{
		ASSERT(pDC->GetWindowOrg() == CPoint(0,0));

		// by default shift viewport origin in negative direction of scroll
		ptVpOrg = -GetDeviceScrollPosition();

		if (m_bCenter)
		{
			CRect rect;
			GetClientRect(&rect);

			// if client area is larger than total device size,
			// override scroll positions to place origin such that
			// output is centered in the window
			if (m_totalDev.cx < rect.Width())
				ptVpOrg.x = (rect.Width() - m_totalDev.cx) / 2;
			if (m_totalDev.cy < rect.Height())
				ptVpOrg.y = (rect.Height() - m_totalDev.cy) / 2;
		}
	}
	pDC->SetViewportOrg(ptVpOrg);

	CView::OnPrepareDC(pDC, pInfo);     // For default Printing behavior
}

/////////////////////////////////////////////////////////////////////////////
// Set mode and scaling/scrolling sizes

void CScrollView::SetScaleToFitSize(SIZE sizeTotal)
{
	// Note: It is possible to set sizeTotal members to negative values to
	//  effectively invert either the X or Y axis.

	ASSERT(m_hWnd != NULL);
	m_nMapMode = MM_SCALETOFIT;     // special internal value
	m_totalLog = sizeTotal;

	// reset and turn any scroll bars off
	if (m_hWnd != NULL && (GetStyle() & (WS_HSCROLL|WS_VSCROLL)))
	{
		SetScrollPos(SB_HORZ, 0);
		SetScrollPos(SB_VERT, 0);
		EnableScrollBarCtrl(SB_BOTH, FALSE);
		ASSERT((GetStyle() & (WS_HSCROLL|WS_VSCROLL)) == 0);
	}

	CRect rectT;
	GetClientRect(rectT);
	m_totalDev = rectT.Size();

	if (m_hWnd != NULL)
	{
		// window has been created, invalidate
		UpdateBars();
		Invalidate(TRUE);
	}
}

const AFX_DATADEF SIZE CScrollView::sizeDefault = {0,0};

void CScrollView::SetScrollSizes(int nMapMode, SIZE sizeTotal,
	const SIZE& sizePage, const SIZE& sizeLine)
{
	ASSERT(sizeTotal.cx >= 0 && sizeTotal.cy >= 0);
	ASSERT(nMapMode > 0);
	ASSERT(nMapMode != MM_ISOTROPIC && nMapMode != MM_ANISOTROPIC);

	int nOldMapMode = m_nMapMode;
	m_nMapMode = nMapMode;
	m_totalLog = sizeTotal;

	//BLOCK: convert logical coordinate space to device coordinates
	{
		CWindowDC dc(NULL);
		ASSERT(m_nMapMode > 0);
		dc.SetMapMode(m_nMapMode);

		// total size
		m_totalDev = m_totalLog;
		dc.LPtoDP((LPPOINT)&m_totalDev);
		m_pageDev = sizePage;
		dc.LPtoDP((LPPOINT)&m_pageDev);
		m_lineDev = sizeLine;
		dc.LPtoDP((LPPOINT)&m_lineDev);
		if (m_totalDev.cy < 0)
			m_totalDev.cy = -m_totalDev.cy;
		if (m_pageDev.cy < 0)
			m_pageDev.cy = -m_pageDev.cy;
		if (m_lineDev.cy < 0)
			m_lineDev.cy = -m_lineDev.cy;
	} // release DC here

	// now adjust device specific sizes
	ASSERT(m_totalDev.cx >= 0 && m_totalDev.cy >= 0);
	if (m_pageDev.cx == 0)
		m_pageDev.cx = m_totalDev.cx / 10;
	if (m_pageDev.cy == 0)
		m_pageDev.cy = m_totalDev.cy / 10;
	if (m_lineDev.cx == 0)
		m_lineDev.cx = m_pageDev.cx / 10;
	if (m_lineDev.cy == 0)
		m_lineDev.cy = m_pageDev.cy / 10;

	if (m_hWnd != NULL)
	{
		// window has been created, invalidate now
		UpdateBars();
		if (nOldMapMode != m_nMapMode)
			Invalidate(TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Getting information

CPoint CScrollView::GetScrollPosition() const   // logical coordinates
{
	if (m_nMapMode == MM_SCALETOFIT)
	{
		return CPoint(0, 0);    // must be 0,0
	}

	CPoint pt = GetDeviceScrollPosition();

	if (m_bCenter)
	{
		CRect rect;
		GetClientRect(&rect);

		// if client area is larger than total device size,
		// the scroll positions are overridden to place origin such that
		// output is centered in the window
		// GetDeviceScrollPosition() must reflect this

		if (m_totalDev.cx < rect.Width())
			pt.x = -((rect.Width() - m_totalDev.cx) / 2);
		if (m_totalDev.cy < rect.Height())
			pt.y = -((rect.Height() - m_totalDev.cy) / 2);

	}
	// pt may be negative if m_bCenter is set

	if (m_nMapMode != MM_TEXT)
	{
		ASSERT(m_nMapMode > 0); // must be set
		CWindowDC dc(NULL);
		dc.SetMapMode(m_nMapMode);
		dc.DPtoLP((LPPOINT)&pt);
	}
	return pt;
}

void CScrollView::ScrollToPosition(POINT pt)    // logical coordinates
{
	ASSERT(m_nMapMode > 0);     // not allowed for shrink to fit
	if (m_nMapMode != MM_TEXT)
	{
		CWindowDC dc(NULL);
		dc.SetMapMode(m_nMapMode);
		dc.LPtoDP((LPPOINT)&pt);
	}

	// now in device coordinates - limit if out of range
	int xMax = GetScrollLimit(SB_HORZ);
	int yMax = GetScrollLimit(SB_VERT);
	if (pt.x < 0)
		pt.x = 0;
	else if (pt.x > xMax)
		pt.x = xMax;
	if (pt.y < 0)
		pt.y = 0;
	else if (pt.y > yMax)
		pt.y = yMax;

	ScrollToDevicePosition(pt);
}

CPoint CScrollView::GetDeviceScrollPosition() const
{
	CPoint pt(GetScrollPos(SB_HORZ), GetScrollPos(SB_VERT));
	ASSERT(pt.x >= 0 && pt.y >= 0);
	return pt;
}

void CScrollView::GetDeviceScrollSizes(int& nMapMode, SIZE& sizeTotal,
			SIZE& sizePage, SIZE& sizeLine) const
{
	if (m_nMapMode <= 0)
		TRACE(traceAppMsg, 0, "Warning: CScrollView::GetDeviceScrollSizes returning invalid mapping mode.\n");
	nMapMode = m_nMapMode;
	sizeTotal = m_totalDev;
	sizePage = m_pageDev;
	sizeLine = m_lineDev;
}

void CScrollView::ScrollToDevicePosition(POINT ptDev)
{
	ASSERT(ptDev.x >= 0);
	ASSERT(ptDev.y >= 0);

	// Note: ScrollToDevicePosition can and is used to scroll out-of-range
	//  areas as far as CScrollView is concerned -- specifically in
	//  the print-preview code.  Since OnScrollBy makes sure the range is
	//  valid, ScrollToDevicePosition does not vector through OnScrollBy.

	int xOrig = GetScrollPos(SB_HORZ);
	SetScrollPos(SB_HORZ, ptDev.x);
	int yOrig = GetScrollPos(SB_VERT);
	SetScrollPos(SB_VERT, ptDev.y);
	ScrollWindow(xOrig - ptDev.x, yOrig - ptDev.y);
}

CSize CScrollView::GetWheelScrollDistance(CSize sizeDistance, BOOL bHorz, BOOL bVert)
{
	CSize sizeRet;

	if (bHorz)
		sizeRet.cx = sizeDistance.cx / 10;
	else
		sizeRet.cx = 0;

	if (bVert)
		sizeRet.cy = sizeDistance.cy / 10;
	else
		sizeRet.cy = 0;

	return sizeRet;
}

/////////////////////////////////////////////////////////////////////////////
// Other helpers

void CScrollView::FillOutsideRect(CDC* pDC, CBrush* pBrush)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBrush);

	// fill rect outside the image
	CRect rect;
	GetClientRect(rect);
	ASSERT(rect.left == 0 && rect.top == 0);
	rect.left = m_totalDev.cx;
	if (!rect.IsRectEmpty())
		pDC->FillRect(rect, pBrush);    // vertical strip along the side
	rect.left = 0;
	rect.right = m_totalDev.cx;
	rect.top = m_totalDev.cy;
	if (!rect.IsRectEmpty())
		pDC->FillRect(rect, pBrush);    // horizontal strip along the bottom
}

void CScrollView::ResizeParentToFit(BOOL bShrinkOnly)
{
	// adjust parent rect so client rect is appropriate size
	ASSERT(m_nMapMode != MM_NONE);  // mapping mode must be known

	// determine current size of the client area as if no scrollbars present
	CRect rectClient;
	GetWindowRect(rectClient);
	CRect rect = rectClient;
	CalcWindowRect(rect);
	rectClient.left += rectClient.left - rect.left;
	rectClient.top += rectClient.top - rect.top;
	rectClient.right -= rect.right - rectClient.right;
	rectClient.bottom -= rect.bottom - rectClient.bottom;
	rectClient.OffsetRect(-rectClient.left, -rectClient.top);
	ASSERT(rectClient.left == 0 && rectClient.top == 0);

	// determine desired size of the view
	CRect rectView(0, 0, m_totalDev.cx, m_totalDev.cy);
	if (bShrinkOnly)
	{
		if (rectClient.right <= m_totalDev.cx)
			rectView.right = rectClient.right;
		if (rectClient.bottom <= m_totalDev.cy)
			rectView.bottom = rectClient.bottom;
	}
	CalcWindowRect(rectView, CWnd::adjustOutside);
	rectView.OffsetRect(-rectView.left, -rectView.top);
	ASSERT(rectView.left == 0 && rectView.top == 0);
	if (bShrinkOnly)
	{
		if (rectClient.right <= m_totalDev.cx)
			rectView.right = rectClient.right;
		if (rectClient.bottom <= m_totalDev.cy)
			rectView.bottom = rectClient.bottom;
	}

	// dermine and set size of frame based on desired size of view
	CRect rectFrame;
	CFrameWnd* pFrame = EnsureParentFrame();
	pFrame->GetWindowRect(rectFrame);
	CSize size = rectFrame.Size();
	size.cx += rectView.right - rectClient.right;
	size.cy += rectView.bottom - rectClient.bottom;
	pFrame->SetWindowPos(NULL, 0, 0, size.cx, size.cy,
		SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
}

/////////////////////////////////////////////////////////////////////////////

void CScrollView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);
	if (m_nMapMode == MM_SCALETOFIT)
	{
		// force recalculation of scale to fit parameters
		SetScaleToFitSize(m_totalLog);
	}
	else
	{
		// UpdateBars() handles locking out recursion
		UpdateBars();
	}
}

LRESULT CScrollView::HandleMButtonDown(WPARAM wParam, LPARAM lParam)
{
	UINT nFlags = static_cast<UINT>(wParam);
	CPoint point(lParam);

	// if the user has CTRL or SHIFT down, we certainly
	// do not handle the message

	if (nFlags & (MK_SHIFT | MK_CONTROL))
	{
		CView::OnMButtonDown(nFlags, point);
		return FALSE;
	}

	// Otherwise, we actually have scrolling work to do.
	// See if we have a wheel mouse...

	BOOL bSupport = ::GetSystemMetrics(SM_MOUSEWHEELPRESENT);

	// If not a wheel mouse, the middle button is really the
	// middle button and not the wheel; the application should've
	//	handled it.

	if (!bSupport)
		CView::OnMButtonDown(nFlags, point);
	else
	{
		if (m_pAnchorWindow == NULL)
		{
			BOOL bVertBar;
			BOOL bHorzBar;
			CheckScrollBars(bHorzBar, bVertBar);

			UINT nBitmapID = 0;

			// based on which scrollbars we have, figure out which
			// anchor cursor to use for the anchor window
			if (bVertBar)
			{
				if (bHorzBar)
					nBitmapID = AFX_IDC_MOUSE_ORG_HV;
				else
					nBitmapID = AFX_IDC_MOUSE_ORG_VERT;
			}
			else if (bHorzBar)
				nBitmapID = AFX_IDC_MOUSE_ORG_HORZ;

			// if there's no scrollbars, we don't do anything!
			if (nBitmapID == 0)
			{
				CView::OnMButtonDown(nFlags, point);
				return FALSE;
			}
			else
			{
				m_pAnchorWindow = new _AFX_MOUSEANCHORWND(point);
				m_pAnchorWindow->SetBitmap(nBitmapID);
				m_pAnchorWindow->Create(this);
				m_pAnchorWindow->ShowWindow(SW_SHOWNA);
			}
		}
		else
		{
			m_pAnchorWindow->DestroyWindow();
			delete m_pAnchorWindow;
			m_pAnchorWindow = NULL;
		}
	}

	return TRUE;
}

LRESULT CScrollView::OnPrintClient(WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);

	HDC hdc = (HDC) wParam;
	if (hdc == NULL)
	{
		return 0L;
	}

	CDC dc;
	dc.Attach(hdc);

	CDC dcView;
	dcView.CreateCompatibleDC(&dc);

	CRect rect;
	GetClientRect(rect);

	CImage bmpSrc;
	bmpSrc.CreateEx(rect.Width(), rect.Height(), 32, BI_RGB, NULL, CImage::createAlphaChannel);

	HBITMAP hBmpOld = (HBITMAP)dcView.SelectObject((HBITMAP)bmpSrc);

	dcView.BitBlt(0, 0, rect.Width(), rect.Height(), &dc, 0, 0, SRCCOPY);

	dcView.SetViewportOrg(0, 0);
	dcView.SetWindowOrg(0, 0);
	dcView.SetMapMode(MM_TEXT);

	OnPrepareDC(&dcView, NULL);
	OnDraw(&dcView);

	dc.BitBlt(0, 0, rect.Width(), rect.Height(), &dcView, 0, 0, SRCCOPY);

	dcView.SelectObject(hBmpOld);
	dc.Detach();

	return 0L;
}

/////////////////////////////////////////////////////////////////////////////
// Scrolling Helpers

void CScrollView::CenterOnPoint(CPoint ptCenter) // center in device coords
{
	CRect rect;
	GetClientRect(&rect);           // find size of client window

	int xDesired = ptCenter.x - rect.Width() / 2;
	int yDesired = ptCenter.y - rect.Height() / 2;

	DWORD dwStyle = GetStyle();

	if ((dwStyle & WS_HSCROLL) == 0 || xDesired < 0)
	{
		xDesired = 0;
	}
	else
	{
		int xMax = GetScrollLimit(SB_HORZ);
		if (xDesired > xMax)
			xDesired = xMax;
	}

	if ((dwStyle & WS_VSCROLL) == 0 || yDesired < 0)
	{
		yDesired = 0;
	}
	else
	{
		int yMax = GetScrollLimit(SB_VERT);
		if (yDesired > yMax)
			yDesired = yMax;
	}

	ASSERT(xDesired >= 0);
	ASSERT(yDesired >= 0);

	SetScrollPos(SB_HORZ, xDesired);
	SetScrollPos(SB_VERT, yDesired);
}

/////////////////////////////////////////////////////////////////////////////
// Tie to scrollbars and CWnd behaviour

void CScrollView::GetScrollBarSizes(CSize& sizeSb)
{
	sizeSb.cx = sizeSb.cy = 0;
	DWORD dwStyle = GetStyle();

	if (GetScrollBarCtrl(SB_VERT) == NULL)
	{
		// vert scrollbars will impact client area of this window
		sizeSb.cx = afxData.cxVScroll;
		if (dwStyle & WS_BORDER)
			sizeSb.cx -= AFX_CX_BORDER;
	}
	if (GetScrollBarCtrl(SB_HORZ) == NULL)
	{
		// horz scrollbars will impact client area of this window
		sizeSb.cy = afxData.cyHScroll;
		if (dwStyle & WS_BORDER)
			sizeSb.cy -= AFX_CY_BORDER;
	}
}

BOOL CScrollView::GetTrueClientSize(CSize& size, CSize& sizeSb)
	// return TRUE if enough room to add scrollbars if needed
{
	CRect rect;
	GetClientRect(&rect);
	ASSERT(rect.top == 0 && rect.left == 0);
	size.cx = rect.right;
	size.cy = rect.bottom;
	DWORD dwStyle = GetStyle();

	// first get the size of the scrollbars for this window
	GetScrollBarSizes(sizeSb);

	// first calculate the size of a potential scrollbar
	// (scroll bar controls do not get turned on/off)
	if (sizeSb.cx != 0 && (dwStyle & WS_VSCROLL))
	{
		// vert scrollbars will impact client area of this window
		size.cx += sizeSb.cx;   // currently on - adjust now
	}
	if (sizeSb.cy != 0 && (dwStyle & WS_HSCROLL))
	{
		// horz scrollbars will impact client area of this window
		size.cy += sizeSb.cy;   // currently on - adjust now
	}

	// return TRUE if enough room
	return (size.cx > sizeSb.cx && size.cy > sizeSb.cy);
}

// helper to return the state of the scrollbars without actually changing
//  the state of the scrollbars
void CScrollView::GetScrollBarState(CSize sizeClient, CSize& needSb,
	CSize& sizeRange, CPoint& ptMove, BOOL bInsideClient)
{
	// get scroll bar sizes (the part that is in the client area)
	CSize sizeSb;
	GetScrollBarSizes(sizeSb);

	// enough room to add scrollbars
	sizeRange = m_totalDev - sizeClient;
		// > 0 => need to scroll
	ptMove = GetDeviceScrollPosition();
		// point to move to (start at current scroll pos)

	BOOL bNeedH = sizeRange.cx > 0;
	if (!bNeedH)
		ptMove.x = 0;                       // jump back to origin
	else if (bInsideClient)
		sizeRange.cy += sizeSb.cy;          // need room for a scroll bar

	BOOL bNeedV = sizeRange.cy > 0;
	if (!bNeedV)
		ptMove.y = 0;                       // jump back to origin
	else if (bInsideClient)
		sizeRange.cx += sizeSb.cx;          // need room for a scroll bar

	if (bNeedV && !bNeedH && sizeRange.cx > 0)
	{
		ASSERT(bInsideClient);
		// need a horizontal scrollbar after all
		bNeedH = TRUE;
		sizeRange.cy += sizeSb.cy;
	}

	// if current scroll position will be past the limit, scroll to limit
	if (sizeRange.cx > 0 && ptMove.x >= sizeRange.cx)
		ptMove.x = sizeRange.cx;
	if (sizeRange.cy > 0 && ptMove.y >= sizeRange.cy)
		ptMove.y = sizeRange.cy;

	// now update the bars as appropriate
	needSb.cx = bNeedH;
	needSb.cy = bNeedV;

	// needSb, sizeRange, and ptMove area now all updated
}

void CScrollView::UpdateBars()
{
	// UpdateBars may cause window to be resized - ignore those resizings
	if (m_bInsideUpdate)
		return;         // Do not allow recursive calls

	// Lock out recursion
	m_bInsideUpdate = TRUE;

	// update the horizontal to reflect reality
	// NOTE: turning on/off the scrollbars will cause 'OnSize' callbacks
	ASSERT(m_totalDev.cx >= 0 && m_totalDev.cy >= 0);

	CRect rectClient;
	BOOL bCalcClient = TRUE;

	// allow parent to do inside-out layout first
	CWnd* pParentWnd = GetParent();
	if (pParentWnd != NULL)
	{
		// if parent window responds to this message, use just
		//  client area for scroll bar calc -- not "true" client area
		if ((BOOL)pParentWnd->SendMessage(WM_RECALCPARENT, 0,
			(LPARAM)(LPCRECT)&rectClient) != 0)
		{
			// use rectClient instead of GetTrueClientSize for
			//  client size calculation.
			bCalcClient = FALSE;
		}
	}

	CSize sizeClient;
	CSize sizeSb;

	if (bCalcClient)
	{
		// get client rect
		if (!GetTrueClientSize(sizeClient, sizeSb))
		{
			// no room for scroll bars (common for zero sized elements)
			CRect rect;
			GetClientRect(&rect);
			if (rect.right > 0 && rect.bottom > 0)
			{
				// if entire client area is not invisible, assume we have
				//  control over our scrollbars
				EnableScrollBarCtrl(SB_BOTH, FALSE);
			}
			m_bInsideUpdate = FALSE;
			return;
		}
	}
	else
	{
		// let parent window determine the "client" rect
		GetScrollBarSizes(sizeSb);
		sizeClient.cx = rectClient.right - rectClient.left;
		sizeClient.cy = rectClient.bottom - rectClient.top;
	}

	// enough room to add scrollbars
	CSize sizeRange;
	CPoint ptMove;
	CSize needSb;

	// get the current scroll bar state given the true client area
	GetScrollBarState(sizeClient, needSb, sizeRange, ptMove, bCalcClient);
	if (needSb.cx)
		sizeClient.cy -= sizeSb.cy;
	if (needSb.cy)
		sizeClient.cx -= sizeSb.cx;

	// first scroll the window as needed
	ScrollToDevicePosition(ptMove); // will set the scroll bar positions too

	// this structure needed to update the scrollbar page range
	SCROLLINFO info;
	info.fMask = SIF_PAGE|SIF_RANGE;
	info.nMin = 0;

	// now update the bars as appropriate
	EnableScrollBarCtrl(SB_HORZ, needSb.cx);
	if (needSb.cx)
	{
		info.nPage = sizeClient.cx;
		info.nMax = m_totalDev.cx-1;
		if (!SetScrollInfo(SB_HORZ, &info, TRUE))
			SetScrollRange(SB_HORZ, 0, sizeRange.cx, TRUE);
	}
	EnableScrollBarCtrl(SB_VERT, needSb.cy);
	if (needSb.cy)
	{
		info.nPage = sizeClient.cy;
		info.nMax = m_totalDev.cy-1;
		if (!SetScrollInfo(SB_VERT, &info, TRUE))
			SetScrollRange(SB_VERT, 0, sizeRange.cy, TRUE);
	}

	// remove recursion lockout
	m_bInsideUpdate = FALSE;
}

void CScrollView::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	if (nAdjustType == adjustOutside)
	{
		// allow for special client-edge style
		::AdjustWindowRectEx(lpClientRect, 0, FALSE, GetExStyle());

		if (m_nMapMode != MM_SCALETOFIT)
		{
			// if the view is being used in-place, add scrollbar sizes
			//  (scollbars should appear on the outside when in-place editing)
			CSize sizeClient(
				lpClientRect->right - lpClientRect->left,
				lpClientRect->bottom - lpClientRect->top);

			CSize sizeRange = m_totalDev - sizeClient;
				// > 0 => need to scroll

			// get scroll bar sizes (used to adjust the window)
			CSize sizeSb;
			GetScrollBarSizes(sizeSb);

			// adjust the window size based on the state
			if (sizeRange.cy > 0)
			{   // vertical scroll bars take up horizontal space
				lpClientRect->right += sizeSb.cx;
			}
			if (sizeRange.cx > 0)
			{   // horizontal scroll bars take up vertical space
				lpClientRect->bottom += sizeSb.cy;
			}
		}
	}
	else
	{
		// call default to handle other non-client areas
		::AdjustWindowRectEx(lpClientRect, GetStyle(), FALSE,
			GetExStyle() & ~(WS_EX_CLIENTEDGE));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CScrollView scrolling

void CScrollView::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (pScrollBar != NULL && pScrollBar->SendChildNotifyLastMsg())
		return;     // eat it

	// ignore scroll bar msgs from other controls
	if (pScrollBar != GetScrollBarCtrl(SB_HORZ))
		return;

	OnScroll(MAKEWORD(nSBCode, 0xff), nPos);
}

void CScrollView::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (pScrollBar != NULL && pScrollBar->SendChildNotifyLastMsg())
		return;     // eat it

	// ignore scroll bar msgs from other controls
	if (pScrollBar != GetScrollBarCtrl(SB_VERT))
		return;

	OnScroll(MAKEWORD(0xff, nSBCode), nPos);
}

BOOL CScrollView::OnMouseWheel(UINT fFlags, short zDelta, CPoint point)
{
	// we don't handle anything but scrolling
	if (fFlags & (MK_SHIFT | MK_CONTROL))
		return FALSE;

	// if the parent is a splitter, it will handle the message
	if (GetParentSplitter(this, TRUE))
		return FALSE;

	// we can't get out of it--perform the scroll ourselves
	return DoMouseWheel(fFlags, zDelta, point);
}

void CScrollView::CheckScrollBars(BOOL& bHasHorzBar, BOOL& bHasVertBar) const
{
	DWORD dwStyle = GetStyle();
	CScrollBar* pBar = GetScrollBarCtrl(SB_VERT);
	bHasVertBar = ((pBar != NULL) && pBar->IsWindowEnabled()) ||
					(dwStyle & WS_VSCROLL);

	pBar = GetScrollBarCtrl(SB_HORZ);
	bHasHorzBar = ((pBar != NULL) && pBar->IsWindowEnabled()) ||
					(dwStyle & WS_HSCROLL);
}

// This function isn't virtual. If you need to override it,
// you really need to override OnMouseWheel() here or in
// CSplitterWnd.

BOOL CScrollView::DoMouseWheel(UINT fFlags, short zDelta, CPoint point)
{
	UNUSED_ALWAYS(point);
	UNUSED_ALWAYS(fFlags);

	// if we have a vertical scroll bar, the wheel scrolls that
	// if we have _only_ a horizontal scroll bar, the wheel scrolls that
	// otherwise, don't do any work at all

	BOOL bHasHorzBar, bHasVertBar;
	CheckScrollBars(bHasHorzBar, bHasVertBar);
	if (!bHasVertBar && !bHasHorzBar)
		return FALSE;

	BOOL bResult = FALSE;
	UINT uWheelScrollLines = _AfxGetMouseScrollLines();
	int nToScroll = ::MulDiv(-zDelta, uWheelScrollLines, WHEEL_DELTA);
	int nDisplacement;

	if (bHasVertBar)
	{
		if (uWheelScrollLines == WHEEL_PAGESCROLL)
		{
			nDisplacement = m_pageDev.cy;
			if (zDelta > 0)
				nDisplacement = -nDisplacement;
		}
		else
		{
			nDisplacement = nToScroll * m_lineDev.cy;
			nDisplacement = min(nDisplacement, m_pageDev.cy);
		}
		bResult = OnScrollBy(CSize(0, nDisplacement), TRUE);
	}
	else if (bHasHorzBar)
	{
		if (uWheelScrollLines == WHEEL_PAGESCROLL)
		{
			nDisplacement = m_pageDev.cx;
			if (zDelta > 0)
				nDisplacement = -nDisplacement;
		}
		else
		{
			nDisplacement = nToScroll * m_lineDev.cx;
			nDisplacement = min(nDisplacement, m_pageDev.cx);
		}
		bResult = OnScrollBy(CSize(nDisplacement, 0), TRUE);
	}

	if (bResult)
		UpdateWindow();

	return bResult;
}

BOOL CScrollView::OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll)
{
	// calc new x position
	int x = GetScrollPos(SB_HORZ);
	int xOrig = x;

	switch (LOBYTE(nScrollCode))
	{
	case SB_TOP:
		x = 0;
		break;
	case SB_BOTTOM:
		x = INT_MAX;
		break;
	case SB_LINEUP:
		x -= m_lineDev.cx;
		break;
	case SB_LINEDOWN:
		x += m_lineDev.cx;
		break;
	case SB_PAGEUP:
		x -= m_pageDev.cx;
		break;
	case SB_PAGEDOWN:
		x += m_pageDev.cx;
		break;
	case SB_THUMBTRACK:
		x = nPos;
		break;
	}

	// calc new y position
	int y = GetScrollPos(SB_VERT);
	int yOrig = y;

	switch (HIBYTE(nScrollCode))
	{
	case SB_TOP:
		y = 0;
		break;
	case SB_BOTTOM:
		y = INT_MAX;
		break;
	case SB_LINEUP:
		y -= m_lineDev.cy;
		break;
	case SB_LINEDOWN:
		y += m_lineDev.cy;
		break;
	case SB_PAGEUP:
		y -= m_pageDev.cy;
		break;
	case SB_PAGEDOWN:
		y += m_pageDev.cy;
		break;
	case SB_THUMBTRACK:
		y = nPos;
		break;
	}

	BOOL bResult = OnScrollBy(CSize(x - xOrig, y - yOrig), bDoScroll);
	if (bResult && bDoScroll)
		UpdateWindow();

	return bResult;
}

BOOL CScrollView::OnScrollBy(CSize sizeScroll, BOOL bDoScroll)
{
	int xOrig, x;
	int yOrig, y;

	// don't scroll if there is no valid scroll range (ie. no scroll bar)
	CScrollBar* pBar;
	DWORD dwStyle = GetStyle();
	pBar = GetScrollBarCtrl(SB_VERT);
	if ((pBar != NULL && !pBar->IsWindowEnabled()) ||
		(pBar == NULL && !(dwStyle & WS_VSCROLL)))
	{
		// vertical scroll bar not enabled
		sizeScroll.cy = 0;
	}
	pBar = GetScrollBarCtrl(SB_HORZ);
	if ((pBar != NULL && !pBar->IsWindowEnabled()) ||
		(pBar == NULL && !(dwStyle & WS_HSCROLL)))
	{
		// horizontal scroll bar not enabled
		sizeScroll.cx = 0;
	}

	// adjust current x position
	xOrig = x = GetScrollPos(SB_HORZ);
	int xMax = GetScrollLimit(SB_HORZ);
	x += sizeScroll.cx;
	if (x < 0)
		x = 0;
	else if (x > xMax)
		x = xMax;

	// adjust current y position
	yOrig = y = GetScrollPos(SB_VERT);
	int yMax = GetScrollLimit(SB_VERT);
	y += sizeScroll.cy;
	if (y < 0)
		y = 0;
	else if (y > yMax)
		y = yMax;

	// did anything change?
	if (x == xOrig && y == yOrig)
		return FALSE;

	if (bDoScroll)
	{
		// do scroll and update scroll positions
		ScrollWindow(-(x-xOrig), -(y-yOrig));
		if (x != xOrig)
			SetScrollPos(SB_HORZ, x);
		if (y != yOrig)
			SetScrollPos(SB_VERT, y);
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CScrollView diagnostics

#ifdef _DEBUG
void CScrollView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

	dc << "m_totalLog = " << m_totalLog;
	dc << "\nm_totalDev = " << m_totalDev;
	dc << "\nm_pageDev = " << m_pageDev;
	dc << "\nm_lineDev = " << m_lineDev;
	dc << "\nm_bCenter = " << m_bCenter;
	dc << "\nm_bInsideUpdate = " << m_bInsideUpdate;
	dc << "\nm_nMapMode = ";
	switch (m_nMapMode)
	{
	case MM_NONE:
		dc << "MM_NONE";
		break;
	case MM_SCALETOFIT:
		dc << "MM_SCALETOFIT";
		break;
	case MM_TEXT:
		dc << "MM_TEXT";
		break;
	case MM_LOMETRIC:
		dc << "MM_LOMETRIC";
		break;
	case MM_HIMETRIC:
		dc << "MM_HIMETRIC";
		break;
	case MM_LOENGLISH:
		dc << "MM_LOENGLISH";
		break;
	case MM_HIENGLISH:
		dc << "MM_HIENGLISH";
		break;
	case MM_TWIPS:
		dc << "MM_TWIPS";
		break;
	default:
		dc << "*unknown*";
		break;
	}

	dc << "\n";
}

void CScrollView::AssertValid() const
{
	CView::AssertValid();

	switch (m_nMapMode)
	{
	case MM_NONE:
	case MM_SCALETOFIT:
	case MM_TEXT:
	case MM_LOMETRIC:
	case MM_HIMETRIC:
	case MM_LOENGLISH:
	case MM_HIENGLISH:
	case MM_TWIPS:
		break;
	case MM_ISOTROPIC:
	case MM_ANISOTROPIC:
		ASSERT(FALSE); // illegal mapping mode
	default:
		ASSERT(FALSE); // unknown mapping mode
	}
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CScrollView, CView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winctrl1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#ifndef _AFX_NO_OCC_SUPPORT
#include "occimpl.h"
#endif



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CStatic

BOOL CStatic::Create(LPCTSTR lpszText, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	CWnd* pWnd = this;
	return pWnd->Create(_T("STATIC"), lpszText, dwStyle, rect, pParentWnd, nID);
}

CStatic::~CStatic()
{
	DestroyWindow();
}

// Derived class is responsible for implementing all of these handlers
//   for owner/self draw controls
void CStatic::DrawItem(LPDRAWITEMSTRUCT)
{
	ASSERT(FALSE);
}

BOOL CStatic::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	if (message != WM_DRAWITEM)
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);

	ASSERT(pResult == NULL);       // no return value expected
	UNUSED(pResult); // unused in release builds
	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CButton

BOOL CButton::Create(LPCTSTR lpszCaption, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	CWnd* pWnd = this;
	return pWnd->Create(_T("BUTTON"), lpszCaption, dwStyle, rect, pParentWnd, nID);
}

CButton::~CButton()
{
	DestroyWindow();
}

// Helper for radio buttons
int CWnd::GetCheckedRadioButton(int nIDFirstButton, int nIDLastButton) const
{
	for (int nID = nIDFirstButton; nID <= nIDLastButton; nID++)
	{
		if (IsDlgButtonChecked(nID))
			return nID; // id that matched
	}
	return 0; // invalid ID
}

// Derived class is responsible for implementing all of these handlers
//   for owner/self draw controls
void CButton::DrawItem(LPDRAWITEMSTRUCT)
{
	ASSERT(FALSE);
}

BOOL CButton::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	if (message != WM_DRAWITEM)
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);

	ASSERT(pResult == NULL);       // no return value expected
	UNUSED(pResult); // unused in release builds
	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSplitButton

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
BEGIN_MESSAGE_MAP(CSplitButton, CButton)
	ON_NOTIFY_REFLECT(BCN_DROPDOWN, &CSplitButton::OnDropDown)
END_MESSAGE_MAP()

BOOL CSplitButton::Create(LPCTSTR lpszCaption, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	return CButton::Create(lpszCaption, dwStyle|BS_SPLITBUTTON, rect, pParentWnd, nID);
}

CSplitButton::~CSplitButton()
{
	Cleanup();
}

void CSplitButton::SetDropDownMenu(UINT nMenuId, UINT nSubMenuId)
{
	Cleanup();
	m_nMenuId = nMenuId;
	m_nSubMenuId = nSubMenuId;
}

void CSplitButton::SetDropDownMenu(CMenu* pMenu)
{
	Cleanup();
	m_pMenu = pMenu;
}

void CSplitButton::Cleanup()
{
	if (m_pMenu)
	{
		delete m_pMenu;
	}
	m_pMenu = NULL;
	m_nMenuId = (UINT)-1;
	m_nSubMenuId = (UINT)-1;
}

void CSplitButton::OnDropDown(NMHDR* /*pNMHDR*/, LRESULT *pResult)
{
	ASSERT(pResult != NULL);
	CMenu menu; // used only for loading menu from resource

	//use the pointer first
	CMenu* pMenu = m_pMenu; 
	// use the Menu IDs if pointer is NULL
	if (pMenu == NULL && m_nMenuId != (UINT)-1 && m_nSubMenuId != (UINT) -1)
	{
		menu.LoadMenu(m_nMenuId);
		pMenu = menu.GetSubMenu(m_nSubMenuId);
	}

	if (pMenu != NULL)
	{
		CRect rectButton;
		this->GetWindowRect(&rectButton);

		TPMPARAMS tpmParams;
		tpmParams.cbSize=sizeof(TPMPARAMS);
		tpmParams.rcExclude= rectButton;

		pMenu->TrackPopupMenuEx(TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON, rectButton.left, rectButton.bottom, this->GetParent(),&tpmParams);
	}
	*pResult = 0;
}
#endif // (_WIN32_WINNT >= 0x600) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CListBox

BOOL CListBox::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
		UINT nID)
{
	CWnd* pWnd = this;
	return pWnd->Create(_T("LISTBOX"), NULL, dwStyle, rect, pParentWnd, nID);
}

CListBox::~CListBox()
{
	DestroyWindow();
}

// Derived class is responsible for implementing these handlers
//   for owner/self draw controls (except for the optional DeleteItem)
void CListBox::DrawItem(LPDRAWITEMSTRUCT)
	{ ASSERT(FALSE); }
void CListBox::MeasureItem(LPMEASUREITEMSTRUCT)
	{ ASSERT(FALSE); }
int CListBox::CompareItem(LPCOMPAREITEMSTRUCT)
	{ ASSERT(FALSE); return 0; }
void CListBox::DeleteItem(LPDELETEITEMSTRUCT)
	{ /* default to nothing */ }
int CListBox::VKeyToItem(UINT, UINT)
	{ return int(Default()); }
int CListBox::CharToItem(UINT, UINT)
	{ return int(Default()); }

BOOL CListBox::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	switch (message)
	{
	case WM_DRAWITEM:
		ASSERT(pResult == NULL);       // no return value expected
		DrawItem((LPDRAWITEMSTRUCT)lParam);
		break;
	case WM_MEASUREITEM:
		ASSERT(pResult == NULL);       // no return value expected
		MeasureItem((LPMEASUREITEMSTRUCT)lParam);
		break;
	case WM_COMPAREITEM:
		ASSERT(pResult != NULL);       // return value expected
		*pResult = CompareItem((LPCOMPAREITEMSTRUCT)lParam);
		break;
	case WM_DELETEITEM:
		ASSERT(pResult == NULL);       // no return value expected
		DeleteItem((LPDELETEITEMSTRUCT)lParam);
		break;
	case WM_VKEYTOITEM:
		*pResult = VKeyToItem(LOWORD(wParam), HIWORD(wParam));
		break;
	case WM_CHARTOITEM:
		*pResult = CharToItem(LOWORD(wParam), HIWORD(wParam));
		break;
	default:
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);
	}
	return TRUE;
}

void CListBox::GetText(int nIndex, CString& rString) const
{
	ASSERT(::IsWindow(m_hWnd));
	GetText(nIndex, rString.GetBufferSetLength(GetTextLen(nIndex)));
	rString.ReleaseBuffer();
}

UINT CListBox::ItemFromPoint(CPoint pt, BOOL& bOutside) const
{
	ASSERT(::IsWindow(m_hWnd));
	DWORD dw = (DWORD)::SendMessage(m_hWnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));
	bOutside = !!HIWORD(dw);
	return LOWORD(dw);
}

/////////////////////////////////////////////////////////////////////////////
// CComboBox

BOOL CComboBox::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
		UINT nID)
{
	CWnd* pWnd = this;
	return pWnd->Create(_T("COMBOBOX"), NULL, dwStyle, rect, pParentWnd, nID);
}

CComboBox::~CComboBox()
{
	DestroyWindow();
}

// Derived class is responsible for implementing these handlers
//   for owner/self draw controls (except for the optional DeleteItem)
void CComboBox::DrawItem(LPDRAWITEMSTRUCT)
	{ ASSERT(FALSE); }
void CComboBox::MeasureItem(LPMEASUREITEMSTRUCT)
	{ ASSERT(FALSE); }
int CComboBox::CompareItem(LPCOMPAREITEMSTRUCT)
	{ ASSERT(FALSE); return 0; }
void CComboBox::DeleteItem(LPDELETEITEMSTRUCT)
	{ /* default to nothing */ }

BOOL CComboBox::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	switch (message)
	{
	case WM_DRAWITEM:
		ASSERT(pResult == NULL);       // no return value expected
		DrawItem((LPDRAWITEMSTRUCT)lParam);
		break;
	case WM_MEASUREITEM:
		ASSERT(pResult == NULL);       // no return value expected
		MeasureItem((LPMEASUREITEMSTRUCT)lParam);
		break;
	case WM_COMPAREITEM:
		ASSERT(pResult != NULL);       // return value expected
		*pResult = CompareItem((LPCOMPAREITEMSTRUCT)lParam);
		break;
	case WM_DELETEITEM:
		ASSERT(pResult == NULL);       // no return value expected
		DeleteItem((LPDELETEITEMSTRUCT)lParam);
		break;
	default:
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);
	}
	return TRUE;
}

void CComboBox::GetLBText(int nIndex, CString& rString) const
{
	ASSERT(::IsWindow(m_hWnd));
	GetLBText(nIndex, rString.GetBufferSetLength(GetLBTextLen(nIndex)));
	rString.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
// CEdit

BOOL CEdit::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	CWnd* pWnd = this;
	return pWnd->Create(_T("EDIT"), NULL, dwStyle, rect, pParentWnd, nID);
}

CEdit::~CEdit()
{
	DestroyWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CScrollBar

BOOL CScrollBar::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
		UINT nID)
{
	CWnd* pWnd = this;
	return pWnd->Create(_T("SCROLLBAR"), NULL, dwStyle, rect, pParentWnd, nID);
}

CScrollBar::~CScrollBar()
{
	DestroyWindow();
}


IMPLEMENT_DYNAMIC(CStatic, CWnd)
IMPLEMENT_DYNAMIC(CButton, CWnd)
#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
IMPLEMENT_DYNAMIC(CSplitButton, CButton)
#endif// (_WIN32_WINNT >= 0x600) && defined(UNICODE)
IMPLEMENT_DYNAMIC(CListBox, CWnd)
IMPLEMENT_DYNAMIC(CComboBox, CWnd)
IMPLEMENT_DYNAMIC(CEdit, CWnd)
IMPLEMENT_DYNAMIC(CScrollBar, CWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winctrl2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDragListBox

CDragListBox::~CDragListBox()
{
	DestroyWindow();
}

void CDragListBox::PreSubclassWindow()
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT((GetStyle() & (LBS_MULTIPLESEL|LBS_SORT)) == 0);
	AfxMakeDragList(m_hWnd);
}

BOOL CDragListBox::BeginDrag(CPoint pt)
{
	m_nLast = -1;
	DrawInsert(ItemFromPt(pt));
	return TRUE;
}

void CDragListBox::CancelDrag(CPoint)
{
	DrawInsert(-1);
}

UINT CDragListBox::Dragging(CPoint pt)
{
	int nIndex = ItemFromPt(pt, FALSE); // don't allow scrolling just yet
	DrawInsert(nIndex);
	ItemFromPt(pt);
	return (nIndex == LB_ERR) ? DL_STOPCURSOR : DL_MOVECURSOR;
}

void CDragListBox::Dropped(int nSrcIndex, CPoint pt)
{
	ASSERT(!(GetStyle() & (LBS_OWNERDRAWFIXED|LBS_OWNERDRAWVARIABLE)) ||
		(GetStyle() & LBS_HASSTRINGS));

	DrawInsert(-1);
	int nDestIndex = ItemFromPt(pt);

	if (nSrcIndex == -1 || nDestIndex == -1)
		return;
	if (nDestIndex == nSrcIndex || nDestIndex == nSrcIndex+1)
		return; //didn't move
	CString str;
	UINT_PTR dwData;
	GetText(nSrcIndex, str);
	dwData = GetItemData(nSrcIndex);
	DeleteString(nSrcIndex);
	if (nSrcIndex < nDestIndex)
		nDestIndex--;
	nDestIndex = InsertString(nDestIndex, str);
	SetItemData(nDestIndex, dwData);
	SetCurSel(nDestIndex);
}

void CDragListBox::DrawInsert(int nIndex)
{
	if (m_nLast != nIndex)
	{
		DrawSingle(m_nLast);
		DrawSingle(nIndex);
		m_nLast = nIndex;
	}
}

void CDragListBox::DrawSingle(int nIndex)
{
	if (nIndex == -1)
		return;
	CBrush* pBrush = CDC::GetHalftoneBrush();
	CRect rect;
	GetClientRect(&rect);
	CRgn rgn;
	rgn.CreateRectRgnIndirect(&rect);

	CDC* pDC = GetDC();
	// prevent drawing outside of listbox
	// this can happen at the top of the listbox since the listbox's DC is the
	// parent's DC
	pDC->SelectClipRgn(&rgn);

	GetItemRect(nIndex, &rect);
	rect.bottom = rect.top+2;
	rect.top -= 2;
	CBrush* pBrushOld = pDC->SelectObject(pBrush);
	//draw main line
	pDC->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);

	pDC->SelectObject(pBrushOld);
	ReleaseDC(pDC);
}

BOOL CDragListBox::OnChildNotify(UINT nMessage, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	if (nMessage != m_nMsgDragList)
		return CListBox::OnChildNotify(nMessage, wParam, lParam, pResult);

	ASSERT(pResult != NULL);
	LPDRAGLISTINFO pInfo = (LPDRAGLISTINFO)lParam;
	ASSERT(pInfo != NULL);
	switch (pInfo->uNotification)
	{
	case DL_BEGINDRAG:
		*pResult = BeginDrag(pInfo->ptCursor);
		break;
	case DL_CANCELDRAG:
		CancelDrag(pInfo->ptCursor);
		break;
	case DL_DRAGGING:
		*pResult = Dragging(pInfo->ptCursor);
		break;
	case DL_DROPPED:
		Dropped(GetCurSel(), pInfo->ptCursor);
		break;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrl

BEGIN_MESSAGE_MAP(CToolBarCtrl, CWnd)
	//{{AFX_MSG_MAP(CToolBarCtrl)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CToolBarCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_BAR_REG));

	CWnd* pWnd = this;
	return pWnd->Create(TOOLBARCLASSNAME, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CToolBarCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CToolBarCtrl::~CToolBarCtrl()
{
	DestroyWindow();
}

int CToolBarCtrl::AddBitmap(int nNumButtons, CBitmap* pBitmap)
{
	ASSERT(::IsWindow(m_hWnd));
	TBADDBITMAP tbab;
	tbab.hInst = NULL;
	tbab.nID = (UINT_PTR)pBitmap->GetSafeHandle();
	return (int) ::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons,
		(LPARAM)&tbab);
}

int CToolBarCtrl::AddBitmap(int nNumButtons, UINT nBitmapID)
{
	ASSERT(::IsWindow(m_hWnd));
	TBADDBITMAP tbab;
	tbab.hInst = AfxFindResourceHandle((LPCTSTR)(DWORD_PTR)nBitmapID, RT_BITMAP);
	ASSERT(tbab.hInst != NULL);
	tbab.nID = nBitmapID;
	return (int) ::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons,
		(LPARAM)&tbab);
}

void CToolBarCtrl::SaveState(HKEY hKeyRoot, LPCTSTR lpszSubKey,
	LPCTSTR lpszValueName)
{
	ASSERT(::IsWindow(m_hWnd));
	TBSAVEPARAMS tbs;
	tbs.hkr = hKeyRoot;
	tbs.pszSubKey = lpszSubKey;
	tbs.pszValueName = lpszValueName;
	::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)TRUE, (LPARAM)&tbs);
}

void CToolBarCtrl::RestoreState(HKEY hKeyRoot, LPCTSTR lpszSubKey,
	LPCTSTR lpszValueName)
{
	ASSERT(::IsWindow(m_hWnd));
	TBSAVEPARAMS tbs;
	tbs.hkr = hKeyRoot;
	tbs.pszSubKey = lpszSubKey;
	tbs.pszValueName = lpszValueName;
	::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)FALSE, (LPARAM)&tbs);
}

int CToolBarCtrl::AddString(UINT nStringID)
{
	ASSERT(::IsWindow(m_hWnd));
	HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE((nStringID>>4)+1),
		RT_STRING);
	ASSERT(hInst != NULL);

	CString strTemp;
	BOOL bLoaded = strTemp.LoadString(hInst, nStringID);
	ASSERT(bLoaded);
	
	return (int)::SendMessage(m_hWnd, TB_ADDSTRING, 0, (LPARAM)strTemp.GetBuffer());
}

int CToolBarCtrl::OnCreate(LPCREATESTRUCT lpcs)
{
	if (CWnd::OnCreate(lpcs) == -1)
		return -1;
	SetButtonStructSize(sizeof(TBBUTTON));
	return 0;
}

HRESULT CToolBarCtrl::GetDropTarget(IDropTarget** ppDropTarget) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(ppDropTarget);
	return (HRESULT) ::SendMessage(m_hWnd, TB_GETOBJECT, (WPARAM)&IID_IDropTarget, (LPARAM)ppDropTarget);
}

int CToolBarCtrl::GetString(int nString, CString& str) const
{
	ASSERT(::IsWindow(m_hWnd));
	int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(0, nString), NULL));
	if(nLength != -1)
	{
		nLength = (int)::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(nLength + 1, nString), (LPARAM)str.GetBufferSetLength(nLength+1));
		str.ReleaseBuffer();
	}
	return nLength;
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBarCtrl

BOOL CStatusBarCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_BAR_REG));

	CWnd* pWnd = this;
	return pWnd->Create(STATUSCLASSNAME, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CStatusBarCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle,
	const RECT& rect,	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;

}

CStatusBarCtrl::~CStatusBarCtrl()
{
	DestroyWindow();
}

int CStatusBarCtrl::GetText(LPTSTR lpszText, int nPane, int* pType) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(nPane < 256);
	LRESULT dw = ::SendMessage(m_hWnd, SB_GETTEXT, (WPARAM)nPane,
		(LPARAM)lpszText);
	if (pType != NULL)
		*pType = HIWORD(dw);
	return LOWORD(dw);
}

CString CStatusBarCtrl::GetText(int nPane, int* pType) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(nPane < 256);
	int nLength = LOWORD(::SendMessage(m_hWnd, SB_GETTEXTLENGTH,
		(WPARAM)nPane, 0L));
	CString str;
	LRESULT dw = ::SendMessage(m_hWnd, SB_GETTEXT, (WPARAM)nPane,
		(LPARAM)str.GetBufferSetLength(nLength+1));
	str.ReleaseBuffer();
	if (pType != NULL)
		*pType = HIWORD(dw);
	return str;
}

int CStatusBarCtrl::GetTextLength(int nPane, int* pType) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(nPane < 256);
	LRESULT dw = ::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L);
	if (pType != NULL)
		*pType = HIWORD(dw);
	return LOWORD(dw);
}

CString CStatusBarCtrl::GetTipText(int nPane) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(nPane < 256);
	TCHAR buf[256];
	::SendMessage(m_hWnd, SB_GETTIPTEXT, MAKEWPARAM(nPane, 256), (LPARAM)buf);
	return CString(buf);
}

BOOL CStatusBarCtrl::GetBorders(int& nHorz, int& nVert, int& nSpacing) const
{
	ASSERT(::IsWindow(m_hWnd));
	int borders[3];
	BOOL bResult = (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)borders);
	if (bResult)
	{
		nHorz = borders[0];
		nVert = borders[1];
		nSpacing = borders[2];
	}
	return bResult;
}

void CStatusBarCtrl::DrawItem(LPDRAWITEMSTRUCT)
{
	ASSERT(FALSE);  // must override for self draw status bars
}

BOOL CStatusBarCtrl::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	if (message != WM_DRAWITEM)
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);

	ASSERT(pResult == NULL);       // no return value expected
	UNUSED(pResult); // unused in release builds

	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CListCtrl

BEGIN_MESSAGE_MAP(CListCtrl, CWnd)
	//{{AFX_MSG_MAP(CListCtrl)
	ON_WM_NCDESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CListCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_LISTVIEW_REG));

	CWnd* pWnd = this;
	return pWnd->Create(WC_LISTVIEW, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CListCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CListCtrl::~CListCtrl()
{
	DestroyWindow();
}

BOOL CListCtrl::GetItemRect(int nItem, LPRECT lpRect, UINT nCode) const
{
	ASSERT(::IsWindow(m_hWnd));
	lpRect->left = nCode;
	return (BOOL) ::SendMessage(m_hWnd, LVM_GETITEMRECT, (WPARAM)nItem,
		(LPARAM)lpRect);
}

BOOL CListCtrl::SetItemCountEx(int iCount, DWORD dwFlags /* = LVSICF_NOINVALIDATEALL */)
{
	ASSERT(::IsWindow(m_hWnd));

	// can't have dwFlags on a control that isn't virutal
	ASSERT(dwFlags == 0 || (GetStyle() & LVS_OWNERDATA));

	return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMCOUNT, (WPARAM) iCount,
		(LPARAM) dwFlags);
}

CSize CListCtrl::SetIconSpacing(int cx, int cy)
{
	ASSERT(::IsWindow(m_hWnd));
	DWORD dwRet = (DWORD) ::SendMessage(m_hWnd, LVM_SETICONSPACING,
		0, (LPARAM) MAKELONG(cx, cy));

	return CSize(dwRet);
}

CSize CListCtrl::SetIconSpacing(CSize size)
{
	ASSERT(::IsWindow(m_hWnd));
	DWORD dwRet = (DWORD) ::SendMessage(m_hWnd, LVM_SETICONSPACING,
		0, (LPARAM) MAKELONG(size.cx, size.cy));

	return CSize(dwRet);
}

BOOL CListCtrl::GetSubItemRect(int iItem, int iSubItem, int nArea, CRect& ref) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(nArea == LVIR_BOUNDS || nArea == LVIR_ICON || nArea == LVIR_LABEL || nArea == LVIR_SELECTBOUNDS);

	RECT rect;
	rect.top = iSubItem;
	rect.left = nArea;
	BOOL bRet = (BOOL) ::SendMessage(m_hWnd, LVM_GETSUBITEMRECT,
		iItem, (LPARAM) &rect);

	if (bRet)
		ref = rect;
	return bRet;
}

int CListCtrl::InsertColumn(int nCol, LPCTSTR lpszColumnHeading, int nFormat,
	int nWidth, int nSubItem)
{
	LVCOLUMN column;
	column.mask = LVCF_TEXT|LVCF_FMT;
	column.pszText = (LPTSTR)lpszColumnHeading;
	column.fmt = nFormat;
	if (nWidth != -1)
	{
		column.mask |= LVCF_WIDTH;
		column.cx = nWidth;
	}
	if (nSubItem != -1)
	{
		column.mask |= LVCF_SUBITEM;
		column.iSubItem = nSubItem;
	}
	return CListCtrl::InsertColumn(nCol, &column);
}

int CListCtrl::InsertItem(UINT nMask, int nItem, LPCTSTR lpszItem, UINT nState, UINT nStateMask,
	int nImage, LPARAM lParam)
{
	ASSERT(::IsWindow(m_hWnd));
	LVITEM item;
	item.mask = nMask;
	item.iItem = nItem;
	item.iSubItem = 0;
	item.pszText = (LPTSTR)lpszItem;
	item.state = nState;
	item.stateMask = nStateMask;
	item.iImage = nImage;
	item.lParam = lParam;
	return CListCtrl::InsertItem(&item);
}

int CListCtrl::HitTest(CPoint pt, UINT* pFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	LVHITTESTINFO hti;
	hti.pt = pt;
	int nRes = (int) ::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)&hti);
	if (pFlags != NULL)
		*pFlags = hti.flags;
	return nRes;
}

BOOL CListCtrl::SetItem(int nItem, int nSubItem, UINT nMask, LPCTSTR lpszItem,
	int nImage, UINT nState, UINT nStateMask, LPARAM lParam)
{
	ASSERT((nMask & LVIF_INDENT) == 0);
	return SetItem(nItem, nSubItem, nMask, lpszItem, nImage, nState, nStateMask, lParam, 0);
}

BOOL CListCtrl::SetItem(int nItem, int nSubItem, UINT nMask, LPCTSTR lpszItem,
	int nImage, UINT nState, UINT nStateMask, LPARAM lParam, int nIndent)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT((GetStyle() & LVS_OWNERDATA)==0);

	LVITEM lvi;
	lvi.mask = nMask;
	lvi.iItem = nItem;
	lvi.iSubItem = nSubItem;
	lvi.stateMask = nStateMask;
	lvi.state = nState;
	lvi.pszText = (LPTSTR) lpszItem;
	lvi.iImage = nImage;
	lvi.lParam = lParam;
	lvi.iIndent = nIndent;

	return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)&lvi);
}

BOOL CListCtrl::SetItemState(int nItem, UINT nState, UINT nStateMask)
{
	ASSERT(::IsWindow(m_hWnd));
	LVITEM lvi;
	lvi.stateMask = nStateMask;
	lvi.state = nState;
	return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)&lvi);
}

BOOL CListCtrl::SetItemText(int nItem, int nSubItem, LPCTSTR lpszText)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT((GetStyle() & LVS_OWNERDATA)==0);
	LVITEM lvi;
	lvi.iSubItem = nSubItem;
	lvi.pszText = (LPTSTR) lpszText;
	return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMTEXT, nItem, (LPARAM)&lvi);
}

CString CListCtrl::GetItemText(int nItem, int nSubItem) const
{
	ASSERT(::IsWindow(m_hWnd));
	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.iSubItem = nSubItem;
	CString str;
	int nLen = 128;
	int nRes;
	do
	{
		nLen *= 2;
		lvi.cchTextMax = nLen;
		lvi.pszText = str.GetBufferSetLength(nLen);
		nRes  = (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem,
			(LPARAM)&lvi);
	} while (nRes >= nLen-1);
	str.ReleaseBuffer();
	return str;
}

int CListCtrl::GetItemText(_In_ int nItem, _In_ int nSubItem, _Out_z_cap_post_count_(nLen, return + 1) LPTSTR lpszText, _In_ int nLen) const
{
	ASSERT(::IsWindow(m_hWnd));
	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.iSubItem = nSubItem;
	lvi.cchTextMax = nLen;
	lvi.pszText = lpszText;
	return (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem,
		(LPARAM)&lvi);
}

DWORD_PTR CListCtrl::GetItemData(int nItem) const
{
	ASSERT(::IsWindow(m_hWnd));
	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.iItem = nItem;
	lvi.mask = LVIF_PARAM;
	VERIFY(::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)&lvi));
	return lvi.lParam;
}

void CListCtrl::DrawItem(LPDRAWITEMSTRUCT)
{
	ASSERT(FALSE);
}

BOOL CListCtrl::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	if (message != WM_DRAWITEM)
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);

	ASSERT(pResult == NULL);       // no return value expected
	UNUSED(pResult); // unused in release builds

	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
}

void CListCtrl::RemoveImageList(int nImageList)
{
	HIMAGELIST h = (HIMAGELIST)SendMessage(LVM_GETIMAGELIST,
		(WPARAM)nImageList);
	if (CImageList::FromHandlePermanent(h) != NULL)
		SendMessage(LVM_SETIMAGELIST, (WPARAM)nImageList, NULL);
}

void CListCtrl::OnNcDestroy()
{
	RemoveImageList(LVSIL_NORMAL);
	RemoveImageList(LVSIL_SMALL);
	RemoveImageList(LVSIL_STATE);

	CWnd::OnNcDestroy();
}

CImageList* CListCtrl::CreateDragImage(int nItem, LPPOINT lpPoint)
{
	ASSERT(::IsWindow(m_hWnd));

	HIMAGELIST hImageList = (HIMAGELIST)::SendMessage(m_hWnd,
		LVM_CREATEDRAGIMAGE, nItem, (LPARAM)lpPoint);
	if (hImageList == NULL)
		return NULL;

	CImageList* pImageList = new CImageList;
	VERIFY(pImageList->Attach(hImageList));
	return pImageList;
}

/////////////////////////////////////////////////////////////////////////////
// CTreeCtrl

BEGIN_MESSAGE_MAP(CTreeCtrl, CWnd)
	//{{AFX_MSG_MAP(CTreeCtrl)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CTreeCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_TREEVIEW_REG));

	CWnd* pWnd = this;
	return pWnd->Create(WC_TREEVIEW, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CTreeCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CTreeCtrl::~CTreeCtrl()
{
	DestroyWindow();
}

BOOL CTreeCtrl::GetItemRect(HTREEITEM hItem, LPRECT lpRect, BOOL bTextOnly) const
{
	ASSERT(::IsWindow(m_hWnd));
	*(HTREEITEM*)lpRect = hItem;
	return (BOOL)::SendMessage(m_hWnd, TVM_GETITEMRECT, (WPARAM)bTextOnly,
		(LPARAM)lpRect);
}

CString CTreeCtrl::GetItemText(HTREEITEM hItem) const
{
	ASSERT(::IsWindow(m_hWnd));
	TVITEM item;
	item.hItem = hItem;
	item.mask = TVIF_TEXT;
	CString str;
	int nLen = 128;
	int nRes;
	do
	{
		nLen *= 2;
		item.pszText = str.GetBufferSetLength(nLen);
		item.cchTextMax = nLen;
		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		nRes = lstrlen(item.pszText);
	} while (nRes >= nLen-1);
	str.ReleaseBuffer();
	return str;
}

BOOL CTreeCtrl::GetItemImage(HTREEITEM hItem, int& nImage, int& nSelectedImage) const
{
	ASSERT(::IsWindow(m_hWnd));
	TVITEM item;
	item.hItem = hItem;
	item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE;
	BOOL bRes = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
	if (bRes)
	{
		nImage = item.iImage;
		nSelectedImage = item.iSelectedImage;
	}
	return bRes;
}

UINT CTreeCtrl::GetItemState(HTREEITEM hItem, UINT nStateMask) const
{
	ASSERT(::IsWindow(m_hWnd));
	TVITEM item;
	item.hItem = hItem;
	item.mask = TVIF_STATE;
	item.stateMask = nStateMask;
	item.state = 0;
	VERIFY(::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item));
	return item.state;
}

DWORD_PTR CTreeCtrl::GetItemData(HTREEITEM hItem) const
{
	ENSURE(::IsWindow(m_hWnd));
	ENSURE_ARG(hItem != NULL);
	TVITEM item;
	item.hItem = hItem;
	item.mask = TVIF_PARAM;
	VERIFY(::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item));
	return item.lParam;
}

BOOL CTreeCtrl::ItemHasChildren(HTREEITEM hItem) const
{
	ASSERT(::IsWindow(m_hWnd));
	TVITEM item;
	item.hItem = hItem;
	item.mask = TVIF_CHILDREN;
	::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
	return item.cChildren;
}

BOOL CTreeCtrl::SetItem(HTREEITEM hItem, UINT nMask, LPCTSTR lpszItem, int nImage,
	int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
{
	ASSERT(::IsWindow(m_hWnd));
	TVITEM item;
	item.hItem = hItem;
	item.mask = nMask;
	item.pszText = (LPTSTR) lpszItem;
	item.iImage = nImage;
	item.iSelectedImage = nSelectedImage;
	item.state = nState;
	item.stateMask = nStateMask;
	item.lParam = lParam;
	return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)&item);
}

#if (_WIN32_IE >= 0x0600)
BOOL CTreeCtrl::SetItemEx(HTREEITEM hItem, UINT nMask, LPCTSTR lpszItem, int nImage,
	int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam, 
	UINT uStateEx, HWND hWnd, int iExpandedImage)
{
	ASSERT(::IsWindow(m_hWnd));
	TVITEMEX item;
	item.hItem = hItem;
	item.mask = nMask;
	item.pszText = (LPTSTR) lpszItem;
	item.iImage = nImage;
	item.iSelectedImage = nSelectedImage;
	item.state = nState;
	item.stateMask = nStateMask;
	item.lParam = lParam;
	item.uStateEx = uStateEx;
	item.hwnd = hWnd;
	item.iExpandedImage = iExpandedImage;
	return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)&item);
}
#endif

HTREEITEM CTreeCtrl::InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
	int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
	HTREEITEM hParent, HTREEITEM hInsertAfter)
{
	ASSERT(::IsWindow(m_hWnd));
	TVINSERTSTRUCT tvis;
	tvis.hParent = hParent;
	tvis.hInsertAfter = hInsertAfter;
	tvis.item.mask = nMask;
	tvis.item.pszText = (LPTSTR) lpszItem;
	tvis.item.iImage = nImage;
	tvis.item.iSelectedImage = nSelectedImage;
	tvis.item.state = nState;
	tvis.item.stateMask = nStateMask;
	tvis.item.lParam = lParam;
	return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
}

HTREEITEM CTreeCtrl::HitTest(CPoint pt, UINT* pFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	TVHITTESTINFO hti;
	hti.pt = pt;
	HTREEITEM h = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0,
		(LPARAM)&hti);
	if (pFlags != NULL)
		*pFlags = hti.flags;
	return h;
}

void CTreeCtrl::RemoveImageList(int nImageList)
{
	HIMAGELIST h = (HIMAGELIST)SendMessage(TVM_GETIMAGELIST,
		(WPARAM)nImageList);
	if (CImageList::FromHandlePermanent(h) != NULL)
		SendMessage(TVM_SETIMAGELIST, (WPARAM)nImageList, NULL);
}

void CTreeCtrl::OnDestroy()
{
	RemoveImageList(LVSIL_NORMAL);
	RemoveImageList(LVSIL_STATE);

	CWnd::OnDestroy();
}

CImageList* CTreeCtrl::CreateDragImage(HTREEITEM hItem)
{
	ASSERT(::IsWindow(m_hWnd));

	HIMAGELIST hImageList = (HIMAGELIST)::SendMessage(m_hWnd,
		TVM_CREATEDRAGIMAGE, 0, (LPARAM)hItem);
	if (hImageList == NULL)
		return NULL;

	CImageList* pImageList = new CImageList;
	VERIFY(pImageList->Attach(hImageList));
	return pImageList;
}

BOOL CTreeCtrl::GetCheck(HTREEITEM hItem) const
{
	ASSERT(::IsWindow(m_hWnd));
	TVITEM item;
	item.mask = TVIF_HANDLE | TVIF_STATE;
	item.hItem = hItem;
	item.stateMask = TVIS_STATEIMAGEMASK;
	VERIFY(::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item));
	// Return zero if it's not checked, or nonzero otherwise.
	return ((BOOL)(item.state >> 12) -1);
}

BOOL CTreeCtrl::SetCheck(HTREEITEM hItem, BOOL fCheck)
{
	ASSERT(::IsWindow(m_hWnd));
	TVITEM item;
	item.mask = TVIF_HANDLE | TVIF_STATE;
	item.hItem = hItem;
	item.stateMask = TVIS_STATEIMAGEMASK;

	 // Since state images are one-based, passing a 1 to the 
	 // INDEXTOSTATEIMAGEMASK macro turns the check off, and
	// passing 2 turns it on.
	item.state = INDEXTOSTATEIMAGEMASK((fCheck ? 2 : 1));

	return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)&item);
}

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

BOOL CTreeCtrl::GetItemPartRect(HTREEITEM hItem, TVITEMPART nPart, LPRECT lpRect)
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(lpRect);
	TVGETITEMPARTRECTINFO info; 
	info.hti = hItem; 
	info.prc = lpRect; 
	info.partID = nPart; 
	return (BOOL)::SendMessage((m_hWnd), TVM_GETITEMPARTRECT, 0, (LPARAM)&info); 
}

UINT CTreeCtrl::GetItemStateEx(HTREEITEM hItem) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(hItem);

	TVITEMEX item;
	item.hItem = hItem;
	item.mask = TVIF_STATEEX;
	VERIFY(::SendMessage(m_hWnd, TVM_GETITEM,0,(LPARAM)&item));
	return item.uStateEx;
}

int CTreeCtrl::GetItemExpandedImageIndex(HTREEITEM hItem) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(hItem);

	TVITEMEX item;
	item.hItem = hItem;

	item.mask = TVIF_EXPANDEDIMAGE;
	item.uStateEx = TVIF_EXPANDEDIMAGE;
	VERIFY(::SendMessage(m_hWnd, TVM_GETITEM,0,(LPARAM)&item));
	return item.iExpandedImage;
}
#endif
/////////////////////////////////////////////////////////////////////////////
// CSpinButtonCtrl

BOOL CSpinButtonCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_UPDOWN_REG));

	CWnd* pWnd = this;
	return pWnd->Create(UPDOWN_CLASS, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CSpinButtonCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle,
	const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CSpinButtonCtrl::~CSpinButtonCtrl()
{
	DestroyWindow();
}

void CSpinButtonCtrl::GetRange(int &lower, int& upper) const
{
	ASSERT(::IsWindow(m_hWnd));
	LRESULT dw = ::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0l);
	lower = (int)(short)HIWORD(dw);
	upper = (int)(short)LOWORD(dw);
}

/////////////////////////////////////////////////////////////////////////////
// CSliderCtrl

BOOL CSliderCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_BAR_REG));

	CWnd* pWnd = this;
	return pWnd->Create(TRACKBAR_CLASS, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CSliderCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CSliderCtrl::~CSliderCtrl()
{
	DestroyWindow();
}

void CSliderCtrl::GetRange(int& nMin, int& nMax) const
{
	ASSERT(::IsWindow(m_hWnd));
	nMin = GetRangeMin();
	nMax = GetRangeMax();
}

void CSliderCtrl::SetRange(int nMin, int nMax, BOOL bRedraw)
{
	SetRangeMin(nMin, bRedraw); // instead of TBM_SETRANGE, use TBM_SETRANGEMIN and
	SetRangeMax(nMax, bRedraw); // TBM_SETRANGEMAX which use LONGs instead of WORDs.
}

void CSliderCtrl::GetSelection(int& nMin, int& nMax) const
{
	ASSERT(::IsWindow(m_hWnd));
	nMin = int(::SendMessage(m_hWnd, TBM_GETSELSTART, 0, 0L));
	nMax = int(::SendMessage(m_hWnd, TBM_GETSELEND, 0, 0L));
}

void CSliderCtrl::SetSelection(int nMin, int nMax)
{
	ASSERT(::IsWindow(m_hWnd));
	::SendMessage(m_hWnd, TBM_SETSELSTART, 0, (LPARAM)nMin); // instead of TBM_SETSEL, use TBM_SETSELSTART and
	::SendMessage(m_hWnd, TBM_SETSELEND, 0, (LPARAM)nMax);   // TBM_SETSELEND which use LONGs instead of WORDs.
}

/////////////////////////////////////////////////////////////////////////////
// CProgressCtrl

BOOL CProgressCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_PROGRESS_REG));

	CWnd* pWnd = this;
	return pWnd->Create(PROGRESS_CLASS, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CProgressCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle,
	const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CProgressCtrl::~CProgressCtrl()
{
	DestroyWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CHeaderCtrl

BOOL CHeaderCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_LISTVIEW_REG));

	CWnd* pWnd = this;
	return pWnd->Create(WC_HEADER, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CHeaderCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CHeaderCtrl::~CHeaderCtrl()
{
	DestroyWindow();
}

void CHeaderCtrl::DrawItem(LPDRAWITEMSTRUCT)
{
	ASSERT(FALSE);  // must override for self draw header controls
}

BOOL CHeaderCtrl::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	if (message != WM_DRAWITEM)
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);

	ASSERT(pResult == NULL);       // no return value expected
	UNUSED(pResult); // unused in release builds

	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CHotKeyCtrl

BOOL CHotKeyCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_HOTKEY_REG));

	CWnd* pWnd = this;
	return pWnd->Create(HOTKEY_CLASS, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CHotKeyCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CHotKeyCtrl::~CHotKeyCtrl()
{
	DestroyWindow();
}

void CHotKeyCtrl::GetHotKey(WORD &wVirtualKeyCode, WORD &wModifiers) const
{
	ASSERT(::IsWindow(m_hWnd));
	LRESULT dw = ::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
	wVirtualKeyCode = LOBYTE(LOWORD(dw));
	wModifiers = HIBYTE(LOWORD(dw));
}

CString CHotKeyCtrl::GetKeyName(UINT vk, BOOL fExtended)
{
	LONG lScan = MapVirtualKey(vk, 0) << 16;

	// if it's an extended key, add the extended flag
	if (fExtended)
		lScan |= 0x01000000L;

	CString str;
	int nBufferLen = 64;
	int nLen;
	do
	{
		nBufferLen *= 2;
		LPTSTR psz = str.GetBufferSetLength(nBufferLen);
		nLen = ::GetKeyNameText(lScan, psz, nBufferLen + 1);
		str.ReleaseBuffer(nLen);
	}
	while (nLen == nBufferLen);
	return str;
}

static const TCHAR szPlus[] = _T(" + ");

CString CHotKeyCtrl::GetHotKeyName() const
{
	ASSERT(::IsWindow(m_hWnd));

	CString strKeyName;
	WORD wCode;
	WORD wModifiers;

	GetHotKey(wCode, wModifiers);
	if (wCode != 0 || wModifiers != 0)
	{
		if (wModifiers & HOTKEYF_CONTROL)
		{
			strKeyName += GetKeyName(VK_CONTROL, FALSE);
			strKeyName += szPlus;
		}

		if (wModifiers & HOTKEYF_SHIFT)
		{
			strKeyName += GetKeyName(VK_SHIFT, FALSE);
			strKeyName += szPlus;
		}

		if (wModifiers & HOTKEYF_ALT)
		{
			strKeyName += GetKeyName(VK_MENU, FALSE);
			strKeyName += szPlus;
		}

		strKeyName += GetKeyName(wCode, wModifiers & HOTKEYF_EXT);
	}

	return strKeyName;
}

/////////////////////////////////////////////////////////////////////////////
// CTabCtrl

BEGIN_MESSAGE_MAP(CTabCtrl, CWnd)
	//{{AFX_MSG_MAP(CTabCtrl)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CTabCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_TAB_REG));

	CWnd* pWnd = this;
	return pWnd->Create(WC_TABCONTROL, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CTabCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd,	UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CTabCtrl::~CTabCtrl()
{
	DestroyWindow();
}

void CTabCtrl::DrawItem(LPDRAWITEMSTRUCT)
{
	ASSERT(FALSE);  // must override for self draw tab controls
}

BOOL CTabCtrl::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	if (message != WM_DRAWITEM)
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);

	ASSERT(pResult == NULL);       // no return value expected
	UNUSED(pResult); // unused in release builds

	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
}

void CTabCtrl::OnDestroy()
{
	HIMAGELIST h = (HIMAGELIST)SendMessage(TCM_GETIMAGELIST);
	if (CImageList::FromHandlePermanent(h) != NULL)
		SendMessage(TCM_SETIMAGELIST, NULL, NULL);

	CWnd::OnDestroy();
}

DWORD CTabCtrl::GetItemState(int nItem, DWORD dwMask) const
{
	ASSERT(::IsWindow(m_hWnd));

	TCITEM item;
	item.mask = TCIF_STATE;
	item.dwStateMask = dwMask;
	VERIFY(::SendMessage(m_hWnd, TCM_GETITEM, (WPARAM)nItem, (LPARAM)&item));

	return item.dwState;
}

BOOL CTabCtrl::SetItemState(int nItem, DWORD dwMask, DWORD dwState)
{
	ASSERT(::IsWindow(m_hWnd));

	TCITEM item;
	item.mask = TCIF_STATE;
	item.dwState = dwState;
	item.dwStateMask = dwMask;

	return (BOOL) ::SendMessage(m_hWnd, TCM_SETITEM,
		(WPARAM) nItem, (LPARAM) &item);
}

LONG CTabCtrl::InsertItem(UINT nMask, int nItem, LPCTSTR lpszItem,
	int nImage, LPARAM lParam)
{
	ASSERT(::IsWindow(m_hWnd));

	TCITEM item;
	item.mask = nMask;
	item.iImage = nImage;
	item.lParam = lParam;
	item.pszText = (LPTSTR) lpszItem;

	return (LONG) ::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM) &item);
}

LONG CTabCtrl::InsertItem(UINT nMask, int nItem, LPCTSTR lpszItem,
	int nImage, LPARAM lParam, DWORD dwState, DWORD dwStateMask)
{
	ASSERT(::IsWindow(m_hWnd));

	TCITEM item;
	item.mask = nMask;
	item.iImage = nImage;
	item.lParam = lParam;
	item.pszText = (LPTSTR) lpszItem;
	item.dwState = dwState;
	item.dwStateMask = dwStateMask;

	return (LONG) ::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM) &item);
}


/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrl

BOOL CAnimateCtrl::Create(DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_ANIMATE_REG));

	CWnd* pWnd = this;
	return pWnd->Create(ANIMATE_CLASS, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CAnimateCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}


CAnimateCtrl::~CAnimateCtrl()
{
	DestroyWindow();
}

#ifndef _AFX_NO_RICHEDIT_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// CRichEdit

CRichEditCtrl::~CRichEditCtrl()
{
	DestroyWindow();
}

#endif //!_AFX_NO_RICHEDIT_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// CImageList

CHandleMap* PASCAL afxMapHIMAGELIST(BOOL bCreate)
{
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	if (pState->m_pmapHIMAGELIST == NULL && bCreate)
	{
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
#ifndef _AFX_PORTABLE
		_PNH pnhOldHandler = AfxSetNewHandler(&AfxCriticalNewHandler);
#endif
		pState->m_pmapHIMAGELIST = new CHandleMap(RUNTIME_CLASS(CImageList),
			ConstructDestruct<CImageList>::Construct, ConstructDestruct<CImageList>::Destruct, 
			offsetof(CImageList, m_hImageList));

#ifndef _AFX_PORTABLE
		AfxSetNewHandler(pnhOldHandler);
#endif
		AfxEnableMemoryTracking(bEnable);
	}
	return pState->m_pmapHIMAGELIST;
}

CImageList::CImageList()
{
	m_hImageList = NULL;
}

CImageList::~CImageList()
{
	AFX_BEGIN_DESTRUCTOR

		DeleteImageList();

	AFX_END_DESTRUCTOR
}

HIMAGELIST CImageList::Detach()
{
	HIMAGELIST hImageList = m_hImageList;
	if (hImageList != NULL)
	{
		CHandleMap* pMap = afxMapHIMAGELIST();
		if (pMap != NULL)
			pMap->RemoveHandle(m_hImageList);
	}

	m_hImageList = NULL;
	return hImageList;
}

BOOL CImageList::DeleteImageList()
{
	if (m_hImageList == NULL)
		return FALSE;
	return AfxImageList_Destroy(Detach());
}

CImageList* PASCAL CImageList::FromHandle(HIMAGELIST h)
{
	CHandleMap* pMap = afxMapHIMAGELIST(TRUE);
	ASSERT(pMap != NULL);
	CImageList* pImageList = (CImageList*)pMap->FromHandle(h);
	ASSERT(pImageList == NULL || pImageList->m_hImageList == h);
	return pImageList;
}

CImageList* PASCAL CImageList::FromHandlePermanent(HIMAGELIST h)
{
	CHandleMap* pMap = afxMapHIMAGELIST();
	CImageList* pImageList = NULL;
	if (pMap != NULL)
	{
		// only look in the permanent map - does no allocations
		pImageList = (CImageList*)pMap->LookupPermanent(h);
		ASSERT(pImageList == NULL || pImageList->m_hImageList == h);
	}
	return pImageList;
}

BOOL CImageList::Create(int cx, int cy, UINT nFlags, int nInitial, int nGrow)
{
	return Attach(AfxImageList_Create(cx, cy, nFlags, nInitial, nGrow));
}

BOOL CImageList::Create(UINT nBitmapID, int cx, int nGrow, COLORREF crMask)
{
	ASSERT(HIWORD(nBitmapID) == 0);
	HINSTANCE hInst = AfxFindResourceHandle((LPCTSTR)(DWORD_PTR)nBitmapID, RT_BITMAP);
	ASSERT(hInst != NULL);
	return Attach(AfxImageList_LoadBitmap(hInst, 
		(LPCTSTR)(DWORD_PTR)nBitmapID, cx, nGrow, crMask));
}

BOOL CImageList::Create(LPCTSTR lpszBitmapID, int cx, int nGrow,
	COLORREF crMask)
{
	HINSTANCE hInst = AfxFindResourceHandle(lpszBitmapID, RT_BITMAP);
	ASSERT(hInst != NULL);
	return Attach(AfxImageList_LoadBitmap(hInst, lpszBitmapID, cx, nGrow, crMask));
}

BOOL CImageList::Create(CImageList& imagelist1, int nImage1,
	CImageList& imagelist2, int nImage2, int dx, int dy)
{
	return Attach(AfxImageList_Merge(imagelist1.m_hImageList, nImage1,
		imagelist2.m_hImageList, nImage2, dx, dy));
}

BOOL CImageList::Attach(HIMAGELIST hImageList)
{
	ASSERT(m_hImageList == NULL);      // only attach once, detach on destroy
	ASSERT(FromHandlePermanent(hImageList) == NULL);

	if (hImageList == NULL)
		return FALSE;

	CHandleMap* pMap = afxMapHIMAGELIST(TRUE);
	ASSERT(pMap != NULL);

	pMap->SetPermanent(m_hImageList = hImageList, this);
	return TRUE;
}

#ifndef _AFX_NO_OLE_SUPPORT
BOOL CImageList::Read(CArchive* pArchive)
{
	ASSERT(m_hImageList == NULL);
	ASSERT(pArchive != NULL);
	ASSERT(pArchive->IsLoading());
	CArchiveStream arcstream(pArchive);

	m_hImageList = AfxImageList_Read(&arcstream);
	return (m_hImageList != NULL);
}

BOOL CImageList::Write(CArchive* pArchive)
{
	ASSERT(m_hImageList != NULL);
	ASSERT(pArchive != NULL);
	ASSERT(pArchive->IsStoring());
	CArchiveStream arcstream(pArchive);
	return AfxImageList_Write(m_hImageList, &arcstream);
}
#endif //_AFX_NO_OLE_SUPPORT

#ifdef _DEBUG
void CImageList::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_hImageList = " << (void*)m_hImageList;
	dc << "\n";
}

void CImageList::AssertValid() const
{
	CObject::AssertValid();
	if (m_hImageList == NULL)
		return;
	// should also be in the permanent or temporary handle map
	CObject* p=NULL;

	CHandleMap* pMap = afxMapHIMAGELIST();
	ASSERT(pMap != NULL);

	if(pMap)
	{
		ASSERT((p = pMap->LookupPermanent(m_hImageList)) != NULL ||
			(p = pMap->LookupTemporary(m_hImageList)) != NULL);
	}
	ASSERT((CImageList*)p == this);   // must be us
}
#endif


/////////////////////////////////////////////////////////////////////////////


#ifndef _AFX_ENABLE_INLINES

#define _AFXCMN_INLINE
#include "afxcmn.inl"

#endif //_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(CDragListBox, CListBox)
IMPLEMENT_DYNAMIC(CSpinButtonCtrl, CWnd)
IMPLEMENT_DYNAMIC(CSliderCtrl, CWnd)
IMPLEMENT_DYNAMIC(CProgressCtrl, CWnd)
IMPLEMENT_DYNAMIC(CComboBoxEx, CComboBox)
IMPLEMENT_DYNAMIC(CHeaderCtrl, CWnd)
IMPLEMENT_DYNAMIC(CHotKeyCtrl, CWnd)
IMPLEMENT_DYNAMIC(CAnimateCtrl, CWnd)
IMPLEMENT_DYNAMIC(CTabCtrl, CWnd)
IMPLEMENT_DYNAMIC(CTreeCtrl, CWnd)
IMPLEMENT_DYNAMIC(CListCtrl, CWnd)
IMPLEMENT_DYNAMIC(CToolBarCtrl, CWnd)
IMPLEMENT_DYNAMIC(CStatusBarCtrl, CWnd)
IMPLEMENT_DYNCREATE(CImageList, CObject)

#ifndef _AFX_NO_RICHEDIT_SUPPORT
IMPLEMENT_DYNAMIC(CRichEditCtrl, CWnd)
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winctrl3.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// _AFX_CHECKLIST_STATE

class _AFX_CHECKLIST_STATE : public CNoTrackObject
{
public:
	_AFX_CHECKLIST_STATE();
	virtual ~_AFX_CHECKLIST_STATE();

	HBITMAP m_hbitmapCheck;
	CSize m_sizeCheck;

// Controls are themed only if comctl32 6.0 or greater is loaded.
// Don't call the Theme API's if a themed version of comctl32 is not loaded.
	DWORD m_dwVerComCtl32;
};

_AFX_CHECKLIST_STATE::_AFX_CHECKLIST_STATE()
{
	CBitmap bitmap;

	VERIFY(bitmap.LoadBitmap(AFX_IDB_CHECKLISTBOX_95));

	BITMAP bm;
	bitmap.GetObject(sizeof (BITMAP), &bm);
	m_sizeCheck.cx = bm.bmWidth / 3;
	m_sizeCheck.cy = bm.bmHeight;
	m_hbitmapCheck = (HBITMAP)bitmap.Detach();

	// Cannot initialize here since conctl32.dll may not yet be loaded and/or
	// this code is executed during DllMain	
	m_dwVerComCtl32 = 0;
}

_AFX_CHECKLIST_STATE::~_AFX_CHECKLIST_STATE()
{
	if (m_hbitmapCheck != NULL)
		::DeleteObject(m_hbitmapCheck);
}

EXTERN_PROCESS_LOCAL(_AFX_CHECKLIST_STATE, _afxChecklistState)

/////////////////////////////////////////////////////////////////////////////
// AFX_CHECK_DATA

struct AFX_CHECK_DATA
{
public:
	int m_nCheck;
	BOOL m_bEnabled;
	UINT_PTR m_dwUserData;

	AFX_CHECK_DATA()
	{
		m_nCheck = 0;
		m_bEnabled = TRUE;
		m_dwUserData = 0;
	};
};

/////////////////////////////////////////////////////////////////////////////
// CCheckListBox

BEGIN_MESSAGE_MAP(CCheckListBox, CListBox)
	//{{AFX_MSG_MAP(CCheckListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_KEYDOWN()
	ON_WM_CREATE()
	ON_WM_LBUTTONDBLCLK()
	ON_MESSAGE(WM_SETFONT, &CCheckListBox::OnSetFont)
	ON_MESSAGE(LB_ADDSTRING, &CCheckListBox::OnLBAddString)
	ON_MESSAGE(LB_FINDSTRING, &CCheckListBox::OnLBFindString)
	ON_MESSAGE(LB_FINDSTRINGEXACT, &CCheckListBox::OnLBFindStringExact)
	ON_MESSAGE(LB_GETITEMDATA, &CCheckListBox::OnLBGetItemData)
	ON_MESSAGE(LB_GETTEXT, &CCheckListBox::OnLBGetText)
	ON_MESSAGE(LB_INSERTSTRING, &CCheckListBox::OnLBInsertString)
	ON_MESSAGE(LB_SELECTSTRING, &CCheckListBox::OnLBSelectString)
	ON_MESSAGE(LB_SETITEMDATA, &CCheckListBox::OnLBSetItemData)
	ON_MESSAGE(LB_SETITEMHEIGHT, &CCheckListBox::OnLBSetItemHeight)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CCheckListBox::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	if (!(dwStyle & LBS_OWNERDRAWVARIABLE)) //must be one or the other
		dwStyle |= LBS_OWNERDRAWFIXED;

	return CListBox::Create(dwStyle, rect, pParentWnd, nID);
}

void CCheckListBox::SetCheckStyle(UINT nStyle)
{
	ASSERT(nStyle == 0 || nStyle == BS_CHECKBOX ||
		nStyle == BS_AUTOCHECKBOX || nStyle == BS_AUTO3STATE ||
		nStyle == BS_3STATE);

	m_nStyle = nStyle;
}

void CCheckListBox::SetCheck(int nIndex, int nCheck)
{
	ASSERT(::IsWindow(m_hWnd));

	if (nCheck == 2)
	{
		if (m_nStyle == BS_CHECKBOX || m_nStyle == BS_AUTOCHECKBOX)
		{
			// Fire accessibility event
			// nIndex is 0 based and accessibility index is 1 based
			NotifyWinEvent(EVENT_OBJECT_STATECHANGE, OBJID_CLIENT, nIndex + 1);
			return;
		}
	}

	LRESULT lResult = DefWindowProc(LB_GETITEMDATA, nIndex, 0);
	if (lResult != LB_ERR)
	{

		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)lResult;

		if (pState == NULL)
			pState = new AFX_CHECK_DATA;

		pState->m_nCheck = nCheck;
		VERIFY(DefWindowProc(LB_SETITEMDATA, nIndex, (LPARAM)pState) != LB_ERR);

		InvalidateCheck(nIndex);
		// Fire accessibility event
		// nIndex is 0 based and accessibility index is 1 based
		NotifyWinEvent(EVENT_OBJECT_STATECHANGE, OBJID_CLIENT, nIndex + 1);
	}
}

int CCheckListBox::GetCheck(int nIndex)
{
	ASSERT(::IsWindow(m_hWnd));

	LRESULT lResult = DefWindowProc(LB_GETITEMDATA, nIndex, 0);
	if (lResult != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)lResult;
		if (pState != NULL)
			return pState->m_nCheck;
	}
	return 0; // The default
}

void CCheckListBox::Enable(int nIndex, BOOL bEnabled)
{
	ASSERT(::IsWindow(m_hWnd));

	LRESULT lResult = DefWindowProc(LB_GETITEMDATA, nIndex, 0);
	if (lResult != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)lResult;

		if (pState == NULL)
			pState = new AFX_CHECK_DATA;

		pState->m_bEnabled = bEnabled;
		VERIFY(DefWindowProc(LB_SETITEMDATA, nIndex, (LPARAM)pState) != LB_ERR);

		InvalidateItem(nIndex);
	}
}

BOOL CCheckListBox::IsEnabled(int nIndex)
{
	ASSERT(::IsWindow(m_hWnd));

	LRESULT lResult = DefWindowProc(LB_GETITEMDATA, nIndex, 0);
	if (lResult != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)lResult;
		if (pState != NULL)
			return pState->m_bEnabled;
	}
	return TRUE; // The default
}

CRect CCheckListBox::OnGetCheckPosition(CRect, CRect rectCheckBox)
{
	return rectCheckBox;
}

void CCheckListBox::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	// You must override DrawItem and MeasureItem for LBS_OWNERDRAWVARIABLE
	ASSERT((GetStyle() & (LBS_OWNERDRAWFIXED | LBS_HASSTRINGS)) ==
		(LBS_OWNERDRAWFIXED | LBS_HASSTRINGS));

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	ENSURE(pDC);

	if (((LONG)(lpDrawItemStruct->itemID) >= 0) &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
	{
		int cyItem = GetItemHeight(lpDrawItemStruct->itemID);
		BOOL fDisabled = !IsWindowEnabled() || !IsEnabled(lpDrawItemStruct->itemID);

		COLORREF newTextColor = fDisabled ?
			RGB(0x80, 0x80, 0x80) : GetSysColor(COLOR_WINDOWTEXT);  // light gray
		COLORREF oldTextColor = pDC->SetTextColor(newTextColor);

		COLORREF newBkColor = GetSysColor(COLOR_WINDOW);
		COLORREF oldBkColor = pDC->SetBkColor(newBkColor);

		if (newTextColor == newBkColor)
			newTextColor = RGB(0xC0, 0xC0, 0xC0);   // dark gray

		if (!fDisabled && ((lpDrawItemStruct->itemState & ODS_SELECTED) != 0))
		{
			pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
			pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		}

		if (m_cyText == 0)
			VERIFY(cyItem >= CalcMinimumItemHeight());

		CString strText;
		GetText(lpDrawItemStruct->itemID, strText);

		pDC->ExtTextOut(lpDrawItemStruct->rcItem.left,
			lpDrawItemStruct->rcItem.top + max(0, (cyItem - m_cyText) / 2),
			ETO_OPAQUE, &(lpDrawItemStruct->rcItem), strText, (int)strText.GetLength(), NULL);

		pDC->SetTextColor(oldTextColor);
		pDC->SetBkColor(oldBkColor);
	}

	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
		pDC->DrawFocusRect(&(lpDrawItemStruct->rcItem));
}

void CCheckListBox::MeasureItem(LPMEASUREITEMSTRUCT)
{
	// You must override DrawItem and MeasureItem for LBS_OWNERDRAWVARIABLE
	ASSERT((GetStyle() & (LBS_OWNERDRAWFIXED | LBS_HASSTRINGS)) ==
		(LBS_OWNERDRAWFIXED | LBS_HASSTRINGS));
}

void CCheckListBox::PreDrawItemHelper(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if (lpDrawItemStruct->itemData != 0 && lpDrawItemStruct->itemData != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)lpDrawItemStruct->itemData;
		lpDrawItemStruct->itemData = pState->m_dwUserData;
	}
	DrawItem(lpDrawItemStruct);
}

bool CCheckListBox::PreDrawItemThemed(CDC* pDC, DRAWITEMSTRUCT &drawItem, int nCheck, int cyItem)
{
	bool bRet = false;
	// Draw the check boxes using the theme API's only if the app is themed.
	if (CThemeHelper::IsAppThemed())
	{
		HTHEME hTheme = CThemeHelper::OpenThemeData(m_hWnd, L"Button");
		if (hTheme != NULL)
		{
			int nState = CBS_UNCHECKEDNORMAL;
			switch (nCheck)
			{
			case 1 :
				nState = CBS_CHECKEDNORMAL;
				break;
			case 2 :
				nState = CBS_UNCHECKEDDISABLED;
			}

			SIZE size;
			
			if (SUCCEEDED(CThemeHelper::GetThemePartSize(hTheme, pDC->m_hDC, BP_CHECKBOX, nState, NULL, TS_TRUE, &size)))
			{
				CRect rectCheck = drawItem.rcItem;
				rectCheck.left += 1;
				rectCheck.top += 1 + max(0, (cyItem - size.cy) / 2);
				rectCheck.right = rectCheck.left + size.cx;
				rectCheck.bottom = rectCheck.top + size.cy;
				//ASSERT(rectCheck.IntersectRect(rectItem, rectCheckBox));
				//ASSERT((rectCheck == rectCheckBox) && (rectCheckBox.Size() == pChecklistState->m_sizeCheck));

				CRect rectItem = drawItem.rcItem;
				rectItem.right = rectItem.left + size.cx + 2;

				CRect rectCheckBox = OnGetCheckPosition(rectItem, rectCheck);
				if (SUCCEEDED(CThemeHelper::DrawThemeBackground(hTheme, pDC->m_hDC, BP_CHECKBOX, nState, &rectCheckBox, NULL)))
				{
					bRet = true;
					drawItem.rcItem.left = drawItem.rcItem.left + size.cx + 3;
				}
				CThemeHelper::CloseThemeData(hTheme);
			}
		}
	}
	return bRet;
}

void CCheckListBox::PreDrawItemNonThemed(CDC* pDC, DRAWITEMSTRUCT &drawItem, int nCheck, int cyItem)
{
	_AFX_CHECKLIST_STATE* pChecklistState = _afxChecklistState;		
	CDC bitmapDC;
	if (bitmapDC.CreateCompatibleDC(pDC))
	{

		// Change Compatible DC to LTR since the bitmap is LTR
		DWORD dwLayoutBitmapDC = bitmapDC.GetLayout();
		bitmapDC.SetLayout(0);

		HBITMAP hOldBitmap = (HBITMAP)::SelectObject(bitmapDC.m_hDC, pChecklistState->m_hbitmapCheck);

		CRect rectCheck = drawItem.rcItem;
		rectCheck.left += 1;
		rectCheck.top += 1 + max(0, (cyItem - pChecklistState->m_sizeCheck.cy) / 2);
		rectCheck.right = rectCheck.left + pChecklistState->m_sizeCheck.cx;
		rectCheck.bottom = rectCheck.top + pChecklistState->m_sizeCheck.cy;

		CRect rectItem = drawItem.rcItem;
		rectItem.right = rectItem.left + pChecklistState->m_sizeCheck.cx + 2;
		CRect rectCheckBox = OnGetCheckPosition(rectItem, rectCheck);

		ASSERT(rectCheck.IntersectRect(rectItem, rectCheckBox));
		ASSERT((rectCheck == rectCheckBox) && (rectCheckBox.Size() == pChecklistState->m_sizeCheck));

		COLORREF newBkColor = GetSysColor(COLOR_WINDOW);

		BOOL fDisabled = !IsWindowEnabled() || !IsEnabled(drawItem.itemID);
		if ((drawItem.itemState & ODS_SELECTED) && !fDisabled)
			newBkColor = GetSysColor(COLOR_HIGHLIGHT);

		CBrush brush(newBkColor);
		pDC->FillRect(rectItem, &brush);

		DWORD dwLayoutDC = pDC->GetLayout();

		// Change destination DC layout to preserve bitmap orientation
		pDC->SetLayout(dwLayoutDC | LAYOUT_BITMAPORIENTATIONPRESERVED);

		pDC->BitBlt(rectCheckBox.left, rectCheckBox.top,
			pChecklistState->m_sizeCheck.cx, pChecklistState->m_sizeCheck.cy, &bitmapDC,
			pChecklistState->m_sizeCheck.cx  * nCheck, 0, SRCCOPY);

		// Restore DC layout
		pDC->SetLayout(dwLayoutDC);

		bitmapDC.SetLayout(dwLayoutBitmapDC);
		::SelectObject(bitmapDC.m_hDC, hOldBitmap);
		drawItem.rcItem.left = drawItem.rcItem.left + pChecklistState->m_sizeCheck.cx + 3;
	}
}

void CCheckListBox::PreDrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	DRAWITEMSTRUCT drawItem = *lpDrawItemStruct;

	if ((((LONG)drawItem.itemID) >= 0) && (drawItem.itemAction != 0))
	{
		int cyItem = GetItemHeight(drawItem.itemID);

		CDC* pDC = CDC::FromHandle(drawItem.hDC);

		COLORREF newBkColor = GetSysColor(COLOR_WINDOW);

		BOOL fDisabled = !IsWindowEnabled() || !IsEnabled(drawItem.itemID);
		if ((drawItem.itemState & ODS_SELECTED) && !fDisabled)
			newBkColor = GetSysColor(COLOR_HIGHLIGHT);

		COLORREF oldBkColor = pDC->SetBkColor(newBkColor);

		int nCheck = GetCheck(drawItem.itemID);
		bool bThemed = false;

		_AFX_CHECKLIST_STATE* pChecklistState = _afxChecklistState;		
		// use of comctl32 6.0 or greater indicates that the control can be themed.
		if (pChecklistState->m_dwVerComCtl32 == 0)
		{
			DWORD dwMinor;

			HRESULT hr = AtlGetCommCtrlVersion(&pChecklistState->m_dwVerComCtl32, &dwMinor);
			if (FAILED(hr))
			{
				// Could not get comctl32's version. Default to < 6
				pChecklistState->m_dwVerComCtl32 = 5;
			}
		}

		if (pChecklistState->m_dwVerComCtl32 >= 6)
		{
			bThemed = PreDrawItemThemed(pDC, drawItem, nCheck, cyItem);
		}

		if (!bThemed)
		{
			PreDrawItemNonThemed(pDC, drawItem, nCheck, cyItem);
		}

		pDC->SetBkColor(oldBkColor);
	}
	PreDrawItemHelper(&drawItem);
}

void CCheckListBox::PreMeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	int cyItem = CalcMinimumItemHeight();

	MEASUREITEMSTRUCT measureItem = *lpMeasureItemStruct;

	measureItem.itemHeight = cyItem;
	measureItem.itemWidth  = (UINT)-1;

	// Windows95 and Windows NT disagree on what this value
	// should be.  According to the docs, they are both wrong
	if (GetStyle() & LBS_OWNERDRAWVARIABLE)
	{
		LRESULT lResult = DefWindowProc(LB_GETITEMDATA, measureItem.itemID, 0);
		if (lResult != LB_ERR)
			measureItem.itemData = lResult;
		else
			measureItem.itemData = 0;

		// This is only done in the LBS_OWNERDRAWVARIABLE case
		// because Windows 95 does not initialize itemData to zero in the
		// case of LBS_OWNERDRAWFIXED list boxes (it is stack garbage).
		if (measureItem.itemData != 0 && measureItem.itemData != LB_ERR)
		{
			AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)measureItem.itemData;
			measureItem.itemData = pState->m_dwUserData;
		}
	}

	MeasureItem(&measureItem);

	lpMeasureItemStruct->itemHeight = max(measureItem.itemHeight,(UINT) cyItem);
	lpMeasureItemStruct->itemWidth = measureItem.itemWidth;
}

int CCheckListBox::PreCompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct)
{
	COMPAREITEMSTRUCT compareItem = *lpCompareItemStruct;

	if (compareItem.itemData1 != 0 && compareItem.itemData1 != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)compareItem.itemData1;
		compareItem.itemData1 = pState->m_dwUserData;
	}
	if (compareItem.itemData2 != 0 && compareItem.itemData2 != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)compareItem.itemData2;
		compareItem.itemData2 = pState->m_dwUserData;
	}
	return CompareItem(&compareItem);
}

void CCheckListBox::PreDeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct)
{
	DELETEITEMSTRUCT deleteItem = *lpDeleteItemStruct;

	// The following if block is required because Windows NT
	// version 3.51 does not properly fill out the LPDELETEITEMSTRUCT.
	if (deleteItem.itemData == 0)
	{
		LRESULT lResult = DefWindowProc(LB_GETITEMDATA, deleteItem.itemID, 0);
		if (lResult != LB_ERR)
			deleteItem.itemData = lResult;
	}

	if (deleteItem.itemData != 0 && deleteItem.itemData != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)deleteItem.itemData;
		deleteItem.itemData = pState->m_dwUserData;
		delete pState;
	}
	DeleteItem(&deleteItem);
}

BOOL CCheckListBox::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
	LRESULT* pResult)
{
	switch (message)
	{
	case WM_DRAWITEM:
		ASSERT(pResult == NULL);       // no return value expected
		PreDrawItem((LPDRAWITEMSTRUCT)lParam);
		break;
	case WM_MEASUREITEM:
		ASSERT(pResult == NULL);       // no return value expected
		PreMeasureItem((LPMEASUREITEMSTRUCT)lParam);
		break;
	case WM_COMPAREITEM:
		ASSERT(pResult != NULL);       // return value expected
		*pResult = PreCompareItem((LPCOMPAREITEMSTRUCT)lParam);
		break;
	case WM_DELETEITEM:
		ASSERT(pResult == NULL);       // no return value expected
		PreDeleteItem((LPDELETEITEMSTRUCT)lParam);
		break;
	default:
		return CListBox::OnChildNotify(message, wParam, lParam, pResult);
	}
	return TRUE;
}

#ifdef _DEBUG
void CCheckListBox::PreSubclassWindow()
{
	CListBox::PreSubclassWindow();

	// CCheckListBoxes must be owner drawn
	ASSERT(GetStyle() & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE));
}
#endif

int CCheckListBox::CalcMinimumItemHeight()
{
	int nResult;

	_AFX_CHECKLIST_STATE* pChecklistState = _afxChecklistState;

	if ((GetStyle() & (LBS_HASSTRINGS | LBS_OWNERDRAWFIXED)) ==
		(LBS_HASSTRINGS | LBS_OWNERDRAWFIXED))
	{
		CClientDC dc(this);
		CFont* pOldFont = dc.SelectObject(GetFont());
		TEXTMETRIC tm;
		VERIFY (dc.GetTextMetrics ( &tm ));
		dc.SelectObject(pOldFont);

		m_cyText = tm.tmHeight;
		nResult = max(pChecklistState->m_sizeCheck.cy + 1, m_cyText);
	}
	else
	{
		nResult = pChecklistState->m_sizeCheck.cy + 1;
	}

	return nResult;
}

void CCheckListBox::InvalidateCheck(int nIndex)
{
	CRect rect;
	_AFX_CHECKLIST_STATE* pChecklistState = _afxChecklistState;

	GetItemRect(nIndex, rect);
	rect.right = rect.left + pChecklistState->m_sizeCheck.cx + 2;
	InvalidateRect(rect, FALSE);
}

void CCheckListBox::InvalidateItem(int nIndex)
{
	CRect rect;
	GetItemRect(nIndex, rect);
	InvalidateRect(rect, FALSE);
}

int CCheckListBox::CheckFromPoint(CPoint point, BOOL& bInCheck)
{
	// assume did not hit anything
	bInCheck = FALSE;
	int nIndex = -1;

	_AFX_CHECKLIST_STATE* pChecklistState = _afxChecklistState;
	if ((GetStyle() & (LBS_OWNERDRAWFIXED|LBS_MULTICOLUMN)) == LBS_OWNERDRAWFIXED)
	{
		// optimized case for ownerdraw fixed, single column
		int cyItem = GetItemHeight(0);
		if (point.y < cyItem * GetCount())
		{
			nIndex = GetTopIndex() + point.y / cyItem;
			if (point.x < pChecklistState->m_sizeCheck.cx + 2)
				++bInCheck;
		}
	}
	else
	{
		// general case for ownerdraw variable or multiple column
		for (int i = GetTopIndex(); i < GetCount(); i++)
		{
			CRect itemRect;
			GetItemRect(i, &itemRect);
			if (itemRect.PtInRect(point))
			{
				nIndex = i;
				if (point.x < itemRect.left + pChecklistState->m_sizeCheck.cx + 2)
					++bInCheck;
				break;
			}
		}
	}
	return nIndex;
}

void CCheckListBox::SetSelectionCheck( int nCheck )
{
   int nSelectedItems;
   int iSelectedItem;

   nSelectedItems = GetSelCount();
   if( nSelectedItems > 0 )
   {
      CArray<int> rgiSelectedItems;
      rgiSelectedItems.SetSize(nSelectedItems);
	  int *piSelectedItems = rgiSelectedItems.GetData(); 
	  GetSelItems( nSelectedItems, piSelectedItems );
	  for( iSelectedItem = 0; iSelectedItem < nSelectedItems; iSelectedItem++ )
	  {
		 if( IsEnabled( piSelectedItems[iSelectedItem] ) )
		 {
			SetCheck( piSelectedItems[iSelectedItem], nCheck );
			InvalidateCheck( piSelectedItems[iSelectedItem] );
		 }
	  }
   }
}

void CCheckListBox::OnLButtonDown(UINT nFlags, CPoint point)
{
   SetFocus();

   // determine where the click is
   BOOL bInCheck;
   int nIndex = CheckFromPoint(point, bInCheck);

   // if the item is disabled, then eat the click
   if (!IsEnabled(nIndex))
	  return;

   if (m_nStyle != BS_CHECKBOX && m_nStyle != BS_3STATE)
   {
	  // toggle the check mark automatically if the check mark was hit
	  if (bInCheck)
	  {
		 CWnd* pParent = GetParent();
		 ASSERT_VALID( pParent );

			int nModulo = (m_nStyle == BS_AUTO3STATE) ? 3 : 2;
		 int nCheck;
		 int nNewCheck;

		 nCheck = GetCheck( nIndex );
		 nCheck = (nCheck == nModulo) ? nCheck-1 : nCheck;
		 nNewCheck = (nCheck+1)%nModulo;
		 SetCheck( nIndex, nNewCheck );
		 InvalidateCheck( nIndex );

		 if( (GetStyle()&(LBS_EXTENDEDSEL|LBS_MULTIPLESEL)) && GetSel(
			nIndex ) )
		 {
			// The listbox is a multi-select listbox, and the user clicked on
			// a selected check, so change the check on all of the selected 
			// items.
			SetSelectionCheck( nNewCheck );
		 }
		 else
		 {
			CListBox::OnLButtonDown( nFlags, point );
		 }

		 // Inform parent of check
		 pParent->SendMessage( WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(), 
			CLBN_CHKCHANGE ), (LPARAM)m_hWnd );
		 return;
	  }
   }

	// do default listbox selection logic
   CListBox::OnLButtonDown( nFlags, point );
}

void CCheckListBox::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	BOOL bInCheck;
	CheckFromPoint(point, bInCheck);

	if (bInCheck)
	{
		// Double and single clicks act the same on the check box!
		OnLButtonDown(nFlags, point);
		return;
	}

	CListBox::OnLButtonDblClk(nFlags, point);
}

void CCheckListBox::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_SPACE)
	{
		int nIndex = GetCaretIndex();
		CWnd* pParent = GetParent();
		ASSERT_VALID(pParent);

		if (nIndex != LB_ERR)
		{
			if (m_nStyle != BS_CHECKBOX && m_nStyle != BS_3STATE)
			{
				if ((GetStyle() & LBS_MULTIPLESEL) != 0)
				{
					if (IsEnabled(nIndex))
					{
						BOOL bSelected = GetSel(nIndex);
						if (bSelected)
						{
							int nModulo = (m_nStyle == BS_AUTO3STATE) ? 3 : 2;
							int nCheck = GetCheck(nIndex);
							nCheck = (nCheck == nModulo) ? nCheck - 1 : nCheck;
							SetCheck(nIndex, (nCheck + 1) % nModulo);

							// Inform of check
							pParent->SendMessage(WM_COMMAND,
								MAKEWPARAM(GetDlgCtrlID(), CLBN_CHKCHANGE),
								(LPARAM)m_hWnd);
						}
						SetSel(nIndex, !bSelected);
					}
					else
						SetSel(nIndex, FALSE); // unselect disabled items

					return;
				}
				else
				{
					// If there is a selection, the space bar toggles that check,
					// all other keys are the same as a standard listbox.

					if (IsEnabled(nIndex))
					{
						int nModulo = (m_nStyle == BS_AUTO3STATE) ? 3 : 2;
						int nCheck = GetCheck(nIndex);
						nCheck = (nCheck == nModulo) ? nCheck - 1 : nCheck;
				  int nNewCheck = (nCheck+1)%nModulo;
						SetCheck(nIndex, nNewCheck);

						InvalidateCheck(nIndex);

				  if( GetStyle()&LBS_EXTENDEDSEL )
				  {
					 // The listbox is a multi-select listbox, and the user 
					 // clicked on a selected check, so change the check on all 
					 // of the selected items.
					 SetSelectionCheck( nNewCheck );
				  }

						// Inform of check
						pParent->SendMessage(WM_COMMAND,
							MAKEWPARAM(GetDlgCtrlID(), CLBN_CHKCHANGE),
							(LPARAM)m_hWnd);
					}
					else
						SetSel(nIndex, FALSE); // unselect disabled items

					return;
				}
			}
		}
	}
	CListBox::OnKeyDown(nChar, nRepCnt, nFlags);
}

int CCheckListBox::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CListBox::OnCreate(lpCreateStruct) == -1)
		return -1;

	if ((GetStyle() & (LBS_OWNERDRAWFIXED | LBS_HASSTRINGS))
		== (LBS_OWNERDRAWFIXED | LBS_HASSTRINGS))
		SetItemHeight(0, CalcMinimumItemHeight());

	return 0;
}

LRESULT CCheckListBox::OnSetFont(WPARAM , LPARAM)
{
	Default();

	if ((GetStyle() & (LBS_OWNERDRAWFIXED | LBS_HASSTRINGS))
		== (LBS_OWNERDRAWFIXED | LBS_HASSTRINGS))
		SetItemHeight(0, CalcMinimumItemHeight());

	return 0;
}

LRESULT CCheckListBox::OnLBAddString(WPARAM wParam, LPARAM lParam)
{
	AFX_CHECK_DATA* pState = NULL;

	if (!(GetStyle() & LBS_HASSTRINGS))
	{
		pState = new AFX_CHECK_DATA;

		pState->m_dwUserData = lParam;
		lParam = (LPARAM)pState;
	}

	LRESULT lResult = DefWindowProc(LB_ADDSTRING, wParam, lParam);

	if (lResult == LB_ERR && pState != NULL)
		delete pState;

	return lResult;
}

LRESULT CCheckListBox::OnLBFindString(WPARAM wParam, LPARAM lParam)
{
	if (GetStyle() & LBS_HASSTRINGS)
		return DefWindowProc(LB_FINDSTRING, wParam, lParam);

	int nIndex = (int)wParam;
	if (nIndex == -1) nIndex = 0;

	for(; nIndex < GetCount(); nIndex++)
		if ((UINT_PTR)lParam == GetItemData(nIndex))
			return nIndex;

	return LB_ERR;
}

LRESULT CCheckListBox::OnLBFindStringExact(WPARAM wParam, LPARAM lParam)
{
	if (GetStyle() & (LBS_HASSTRINGS | LBS_SORT))
		return DefWindowProc(LB_FINDSTRINGEXACT, wParam, lParam);

	int nIndex = (int)wParam;
	if (nIndex == -1) nIndex = 0;

	for(; nIndex < GetCount(); nIndex++)
		if ((UINT_PTR)lParam == GetItemData(nIndex))
			return nIndex;

	return LB_ERR;
}

LRESULT CCheckListBox::OnLBGetItemData(WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = DefWindowProc(LB_GETITEMDATA, wParam, lParam);

	if (lResult != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)lResult;

		if (pState == NULL)
			return 0; // default

		lResult = pState->m_dwUserData;
	}
	return lResult;
}

LRESULT CCheckListBox::OnLBGetText(WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = DefWindowProc(LB_GETTEXT, wParam, lParam);

	if (GetStyle() & LBS_HASSTRINGS)
		return lResult;

	if (lResult != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)lParam;

		if (pState != NULL)
			lParam = pState->m_dwUserData;
	}
	return lResult;
}

LRESULT CCheckListBox::OnLBInsertString(WPARAM wParam, LPARAM lParam)
{
	AFX_CHECK_DATA* pState = NULL;

	if (!(GetStyle() & LBS_HASSTRINGS))
	{
		pState = new AFX_CHECK_DATA;
		pState->m_dwUserData = lParam;
		lParam = (LPARAM)pState;
	}

	LRESULT lResult = DefWindowProc(LB_INSERTSTRING, wParam, lParam);

	if (lResult == LB_ERR && pState != NULL)
		delete pState;

	return lResult;
}

LRESULT CCheckListBox::OnLBSelectString(WPARAM wParam, LPARAM lParam)
{
	if (GetStyle() & LBS_HASSTRINGS)
		return DefWindowProc(LB_SELECTSTRING, wParam, lParam);

	int nIndex = (int)wParam;
	if (nIndex == -1) nIndex = 0;

	for(; nIndex < GetCount(); nIndex++)
		if ((UINT_PTR)lParam == GetItemData(nIndex))
		{
			SetCurSel(nIndex);
			return nIndex;
		}

	return LB_ERR;
}

LRESULT CCheckListBox::OnLBSetItemData(WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = DefWindowProc(LB_GETITEMDATA, wParam, 0);

	if (lResult != LB_ERR)
	{
		AFX_CHECK_DATA* pState = (AFX_CHECK_DATA*)lResult;

		if (pState == NULL)
			pState = new AFX_CHECK_DATA;

		pState->m_dwUserData = lParam;
		lResult = DefWindowProc(LB_SETITEMDATA, wParam, (LPARAM)pState);

		if (lResult == LB_ERR)
			delete pState;
	}
	return lResult;
}

LRESULT CCheckListBox::OnLBSetItemHeight(WPARAM wParam, LPARAM lParam)
{
	int nHeight = max(CalcMinimumItemHeight(),(int)LOWORD(lParam));
	return DefWindowProc(LB_SETITEMHEIGHT, wParam, MAKELPARAM(nHeight,0));
}

// Active Accessibility support
HRESULT CCheckListBox::get_accState(VARIANT varChild, VARIANT *pvarState)
{
	HRESULT hr = CListBox::get_accState(varChild, pvarState);
	if (SUCCEEDED(hr) && pvarState->vt == VT_I4)
	{
		// Add on the check state for the child item
		if (varChild.lVal != CHILDID_SELF)
		{
			int nCheck = GetCheck(varChild.lVal - 1);
			if (nCheck == 1)
			{
				pvarState->lVal |= STATE_SYSTEM_CHECKED;
			}
			else if (nCheck == 2)
			{
				pvarState->lVal |= STATE_SYSTEM_MIXED;
			}
		}
	}
	return hr;
}
HRESULT CCheckListBox::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
	HRESULT hr = S_OK;
	if (varChild.lVal != CHILDID_SELF && varChild.lVal > 0 && varChild.lVal <= GetCount())
	{
		// if it is one of the items in the checked list box then set the item role to be a check box
		pvarRole->vt = VT_I4;
		pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
	}
	else
	{
		hr = CListBox::get_accRole(varChild, pvarRole);
	}
	return hr;
}

HRESULT CCheckListBox::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
	HRESULT hr = S_OK;
	if (varChild.lVal != CHILDID_SELF && varChild.lVal > 0 && varChild.lVal <= GetCount())
	{
		int nModulo = (m_nStyle == BS_AUTO3STATE) ? 3 : 2;
		int nCheck;
		int nNewCheck;

		nCheck = GetCheck(varChild.lVal - 1);
		nNewCheck = (nCheck+1)%nModulo;

		CString str;
		str.LoadString(AFX_IDS_CHECKLISTBOX_UNCHECK + nNewCheck);
		*pszDefaultAction = str.AllocSysString();
	}
	else
	{
		hr = CListBox::get_accDefaultAction(varChild, pszDefaultAction);
	}
	return hr;
}
HRESULT CCheckListBox::accDoDefaultAction(VARIANT varChild)
{
	HRESULT hr = S_OK;
	if (varChild.lVal != CHILDID_SELF && varChild.lVal > 0 && varChild.lVal <= GetCount())
	{
		// Default action is similar to clicking on the checkbox for one of the items.
		int nModulo = (m_nStyle == BS_AUTO3STATE) ? 3 : 2;
		int nCheck;
		int nNewCheck;

		nCheck = GetCheck(varChild.lVal - 1);
		nNewCheck = (nCheck+1)%nModulo;
		SetCheck(varChild.lVal - 1, nNewCheck);
		if( (GetStyle()&(LBS_EXTENDEDSEL|LBS_MULTIPLESEL)) && GetSel( varChild.lVal - 1 ) )
		{
			SetSelectionCheck(nNewCheck);
		}
		CWnd* pParent = GetParent();
		ASSERT_VALID( pParent );
		// Inform parent of check
		pParent->SendMessage( WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(), CLBN_CHKCHANGE ), (LPARAM)m_hWnd );
		SetSel(varChild.lVal - 1);
	}
	else
	{
		hr = CListBox::accDoDefaultAction(varChild);
	}
	return hr;
}


IMPLEMENT_DYNAMIC(CCheckListBox, CListBox)

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_CHECKLIST_STATE, _afxChecklistState)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winctrl5.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDateTimeCtrl

BOOL CDateTimeCtrl::Create(_In_ DWORD dwStyle, _In_ const RECT& rect,
	_In_ CWnd* pParentWnd, _In_ UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_DATE_REG));

	CWnd* pWnd = this;
	return pWnd->Create(DATETIMEPICK_CLASS, NULL, dwStyle, rect, pParentWnd, nID);
}

DWORD CDateTimeCtrl::GetRange(_Out_ CTime* pMinTime, _Out_ CTime* pMaxTime) const
{
	ASSERT(::IsWindow(m_hWnd));
	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));

	DWORD dwResult = DWORD(::SendMessage(m_hWnd, DTM_GETRANGE, 0, (LPARAM) sysTimes));

	if (pMinTime != NULL)
	{
		if (dwResult & GDTR_MIN)
			*pMinTime = CTime(sysTimes[0]);
	}

	if (pMaxTime != NULL)
	{
		if (dwResult & GDTR_MAX)
			*pMaxTime = CTime(sysTimes[1]);
	}

	return dwResult;

}

DWORD CDateTimeCtrl::GetRange(_Out_ COleDateTime* pMinTime, _Out_ COleDateTime* pMaxTime) const
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));

	DWORD dwResult = DWORD(::SendMessage(m_hWnd, DTM_GETRANGE, 0, (LPARAM) sysTimes));
	if (pMinTime != NULL)
	{
		if (dwResult & GDTR_MIN)
			*pMinTime = COleDateTime(sysTimes[0]);
		else
			pMinTime->SetStatus(COleDateTime::null);
	}

	if (pMaxTime != NULL)
	{
		if (dwResult & GDTR_MAX)
			*pMaxTime = COleDateTime(sysTimes[1]);
		else
			pMaxTime->SetStatus(COleDateTime::null);
	}

	return dwResult;
}

BOOL CDateTimeCtrl::SetRange(_In_ const CTime* pMinTime, _In_ const CTime* pMaxTime)
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];

	WPARAM wFlags = 0;
	if (pMinTime != NULL && pMinTime->GetAsSystemTime(sysTimes[0]))
		wFlags |= GDTR_MIN;

	if (pMaxTime != NULL && pMaxTime->GetAsSystemTime(sysTimes[1]))
		wFlags |= GDTR_MAX;

	return (BOOL) ::SendMessage(m_hWnd, DTM_SETRANGE, wFlags, (LPARAM) sysTimes);
}

BOOL CDateTimeCtrl::SetRange(_In_ const COleDateTime* pMinTime, _In_ const COleDateTime* pMaxTime)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pMinTime == NULL || pMinTime->GetStatus() != COleDateTime::invalid);
	ASSERT(pMaxTime == NULL || pMaxTime->GetStatus() != COleDateTime::invalid);

	SYSTEMTIME sysTime[2];

	WPARAM wFlags = 0;
	if (pMinTime != NULL && pMinTime->GetStatus() != COleDateTime::null)
	{
		if (pMinTime->GetAsSystemTime(sysTime[0]))
			wFlags |= GDTR_MIN;
	}

	if (pMaxTime != NULL && pMaxTime->GetStatus() != COleDateTime::null)
	{
		if (pMaxTime->GetAsSystemTime(sysTime[1]))
			wFlags |= GDTR_MAX;
	}

	return (BOOL) ::SendMessage(m_hWnd, DTM_SETRANGE, wFlags, (LPARAM) sysTime);
}

BOOL CDateTimeCtrl::SetTime(_In_ LPSYSTEMTIME pTimeNew /* = NULL */)
{
	ASSERT(::IsWindow(m_hWnd));
	WPARAM wParam = (pTimeNew == NULL) ? GDT_NONE : GDT_VALID;
	return (BOOL) ::SendMessage(m_hWnd, DTM_SETSYSTEMTIME,
		wParam, (LPARAM) pTimeNew);
}

BOOL CDateTimeCtrl::SetTime(_In_ const COleDateTime& timeNew)
{
	BOOL bRetVal = FALSE;

	// make sure the time isn't invalid
	ASSERT(timeNew.GetStatus() != COleDateTime::invalid);
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTime;
	WPARAM wParam = GDT_NONE;
	if (timeNew.GetStatus() == COleDateTime::valid &&
		timeNew.GetAsSystemTime(sysTime))
	{
		wParam = GDT_VALID;
	}

	bRetVal = (BOOL) ::SendMessage(m_hWnd,
			DTM_SETSYSTEMTIME, wParam, (LPARAM) &sysTime);

	return bRetVal;
}

BOOL CDateTimeCtrl::SetTime(_In_ const CTime* pTimeNew)
{
	BOOL bRetVal = FALSE;

	// make sure the time isn't invalid
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTime;
	WPARAM wParam = GDT_NONE;
	if (pTimeNew != NULL && pTimeNew->GetAsSystemTime(sysTime))
	{
		wParam = GDT_VALID;
	}

	bRetVal = (BOOL) ::SendMessage(m_hWnd,
			DTM_SETSYSTEMTIME, wParam, (LPARAM) &sysTime);

	return bRetVal;
}

BOOL CDateTimeCtrl::GetTime(_Out_ COleDateTime& timeDest) const
{
	SYSTEMTIME sysTime;
	BOOL bRetVal = TRUE;

	LRESULT result = ::SendMessage(m_hWnd, DTM_GETSYSTEMTIME, 0, (LPARAM) &sysTime);
	if (result == GDT_VALID)
	{
		timeDest = COleDateTime(sysTime);
		bRetVal = TRUE;
		ASSERT(timeDest.GetStatus() == COleDateTime::valid);
	}
	else if (result == GDT_NONE)
	{
		timeDest.SetStatus(COleDateTime::null);
		bRetVal = TRUE;
	}
	else
		timeDest.SetStatus(COleDateTime::invalid);
	return bRetVal;
}

DWORD CDateTimeCtrl::GetTime(_Out_ CTime& timeDest) const
{
	SYSTEMTIME sysTime;
	DWORD dwResult = (DWORD)
		::SendMessage(m_hWnd, DTM_GETSYSTEMTIME, 0, (LPARAM) &sysTime);

	if (dwResult == GDT_VALID)
		timeDest = CTime(sysTime);

	return dwResult;
}

CDateTimeCtrl::~CDateTimeCtrl()
{
	DestroyWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CMonthCalCtrl

BOOL CMonthCalCtrl::Create(_In_ DWORD dwStyle, _In_ const RECT& rect,
	_In_ CWnd* pParentWnd, _In_ UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_DATE_REG));

	CWnd* pWnd = this;
	return pWnd->Create(MONTHCAL_CLASS, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CMonthCalCtrl::Create(_In_ DWORD dwStyle, _In_ const POINT& pt,
	_In_ CWnd* pParentWnd, _In_ UINT nID)
{
	BOOL bWasVisible = (dwStyle & WS_VISIBLE);
	dwStyle &= ~WS_VISIBLE;

	CRect rect(pt.x, pt.y, 0, 0);

	BOOL bRetVal = FALSE;
	if (Create(dwStyle, rect, pParentWnd, nID))
	{
		if (SizeMinReq())
		{
			if (bWasVisible)
				ShowWindow(SW_SHOWNA);
			bRetVal = TRUE;
		}
		else
			DestroyWindow();
	}

	return bRetVal;
}

BOOL CMonthCalCtrl::SizeMinReq(_In_ BOOL bRepaint /* = TRUE */)
{
	CRect rect;
	BOOL bRetVal = FALSE;
	if (GetMinReqRect(rect))
	{
		DWORD dwFlags = SWP_NOZORDER | SWP_NOREPOSITION | SWP_NOMOVE | SWP_NOACTIVATE;
		if (!bRepaint)
			dwFlags |= SWP_NOREDRAW;
		SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(), dwFlags);
		bRetVal = TRUE;
	}

	return bRetVal;
}

void CMonthCalCtrl::SetToday(_In_ const COleDateTime& refTime)
{
	ASSERT_VALID(this);

	// make sure the time isn't invalid
	ASSERT(refTime.GetStatus() != COleDateTime::invalid);
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTime;
	LPSYSTEMTIME pSysTime = NULL;
	WPARAM wParam = GDT_NONE;

	// if the passed time is null or out of range,
	// we'll set the control to NULL

	if (refTime.GetAsSystemTime(sysTime))
	{
		pSysTime = &sysTime;
		wParam = GDT_VALID;
	}

	if (::IsWindow(m_hWnd))
		::SendMessage(m_hWnd, MCM_SETTODAY, wParam, (LPARAM) pSysTime);
}

void CMonthCalCtrl::SetToday(_In_ const CTime* pDateTime)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT_VALID(this);

	// if the passed time is NULL, we'll set the
	// control to NULL

	WPARAM wParam = GDT_NONE;
	LPSYSTEMTIME pSysTime = NULL;
	SYSTEMTIME sysTime;

	if (pDateTime != NULL && pDateTime->GetAsSystemTime(sysTime))
	{
		wParam = GDT_VALID;
		pSysTime = &sysTime;
	}

	if (::IsWindow(m_hWnd))
 		::SendMessage(m_hWnd, MCM_SETTODAY, wParam, (LPARAM) pSysTime);
}

BOOL CMonthCalCtrl::SetCurSel(_In_ const COleDateTime& refTime)
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTime;
	BOOL bRetVal = FALSE;

	// if the passed time is null or out of range,
	// we'll set the control to NULL

	if (refTime.GetAsSystemTime(sysTime) &&
		refTime.GetStatus() == COleDateTime::valid)
	{
		bRetVal = (BOOL)
			::SendMessage(m_hWnd, MCM_SETCURSEL, 0, (LPARAM) &sysTime);
	}

	return bRetVal;
}

BOOL CMonthCalCtrl::SetCurSel(_In_ const CTime& refTime)
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTime;
	BOOL bRetVal = FALSE;

	if (refTime.GetAsSystemTime(sysTime))
	{
		bRetVal = (BOOL)
			::SendMessage(m_hWnd, MCM_SETCURSEL, 0, (LPARAM) &sysTime);
	}

	return bRetVal;
}

BOOL CMonthCalCtrl::GetCurSel(_Out_ COleDateTime& refTime) const
{
	ASSERT(::IsWindow(m_hWnd));

	// can't use this method on multiple selection controls
	ASSERT(!(GetStyle() & MCS_MULTISELECT));

	SYSTEMTIME sysTime;
	BOOL bResult = GetCurSel(&sysTime);

	if (bResult)
		refTime = COleDateTime(sysTime);

	return bResult;
}

BOOL CMonthCalCtrl::GetToday(_Out_ COleDateTime& refTime) const
{
	ASSERT(::IsWindow(m_hWnd));

	// can't use this method on multiple selection controls
	ASSERT(!(GetStyle() & MCS_MULTISELECT));

	SYSTEMTIME sysTime;
	BOOL bResult = (BOOL)
		::SendMessage(m_hWnd, MCM_GETTODAY, 0, (LPARAM) &sysTime);

	if (bResult)
		refTime = COleDateTime(sysTime);

	return bResult;
}

BOOL CMonthCalCtrl::GetCurSel(_Out_ CTime& refTime) const
{
	ASSERT(::IsWindow(m_hWnd));

	// can't use this method on multiple selection controls
	ASSERT(!(GetStyle() & MCS_MULTISELECT));

	SYSTEMTIME sysTime;
	BOOL bResult = GetCurSel(&sysTime);

	if (bResult)
		refTime = CTime(sysTime);

	return bResult;
}

BOOL CMonthCalCtrl::GetToday(_Out_ CTime& refTime) const
{
	ASSERT(::IsWindow(m_hWnd));

 	// can't use this method on multiple selection controls
	ASSERT(!(GetStyle() & MCS_MULTISELECT));

	SYSTEMTIME sysTime;
	BOOL bResult = (BOOL)
		::SendMessage(m_hWnd, MCM_GETTODAY, 0, (LPARAM) &sysTime);

	if (bResult)
		refTime = CTime(sysTime);

	return bResult;
}

CMonthCalCtrl::~CMonthCalCtrl()
{
	DestroyWindow();
}

int CMonthCalCtrl::GetFirstDayOfWeek(_Out_ BOOL* pbLocal /* = NULL */) const
{
	ASSERT(::IsWindow(m_hWnd));
	DWORD dwResult;
	dwResult = (DWORD) ::SendMessage(m_hWnd, MCM_GETFIRSTDAYOFWEEK, 0, 0);

	// set *pbLocal to reflect if the first day of week
	// matches current locale setting

	if (pbLocal)
		*pbLocal = HIWORD(dwResult);
	return LOWORD(dwResult);
}

BOOL CMonthCalCtrl::SetFirstDayOfWeek(_In_ int iDay, _Out_ int* lpnOld /* = NULL */)
{
	ASSERT(::IsWindow(m_hWnd));
	DWORD dwResult;
	dwResult = (DWORD) ::SendMessage(m_hWnd, MCM_SETFIRSTDAYOFWEEK, 0, (WPARAM) iDay);

	if (lpnOld != NULL)
		*lpnOld = LOWORD(dwResult);

	return (BOOL) HIWORD(dwResult);
}

BOOL CMonthCalCtrl::SetDayState(_In_ int nMonths, _In_ LPMONTHDAYSTATE pStates)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(GetStyle()&MCS_DAYSTATE);
	ASSERT(AfxIsValidAddress(pStates, nMonths * sizeof(MONTHDAYSTATE), FALSE));
	return (BOOL) ::SendMessage(m_hWnd, MCM_SETDAYSTATE, (WPARAM) nMonths, (LPARAM) pStates);
}

BOOL CMonthCalCtrl::SetRange(_In_ const COleDateTime* pMinRange,
	_In_ const COleDateTime* pMaxRange)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pMinRange == NULL || pMinRange->GetStatus() != COleDateTime::invalid);
	ASSERT(pMaxRange == NULL || pMaxRange->GetStatus() != COleDateTime::invalid);

	SYSTEMTIME sysTimes[2];
	WPARAM wFlags = 0;

	if (pMinRange != NULL && pMinRange->GetStatus() != COleDateTime::null)
	{
		if (pMinRange->GetAsSystemTime(sysTimes[0]))
			wFlags |= GDTR_MIN;
	}

	if (pMaxRange != NULL && pMaxRange->GetStatus() != COleDateTime::null)
	{
		if (pMaxRange->GetAsSystemTime(sysTimes[1]))
			wFlags |= GDTR_MAX;
	}

	return (BOOL)
		::SendMessage(m_hWnd, MCM_SETRANGE, wFlags, (LPARAM) sysTimes);
}

BOOL CMonthCalCtrl::SetRange(_In_ const LPSYSTEMTIME pMinRange,
	_In_ const LPSYSTEMTIME pMaxRange)
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	WPARAM wFlags = 0;

	if (pMinRange != NULL)
	{
		sysTimes[0] =  *pMinRange;
		wFlags |= GDTR_MIN;
	}

	if (pMaxRange != NULL)
	{
		sysTimes[1] = *pMaxRange;
		wFlags |= GDTR_MAX;
	}

	return (BOOL)
		::SendMessage(m_hWnd, MCM_SETRANGE, wFlags, (LPARAM) sysTimes);
}

DWORD CMonthCalCtrl::GetRange(_Out_ COleDateTime* pMinRange,
	_Out_ COleDateTime* pMaxRange) const
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));

	DWORD dwRanges = (DWORD)
		::SendMessage(m_hWnd, MCM_GETRANGE, 0, (LPARAM) sysTimes);

	if (dwRanges & GDTR_MIN && pMinRange)
		*pMinRange = COleDateTime(sysTimes[0]);

	if (dwRanges & GDTR_MAX && pMaxRange)
		*pMaxRange = COleDateTime(sysTimes[1]);

	return dwRanges;
}

DWORD CMonthCalCtrl::GetRange(_Out_ LPSYSTEMTIME pMinRange,
	_Out_ LPSYSTEMTIME pMaxRange) const
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));

	DWORD dwRanges = (DWORD)
		::SendMessage(m_hWnd, MCM_GETRANGE, 0, (LPARAM) sysTimes);

	if (dwRanges & GDTR_MIN && pMinRange)
		*pMinRange = sysTimes[0];

	if (dwRanges & GDTR_MAX && pMaxRange)
		*pMaxRange = sysTimes[1];

	return dwRanges;
}

BOOL CMonthCalCtrl::SetRange(_In_ const CTime* pMinRange, _In_ const CTime* pMaxRange)
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	WPARAM wFlags = 0;
	if (pMinRange != NULL && pMinRange->GetAsSystemTime(sysTimes[0]))
		wFlags |= GDTR_MIN;

	if (pMaxRange != NULL && pMaxRange->GetAsSystemTime(sysTimes[1]))
		wFlags |= GDTR_MAX;

	return (BOOL)
		::SendMessage(m_hWnd, MCM_SETRANGE, wFlags, (LPARAM) sysTimes);
}

DWORD CMonthCalCtrl::GetRange(_Out_ CTime* pMinRange, _Out_ CTime* pMaxRange) const
{
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));

	DWORD dwRanges = (DWORD)
		::SendMessage(m_hWnd, MCM_GETRANGE, 0, (LPARAM) sysTimes);

	if (dwRanges & GDTR_MIN && pMinRange)
		*pMinRange = CTime(sysTimes[0]);

	if (dwRanges & GDTR_MAX && pMaxRange)
		*pMaxRange = CTime(sysTimes[1]);

	return dwRanges;
}

int CMonthCalCtrl::GetMonthRange(_Out_ COleDateTime& refMinRange,
	_Out_ COleDateTime& refMaxRange, _In_ DWORD dwFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(dwFlags == GMR_DAYSTATE || dwFlags == GMR_VISIBLE);

	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));
	int nCount = (int) ::SendMessage(m_hWnd, MCM_GETMONTHRANGE,
		(WPARAM) dwFlags, (LPARAM) sysTimes);

	refMinRange = COleDateTime(sysTimes[0]);
	refMaxRange = COleDateTime(sysTimes[1]);

	return nCount;
}

int CMonthCalCtrl::GetMonthRange(_Out_ LPSYSTEMTIME pMinRange,
	_Out_ LPSYSTEMTIME pMaxRange, _In_ DWORD dwFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT_POINTER(pMinRange, SYSTEMTIME);
	ASSERT_POINTER(pMaxRange, SYSTEMTIME);

	SYSTEMTIME sysTimes[2];

	int nCount = (int) ::SendMessage(m_hWnd, MCM_GETMONTHRANGE,
		(WPARAM) dwFlags, (LPARAM) sysTimes);

	*pMinRange = sysTimes[0];
	*pMaxRange = sysTimes[1];

	return nCount;
}

int CMonthCalCtrl::GetMonthRange(_Out_ CTime& refMinRange, _Out_ CTime& refMaxRange,
	_In_ DWORD dwFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(dwFlags == GMR_DAYSTATE || dwFlags == GMR_VISIBLE);

	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));
	int nCount = (int) ::SendMessage(m_hWnd, MCM_GETMONTHRANGE,
		(WPARAM) dwFlags, (LPARAM) sysTimes);

	refMinRange = CTime(sysTimes[0]);
	refMaxRange = CTime(sysTimes[1]);

	return nCount;
}

BOOL CMonthCalCtrl::GetSelRange(_Out_ LPSYSTEMTIME pMinRange,
	_Out_ LPSYSTEMTIME pMaxRange) const
{
	ASSERT(m_hWnd != NULL);
	ASSERT((GetStyle() & MCS_MULTISELECT));

	ASSERT_POINTER(pMinRange, SYSTEMTIME);
	ASSERT_POINTER(pMaxRange, SYSTEMTIME);

	SYSTEMTIME sysTimes[2];
	BOOL bReturn = (BOOL) ::SendMessage(m_hWnd, MCM_GETSELRANGE,
		0, (LPARAM) sysTimes);

	if (bReturn)
	{
		*pMinRange = sysTimes[0];
		*pMaxRange = sysTimes[1];
	}

	return bReturn;
}

BOOL CMonthCalCtrl::SetSelRange(_In_ const LPSYSTEMTIME pMinRange,
	_In_ const LPSYSTEMTIME pMaxRange)
{
	ASSERT(m_hWnd != NULL);
	ASSERT((GetStyle() & MCS_MULTISELECT));

	ASSERT_POINTER(pMinRange, SYSTEMTIME);
	ASSERT_POINTER(pMaxRange, SYSTEMTIME);

	SYSTEMTIME sysTimes[2];
	sysTimes[0] = *pMinRange;
	sysTimes[1] = *pMaxRange;

	return (BOOL) ::SendMessage(m_hWnd, MCM_SETSELRANGE,
		0, (LPARAM) sysTimes);
}

BOOL CMonthCalCtrl::SetSelRange(_In_ const COleDateTime& refMinRange,
	_In_ const COleDateTime& refMaxRange)
{
	// control must have multiple select
	ASSERT((GetStyle() & MCS_MULTISELECT));
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	BOOL bResult = FALSE;

	if (refMinRange.GetStatus() == COleDateTime::valid &&
		refMaxRange.GetStatus() == COleDateTime::valid)
	{
		if (refMinRange.GetAsSystemTime(sysTimes[0]) &&
			refMaxRange.GetAsSystemTime(sysTimes[1]))
		{
			bResult = (BOOL)
				::SendMessage(m_hWnd, MCM_SETSELRANGE, 0, (LPARAM)sysTimes);
		}
	}

	return bResult;
}

BOOL CMonthCalCtrl::GetSelRange(_Out_ COleDateTime& refMinRange,
	_Out_ COleDateTime& refMaxRange) const
{
	// control must have multiple select
	ASSERT((GetStyle() & MCS_MULTISELECT));
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));
	BOOL bResult = (BOOL)
		::SendMessage(m_hWnd, MCM_GETSELRANGE, 0, (LPARAM) sysTimes);

	if (bResult)
	{
		refMinRange = COleDateTime(sysTimes[0]);
		refMaxRange = COleDateTime(sysTimes[1]);
	}
	return bResult;
}

BOOL CMonthCalCtrl::SetSelRange(_In_ const CTime& refMinRange,
	_In_ const CTime& refMaxRange)
{
	// control must have multiple select
	ASSERT((GetStyle() & MCS_MULTISELECT));
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	BOOL bResult = FALSE;

	if (refMinRange.GetAsSystemTime(sysTimes[0]) &&
		refMaxRange.GetAsSystemTime(sysTimes[1]))
	{
		bResult = (BOOL)
			::SendMessage(m_hWnd, MCM_SETSELRANGE, 0, (LPARAM)sysTimes);
	}

	return bResult;
}

BOOL CMonthCalCtrl::GetSelRange(_Out_ CTime& refMinRange, _Out_ CTime& refMaxRange) const
{
	// control must have multiple select
	ASSERT((GetStyle() & MCS_MULTISELECT));
	ASSERT(::IsWindow(m_hWnd));

	SYSTEMTIME sysTimes[2];
	memset(sysTimes, 0, sizeof(sysTimes));
	BOOL bResult = (BOOL)
		::SendMessage(m_hWnd, MCM_GETSELRANGE, 0, (LPARAM) sysTimes);

	if (bResult)
	{
		refMinRange = CTime(sysTimes[0]);
		refMaxRange = CTime(sysTimes[1]);
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// DDX_ routines

void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, COleDateTime& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CDateTimeCtrl* pWnd = (CDateTimeCtrl*) CWnd::FromHandle(hWndCtrl);

	ENSURE(pWnd);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetTime(value);
	}
	else
	{
		pWnd->SetTime(value);
	}
}

void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, FILETIME& value)
{
	SYSTEMTIME st;

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CDateTimeCtrl* pWnd = (CDateTimeCtrl*) CWnd::FromHandle(hWndCtrl);

	ENSURE(pWnd);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetTime(&st);
		SystemTimeToFileTime(&st, &value);
	}
	else
	{
		FileTimeToSystemTime(&value, &st);
		pWnd->SetTime(&st);
	}
}

void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, CTime& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CDateTimeCtrl* pWnd = (CDateTimeCtrl*) CWnd::FromHandle(hWndCtrl);

	ENSURE(pWnd);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetTime(value);
	}
	else
	{
		pWnd->SetTime(&value);
	}
}

void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, CString& value)
{
	// if getting, just use regular DDX_Text(CString&) routine
	// as control supports WM_GETTEXT and WM_GETTEXTLENGTH
	if (pDX->m_bSaveAndValidate)
	{
		DDX_Text(pDX, nIDC, value);
	}
	else
	{
		// otherwise, formulate COleDateTime and
		// set time directly--control doesn't support WM_SETTEXT

		COleDateTime dt;
		dt.ParseDateTime(value);
		DDX_DateTimeCtrl(pDX, nIDC, dt);
	}
}

void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC,
	COleDateTime& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CMonthCalCtrl* pWnd = (CMonthCalCtrl*) CWnd::FromHandle(hWndCtrl);

	ENSURE(pWnd);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetCurSel(value);
	}
	else
	{
		pWnd->SetCurSel(value);
	}
}

void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC,
	FILETIME& value)
{
	SYSTEMTIME st;

	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CMonthCalCtrl* pWnd = (CMonthCalCtrl*) CWnd::FromHandle(hWndCtrl);

	ENSURE(pWnd);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetCurSel(&st);
		SystemTimeToFileTime(&st, &value);
	}
	else
	{
		FileTimeToSystemTime(&value, &st);
		pWnd->SetCurSel(&st);
	}
}

void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, CTime& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	CMonthCalCtrl* pWnd = (CMonthCalCtrl*) CWnd::FromHandle(hWndCtrl);

	ENSURE(pWnd);
	if (pDX->m_bSaveAndValidate)
	{
		pWnd->GetCurSel(value);
	}
	else
	{
		pWnd->SetCurSel(value);
	}
}

void AFXAPI DDV_MinMaxDateTime(CDataExchange* pDX, CTime& refValue,
	const CTime* pMinRange, const CTime* pMaxRange)
{
	ASSERT(pMinRange == NULL || pMaxRange == NULL || *pMinRange <= *pMaxRange);

	CDateTimeCtrl* pWnd = (CDateTimeCtrl*) pDX->m_pDlgWnd->GetDlgItem(pDX->m_idLastControl);

	if (!pDX->m_bSaveAndValidate)
	{
		if ( (pMinRange != NULL && *pMinRange > refValue) ||
			  (pMaxRange != NULL && *pMaxRange < refValue))
		{
			TRACE(traceAppMsg, 0, "Warning: initial dialog data is out of range in "
				"control ID %d.\n", pDX->m_idLastControl);

			return;     // don't stop now
		}
	}

	ENSURE(pWnd);
	pWnd->SetRange(pMinRange, pMaxRange);
}

void AFXAPI DDV_MinMaxDateTime(CDataExchange* pDX,	COleDateTime& refValue,
	const COleDateTime* pMinRange, const COleDateTime* pMaxRange)
{
	ASSERT(pMinRange == NULL || pMaxRange == NULL || *pMinRange <= *pMaxRange);
	CDateTimeCtrl* pWnd = (CDateTimeCtrl*) pDX->m_pDlgWnd->GetDlgItem(pDX->m_idLastControl);

	if (!pDX->m_bSaveAndValidate)
	{
		if ( (pMinRange != NULL && *pMinRange > refValue) ||
			  (pMaxRange != NULL && *pMaxRange < refValue))
		{
			TRACE(traceAppMsg, 0, "Warning: initial dialog data is out of range in "
				"control ID %d.\n", pDX->m_idLastControl);

			return;     // don't stop now
		}
	}

	ENSURE(pWnd);
	pWnd->SetRange(pMinRange, pMaxRange);
}

void AFXAPI DDV_MinMaxMonth(CDataExchange* pDX,	CTime& refValue,
	const CTime* pMinRange, const CTime* pMaxRange)
{
	ASSERT(pMinRange == NULL || pMaxRange == NULL || *pMinRange <= *pMaxRange);
	CMonthCalCtrl* pWnd = (CMonthCalCtrl*) pDX->m_pDlgWnd->GetDlgItem(pDX->m_idLastControl);

	if (!pDX->m_bSaveAndValidate)
	{
		if ( (pMinRange != NULL && *pMinRange > refValue) ||
			  (pMaxRange != NULL && *pMaxRange < refValue))
		{
			TRACE(traceAppMsg, 0, "Warning: initial dialog data is out of range in "
				"control ID %d.\n", pDX->m_idLastControl);

			return;     // don't stop now
		}
	}

	ENSURE(pWnd);
	pWnd->SetRange(pMinRange, pMaxRange);
}

void AFXAPI DDV_MinMaxMonth(CDataExchange* pDX,	COleDateTime& refValue,
	const COleDateTime* pMinRange, const COleDateTime* pMaxRange)
{
	ASSERT(pMinRange == NULL || pMaxRange == NULL || *pMinRange <= *pMaxRange);
	CMonthCalCtrl* pWnd = (CMonthCalCtrl*) pDX->m_pDlgWnd->GetDlgItem(pDX->m_idLastControl);

	if (!pDX->m_bSaveAndValidate)
	{
		if ( (pMinRange != NULL && *pMinRange > refValue) ||
			  (pMaxRange != NULL && *pMaxRange < refValue))
		{
			TRACE(traceAppMsg, 0, "Warning: initial dialog data is out of range in "
				"control ID %d.\n", pDX->m_idLastControl);

			return;     // don't stop now
		}
	}

	ENSURE(pWnd);
	pWnd->SetRange(pMinRange, pMaxRange);
}

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_ENABLE_INLINES

#define _AFXDTCTL_INLINE
#include "afxdtctl.inl"

#endif //_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(CDateTimeCtrl, CWnd)
IMPLEMENT_DYNAMIC(CMonthCalCtrl, CWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winbtn.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CBitmapButton

// LoadBitmaps will load in one, two, three or all four bitmaps
// returns TRUE if all specified images are loaded
BOOL CBitmapButton::LoadBitmaps(LPCTSTR lpszBitmapResource,
	LPCTSTR lpszBitmapResourceSel, LPCTSTR lpszBitmapResourceFocus,
	LPCTSTR lpszBitmapResourceDisabled)
{
	// delete old bitmaps (if present)
	m_bitmap.DeleteObject();
	m_bitmapSel.DeleteObject();
	m_bitmapFocus.DeleteObject();
	m_bitmapDisabled.DeleteObject();

	if (!m_bitmap.LoadBitmap(lpszBitmapResource))
	{
		TRACE(traceAppMsg, 0, "Failed to load bitmap for normal image.\n");
		return FALSE;   // need this one image
	}
	BOOL bAllLoaded = TRUE;
	if (lpszBitmapResourceSel != NULL)
	{
		if (!m_bitmapSel.LoadBitmap(lpszBitmapResourceSel))
		{
			TRACE(traceAppMsg, 0, "Failed to load bitmap for selected image.\n");
			bAllLoaded = FALSE;
		}
	}
	if (lpszBitmapResourceFocus != NULL)
	{
		if (!m_bitmapFocus.LoadBitmap(lpszBitmapResourceFocus))
			bAllLoaded = FALSE;
	}
	if (lpszBitmapResourceDisabled != NULL)
	{
		if (!m_bitmapDisabled.LoadBitmap(lpszBitmapResourceDisabled))
			bAllLoaded = FALSE;
	}
	return bAllLoaded;
}

// SizeToContent will resize the button to the size of the bitmap
void CBitmapButton::SizeToContent()
{
	ASSERT(m_bitmap.m_hObject != NULL);
	CSize bitmapSize;
	BITMAP bmInfo;
	VERIFY(m_bitmap.GetObject(sizeof(bmInfo), &bmInfo) == sizeof(bmInfo));
	VERIFY(SetWindowPos(NULL, -1, -1, bmInfo.bmWidth, bmInfo.bmHeight,
		SWP_NOMOVE|SWP_NOZORDER|SWP_NOREDRAW|SWP_NOACTIVATE));
}

// Autoload will load the bitmap resources based on the text of
//  the button
// Using suffices "U", "D", "F" and "X" for up/down/focus/disabled
BOOL CBitmapButton::AutoLoad(UINT nID, CWnd* pParent)
{
	// first attach the CBitmapButton to the dialog control
	if (!SubclassDlgItem(nID, pParent))
		return FALSE;

	CString buttonName;
	GetWindowText(buttonName);
	ASSERT(!buttonName.IsEmpty());      // must provide a title

	LoadBitmaps(buttonName + _T("U"), buttonName + _T("D"),
	  buttonName + _T("F"), buttonName + _T("X"));

	// we need at least the primary
	if (m_bitmap.m_hObject == NULL)
		return FALSE;

	// size to content
	SizeToContent();
	return TRUE;
}

// Draw the appropriate bitmap
void CBitmapButton::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS != NULL);
	// must have at least the first bitmap loaded before calling DrawItem
	ASSERT(m_bitmap.m_hObject != NULL);     // required

	// use the main bitmap for up, the selected bitmap for down
	CBitmap* pBitmap = &m_bitmap;
	UINT state = lpDIS->itemState;
	if ((state & ODS_SELECTED) && m_bitmapSel.m_hObject != NULL)
		pBitmap = &m_bitmapSel;
	else if ((state & ODS_FOCUS) && m_bitmapFocus.m_hObject != NULL)
		pBitmap = &m_bitmapFocus;   // third image for focused
	else if ((state & ODS_DISABLED) && m_bitmapDisabled.m_hObject != NULL)
		pBitmap = &m_bitmapDisabled;   // last image for disabled

	// draw the whole button
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	CDC memDC;
	memDC.CreateCompatibleDC(pDC);
	CBitmap* pOld = memDC.SelectObject(pBitmap);
	if (pOld == NULL)
		return;     // destructors will clean up

	CRect rect;
	rect.CopyRect(&lpDIS->rcItem);
	pDC->BitBlt(rect.left, rect.top, rect.Width(), rect.Height(),
		&memDC, 0, 0, SRCCOPY);
	memDC.SelectObject(pOld);
}

/////////////////////////////////////////////////////////////////////////////
// CBitmapButton diagnostics
#ifdef _DEBUG
void CBitmapButton::AssertValid() const
{
	CButton::AssertValid();

	m_bitmap.AssertValid();
	m_bitmapSel.AssertValid();
	m_bitmapFocus.AssertValid();
	m_bitmapDisabled.AssertValid();
}

void CBitmapButton::Dump(CDumpContext& dc) const
{
	CButton::Dump(dc);

	dc << "m_bitmap = " << (void*)m_bitmap.m_hObject;
	dc << "\nm_bitmapSel = " << (void*)m_bitmapSel.m_hObject;
	dc << "\nm_bitmapFocus = " << (void*)m_bitmapFocus.m_hObject;
	dc << "\nm_bitmapDisabled = " << (void*)m_bitmapDisabled.m_hObject;

	dc << "\n";
}
#endif


IMPLEMENT_DYNAMIC(CBitmapButton, CButton)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\wincore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#ifndef _AFX_NO_OCC_SUPPORT
#include "occimpl.h"
#endif

#include <atlacc.h>	// Accessible Proxy from ATL
#include "sal.h"

#include "afxctrlcontainer.h"

// for dll builds we just delay load it
#ifndef _AFXDLL
PROCESS_LOCAL(_AFX_HTMLHELP_STATE, _afxHtmlHelpState)
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Globals

const UINT CWnd::m_nMsgDragList = ::RegisterWindowMessage(DRAGLISTMSGSTRING);

// CWnds for setting z-order with SetWindowPos's pWndInsertAfter parameter
const AFX_DATADEF CWnd CWnd::wndTop(HWND_TOP);
const AFX_DATADEF CWnd CWnd::wndBottom(HWND_BOTTOM);
const AFX_DATADEF CWnd CWnd::wndTopMost(HWND_TOPMOST);
const AFX_DATADEF CWnd CWnd::wndNoTopMost(HWND_NOTOPMOST);

const TCHAR _afxWnd[] = AFX_WND;
const TCHAR _afxWndControlBar[] = AFX_WNDCONTROLBAR;
const TCHAR _afxWndMDIFrame[] = AFX_WNDMDIFRAME;
const TCHAR _afxWndFrameOrView[] = AFX_WNDFRAMEORVIEW;
const TCHAR _afxWndOleControl[] = AFX_WNDOLECONTROL;

/////////////////////////////////////////////////////////////////////////////
// CWnd construction

CWnd::CWnd()
{
	m_hWnd = NULL;
	m_bEnableActiveAccessibility = false;
	m_bIsTouchWindowRegistered = FALSE;
	m_pProxy = NULL;
	m_pStdObject = NULL;
	m_hWndOwner = NULL;
	m_nFlags = 0;
	m_pfnSuper = NULL;
	m_nModalResult = 0;
	m_pDropTarget = NULL;
#ifndef _AFX_NO_OCC_SUPPORT	
	m_pCtrlCont = NULL;
	m_pCtrlSite = NULL;
#endif
	m_pMFCCtrlContainer = NULL;

	m_ptGestureFrom = CPoint(-1, -1);
	m_ulGestureArg = 0;
	m_bGestureInited = FALSE;
	m_pCurrentGestureInfo = NULL;
}

CWnd::CWnd(HWND hWnd)
{
	m_hWnd = hWnd;
	m_bEnableActiveAccessibility = false;
	m_bIsTouchWindowRegistered = FALSE;
	m_pProxy = NULL;
	m_hWndOwner = NULL;
	m_nFlags = 0;
	m_pfnSuper = NULL;
	m_nModalResult = 0;
	m_pDropTarget = NULL;
#ifndef _AFX_NO_OCC_SUPPORT	
	m_pCtrlCont = NULL;
	m_pCtrlSite = NULL;
#endif
	m_pMFCCtrlContainer = NULL;

	m_ptGestureFrom = CPoint(-1, -1);
	m_ulGestureArg = 0;
	m_bGestureInited = FALSE;
	m_pCurrentGestureInfo = NULL;
}

// Change a window's style

AFX_STATIC BOOL AFXAPI _AfxModifyStyle(HWND hWnd, int nStyleOffset,
	DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	ASSERT(hWnd != NULL);
	DWORD dwStyle = ::GetWindowLong(hWnd, nStyleOffset);
	DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
	if (dwStyle == dwNewStyle)
		return FALSE;

	::SetWindowLong(hWnd, nStyleOffset, dwNewStyle);
	if (nFlags != 0)
	{
		::SetWindowPos(hWnd, NULL, 0, 0, 0, 0,
			SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
	}
	return TRUE;
}

BOOL PASCAL
CWnd::ModifyStyle(HWND hWnd, DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	return _AfxModifyStyle(hWnd, GWL_STYLE, dwRemove, dwAdd, nFlags);
}

BOOL PASCAL
CWnd::ModifyStyleEx(HWND hWnd, DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	return _AfxModifyStyle(hWnd, GWL_EXSTYLE, dwRemove, dwAdd, nFlags);
}

/////////////////////////////////////////////////////////////////////////////
// Special helpers for certain windows messages

AFX_STATIC void AFXAPI _AfxPreInitDialog(
	CWnd* pWnd, LPRECT lpRectOld, DWORD* pdwStyleOld)
{
	ASSERT(lpRectOld != NULL);
	ASSERT(pdwStyleOld != NULL);

	pWnd->GetWindowRect(lpRectOld);
	*pdwStyleOld = pWnd->GetStyle();
}

AFX_STATIC void AFXAPI _AfxPostInitDialog(
	CWnd* pWnd, const RECT& rectOld, DWORD dwStyleOld)
{
	// must be hidden to start with
	if (dwStyleOld & WS_VISIBLE)
		return;

	// must not be visible after WM_INITDIALOG
	if (pWnd->GetStyle() & (WS_VISIBLE|WS_CHILD))
		return;

	// must not move during WM_INITDIALOG
	CRect rect;
	pWnd->GetWindowRect(rect);
	if (rectOld.left != rect.left || rectOld.top != rect.top)
		return;

	// must be unowned or owner disabled
	CWnd* pParent = pWnd->GetWindow(GW_OWNER);
	if (pParent != NULL && pParent->IsWindowEnabled())
		return;

	if (!pWnd->CheckAutoCenter())
		return;

	// center modal dialog boxes/message boxes
	pWnd->CenterWindow();
}

AFX_STATIC void AFXAPI
_AfxHandleActivate(CWnd* pWnd, WPARAM nState, CWnd* pWndOther)
{
	ASSERT(pWnd != NULL);		

	// send WM_ACTIVATETOPLEVEL when top-level parents change
	if (!(pWnd->GetStyle() & WS_CHILD))
	{
		CWnd* pTopLevel= pWnd->GetTopLevelParent();
		if (pTopLevel && (pWndOther == NULL || !::IsWindow(pWndOther->m_hWnd) || pTopLevel != pWndOther->GetTopLevelParent()))
		{
			// lParam points to window getting the WM_ACTIVATE message and
			//  hWndOther from the WM_ACTIVATE.
			HWND hWnd2[2];
			hWnd2[0] = pWnd->m_hWnd;
			hWnd2[1] = pWndOther->GetSafeHwnd();
			// send it...
			pTopLevel->SendMessage(WM_ACTIVATETOPLEVEL, nState, (LPARAM)&hWnd2[0]);
		}
	}
}

AFX_STATIC BOOL AFXAPI
_AfxHandleSetCursor(CWnd* pWnd, UINT nHitTest, UINT nMsg)
{
	if (nHitTest == HTERROR &&
		(nMsg == WM_LBUTTONDOWN || nMsg == WM_MBUTTONDOWN ||
		 nMsg == WM_RBUTTONDOWN))
	{
		// activate the last active window if not active
		CWnd* pLastActive = pWnd->GetTopLevelParent();
		if (pLastActive != NULL)
			pLastActive = pLastActive->GetLastActivePopup();
		if (pLastActive != NULL &&
			pLastActive != CWnd::GetForegroundWindow() &&
			pLastActive->IsWindowEnabled())
		{
			pLastActive->SetForegroundWindow();
			return TRUE;
		}
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Official way to send message to a CWnd

LRESULT AFXAPI AfxCallWndProc(CWnd* pWnd, HWND hWnd, UINT nMsg,
	WPARAM wParam = 0, LPARAM lParam = 0)
{
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	MSG oldState = pThreadState->m_lastSentMsg;   // save for nesting
	pThreadState->m_lastSentMsg.hwnd = hWnd;
	pThreadState->m_lastSentMsg.message = nMsg;
	pThreadState->m_lastSentMsg.wParam = wParam;
	pThreadState->m_lastSentMsg.lParam = lParam;

#ifdef _DEBUG
	_AfxTraceMsg(_T("WndProc"), &pThreadState->m_lastSentMsg);
#endif

	// Catch exceptions thrown outside the scope of a callback
	// in debug builds and warn the user.
	LRESULT lResult;
	TRY
	{
#ifndef _AFX_NO_OCC_SUPPORT
		// special case for WM_DESTROY
		if ((nMsg == WM_DESTROY) && (pWnd->m_pCtrlCont != NULL))
			pWnd->m_pCtrlCont->OnUIActivate(NULL);
#endif

		// special case for WM_INITDIALOG
		CRect rectOld;
		DWORD dwStyle = 0;
		if (nMsg == WM_INITDIALOG)
			_AfxPreInitDialog(pWnd, &rectOld, &dwStyle);

		// delegate to object's WindowProc
		lResult = pWnd->WindowProc(nMsg, wParam, lParam);

		// more special case for WM_INITDIALOG
		if (nMsg == WM_INITDIALOG)
			_AfxPostInitDialog(pWnd, rectOld, dwStyle);
	}
	CATCH_ALL(e)
	{
		lResult = AfxProcessWndProcException(e, &pThreadState->m_lastSentMsg);
		TRACE(traceAppMsg, 0, "Warning: Uncaught exception in WindowProc (returning %ld).\n",
			lResult);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	pThreadState->m_lastSentMsg = oldState;
	return lResult;
}

const MSG* PASCAL CWnd::GetCurrentMessage()
{
	// fill in time and position when asked for
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	pThreadState->m_lastSentMsg.time = ::GetMessageTime();
	pThreadState->m_lastSentMsg.pt = CPoint(::GetMessagePos());
	return &pThreadState->m_lastSentMsg;
}

LRESULT CWnd::Default()
{
	// call DefWindowProc with the last message
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	return DefWindowProc(pThreadState->m_lastSentMsg.message,
		pThreadState->m_lastSentMsg.wParam, pThreadState->m_lastSentMsg.lParam);
}

/////////////////////////////////////////////////////////////////////////////
// Map from HWND to CWnd*

CHandleMap* PASCAL afxMapHWND(BOOL bCreate)
{
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	if (pState->m_pmapHWND == NULL && bCreate)
	{
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
#ifndef _AFX_PORTABLE
		_PNH pnhOldHandler = AfxSetNewHandler(&AfxCriticalNewHandler);
#endif
		pState->m_pmapHWND = new CHandleMap(RUNTIME_CLASS(CWnd),
			ConstructDestruct<CWnd>::Construct, ConstructDestruct<CWnd>::Destruct, 
			offsetof(CWnd, m_hWnd));

#ifndef _AFX_PORTABLE
		AfxSetNewHandler(pnhOldHandler);
#endif
		AfxEnableMemoryTracking(bEnable);
	}
	return pState->m_pmapHWND;
}

CWnd* PASCAL CWnd::FromHandle(HWND hWnd)
{
	CHandleMap* pMap = afxMapHWND(TRUE); //create map if not exist
	ASSERT(pMap != NULL);
	CWnd* pWnd = (CWnd*)pMap->FromHandle(hWnd);

#ifndef _AFX_NO_OCC_SUPPORT
	pWnd->AttachControlSite(pMap);
#endif

	ASSERT(pWnd == NULL || pWnd->m_hWnd == hWnd);
	return pWnd;
}

CWnd* PASCAL CWnd::FromHandlePermanent(HWND hWnd)
{
	CHandleMap* pMap = afxMapHWND();
	CWnd* pWnd = NULL;
	if (pMap != NULL)
	{
		// only look in the permanent map - does no allocations
		pWnd = (CWnd*)pMap->LookupPermanent(hWnd);
		ASSERT(pWnd == NULL || pWnd->m_hWnd == hWnd);
	}
	return pWnd;
}

BOOL CWnd::Attach(HWND hWndNew)
{
	ASSERT(m_hWnd == NULL);     // only attach once, detach on destroy
	ASSERT(FromHandlePermanent(hWndNew) == NULL);
		// must not already be in permanent map

	if (hWndNew == NULL)
		return FALSE;

	CHandleMap* pMap = afxMapHWND(TRUE); // create map if not exist
	ASSERT(pMap != NULL);

	pMap->SetPermanent(m_hWnd = hWndNew, this);


#ifndef _AFX_NO_OCC_SUPPORT
	AttachControlSite(pMap);
#endif

	return TRUE;
}

HWND CWnd::Detach()
{
	HWND hWnd = m_hWnd;
	if (hWnd != NULL)
	{
		CHandleMap* pMap = afxMapHWND(); // don't create if not exist
		if (pMap != NULL)
			pMap->RemoveHandle(m_hWnd);
	m_hWnd = NULL;
	}

#ifndef _AFX_NO_OCC_SUPPORT
	m_pCtrlSite = NULL;
#endif

	return hWnd;
}

void CWnd::PreSubclassWindow()
{
	// no default processing
}

/////////////////////////////////////////////////////////////////////////////
// CMenu functions
CMenu* CWnd::GetMenu() const
{
	ASSERT(::IsWindow(m_hWnd));
	return CMenu::FromHandle(::GetMenu(m_hWnd));
}

BOOL CWnd::SetMenu(CMenu* pMenu)
{
	ASSERT(::IsWindow(m_hWnd));
	return ::SetMenu(m_hWnd, pMenu->GetSafeHmenu());
}

////////////////////////////////////////////////////////////////////////////
// The WndProc for all CWnd's and derived classes

LRESULT CALLBACK
AfxWndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	// special message which identifies the window as using AfxWndProc
	if (nMsg == WM_QUERYAFXWNDPROC)
		return 1;

	// all other messages route through message map
	CWnd* pWnd = CWnd::FromHandlePermanent(hWnd);
	ASSERT(pWnd != NULL);					
	ASSERT(pWnd==NULL || pWnd->m_hWnd == hWnd);
	if (pWnd == NULL || pWnd->m_hWnd != hWnd)
		return ::DefWindowProc(hWnd, nMsg, wParam, lParam);
	return AfxCallWndProc(pWnd, hWnd, nMsg, wParam, lParam);
}

// always indirectly accessed via AfxGetAfxWndProc
WNDPROC AFXAPI AfxGetAfxWndProc()
{
#ifdef _AFXDLL
	return AfxGetModuleState()->m_pfnAfxWndProc;
#else
	return &AfxWndProc;
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Special WndProcs (activation handling & gray dialogs)

AFX_STATIC_DATA const TCHAR _afxOldWndProc[] = _T("AfxOldWndProc423");

LRESULT CALLBACK
_AfxActivationWndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	WNDPROC oldWndProc = (WNDPROC)::GetProp(hWnd, _afxOldWndProc);
	ASSERT(oldWndProc != NULL);	

	LRESULT lResult = 0;
	TRY
	{
		BOOL bCallDefault = TRUE;
		switch (nMsg)
		{
		case WM_INITDIALOG:
			{
				DWORD dwStyle;
				CRect rectOld;
				CWnd* pWnd = CWnd::FromHandle(hWnd);
				_AfxPreInitDialog(pWnd, &rectOld, &dwStyle);
				bCallDefault = FALSE;
				lResult = CallWindowProc(oldWndProc, hWnd, nMsg, wParam, lParam);
				_AfxPostInitDialog(pWnd, rectOld, dwStyle);
			}
			break;

		case WM_ACTIVATE:
			_AfxHandleActivate(CWnd::FromHandle(hWnd), wParam,
				CWnd::FromHandle((HWND)lParam));
			break;

		case WM_SETCURSOR:
			bCallDefault = !_AfxHandleSetCursor(CWnd::FromHandle(hWnd),
				(short)LOWORD(lParam), HIWORD(lParam));
			break;

		case WM_NCDESTROY:
			SetWindowLongPtr(hWnd, GWLP_WNDPROC, reinterpret_cast<INT_PTR>(oldWndProc));
			RemoveProp(hWnd, _afxOldWndProc);
			GlobalDeleteAtom(GlobalFindAtom(_afxOldWndProc));
			break;
		}

		// call original wndproc for default handling
		if (bCallDefault)
			lResult = CallWindowProc(oldWndProc, hWnd, nMsg, wParam, lParam);
	}
	CATCH_ALL(e)
	{
		// handle exception
		MSG msg;
		msg.hwnd = hWnd;
		msg.message = nMsg;
		msg.wParam = wParam;
		msg.lParam = lParam;
		lResult = AfxProcessWndProcException(e, &msg);
		TRACE(traceAppMsg, 0, "Warning: Uncaught exception in _AfxActivationWndProc (returning %ld).\n",
			lResult);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return lResult;
}

/////////////////////////////////////////////////////////////////////////////
// Window creation hooks

LRESULT CALLBACK
_AfxCbtFilterHook(int code, WPARAM wParam, LPARAM lParam)
{
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	if (code != HCBT_CREATEWND)
	{
		// wait for HCBT_CREATEWND just pass others on...
		return CallNextHookEx(pThreadState->m_hHookOldCbtFilter, code,
			wParam, lParam);
	}

	ASSERT(lParam != NULL);
	LPCREATESTRUCT lpcs = ((LPCBT_CREATEWND)lParam)->lpcs;
	ASSERT(lpcs != NULL);

	CWnd* pWndInit = pThreadState->m_pWndInit;
	BOOL bContextIsDLL = afxContextIsDLL;
	if (pWndInit != NULL || (!(lpcs->style & WS_CHILD) && !bContextIsDLL))
	{
		// Note: special check to avoid subclassing the IME window
		if (_afxDBCS)
		{
			// check for cheap CS_IME style first...
			if (GetClassLong((HWND)wParam, GCL_STYLE) & CS_IME)
				goto lCallNextHook;

			// get class name of the window that is being created
			LPCTSTR pszClassName;
			TCHAR szClassName[_countof("ime")+1];
			if (DWORD_PTR(lpcs->lpszClass) > 0xffff)
			{
				pszClassName = lpcs->lpszClass;
			}
			else
			{
				szClassName[0] = '\0';
				GlobalGetAtomName((ATOM)lpcs->lpszClass, szClassName, _countof(szClassName));
				pszClassName = szClassName;
			}

			// a little more expensive to test this way, but necessary...
			if (::AfxInvariantStrICmp(pszClassName, _T("ime")) == 0)
				goto lCallNextHook;
		}

		ASSERT(wParam != NULL); // should be non-NULL HWND
		HWND hWnd = (HWND)wParam;
		WNDPROC oldWndProc;
		if (pWndInit != NULL)
		{
			AFX_MANAGE_STATE(pWndInit->m_pModuleState);

			// the window should not be in the permanent map at this time
			ASSERT(CWnd::FromHandlePermanent(hWnd) == NULL);

			// connect the HWND to pWndInit...
			pWndInit->Attach(hWnd);
			// allow other subclassing to occur first
			pWndInit->PreSubclassWindow();

			WNDPROC *pOldWndProc = pWndInit->GetSuperWndProcAddr();
			ASSERT(pOldWndProc != NULL);

			// subclass the window with standard AfxWndProc
			WNDPROC afxWndProc = AfxGetAfxWndProc();
			oldWndProc = (WNDPROC)SetWindowLongPtr(hWnd, GWLP_WNDPROC,
				(DWORD_PTR)afxWndProc);
			ASSERT(oldWndProc != NULL);
			if (oldWndProc != afxWndProc)
				*pOldWndProc = oldWndProc;

			pThreadState->m_pWndInit = NULL;
		}
		else
		{
			ASSERT(!bContextIsDLL);   // should never get here

			static ATOM s_atomMenu = 0;
			bool bSubclass = true;			

			if (s_atomMenu == 0)
			{
				WNDCLASSEX wc;
				memset(&wc, 0, sizeof(WNDCLASSEX));
				wc.cbSize = sizeof(WNDCLASSEX);
				s_atomMenu = (ATOM)::AfxCtxGetClassInfoEx(NULL, _T("#32768"), &wc);
			}

			// Do not subclass menus.
			if (s_atomMenu != 0)
			{
				ATOM atomWnd = (ATOM)::GetClassLongPtr(hWnd, GCW_ATOM);
				if (atomWnd == s_atomMenu)
						bSubclass = false;
			}
			else
			{			
				TCHAR szClassName[256];
				if (::GetClassName(hWnd, szClassName, 256))
				{
					szClassName[255] = NULL;
					if (_tcscmp(szClassName, _T("#32768")) == 0)
						bSubclass = false;
				}
			}			
			if (bSubclass)
			{
				// subclass the window with the proc which does gray backgrounds
				oldWndProc = (WNDPROC)GetWindowLongPtr(hWnd, GWLP_WNDPROC);
				if (oldWndProc != NULL && GetProp(hWnd, _afxOldWndProc) == NULL)
				{
					SetProp(hWnd, _afxOldWndProc, oldWndProc);
					if ((WNDPROC)GetProp(hWnd, _afxOldWndProc) == oldWndProc)
					{
						GlobalAddAtom(_afxOldWndProc);
						SetWindowLongPtr(hWnd, GWLP_WNDPROC, (DWORD_PTR)_AfxActivationWndProc);
						ASSERT(oldWndProc != NULL);
					}
				}
			}
		}
	}

lCallNextHook:
	LRESULT lResult = CallNextHookEx(pThreadState->m_hHookOldCbtFilter, code,
		wParam, lParam);

#ifndef _AFXDLL
	if (bContextIsDLL)
	{
		::UnhookWindowsHookEx(pThreadState->m_hHookOldCbtFilter);
		pThreadState->m_hHookOldCbtFilter = NULL;
	}
#endif
	return lResult;
}

void AFXAPI AfxHookWindowCreate(CWnd* pWnd)
{
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	if (pThreadState->m_pWndInit == pWnd)
		return;

	if (pThreadState->m_hHookOldCbtFilter == NULL)
	{
		pThreadState->m_hHookOldCbtFilter = ::SetWindowsHookEx(WH_CBT,
			_AfxCbtFilterHook, NULL, ::GetCurrentThreadId());
		if (pThreadState->m_hHookOldCbtFilter == NULL)
			AfxThrowMemoryException();
	}
	ASSERT(pThreadState->m_hHookOldCbtFilter != NULL);
	ASSERT(pWnd != NULL);
	ASSERT(pWnd->m_hWnd == NULL);   // only do once

	ASSERT(pThreadState->m_pWndInit == NULL);   // hook not already in progress
	pThreadState->m_pWndInit = pWnd;
}

BOOL AFXAPI AfxUnhookWindowCreate()
{
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
#ifndef _AFXDLL
	if (afxContextIsDLL && pThreadState->m_hHookOldCbtFilter != NULL)
	{
		::UnhookWindowsHookEx(pThreadState->m_hHookOldCbtFilter);
		pThreadState->m_hHookOldCbtFilter = NULL;
	}
#endif
	if (pThreadState->m_pWndInit != NULL)
	{
		pThreadState->m_pWndInit = NULL;
		return FALSE;   // was not successfully hooked
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CWnd creation

BOOL CWnd::CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		LPVOID lpParam /* = NULL */)
{
	return CreateEx(dwExStyle, lpszClassName, lpszWindowName, dwStyle,
		rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
		pParentWnd->GetSafeHwnd(), (HMENU)(UINT_PTR)nID, lpParam);
}

BOOL CWnd::CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,
	LPCTSTR lpszWindowName, DWORD dwStyle,
	int x, int y, int nWidth, int nHeight,
	HWND hWndParent, HMENU nIDorHMenu, LPVOID lpParam)
{
	ASSERT(lpszClassName == NULL || AfxIsValidString(lpszClassName) || 
		AfxIsValidAtom(lpszClassName));
	ENSURE_ARG(lpszWindowName == NULL || AfxIsValidString(lpszWindowName));
	
	// allow modification of several common create parameters
	CREATESTRUCT cs;
	cs.dwExStyle = dwExStyle;
	cs.lpszClass = lpszClassName;
	cs.lpszName = lpszWindowName;
	cs.style = dwStyle;
	cs.x = x;
	cs.y = y;
	cs.cx = nWidth;
	cs.cy = nHeight;
	cs.hwndParent = hWndParent;
	cs.hMenu = nIDorHMenu;
	cs.hInstance = AfxGetInstanceHandle();
	cs.lpCreateParams = lpParam;

	if (!PreCreateWindow(cs))
	{
		PostNcDestroy();
		return FALSE;
	}

	AfxHookWindowCreate(this);
	HWND hWnd = ::AfxCtxCreateWindowEx(cs.dwExStyle, cs.lpszClass,
			cs.lpszName, cs.style, cs.x, cs.y, cs.cx, cs.cy,
			cs.hwndParent, cs.hMenu, cs.hInstance, cs.lpCreateParams);

#ifdef _DEBUG
	if (hWnd == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: Window creation failed: GetLastError returns 0x%8.8X\n",
			GetLastError());
	}
#endif

	if (!AfxUnhookWindowCreate())
		PostNcDestroy();        // cleanup if CreateWindowEx fails too soon

	if (hWnd == NULL)
		return FALSE;
	ASSERT(hWnd == m_hWnd); // should have been set in send msg hook
	return TRUE;
}

// for child windows
BOOL CWnd::PreCreateWindow(CREATESTRUCT& cs)
{
	if (cs.lpszClass == NULL)
	{
		// make sure the default window class is registered
		VERIFY(AfxDeferRegisterClass(AFX_WND_REG));

		// no WNDCLASS provided - use child window default
		ASSERT(cs.style & WS_CHILD);
		cs.lpszClass = _afxWnd;
	}

	if ((cs.hMenu == NULL) && (cs.style & WS_CHILD))
	{
		cs.hMenu = (HMENU)(UINT_PTR)this;
	}

	return TRUE;
}

BOOL CWnd::Create(LPCTSTR lpszClassName,
	LPCTSTR lpszWindowName, DWORD dwStyle,
	const RECT& rect,
	CWnd* pParentWnd, UINT nID,
	CCreateContext* pContext)
{
	// can't use for desktop or pop-up windows (use CreateEx instead)
	ASSERT(pParentWnd != NULL);
	ASSERT((dwStyle & WS_POPUP) == 0);

	return CreateEx(0, lpszClassName, lpszWindowName,
		dwStyle | WS_CHILD,
		rect.left, rect.top,
		rect.right - rect.left, rect.bottom - rect.top,
		pParentWnd->GetSafeHwnd(), (HMENU)(UINT_PTR)nID, (LPVOID)pContext);
}

CWnd::~CWnd()
{
	if (m_hWnd != NULL &&
		this != (CWnd*)&wndTop && this != (CWnd*)&wndBottom &&
		this != (CWnd*)&wndTopMost && this != (CWnd*)&wndNoTopMost)
	{
		TRACE(traceAppMsg, 0, _T("Warning: calling DestroyWindow in CWnd::~CWnd; ")
		   _T("OnDestroy or PostNcDestroy in derived class will not be called.\n"));
		DestroyWindow();
	}

#ifndef _AFX_NO_OCC_SUPPORT
	// cleanup control container,
	// including destroying controls

	delete m_pCtrlCont;

	// cleanup control site
	if (m_pCtrlSite != NULL && m_pCtrlSite->m_pWndCtrl == this)
		m_pCtrlSite->m_pWndCtrl = NULL;
#endif

	delete m_pMFCCtrlContainer;

	if (m_pCurrentGestureInfo != NULL)
	{
		delete m_pCurrentGestureInfo;
	}
}

void CWnd::OnDestroy()
{
#ifndef _AFX_NO_OCC_SUPPORT
	// cleanup control container
	delete m_pCtrlCont;
	m_pCtrlCont = NULL;
#endif

	// Active Accessibility
	if (m_pProxy != NULL)
		m_pProxy->SetServer(NULL, NULL);
	if (m_pStdObject != NULL)
		m_pStdObject->Release();

	if (m_bIsTouchWindowRegistered)
	{
		RegisterTouchWindow(FALSE);
	}

	Default();
}

// WM_NCDESTROY is the absolute LAST message sent.
void CWnd::OnNcDestroy()
{
	// cleanup main and active windows
	CWinThread* pThread = AfxGetThread();
	if (pThread != NULL)
	{
		if (pThread->m_pMainWnd == this)
		{
			if (!afxContextIsDLL)
			{
				// shut down current thread if possible
				if (pThread != AfxGetApp() || AfxOleCanExitApp())
					AfxPostQuitMessage(0);
			}
			pThread->m_pMainWnd = NULL;
		}
		if (pThread->m_pActiveWnd == this)
			pThread->m_pActiveWnd = NULL;
	}

#ifndef _AFX_NO_OLE_SUPPORT
	// cleanup OLE drop target interface
	if (m_pDropTarget != NULL)
	{
		m_pDropTarget->Revoke();
		m_pDropTarget = NULL;
	}
#endif

#ifndef _AFX_NO_OCC_SUPPORT
	// cleanup control container
	delete m_pCtrlCont;
	m_pCtrlCont = NULL;
#endif

	// cleanup tooltip support
	if (m_nFlags & WF_TOOLTIPS)
	{
		CToolTipCtrl* pToolTip = AfxGetModuleThreadState()->m_pToolTip;
		if (pToolTip->GetSafeHwnd() != NULL)
		{
			TOOLINFO ti; memset(&ti, 0, sizeof(TOOLINFO));
			ti.cbSize = sizeof(AFX_OLDTOOLINFO);
			ti.uFlags = TTF_IDISHWND;
			ti.hwnd = m_hWnd;
			ti.uId = (UINT_PTR)m_hWnd;
			pToolTip->SendMessage(TTM_DELTOOL, 0, (LPARAM)&ti);
		}
	}

	// call default, unsubclass, and detach from the map
	WNDPROC pfnWndProc = WNDPROC(GetWindowLongPtr(m_hWnd, GWLP_WNDPROC));
	Default();
	if (WNDPROC(GetWindowLongPtr(m_hWnd, GWLP_WNDPROC)) == pfnWndProc)
	{
		WNDPROC pfnSuper = *GetSuperWndProcAddr();
		if (pfnSuper != NULL)
			SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, reinterpret_cast<INT_PTR>(pfnSuper));
	}
	Detach();
	ASSERT(m_hWnd == NULL);

	// call special post-cleanup routine
	PostNcDestroy();
}

void CWnd::PostNcDestroy()
{
	// default to nothing
}

void CWnd::OnFinalRelease()
{
	if (m_hWnd != NULL)
		DestroyWindow();    // will call PostNcDestroy
	else
		PostNcDestroy();
}

#ifdef _DEBUG
void CWnd::AssertValid() const
{
	if (m_hWnd == NULL)
		return;     // null (unattached) windows are valid

	// check for special wnd??? values
	ASSERT(HWND_TOP == NULL);       // same as desktop
	if (m_hWnd == HWND_BOTTOM)
		ASSERT(this == &CWnd::wndBottom);
	else if (m_hWnd == HWND_TOPMOST)
		ASSERT(this == &CWnd::wndTopMost);
	else if (m_hWnd == HWND_NOTOPMOST)
		ASSERT(this == &CWnd::wndNoTopMost);
	else
	{
		// should be a normal window
		ASSERT(::IsWindow(m_hWnd));

		// should also be in the permanent or temporary handle map
		CHandleMap* pMap = afxMapHWND();
		ASSERT(pMap != NULL);

		CObject* p=NULL;
		if(pMap)
		{
			ASSERT( (p = pMap->LookupPermanent(m_hWnd)) != NULL ||
					(p = pMap->LookupTemporary(m_hWnd)) != NULL);
		}
		ASSERT((CWnd*)p == this);   // must be us

		// Note: if either of the above asserts fire and you are
		// writing a multithreaded application, it is likely that
		// you have passed a C++ object from one thread to another
		// and have used that object in a way that was not intended.
		// (only simple inline wrapper functions should be used)
		//
		// In general, CWnd objects should be passed by HWND from
		// one thread to another.  The receiving thread can wrap
		// the HWND with a CWnd object by using CWnd::FromHandle.
		//
		// It is dangerous to pass C++ objects from one thread to
		// another, unless the objects are designed to be used in
		// such a manner.
	}
}

void CWnd::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "\nm_hWnd = " << (void*)m_hWnd;

	if (m_hWnd == NULL || m_hWnd == HWND_BOTTOM ||
		m_hWnd == HWND_TOPMOST || m_hWnd == HWND_NOTOPMOST)
	{
		// not a normal window - nothing more to dump
		return;
	}

	if (!::IsWindow(m_hWnd))
	{
		// not a valid window
		dc << " (illegal HWND)";
		return; // don't do anything more
	}

	CWnd* pWnd = CWnd::FromHandlePermanent(m_hWnd);
	if (pWnd != this)
		dc << " (Detached or temporary window)";
	else
		dc << " (permanent window)";

	// dump out window specific statistics
	TCHAR szBuf [64];
	if (!::SendMessage(m_hWnd, WM_QUERYAFXWNDPROC, 0, 0) && pWnd == this)
		GetWindowText(szBuf, _countof(szBuf));
	else
		::DefWindowProc(m_hWnd, WM_GETTEXT, _countof(szBuf), (LPARAM)&szBuf[0]);
	dc << "\ncaption = \"" << szBuf << "\"";

	::GetClassName(m_hWnd, szBuf, _countof(szBuf));
	dc << "\nclass name = \"" << szBuf << "\"";

	CRect rect;
	GetWindowRect(&rect);
	dc << "\nrect = " << rect;
	dc << "\nparent CWnd* = " << (void*)GetParent();

	dc << "\nstyle = " << (void*)(DWORD_PTR)::GetWindowLong(m_hWnd, GWL_STYLE);
	if (::GetWindowLong(m_hWnd, GWL_STYLE) & WS_CHILD)
		dc << "\nid = " << _AfxGetDlgCtrlID(m_hWnd);

	dc << "\n";
}
#endif

BOOL CWnd::DestroyWindow()
{
	CWnd* pWnd;
	CHandleMap* pMap;
	HWND hWndOrig;
	BOOL bResult;

	if ((m_hWnd == NULL) && (m_pCtrlSite == NULL))
		return FALSE;

	bResult = FALSE;
	pMap = NULL;
	pWnd = NULL;
	hWndOrig = NULL;
	if (m_hWnd != NULL)
	{
		pMap = afxMapHWND();
		ENSURE(pMap != NULL);
		pWnd = (CWnd*)pMap->LookupPermanent(m_hWnd);
#ifdef _DEBUG
		hWndOrig = m_hWnd;
#endif
	}

#ifdef _AFX_NO_OCC_SUPPORT
	if (m_hWnd != NULL)
		bResult = ::DestroyWindow(m_hWnd);
#else //_AFX_NO_OCC_SUPPORT
	if ((m_hWnd != NULL) || (m_pCtrlSite != NULL))
	{
		if (m_pCtrlSite == NULL)
			bResult = ::DestroyWindow(m_hWnd);
		else
			bResult = m_pCtrlSite->DestroyControl();
	}
#endif //_AFX_NO_OCC_SUPPORT

	if (hWndOrig != NULL)
	{
		// Note that 'this' may have been deleted at this point,
		//  (but only if pWnd != NULL)
		if (pWnd != NULL)
		{
			// Should have been detached by OnNcDestroy
#ifdef _DEBUG
			ASSERT(pMap->LookupPermanent(hWndOrig) == NULL);
#endif
		}
		else
		{
#ifdef _DEBUG
			ASSERT(m_hWnd == hWndOrig);
#endif
		// Detach after DestroyWindow called just in case
			Detach();
		}
	}

	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// Default CWnd implementation

LRESULT CWnd::DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	if (m_pfnSuper != NULL)
		return ::CallWindowProc(m_pfnSuper, m_hWnd, nMsg, wParam, lParam);

	WNDPROC pfnWndProc;
	if ((pfnWndProc = *GetSuperWndProcAddr()) == NULL)
		return ::DefWindowProc(m_hWnd, nMsg, wParam, lParam);
	else
		return ::CallWindowProc(pfnWndProc, m_hWnd, nMsg, wParam, lParam);
}

WNDPROC* CWnd::GetSuperWndProcAddr()
{
	// Note: it is no longer necessary to override GetSuperWndProcAddr
	//  for each control class with a different WNDCLASS.
	//  This implementation now uses instance data, such that the previous
	//  WNDPROC can be anything.

	return &m_pfnSuper;
}

BOOL CWnd::PreTranslateMessage(MSG* pMsg)
{
	// handle tooltip messages (some messages cancel, some may cause it to popup)
	AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();
	if (pModuleState->m_pfnFilterToolTipMessage != NULL)
		(*pModuleState->m_pfnFilterToolTipMessage)(pMsg, this);

	// no default processing
	return FALSE;
}

void PASCAL CWnd::CancelToolTips(BOOL bKeys)
{
	// check for active tooltip
	AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();
	CToolTipCtrl* pToolTip = pModuleThreadState->m_pToolTip;
	if (pToolTip->GetSafeHwnd() != NULL)
		pToolTip->SendMessage(TTM_ACTIVATE, FALSE);

	// check for active control bar fly-by status
	CControlBar* pLastStatus = pModuleThreadState->m_pLastStatus;
	if (bKeys && pLastStatus != NULL && GetKeyState(VK_LBUTTON) >= 0)
		pLastStatus->SetStatusText(static_cast<INT_PTR>(-1));
}

INT_PTR CWnd::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	// find child window which hits the point
	// (don't use WindowFromPoint, because it ignores disabled windows)
	HWND hWndChild = _AfxTopChildWindowFromPoint(m_hWnd, point);
	if (hWndChild != NULL)
	{
		// return positive hit if control ID isn't -1
		INT_PTR nHit = _AfxGetDlgCtrlID(hWndChild);

		// hits against child windows always center the tip
		if (pTI != NULL && pTI->cbSize >= sizeof(AFX_OLDTOOLINFO))
		{
			// setup the TOOLINFO structure
			pTI->hwnd = m_hWnd;
			pTI->uId = (UINT_PTR)hWndChild;
			pTI->uFlags |= TTF_IDISHWND;
			pTI->lpszText = LPSTR_TEXTCALLBACK;

			// set TTF_NOTBUTTON and TTF_CENTERTIP if it isn't a button
			if (!(::SendMessage(hWndChild, WM_GETDLGCODE, 0, 0) & DLGC_BUTTON))
				pTI->uFlags |= TTF_NOTBUTTON|TTF_CENTERTIP;
		}
		return nHit;
	}
	return -1;  // not found
}

void CWnd::GetWindowText(CString& rString) const
{
	ASSERT(::IsWindow(m_hWnd));

#ifndef _AFX_NO_OCC_SUPPORT
	if (m_pCtrlSite == NULL)
	{
#endif
		int nLen = ::GetWindowTextLength(m_hWnd);
		::GetWindowText(m_hWnd, rString.GetBufferSetLength(nLen), nLen+1);
		rString.ReleaseBuffer();

#ifndef _AFX_NO_OCC_SUPPORT
	}
	else
	{
		m_pCtrlSite->GetWindowText(rString);
	}
#endif
}

int CWnd::GetDlgItemText(int nID, CString& rString) const
{
	ASSERT(::IsWindow(m_hWnd));
	rString = _T("");    // empty without deallocating

#ifndef _AFX_NO_OCC_SUPPORT
	if (m_pCtrlCont == NULL)
	{
#endif
		HWND hWnd = ::GetDlgItem(m_hWnd, nID);
		if (hWnd != NULL)
		{
			int nLen = ::GetWindowTextLength(hWnd);
			::GetWindowText(hWnd, rString.GetBufferSetLength(nLen), nLen+1);
			rString.ReleaseBuffer();
		}

#ifndef _AFX_NO_OCC_SUPPORT
	}
	else
	{
		CWnd* pWnd = GetDlgItem(nID);
		if (pWnd != NULL)
			pWnd->GetWindowText(rString);
	}
#endif

	return (int)rString.GetLength();
}

BOOL CWnd::GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const
{
	ASSERT(::IsWindow(m_hWnd));
	lpwndpl->length = sizeof(WINDOWPLACEMENT);
	return ::GetWindowPlacement(m_hWnd, lpwndpl);
}

BOOL CWnd::SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl)
{
	ASSERT(::IsWindow(m_hWnd));
	((WINDOWPLACEMENT*)lpwndpl)->length = sizeof(WINDOWPLACEMENT);
	return ::SetWindowPlacement(m_hWnd, lpwndpl);
}

/////////////////////////////////////////////////////////////////////////////
// CWnd will delegate owner draw messages to self drawing controls

// Drawing: for all 4 control types
void CWnd::OnDrawItem(int /*nIDCtl*/, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if (lpDrawItemStruct->CtlType == ODT_MENU)
	{
		CMenu* pMenu = CMenu::FromHandlePermanent(
			(HMENU)lpDrawItemStruct->hwndItem);
		if (pMenu != NULL)
		{
			pMenu->DrawItem(lpDrawItemStruct);
			return; // eat it
		}
	}

	// reflect notification to child window control
	if (ReflectLastMsg(lpDrawItemStruct->hwndItem))
		return;     // eat it

	// not handled - do default
	Default();
}

// Drawing: for all 4 control types
int CWnd::OnCompareItem(int /*nIDCtl*/, LPCOMPAREITEMSTRUCT lpCompareItemStruct)
{
	// reflect notification to child window control
	LRESULT lResult;
	if (ReflectLastMsg(lpCompareItemStruct->hwndItem, &lResult))
		return (int)lResult;        // eat it

	// not handled - do default
	return (int)Default();
}

void CWnd::OnDeleteItem(int /*nIDCtl*/, LPDELETEITEMSTRUCT lpDeleteItemStruct)
{
	// reflect notification to child window control
	if (ReflectLastMsg(lpDeleteItemStruct->hwndItem))
		return;     // eat it
	// not handled - do default
	Default();
}

int CWnd::OnCharToItem(UINT, CListBox* pWnd, UINT)
{
	if (pWnd != NULL)
	{
		LRESULT lResult;
		if (pWnd->SendChildNotifyLastMsg(&lResult))
			return (int)lResult;     // eat it
	}
	// not handled - do default
	return (int)Default();
}

int CWnd::OnVKeyToItem(UINT, CListBox* pWnd, UINT)
{
	if (pWnd != NULL)
	{
		LRESULT lResult;
		if (pWnd->SendChildNotifyLastMsg(&lResult))
			return (int)lResult;     // eat it
	}
	// not handled - do default
	return (int)Default();
}

/////////////////////////////////////////////////////////////////////////////
// Self drawing menus are a little trickier

BOOL CMenu::TrackPopupMenu(UINT nFlags, int x, int y,
		CWnd* pWnd, LPCRECT lpRect)
{
	ASSERT(m_hMenu != NULL);

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOld = pThreadState->m_hTrackingWindow;
	HMENU hMenuOld = pThreadState->m_hTrackingMenu;
	pThreadState->m_hTrackingWindow = pWnd->GetSafeHwnd();
	pThreadState->m_hTrackingMenu = m_hMenu;
	BOOL bOK = ::TrackPopupMenu(m_hMenu, nFlags, x, y, 0,
			pThreadState->m_hTrackingWindow, lpRect);
	pThreadState->m_hTrackingWindow = hWndOld;
	pThreadState->m_hTrackingMenu = hMenuOld;

	return bOK;
}

BOOL CMenu::TrackPopupMenuEx(UINT fuFlags, int x, int y, CWnd* pWnd, LPTPMPARAMS lptpm)
{
	ASSERT(m_hMenu != NULL);

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOld = pThreadState->m_hTrackingWindow;
	HMENU hMenuOld = pThreadState->m_hTrackingMenu;
	pThreadState->m_hTrackingWindow = pWnd->GetSafeHwnd();
	pThreadState->m_hTrackingMenu = m_hMenu;
	BOOL bOK = ::TrackPopupMenuEx(m_hMenu, fuFlags, x, y,
			pThreadState->m_hTrackingWindow, lptpm);
	pThreadState->m_hTrackingWindow = hWndOld;
	pThreadState->m_hTrackingMenu = hMenuOld;

	return bOK;
}	

AFX_STATIC CMenu* AFXAPI _AfxFindPopupMenuFromID(CMenu* pMenu, UINT nID)
{
	ENSURE_VALID(pMenu);
	// walk through all items, looking for ID match
	int nItems = pMenu->GetMenuItemCount();
	for (int iItem = 0; iItem < nItems; iItem++)
	{
		CMenu* pPopup = pMenu->GetSubMenu(iItem);
		if (pPopup != NULL)
		{
			if(pPopup->m_hMenu == (HMENU)(UINT_PTR)nID) {
				pMenu = CMenu::FromHandlePermanent(pMenu->m_hMenu);
				return pMenu;
			}
			// recurse to child popup
			pPopup = _AfxFindPopupMenuFromID(pPopup, nID);
			// check popups on this popup
			if (pPopup != NULL)
				return pPopup;
		}
		else if (pMenu->GetMenuItemID(iItem) == nID)
		{
			// it is a normal item inside our popup
			pMenu = CMenu::FromHandlePermanent(pMenu->m_hMenu);
			return pMenu;
		}
	}
	// not found
	return NULL;
}

// Measure item implementation relies on unique control/menu IDs
void CWnd::OnMeasureItem(int /*nIDCtl*/, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	if (lpMeasureItemStruct->CtlType == ODT_MENU)
	{
		ASSERT(lpMeasureItemStruct->CtlID == 0);
		CMenu* pMenu=NULL;

		_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
		if (pThreadState->m_hTrackingWindow == m_hWnd)
		{
			// start from popup
			pMenu = CMenu::FromHandle(pThreadState->m_hTrackingMenu);
		}
		else
		{
			// start from menubar
			pMenu = GetMenu();
		}

		ENSURE(pMenu);

		pMenu = _AfxFindPopupMenuFromID(pMenu, lpMeasureItemStruct->itemID);
		if (pMenu != NULL)
		{
			pMenu->MeasureItem(lpMeasureItemStruct);
		}
		else
		{
			TRACE(traceAppMsg, 0, "Warning: unknown WM_MEASUREITEM for menu item 0x%04X.\n",
				lpMeasureItemStruct->itemID);
		}
	}
	else
	{
		CWnd* pChild = GetDescendantWindow(lpMeasureItemStruct->CtlID, TRUE);
		if (pChild != NULL && pChild->SendChildNotifyLastMsg())
			return;     // eaten by child
	}
	// not handled - do default
	Default();
}

/////////////////////////////////////////////////////////////////////////////
// Additional helpers for WNDCLASS init

// like RegisterClass, except will automatically call UnregisterClass
BOOL AFXAPI AfxRegisterClass(WNDCLASS* lpWndClass)
{
	WNDCLASS wndcls;		
	if (AfxCtxGetClassInfo(lpWndClass->hInstance, lpWndClass->lpszClassName,
		&wndcls))
	{
		// class already registered
		return TRUE;
	}

	if (!::AfxCtxRegisterClass(lpWndClass))
	{
		TRACE(traceAppMsg, 0, _T("Can't register window class named %s\n"),
			lpWndClass->lpszClassName);
		return FALSE;
	}

	BOOL bRet = TRUE;

	if (afxContextIsDLL)
	{
		AfxLockGlobals(CRIT_REGCLASSLIST);
		TRY
		{
			// class registered successfully, add to registered list
			AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
			pModuleState->m_strUnregisterList+=lpWndClass->lpszClassName;
			pModuleState->m_strUnregisterList+='\n';
		}
		CATCH_ALL(e)
		{
			AfxUnlockGlobals(CRIT_REGCLASSLIST);
			THROW_LAST();
			// Note: DELETE_EXCEPTION not required.
		}
		END_CATCH_ALL
		AfxUnlockGlobals(CRIT_REGCLASSLIST);
	}

	return bRet;
}

LPCTSTR AFXAPI AfxRegisterWndClass(UINT nClassStyle,
	HCURSOR hCursor, HBRUSH hbrBackground, HICON hIcon)
{
	// Returns a temporary string name for the class
	//  Save in a CString if you want to use it for a long time
	LPTSTR lpszName = AfxGetThreadState()->m_szTempClassName;

	// generate a synthetic name for this class
	HINSTANCE hInst = AfxGetInstanceHandle();

	if (hCursor == NULL && hbrBackground == NULL && hIcon == NULL)
	{
		ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(lpszName, _AFX_TEMP_CLASS_NAME_SIZE, _AFX_TEMP_CLASS_NAME_SIZE - 1, _T("Afx:%p:%x"), hInst, nClassStyle));
	}
	else
	{
		ATL_CRT_ERRORCHECK_SPRINTF(_sntprintf_s(lpszName, _AFX_TEMP_CLASS_NAME_SIZE, _AFX_TEMP_CLASS_NAME_SIZE - 1, _T("Afx:%p:%x:%p:%p:%p"), hInst, nClassStyle,
			hCursor, hbrBackground, hIcon));
	}
	
	// see if the class already exists
	WNDCLASS wndcls;
	if (::AfxCtxGetClassInfo(hInst, lpszName, &wndcls))
	{
		// already registered, assert everything is good
		ASSERT(wndcls.style == nClassStyle);

		// NOTE: We have to trust that the hIcon, hbrBackground, and the
		//  hCursor are semantically the same, because sometimes Windows does
		//  some internal translation or copying of those handles before
		//  storing them in the internal WNDCLASS retrieved by GetClassInfo.
		return lpszName;
	}

	// otherwise we need to register a new class
	wndcls.style = nClassStyle;
	wndcls.lpfnWndProc = DefWindowProc;
	wndcls.cbClsExtra = wndcls.cbWndExtra = 0;
	wndcls.hInstance = hInst;
	wndcls.hIcon = hIcon;
	wndcls.hCursor = hCursor;
	wndcls.hbrBackground = hbrBackground;
	wndcls.lpszMenuName = NULL;
	wndcls.lpszClassName = lpszName;
	if (!AfxRegisterClass(&wndcls))
		AfxThrowResourceException();

	// return thread-local pointer
	return lpszName;
}

struct AFX_CTLCOLOR
{
	HWND hWnd;
	HDC hDC;
	UINT nCtlType;
};

LRESULT CWnd::OnNTCtlColor(WPARAM wParam, LPARAM lParam)
{
	// fill in special struct for compatiblity with 16-bit WM_CTLCOLOR
	AFX_CTLCOLOR ctl;
	ctl.hDC = (HDC)wParam;
	ctl.hWnd = (HWND)lParam;
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	ctl.nCtlType = pThreadState->m_lastSentMsg.message - WM_CTLCOLORMSGBOX;
	//ASSERT(ctl.nCtlType >= CTLCOLOR_MSGBOX);
	ASSERT(ctl.nCtlType <= CTLCOLOR_STATIC);

	// Note: We call the virtual WindowProc for this window directly,
	//  instead of calling AfxCallWindowProc, so that Default()
	//  will still work (it will call the Default window proc with
	//  the original Win32 WM_CTLCOLOR message).
	return WindowProc(WM_CTLCOLOR, 0, (LPARAM)&ctl);
}

/////////////////////////////////////////////////////////////////////////////
// Multi-touch support:

BOOL CWnd::RegisterTouchWindow(BOOL bRegister, ULONG ulFlags)
{
	m_bIsTouchWindowRegistered = FALSE;
	
	static HMODULE hUserDll = AfxCtxLoadLibrary(_T("user32.dll"));
	ENSURE(hUserDll != NULL);

	typedef	BOOL (__stdcall *PFNREGISTERTOUCHWINDOW)(HWND, ULONG);
	typedef	BOOL (__stdcall *PFNUNREGISTERTOUCHWINDOW)(HWND);

	static PFNREGISTERTOUCHWINDOW pfRegister = (PFNREGISTERTOUCHWINDOW)GetProcAddress(hUserDll, "RegisterTouchWindow");
	static PFNUNREGISTERTOUCHWINDOW pfUnregister = (PFNUNREGISTERTOUCHWINDOW)GetProcAddress(hUserDll, "UnregisterTouchWindow");

	if (pfRegister == NULL || pfUnregister == NULL)
	{
		return FALSE;
	}

	if (!bRegister)
	{
		return (*pfUnregister)(GetSafeHwnd());
	}
	
	m_bIsTouchWindowRegistered = (*pfRegister)(GetSafeHwnd(), ulFlags);
	return m_bIsTouchWindowRegistered;
}

BOOL CWnd::IsTouchWindow() const
{
	static HMODULE hUserDll = AfxCtxLoadLibrary(_T("user32.dll"));
	ENSURE(hUserDll != NULL);

	typedef	BOOL (__stdcall *PFNISTOUCHWINDOW)(HWND);
	static PFNISTOUCHWINDOW pfIsTouchWindow = (PFNISTOUCHWINDOW)GetProcAddress(hUserDll, "IsTouchWindow");

	if (pfIsTouchWindow == NULL)
	{
		return FALSE;
	}

	return (*pfIsTouchWindow)(GetSafeHwnd());
}

LRESULT CWnd::OnTabletQuerySystemGestureStatus(WPARAM /*wParam*/, LPARAM lParam)
{
	CPoint ptTouch(GET_X_LPARAM (lParam), GET_Y_LPARAM(lParam));
	ScreenToClient(&ptTouch);

	return (LRESULT)GetGestureStatus(ptTouch);
}

ULONG CWnd::GetGestureStatus(CPoint /*ptTouch*/)
{
	return TABLET_DISABLE_PRESSANDHOLD;
}

LRESULT CWnd::OnTouchMessage(WPARAM wParam, LPARAM lParam)
{
	HANDLE hTouchInput = (HANDLE)lParam;

	UINT nInputsCount = LOWORD(wParam);
	if (nInputsCount == 0)
	{
		return Default();
	}

	static HMODULE hUserDll = AfxCtxLoadLibrary(_T("user32.dll"));
	ENSURE(hUserDll != NULL);

	typedef	BOOL (__stdcall *PFNGETTOUCHINPUTINFO)(HANDLE, UINT, PTOUCHINPUT, int);
	static PFNGETTOUCHINPUTINFO pfGetTouchInputInfo = (PFNGETTOUCHINPUTINFO)GetProcAddress(hUserDll, "GetTouchInputInfo");

	typedef	BOOL (__stdcall *PFNCLOSETOUCHINPUTHANDLE)(HANDLE);
	static PFNCLOSETOUCHINPUTHANDLE pfCloseTouchInputHandle = (PFNCLOSETOUCHINPUTHANDLE)GetProcAddress(hUserDll, "CloseTouchInputHandle");

	if (pfGetTouchInputInfo == NULL || pfCloseTouchInputHandle == NULL)
	{
		return Default();
	}

	PTOUCHINPUT pInputs = new TOUCHINPUT[nInputsCount];
	if (pInputs == NULL)
	{
		ASSERT(FALSE);
		return Default();
	}

	if (!(*pfGetTouchInputInfo)(hTouchInput, nInputsCount, pInputs, sizeof(TOUCHINPUT)))
	{
		ASSERT(FALSE);
		return Default();
	}

	BOOL bRes = OnTouchInputs(nInputsCount, pInputs);

	delete [] pInputs;
	(*pfCloseTouchInputHandle)(hTouchInput);

	return bRes ? 0 : Default ();
}

BOOL CWnd::OnTouchInputs(UINT nInputsCount, PTOUCHINPUT pInputs)
{
    for (UINT i = 0; i < nInputsCount; i++)
	{
		CPoint ptCurr(TOUCH_COORD_TO_PIXEL(pInputs[i].x), TOUCH_COORD_TO_PIXEL(pInputs[i].y));
		ScreenToClient(&ptCurr);

		if (!OnTouchInput(ptCurr, i, nInputsCount, &pInputs[i]))
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CWnd::OnTouchInput(CPoint /* pt */, int /* nInputNumber */, int /* nInputsCount */, PTOUCHINPUT /* pInput */)
{
	ASSERT(FALSE);	// Should be implemented in derived class
	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Gesture support:

BOOL CWnd::SetGestureConfig(CGestureConfig* pConfig)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pConfig);

	GESTURECONFIG* pConfigs = pConfig->m_pConfigs;
	UINT cIDs = (UINT)pConfig->m_nConfigs;

	static HMODULE hUserDll = AfxCtxLoadLibrary(_T("user32.dll"));
	ENSURE(hUserDll != NULL);

	typedef	BOOL (__stdcall *SETGESTURECONFIG)(HWND, DWORD, UINT, PGESTURECONFIG, UINT);
	static SETGESTURECONFIG pfSetGestureConfig = (SETGESTURECONFIG)GetProcAddress(hUserDll, "SetGestureConfig");
	if (pfSetGestureConfig == NULL)
	{
		return FALSE;
	}

	return (*pfSetGestureConfig)(GetSafeHwnd(), 0, cIDs, pConfigs, sizeof(GESTURECONFIG));
}

BOOL CWnd::GetGestureConfig(CGestureConfig* pConfig)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pConfig);

	if (!m_bGestureInited)
	{
		CGestureConfig configDefault;
		SetGestureConfig(&configDefault);
		m_bGestureInited = TRUE;
	}

	GESTURECONFIG* pConfigs = pConfig->m_pConfigs;
	UINT cIDs = (UINT)pConfig->m_nConfigs;

	static HMODULE hUserDll = AfxCtxLoadLibrary(_T("user32.dll"));
	ENSURE(hUserDll != NULL);

	typedef	BOOL (__stdcall *GETGESTURECONFIG)(HWND, DWORD, DWORD, PUINT, PGESTURECONFIG, UINT);
	static GETGESTURECONFIG pfGetGestureConfig = (GETGESTURECONFIG)GetProcAddress(hUserDll, "GetGestureConfig");
	if (pfGetGestureConfig == NULL)
	{
		return FALSE;
	}

	return (*pfGetGestureConfig)(GetSafeHwnd(), 0, 0, &cIDs, pConfigs, sizeof(GESTURECONFIG));
}

LRESULT CWnd::OnGesture(WPARAM /*wParam*/, LPARAM lParam)
{
	static HMODULE hUserDll = AfxCtxLoadLibrary(_T("user32.dll"));
	ENSURE(hUserDll != NULL);

	typedef	BOOL (__stdcall *GETGESTUREINFO)(HGESTUREINFO, PGESTUREINFO);
	typedef	BOOL (__stdcall *CLOSEGESTUREINFOHANDLE)(HGESTUREINFO);

	static GETGESTUREINFO pfGetGestureInfo = (GETGESTUREINFO)GetProcAddress(hUserDll, "GetGestureInfo");
	static CLOSEGESTUREINFOHANDLE pfCloseGestureInfoHandle = (CLOSEGESTUREINFOHANDLE)GetProcAddress(hUserDll, "CloseGestureInfoHandle");

	if (pfGetGestureInfo == NULL || pfCloseGestureInfoHandle == NULL)
	{
		return Default ();
	}

	if (m_pCurrentGestureInfo == NULL)
	{
		m_pCurrentGestureInfo = new GESTUREINFO;
	}

	ZeroMemory(m_pCurrentGestureInfo, sizeof(GESTUREINFO));
	m_pCurrentGestureInfo->cbSize = sizeof(GESTUREINFO);

	if (!(*pfGetGestureInfo)((HGESTUREINFO)lParam, m_pCurrentGestureInfo) || m_pCurrentGestureInfo->hwndTarget != GetSafeHwnd())
	{
		ZeroMemory(m_pCurrentGestureInfo, sizeof(GESTUREINFO));
		return Default ();
	}

	CPoint pt(m_pCurrentGestureInfo->ptsLocation.x, m_pCurrentGestureInfo->ptsLocation.y);
	ScreenToClient(&pt);

	BOOL bDefaultProcessing = TRUE;

	switch (m_pCurrentGestureInfo->dwID)
	{
	case GID_BEGIN:
		m_ptGestureFrom = pt;
		m_ulGestureArg = m_pCurrentGestureInfo->ullArguments;
		return Default();

	case GID_END:
		m_ptGestureFrom = CPoint(-1, -1);
		m_ulGestureArg = 0;
		ZeroMemory(m_pCurrentGestureInfo, sizeof(GESTUREINFO));
		return Default();

	case GID_ZOOM:
		bDefaultProcessing = !OnGestureZoom(pt, (long)(m_pCurrentGestureInfo->ullArguments - m_ulGestureArg));
		break;

	case GID_PAN:
		bDefaultProcessing = !OnGesturePan(m_ptGestureFrom, pt);
		break;

	case GID_ROTATE:
		bDefaultProcessing = !OnGestureRotate(pt, GID_ROTATE_ANGLE_FROM_ARGUMENT(m_pCurrentGestureInfo->ullArguments));
		break;

	case GID_TWOFINGERTAP:
		bDefaultProcessing = !OnGestureTwoFingerTap(pt);
		break;

	case GID_PRESSANDTAP:
		bDefaultProcessing = !OnGesturePressAndTap(pt, (long)m_pCurrentGestureInfo->ullArguments);
		break;
	}

	if (!bDefaultProcessing)
	{
		(*pfCloseGestureInfoHandle)((HGESTUREINFO)lParam);
	}

	m_ptGestureFrom = pt;
	m_ulGestureArg = m_pCurrentGestureInfo->ullArguments;

	return bDefaultProcessing ? Default() : 0;
}

BOOL CWnd::OnGestureZoom(CPoint /*ptCenter*/, long /*lDelta*/)
{
	return FALSE;	// Default processing
}

BOOL CWnd::OnGesturePan(CPoint /*ptFrom*/, CPoint /*ptTo*/)
{
	return FALSE;	// Default processing
}

BOOL CWnd::OnGestureRotate(CPoint /*ptCenter*/, double /*dblAngle*/)
{
	return FALSE;	// Default processing
}

BOOL CWnd::OnGestureTwoFingerTap(CPoint /*ptCenter*/)
{
	return FALSE;	// Default processing
}

BOOL CWnd::OnGesturePressAndTap(CPoint /*ptPress*/, long /*lDelta*/)
{
	return FALSE;	// Default processing
}

/////////////////////////////////////////////////////////////////////////////
// CWnd extensions for help support

void CWnd::WinHelp(DWORD_PTR dwData, UINT nCmd)
{
	CWinApp* pApp = AfxGetApp();
	ASSERT_VALID(pApp);
	ASSERT(pApp->m_pszHelpFilePath != NULL);
	ASSERT(pApp->m_eHelpType == afxWinHelp);

	CWaitCursor wait;

	PrepareForHelp();

	// need to use top level parent (for the case where m_hWnd is in DLL)
	CWnd* pWnd = EnsureTopLevelParent();

	TRACE(traceAppMsg, 0, _T("WinHelp: pszHelpFile = '%s', dwData: $%lx, fuCommand: %d.\n"), pApp->m_pszHelpFilePath, dwData, nCmd);

	// finally, run the Windows Help engine
	if (!::WinHelp(pWnd->m_hWnd, pApp->m_pszHelpFilePath, nCmd, dwData))
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH_HELP);
	}
}

void CWnd::HtmlHelp(DWORD_PTR dwData, UINT nCmd)
{
	CWinApp* pApp = AfxGetApp();
	ASSERT_VALID(pApp);
	ASSERT(pApp->m_pszHelpFilePath != NULL);
	// to call HtmlHelp the m_fUseHtmlHelp must be set in
	// the application's constructor
	ASSERT(pApp->m_eHelpType == afxHTMLHelp);

	CWaitCursor wait;

	PrepareForHelp();

	// need to use top level parent (for the case where m_hWnd is in DLL)
	CWnd* pWnd = EnsureTopLevelParent();

	TRACE(traceAppMsg, 0, _T("HtmlHelp: pszHelpFile = '%s', dwData: $%lx, fuCommand: %d.\n"), pApp->m_pszHelpFilePath, dwData, nCmd);

	// run the HTML Help engine
	if (!AfxHtmlHelp(pWnd->m_hWnd, pApp->m_pszHelpFilePath, nCmd, dwData))
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH_HELP);
	}
}

void CWnd::PrepareForHelp()
{
	if (IsFrameWnd())
	{
		// CFrameWnd windows should be allowed to exit help mode first
		CFrameWnd* pFrameWnd = static_cast<CFrameWnd*>(this);
		pFrameWnd->ExitHelpMode();
	}

	// cancel any tracking modes
	SendMessage(WM_CANCELMODE);
	SendMessageToDescendants(WM_CANCELMODE, 0, 0, TRUE, TRUE);

	// need to use top level parent (for the case where m_hWnd is in DLL)
	CWnd* pWnd = EnsureTopLevelParent();
	pWnd->SendMessage(WM_CANCELMODE);
	pWnd->SendMessageToDescendants(WM_CANCELMODE, 0, 0, TRUE, TRUE);

	// attempt to cancel capture
	HWND hWndCapture = ::GetCapture();
	if (hWndCapture != NULL)
		::SendMessage(hWndCapture, WM_CANCELMODE, 0, 0);
}

// for dll builds we just delay load it
#ifndef _AFXDLL
_AFX_HTMLHELP_STATE::~_AFX_HTMLHELP_STATE()
{
	if (m_hInstHtmlHelp)
		FreeLibrary(m_hInstHtmlHelp);
}
#endif

HWND WINAPI AfxHtmlHelp(HWND hWnd, LPCTSTR szHelpFilePath, UINT nCmd, DWORD_PTR dwData)
{
// for dll builds we just delay load it
#ifndef _AFXDLL
#ifdef _UNICODE
	#define _HTMLHELP_ENTRY "HtmlHelpW"
#else
	#define _HTMLHELP_ENTRY "HtmlHelpA"
#endif

	AfxLockGlobals(CRIT_DYNDLLLOAD);
	// check if the HtmlHelp library was loaded
	_AFX_HTMLHELP_STATE* pState = _afxHtmlHelpState.GetData();
	if (!pState->m_pfnHtmlHelp)
	{
		// load the library
		ASSERT(!pState->m_hInstHtmlHelp);
		pState->m_hInstHtmlHelp = AfxCtxLoadLibraryW(L"hhctrl.ocx");
		if (!pState->m_hInstHtmlHelp)
			return NULL;
		pState->m_pfnHtmlHelp = (HTMLHELPPROC *) GetProcAddress(pState->m_hInstHtmlHelp, _HTMLHELP_ENTRY);
		if (!pState->m_pfnHtmlHelp)
		{
			FreeLibrary(pState->m_hInstHtmlHelp);
			pState->m_hInstHtmlHelp = NULL;
			return NULL;
		}
	}
	AfxUnlockGlobals(CRIT_DYNDLLLOAD);
	// now call it
	return (*(pState->m_pfnHtmlHelp))(hWnd, szHelpFilePath, nCmd, dwData);
#else
	return ::HtmlHelp(hWnd, szHelpFilePath, nCmd, dwData);
#endif
}

void CWnd::WinHelpInternal(DWORD_PTR dwData, UINT nCmd)
{
	CWinApp* pApp = AfxGetApp();
	ASSERT_VALID(pApp);
	if (pApp->m_eHelpType == afxHTMLHelp)
	{
		// translate from WinHelp commands and data to to HtmlHelp
		ASSERT((nCmd == HELP_CONTEXT) || (nCmd == HELP_CONTENTS) || (nCmd == HELP_FINDER));
		if (nCmd == HELP_CONTEXT)
			nCmd = HH_HELP_CONTEXT;
		else if (nCmd == HELP_CONTENTS)
			nCmd = HH_DISPLAY_TOC;
		else if (nCmd == HELP_FINDER)
			nCmd = HH_HELP_FINDER;
		HtmlHelp(dwData, nCmd);
	}
	else
		WinHelp(dwData, nCmd);
}

/////////////////////////////////////////////////////////////////////////////
// Message table implementation

BEGIN_MESSAGE_MAP(CWnd, CCmdTarget)
	ON_MESSAGE(WM_CTLCOLORSTATIC, &CWnd::OnNTCtlColor)
	ON_MESSAGE(WM_CTLCOLOREDIT, &CWnd::OnNTCtlColor)
	ON_MESSAGE(WM_CTLCOLORBTN, &CWnd::OnNTCtlColor)
	ON_MESSAGE(WM_CTLCOLORLISTBOX, &CWnd::OnNTCtlColor)
	ON_MESSAGE(WM_CTLCOLORDLG, &CWnd::OnNTCtlColor)
	ON_MESSAGE(WM_CTLCOLORMSGBOX, &CWnd::OnNTCtlColor)
	ON_MESSAGE(WM_CTLCOLORSCROLLBAR, &CWnd::OnNTCtlColor)
	//{{AFX_MSG_MAP(CWnd)
    ON_WM_SETFOCUS()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_WM_CTLCOLOR()
	ON_WM_COMPAREITEM()
	ON_WM_ENTERIDLE()
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_DELETEITEM()
	ON_WM_CHARTOITEM()
	ON_WM_VKEYTOITEM()
	ON_WM_NCDESTROY()
	ON_WM_PARENTNOTIFY()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_DEVMODECHANGE()
	ON_WM_HELPINFO()
	ON_WM_SETTINGCHANGE()
	//}}AFX_MSG_MAP
#ifndef _AFX_NO_OCC_SUPPORT
	ON_WM_DESTROY()
#endif
	ON_MESSAGE(WM_ACTIVATETOPLEVEL, &CWnd::OnActivateTopLevel)
	ON_MESSAGE(WM_DISPLAYCHANGE, &CWnd::OnDisplayChange)
	ON_REGISTERED_MESSAGE(CWnd::m_nMsgDragList, &CWnd::OnDragList)
	ON_MESSAGE(WM_GETOBJECT, &CWnd::OnGetObject)
	ON_MESSAGE(WM_TOUCH, &CWnd::OnTouchMessage)
	ON_MESSAGE(WM_TABLET_QUERYSYSTEMGESTURESTATUS, &CWnd::OnTabletQuerySystemGestureStatus)
	ON_MESSAGE(WM_GESTURE, &CWnd::OnGesture)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Routines for fast search of message maps

const AFX_MSGMAP_ENTRY* AFXAPI
AfxFindMessageEntry(const AFX_MSGMAP_ENTRY* lpEntry,
	UINT nMsg, UINT nCode, UINT nID)
{
#if defined(_M_IX86) && !defined(_AFX_PORTABLE)
// 32-bit Intel 386/486 version.

	ASSERT(offsetof(AFX_MSGMAP_ENTRY, nMessage) == 0);
	ASSERT(offsetof(AFX_MSGMAP_ENTRY, nCode) == 4);
	ASSERT(offsetof(AFX_MSGMAP_ENTRY, nID) == 8);
	ASSERT(offsetof(AFX_MSGMAP_ENTRY, nLastID) == 12);
	ASSERT(offsetof(AFX_MSGMAP_ENTRY, nSig) == 16);

	_asm
	{
			MOV     EBX,lpEntry
			MOV     EAX,nMsg
			MOV     EDX,nCode
			MOV     ECX,nID
	__loop:
			CMP     DWORD PTR [EBX+16],0        ; nSig (0 => end)
			JZ      __failed
			CMP     EAX,DWORD PTR [EBX]         ; nMessage
			JE      __found_message
	__next:
			ADD     EBX,SIZE AFX_MSGMAP_ENTRY
			JMP     short __loop
	__found_message:
			CMP     EDX,DWORD PTR [EBX+4]       ; nCode
			JNE     __next
	// message and code good so far
	// check the ID
			CMP     ECX,DWORD PTR [EBX+8]       ; nID
			JB      __next
			CMP     ECX,DWORD PTR [EBX+12]      ; nLastID
			JA      __next
	// found a match
			MOV     lpEntry,EBX                 ; return EBX
			JMP     short __end
	__failed:
			XOR     EAX,EAX                     ; return NULL
			MOV     lpEntry,EAX
	__end:
	}
	return lpEntry;
#else  // _AFX_PORTABLE
	// C version of search routine
	while (lpEntry->nSig != AfxSig_end)
	{
		if (lpEntry->nMessage == nMsg && lpEntry->nCode == nCode &&
			nID >= lpEntry->nID && nID <= lpEntry->nLastID)
		{
			return lpEntry;
		}
		lpEntry++;
	}
	return NULL;    // not found
#endif  // _AFX_PORTABLE
}

/////////////////////////////////////////////////////////////////////////////
// Cache of most recently sent messages

#ifndef iHashMax
// iHashMax must be a power of two
	#define iHashMax 512
#endif

struct AFX_MSG_CACHE
{
	UINT nMsg;
	const AFX_MSGMAP_ENTRY* lpEntry;
	const AFX_MSGMAP* pMessageMap;
};

AFX_MSG_CACHE _afxMsgCache[iHashMax];

void AFXAPI AfxResetMsgCache()
{
	memset(_afxMsgCache, 0, sizeof(_afxMsgCache));
}

/////////////////////////////////////////////////////////////////////////////
// main WindowProc implementation

LRESULT CWnd::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	// OnWndMsg does most of the work, except for DefWindowProc call
	LRESULT lResult = 0;
	if (!OnWndMsg(message, wParam, lParam, &lResult))
		lResult = DefWindowProc(message, wParam, lParam);
	return lResult;
}

BOOL CWnd::OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	LRESULT lResult = 0;
	union MessageMapFunctions mmf;
	mmf.pfn = 0;
	CInternalGlobalLock winMsgLock;
	// special case for commands
	if (message == WM_COMMAND)
	{
		if (OnCommand(wParam, lParam))
		{
			lResult = 1;
			goto LReturnTrue;
		}
		return FALSE;
	}

	// special case for notifies
	if (message == WM_NOTIFY)
	{
		NMHDR* pNMHDR = (NMHDR*)lParam;
		if (pNMHDR->hwndFrom != NULL && OnNotify(wParam, lParam, &lResult))
			goto LReturnTrue;
		return FALSE;
	}

	// special case for activation
	if (message == WM_ACTIVATE)
		_AfxHandleActivate(this, wParam, CWnd::FromHandle((HWND)lParam));

	// special case for set cursor HTERROR
	if (message == WM_SETCURSOR &&
		_AfxHandleSetCursor(this, (short)LOWORD(lParam), HIWORD(lParam)))
	{
		lResult = 1;
		goto LReturnTrue;
	}

   // special case for windows that contain windowless ActiveX controls
   BOOL bHandled;

   bHandled = FALSE;
   if ((m_pCtrlCont != NULL) && (m_pCtrlCont->m_nWindowlessControls > 0))
   {
	  if (((message >= WM_MOUSEFIRST) && (message <= AFX_WM_MOUSELAST)) ||
		 ((message >= WM_KEYFIRST) && (message <= WM_IME_KEYLAST)) ||
		 ((message >= WM_IME_SETCONTEXT) && (message <= WM_IME_KEYUP)))
	  {
		 bHandled = m_pCtrlCont->HandleWindowlessMessage(message, wParam, lParam, &lResult);
	  }
   }
   if (bHandled)
   {
	  goto LReturnTrue;
   }

	const AFX_MSGMAP* pMessageMap; pMessageMap = GetMessageMap();
	UINT iHash; iHash = (LOWORD((DWORD_PTR)pMessageMap) ^ message) & (iHashMax-1);
	winMsgLock.Lock(CRIT_WINMSGCACHE);
	AFX_MSG_CACHE* pMsgCache; pMsgCache = &_afxMsgCache[iHash];
	const AFX_MSGMAP_ENTRY* lpEntry;
	if (message == pMsgCache->nMsg && pMessageMap == pMsgCache->pMessageMap)
	{
		// cache hit
		lpEntry = pMsgCache->lpEntry;
		winMsgLock.Unlock();
		if (lpEntry == NULL)
			return FALSE;

		// cache hit, and it needs to be handled
		if (message < 0xC000)
			goto LDispatch;
		else
			goto LDispatchRegistered;
	}
	else
	{
		// not in cache, look for it
		pMsgCache->nMsg = message;
		pMsgCache->pMessageMap = pMessageMap;

		for (/* pMessageMap already init'ed */; pMessageMap->pfnGetBaseMap != NULL;
			pMessageMap = (*pMessageMap->pfnGetBaseMap)())
		{
			// Note: catch not so common but fatal mistake!!
			//      BEGIN_MESSAGE_MAP(CMyWnd, CMyWnd)
			ASSERT(pMessageMap != (*pMessageMap->pfnGetBaseMap)());
			if (message < 0xC000)
			{
				// constant window message
				if ((lpEntry = AfxFindMessageEntry(pMessageMap->lpEntries,
					message, 0, 0)) != NULL)
				{
					pMsgCache->lpEntry = lpEntry;
					winMsgLock.Unlock();
					goto LDispatch;
				}
			}
			else
			{
				// registered windows message
				lpEntry = pMessageMap->lpEntries;
				while ((lpEntry = AfxFindMessageEntry(lpEntry, 0xC000, 0, 0)) != NULL)
				{
					UINT* pnID = (UINT*)(lpEntry->nSig);
					ASSERT(*pnID >= 0xC000 || *pnID == 0);
						// must be successfully registered
					if (*pnID == message)
					{
						pMsgCache->lpEntry = lpEntry;
						winMsgLock.Unlock();
						goto LDispatchRegistered;
					}
					lpEntry++;      // keep looking past this one
				}
			}
		}

		pMsgCache->lpEntry = NULL;
		winMsgLock.Unlock();
		return FALSE;
	}

LDispatch:
	ASSERT(message < 0xC000);

	mmf.pfn = lpEntry->pfn;

	switch (lpEntry->nSig)
	{
	default:
		ASSERT(FALSE);
		break;
	case AfxSig_l_p:
		{
			CPoint point(lParam);		
			lResult = (this->*mmf.pfn_l_p)(point);
			break;
		}		
	case AfxSig_b_D_v:
		lResult = (this->*mmf.pfn_b_D)(CDC::FromHandle(reinterpret_cast<HDC>(wParam)));
		break;

	case AfxSig_b_b_v:
		lResult = (this->*mmf.pfn_b_b)(static_cast<BOOL>(wParam));
		break;

	case AfxSig_b_u_v:
		lResult = (this->*mmf.pfn_b_u)(static_cast<UINT>(wParam));
		break;

	case AfxSig_b_h_v:
		lResult = (this->*mmf.pfn_b_h)(reinterpret_cast<HANDLE>(wParam));
		break;

	case AfxSig_i_u_v:
		lResult = (this->*mmf.pfn_i_u)(static_cast<UINT>(wParam));
		break;

	case AfxSig_C_v_v:
		lResult = reinterpret_cast<LRESULT>((this->*mmf.pfn_C_v)());
		break;

	case AfxSig_v_u_W:
		(this->*mmf.pfn_v_u_W)(static_cast<UINT>(wParam), 
			CWnd::FromHandle(reinterpret_cast<HWND>(lParam)));
		break;

	case AfxSig_u_u_v:
		lResult = (this->*mmf.pfn_u_u)(static_cast<UINT>(wParam));
		break;

	case AfxSig_b_v_v:
		lResult = (this->*mmf.pfn_b_v)();
		break;

	case AfxSig_b_W_uu:
		lResult = (this->*mmf.pfn_b_W_u_u)(CWnd::FromHandle(reinterpret_cast<HWND>(wParam)),
			LOWORD(lParam), HIWORD(lParam));
		break;

	case AfxSig_b_W_COPYDATASTRUCT:
		lResult = (this->*mmf.pfn_b_W_COPYDATASTRUCT)(
			CWnd::FromHandle(reinterpret_cast<HWND>(wParam)),
			reinterpret_cast<COPYDATASTRUCT*>(lParam));
		break;

	case AfxSig_b_v_HELPINFO:
		lResult = (this->*mmf.pfn_b_HELPINFO)(reinterpret_cast<LPHELPINFO>(lParam));
		break;

	case AfxSig_CTLCOLOR:
		{
			// special case for OnCtlColor to avoid too many temporary objects
			ASSERT(message == WM_CTLCOLOR);
			AFX_CTLCOLOR* pCtl = reinterpret_cast<AFX_CTLCOLOR*>(lParam);
			CDC dcTemp; 
			dcTemp.m_hDC = pCtl->hDC;
			CWnd wndTemp; 
			wndTemp.m_hWnd = pCtl->hWnd;
			UINT nCtlType = pCtl->nCtlType;
			// if not coming from a permanent window, use stack temporary
			CWnd* pWnd = CWnd::FromHandlePermanent(wndTemp.m_hWnd);
			if (pWnd == NULL)
			{
#ifndef _AFX_NO_OCC_SUPPORT
				// determine the site of the OLE control if it is one
				COleControlSite* pSite;
				if (m_pCtrlCont != NULL && (pSite = (COleControlSite*)
					m_pCtrlCont->m_siteMap.GetValueAt(wndTemp.m_hWnd)) != NULL)
				{
					wndTemp.m_pCtrlSite = pSite;
				}
#endif
				pWnd = &wndTemp;
			}
			HBRUSH hbr = (this->*mmf.pfn_B_D_W_u)(&dcTemp, pWnd, nCtlType);
			// fast detach of temporary objects
			dcTemp.m_hDC = NULL;
			wndTemp.m_hWnd = NULL;
			lResult = reinterpret_cast<LRESULT>(hbr);
		}
		break;

	case AfxSig_CTLCOLOR_REFLECT:
		{
			// special case for CtlColor to avoid too many temporary objects
			ASSERT(message == WM_REFLECT_BASE+WM_CTLCOLOR);
			AFX_CTLCOLOR* pCtl = reinterpret_cast<AFX_CTLCOLOR*>(lParam);
			CDC dcTemp; 
			dcTemp.m_hDC = pCtl->hDC;
			UINT nCtlType = pCtl->nCtlType;
			HBRUSH hbr = (this->*mmf.pfn_B_D_u)(&dcTemp, nCtlType);
			// fast detach of temporary objects
			dcTemp.m_hDC = NULL;
			lResult = reinterpret_cast<LRESULT>(hbr);
		}
		break;

	case AfxSig_i_u_W_u:
		lResult = (this->*mmf.pfn_i_u_W_u)(LOWORD(wParam),
			CWnd::FromHandle(reinterpret_cast<HWND>(lParam)), HIWORD(wParam));
		break;

	case AfxSig_i_uu_v:
		lResult = (this->*mmf.pfn_i_u_u)(LOWORD(wParam), HIWORD(wParam));
		break;

	case AfxSig_i_W_uu:
		lResult = (this->*mmf.pfn_i_W_u_u)(CWnd::FromHandle(reinterpret_cast<HWND>(wParam)),
			LOWORD(lParam), HIWORD(lParam));
		break;

	case AfxSig_i_v_s:
		lResult = (this->*mmf.pfn_i_s)(reinterpret_cast<LPTSTR>(lParam));
		break;

	case AfxSig_l_w_l:
		lResult = (this->*mmf.pfn_l_w_l)(wParam, lParam);
		break;

	case AfxSig_l_uu_M:
		lResult = (this->*mmf.pfn_l_u_u_M)(LOWORD(wParam), HIWORD(wParam), 
			CMenu::FromHandle(reinterpret_cast<HMENU>(lParam)));
		break;
		
	case AfxSig_v_b_h:
	    (this->*mmf.pfn_v_b_h)(static_cast<BOOL>(wParam), 
			reinterpret_cast<HANDLE>(lParam));
		break;

	case AfxSig_v_h_v:
	    (this->*mmf.pfn_v_h)(reinterpret_cast<HANDLE>(wParam));
		break;

	case AfxSig_v_h_h:
	    (this->*mmf.pfn_v_h_h)(reinterpret_cast<HANDLE>(wParam), 
			reinterpret_cast<HANDLE>(lParam));
		break;

	case AfxSig_v_v_v:
		(this->*mmf.pfn_v_v)();
		break;

	case AfxSig_v_u_v:
		(this->*mmf.pfn_v_u)(static_cast<UINT>(wParam));
		break;

	case AfxSig_v_u_u:
		(this->*mmf.pfn_v_u_u)(static_cast<UINT>(wParam), static_cast<UINT>(lParam));
		break;

	case AfxSig_v_uu_v:
		(this->*mmf.pfn_v_u_u)(LOWORD(wParam), HIWORD(wParam));
		break;

	case AfxSig_v_v_ii:
		(this->*mmf.pfn_v_i_i)(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
		break;

	case AfxSig_v_u_uu:
		(this->*mmf.pfn_v_u_u_u)(static_cast<UINT>(wParam), LOWORD(lParam), HIWORD(lParam));
		break;

	case AfxSig_v_u_ii:
		(this->*mmf.pfn_v_u_i_i)(static_cast<UINT>(wParam), LOWORD(lParam), HIWORD(lParam));
		break;

	case AfxSig_v_w_l:
		(this->*mmf.pfn_v_w_l)(wParam, lParam);
		break;

	case AfxSig_MDIACTIVATE:
		(this->*mmf.pfn_v_b_W_W)(m_hWnd == reinterpret_cast<HWND>(lParam),
			CWnd::FromHandle(reinterpret_cast<HWND>(lParam)),
			CWnd::FromHandle(reinterpret_cast<HWND>(wParam)));
		break;

	case AfxSig_v_D_v:
		(this->*mmf.pfn_v_D)(CDC::FromHandle(reinterpret_cast<HDC>(wParam)));
		break;

	case AfxSig_v_M_v:
		(this->*mmf.pfn_v_M)(CMenu::FromHandle(reinterpret_cast<HMENU>(wParam)));
		break;

	case AfxSig_v_M_ub:
		(this->*mmf.pfn_v_M_u_b)(CMenu::FromHandle(reinterpret_cast<HMENU>(wParam)),
			GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
		break;

	case AfxSig_v_W_v:
		(this->*mmf.pfn_v_W)(CWnd::FromHandle(reinterpret_cast<HWND>(wParam)));
		break;

	case AfxSig_v_v_W:
		(this->*mmf.pfn_v_W)(CWnd::FromHandle(reinterpret_cast<HWND>(lParam)));
		break;

	case AfxSig_v_W_uu:
		(this->*mmf.pfn_v_W_u_u)(CWnd::FromHandle(reinterpret_cast<HWND>(wParam)), LOWORD(lParam),
			HIWORD(lParam));
		break;

	case AfxSig_v_W_p:
		{
			CPoint point(lParam);
			(this->*mmf.pfn_v_W_p)(CWnd::FromHandle(reinterpret_cast<HWND>(wParam)), point);
		}
		break;

	case AfxSig_v_W_h:
		(this->*mmf.pfn_v_W_h)(CWnd::FromHandle(reinterpret_cast<HWND>(wParam)),
				reinterpret_cast<HANDLE>(lParam));
		break;

	case AfxSig_ACTIVATE:
		(this->*mmf.pfn_v_u_W_b)(LOWORD(wParam),
			CWnd::FromHandle(reinterpret_cast<HWND>(lParam)), HIWORD(wParam));
		break;

	case AfxSig_SCROLL:
	case AfxSig_SCROLL_REFLECT:
		{
			// special case for WM_VSCROLL and WM_HSCROLL
			ASSERT(message == WM_VSCROLL || message == WM_HSCROLL ||
				message == WM_VSCROLL+WM_REFLECT_BASE || message == WM_HSCROLL+WM_REFLECT_BASE);
			int nScrollCode = (short)LOWORD(wParam);
			int nPos = (short)HIWORD(wParam);
			if (lpEntry->nSig == AfxSig_SCROLL)
				(this->*mmf.pfn_v_u_u_W)(nScrollCode, nPos,
					CWnd::FromHandle(reinterpret_cast<HWND>(lParam)));
			else
				(this->*mmf.pfn_v_u_u)(nScrollCode, nPos);
		}
		break;

	case AfxSig_v_v_s:
		(this->*mmf.pfn_v_s)(reinterpret_cast<LPTSTR>(lParam));
		break;

	case AfxSig_v_u_cs:
		(this->*mmf.pfn_v_u_cs)(static_cast<UINT>(wParam), reinterpret_cast<LPCTSTR>(lParam));
		break;

	case AfxSig_OWNERDRAW:
		(this->*mmf.pfn_v_i_s)(static_cast<int>(wParam), reinterpret_cast<LPTSTR>(lParam));
		lResult = TRUE;
		break;

	case AfxSig_i_i_s:
		lResult = (this->*mmf.pfn_i_i_s)(static_cast<int>(wParam), reinterpret_cast<LPTSTR>(lParam));
		break;

	case AfxSig_u_v_p:
		{
			CPoint point(lParam);
			lResult = (this->*mmf.pfn_u_p)(point);
		}
		break;

	case AfxSig_u_v_v:
		lResult = (this->*mmf.pfn_u_v)();
		break;

	case AfxSig_v_b_NCCALCSIZEPARAMS:
		(this->*mmf.pfn_v_b_NCCALCSIZEPARAMS)(static_cast<BOOL>(wParam), 
			reinterpret_cast<NCCALCSIZE_PARAMS*>(lParam));
		break;

	case AfxSig_v_v_WINDOWPOS:
		(this->*mmf.pfn_v_v_WINDOWPOS)(reinterpret_cast<WINDOWPOS*>(lParam));
		break;

	case AfxSig_v_uu_M:
		(this->*mmf.pfn_v_u_u_M)(LOWORD(wParam), HIWORD(wParam), reinterpret_cast<HMENU>(lParam));
		break;

	case AfxSig_v_u_p:
		{
			CPoint point(lParam);
			(this->*mmf.pfn_v_u_p)(static_cast<UINT>(wParam), point);
		}
		break;

	case AfxSig_SIZING:
		(this->*mmf.pfn_v_u_pr)(static_cast<UINT>(wParam), reinterpret_cast<LPRECT>(lParam));
		lResult = TRUE;
		break;

	case AfxSig_MOUSEWHEEL:
		lResult = (this->*mmf.pfn_b_u_s_p)(LOWORD(wParam), (short)HIWORD(wParam),
			CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)));
		if (!lResult)
			return FALSE;
		break;
	case AfxSig_MOUSEHWHEEL:
		(this->*mmf.pfn_MOUSEHWHEEL)(LOWORD(wParam), (short)HIWORD(wParam),
			CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)));
		break;
	case AfxSig_l:
		lResult = (this->*mmf.pfn_l_v)();
		if (lResult != 0)
			return FALSE;
		break;
	case AfxSig_u_W_u:
		lResult = (this->*mmf.pfn_u_W_u)(CWnd::FromHandle(reinterpret_cast<HWND>(wParam)), static_cast<UINT>(lParam));
		break;
	case AfxSig_v_u_M:
		(this->*mmf.pfn_v_u_M)(static_cast<UINT>(wParam), CMenu::FromHandle(reinterpret_cast<HMENU>(lParam)));
		break;
	case AfxSig_u_u_M:
		lResult = (this->*mmf.pfn_u_u_M)(static_cast<UINT>(wParam), CMenu::FromHandle(reinterpret_cast<HMENU>(lParam)));
		break;
	case AfxSig_u_v_MENUGETOBJECTINFO:
		lResult = (this->*mmf.pfn_u_v_MENUGETOBJECTINFO)(reinterpret_cast<MENUGETOBJECTINFO*>(lParam));
		break;
	case AfxSig_v_M_u:
		(this->*mmf.pfn_v_M_u)(CMenu::FromHandle(reinterpret_cast<HMENU>(wParam)), static_cast<UINT>(lParam));
		break;
	case AfxSig_v_u_LPMDINEXTMENU:
		(this->*mmf.pfn_v_u_LPMDINEXTMENU)(static_cast<UINT>(wParam), reinterpret_cast<LPMDINEXTMENU>(lParam));
		break;
	case AfxSig_APPCOMMAND:
		(this->*mmf.pfn_APPCOMMAND)(CWnd::FromHandle(reinterpret_cast<HWND>(wParam)), static_cast<UINT>(GET_APPCOMMAND_LPARAM(lParam)), static_cast<UINT>(GET_DEVICE_LPARAM(lParam)), static_cast<UINT>(GET_KEYSTATE_LPARAM(lParam)));
		lResult = TRUE;
		break;
	case AfxSig_RAWINPUT:
		(this->*mmf.pfn_RAWINPUT)(static_cast<UINT>(GET_RAWINPUT_CODE_WPARAM(wParam)), reinterpret_cast<HRAWINPUT>(lParam));
		break;
	case AfxSig_u_u_u:
		lResult = (this->*mmf.pfn_u_u_u)(static_cast<UINT>(wParam), static_cast<UINT>(lParam));
		break;
	case AfxSig_MOUSE_XBUTTON:
		(this->*mmf.pfn_MOUSE_XBUTTON)(static_cast<UINT>(GET_KEYSTATE_WPARAM(wParam)), static_cast<UINT>(GET_XBUTTON_WPARAM(wParam)), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)));
		lResult = TRUE;
		break;
	case AfxSig_MOUSE_NCXBUTTON:
		(this->*mmf.pfn_MOUSE_NCXBUTTON)(static_cast<short>(GET_NCHITTEST_WPARAM(wParam)), static_cast<UINT>(GET_XBUTTON_WPARAM(wParam)), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)));
		lResult = TRUE;
		break;
	case AfxSig_INPUTLANGCHANGE:
		(this->*mmf.pfn_INPUTLANGCHANGE)(static_cast<UINT>(wParam), static_cast<UINT>(lParam));
		lResult = TRUE;
		break;
	case AfxSig_INPUTDEVICECHANGE:
		(this->*mmf.pfn_INPUTDEVICECHANGE)(GET_DEVICE_CHANGE_LPARAM(wParam), reinterpret_cast<HANDLE>(lParam));
		break;
	case AfxSig_v_u_hkl:
		(this->*mmf.pfn_v_u_h)(static_cast<UINT>(wParam), reinterpret_cast<HKL>(lParam));
		break;
	}
	goto LReturnTrue;

LDispatchRegistered:    // for registered windows messages
	ASSERT(message >= 0xC000);
	ASSERT(sizeof(mmf) == sizeof(mmf.pfn));
	mmf.pfn = lpEntry->pfn;
	lResult = (this->*mmf.pfn_l_w_l)(wParam, lParam);

LReturnTrue:
	if (pResult != NULL)
		*pResult = lResult;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CTestCmdUI - used to test for disabled commands before dispatching

class CTestCmdUI : public CCmdUI
{
public:
	CTestCmdUI();

public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetRadio(BOOL bOn);
	virtual void SetText(LPCTSTR);

	BOOL m_bEnabled;
};

CTestCmdUI::CTestCmdUI()
{
	m_bEnabled = TRUE;  // assume it is enabled
}

void CTestCmdUI::Enable(BOOL bOn)
{
	m_bEnabled = bOn;
	m_bEnableChanged = TRUE;
}

void CTestCmdUI::SetCheck(int)
{
	// do nothing -- just want to know about calls to Enable
}

void CTestCmdUI::SetRadio(BOOL)
{
	// do nothing -- just want to know about calls to Enable
}

void CTestCmdUI::SetText(LPCTSTR)
{
	// do nothing -- just want to know about calls to Enable
}

/////////////////////////////////////////////////////////////////////////////
// CWnd command handling

BOOL CWnd::OnCommand(WPARAM wParam, LPARAM lParam)
	// return TRUE if command invocation was attempted
{
	UINT nID = LOWORD(wParam);
	HWND hWndCtrl = (HWND)lParam;
	int nCode = HIWORD(wParam);

	// default routing for command messages (through closure table)

	if (hWndCtrl == NULL)
	{
		// zero IDs for normal commands are not allowed
		if (nID == 0)
			return FALSE;

		// make sure command has not become disabled before routing
		CTestCmdUI state;
		state.m_nID = nID;
		OnCmdMsg(nID, CN_UPDATE_COMMAND_UI, &state, NULL);
		if (!state.m_bEnabled)
		{
			TRACE(traceAppMsg, 0, "Warning: not executing disabled command %d\n", nID);
			return TRUE;
		}

		// menu or accelerator
		nCode = CN_COMMAND;
	}
	else
	{
		// control notification
		ASSERT(nID == 0 || ::IsWindow(hWndCtrl));

		if (_afxThreadState->m_hLockoutNotifyWindow == m_hWnd)
			return TRUE;        // locked out - ignore control notification

		// reflect notification to child window control
		if (ReflectLastMsg(hWndCtrl))
			return TRUE;    // eaten by child

		// zero IDs for normal commands are not allowed
		if (nID == 0)
			return FALSE;
	}

#ifdef _DEBUG
	if (nCode < 0 && nCode != (int)0x8000)
		TRACE(traceAppMsg, 0, "Implementation Warning: control notification = $%X.\n",
			nCode);
#endif

	return OnCmdMsg(nID, nCode, NULL, NULL);
}

BOOL CWnd::OnNotify(WPARAM, LPARAM lParam, LRESULT* pResult)
{
	ASSERT(pResult != NULL);
	NMHDR* pNMHDR = (NMHDR*)lParam;
	HWND hWndCtrl = pNMHDR->hwndFrom;

	// get the child ID from the window itself
	UINT_PTR nID = _AfxGetDlgCtrlID(hWndCtrl);
	int nCode = pNMHDR->code;

	ASSERT(hWndCtrl != NULL);
	ASSERT(::IsWindow(hWndCtrl));

	if (_afxThreadState->m_hLockoutNotifyWindow == m_hWnd)
		return TRUE;        // locked out - ignore control notification

	// reflect notification to child window control
	if (ReflectLastMsg(hWndCtrl, pResult))
		return TRUE;        // eaten by child

	AFX_NOTIFY notify;
	notify.pResult = pResult;
	notify.pNMHDR = pNMHDR;
	return OnCmdMsg((UINT)nID, MAKELONG(nCode, WM_NOTIFY), &notify, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// CWnd extensions

CFrameWnd* CWnd::GetParentFrame() const
{
	if (GetSafeHwnd() == NULL) // no Window attached
	{
		return NULL;
	}

	ASSERT_VALID(this);

	CWnd* pParentWnd = GetParent();  // start with one parent up
	while (pParentWnd != NULL)
	{
		if (pParentWnd->IsFrameWnd())
		{
			return (CFrameWnd*)pParentWnd;
		}
		pParentWnd = pParentWnd->GetParent();
	}
	return NULL;
}

HWND AFXAPI AfxGetParentOwner(HWND hWnd)
{
	// check for permanent-owned window first
	CWnd* pWnd = CWnd::FromHandlePermanent(hWnd);
	if (pWnd != NULL)
		return pWnd->GetOwner()->GetSafeHwnd();

	// otherwise, return parent in the Windows sense
	return (::GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD) ?
		::GetParent(hWnd) : ::GetWindow(hWnd, GW_OWNER);
}

CWnd* CWnd::GetTopLevelParent() const
{
	if (GetSafeHwnd() == NULL) // no Window attached
		return NULL;

	ASSERT_VALID(this);

	HWND hWndParent = m_hWnd;
	HWND hWndT;
	while ((hWndT = AfxGetParentOwner(hWndParent)) != NULL)
		hWndParent = hWndT;

	return CWnd::FromHandle(hWndParent);
}

CWnd* CWnd::GetTopLevelOwner() const
{
	if (GetSafeHwnd() == NULL) // no Window attached
		return NULL;

	ASSERT_VALID(this);

	HWND hWndOwner = m_hWnd;
	HWND hWndT;
	while ((hWndT = ::GetWindow(hWndOwner, GW_OWNER)) != NULL)
		hWndOwner = hWndT;

	return CWnd::FromHandle(hWndOwner);
}

CWnd* CWnd::GetParentOwner() const
{
	if (GetSafeHwnd() == NULL) // no Window attached
		return NULL;

	ASSERT_VALID(this);

	HWND hWndParent = m_hWnd;
	HWND hWndT;
	while ((::GetWindowLong(hWndParent, GWL_STYLE) & WS_CHILD) &&
		(hWndT = ::GetParent(hWndParent)) != NULL)
	{
		hWndParent = hWndT;
	}

	return CWnd::FromHandle(hWndParent);
}

BOOL CWnd::IsTopParentActive() const
{
	ASSERT(m_hWnd != NULL);
	ASSERT_VALID(this);

    CWnd *pWndTopLevel=EnsureTopLevelParent();

	return CWnd::GetForegroundWindow() == pWndTopLevel->GetLastActivePopup();
}

void CWnd::ActivateTopParent()
{
	// special activate logic for floating toolbars and palettes
	CWnd* pActiveWnd = GetForegroundWindow();
	if (pActiveWnd == NULL || !(pActiveWnd->m_hWnd == m_hWnd || ::IsChild(pActiveWnd->m_hWnd, m_hWnd)))
	{
		// clicking on floating frame when it does not have
		// focus itself -- activate the toplevel frame instead.
		EnsureTopLevelParent()->SetForegroundWindow();
	}
}

CFrameWnd* CWnd::GetTopLevelFrame() const
{
	if (GetSafeHwnd() == NULL) // no Window attached
		return NULL;

	ASSERT_VALID(this);

	CFrameWnd* pFrameWnd = (CFrameWnd*)this;
	if (!IsFrameWnd())
		pFrameWnd = GetParentFrame();

	if (pFrameWnd != NULL)
	{
		CFrameWnd* pTemp;
		while ((pTemp = pFrameWnd->GetParentFrame()) != NULL)
			pFrameWnd = pTemp;
	}
	return pFrameWnd;
}

CWnd* PASCAL CWnd::GetSafeOwner(CWnd* pParent, HWND* pWndTop)
{
	HWND hWnd = GetSafeOwner_(pParent->GetSafeHwnd(), pWndTop);
	return CWnd::FromHandle(hWnd);
}

int CWnd::MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption, UINT nType)
{
	if (lpszCaption == NULL)
		lpszCaption = AfxGetAppName();
	int nResult = ::AfxCtxMessageBox(GetSafeHwnd(), lpszText, lpszCaption, nType);
	return nResult;
}

CWnd* PASCAL CWnd::GetDescendantWindow(HWND hWnd, int nID, BOOL bOnlyPerm)
{
	// GetDlgItem recursive (return first found)
	// breadth-first for 1 level, then depth-first for next level

	// use GetDlgItem since it is a fast USER function
	HWND hWndChild;
	CWnd* pWndChild;
	if ((hWndChild = ::GetDlgItem(hWnd, nID)) != NULL)
	{
		if (::GetTopWindow(hWndChild) != NULL)
		{
			// children with the same ID as their parent have priority
			pWndChild = GetDescendantWindow(hWndChild, nID, bOnlyPerm);
			if (pWndChild != NULL)
				return pWndChild;
		}
		// return temporary handle if allowed
		if (!bOnlyPerm)
			return CWnd::FromHandle(hWndChild);

		// return only permanent handle
		pWndChild = CWnd::FromHandlePermanent(hWndChild);
		if (pWndChild != NULL)
			return pWndChild;
	}

	// walk each child
	for (hWndChild = ::GetTopWindow(hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		pWndChild = GetDescendantWindow(hWndChild, nID, bOnlyPerm);
		if (pWndChild != NULL)
			return pWndChild;
	}
	return NULL;    // not found
}

void PASCAL CWnd::SendMessageToDescendants(HWND hWnd, UINT message,
	WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm)
{
	// walk through HWNDs to avoid creating temporary CWnd objects
	// unless we need to call this function recursively
	for (HWND hWndChild = ::GetTopWindow(hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		// if bOnlyPerm is TRUE, don't send to non-permanent windows
		if (bOnlyPerm)
		{
			CWnd* pWnd = CWnd::FromHandlePermanent(hWndChild);
			if (pWnd != NULL)
			{
				// call window proc directly since it is a C++ window
				AfxCallWndProc(pWnd, pWnd->m_hWnd, message, wParam, lParam);
			}
		}
		else
		{
			// send message with Windows SendMessage API
			::SendMessage(hWndChild, message, wParam, lParam);
		}
		if (bDeep && ::GetTopWindow(hWndChild) != NULL)
		{
			// send to child windows after parent
			SendMessageToDescendants(hWndChild, message, wParam, lParam,
				bDeep, bOnlyPerm);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Scroll bar helpers
//  hook for CWnd functions
//    only works for derived class (eg: CView) that override 'GetScrollBarCtrl'
// if the window doesn't have a _visible_ windows scrollbar - then
//   look for a sibling with the appropriate ID

CScrollBar* CWnd::GetScrollBarCtrl(int) const
{
	return NULL;        // no special scrollers supported
}

int CWnd::SetScrollPos(int nBar, int nPos, BOOL bRedraw)
{
	CScrollBar* pScrollBar;
	if ((pScrollBar = GetScrollBarCtrl(nBar)) != NULL)
		return pScrollBar->SetScrollPos(nPos, bRedraw);
	else
		return ::SetScrollPos(m_hWnd, nBar, nPos, bRedraw);
}

int CWnd::GetScrollPos(int nBar) const
{
	CScrollBar* pScrollBar;
	if ((pScrollBar = GetScrollBarCtrl(nBar)) != NULL)
		return pScrollBar->GetScrollPos();
	else
		return ::GetScrollPos(m_hWnd, nBar);
}

void CWnd::SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw)
{
	CScrollBar* pScrollBar;
	if ((pScrollBar = GetScrollBarCtrl(nBar)) != NULL)
		pScrollBar->SetScrollRange(nMinPos, nMaxPos, bRedraw);
	else
		::SetScrollRange(m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
}

void CWnd::GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const
{
	CScrollBar* pScrollBar;
	if ((pScrollBar = GetScrollBarCtrl(nBar)) != NULL)
		pScrollBar->GetScrollRange(lpMinPos, lpMaxPos);
	else
		::GetScrollRange(m_hWnd, nBar, lpMinPos, lpMaxPos);
}

// Turn on/off non-control scrollbars
//   for WS_?SCROLL scrollbars - show/hide them
//   for control scrollbar - enable/disable them
void CWnd::EnableScrollBarCtrl(int nBar, BOOL bEnable)
{
	CScrollBar* pScrollBar;
	if (nBar == SB_BOTH)
	{
		EnableScrollBarCtrl(SB_HORZ, bEnable);
		EnableScrollBarCtrl(SB_VERT, bEnable);
	}
	else if ((pScrollBar = GetScrollBarCtrl(nBar)) != NULL)
	{
		// control scrollbar - enable or disable
		pScrollBar->EnableWindow(bEnable);
	}
	else
	{
		// WS_?SCROLL scrollbar - show or hide
		ShowScrollBar(nBar, bEnable);
	}
}

BOOL CWnd::SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw)
{
	ASSERT(lpScrollInfo != NULL);

	HWND hWnd = m_hWnd;
	CScrollBar* pScrollBar;
	if (nBar != SB_CTL && (pScrollBar = GetScrollBarCtrl(nBar)) != NULL)
	{
		hWnd = pScrollBar->m_hWnd;
		nBar = SB_CTL;
	}
	lpScrollInfo->cbSize = sizeof(*lpScrollInfo);
	::SetScrollInfo(hWnd, nBar, lpScrollInfo, bRedraw);
	return TRUE;
}

BOOL CWnd::GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, UINT nMask)
{
	ASSERT(lpScrollInfo != NULL);

	HWND hWnd = m_hWnd;
	CScrollBar* pScrollBar;
	if (nBar != SB_CTL && (pScrollBar = GetScrollBarCtrl(nBar)) != NULL)
	{
		hWnd = pScrollBar->m_hWnd;
		nBar = SB_CTL;
	}
	lpScrollInfo->cbSize = sizeof(*lpScrollInfo);
	lpScrollInfo->fMask = nMask;
	return ::GetScrollInfo(hWnd, nBar, lpScrollInfo);
}

int CWnd::GetScrollLimit(int nBar)
{
	int nMin, nMax;
	GetScrollRange(nBar, &nMin, &nMax);
	SCROLLINFO info;
	if (GetScrollInfo(nBar, &info, SIF_PAGE))
	{
		nMax -= __max(info.nPage-1,0);
	}
	return nMax;
}

void CWnd::ScrollWindow(int xAmount, int yAmount,
	LPCRECT lpRect, LPCRECT lpClipRect)
{
	ASSERT(::IsWindow(m_hWnd));

	if (IsWindowVisible() || lpRect != NULL || lpClipRect != NULL)
	{
		// When visible, let Windows do the scrolling
		::ScrollWindow(m_hWnd, xAmount, yAmount, lpRect, lpClipRect);
	}
	else
	{
		// Windows does not perform any scrolling if the window is
		// not visible.  This leaves child windows unscrolled.
		// To account for this oversight, the child windows are moved
		// directly instead.
		HWND hWndChild = ::GetWindow(m_hWnd, GW_CHILD);
		if (hWndChild != NULL)
		{
			for (; hWndChild != NULL;
				hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
			{
				CRect rect;
				::GetWindowRect(hWndChild, &rect);
				ScreenToClient(&rect);
				::SetWindowPos(hWndChild, NULL,
					rect.left+xAmount, rect.top+yAmount, 0, 0,
					SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER);
			}
		}
	}

#ifndef _AFX_NO_OCC_SUPPORT

	if ((m_pCtrlCont == NULL) || (lpRect != NULL))
		return;

	// the following code is for OLE control containers only

	m_pCtrlCont->ScrollChildren(xAmount, yAmount);

#endif // !_AFX_NO_OCC_SUPPORT
}

/////////////////////////////////////////////////////////////////////////////
// minimal layout support

void CWnd::RepositionBars(UINT nIDFirst, UINT nIDLast, UINT nIDLeftOver,
	UINT nFlags, LPRECT lpRectParam, LPCRECT lpRectClient, BOOL bStretch)
{
	ASSERT(nFlags == 0 || (nFlags & ~reposNoPosLeftOver) == reposQuery || 
			(nFlags & ~reposNoPosLeftOver) == reposExtra);

	// walk kids in order, control bars get the resize notification
	//   which allow them to shrink the client area
	// remaining size goes to the 'nIDLeftOver' pane
	// NOTE: nIDFirst->nIDLast are usually 0->0xffff

	AFX_SIZEPARENTPARAMS layout;
	HWND hWndLeftOver = NULL;

	layout.bStretch = bStretch;
	layout.sizeTotal.cx = layout.sizeTotal.cy = 0;
	if (lpRectClient != NULL)
		layout.rect = *lpRectClient;    // starting rect comes from parameter
	else
		GetClientRect(&layout.rect);    // starting rect comes from client rect

	if ((nFlags & ~reposNoPosLeftOver) != reposQuery)
		layout.hDWP = ::BeginDeferWindowPos(8); // reasonable guess
	else
		layout.hDWP = NULL; // not actually doing layout

	for (HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		UINT_PTR nIDC = _AfxGetDlgCtrlID(hWndChild);
		CWnd* pWnd = CWnd::FromHandlePermanent(hWndChild);
		if (nIDC == nIDLeftOver)
			hWndLeftOver = hWndChild;
		else if (nIDC >= nIDFirst && nIDC <= nIDLast && pWnd != NULL)
			::SendMessage(hWndChild, WM_SIZEPARENT, 0, (LPARAM)&layout);
	}

	// if just getting the available rectangle, return it now...
	if ((nFlags & ~reposNoPosLeftOver) == reposQuery)
	{
		ASSERT(lpRectParam != NULL);
		if (bStretch)
			::CopyRect(lpRectParam, &layout.rect);
		else
		{
			lpRectParam->left = lpRectParam->top = 0;
			lpRectParam->right = layout.sizeTotal.cx;
			lpRectParam->bottom = layout.sizeTotal.cy;
		}
		return;
	}

	// the rest is the client size of the left-over pane
	if (nIDLeftOver != 0 && hWndLeftOver != NULL)
	{
		CWnd* pLeftOver = CWnd::FromHandle(hWndLeftOver);
		// allow extra space as specified by lpRectBorder
		if ((nFlags & ~reposNoPosLeftOver) == reposExtra)
		{
			ASSERT(lpRectParam != NULL);
			layout.rect.left += lpRectParam->left;
			layout.rect.top += lpRectParam->top;
			layout.rect.right -= lpRectParam->right;
			layout.rect.bottom -= lpRectParam->bottom;
		}
		// reposition the window
		if ((nFlags & reposNoPosLeftOver) != reposNoPosLeftOver)
		{
			pLeftOver->CalcWindowRect(&layout.rect);
			AfxRepositionWindow(&layout, hWndLeftOver, &layout.rect);
		}
	}

	// move and resize all the windows at once!
	if (layout.hDWP == NULL || !::EndDeferWindowPos(layout.hDWP))
		TRACE(traceAppMsg, 0, "Warning: DeferWindowPos failed - low system resources.\n");
}

void AFXAPI AfxRepositionWindow(AFX_SIZEPARENTPARAMS* lpLayout,
	HWND hWnd, LPCRECT lpRect)
{
	ASSERT(hWnd != NULL);
	ASSERT(lpRect != NULL);
	HWND hWndParent = ::GetParent(hWnd);
	ASSERT(hWndParent != NULL);

	if (lpLayout != NULL && lpLayout->hDWP == NULL)
		return;

	// first check if the new rectangle is the same as the current
	CRect rectOld;
	::GetWindowRect(hWnd, rectOld);
	::ScreenToClient(hWndParent, &rectOld.TopLeft());
	::ScreenToClient(hWndParent, &rectOld.BottomRight());
	if (::EqualRect(rectOld, lpRect))
		return;     // nothing to do

	// try to use DeferWindowPos for speed, otherwise use SetWindowPos
	if (lpLayout != NULL)
	{
		lpLayout->hDWP = ::DeferWindowPos(lpLayout->hDWP, hWnd, NULL,
			lpRect->left, lpRect->top,  lpRect->right - lpRect->left,
			lpRect->bottom - lpRect->top, SWP_NOACTIVATE|SWP_NOZORDER);
	}
	else
	{
		::SetWindowPos(hWnd, NULL, lpRect->left, lpRect->top,
			lpRect->right - lpRect->left, lpRect->bottom - lpRect->top,
			SWP_NOACTIVATE|SWP_NOZORDER);
	}
}

void CWnd::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	DWORD dwExStyle = GetExStyle();
	if (nAdjustType == 0)
		dwExStyle &= ~WS_EX_CLIENTEDGE;
	::AdjustWindowRectEx(lpClientRect, GetStyle(), FALSE, dwExStyle);
}

/////////////////////////////////////////////////////////////////////////////
// Special keyboard/system command processing

BOOL CWnd::HandleFloatingSysCommand(UINT nID, LPARAM lParam)
{
	CWnd* pParent = GetTopLevelParent();
	switch (nID & 0xfff0)
	{
	case SC_PREVWINDOW:
	case SC_NEXTWINDOW:
		if (LOWORD(lParam) == VK_F6 && pParent != NULL)
		{
			pParent->SetFocus();
			return TRUE;
		}
		break;

	case SC_CLOSE:
	case SC_KEYMENU:
		// Check lParam.  If it is 0L, then the user may have done
		// an Alt+Tab, so just ignore it.  This breaks the ability to
		// just press the Alt-key and have the first menu selected,
		// but this is minor compared to what happens in the Alt+Tab
		// case.
		if ((nID & 0xfff0) == SC_CLOSE || lParam != 0L)
		{
			if (pParent != NULL)
			{
				// Sending the above WM_SYSCOMMAND may destroy the app,
				// so we have to be careful about restoring activation
				// and focus after sending it.
				HWND hWndSave = m_hWnd;
				HWND hWndFocus = ::GetFocus();
				pParent->SetActiveWindow();
				pParent->SendMessage(WM_SYSCOMMAND, nID, lParam);

				// be very careful here...
				if (::IsWindow(hWndSave))
					::SetActiveWindow(hWndSave);
				if (::IsWindow(hWndFocus))
					::SetFocus(hWndFocus);
			}
		}
		return TRUE;
	}
	return FALSE;
}

BOOL PASCAL CWnd::WalkPreTranslateTree(HWND hWndStop, MSG* pMsg)
{
	ASSERT(hWndStop == NULL || ::IsWindow(hWndStop));
	ASSERT(pMsg != NULL);

	// walk from the target window up to the hWndStop window checking
	//  if any window wants to translate this message

	for (HWND hWnd = pMsg->hwnd; hWnd != NULL; hWnd = ::GetParent(hWnd))
	{
		CWnd* pWnd = CWnd::FromHandlePermanent(hWnd);
		if (pWnd != NULL)
		{
			// target window is a C++ window
			if (pWnd->PreTranslateMessage(pMsg))
				return TRUE; // trapped by target window (eg: accelerators)
		}

		// got to hWndStop window without interest
		if (hWnd == hWndStop)
			break;
	}
	return FALSE;       // no special processing
}

BOOL CWnd::SendChildNotifyLastMsg(LRESULT* pResult)
{
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	return OnChildNotify(pThreadState->m_lastSentMsg.message,
		pThreadState->m_lastSentMsg.wParam, pThreadState->m_lastSentMsg.lParam, pResult);
}

BOOL PASCAL CWnd::ReflectLastMsg(HWND hWndChild, LRESULT* pResult)
{
	// get the map, and if no map, then this message does not need reflection
	CHandleMap* pMap = afxMapHWND();
	if (pMap == NULL)
		return FALSE;

	// check if in permanent map, if it is reflect it (could be OLE control)
	CWnd* pWnd = (CWnd*)pMap->LookupPermanent(hWndChild);
	ASSERT(pWnd == NULL || pWnd->m_hWnd == hWndChild);
	if (pWnd == NULL)
	{
#ifndef _AFX_NO_OCC_SUPPORT
		// check if the window is an OLE control
		CWnd* pWndParent = (CWnd*)pMap->LookupPermanent(::GetParent(hWndChild));
		if (pWndParent != NULL && pWndParent->m_pCtrlCont != NULL)
		{
			// If a matching control site exists, it's an OLE control
			COleControlSite* pSite = (COleControlSite*)pWndParent->
				m_pCtrlCont->m_siteMap.GetValueAt(hWndChild);
			if (pSite != NULL)
			{
				CWnd wndTemp(hWndChild);
				wndTemp.m_pCtrlSite = pSite;
				LRESULT lResult = wndTemp.SendChildNotifyLastMsg(pResult);
				wndTemp.m_hWnd = NULL;
				return lResult != 0;
			}
		}
#endif //!_AFX_NO_OCC_SUPPORT
		return FALSE;
	}

	// only OLE controls and permanent windows will get reflected msgs
	ASSERT(pWnd != NULL);
	return pWnd->SendChildNotifyLastMsg(pResult);
}

BOOL CWnd::OnChildNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
#ifndef _AFX_NO_OCC_SUPPORT
	if (m_pCtrlSite != NULL)
	{
		// first forward raw OCM_ messages to OLE control sources
		LRESULT lResult = SendMessage(OCM__BASE+uMsg, wParam, lParam);
		if (uMsg >= WM_CTLCOLORMSGBOX && uMsg <= WM_CTLCOLORSTATIC &&
			(HBRUSH)lResult == NULL)
		{
			// for WM_CTLCOLOR msgs, returning NULL implies continue routing
			return FALSE;
		}
		if (pResult != NULL)
			*pResult = lResult;
		return TRUE;
	}
#endif

	return ReflectChildNotify(uMsg, wParam, lParam, pResult);
}

BOOL CWnd::ReflectChildNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	// Note: reflected messages are send directly to CWnd::OnWndMsg
	//  and CWnd::OnCmdMsg for speed and because these messages are not
	//  routed by normal OnCmdMsg routing (they are only dispatched)

	switch (uMsg)
	{
	// normal messages (just wParam, lParam through OnWndMsg)
	case WM_HSCROLL:
	case WM_VSCROLL:
	case WM_PARENTNOTIFY:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_DELETEITEM:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_COMPAREITEM:
		// reflect the message through the message map as WM_REFLECT_BASE+uMsg
		return CWnd::OnWndMsg(WM_REFLECT_BASE+uMsg, wParam, lParam, pResult);

	// special case for WM_COMMAND
	case WM_COMMAND:
		{
			// reflect the message through the message map as OCM_COMMAND
			int nCode = HIWORD(wParam);
			if (CWnd::OnCmdMsg(0, MAKELONG(nCode, WM_REFLECT_BASE+WM_COMMAND), NULL, NULL))
			{
				if (pResult != NULL)
					*pResult = 1;
				return TRUE;
			}
		}
		break;

	// special case for WM_NOTIFY
	case WM_NOTIFY:
		{
			// reflect the message through the message map as OCM_NOTIFY
			NMHDR* pNMHDR = (NMHDR*)lParam;
			int nCode = pNMHDR->code;
			AFX_NOTIFY notify;
			notify.pResult = pResult;
			notify.pNMHDR = pNMHDR;
			return CWnd::OnCmdMsg(0, MAKELONG(nCode, WM_REFLECT_BASE+WM_NOTIFY), &notify, NULL);
		}

	// other special cases (WM_CTLCOLOR family)
	default:
		if (uMsg >= WM_CTLCOLORMSGBOX && uMsg <= WM_CTLCOLORSTATIC)
		{
			// fill in special struct for compatiblity with 16-bit WM_CTLCOLOR
			AFX_CTLCOLOR ctl;
			ctl.hDC = (HDC)wParam;
			ctl.nCtlType = uMsg - WM_CTLCOLORMSGBOX;
			//ASSERT(ctl.nCtlType >= CTLCOLOR_MSGBOX);
			ASSERT(ctl.nCtlType <= CTLCOLOR_STATIC);

			// reflect the message through the message map as OCM_CTLCOLOR
			BOOL bResult = CWnd::OnWndMsg(WM_REFLECT_BASE+WM_CTLCOLOR, 0, (LPARAM)&ctl, pResult);
			if ((HBRUSH)*pResult == NULL)
				bResult = FALSE;
			return bResult;
		}
		break;
	}

	return FALSE;   // let the parent handle it
}

void CWnd::OnParentNotify(UINT message, LPARAM lParam)
{
	if ((LOWORD(message) == WM_CREATE || LOWORD(message) == WM_DESTROY))
	{
		if (ReflectLastMsg((HWND)lParam))
			return;     // eat it
	}
	// not handled - do default
	Default();
}

void CWnd::OnSetFocus(CWnd*)
{ 
   BOOL bHandled;

   bHandled = FALSE;
#ifndef _AFX_NO_OCC_SUPPORT
   if (m_pCtrlCont != NULL)
   {
	  bHandled = m_pCtrlCont->HandleSetFocus();
   }
#endif  //!_AFX_NO_OCC_SUPPORT
   if( !bHandled )
   {
	  Default();
   }
}

LRESULT CWnd::OnActivateTopLevel(WPARAM wParam, LPARAM)
{
	if (LOWORD(wParam) == WA_INACTIVE)
	{
		AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();
		if (pModuleThreadState->m_pLastInfo != NULL &&
			!(pModuleThreadState->m_pLastInfo->uFlags & TTF_ALWAYSTIP))
			CancelToolTips(TRUE);
	}

	return 0;
}

void CWnd::OnSysColorChange()
{
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd == this)
	{
		// recolor global brushes used by control bars
		afxData.UpdateSysColors();
	}

	// forward this message to all other child windows
	if (!(GetStyle() & WS_CHILD))
		SendMessageToDescendants(WM_SYSCOLORCHANGE, 0, 0L, TRUE, TRUE);

	Default();
}

BOOL _afxGotScrollLines;

void CWnd::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	UNUSED_ALWAYS(uFlags);
	UNUSED_ALWAYS(lpszSection);

	// force refresh of settings that we cache
	_afxGotScrollLines = FALSE;

	if (m_pCtrlCont != NULL) 
	{
		m_pCtrlCont->BroadcastAmbientPropertyChange( DISPID_AMBIENT_LOCALEID );
	}

	CWnd::OnDisplayChange(0, 0);    // to update system metrics, etc.
}

void CWnd::OnDevModeChange(_In_z_ LPTSTR lpDeviceName)
{
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd == this)
		pApp->DevModeChange(lpDeviceName);

	// forward this message to all other child windows
	if (!(GetStyle() & WS_CHILD))
	{
		const MSG* pMsg = GetCurrentMessage();
		SendMessageToDescendants(pMsg->message, pMsg->wParam, pMsg->lParam,
			TRUE, TRUE);
	}
}

BOOL CWnd::OnHelpInfo(HELPINFO* /*pHelpInfo*/)
{
	if (!(GetStyle() & WS_CHILD))
	{
		CWnd* pMainWnd = AfxGetMainWnd();
		if (pMainWnd != NULL &&
			GetKeyState(VK_SHIFT) >= 0 &&
			GetKeyState(VK_CONTROL) >= 0 &&
			GetKeyState(VK_MENU) >= 0)
		{
			pMainWnd->SendMessage(WM_COMMAND, ID_HELP);
			return TRUE;
		}
	}
	return Default() != 0;
}

LRESULT CWnd::OnDisplayChange(WPARAM, LPARAM)
{
	// update metrics if this window is the main window
	if (AfxGetMainWnd() == this)
	{
		// update any system metrics cache
		afxData.UpdateSysMetrics();
	}

	// forward this message to all other child windows
	if (!(GetStyle() & WS_CHILD))
	{
		const MSG* pMsg = GetCurrentMessage();
		SendMessageToDescendants(pMsg->message, pMsg->wParam, pMsg->lParam,
			TRUE, TRUE);
	}

	return Default();
}

LRESULT CWnd::OnDragList(WPARAM, LPARAM lParam)
{
	LPDRAGLISTINFO lpInfo = (LPDRAGLISTINFO)lParam;
	ASSERT(lpInfo != NULL);

	LRESULT lResult;
	if (ReflectLastMsg(lpInfo->hWnd, &lResult))
		return (int)lResult;    // eat it

	// not handled - do default
	return (int)Default();
}

// Accessibility
LRESULT CWnd::OnGetObject(WPARAM wParam, LPARAM lParam)
{
	if (!m_bEnableActiveAccessibility)
		return Default();

	LRESULT lRet = 0;
	HRESULT hr = CreateAccessibleProxy(wParam, lParam, &lRet);
	if (FAILED(hr))
		return Default();
	return lRet;
}

//Helper class for Active Accesibility Proxy
//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
void AFXAPI AfxOleLockApp();
void AFXAPI AfxOleUnlockApp();

template <class Base>
class CMFCComObject : public Base
{
public:
	typedef Base _BaseClass;
	CMFCComObject(void* = NULL)
	{
		AfxOleLockApp();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	~CMFCComObject()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		AfxOleUnlockApp();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() throw() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)() throw()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) throw()
	{return _InternalQueryInterface(iid, ppvObject);}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}

	static HRESULT WINAPI CreateInstance(CMFCComObject<Base>** pp)
	{
		ATLASSERT(pp != NULL);
		if (pp == NULL)
			return E_POINTER;
		*pp = NULL;

		HRESULT hRes = E_OUTOFMEMORY;
		CMFCComObject<Base>* p = NULL;
		ATLTRY(p = new CMFCComObject<Base>())
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->_AtlInitialConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->FinalConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->_AtlFinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}	
};

BEGIN_INTERFACE_MAP(CWnd, CCmdTarget)
//	INTERFACE_PART(CWnd, __uuidof(IAccessible), Accessible)
//	INTERFACE_PART(CWnd, __uuidof(IAccessibleServer), AccessibleServer)
END_INTERFACE_MAP()

ULONG FAR EXPORT CWnd::XAccessible::AddRef()
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CWnd::XAccessible::Release()
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CWnd::XAccessible::QueryInterface(
	REFIID iid, void FAR* FAR* ppvObj)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT CWnd::XAccessible::Invoke(
			/* [in] */ DISPID dispIdMember,
			/* [in] */ REFIID refiid,
			/* [in] */ LCID lcid,
			/* [in] */ WORD wFlags,
			/* [out][in] */ DISPPARAMS *pDispParams,
			/* [out] */ VARIANT *pVarResult,
			/* [out] */ EXCEPINFO *pExcepInfo,
			/* [out] */ UINT *puArgErr) 
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return AtlIAccessibleInvokeHelper((IAccessible*)(void*)this, dispIdMember, refiid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
} 

HRESULT CWnd::XAccessible::GetIDsOfNames(
	REFIID refiid,
	LPOLESTR *rgszNames,
	UINT cNames,
	LCID lcid,
	DISPID *rgDispId) 
{
	return AtlIAccessibleGetIDsOfNamesHelper(refiid, rgszNames, cNames, lcid, rgDispId);
}

HRESULT CWnd::XAccessible::GetTypeInfoCount(unsigned int*  pctinfo) 
{
	if (pctinfo == NULL) 
	{
		return E_POINTER;
	}
	*pctinfo = 1;
	return S_OK;
}
HRESULT CWnd::XAccessible::GetTypeInfo(unsigned int /*iTInfo*/, LCID /*lcid*/, ITypeInfo** /*ppTInfo*/) 
{
	return E_NOTIMPL;
}

HRESULT CWnd::XAccessible::get_accParent(IDispatch **ppdispParent)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accParent(ppdispParent);
}
HRESULT CWnd::XAccessible::get_accChildCount(long *pcountChildren)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accChildCount(pcountChildren);
}
HRESULT CWnd::XAccessible::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accChild(varChild, ppdispChild);
}
HRESULT CWnd::XAccessible::get_accName(VARIANT varChild, BSTR *pszName)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accName(varChild, pszName);
}
HRESULT CWnd::XAccessible::get_accValue(VARIANT varChild, BSTR *pszValue)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accValue(varChild, pszValue);
}
HRESULT CWnd::XAccessible::get_accDescription(VARIANT varChild, BSTR *pszDescription)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accDescription(varChild, pszDescription);
}
HRESULT CWnd::XAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accRole(varChild, pvarRole);
}
HRESULT CWnd::XAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accState(varChild, pvarState);
}
HRESULT CWnd::XAccessible::get_accHelp(VARIANT varChild, BSTR *pszHelp)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accHelp(varChild, pszHelp);
}
HRESULT CWnd::XAccessible::get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}
HRESULT CWnd::XAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}
HRESULT CWnd::XAccessible::get_accFocus(VARIANT *pvarChild)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accFocus(pvarChild);
}
HRESULT CWnd::XAccessible::get_accSelection(VARIANT *pvarChildren)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accSelection(pvarChildren);
}
HRESULT CWnd::XAccessible::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->get_accDefaultAction(varChild, pszDefaultAction);
}
HRESULT CWnd::XAccessible::accSelect(long flagsSelect, VARIANT varChild)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->accSelect(flagsSelect, varChild);
}
HRESULT CWnd::XAccessible::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}
HRESULT CWnd::XAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->accNavigate(navDir, varStart, pvarEndUpAt);
}
HRESULT CWnd::XAccessible::accHitTest(long xLeft, long yTop, VARIANT *pvarChild)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->accHitTest(xLeft, yTop, pvarChild);
}
HRESULT CWnd::XAccessible::accDoDefaultAction(VARIANT varChild)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->accDoDefaultAction(varChild);
}
//Obsolete
HRESULT CWnd::XAccessible::put_accName(VARIANT varChild, BSTR szName)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->put_accName(varChild, szName);
}
//Obsolete
HRESULT CWnd::XAccessible::put_accValue(VARIANT varChild, BSTR szValue)
{
	METHOD_PROLOGUE(CWnd, Accessible)
	return pThis->put_accValue(varChild, szValue);
}

ULONG FAR EXPORT CWnd::XAccessibleServer::AddRef()
{
	METHOD_PROLOGUE(CWnd, AccessibleServer)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CWnd::XAccessibleServer::Release()
{
	METHOD_PROLOGUE(CWnd, AccessibleServer)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CWnd::XAccessibleServer::QueryInterface(
	REFIID iid, void FAR* FAR* ppvObj)
{
	METHOD_PROLOGUE(CWnd, AccessibleServer)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT CWnd::XAccessibleServer::SetProxy(IAccessibleProxy *pProxy)
{
	METHOD_PROLOGUE(CWnd, AccessibleServer)
	return pThis->SetProxy(pProxy);
}

HRESULT CWnd::XAccessibleServer::GetHWND(HWND *phWnd)
{
	if (phWnd == NULL)
		return E_POINTER;
	METHOD_PROLOGUE(CWnd, AccessibleServer)
	*phWnd = pThis->m_hWnd;
	return S_OK;
}

HRESULT CWnd::XAccessibleServer::GetEnumVariant(IEnumVARIANT **ppEnumVariant)
{
	if (ppEnumVariant == NULL)
		return E_POINTER;
	*ppEnumVariant = NULL;
	return E_NOTIMPL;
}


HRESULT CWnd::EnsureStdObj()
{
	if (m_pStdObject == NULL)
	{
		HRESULT hr = CreateStdAccessibleObject(m_hWnd, OBJID_CLIENT, __uuidof(IAccessible), (void**)&m_pStdObject);
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}

// Delegate to standard helper?
HRESULT CWnd::get_accParent(IDispatch **ppdispParent)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accParent(ppdispParent);
}

// Delegate to standard helper?
HRESULT CWnd::get_accChildCount(long *pcountChildren)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accChildCount(pcountChildren);
}

// Delegate to standard helper?
HRESULT CWnd::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accChild(varChild, ppdispChild);
}

// Override in users code
HRESULT CWnd::get_accName(VARIANT varChild, BSTR *pszName)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accName(varChild, pszName);
}

// Override in users code
// Default inplementation will get window text and return it.
HRESULT CWnd::get_accValue(VARIANT varChild, BSTR *pszValue)
{
	return m_pStdObject->get_accValue(varChild, pszValue);
}

// Override in users code
HRESULT CWnd::get_accDescription(VARIANT varChild, BSTR *pszDescription)
{
	return m_pStdObject->get_accDescription(varChild, pszDescription);
}

// Investigate
HRESULT CWnd::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accRole(varChild, pvarRole);
}

// Investigate
HRESULT CWnd::get_accState(VARIANT varChild, VARIANT *pvarState)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accState(varChild, pvarState);
}

// Override in User's code?
HRESULT CWnd::get_accHelp(VARIANT varChild, BSTR *pszHelp)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accHelp(varChild, pszHelp);
}

// Override in user's code?
HRESULT CWnd::get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}

// Override in user's code?
HRESULT CWnd::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}

// Delegate to standard implementation?
HRESULT CWnd::get_accFocus(VARIANT *pvarChild)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accFocus(pvarChild);
}

// Investigate
HRESULT CWnd::get_accSelection(VARIANT *pvarChildren)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accSelection(pvarChildren);
}

// Override in user's code
HRESULT CWnd::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->get_accDefaultAction(varChild, pszDefaultAction);
}

// Investigate
HRESULT CWnd::accSelect(long flagsSelect, VARIANT varChild)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->accSelect(flagsSelect, varChild);
}

// Delegate?
HRESULT CWnd::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}

// Delegate? May have to implement for COM children
HRESULT CWnd::accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->accNavigate(navDir, varStart, pvarEndUpAt);
}

// Delegate?
HRESULT CWnd::accHitTest(long xLeft, long yTop, VARIANT *pvarChild)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->accHitTest(xLeft, yTop, pvarChild);
}

// Override in user's code
HRESULT CWnd::accDoDefaultAction(VARIANT varChild)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->accDoDefaultAction(varChild);
}

//Obsolete
HRESULT CWnd::put_accName(VARIANT varChild, BSTR szName)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->put_accName(varChild, szName);
}

//Obsolete
HRESULT CWnd::put_accValue(VARIANT varChild, BSTR szValue)
{
	ASSERT(m_pStdObject != NULL);
	return m_pStdObject->put_accName(varChild, szValue);
}

HRESULT CWnd::SetProxy(IAccessibleProxy *pProxy)
{
	m_pProxy = pProxy;
	return S_OK;
}

HRESULT CWnd::CreateAccessibleProxy(WPARAM wParam, LPARAM lParam, LRESULT *pResult)
{
	ASSERT(pResult != NULL);
	DWORD dwObjId = (DWORD) lParam;
	HRESULT hr = E_FAIL;

	if (dwObjId == OBJID_CLIENT)
	{
		hr = EnsureStdObj();
		if (SUCCEEDED(hr))
		{
			if (m_pProxy == NULL)
			{
				CMFCComObject<CAccessibleProxy> *p;
				hr = CMFCComObject<CAccessibleProxy>::CreateInstance(&p);
				if (SUCCEEDED(hr))
				{
					CComPtr<IAccessibleProxy> spProx;
					hr = p->QueryInterface(&spProx);
					if (SUCCEEDED(hr))
					{
						m_pProxy = spProx;
						spProx->SetServer(static_cast<IAccessible*>((void*)&m_xAccessible), static_cast<IAccessibleServer*>((void*)&m_xAccessibleServer));
						*pResult = LresultFromObject (__uuidof(IAccessible), wParam, m_pProxy);
					}
					hr = S_OK;
				}
			}
			else
			{
				*pResult = LresultFromObject (__uuidof(IAccessible), wParam, m_pProxy);
				hr = S_OK;
			}
		}
	}
	return hr;
}

// Helpers for CWnd or derived class that contains Windowless Active X controls
// Used by CView, CFormView, CDialog and CDialogBar
long CWnd::GetWindowLessChildCount()
{
	long lCount = 0;
 	if (m_pCtrlCont != NULL)
	{
		// Add to the count the number of windowless active X controls.
		POSITION pos = m_pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
		while(pos)
		{
			COleControlSiteOrWnd *pSiteOrWnd = m_pCtrlCont->m_listSitesOrWnds.GetNext(pos);
			ASSERT(pSiteOrWnd);
			if(pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->m_bIsWindowless)
				lCount ++;
		}
	}
	return lCount;
}
long CWnd::GetWindowedChildCount()
{
	long lCount = 0;
	for (CWnd* pChild = GetWindow(GW_CHILD); pChild != NULL; pChild = pChild->GetWindow(GW_HWNDNEXT), lCount++);
	return lCount;
}

long CWnd::GetAccessibleChildCount()
{
	return GetWindowedChildCount() + GetWindowLessChildCount();
}

HRESULT CWnd::GetAccessibleChild(VARIANT varChild, IDispatch** ppdispChild)
{
	if (ppdispChild == NULL)
		return E_POINTER;
	*ppdispChild = NULL;

	long lCount = varChild.lVal - 1;
	if (lCount < 0)
		return E_INVALIDARG;

	CWnd* pChild = NULL;
	for(pChild = GetWindow(GW_CHILD); pChild != NULL && lCount != 0; pChild = pChild->GetWindow(GW_HWNDNEXT), lCount--);
	if (pChild != NULL)
	{
		// Found HWND
		return AccessibleObjectFromWindow(pChild->m_hWnd, OBJID_WINDOW, IID_IAccessible, (void**)ppdispChild);
	}
	// Windowless controls don't support accessibility.
	return S_FALSE;
}


HRESULT CWnd::GetAccessibleName(VARIANT varChild, BSTR* pszName)
{
	if (varChild.lVal == CHILDID_SELF)
	{
		CString strText;
		GetWindowText(strText);
		*pszName = strText.AllocSysString();
		return S_OK;
	}
	else
	{
		// Get Number of windowed children
		long lCount = GetWindowedChildCount();
		if (varChild.lVal > lCount)
		{
 			if (m_pCtrlCont != NULL)
			{
				// Add to the count the number of windowless active X controls.
				POSITION pos = m_pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
				while(pos != NULL)
				{
					COleControlSiteOrWnd *pSiteOrWnd = m_pCtrlCont->m_listSitesOrWnds.GetNext(pos);
					ASSERT(pSiteOrWnd);
					if(pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->m_bIsWindowless)
					{
						lCount ++;
						if (lCount == varChild.lVal)
						{
							CString strText;
							pSiteOrWnd->m_pSite->GetWindowText(strText);
							*pszName = strText.AllocSysString();
							return S_OK;
						}
					}
				}
			}			
		}
	}
	//out of range
	return E_INVALIDARG;
}
HRESULT CWnd::GetAccessibilityLocation(VARIANT varChild, long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight)
{
	HRESULT hr = CWnd::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
	if (FAILED(hr))
	{
		// Get Number of windowed children
		long lCount;
		CWnd::get_accChildCount(&lCount);
		long lWindowlessCount = GetWindowLessChildCount();
		if (varChild.lVal <= lCount + lWindowlessCount)
		{
			// Add to the count the number of windowless active X controls.
			POSITION pos;
			pos = m_pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
			COleControlSiteOrWnd *pSiteOrWnd;
			while(pos)
			{
				pSiteOrWnd = m_pCtrlCont->m_listSitesOrWnds.GetNext(pos);
				ASSERT(pSiteOrWnd);
				if(pSiteOrWnd->m_pSite)
				{
					if(pSiteOrWnd->m_pSite->m_bIsWindowless)
						lCount++;

					if (lCount == varChild.lVal)
					{
						CRect rect(pSiteOrWnd->m_pSite->m_rect);
						ClientToScreen(&rect);
						*pxLeft = rect.left;
						*pyTop = rect.top;
						*pcxWidth = rect.Width();
						*pcyHeight = rect.Height();
						hr = S_OK;
					}
				}
			}
		}
	}
	return hr;
}

HRESULT CWnd::GetAccessibilityHitTest(long xLeft, long yTop, VARIANT *pvarChild)
{
	// Check if it is one of the Windowless controls
 	if (m_pCtrlCont != NULL)
	{
		CPoint pt(xLeft, yTop);
		ScreenToClient(&pt);
		long lCount = GetWindowedChildCount();
		// If windowed child then let the standard object handle it.
 		if (m_pCtrlCont != NULL)
		{
			POSITION pos;
			pos = m_pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
			while(pos)
			{
				COleControlSiteOrWnd *pSiteOrWnd = m_pCtrlCont->m_listSitesOrWnds.GetNext(pos);
				ASSERT(pSiteOrWnd);
				if (pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite->m_bIsWindowless)
				{
					lCount ++;
					if (pSiteOrWnd->m_pSite->m_rect.PtInRect(pt))
					{
						pvarChild->vt = VT_I4;
						pvarChild->lVal = lCount;
						return S_OK;
					}
				}
			}
		}			
	}
	return CWnd::accHitTest(xLeft, yTop, pvarChild);
}

void CWnd::OnHScroll(UINT, UINT, CScrollBar* pScrollBar)
{
	if (pScrollBar != NULL && pScrollBar->SendChildNotifyLastMsg())
		return;     // eat it

	Default();
}

void CWnd::OnVScroll(UINT, UINT, CScrollBar* pScrollBar)
{
	if (pScrollBar != NULL && pScrollBar->SendChildNotifyLastMsg())
		return;     // eat it

	Default();
}

void CWnd::OnPaint()
{
   if (m_pCtrlCont != NULL)
   {
	  // Paint windowless controls
	  CPaintDC dc(this);
	  m_pCtrlCont->OnPaint(&dc);
   }

   Default();
}

void CWnd::OnEnterIdle(UINT /*nWhy*/, CWnd* /*pWho*/)
{
	// In some OLE inplace active scenarios, OLE will post a
	// message instead of sending it.  This causes so many WM_ENTERIDLE
	// messages to be sent that tasks running in the background stop
	// running.  By dispatching the pending WM_ENTERIDLE messages
	// when the first one is received, we trick Windows into thinking
	// that only one was really sent and dispatched.
	{
		MSG msg;
		while (PeekMessage(&msg, NULL, WM_ENTERIDLE, WM_ENTERIDLE, PM_REMOVE))
			DispatchMessage(&msg);
	}

	Default();
}

HBRUSH CWnd::OnCtlColor(CDC*, CWnd* pWnd, UINT)
{
	ASSERT(pWnd != NULL && pWnd->m_hWnd != NULL);
	LRESULT lResult;
	if (pWnd->SendChildNotifyLastMsg(&lResult))
		return (HBRUSH)lResult;     // eat it
	return (HBRUSH)Default();
}

// implementation of OnCtlColor for default gray backgrounds
//   (works for any window containing controls)
//  return value of FALSE means caller must call DefWindowProc's default
//  TRUE means that 'hbrGray' will be used and the appropriate text
//    ('clrText') and background colors are set.
BOOL PASCAL CWnd::GrayCtlColor(HDC hDC, HWND hWnd, UINT nCtlColor,
	HBRUSH hbrGray, COLORREF clrText)
{
	if (hDC == NULL)
	{
		// sometimes Win32 passes a NULL hDC in the WM_CTLCOLOR message.
		TRACE(traceAppMsg, 0, "Warning: hDC is NULL in CWnd::GrayCtlColor; WM_CTLCOLOR not processed.\n");
		return FALSE;
	}

	if (hbrGray == NULL ||
		nCtlColor == CTLCOLOR_EDIT || nCtlColor == CTLCOLOR_MSGBOX ||
		nCtlColor == CTLCOLOR_SCROLLBAR)
	{
		return FALSE;
	}

	if (nCtlColor == CTLCOLOR_LISTBOX)
	{
		// only handle requests to draw the space between edit and drop button
		//  in a drop-down combo (not a drop-down list)
		if (!_AfxIsComboBoxControl(hWnd, (UINT)CBS_DROPDOWN))
			return FALSE;
	}

	// set background color and return handle to brush
	LOGBRUSH logbrush;
	VERIFY(::GetObject(hbrGray, sizeof(LOGBRUSH), (LPVOID)&logbrush));
	::SetBkColor(hDC, logbrush.lbColor);
	if (clrText == (COLORREF)-1)
		clrText = ::GetSysColor(COLOR_WINDOWTEXT);  // normal text
	::SetTextColor(hDC, clrText);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// 'dialog data' support

BOOL CWnd::UpdateData(BOOL bSaveAndValidate)
{
	ASSERT(::IsWindow(m_hWnd)); // calling UpdateData before DoModal?

	CDataExchange dx(this, bSaveAndValidate);

	// prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	BOOL bOK = FALSE;       // assume failure
	TRY
	{
		DoDataExchange(&dx);
		bOK = TRUE;         // it worked
	}
	CATCH(CUserException, e)
	{
		// validation failed - user already alerted, fall through
		ASSERT(!bOK);
		// Note: DELETE_EXCEPTION_(e) not required
	}
	AND_CATCH_ALL(e)
	{
		// validation failed due to OOM or other resource failure
		e->ReportError(MB_ICONEXCLAMATION, AFX_IDP_INTERNAL_FAILURE);
		ASSERT(!bOK);
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
	return bOK;
}

CDataExchange::CDataExchange(CWnd* pDlgWnd, BOOL bSaveAndValidate)
{
	ASSERT_VALID(pDlgWnd);
	m_bSaveAndValidate = bSaveAndValidate;
	m_pDlgWnd = pDlgWnd;
	m_idLastControl = 0;
}

/////////////////////////////////////////////////////////////////////////////
// Centering dialog support (works for any non-child window)

void CWnd::CenterWindow(CWnd* pAlternateOwner)
{
	ASSERT(::IsWindow(m_hWnd));

	// determine owner window to center against
	DWORD dwStyle = GetStyle();
	HWND hWndCenter = pAlternateOwner->GetSafeHwnd();
	if (pAlternateOwner == NULL)
	{
		if (dwStyle & WS_CHILD)
			hWndCenter = ::GetParent(m_hWnd);
		else
			hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
		if (hWndCenter != NULL)
		{
			// let parent determine alternate center window
			HWND hWndTemp =
				(HWND)::SendMessage(hWndCenter, WM_QUERYCENTERWND, 0, 0);
			if (hWndTemp != NULL)
				hWndCenter = hWndTemp;
		}
	}

	// get coordinates of the window relative to its parent
	CRect rcDlg;
	GetWindowRect(&rcDlg);
	CRect rcArea;
	CRect rcCenter;
	HWND hWndParent;
	if (!(dwStyle & WS_CHILD))
	{
		// don't center against invisible or minimized windows
		if (hWndCenter != NULL)
		{
			DWORD dwAlternateStyle = ::GetWindowLong(hWndCenter, GWL_STYLE);
			if (!(dwAlternateStyle & WS_VISIBLE) || (dwAlternateStyle & WS_MINIMIZE))
				hWndCenter = NULL;
		}

 		MONITORINFO mi;
		mi.cbSize = sizeof(mi);

		// center within appropriate monitor coordinates
		if (hWndCenter == NULL)
		{
			HWND hwDefault = AfxGetMainWnd()->GetSafeHwnd();

			GetMonitorInfo(
				MonitorFromWindow(hwDefault, MONITOR_DEFAULTTOPRIMARY), &mi);
			rcCenter = mi.rcWork;
			rcArea = mi.rcWork;
		}
		else
		{
			::GetWindowRect(hWndCenter, &rcCenter);
			GetMonitorInfo(
				MonitorFromWindow(hWndCenter, MONITOR_DEFAULTTONEAREST), &mi);
			rcArea = mi.rcWork;
		}
	}
	else
	{
		// center within parent client coordinates
		hWndParent = ::GetParent(m_hWnd);
		ASSERT(::IsWindow(hWndParent));

		::GetClientRect(hWndParent, &rcArea);
		ASSERT(::IsWindow(hWndCenter));
		::GetClientRect(hWndCenter, &rcCenter);
		::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
	}

	// find dialog's upper left based on rcCenter
	int xLeft = (rcCenter.left + rcCenter.right) / 2 - rcDlg.Width() / 2;
	int yTop = (rcCenter.top + rcCenter.bottom) / 2 - rcDlg.Height() / 2;

	// if the dialog is outside the screen, move it inside
	if (xLeft + rcDlg.Width() > rcArea.right)
		xLeft = rcArea.right - rcDlg.Width();
	if (xLeft < rcArea.left)
		xLeft = rcArea.left;

	if (yTop + rcDlg.Height() > rcArea.bottom)
		yTop = rcArea.bottom - rcDlg.Height();
	if (yTop < rcArea.top)
		yTop = rcArea.top;

	// map screen coordinates to child coordinates
	SetWindowPos(NULL, xLeft, yTop, -1, -1,
		SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

BOOL CWnd::CheckAutoCenter()
{
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Dialog initialization support

BOOL CWnd::ExecuteDlgInit(LPCTSTR lpszResourceName)
{
	// find resource handle
	LPVOID lpResource = NULL;
	HGLOBAL hResource = NULL;
	if (lpszResourceName != NULL)
	{
		HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_DLGINIT);
		HRSRC hDlgInit = ::FindResource(hInst, lpszResourceName, RT_DLGINIT);
		if (hDlgInit != NULL)
		{
			// load it
			hResource = LoadResource(hInst, hDlgInit);
			if (hResource == NULL)
				return FALSE;
			// lock it
			lpResource = LockResource(hResource);
			ASSERT(lpResource != NULL);
		}
	}

	// execute it
	BOOL bResult = ExecuteDlgInit(lpResource);

	// cleanup
	if (lpResource != NULL && hResource != NULL)
	{
		UnlockResource(hResource);
		FreeResource(hResource);
	}
	return bResult;
}

BOOL CWnd::ExecuteDlgInit(LPVOID lpResource)
{
	// Subclass Feature Pack controls: 
	if (m_pMFCCtrlContainer == NULL)
	{
		m_pMFCCtrlContainer = new CMFCControlContainer (this);
		m_pMFCCtrlContainer->SubclassDlgControls ();
	}

	BOOL bSuccess = TRUE;
	if (lpResource != NULL)
	{
		UNALIGNED WORD* lpnRes = (WORD*)lpResource;
		while (bSuccess && *lpnRes != 0)	
		{
			WORD nIDC = *lpnRes++;
			WORD nMsg = *lpnRes++;
			DWORD dwLen = *((UNALIGNED DWORD*&)lpnRes)++;

			// In Win32 the WM_ messages have changed.  They have
			// to be translated from the 16-bit values to 32-bit
			// values here.

			#define WIN16_LB_ADDSTRING  0x0401
			#define WIN16_CB_ADDSTRING  0x0403
			#define AFX_CB_ADDSTRING	0x1234

			// unfortunately, WIN16_CB_ADDSTRING == CBEM_INSERTITEM
			if (nMsg == AFX_CB_ADDSTRING)
				nMsg = CBEM_INSERTITEM;
			else if (nMsg == WIN16_LB_ADDSTRING)
				nMsg = LB_ADDSTRING;
			else if (nMsg == WIN16_CB_ADDSTRING)
				nMsg = CB_ADDSTRING;

			// check for invalid/unknown message types
#ifdef _AFX_NO_OCC_SUPPORT
			ASSERT(nMsg == LB_ADDSTRING || nMsg == CB_ADDSTRING ||
				nMsg == CBEM_INSERTITEM || nMsg == WM_MFC_INITCTRL);
#else
			ASSERT(nMsg == LB_ADDSTRING || nMsg == CB_ADDSTRING ||
				nMsg == CBEM_INSERTITEM || nMsg == WM_MFC_INITCTRL ||
				nMsg == WM_OCC_LOADFROMSTREAM ||
				nMsg == WM_OCC_LOADFROMSTREAM_EX ||
				nMsg == WM_OCC_LOADFROMSTORAGE ||
				nMsg == WM_OCC_LOADFROMSTORAGE_EX ||
				nMsg == WM_OCC_INITNEW);
#endif

#ifdef _DEBUG
			// For AddStrings, the count must exactly delimit the
			// string, including the NULL termination.  This check
			// will not catch all mal-formed ADDSTRINGs, but will
			// catch some.
			if (nMsg == LB_ADDSTRING || nMsg == CB_ADDSTRING || nMsg == CBEM_INSERTITEM)
				ASSERT(*((LPBYTE)lpnRes + (UINT)dwLen - 1) == 0);
#endif

			if (nMsg == CBEM_INSERTITEM)
			{
				COMBOBOXEXITEM item = {0};
				item.mask = CBEIF_TEXT;
				item.iItem = -1;
				CString strText(reinterpret_cast<LPTSTR>(lpnRes));				
				item.pszText = const_cast<LPTSTR>(strText.GetString());
				if (::SendDlgItemMessage(m_hWnd, nIDC, nMsg, 0, (LPARAM) &item) == -1)
					bSuccess = FALSE;
			}
			else if (nMsg == WM_MFC_INITCTRL)
			{
				if (::SendDlgItemMessage(m_hWnd, nIDC, nMsg, (WPARAM)dwLen, (LPARAM) lpnRes) == -1)
					bSuccess = FALSE;
				if (m_pMFCCtrlContainer != NULL)
				{
					m_pMFCCtrlContainer->SetControlData(nIDC, dwLen, (BYTE*) lpnRes);
				}
			}
#ifndef _AFX_NO_OCC_SUPPORT
			else if (nMsg == LB_ADDSTRING || nMsg == CB_ADDSTRING)
#endif // !_AFX_NO_OCC_SUPPORT
			{
				// List/Combobox returns -1 for error
				if (::SendDlgItemMessageA(m_hWnd, nIDC, nMsg, 0, (LPARAM) lpnRes) == -1)
					bSuccess = FALSE;
			}


			// skip past data
			lpnRes = (WORD*)((LPBYTE)lpnRes + (UINT)dwLen);
		}
	}

	// send update message to all controls after all other siblings loaded
	if (bSuccess)
		SendMessageToDescendants(WM_INITIALUPDATE, 0, 0, FALSE, FALSE);

	return bSuccess;
}

void CWnd::UpdateDialogControls(CCmdTarget* pTarget, BOOL bDisableIfNoHndler)
{
	CCmdUI state;
	CWnd wndTemp;       // very temporary window just for CmdUI update

	// walk all the kids - assume the IDs are for buttons
	for (HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
			hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		// send to buttons
		wndTemp.m_hWnd = hWndChild; // quick and dirty attach
		state.m_nID = _AfxGetDlgCtrlID(hWndChild);
		state.m_pOther = &wndTemp;

		// check for reflect handlers in the child window
		CWnd* pWnd = CWnd::FromHandlePermanent(hWndChild);
		if (pWnd != NULL)
		{
			// call it directly to disable any routing
			if (pWnd->CWnd::OnCmdMsg(0, MAKELONG(0xffff,
				WM_COMMAND+WM_REFLECT_BASE), &state, NULL))
				continue;
		}

		// check for handlers in the parent window
		if (CWnd::OnCmdMsg((UINT)state.m_nID, CN_UPDATE_COMMAND_UI, &state, NULL))
			continue;

		// determine whether to disable when no handler exists
		BOOL bDisableTemp = bDisableIfNoHndler;
		if (bDisableTemp)
		{
			if ((wndTemp.SendMessage(WM_GETDLGCODE) & DLGC_BUTTON) == 0)
			{
				// non-button controls don't get automagically disabled
				bDisableTemp = FALSE;
			}
			else
			{
				// only certain button controls get automagically disabled
				UINT nStyle = (UINT)(wndTemp.GetStyle() & 0x0F);
				if (nStyle == (UINT)BS_AUTOCHECKBOX ||
					nStyle == (UINT)BS_AUTO3STATE ||
					nStyle == (UINT)BS_GROUPBOX ||
					nStyle == (UINT)BS_AUTORADIOBUTTON)
				{
					bDisableTemp = FALSE;
				}
			}
		}
		// check for handlers in the target (owner)
		state.DoUpdate(pTarget, bDisableTemp);
	}
	wndTemp.m_hWnd = NULL;      // quick and dirty detach
}

BOOL CWnd::PreTranslateInput(LPMSG lpMsg)
{
	ASSERT(::IsWindow(m_hWnd));

	// don't translate non-input events
	if ((lpMsg->message < WM_KEYFIRST || lpMsg->message > WM_KEYLAST) &&
		(lpMsg->message < WM_MOUSEFIRST || lpMsg->message > AFX_WM_MOUSELAST))
		return FALSE;

	return IsDialogMessage(lpMsg);
}

int CWnd::RunModalLoop(DWORD dwFlags)
{
	ASSERT(::IsWindow(m_hWnd)); // window must be created
	ASSERT(!(m_nFlags & WF_MODALLOOP)); // window must not already be in modal state

	// for tracking the idle time state
	BOOL bIdle = TRUE;
	LONG lIdleCount = 0;
	BOOL bShowIdle = (dwFlags & MLF_SHOWONIDLE) && !(GetStyle() & WS_VISIBLE);
	HWND hWndParent = ::GetParent(m_hWnd);
	m_nFlags |= (WF_MODALLOOP|WF_CONTINUEMODAL);
	MSG *pMsg = AfxGetCurrentMessage();

	// acquire and dispatch messages until the modal state is done
	for (;;)
	{
		ASSERT(ContinueModal());

		// phase1: check to see if we can do idle work
		while (bIdle &&
			!::PeekMessage(pMsg, NULL, NULL, NULL, PM_NOREMOVE))
		{
			ASSERT(ContinueModal());

			// show the dialog when the message queue goes idle
			if (bShowIdle)
			{
				ShowWindow(SW_SHOWNORMAL);
				UpdateWindow();
				bShowIdle = FALSE;
			}

			// call OnIdle while in bIdle state
			if (!(dwFlags & MLF_NOIDLEMSG) && hWndParent != NULL && lIdleCount == 0)
			{
				// send WM_ENTERIDLE to the parent
				::SendMessage(hWndParent, WM_ENTERIDLE, MSGF_DIALOGBOX, (LPARAM)m_hWnd);
			}
			if ((dwFlags & MLF_NOKICKIDLE) ||
				!SendMessage(WM_KICKIDLE, MSGF_DIALOGBOX, lIdleCount++))
			{
				// stop idle processing next time
				bIdle = FALSE;
			}
		}

		// phase2: pump messages while available
		do
		{
			ASSERT(ContinueModal());

			// pump message, but quit on WM_QUIT
			if (!AfxPumpMessage())
			{
				AfxPostQuitMessage(0);
				return -1;
			}

			// show the window when certain special messages rec'd
			if (bShowIdle &&
				(pMsg->message == 0x118 || pMsg->message == WM_SYSKEYDOWN))
			{
				ShowWindow(SW_SHOWNORMAL);
				UpdateWindow();
				bShowIdle = FALSE;
			}

			if (!ContinueModal())
				goto ExitModal;

			// reset "no idle" state after pumping "normal" message
			if (AfxIsIdleMessage(pMsg))
			{
				bIdle = TRUE;
				lIdleCount = 0;
			}

		} while (::PeekMessage(pMsg, NULL, NULL, NULL, PM_NOREMOVE));
	}

ExitModal:
	m_nFlags &= ~(WF_MODALLOOP|WF_CONTINUEMODAL);
	return m_nModalResult;
}

BOOL CWnd::ContinueModal()
{
	return m_nFlags & WF_CONTINUEMODAL;
}

void CWnd::EndModalLoop(int nResult)
{
	ASSERT(::IsWindow(m_hWnd));

	// this result will be returned from CWnd::RunModalLoop
	m_nModalResult = nResult;

	// make sure a message goes through to exit the modal loop
	if (m_nFlags & WF_CONTINUEMODAL)
	{
		m_nFlags &= ~WF_CONTINUEMODAL;
		PostMessage(WM_NULL);
	}
}

void CWnd::OnDrawIconicThumbnailOrLivePreview(CDC& dc, CRect /*rect*/, CSize /*szRequiredThumbnailSize*/, BOOL /*bIsThumbnail*/, BOOL& /*bAlphaChannelSet*/)
{
	ASSERT_VALID(&dc);
	SendMessage(WM_PRINT, (WPARAM)dc.GetSafeHdc(), (LPARAM)(PRF_CLIENT | PRF_ERASEBKGND | PRF_CHILDREN | PRF_NONCLIENT));
}

#ifndef _AFX_NO_OCC_SUPPORT

BOOL CWnd::SetOccDialogInfo(_AFX_OCC_DIALOG_INFO*)
{
	ASSERT(FALSE); // this class doesn't support dialog creation
	return FALSE;
}
_AFX_OCC_DIALOG_INFO* CWnd::GetOccDialogInfo()
{	
	return NULL;
}

#endif

/////////////////////////////////////////////////////////////////////////////
// Standard init called by WinMain

AFX_STATIC BOOL AFXAPI _AfxRegisterWithIcon(WNDCLASS* pWndCls,
	LPCTSTR lpszClassName, UINT nIDIcon)
{
	pWndCls->lpszClassName = lpszClassName;
	HINSTANCE hInst = AfxFindResourceHandle(
		ATL_MAKEINTRESOURCE(nIDIcon), ATL_RT_GROUP_ICON);
	if ((pWndCls->hIcon = ::LoadIconW(hInst, ATL_MAKEINTRESOURCEW(nIDIcon))) == NULL)
	{
		// use default icon
		pWndCls->hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
	}
	return AfxRegisterClass(pWndCls);
}

LONG AFXAPI _AfxInitCommonControls(LPINITCOMMONCONTROLSEX lpInitCtrls, LONG fToRegister)
{
	ASSERT(fToRegister != 0);

	LONG lResult = 0;
	if (AFX_COMCTL32_IF_EXISTS(InitCommonControlsEx))
	{
		if (AfxInitCommonControlsEx(lpInitCtrls))
		{
			// InitCommonControlsEx was successful so return the full mask
			lResult = fToRegister;
		}
	}
	else
	{
		// not there, so call InitCommonControls if possible
		if ((fToRegister & AFX_WIN95CTLS_MASK) == fToRegister)
		{
			AfxInitCommonControls();
			lResult = AFX_WIN95CTLS_MASK;
		}
	}
	return lResult;
}

BOOL AFXAPI AfxEndDeferRegisterClass(LONG fToRegister)
{
	// mask off all classes that are already registered
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	fToRegister &= ~pModuleState->m_fRegisteredClasses;
	if (fToRegister == 0)
		return TRUE;

	LONG fRegisteredClasses = 0;

	// common initialization
	WNDCLASS wndcls;
	memset(&wndcls, 0, sizeof(WNDCLASS));   // start with NULL defaults
	wndcls.lpfnWndProc = DefWindowProc;
	wndcls.hInstance = AfxGetInstanceHandle();
	wndcls.hCursor = afxData.hcurArrow;

	INITCOMMONCONTROLSEX init;
	init.dwSize = sizeof(init);

	// work to register classes as specified by fToRegister, populate fRegisteredClasses as we go
	if (fToRegister & AFX_WND_REG)
	{
		// Child windows - no brush, no icon, safest default class styles
		wndcls.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
		wndcls.lpszClassName = _afxWnd;
		if (AfxRegisterClass(&wndcls))
			fRegisteredClasses |= AFX_WND_REG;
	}
	if (fToRegister & AFX_WNDOLECONTROL_REG)
	{
		// OLE Control windows - use parent DC for speed
		wndcls.style |= CS_PARENTDC | CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
		wndcls.lpszClassName = _afxWndOleControl;
		if (AfxRegisterClass(&wndcls))
			fRegisteredClasses |= AFX_WNDOLECONTROL_REG;
	}
	if (fToRegister & AFX_WNDCONTROLBAR_REG)
	{
		// Control bar windows
		wndcls.style = 0;   // control bars don't handle double click
		wndcls.lpszClassName = _afxWndControlBar;
		wndcls.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
		if (AfxRegisterClass(&wndcls))
			fRegisteredClasses |= AFX_WNDCONTROLBAR_REG;
	}
	if (fToRegister & AFX_WNDMDIFRAME_REG)
	{
		// MDI Frame window (also used for splitter window)
		wndcls.style = CS_DBLCLKS;
		wndcls.hbrBackground = NULL;
		if (_AfxRegisterWithIcon(&wndcls, _afxWndMDIFrame, AFX_IDI_STD_MDIFRAME))
			fRegisteredClasses |= AFX_WNDMDIFRAME_REG;
	}
	if (fToRegister & AFX_WNDFRAMEORVIEW_REG)
	{
		// SDI Frame or MDI Child windows or views - normal colors
		wndcls.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
		wndcls.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		if (_AfxRegisterWithIcon(&wndcls, _afxWndFrameOrView, AFX_IDI_STD_FRAME))
			fRegisteredClasses |= AFX_WNDFRAMEORVIEW_REG;
	}
	if (fToRegister & AFX_WNDCOMMCTLS_REG)
	{
		// this flag is compatible with the old InitCommonControls() API
		init.dwICC = ICC_WIN95_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WIN95CTLS_MASK);
		fToRegister &= ~AFX_WIN95CTLS_MASK;
	}
	if (fToRegister & AFX_WNDCOMMCTL_UPDOWN_REG)
	{
		init.dwICC = ICC_UPDOWN_CLASS;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_UPDOWN_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_TREEVIEW_REG)
	{
		init.dwICC = ICC_TREEVIEW_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_TREEVIEW_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_TAB_REG)
	{
		init.dwICC = ICC_TAB_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_TAB_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_PROGRESS_REG)
	{
		init.dwICC = ICC_PROGRESS_CLASS;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_PROGRESS_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_LISTVIEW_REG)
	{
		init.dwICC = ICC_LISTVIEW_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_LISTVIEW_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_HOTKEY_REG)
	{
		init.dwICC = ICC_HOTKEY_CLASS;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_HOTKEY_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_BAR_REG)
	{
		init.dwICC = ICC_BAR_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_BAR_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_ANIMATE_REG)
	{
		init.dwICC = ICC_ANIMATE_CLASS;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_ANIMATE_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_INTERNET_REG)
	{
		init.dwICC = ICC_INTERNET_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_INTERNET_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_COOL_REG)
	{
		init.dwICC = ICC_COOL_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_COOL_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_USEREX_REG)
	{
		init.dwICC = ICC_USEREX_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_USEREX_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_DATE_REG)
	{
		init.dwICC = ICC_DATE_CLASSES;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_DATE_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_LINK_REG)
	{
		init.dwICC = ICC_LINK_CLASS;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_LINK_REG);
	}
	if (fToRegister & AFX_WNDCOMMCTL_PAGER_REG)
	{
		init.dwICC = ICC_PAGESCROLLER_CLASS;
		fRegisteredClasses |= _AfxInitCommonControls(&init, AFX_WNDCOMMCTL_PAGER_REG);
	}

	// save new state of registered controls
	pModuleState->m_fRegisteredClasses |= fRegisteredClasses;

	// special case for all common controls registered, turn on AFX_WNDCOMMCTLS_REG
	if ((pModuleState->m_fRegisteredClasses & AFX_WIN95CTLS_MASK) == AFX_WIN95CTLS_MASK)
	{
		pModuleState->m_fRegisteredClasses |= AFX_WNDCOMMCTLS_REG;
		fRegisteredClasses |= AFX_WNDCOMMCTLS_REG;
	}

	// must have registered at least as mamy classes as requested
	return (fToRegister & fRegisteredClasses) == fToRegister;
}

BOOL AFXAPI AfxInitNetworkAddressControl()
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	ENSURE(pModuleState);
	if (pModuleState->m_bInitNetworkAddressControlCalled == FALSE)
	{
		OSVERSIONINFO vi;
		ZeroMemory(&vi, sizeof(OSVERSIONINFO));
		vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		BOOL b = ::GetVersionEx(&vi);
		ENSURE(b);

		// if running under Vista
		if (vi.dwMajorVersion >= 6)
		{
			// Only try to GetProcAddress and call InitNetworkAddressControl if we are vista and higher.
			// If we call this on OS lower than Vista, this will throw.  We don't want it to throw.
			pModuleState->m_bInitNetworkAddressControl = AfxCtxInitNetworkAddressControl();
		}

		pModuleState->m_bInitNetworkAddressControlCalled = TRUE;
	}
	return pModuleState->m_bInitNetworkAddressControl;
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd (here for library granularity)

BOOL CWnd::IsFrameWnd() const
{
	return FALSE;
}

BOOL CFrameWnd::IsFrameWnd() const
{
	return TRUE;
}

BOOL CFrameWnd::IsTracking() const
{
	return m_nIDTracking != 0 &&
		m_nIDTracking != AFX_IDS_HELPMODEMESSAGE &&
		m_nIDTracking != AFX_IDS_IDLEMESSAGE;
}

/////////////////////////////////////////////////////////////////////////////
// Extra CWnd support for dynamic subclassing of controls

BOOL CWnd::SubclassWindow(HWND hWnd)
{
	if (!Attach(hWnd))
		return FALSE;

	// allow any other subclassing to occur
	PreSubclassWindow();

	// now hook into the AFX WndProc
	WNDPROC* lplpfn = GetSuperWndProcAddr();
	WNDPROC oldWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC,
		(INT_PTR)AfxGetAfxWndProc());
	ASSERT(oldWndProc != AfxGetAfxWndProc());

	if (*lplpfn == NULL)
		*lplpfn = oldWndProc;   // the first control of that type created
#ifdef _DEBUG
	else if (*lplpfn != oldWndProc)
	{
		TRACE(traceAppMsg, 0, "Error: Trying to use SubclassWindow with incorrect CWnd\n");
		TRACE(traceAppMsg, 0, "\tderived class.\n");
		TRACE(traceAppMsg, 0, "\thWnd = $%08X (nIDC=$%08X) is not a %hs.\n", (UINT)(UINT_PTR)hWnd,
			_AfxGetDlgCtrlID(hWnd), GetRuntimeClass()->m_lpszClassName);
		ASSERT(FALSE);
		// undo the subclassing if continuing after assert
	  ::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (INT_PTR)oldWndProc);
	}
#endif

	return TRUE;
}

BOOL CWnd::SubclassDlgItem(UINT nID, CWnd* pParent)
{
	ASSERT(pParent != NULL);
	ASSERT(::IsWindow(pParent->m_hWnd));

	// check for normal dialog control first
	HWND hWndControl = ::GetDlgItem(pParent->m_hWnd, nID);
	if (hWndControl != NULL)
		return SubclassWindow(hWndControl);

#ifndef _AFX_NO_OCC_SUPPORT
	if (pParent->m_pCtrlCont != NULL)
	{
		// normal dialog control not found
		COleControlSite* pSite = pParent->m_pCtrlCont->FindItem(nID);
		if (pSite != NULL)
		{
			ASSERT(pSite->m_hWnd != NULL);
			VERIFY(SubclassWindow(pSite->m_hWnd));

#ifndef _AFX_NO_OCC_SUPPORT
			// If the control has reparented itself (e.g., invisible control),
			// make sure that the CWnd gets properly wired to its control site.
			if (pParent->m_hWnd != ::GetParent(pSite->m_hWnd))
				AttachControlSite(pParent);
#endif //!_AFX_NO_OCC_SUPPORT

			return TRUE;
		}
	}
#endif

	return FALSE;   // control not found
}

HWND CWnd::UnsubclassWindow()
{
	ASSERT(::IsWindow(m_hWnd));

	// set WNDPROC back to original value
	WNDPROC* lplpfn = GetSuperWndProcAddr();
	SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (INT_PTR)*lplpfn);
	*lplpfn = NULL;

	// and Detach the HWND from the CWnd object
	return Detach();
}

BOOL CWnd::CreateControlContainer(COleControlContainer** ppContainer)
{
   ENSURE_ARG( ppContainer != NULL );
   *ppContainer = NULL;  // Use the default container

   return TRUE;
}

BOOL CWnd::CreateControlSite(COleControlContainer*, 
   COleControlSite** ppSite, UINT /* nID */, REFCLSID /* clsid */)
{
   ENSURE_ARG( ppSite != NULL );
   *ppSite = NULL;  // Use the default site

   return TRUE;
}

COleControlContainer* CWnd::GetControlContainer()
{
	return m_pCtrlCont;
}

/////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNCREATE(CWnd, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CGestureConfig functions

CGestureConfig::CGestureConfig()
{
	m_nConfigs = GID_PRESSANDTAP - GID_ZOOM + 1;
	m_pConfigs = new GESTURECONFIG[m_nConfigs];

	// Enable all gesture features by default:
	for (int i = 0; i < m_nConfigs; i++)
	{
		m_pConfigs[i].dwID = GID_ZOOM + i;
		m_pConfigs[i].dwWant = GC_ALLGESTURES;
		m_pConfigs[i].dwBlock = 0;
	}

	// Disable rotate:
	EnableRotate(FALSE);

	// By default Pan supports Gutter, Inertia only and Single Finger Vertically:
	EnablePan(TRUE,  GC_PAN_WITH_GUTTER | GC_PAN_WITH_INERTIA | GC_PAN_WITH_SINGLE_FINGER_VERTICALLY);
}

CGestureConfig::~CGestureConfig()
{
	delete[] m_pConfigs;
}

#ifdef _DEBUG
void CGestureConfig::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	for (int i = 0; i < m_nConfigs; i++)
	{
		dc << m_pConfigs[i].dwID;
		dc << _T(" Want: ");
		dc << m_pConfigs[i].dwWant;
		dc << _T(" Block: ");
		dc << m_pConfigs[i].dwBlock;
		dc << _T("\n");
	}
}
#endif

BOOL CGestureConfig::Modify(DWORD dwID, DWORD dwWant, DWORD dwBlock)
{
	ASSERT_VALID(this);

	ASSERT((dwWant & dwBlock) == 0);	// Should be exclusive!

	for (int i = 0; i < m_nConfigs; i++)
	{
		if (m_pConfigs[i].dwID == dwID)
		{
			m_pConfigs[i].dwWant |= dwWant;
			m_pConfigs[i].dwBlock |= dwBlock;

			// Clean-up dwWant from block and dwBlock from want:
			m_pConfigs[i].dwWant &= ((~dwBlock) & (DWORD)-1);
			m_pConfigs[i].dwBlock &= ((~dwWant) & (DWORD)-1);

			return TRUE;
		}
	}

	// Unknown or unsupported ID
	ASSERT(FALSE);
	return FALSE;
}

DWORD CGestureConfig::Get(DWORD dwID, BOOL bWant) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_nConfigs; i++)
	{
		if (m_pConfigs[i].dwID == dwID)
		{
			return bWant ? m_pConfigs[i].dwWant : m_pConfigs[i].dwBlock;
		}
	}

	// Unknown or unsupported ID
	ASSERT(FALSE);
	return (UINT)-1;
}

void CGestureConfig::EnableZoom(BOOL bEnable)
{
	Modify(GID_ZOOM, bEnable ? GC_ZOOM : 0, bEnable ? 0 : GC_ZOOM);
}

void CGestureConfig::EnableRotate(BOOL bEnable)
{
	Modify(GID_ROTATE, bEnable ? GC_ROTATE : 0, bEnable ? 0 : GC_ROTATE);
}

void CGestureConfig::EnableTwoFingerTap(BOOL bEnable)
{
	Modify(GID_TWOFINGERTAP, bEnable ? GC_TWOFINGERTAP : 0, bEnable ? 0 : GC_TWOFINGERTAP);
}

void CGestureConfig::EnablePressAndTap(BOOL bEnable)
{
	Modify(GID_PRESSANDTAP, bEnable ? GC_PRESSANDTAP : 0, bEnable ? 0 : GC_PRESSANDTAP);
}

void CGestureConfig::EnablePan(BOOL bEnable, DWORD dwFlags)
{
	if (!bEnable)
	{
		Modify(GID_PAN, 0, GC_PAN);	// Disable all pan features
		return;
	}

	DWORD dwWant = GC_PAN;
	DWORD dwBlock = 0;

	DWORD dwAllFlags[] = { GC_PAN_WITH_SINGLE_FINGER_VERTICALLY, GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY, GC_PAN_WITH_GUTTER, GC_PAN_WITH_INERTIA };

	for (int i = 0; i < sizeof(dwAllFlags) / sizeof(DWORD); i++)
	{
		if ((dwFlags & dwAllFlags[i]) == dwAllFlags[i])
		{
			dwWant |= dwAllFlags[i];
		}
		else
		{
			dwBlock |= dwAllFlags[i];
		}
	}

	Modify(GID_PAN, dwWant, dwBlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winctrl6.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"

/////////////////////////////////////////////////////////////////////////////
// CIPAddressCtrl


CIPAddressCtrl::~CIPAddressCtrl()
{
	DestroyWindow();
}

BOOL CIPAddressCtrl::Create(DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_INTERNET_REG));

	// the IP Address Control must be a child
	ASSERT(dwStyle & WS_CHILD);

	CWnd* pWnd = this;
	return pWnd->Create(WC_IPADDRESS, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CIPAddressCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle,
	const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

int CIPAddressCtrl::GetAddress(BYTE& nField0, BYTE& nField1, BYTE& nField2, BYTE& nField3) const
{
	ASSERT(::IsWindow(m_hWnd));
	DWORD dwAddress;
	LRESULT nRetVal = ::SendMessage(m_hWnd, IPM_GETADDRESS, 0, (LPARAM) &dwAddress);

	nField0 = (BYTE) FIRST_IPADDRESS(dwAddress);
	nField1 = (BYTE) SECOND_IPADDRESS(dwAddress);
	nField2 = (BYTE) THIRD_IPADDRESS(dwAddress);
	nField3 = (BYTE) FOURTH_IPADDRESS(dwAddress);

	return int(nRetVal);
}

/////////////////////////////////////////////////////////////////////////////
// CComboBoxEx


BOOL CComboBoxEx::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_USEREX_REG));

	CWnd* pWnd = this;
	return pWnd->Create(WC_COMBOBOXEX, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CComboBoxEx::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

int CComboBoxEx::DeleteItem(int iIndex)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int) ::SendMessage(m_hWnd, CBEM_DELETEITEM, (WPARAM) iIndex, 0);
}

BOOL CComboBoxEx::GetItem(COMBOBOXEXITEM* pCBItem)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pCBItem != NULL);
	ASSERT(AfxIsValidAddress(pCBItem, sizeof(COMBOBOXEXITEM)));

	return (int) ::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM) pCBItem);
}

int CComboBoxEx::InsertItem(const COMBOBOXEXITEM* pCBItem)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pCBItem != NULL);
	ASSERT(AfxIsValidAddress(pCBItem, sizeof(COMBOBOXEXITEM), FALSE));

	return (int) ::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM) pCBItem);
}

BOOL CComboBoxEx::SetItem(const COMBOBOXEXITEM* pCBItem)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pCBItem != NULL);
	ASSERT(AfxIsValidAddress(pCBItem, sizeof(COMBOBOXEXITEM), FALSE));

	return (int) ::SendMessage(m_hWnd, CBEM_SETITEM, 0, (LPARAM) pCBItem);
}

CComboBoxEx::~CComboBoxEx()
{
	DestroyWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CReBarCtrl

CReBarCtrl::~CReBarCtrl()
{
	DestroyWindow();
}

BOOL CReBarCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_COOL_REG));

	CWnd* pWnd = this;
	return pWnd->Create(REBARCLASSNAME, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CReBarCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

CImageList* CReBarCtrl::GetImageList() const
{
	REBARINFO rbi;
	rbi.cbSize = sizeof(rbi);
	rbi.fMask = RBIM_IMAGELIST;
	return GetBarInfo(&rbi) ? CImageList::FromHandle(rbi.himl) : NULL;
}

BOOL CReBarCtrl::SetImageList(CImageList* pImageList)
{
	REBARINFO rbi;
	rbi.cbSize = sizeof(rbi);
	rbi.fMask = RBIM_IMAGELIST;
	rbi.himl = (HIMAGELIST)pImageList->GetSafeHandle();
	return SetBarInfo(&rbi);
}

BOOL CReBarCtrl::GetColorScheme(COLORSCHEME* lpcs) const
{
	lpcs->dwSize = ULONG(sizeof(COLORSCHEME));
	return (::SendMessage(m_hWnd, RB_GETCOLORSCHEME, 0, (LPARAM)lpcs) != 0);
}

void CReBarCtrl::SetColorScheme(const COLORSCHEME* lpcs)
{
	((COLORSCHEME*)lpcs)->dwSize = sizeof(COLORSCHEME);
	SendMessage(RB_SETCOLORSCHEME, 0, (LPARAM)lpcs);
}

/////////////////////////////////////////////////////////////////////////////
// CListCtrl

BOOL CListCtrl::SetColumnOrderArray(int iCount, LPINT piArray)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(AfxIsValidAddress(piArray, iCount * sizeof(int), FALSE));

	return (BOOL) ::SendMessage(m_hWnd, LVM_SETCOLUMNORDERARRAY,
					(WPARAM) iCount, (LPARAM) piArray);
}

BOOL CListCtrl::GetColumnOrderArray(LPINT piArray, int iCount /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));

	// if -1 was passed, find the count ourselves

	int nCount = iCount;
	if (nCount == -1)
	{
		CHeaderCtrl* pCtrl = GetHeaderCtrl();
		ASSERT(pCtrl != NULL);
		if (pCtrl != NULL)
			nCount = pCtrl->GetItemCount();
	}
	if (nCount == -1)
		return FALSE;

	ASSERT(AfxIsValidAddress(piArray, nCount * sizeof(int)));
	return (BOOL) ::SendMessage(m_hWnd, LVM_GETCOLUMNORDERARRAY,
		(WPARAM) nCount, (LPARAM) piArray);
}

BOOL CListCtrl::SetBkImage(HBITMAP hbm, BOOL fTile /*= TRUE*/, int xOffsetPercent /*= 0*/, int yOffsetPercent /*= 0*/)
{
	LVBKIMAGE lv;

	lv.ulFlags = LVBKIF_SOURCE_HBITMAP;
	if( fTile )
		lv.ulFlags |= LVBKIF_STYLE_TILE;
	else
		lv.ulFlags |= LVBKIF_STYLE_NORMAL;
	lv.hbm = hbm;
	lv.xOffsetPercent = xOffsetPercent;
	lv.yOffsetPercent = yOffsetPercent;
	return SetBkImage(&lv);
}

BOOL CListCtrl::SetBkImage(_In_z_ LPTSTR pszUrl, _In_ BOOL fTile /*= TRUE*/, _In_ int xOffsetPercent /*= 0*/, _In_ int yOffsetPercent /*= 0*/)
{
	LVBKIMAGE lv;

	lv.ulFlags = LVBKIF_SOURCE_URL;
	if( fTile )
		lv.ulFlags |= LVBKIF_STYLE_TILE;
	else
		lv.ulFlags |= LVBKIF_STYLE_NORMAL;
	lv.pszImage = pszUrl;
	lv.xOffsetPercent = xOffsetPercent;
	lv.yOffsetPercent = yOffsetPercent;
	return SetBkImage(&lv);
}

BOOL CListCtrl::GetCheck(int nItem) const
{
	ASSERT(::IsWindow(m_hWnd));
	int nState = (int)::SendMessage(m_hWnd, LVM_GETITEMSTATE, (WPARAM)nItem,
		(LPARAM)LVIS_STATEIMAGEMASK);
	// Return zero if it's not checked, or nonzero otherwise.
	return ((BOOL)(nState >> 12) -1);
}

BOOL CListCtrl::SetCheck(int nItem, BOOL fCheck)
{
	ASSERT(::IsWindow(m_hWnd));
	LVITEM lvi;
	lvi.stateMask = LVIS_STATEIMAGEMASK;

	/*
	Since state images are one-based, 1 in this macro turns the check off, and
	2 turns it on.
	*/
	lvi.state = INDEXTOSTATEIMAGEMASK((fCheck ? 2 : 1));
	return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)&lvi);
}

/////////////////////////////////////////////////////////////////////////////
// CHeaderCtrl

CHeaderCtrl* CListCtrl::GetHeaderCtrl() const
{
	ASSERT(::IsWindow(m_hWnd));

	HWND hWnd = (HWND) ::SendMessage(m_hWnd, LVM_GETHEADER, 0, 0);
	if (hWnd == NULL)
		return NULL;
	else
		return (CHeaderCtrl*) CHeaderCtrl::FromHandle(hWnd);
}


BOOL CHeaderCtrl::SetOrderArray(int iCount, LPINT piArray)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(AfxIsValidAddress(piArray, iCount * sizeof(int), FALSE));

	return (BOOL) ::SendMessage(m_hWnd, HDM_SETORDERARRAY,
					(WPARAM) iCount, (LPARAM) piArray);
}

BOOL CHeaderCtrl::GetOrderArray(LPINT piArray, int iCount) const
{
	ASSERT(::IsWindow(m_hWnd));

	// This method no longer has a default value for iCount
	// if -1 was passed, we ASSERT & fail

	int nCount = iCount;
	if (nCount < 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT(AfxIsValidAddress(piArray, iCount * sizeof(int)));

	return (BOOL) ::SendMessage(m_hWnd, HDM_GETORDERARRAY,
		(WPARAM) nCount, (LPARAM) piArray);
}

/////////////////////////////////////////////////////////////////////////////
// CProgressCtrl

void CProgressCtrl::GetRange(int& nLower, int& nUpper) const
{
	ASSERT(::IsWindow(m_hWnd));
	PBRANGE range;
	::SendMessage(m_hWnd, PBM_GETRANGE, (WPARAM) FALSE, (LPARAM) &range);
	nLower = range.iLow;
	nUpper = range.iHigh;
	return;
}

/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

BOOL CPagerCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	ENSURE(AfxDeferRegisterClass(AFX_WNDCOMMCTL_PAGER_REG));

	CWnd* pWnd = this;
	return pWnd->Create(WC_PAGESCROLLER, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CPagerCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

#if (_WIN32_WINNT >= 0x0501)

/////////////////////////////////////////////////////////////////////////////
// CLinkCtrl

BOOL CLinkCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	// initialize common controls
	ENSURE(AfxDeferRegisterClass(AFX_WNDCOMMCTL_LINK_REG));

#ifndef _UNICODE
	ASSERT(0);
	dwStyle;
	rect;
	pParentWnd;
	nID;
	// Can only be used in UNICODE builds
	return FALSE;
#else
	CWnd* pWnd = this;
	return pWnd->Create(WC_LINK, NULL, dwStyle, rect, pParentWnd, nID);
#endif	// _UNICODE
}

BOOL CLinkCtrl::Create(LPCTSTR lpszLinkMarkup, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	// initialize common controls
	ENSURE(AfxDeferRegisterClass(AFX_WNDCOMMCTL_LINK_REG));

#ifndef _UNICODE
	ASSERT(0);
	lpszLinkMarkup;
	dwStyle;
	rect;
	pParentWnd;
	nID;
	// Can only be used in UNICODE builds
	return FALSE;
#else
	CWnd* pWnd = this;
	return pWnd->Create(WC_LINK, lpszLinkMarkup, dwStyle, rect, pParentWnd, nID);
#endif	// _UNICODE
}

BOOL CLinkCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

BOOL CLinkCtrl::CreateEx(LPCTSTR lpszLinkMarkup, DWORD dwExStyle, DWORD dwStyle,
	const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(lpszLinkMarkup, dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CNetAddressCtrl

BOOL CNetAddressCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
#ifndef _UNICODE
	ASSERT(0);
	dwStyle;
	rect;
	pParentWnd;
	nID;
	// Can only be used in UNICODE builds
	return FALSE;
#else
	// initialize common controls
	ENSURE(AfxInitNetworkAddressControl());

	CWnd* pWnd = this;
	return pWnd->Create(WC_NETADDRESS, NULL, dwStyle, rect, pParentWnd, nID);
#endif	// _UNICODE
}

BOOL CNetAddressCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_ENABLE_INLINES

#define _AFXCMN_INLINE
#include "afxcmn2.inl"

#endif //_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(CIPAddressCtrl, CWnd)
IMPLEMENT_DYNAMIC(CReBarCtrl, CWnd)
IMPLEMENT_DYNAMIC(CPagerCtrl, CWnd)

#if (_WIN32_WINNT >= 0x0501)
IMPLEMENT_DYNAMIC(CLinkCtrl, CWnd)
#endif	// _WIN32_WINNT >= 0x0501

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
IMPLEMENT_DYNAMIC(CNetAddressCtrl, CEdit)
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winctrl4.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

#ifndef _AFX_NO_RICHEDIT_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// _AFX_RICHEDIT_STATE

_AFX_RICHEDIT_STATE::~_AFX_RICHEDIT_STATE()
{
	if (m_hInstRichEdit != NULL)
		::FreeLibrary(m_hInstRichEdit);
	if (m_hInstRichEdit2 != NULL)
		::FreeLibrary(m_hInstRichEdit2);
}

_AFX_RICHEDIT_STATE* AFX_CDECL AfxGetRichEditState()
{
	return _afxRichEditState.GetData();
}

BOOL PASCAL AfxInitRichEdit()
{
	_AFX_RICHEDIT_STATE* pState = _afxRichEditState;
	if (pState->m_hInstRichEdit == NULL)
		pState->m_hInstRichEdit = AfxCtxLoadLibraryW(L"RICHED32.DLL");
	return pState->m_hInstRichEdit != NULL;
}

BOOL PASCAL AfxInitRichEdit2()
{
	_AFX_RICHEDIT_STATE* pState = _afxRichEditState;
	if (pState->m_hInstRichEdit2 == NULL)
		pState->m_hInstRichEdit2 = AfxCtxLoadLibraryW(L"RICHED20.DLL");
	return pState->m_hInstRichEdit2 != NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit

BOOL CRichEditCtrl::Create(DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	if (!AfxInitRichEdit2())
		return FALSE;

	CWnd* pWnd = this;
	return pWnd->Create(RICHEDIT_CLASS, NULL, dwStyle, rect,
		pParentWnd, nID);
}

BOOL CRichEditCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle,
	const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	BOOL bRet = Create(dwStyle, rect, pParentWnd, nID);
	if (bRet && dwExStyle != 0)
	{
		bRet = ModifyStyleEx(0, dwExStyle);
	}
	return bRet;
}

int CRichEditCtrl::GetLine(_In_ int nIndex, _Pre_notnull_ _Post_z_ LPTSTR lpszBuffer) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex,
		(LPARAM)lpszBuffer);
}

int CRichEditCtrl::LineIndex(int nLine /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0);
}

int CRichEditCtrl::LineLength(int nLine /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0);
}

void CRichEditCtrl::LineScroll(int nLines, int nChars /* = 0 */)
{
	ASSERT(::IsWindow(m_hWnd));
	::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
}

void CRichEditCtrl::SetSel(long nStartChar, long nEndChar)
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	cr.cpMin = nStartChar;
	cr.cpMax = nEndChar;
	::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
}

BOOL CRichEditCtrl::CanPaste(UINT nFormat) const
{
	ASSERT(::IsWindow(m_hWnd));
	COleMessageFilter* pFilter = AfxOleGetMessageFilter();
	if (pFilter != NULL)
		pFilter->BeginBusyState();
	BOOL b = (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, nFormat, 0L);
	if (pFilter != NULL)
		pFilter->EndBusyState();
	return b;
}

void CRichEditCtrl::PasteSpecial(UINT nClipFormat, DWORD dvAspect, HMETAFILE hMF)
{
	ASSERT(::IsWindow(m_hWnd));
	REPASTESPECIAL reps;
	reps.dwAspect = dvAspect;
	reps.dwParam = (DWORD_PTR)hMF;
	::SendMessage(m_hWnd, EM_PASTESPECIAL, nClipFormat, (LPARAM)&reps);
}

int CRichEditCtrl::GetLine(_In_ int nIndex, _Out_cap_post_count_(nMaxLength, return) LPTSTR lpszBuffer, _In_ int nMaxLength) const
{
	ASSERT(::IsWindow(m_hWnd));
	ENSURE(sizeof(nMaxLength)<=nMaxLength*sizeof(TCHAR)&&nMaxLength>0);
	*(LPINT)lpszBuffer = nMaxLength;
	return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
}

void CRichEditCtrl::GetSel(long& nStartChar, long& nEndChar) const
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
	nStartChar = cr.cpMin;
	nEndChar = cr.cpMax;
}

CString CRichEditCtrl::GetSelText() const
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	cr.cpMin = cr.cpMax = 0;
	::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
	CString strText;
	LPTSTR lpsz=strText.GetBufferSetLength((cr.cpMax - cr.cpMin + 1) * 2);
	lpsz[0] = NULL;
	::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpsz);
	strText.ReleaseBuffer();
	return CString(strText);
}

IRichEditOle* CRichEditCtrl::GetIRichEditOle() const
{
	ASSERT(::IsWindow(m_hWnd));
	IRichEditOle *pRichItem = NULL;
	::SendMessage(m_hWnd, EM_GETOLEINTERFACE, 0, (LPARAM)&pRichItem);
	return pRichItem;
}

long CRichEditCtrl::GetTextLengthEx(DWORD dwFlags,
	UINT nCodePage /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	GETTEXTLENGTHEX textLenEx;
	textLenEx.flags = dwFlags;

	if (nCodePage == -1)
	{
#ifdef _UNICODE
		// UNICODE code page
		textLenEx.codepage = 1200;
#else
		// default code page
		textLenEx.codepage = CP_ACP;
#endif
	}
	else
		// otherwise, use the code page specified
		textLenEx.codepage = nCodePage;

	return (long) ::SendMessage(m_hWnd, EM_GETTEXTLENGTHEX,
		(WPARAM) &textLenEx, 0);
}

int CRichEditCtrl::GetTextRange(int nFirst, int nLast,
	CString& refString) const
{
	ASSERT(::IsWindow(m_hWnd));

	TEXTRANGE textRange;
	textRange.chrg.cpMin = nFirst;
	textRange.chrg.cpMax = nLast;

	// can't be backwards
	int nLength = int(nLast - nFirst + 1);
	ASSERT(nLength > 0);

	textRange.lpstrText = refString.GetBuffer(nLength);
	nLength = (int)::SendMessage(m_hWnd, EM_GETTEXTRANGE, 0, (LPARAM) &textRange);
	refString.ReleaseBuffer(nLength);

	return (int)nLength;
}

BOOL CRichEditCtrl::SetDefaultCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
}

BOOL CRichEditCtrl::SetDefaultCharFormat(CHARFORMAT2 &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT2);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
}

BOOL CRichEditCtrl::SetSelectionCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
}

BOOL CRichEditCtrl::SetSelectionCharFormat(CHARFORMAT2 &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT2);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
}

BOOL CRichEditCtrl::SetWordCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION|SCF_WORD, (LPARAM)&cf);
}

BOOL CRichEditCtrl::SetWordCharFormat(CHARFORMAT2 &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT2);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION|SCF_WORD, (LPARAM)&cf);
}

DWORD CRichEditCtrl::GetDefaultCharFormat(CHARFORMAT &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
}

DWORD CRichEditCtrl::GetDefaultCharFormat(CHARFORMAT2 &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT2);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
}

DWORD CRichEditCtrl::GetSelectionCharFormat(CHARFORMAT &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
}

DWORD CRichEditCtrl::GetSelectionCharFormat(CHARFORMAT2 &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT2);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
}

DWORD CRichEditCtrl::GetParaFormat(PARAFORMAT &pf) const
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
}

DWORD CRichEditCtrl::GetParaFormat(PARAFORMAT2 &pf) const
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT2);
	return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
}

BOOL CRichEditCtrl::SetParaFormat(PARAFORMAT &pf)
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
}

BOOL CRichEditCtrl::SetParaFormat(PARAFORMAT2 &pf)
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT2);
	return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
}
#endif //!_AFX_NO_RICHEDIT_SUPPORT

/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable: 4074)
#pragma init_seg(user)

#ifndef _AFX_NO_RICHEDIT_SUPPORT
AFX_DATADEF PROCESS_LOCAL(_AFX_RICHEDIT_STATE, _afxRichEditState)
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winctrl7.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CImageList

BOOL CImageList::DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)
{
	ASSERT(m_hImageList != NULL);
	ASSERT_POINTER(pimldp, IMAGELISTDRAWPARAMS);

	DWORD dwMajor = 0, dwMinor = 0;
	AtlGetCommCtrlVersion(&dwMajor, &dwMinor);
	if (dwMajor < 6)
	{
		pimldp->cbSize = IMAGELISTDRAWPARAMS_V3_SIZE;
	}
	pimldp->himl = m_hImageList;
	return AfxImageList_DrawIndirect(pimldp);
}

BOOL CImageList::DrawIndirect(CDC* pDC, int nImage, POINT pt,
		SIZE sz, POINT ptOrigin, UINT fStyle /* = ILD_NORMAL */,
		DWORD dwRop /* = SRCCOPY */, COLORREF rgbBack /* = CLR_DEFAULT */,
		COLORREF rgbFore /* = CLR_DEFAULT */,
		DWORD fState /*= ILS_NORMAL*/, DWORD Frame /*= ILS_PULSE*/, COLORREF crEffect /*= CLR_DEFAULT*/)
{
	ASSERT_POINTER(pDC, CDC);
	ASSERT(pDC->m_hDC != NULL);

	IMAGELISTDRAWPARAMS drawing;

	drawing.i = nImage;
	drawing.hdcDst = pDC->m_hDC;
	drawing.x = pt.x;
	drawing.y = pt.y;
	drawing.cx = sz.cx;
	drawing.cy = sz.cy;
	drawing.xBitmap = ptOrigin.x;
	drawing.yBitmap = ptOrigin.y;
	drawing.rgbBk = rgbBack;
	drawing.rgbFg = rgbFore;
	drawing.fStyle = fStyle;
	drawing.dwRop = dwRop;
	drawing.fState = fState;
	drawing.Frame = Frame;
	drawing.crEffect = crEffect;

	// this call initializes cbSize and himl;
	return DrawIndirect(&drawing);
}

BOOL CImageList::Create(CImageList* pImageList)
{
	ASSERT(pImageList != NULL);
	return Attach(AfxImageList_Duplicate(pImageList->m_hImageList));
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winctrl8.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winfrm2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

// dwDockBarMap
const DWORD CFrameWnd::dwDockBarMap[4][2] =
{
	{ AFX_IDW_DOCKBAR_TOP,      CBRS_TOP    },
	{ AFX_IDW_DOCKBAR_BOTTOM,   CBRS_BOTTOM },
	{ AFX_IDW_DOCKBAR_LEFT,     CBRS_LEFT   },
	{ AFX_IDW_DOCKBAR_RIGHT,    CBRS_RIGHT  },
};

/////////////////////////////////////////////////////////////////////////////
// Dockable control bar helpers

CMiniDockFrameWnd* CFrameWnd::CreateFloatingFrame(DWORD dwStyle)
{
	CMiniDockFrameWnd* pFrame = NULL;
	ASSERT(m_pFloatingFrameClass != NULL);
	pFrame = (CMiniDockFrameWnd*)m_pFloatingFrameClass->CreateObject();
	if (pFrame == NULL)
		AfxThrowMemoryException();
	ASSERT_KINDOF(CMiniDockFrameWnd, pFrame);
	if (!pFrame->Create(this, dwStyle))
		AfxThrowResourceException();
	return pFrame;
}

// dock bars will be created in the order specified by dwDockBarMap
// this also controls which gets priority during layout
// this order can be changed by calling EnableDocking repetitively
// with the exact order of priority
void CFrameWnd::EnableDocking(DWORD dwDockStyle)
{
	// must be CBRS_ALIGN_XXX or CBRS_FLOAT_MULTI only
	ASSERT((dwDockStyle & ~(CBRS_ALIGN_ANY|CBRS_FLOAT_MULTI)) == 0);

	m_pFloatingFrameClass = RUNTIME_CLASS(CMiniDockFrameWnd);
	for (int i = 0; i < 4; i++)
	{
		if (dwDockBarMap[i][1] & dwDockStyle & CBRS_ALIGN_ANY)
		{
			CDockBar* pDock = (CDockBar*)GetControlBar(dwDockBarMap[i][0]);
			if (pDock == NULL)
			{
				pDock = new CDockBar;
				if (!pDock->Create(this,
					WS_CLIPSIBLINGS|WS_CLIPCHILDREN|WS_CHILD|WS_VISIBLE |
						dwDockBarMap[i][1], dwDockBarMap[i][0]))
				{
					AfxThrowResourceException();
				}
			}
		}
	}
}

void CFrameWnd::DockControlBar(CControlBar* pBar, UINT nDockBarID, LPCRECT lpRect)
{
	CDockBar* pDockBar = (nDockBarID == 0) ? NULL :
		(CDockBar*)GetControlBar(nDockBarID);
	DockControlBar(pBar, pDockBar, lpRect);
}

void CFrameWnd::DockControlBar(CControlBar* pBar, CDockBar* pDockBar, LPCRECT lpRect)
{
	ENSURE_ARG(pBar != NULL);
	// make sure CControlBar::EnableDocking has been called
	ASSERT(pBar->m_pDockContext != NULL);

	if (pDockBar == NULL)
	{
		for (int i = 0; i < 4; i++)
		{
			if ((dwDockBarMap[i][1] & CBRS_ALIGN_ANY) ==
				(pBar->m_dwStyle & CBRS_ALIGN_ANY))
			{
				pDockBar = (CDockBar*)GetControlBar(dwDockBarMap[i][0]);
				ASSERT(pDockBar != NULL);
				// assert fails when initial CBRS_ of bar does not
				// match available docking sites, as set by EnableDocking()
				break;
			}
		}
	}
	ENSURE_ARG(pDockBar != NULL);
	ASSERT(m_listControlBars.Find(pBar) != NULL);
	ASSERT(pBar->m_pDockSite == this);
	// if this assertion occurred it is because the parent of pBar was not initially
	// this CFrameWnd when pBar's OnCreate was called
	// i.e. this control bar should have been created with a different parent initially

	pDockBar->DockControlBar(pBar, lpRect);
}

void CFrameWnd::ReDockControlBar(CControlBar* pBar, CDockBar* pDockBar, LPCRECT lpRect)
{
	ENSURE_ARG(pBar != NULL);
	// make sure CControlBar::EnableDocking has been called
	ASSERT(pBar->m_pDockContext != NULL);

	if (pDockBar == NULL)
	{
		// Search for the place holder.

		// In case we don't find a place holder, find a bar with the correct alignment
		// and keep it in pPossibleBar.
		CDockBar* pPossibleBar = NULL;
		for (int i = 0; i < 4; i++)
		{
			CDockBar* pTempBar = (CDockBar*)GetControlBar(dwDockBarMap[i][0]);
			if (pTempBar != NULL)
			{
				// Is this the same bar we docked with before?
				if (pTempBar->FindBar((CControlBar*)(DWORD_PTR)_AfxGetDlgCtrlID(pBar->m_hWnd)) > 0)
				{
					pDockBar = pTempBar;
					break;
				}
			}

			if ((dwDockBarMap[i][1] & CBRS_ALIGN_ANY) ==
				(pBar->m_dwStyle & CBRS_ALIGN_ANY))
			{
				pPossibleBar = (CDockBar*)GetControlBar(dwDockBarMap[i][0]);
				ASSERT(pPossibleBar != NULL);
				// assert fails when initial CBRS_ of bar does not
				// match available docking sites, as set by EnableDocking()
			}
		}

		// Did we find the place holder?
		if (pDockBar == NULL)
			pDockBar = pPossibleBar;
	}
	ENSURE_ARG(pDockBar != NULL);
	ASSERT(m_listControlBars.Find(pBar) != NULL);
	ASSERT(pBar->m_pDockSite == this);
	// if this assertion occurred it is because the parent of pBar was not initially
	// this CFrameWnd when pBar's OnCreate was called
	// i.e. this control bar should have been created with a different parent initially

	pDockBar->ReDockControlBar(pBar, lpRect);
}

void CFrameWnd::FloatControlBar(CControlBar* pBar, CPoint point, DWORD dwStyle)
{
	ENSURE_ARG(pBar != NULL);

	// if the bar is already floating and the dock bar only contains this
	// bar and same orientation then move the window rather than recreating
	// the frame
	if (pBar->m_pDockSite != NULL && pBar->m_pDockBar != NULL)
	{
		CDockBar* pDockBar = pBar->m_pDockBar;
		ASSERT_KINDOF(CDockBar, pDockBar);
		if (pDockBar->m_bFloating && pDockBar->GetDockedCount() == 1 &&
			(dwStyle & pDockBar->m_dwStyle & CBRS_ALIGN_ANY) != 0)
		{
			CMiniDockFrameWnd* pDockFrame =
				(CMiniDockFrameWnd*)pDockBar->GetParent();
			ENSURE(pDockFrame != NULL);
			ASSERT_KINDOF(CMiniDockFrameWnd, pDockFrame);
			pDockFrame->SetWindowPos(NULL, point.x, point.y, 0, 0,
				SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
			pDockFrame->RecalcLayout(TRUE);
			pDockFrame->UpdateWindow();
			return;
		}
	}

	if (pBar->m_dwStyle & CBRS_SIZE_DYNAMIC)
	{
		dwStyle |= CBRS_SIZE_DYNAMIC;
		if (dwStyle & CBRS_ORIENT_VERT)
		{
			dwStyle &= ~CBRS_ALIGN_ANY;
			dwStyle |= CBRS_ALIGN_TOP;
		}
	}

	CMiniDockFrameWnd* pDockFrame = CreateFloatingFrame(dwStyle);
	ENSURE_ARG(pDockFrame != NULL);
	pDockFrame->SetWindowPos(NULL, point.x, point.y, 0, 0,
		SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
	if (pDockFrame->m_hWndOwner == NULL)
		pDockFrame->m_hWndOwner = pBar->m_hWnd;

	CDockBar* pDockBar = (CDockBar*)pDockFrame->GetDlgItem(AFX_IDW_DOCKBAR_FLOAT);
	ENSURE_ARG(pDockBar != NULL);
	ASSERT_KINDOF(CDockBar, pDockBar);

	ASSERT(pBar->m_pDockSite == this);
	// if this assertion occurred it is because the parent of pBar was not
	//  initially this CFrameWnd when pBar's OnCreate was called
	// (this control bar should have been created with a different
	//  parent initially)

	pDockBar->DockControlBar(pBar);
	pDockFrame->RecalcLayout(TRUE);
	if (GetWindowLong(pBar->m_hWnd, GWL_STYLE) & WS_VISIBLE)
	{
		pDockFrame->ShowWindow(SW_SHOWNA);
		pDockFrame->UpdateWindow();
	}
}

DWORD CFrameWnd::CanDock(CRect rect, DWORD dwDockStyle, CDockBar** ppDockBar)
{
	// dwDockStyle -- allowable styles of bar
	// don't allow to dock to floating unless multi is specified
	dwDockStyle &= CBRS_ALIGN_ANY|CBRS_FLOAT_MULTI;

	if (ppDockBar != NULL)
		*ppDockBar = NULL;
	POSITION pos = m_listControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		CDockBar* pDockBar = (CDockBar*)m_listControlBars.GetNext(pos);
		if (pDockBar->IsDockBar() && pDockBar->IsWindowVisible() &&
			(pDockBar->m_dwStyle & dwDockStyle & CBRS_ALIGN_ANY) &&
			(!pDockBar->m_bFloating ||
				(dwDockStyle & pDockBar->m_dwStyle & CBRS_FLOAT_MULTI)))
		{
			CRect rectBar;
			pDockBar->GetWindowRect(&rectBar);
			if (rectBar.Width() == 0)
				rectBar.right++;
			if (rectBar.Height() == 0)
				rectBar.bottom++;
			if (rectBar.IntersectRect(rectBar, rect))
			{
				if (ppDockBar != NULL)
					*ppDockBar = pDockBar;
				return pDockBar->m_dwStyle & dwDockStyle;
			}
		}
	}
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winfrmx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Basic Help support

void CWnd::OnHelp()  // use context to derive help context
{
	// attempt to get help from whoever is tracking
	HWND hWnd = ::GetCapture();
	while (hWnd != NULL)
	{
		// attempt to process help
		if (::SendMessage(hWnd, WM_COMMANDHELP, 0, 0))
			return;

		// check next parent/owner in the parent/owner chain
		hWnd = AfxGetParentOwner(hWnd);
	}
	// attempt to get help from whoever has the focus
	hWnd = ::GetFocus();
	while (hWnd != NULL)
	{
		// attempt to process help
		if (::SendMessage(hWnd, WM_COMMANDHELP, 0, 0))
			return;

		// check next parent/owner in the parent/owner chain
		hWnd = AfxGetParentOwner(hWnd);
	}
	// attempt to get help from the active window
	CWnd* pWnd = EnsureTopLevelParent();
	hWnd = ::GetLastActivePopup(pWnd->GetSafeHwnd());
	while (hWnd != NULL)
	{
		// attempt to process help
		if (::SendMessage(hWnd, WM_COMMANDHELP, 0, 0))
			return;

		// check next parent/owner in the parent/owner chain
		hWnd = AfxGetParentOwner(hWnd);
	}
	// No context available, bring up default.
	SendMessage(WM_COMMAND, ID_DEFAULT_HELP);
}

void CFrameWnd::OnHelp()
{
	// Be careful not call WinHelp when the error is failing to lauch help
	if (m_dwPromptContext != 0)
	{
		if (m_dwPromptContext != HID_BASE_PROMPT+AFX_IDP_FAILED_TO_LAUNCH_HELP)
			AfxGetApp()->WinHelpInternal(m_dwPromptContext);
		return;
	}
	CWnd::OnHelp();
}

void CWnd::OnHelpIndex()
{
	AfxGetApp()->WinHelpInternal(0L, HELP_INDEX);
}

void CWnd::OnHelpFinder()
{
	AfxGetApp()->WinHelpInternal(0L, HELP_FINDER);
}

void CWnd::OnHelpUsing()
{
	AfxGetApp()->WinHelpInternal(0L, HELP_HELPONHELP);
}

/////////////////////////////////////////////////////////////////////////////
// Context Help Mode support

BOOL CFrameWnd::CanEnterHelpMode()
{
	ASSERT(m_bHelpMode != HELP_ACTIVE); // already in help mode?

	// unable to start help if the cursor cannot be loaded from the resources
	if (afxData.hcurHelp == NULL)
	{
		afxData.hcurHelp = ::LoadCursor(NULL, IDC_HELP);
		if (afxData.hcurHelp == NULL)
		{
			// load help cursor after handles have been setup
			HINSTANCE hInst = AfxFindResourceHandle(
				ATL_MAKEINTRESOURCE(AFX_IDC_CONTEXTHELP), ATL_RT_GROUP_CURSOR);
			afxData.hcurHelp = LoadCursorW(hInst,
				ATL_MAKEINTRESOURCEW(AFX_IDC_CONTEXTHELP));
		}
		if (afxData.hcurHelp == NULL)
			return FALSE;
	}

	// return TRUE if there is a handler for ID_CONTEXT_HELP
	AFX_CMDHANDLERINFO info;
	return OnCmdMsg(ID_CONTEXT_HELP, CN_COMMAND, NULL, &info);
}

void CFrameWnd::OnContextHelp()
{
	// don't enter twice, and don't enter if initialization fails
	if (m_bHelpMode == HELP_ACTIVE || !CanEnterHelpMode())
		return;

	// don't enter help mode with pending WM_EXITHELPMODE message
	MSG msg;
	if (PeekMessage(&msg, m_hWnd, WM_EXITHELPMODE, WM_EXITHELPMODE,
		PM_REMOVE|PM_NOYIELD))
	{
		return;
	}

	BOOL bHelpMode = m_bHelpMode;
	ASSERT(m_bHelpMode == HELP_INACTIVE || m_bHelpMode == HELP_ENTERING);
	m_bHelpMode = HELP_ACTIVE;

#ifndef _AFX_NO_OLE_SUPPORT
	// allow any in-place active servers to go into help mode
	if (bHelpMode != HELP_ENTERING && m_pNotifyHook != NULL &&
		!m_pNotifyHook->OnContextHelp(TRUE))
	{
		TRACE(traceAppMsg, 0, "Error: an in-place server failed to enter context help mode.\n");
		m_pNotifyHook->OnContextHelp(FALSE);    // undo partial help mode
		m_bHelpMode = HELP_INACTIVE;
		return;
	}
#endif

	if (bHelpMode == HELP_INACTIVE)
	{
		// need to delay help startup until later
		PostMessage(WM_COMMAND, ID_CONTEXT_HELP);
		m_bHelpMode = HELP_ENTERING;
		return;
	}

	ASSERT(m_bHelpMode == HELP_ACTIVE);

	// display special help mode message on status bar
	UINT nMsgSave = (UINT)SendMessage(WM_SETMESSAGESTRING,
		(WPARAM)AFX_IDS_HELPMODEMESSAGE);
	if (nMsgSave == 0)
		nMsgSave = AFX_IDS_IDLEMESSAGE;

	DWORD   dwContext = 0;
	POINT   point;

	GetCursorPos(&point);
	SetHelpCapture(point, NULL);
	LONG lIdleCount = 0;
	CWinApp* pApp = AfxGetApp();

	while (m_bHelpMode)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
		{
			if (!ProcessHelpMsg(msg, &dwContext))
				break;
			ASSERT(dwContext == 0);
		}
		else if (!pApp->OnIdle(lIdleCount++))
		{
			lIdleCount = 0;
			WaitMessage();
		}
	}

	m_bHelpMode = HELP_INACTIVE;
	ReleaseCapture();

	// make sure the cursor is set appropriately
	SetCapture();
	ReleaseCapture();

	// restore original status bar text
	SendMessage(WM_SETMESSAGESTRING, (WPARAM)nMsgSave);

#ifndef _AFX_NO_OLE_SUPPORT
	// tell in-place servers to exit Shift+F1 help mode
	if (m_pNotifyHook != NULL)
		m_pNotifyHook->OnContextHelp(FALSE);
#endif

	if (dwContext != 0)
	{
		if (dwContext == -1)
			SendMessage(WM_COMMAND, ID_DEFAULT_HELP);
		else
			pApp->WinHelpInternal(dwContext);
	}
	PostMessage(WM_KICKIDLE);    // trigger idle update
}

/////////////////////////////////////////////////////////////////////////////
// OnContextHelp helpers.

HWND CFrameWnd::SetHelpCapture(POINT point, BOOL* pbDescendant)
	// set or release capture, depending on where the mouse is
	// also assign the proper cursor to be displayed.
{
	if (!m_bHelpMode)
		return NULL;

	HWND hWndCapture = ::GetCapture();
	CWnd* pWndHit = WindowFromPoint(point);
	HWND hWndHit = pWndHit->GetSafeHwnd();
	CWnd* pTopHit = pWndHit->GetTopLevelParent();
	CWnd* pTopActive = GetActiveWindow()->GetTopLevelParent();
	BOOL bDescendant = FALSE;
	DWORD hCurTask = GetCurrentThreadId();
	DWORD hTaskHit = hWndHit != NULL ? ::GetWindowThreadProcessId(hWndHit, 
		NULL) : NULL;

	if (pTopActive == NULL || hWndHit == ::GetDesktopWindow())
	{
		if (hWndCapture == m_hWnd)
			ReleaseCapture();
		SetCursor(afxData.hcurArrow);
	}
	else if (pTopActive == NULL ||
		hWndHit == NULL || hCurTask != hTaskHit ||
		!AfxIsDescendant(m_hWnd, hWndHit))
	{
		if (hCurTask != hTaskHit)
			hWndHit = NULL;
		if (hWndCapture == m_hWnd)
			ReleaseCapture();
	}
	else
	{
		bDescendant = TRUE;
		if (pTopActive != pTopHit)
			hWndHit = NULL;
		else
		{
			if (hWndCapture != m_hWnd)
				::SetCapture(m_hWnd);
			SetCursor(afxData.hcurHelp);
		}
	}
	if (pbDescendant != NULL)
		*pbDescendant = bDescendant;
	return hWndHit;
}

AFX_STATIC DWORD AFXAPI _AfxMapClientArea(HWND hWnd, POINT point)
{
	DWORD dwContext;

	do
	{
		ASSERT(::IsWindow(hWnd));

		// check current window
		::ScreenToClient(hWnd, &point);
		dwContext = DWORD(::SendMessage(hWnd, WM_HELPHITTEST, 0,
			MAKELONG(point.x, point.y)));
		::ClientToScreen(hWnd, &point);

		// don't use owner's of popup windows, just child/parent relationship
		if ((GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD) == 0)
			break;
		// check parent window
		hWnd = ::GetParent(hWnd);
	}
	while (hWnd && dwContext == 0);

	return dwContext == 0 ? -1 : dwContext;
}

AFX_STATIC DWORD AFXAPI _AfxMapNonClientArea(int iHit)
{
	ASSERT(iHit != HTCLIENT);

	if (iHit < 0 || iHit > HTHELP)
		return (DWORD)-1;

	return HID_BASE_NCAREAS+iHit;
}

BOOL CFrameWnd::ProcessHelpMsg(MSG& msg, DWORD* pContext)
{
	ASSERT(pContext != NULL);

	if (msg.message == WM_EXITHELPMODE ||
		(msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE))
	{
		PeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
		return FALSE;
	}

	CPoint point;
	if ((msg.message >= WM_MOUSEFIRST && msg.message <= AFX_WM_MOUSELAST) ||
		(msg.message >= WM_NCMOUSEFIRST && msg.message <= WM_NCMOUSELAST))
	{
		BOOL bDescendant;
		HWND hWndHit = SetHelpCapture(msg.pt, &bDescendant);
		if (hWndHit == NULL)
			return TRUE;

		if (bDescendant)
		{
			if (msg.message != WM_LBUTTONDOWN)
			{
				// Hit one of our owned windows -- eat the message.
				PeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
				return TRUE;
			}
			int iHit = (int)::SendMessage(hWndHit, WM_NCHITTEST, 0,
				MAKELONG(msg.pt.x, msg.pt.y));
			if (iHit == HTMENU || iHit == HTSYSMENU)
			{
				ASSERT(::GetCapture() == m_hWnd);
				ReleaseCapture();
				// the message we peeked changes into a non-client because
				// of the release capture.
				GetMessage(&msg, NULL, WM_NCLBUTTONDOWN, WM_NCLBUTTONDOWN);
				DispatchMessage(&msg);
				GetCursorPos(&point);
				SetHelpCapture(point, NULL);
			}
			else if (iHit == HTCLIENT)
			{
				*pContext = _AfxMapClientArea(hWndHit, msg.pt);
				PeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
				return FALSE;
			}
			else
			{
				*pContext = _AfxMapNonClientArea(iHit);
				PeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
				return FALSE;
			}
		}
		else
		{
			// Hit one of our apps windows (or desktop) -- dispatch the message.
			PeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);

			// Dispatch mouse messages that hit the desktop!
			DispatchMessage(&msg);
		}
	}
	else if (msg.message == WM_SYSCOMMAND ||
			 (msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST))
	{
		if (::GetCapture() != NULL)
		{
			ReleaseCapture();
			MSG msgCaptured;
			while (PeekMessage(&msgCaptured, NULL, WM_MOUSEFIRST,
				AFX_WM_MOUSELAST, PM_REMOVE|PM_NOYIELD));
		}
		if (PeekMessage(&msg, NULL, msg.message, msg.message, PM_NOREMOVE))
		{
			GetMessage(&msg, NULL, msg.message, msg.message);
			if (!PreTranslateMessage(&msg))
			{
				TranslateMessage(&msg);
				if (msg.message == WM_SYSCOMMAND ||
				  (msg.message >= WM_SYSKEYFIRST &&
					msg.message <= WM_SYSKEYLAST))
				{
					// only dispatch system keys and system commands
					ASSERT(msg.message == WM_SYSCOMMAND ||
						 (msg.message >= WM_SYSKEYFIRST &&
						  msg.message <= WM_SYSKEYLAST));
					DispatchMessage(&msg);
				}
			}
		}
		GetCursorPos(&point);
		SetHelpCapture(point, NULL);
	}
	else
	{
		// allow all other messages to go through (capture still set)
		if (PeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE))
			DispatchMessage(&msg);
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\wingdix.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



AFX_STATIC_DATA HBRUSH _afxHalftoneBrush = 0;

void AFX_CDECL AfxWingdixTerm()
{
	AfxDeleteObject((HGDIOBJ*)&_afxHalftoneBrush);
}
char _afxWingdixTerm = 0;

/////////////////////////////////////////////////////////////////////////////
// More coordinate transforms (in separate file to avoid transitive refs)

#define HIMETRIC_INCH   2540    // HIMETRIC units per inch

void CDC::DPtoHIMETRIC(LPSIZE lpSize) const
{
	ASSERT(AfxIsValidAddress(lpSize, sizeof(SIZE)));

	int nMapMode;
	if (this != NULL && (nMapMode = GetMapMode()) < MM_ISOTROPIC &&
		nMapMode != MM_TEXT)
	{
		// when using a constrained map mode, map against physical inch
		((CDC*)this)->SetMapMode(MM_HIMETRIC);
		DPtoLP(lpSize);
		((CDC*)this)->SetMapMode(nMapMode);
	}
	else
	{
		// map against logical inch for non-constrained mapping modes
		int cxPerInch, cyPerInch;
		if (this != NULL)
		{
			ASSERT_VALID(this);
			ASSERT(m_hDC != NULL);  // no HDC attached or created?
			cxPerInch = GetDeviceCaps(LOGPIXELSX);
			cyPerInch = GetDeviceCaps(LOGPIXELSY);
		}
		else
		{
			cxPerInch = afxData.cxPixelsPerInch;
			cyPerInch = afxData.cyPixelsPerInch;
		}
		ASSERT(cxPerInch != 0 && cyPerInch != 0);
		lpSize->cx = MulDiv(lpSize->cx, HIMETRIC_INCH, cxPerInch);
		lpSize->cy = MulDiv(lpSize->cy, HIMETRIC_INCH, cyPerInch);
	}
}

void CDC::HIMETRICtoDP(LPSIZE lpSize) const
{
	ASSERT(AfxIsValidAddress(lpSize, sizeof(SIZE)));

	int nMapMode;
	if (this != NULL && (nMapMode = GetMapMode()) < MM_ISOTROPIC &&
		nMapMode != MM_TEXT)
	{
		// when using a constrained map mode, map against physical inch
		((CDC*)this)->SetMapMode(MM_HIMETRIC);
		LPtoDP(lpSize);
		((CDC*)this)->SetMapMode(nMapMode);
	}
	else
	{
		// map against logical inch for non-constrained mapping modes
		int cxPerInch, cyPerInch;
		if (this != NULL)
		{
			ASSERT_VALID(this);
			ASSERT(m_hDC != NULL);  // no HDC attached or created?
			cxPerInch = GetDeviceCaps(LOGPIXELSX);
			cyPerInch = GetDeviceCaps(LOGPIXELSY);
		}
		else
		{
			cxPerInch = afxData.cxPixelsPerInch;
			cyPerInch = afxData.cyPixelsPerInch;
		}
		ASSERT(cxPerInch != 0 && cyPerInch != 0);
		lpSize->cx = MulDiv(lpSize->cx, cxPerInch, HIMETRIC_INCH);
		lpSize->cy = MulDiv(lpSize->cy, cyPerInch, HIMETRIC_INCH);
	}
}

void CDC::LPtoHIMETRIC(LPSIZE lpSize) const
{
	ASSERT(AfxIsValidAddress(lpSize, sizeof(SIZE)));

	LPtoDP(lpSize);
	DPtoHIMETRIC(lpSize);
}

void CDC::HIMETRICtoLP(LPSIZE lpSize) const
{
	ASSERT(AfxIsValidAddress(lpSize, sizeof(SIZE)));

	HIMETRICtoDP(lpSize);
	DPtoLP(lpSize);
}

/////////////////////////////////////////////////////////////////////////////
// special CDC drawing primitives/helpers

CBrush* PASCAL CDC::GetHalftoneBrush()
{
	AfxLockGlobals(CRIT_HALFTONEBRUSH);
	if (_afxHalftoneBrush == NULL)
	{
		WORD grayPattern[8];
		for (int i = 0; i < 8; i++)
			grayPattern[i] = (WORD)(0x5555 << (i & 1));
		HBITMAP grayBitmap = CreateBitmap(8, 8, 1, 1, grayPattern);
		if (grayBitmap != NULL)
		{
			_afxHalftoneBrush = ::CreatePatternBrush(grayBitmap);
			DeleteObject(grayBitmap);
		}
	}
	if (!_afxWingdixTerm)
		_afxWingdixTerm = (char)!atexit(&AfxWingdixTerm);
	AfxUnlockGlobals(CRIT_HALFTONEBRUSH);

	return CBrush::FromHandle(_afxHalftoneBrush);
}

void CDC::DrawDragRect(LPCRECT lpRect, SIZE size,
	LPCRECT lpRectLast, SIZE sizeLast, CBrush* pBrush, CBrush* pBrushLast)
{
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT), FALSE));
	ASSERT(lpRectLast == NULL ||
		AfxIsValidAddress(lpRectLast, sizeof(RECT), FALSE));

	// first, determine the update region and select it
	CRgn rgnNew;
	CRgn rgnOutside, rgnInside;
	rgnOutside.CreateRectRgnIndirect(lpRect);
	CRect rect = *lpRect;
	rect.InflateRect(-size.cx, -size.cy);
	rect.IntersectRect(rect, lpRect);
	rgnInside.CreateRectRgnIndirect(rect);
	rgnNew.CreateRectRgn(0, 0, 0, 0);
	rgnNew.CombineRgn(&rgnOutside, &rgnInside, RGN_XOR);

	CBrush* pBrushOld = NULL;
	if (pBrush == NULL)
	{
		pBrush = CDC::GetHalftoneBrush();
	}

	ENSURE(pBrush);

	if (pBrushLast == NULL)
	{
		pBrushLast = pBrush;
	}

	CRgn rgnLast, rgnUpdate;
	if (lpRectLast != NULL)
	{
		// find difference between new region and old region
		rgnLast.CreateRectRgn(0, 0, 0, 0);
		rgnOutside.SetRectRgn(lpRectLast);
		rect = *lpRectLast;
		rect.InflateRect(-sizeLast.cx, -sizeLast.cy);
		rect.IntersectRect(rect, lpRectLast);
		rgnInside.SetRectRgn(rect);
		rgnLast.CombineRgn(&rgnOutside, &rgnInside, RGN_XOR);

		// only diff them if brushes are the same
		if (pBrush->m_hObject == pBrushLast->m_hObject)
		{
			rgnUpdate.CreateRectRgn(0, 0, 0, 0);
			rgnUpdate.CombineRgn(&rgnLast, &rgnNew, RGN_XOR);
		}
	}
	if (pBrush->m_hObject != pBrushLast->m_hObject && lpRectLast != NULL)
	{
		// brushes are different -- erase old region first
		SelectClipRgn(&rgnLast);
		GetClipBox(&rect);
		pBrushOld = SelectObject(pBrushLast);
		PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);
		SelectObject(pBrushOld);
		pBrushOld = NULL;
	}

	// draw into the update/new region
	SelectClipRgn(rgnUpdate.m_hObject != NULL ? &rgnUpdate : &rgnNew);
	GetClipBox(&rect);
	pBrushOld = SelectObject(pBrush);
	PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);

	// cleanup DC
	if (pBrushOld != NULL)
		SelectObject(pBrushOld);
	SelectClipRgn(NULL);
}

void CDC::FillSolidRect(LPCRECT lpRect, COLORREF clr)
{
	ENSURE_VALID(this);
	ENSURE(m_hDC != NULL);
	ENSURE(lpRect);

	::SetBkColor(m_hDC, clr);
	::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL);
}

void CDC::FillSolidRect(int x, int y, int cx, int cy, COLORREF clr)
{
	ASSERT_VALID(this);
	ASSERT(m_hDC != NULL);

	::SetBkColor(m_hDC, clr);
	CRect rect(x, y, x + cx, y + cy);
	::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
}

void CDC::Draw3dRect(LPCRECT lpRect,
	COLORREF clrTopLeft, COLORREF clrBottomRight)
{
	Draw3dRect(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
		lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
}

void CDC::Draw3dRect(int x, int y, int cx, int cy,
	COLORREF clrTopLeft, COLORREF clrBottomRight)
{
	FillSolidRect(x, y, cx - 1, 1, clrTopLeft);
	FillSolidRect(x, y, 1, cy - 1, clrTopLeft);
	FillSolidRect(x + cx, y, -1, cy, clrBottomRight);
	FillSolidRect(x, y + cy, cx, -1, clrBottomRight);
}

/////////////////////////////////////////////////////////////////////////////
// out-of-line CBrush, CFont, etc. helpers

// nPointSize is actually scaled 10x
BOOL CFont::CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, CDC* pDC)
{
	ASSERT(AfxIsValidString(lpszFaceName));

	LOGFONT logFont;
	memset(&logFont, 0, sizeof(LOGFONT));
	logFont.lfCharSet = DEFAULT_CHARSET;
	logFont.lfHeight = nPointSize;
	Checked::tcsncpy_s(logFont.lfFaceName, _countof(logFont.lfFaceName), lpszFaceName, _TRUNCATE);

	return CreatePointFontIndirect(&logFont, pDC);
}

// pLogFont->nHeight is interpreted as PointSize * 10
BOOL CFont::CreatePointFontIndirect(const LOGFONT* lpLogFont, CDC* pDC)
{
	ASSERT(AfxIsValidAddress(lpLogFont, sizeof(LOGFONT), FALSE));
	HDC hDC;
	if (pDC != NULL)
	{
		ASSERT_VALID(pDC);
		ASSERT(pDC->m_hAttribDC != NULL);
		hDC = pDC->m_hAttribDC;
	}
	else
		hDC = ::GetDC(NULL);

	// convert nPointSize to logical units based on pDC
	LOGFONT logFont = *lpLogFont;
	POINT pt;
	// 72 points/inch, 10 decipoints/point
	pt.y = ::MulDiv(::GetDeviceCaps(hDC, LOGPIXELSY), logFont.lfHeight, 720);
	pt.x = 0;
	::DPtoLP(hDC, &pt, 1);
	POINT ptOrg = { 0, 0 };
	::DPtoLP(hDC, &ptOrg, 1);
	logFont.lfHeight = -abs(pt.y - ptOrg.y);

	if (pDC == NULL)
		ReleaseDC(NULL, hDC);

	return CreateFontIndirect(&logFont);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winfrm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <dde.h>        // for DDE execute shell requests

#include "afxdatarecovery.h"
#include "afxglobals.h"
#include <AtlConv.h>

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CRect for creating windows with the default position/size

const AFX_DATADEF CRect CFrameWnd::rectDefault(
	CW_USEDEFAULT, CW_USEDEFAULT,
	0 /* 2*CW_USEDEFAULT */, 0 /* 2*CW_USEDEFAULT */);

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd

BEGIN_MESSAGE_MAP(CFrameWnd, CWnd)
	//{{AFX_MSG_MAP(CFrameWnd)
	ON_WM_INITMENU()
	ON_WM_INITMENUPOPUP()
	ON_WM_MENUSELECT()
	ON_WM_MENUCHAR()
	ON_MESSAGE(WM_POPMESSAGESTRING, &CFrameWnd::OnPopMessageString)
	ON_MESSAGE(WM_SETMESSAGESTRING, &CFrameWnd::OnSetMessageString)
	ON_MESSAGE(WM_HELPPROMPTADDR, &CFrameWnd::OnHelpPromptAddr)
	ON_MESSAGE_VOID(WM_IDLEUPDATECMDUI, CFrameWnd::OnIdleUpdateCmdUI)
	ON_WM_ENTERIDLE()
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_SETFOCUS()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_CLOSE()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_ACTIVATE()
	ON_WM_NCACTIVATE()
	ON_WM_SYSCOMMAND()
	ON_WM_DROPFILES()
	ON_WM_QUERYENDSESSION()
	ON_WM_ENDSESSION()
	ON_WM_SETCURSOR()
	ON_WM_ENABLE()
	// OLE palette support
	ON_WM_QUERYNEWPALETTE()
	ON_WM_PALETTECHANGED()
	ON_MESSAGE(WM_COMMANDHELP, &CFrameWnd::OnCommandHelp)
	ON_MESSAGE(WM_HELPHITTEST, &CFrameWnd::OnHelpHitTest)
	ON_MESSAGE(WM_ACTIVATETOPLEVEL, &CFrameWnd::OnActivateTopLevel)
	// turning on and off standard frame gadgetry
	ON_UPDATE_COMMAND_UI(ID_VIEW_STATUS_BAR, &CFrameWnd::OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_STATUS_BAR, &CFrameWnd::OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, &CFrameWnd::OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, &CFrameWnd::OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_REBAR, &CFrameWnd::OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_REBAR, &CFrameWnd::OnBarCheck)
	// turning on and off standard mode indicators
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_CAPS, &CFrameWnd::OnUpdateKeyIndicator)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_NUM, &CFrameWnd::OnUpdateKeyIndicator)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_SCRL, &CFrameWnd::OnUpdateKeyIndicator)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_KANA, &CFrameWnd::OnUpdateKeyIndicator)
	// standard help handling
	ON_UPDATE_COMMAND_UI(ID_CONTEXT_HELP, &CFrameWnd::OnUpdateContextHelp)
	// toolbar "tooltip" notification
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, &CFrameWnd::OnToolTipText)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, &CFrameWnd::OnToolTipText)
	ON_NOTIFY_EX_RANGE(RBN_CHEVRONPUSHED, 0, 0xFFFF, &CFrameWnd::OnChevronPushed)
	//}}AFX_MSG_MAP
	// message handling for standard DDE commands
	ON_MESSAGE(WM_DDE_INITIATE, &CFrameWnd::OnDDEInitiate)
	ON_MESSAGE(WM_DDE_EXECUTE, &CFrameWnd::OnDDEExecute)
	ON_MESSAGE(WM_DDE_TERMINATE, &CFrameWnd::OnDDETerminate)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd construction/destruction

CFrameWnd::CFrameWnd()
{
	ASSERT(m_hWnd == NULL);

	m_nWindow = -1;                 // unknown window ID
	m_bAutoMenuEnable = TRUE;       // auto enable on by default
	m_lpfnCloseProc = NULL;
	m_hMenuDefault = NULL;
	m_hAccelTable = NULL;
	m_nIDHelp = 0;
	m_nIDTracking = 0;
	m_nIDLastMessage = 0;
	m_pViewActive = NULL;

	m_cModalStack = 0;              // initialize modality support
	m_phWndDisable = NULL;
	m_pNotifyHook = NULL;
	m_hMenuAlt = NULL;
	m_nIdleFlags = 0;               // no idle work at start
	m_rectBorder.SetRectEmpty();

	m_bHelpMode = HELP_INACTIVE;    // not in Shift+F1 help mode
	m_dwPromptContext = 0;

	m_pNextFrameWnd = NULL;         // not in list yet

	m_bInRecalcLayout = FALSE;
	m_pFloatingFrameClass = NULL;
	m_nShowDelay = -1;              // no delay pending

	m_dwMenuBarVisibility = AFX_MBV_KEEPVISIBLE;
	m_dwMenuBarState = AFX_MBS_VISIBLE;
	m_hMenu = NULL;
	m_bTempShowMenu = FALSE;
	m_bMouseHitMenu = FALSE;

	m_nProgressBarRangeMin = 0;
	m_nProgressBarRangeMax = 100;

	AddFrameWnd();
}

CFrameWnd::~CFrameWnd()
{
	AFX_BEGIN_DESTRUCTOR

		RemoveFrameWnd();

		// If we're the current routing frame, pop the routing frame stack
		_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
		while (pThreadState->m_pRoutingFrame == this)
			pThreadState->m_pPushRoutingFrame->Pop();

		if (m_phWndDisable != NULL)
			delete[] (void*)m_phWndDisable;

	AFX_END_DESTRUCTOR
}

void CFrameWnd::AddFrameWnd()
{
	// hook it into the CFrameWnd list
	AFX_MODULE_THREAD_STATE* pState = _AFX_CMDTARGET_GETSTATE()->m_thread;
	pState->m_frameList.AddHead(this);
}

void CFrameWnd::RemoveFrameWnd()
{
	// remove this frame window from the list of frame windows
	AFX_MODULE_THREAD_STATE* pState = _AFX_CMDTARGET_GETSTATE()->m_thread;
	pState->m_frameList.Remove(this);
}

/////////////////////////////////////////////////////////////////////////////
// Special processing etc

BOOL CFrameWnd::LoadAccelTable(LPCTSTR lpszResourceName)
{
	ASSERT(m_hAccelTable == NULL);  // only do once
	ASSERT(lpszResourceName != NULL);

	HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, ATL_RT_ACCELERATOR);
	m_hAccelTable = ::LoadAccelerators(hInst, lpszResourceName);
	return (m_hAccelTable != NULL);
}

HACCEL CFrameWnd::GetDefaultAccelerator()
{
	// use document specific accelerator table over m_hAccelTable
	HACCEL hAccelTable = m_hAccelTable;
	HACCEL hAccel;
	CDocument* pDoc = GetActiveDocument();
	if (pDoc != NULL && (hAccel = pDoc->GetDefaultAccelerator()) != NULL)
		hAccelTable = hAccel;

	return hAccelTable;
}

BOOL CFrameWnd::PreTranslateMessage(MSG* pMsg)
{
	ENSURE_ARG(pMsg != NULL);
	// check for special cancel modes for combo boxes
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_NCLBUTTONDOWN)
		AfxCancelModes(pMsg->hwnd);    // filter clicks

	// check for key strokes that may affect the menu bar state
	if ((m_dwMenuBarVisibility & AFX_MBV_DISPLAYONF10) &&
		 pMsg->message == WM_SYSKEYUP &&
		 pMsg->wParam == VK_F10)
	{
		SetMenuBarState(AFX_MBS_VISIBLE);
	}

	if (m_dwMenuBarVisibility & AFX_MBV_DISPLAYONFOCUS)
	{
		if (pMsg->message == WM_SYSKEYUP &&
			pMsg->wParam == VK_MENU)
		{
			SetMenuBarState(m_dwMenuBarState == AFX_MBS_VISIBLE ? AFX_MBS_HIDDEN : AFX_MBS_VISIBLE);
		}
		else if (pMsg->message == WM_SYSCHAR &&
				m_dwMenuBarState == AFX_MBS_HIDDEN)
		{
			// temporarily show the menu bar to enable menu access keys
			SetMenuBarState(AFX_MBS_VISIBLE);
			m_bTempShowMenu = TRUE;
		}
	}

	if ((m_dwMenuBarVisibility & AFX_MBV_KEEPVISIBLE) == 0)
	{
		if ( (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE) ||
			 (pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_RBUTTONDOWN) ||
			((pMsg->message == WM_NCLBUTTONDOWN || pMsg->message == WM_NCRBUTTONDOWN) && pMsg->wParam != HTMENU))
		{
			SetMenuBarState(AFX_MBS_HIDDEN);
		}
	}

	if (pMsg->message == WM_NCLBUTTONDOWN || pMsg->message == WM_NCRBUTTONDOWN)
	{
		m_bMouseHitMenu = (pMsg->wParam == HTMENU);
	}
	else if (pMsg->message == WM_NCLBUTTONUP || pMsg->message == WM_NCRBUTTONUP ||
		pMsg->message == WM_LBUTTONUP || pMsg->message == WM_RBUTTONUP)
	{
		m_bMouseHitMenu = FALSE;
	}

	// allow tooltip messages to be filtered
	if (CWnd::PreTranslateMessage(pMsg))
		return TRUE;

#ifndef _AFX_NO_OLE_SUPPORT
	// allow hook to consume message
	if (m_pNotifyHook != NULL && m_pNotifyHook->OnPreTranslateMessage(pMsg))
		return TRUE;
#endif

	if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
	{
		// finally, translate the message
		HACCEL hAccel = GetDefaultAccelerator();
		return hAccel != NULL &&  ::TranslateAccelerator(m_hWnd, hAccel, pMsg);
	}
	return FALSE;
}

void CFrameWnd::PostNcDestroy()
{
	// default for frame windows is to allocate them on the heap
	//  the default post-cleanup is to 'delete this'.
	// never explicitly call 'delete' on a CFrameWnd, use DestroyWindow instead
	delete this;
}

void CFrameWnd::OnPaletteChanged(CWnd* pFocusWnd)
{
	CWnd::OnPaletteChanged(pFocusWnd);
#ifndef _AFX_NO_OLE_SUPPORT
	if (m_pNotifyHook != NULL)
		m_pNotifyHook->OnPaletteChanged(pFocusWnd);
#endif
}

BOOL CFrameWnd::OnQueryNewPalette()
{
#ifndef _AFX_NO_OLE_SUPPORT
	if (m_pNotifyHook != NULL && m_pNotifyHook->OnQueryNewPalette())
		return TRUE;
#endif
	return CWnd::OnQueryNewPalette();
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd support for context sensitive help.

void CFrameWnd::ExitHelpMode()
{
	// if not in help mode currently, this is a no-op
	if (!m_bHelpMode)
		return;

	// only post new WM_EXITHELPMODE message if one doesn't already exist
	//  in the queue.
	MSG msg;
	if (!::PeekMessage(&msg, m_hWnd, WM_EXITHELPMODE, WM_EXITHELPMODE,
		PM_REMOVE|PM_NOYIELD))
	{
		VERIFY(::PostMessage(m_hWnd, WM_EXITHELPMODE, 0, 0));
	}

	// release capture if this window has it
	if (::GetCapture() == m_hWnd)
		ReleaseCapture();

	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	ENSURE_VALID(pFrameWnd);
	pFrameWnd->m_bHelpMode = m_bHelpMode = HELP_INACTIVE;
	PostMessage(WM_KICKIDLE);   // trigger idle update
}

BOOL CFrameWnd::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	ENSURE_VALID(pFrameWnd);
	if (pFrameWnd->m_bHelpMode)
	{
		SetCursor(afxData.hcurHelp);
		return TRUE;
	}
	return CWnd::OnSetCursor(pWnd, nHitTest, message);
}

LRESULT CFrameWnd::OnCommandHelp(WPARAM, LPARAM lParam)
{
	if (lParam == 0)
	{
		if (IsTracking())
			lParam = HID_BASE_COMMAND+m_nIDTracking;
		else
			lParam = HID_BASE_RESOURCE+m_nIDHelp;
	}
	if (lParam != 0)
	{
		CWinApp* pApp = AfxGetApp();
		if (pApp != NULL)
			pApp->WinHelpInternal(lParam);
		return TRUE;
	}
	return FALSE;
}

LRESULT CFrameWnd::OnHelpHitTest(WPARAM, LPARAM)
{
	if (m_nIDHelp != 0)
		return HID_BASE_RESOURCE+m_nIDHelp;
	else
		return 0;
}

BOOL CFrameWnd::OnCommand(WPARAM wParam, LPARAM lParam)
	// return TRUE if command invocation was attempted
{
	HWND hWndCtrl = (HWND)lParam;
	UINT nID = LOWORD(wParam);

	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	ENSURE_VALID(pFrameWnd);
	if (pFrameWnd->m_bHelpMode && hWndCtrl == NULL &&
		nID != ID_HELP && nID != ID_DEFAULT_HELP && nID != ID_CONTEXT_HELP)
	{
		// route as help
		if (!SendMessage(WM_COMMANDHELP, 0, HID_BASE_COMMAND+nID))
			SendMessage(WM_COMMAND, ID_DEFAULT_HELP);
		return TRUE;
	}

	// route as normal command
	return CWnd::OnCommand(wParam, lParam);
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd support for modality

BOOL AFXAPI AfxIsDescendant(HWND hWndParent, HWND hWndChild)
	// helper for detecting whether child descendent of parent
	//  (works with owned popups as well)
{
	ASSERT(::IsWindow(hWndParent));
	ASSERT(::IsWindow(hWndChild));

	do
	{
		if (hWndParent == hWndChild)
			return TRUE;

		hWndChild = AfxGetParentOwner(hWndChild);
	} while (hWndChild != NULL);

	return FALSE;
}

void CFrameWnd::BeginModalState()
{
	ASSERT(m_hWnd != NULL);
	ASSERT(::IsWindow(m_hWnd));

	// allow stacking, but don't do anything
	if (++m_cModalStack > 1)
		return;

	// determine top-level parent, since that is the true parent of any
	//  modeless windows anyway...
	CWnd* pParent = EnsureTopLevelParent();

	CArray<HWND,HWND> arrDisabledWnds;	
	// disable all windows connected to this frame (and add them to the list)
	HWND hWnd = ::GetWindow(::GetDesktopWindow(), GW_CHILD);
	while (hWnd != NULL)
	{
		if (::IsWindowEnabled(hWnd) &&
			CWnd::FromHandlePermanent(hWnd) != NULL &&
			AfxIsDescendant(pParent->m_hWnd, hWnd) &&
			::SendMessage(hWnd, WM_DISABLEMODAL, 0, 0) == 0)
		{
			::EnableWindow(hWnd, FALSE);			
			arrDisabledWnds.Add(hWnd);				
		}
		hWnd = ::GetWindow(hWnd, GW_HWNDNEXT);
	}
	INT_PTR nCount = arrDisabledWnds.GetCount();
	if (nCount == 0)
	{
		return;
	}
	ENSURE(nCount > 0);
	m_phWndDisable = new HWND[nCount+1];
	// Terminate the list with a NULL
	m_phWndDisable[nCount] = NULL;
	ENSURE(arrDisabledWnds.GetData()!=NULL);
	// Copy the HWNDs from local array to m_phWndDisable, to be enabled later.
	Checked::memcpy_s(m_phWndDisable,sizeof(HWND)*nCount,arrDisabledWnds.GetData(),sizeof(HWND)*nCount);
}

void CFrameWnd::EndModalState()
{
	// pop one off the stack (don't undo modalness unless stack is down to zero)
	if (m_cModalStack == 0 || --m_cModalStack > 0 || m_phWndDisable == NULL)
		return;

	// enable all the windows disabled by BeginModalState
	ASSERT(m_phWndDisable != NULL);
	UINT nIndex = 0;
	while (m_phWndDisable[nIndex] != NULL)
	{
		ASSERT(m_phWndDisable[nIndex] != NULL);
		if (::IsWindow(m_phWndDisable[nIndex]))
			::EnableWindow(m_phWndDisable[nIndex], TRUE);
		++nIndex;
	}
	delete[] (void*)m_phWndDisable;
	m_phWndDisable = NULL;
}

void CFrameWnd::ShowOwnedWindows(BOOL bShow)
{
	// walk through all top-level windows
	HWND hWnd = ::GetWindow(::GetDesktopWindow(), GW_CHILD);
	while (hWnd != NULL)
	{
		CWnd* pWnd = CWnd::FromHandlePermanent(hWnd);
		if (pWnd != NULL && m_hWnd != hWnd && AfxIsDescendant(m_hWnd, hWnd))
		{
			DWORD dwStyle = ::GetWindowLong(hWnd, GWL_STYLE);
			if (!bShow && (dwStyle & (WS_VISIBLE|WS_DISABLED)) == WS_VISIBLE)
			{
				::ShowWindow(hWnd, SW_HIDE);
				pWnd->m_nFlags |= WF_TEMPHIDE;
			}
			// don't show temporarily hidden windows if we're in print preview mode
			else if (bShow && (dwStyle & (WS_VISIBLE|WS_DISABLED)) == 0 &&
				(pWnd->m_nFlags & WF_TEMPHIDE) && !m_lpfnCloseProc)
			{
				::ShowWindow(hWnd, SW_SHOWNOACTIVATE);
				pWnd->m_nFlags &= ~WF_TEMPHIDE;
			}
		}
		hWnd = ::GetWindow(hWnd, GW_HWNDNEXT);
	}
}

void CFrameWnd::OnEnable(BOOL bEnable)
{
	if (bEnable && (m_nFlags & WF_STAYDISABLED))
	{
		// Work around for MAPI support. This makes sure the main window
		// remains disabled even when the mail system is booting.
		EnableWindow(FALSE);
		::SetFocus(NULL);
		return;
	}

	// only for top-level (and non-owned) windows of our process
	CWnd *pParentWnd = GetParent();
	if (pParentWnd != NULL)
	{
#ifndef _AFX_NO_OLE_SUPPORT
		DWORD dwProcessId = 0;
		::GetWindowThreadProcessId(pParentWnd->GetSafeHwnd(), &dwProcessId);
		if (::GetCurrentProcessId() == dwProcessId)
#endif
			return;
	}

	// this causes modal dialogs to be "truly modal"
	if (!bEnable && !InModalState())
	{
		ASSERT((m_nFlags & WF_MODALDISABLE) == 0);
		m_nFlags |= WF_MODALDISABLE;
		BeginModalState();
	}
	else if (bEnable && (m_nFlags & WF_MODALDISABLE))
	{
		m_nFlags &= ~WF_MODALDISABLE;
		EndModalState();

		// cause normal focus logic to kick in
		if (::GetActiveWindow() == m_hWnd)
			SendMessage(WM_ACTIVATE, WA_ACTIVE);
	}

	// force WM_NCACTIVATE because Windows may think it is unecessary
	if (bEnable && (m_nFlags & WF_STAYACTIVE))
		SendMessage(WM_NCACTIVATE, TRUE);
	// force WM_NCACTIVATE for floating windows too
	NotifyFloatingWindows(bEnable ? FS_ENABLE : FS_DISABLE);
}

void CFrameWnd::NotifyFloatingWindows(DWORD dwFlags)
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);

	// get top level parent frame window first unless this is a child window
	CFrameWnd* pParent = (GetStyle() & WS_CHILD) ? this : GetTopLevelFrame();
	ENSURE(pParent != NULL);
	if (dwFlags & (FS_DEACTIVATE|FS_ACTIVATE))
	{
		// update parent window activation state
		BOOL bActivate = !(dwFlags & FS_DEACTIVATE);
		BOOL bEnabled = pParent->IsWindowEnabled();

		if (bActivate && bEnabled && pParent != this)
		{
			// Excel will try to Activate itself when it receives a
			// WM_NCACTIVATE so we need to keep it from doing that here.
			m_nFlags |= WF_KEEPMINIACTIVE;
			pParent->SendMessage(WM_NCACTIVATE, TRUE);
			m_nFlags &= ~WF_KEEPMINIACTIVE;
		}
		else
		{
			pParent->SendMessage(WM_NCACTIVATE, FALSE);
		}
	}

	// then update the state of all floating windows owned by the parent
	HWND hWnd = ::GetWindow(::GetDesktopWindow(), GW_CHILD);
	while (hWnd != NULL)
	{
		if (AfxIsDescendant(pParent->m_hWnd, hWnd))
			::SendMessage(hWnd, WM_FLOATSTATUS, dwFlags, 0);
		hWnd = ::GetWindow(hWnd, GW_HWNDNEXT);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd second phase creation

BOOL CFrameWnd::PreCreateWindow(CREATESTRUCT& cs)
{
	if (cs.lpszClass == NULL)
	{
		VERIFY(AfxDeferRegisterClass(AFX_WNDFRAMEORVIEW_REG));
		cs.lpszClass = _afxWndFrameOrView;  // COLOR_WINDOW background
	}

	if (cs.style & FWS_ADDTOTITLE)
		cs.style |= FWS_PREFIXTITLE;

	cs.dwExStyle |= WS_EX_CLIENTEDGE;

	return TRUE;
}

BOOL CFrameWnd::Create(LPCTSTR lpszClassName,
	LPCTSTR lpszWindowName,
	DWORD dwStyle,
	const RECT& rect,
	CWnd* pParentWnd,
	LPCTSTR lpszMenuName,
	DWORD dwExStyle,
	CCreateContext* pContext)
{
	HMENU hMenu = NULL;
	if (lpszMenuName != NULL)
	{
		// load in a menu that will get destroyed when window gets destroyed
		HINSTANCE hInst = AfxFindResourceHandle(lpszMenuName, ATL_RT_MENU);
		if ((hMenu = ::LoadMenu(hInst, lpszMenuName)) == NULL)
		{
			TRACE(traceAppMsg, 0, "Warning: failed to load menu for CFrameWnd.\n");
			PostNcDestroy();            // perhaps delete the C++ object
			return FALSE;
		}
	}

	m_strTitle = lpszWindowName;    // save title for later

	if (!CreateEx(dwExStyle, lpszClassName, lpszWindowName, dwStyle,
		rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
		pParentWnd->GetSafeHwnd(), hMenu, (LPVOID)pContext))
	{
		TRACE(traceAppMsg, 0, "Warning: failed to create CFrameWnd.\n");
		if (hMenu != NULL)
			DestroyMenu(hMenu);
		return FALSE;
	}

	return TRUE;
}

CWnd* CFrameWnd::CreateView(CCreateContext* pContext, UINT nID)
{
	ASSERT(m_hWnd != NULL);
	ASSERT(::IsWindow(m_hWnd));
	ENSURE_ARG(pContext != NULL);
	ENSURE_ARG(pContext->m_pNewViewClass != NULL);

	// Note: can be a CWnd with PostNcDestroy self cleanup
	CWnd* pView = (CWnd*)pContext->m_pNewViewClass->CreateObject();
	if (pView == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: Dynamic create of view type %hs failed.\n",
			pContext->m_pNewViewClass->m_lpszClassName);
		return NULL;
	}
	ASSERT_KINDOF(CWnd, pView);

	// views are always created with a border!
	if (!pView->Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
		CRect(0,0,0,0), this, nID, pContext))
	{
		TRACE(traceAppMsg, 0, "Warning: could not create view for frame.\n");
		return NULL;        // can't continue without a view
	}

	if (pView->GetExStyle() & WS_EX_CLIENTEDGE)
	{
		// remove the 3d style from the frame, since the view is
		//  providing it.
		// make sure to recalc the non-client area
		ModifyStyleEx(WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED);
	}
	return pView;
}

BOOL CFrameWnd::OnCreateClient(LPCREATESTRUCT, CCreateContext* pContext)
{
	// default create client will create a view if asked for it
	if (pContext != NULL && pContext->m_pNewViewClass != NULL)
	{
		if (CreateView(pContext, AFX_IDW_PANE_FIRST) == NULL)
			return FALSE;
	}
	return TRUE;
}

int CFrameWnd::OnCreate(LPCREATESTRUCT lpcs)
{
	ENSURE_ARG(lpcs != NULL);
	CCreateContext* pContext = (CCreateContext*)lpcs->lpCreateParams;
	return OnCreateHelper(lpcs, pContext);
}

int CFrameWnd::OnCreateHelper(LPCREATESTRUCT lpcs, CCreateContext* pContext)
{
	if (CWnd::OnCreate(lpcs) == -1)
		return -1;

	// create special children first
	if (!OnCreateClient(lpcs, pContext))
	{
		TRACE(traceAppMsg, 0, "Failed to create client pane/view for frame.\n");
		return -1;
	}

	// post message for initial message string
	PostMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);

	// make sure the child windows have been properly sized
	RecalcLayout();

	return 0;   // create ok
}

LPCTSTR CFrameWnd::GetIconWndClass(DWORD dwDefaultStyle, UINT nIDResource)
{
	ASSERT_VALID_IDR(nIDResource);
	HINSTANCE hInst = AfxFindResourceHandle(
		ATL_MAKEINTRESOURCE(nIDResource), ATL_RT_GROUP_ICON);
	HICON hIcon = ::LoadIconW(hInst, ATL_MAKEINTRESOURCEW(nIDResource));
	if (hIcon != NULL)
	{
		CREATESTRUCT cs;
		memset(&cs, 0, sizeof(CREATESTRUCT));
		cs.style = dwDefaultStyle;
		PreCreateWindow(cs);
			// will fill lpszClassName with default WNDCLASS name
			// ignore instance handle from PreCreateWindow.

		WNDCLASS wndcls;
		if (cs.lpszClass != NULL &&
			AfxCtxGetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wndcls) &&
			wndcls.hIcon != hIcon)
		{
			// register a very similar WNDCLASS
			return AfxRegisterWndClass(wndcls.style,
				wndcls.hCursor, wndcls.hbrBackground, hIcon);
		}
	}
	return NULL;        // just use the default
}

BOOL CFrameWnd::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
	CWnd* pParentWnd, CCreateContext* pContext)
{
	// only do this once
	ASSERT_VALID_IDR(nIDResource);
	ASSERT(m_nIDHelp == 0 || m_nIDHelp == nIDResource);

	m_nIDHelp = nIDResource;    // ID for help context (+HID_BASE_RESOURCE)

	CString strFullString;
	if (strFullString.LoadString(nIDResource))
		AfxExtractSubString(m_strTitle, strFullString, 0);    // first sub-string

	VERIFY(AfxDeferRegisterClass(AFX_WNDFRAMEORVIEW_REG));

	// attempt to create the window
	LPCTSTR lpszClass = GetIconWndClass(dwDefaultStyle, nIDResource);
	CString strTitle = m_strTitle;
	if (!Create(lpszClass, strTitle, dwDefaultStyle, rectDefault,
	  pParentWnd, ATL_MAKEINTRESOURCE(nIDResource), 0L, pContext))
	{
		return FALSE;   // will self destruct on failure normally
	}

	// save the default menu handle
	ASSERT(m_hWnd != NULL);
	m_hMenuDefault = m_dwMenuBarState == AFX_MBS_VISIBLE ? ::GetMenu(m_hWnd) : m_hMenu;

	// load accelerator resource
	LoadAccelTable(ATL_MAKEINTRESOURCE(nIDResource));

	if (pContext == NULL)   // send initial update
		SendMessageToDescendants(WM_INITIALUPDATE, 0, 0, TRUE, TRUE);

	return TRUE;
}

void CFrameWnd::OnUpdateFrameMenu(HMENU hMenuAlt)
{
	if (hMenuAlt == NULL)
	{
		// attempt to get default menu from document
		CDocument* pDoc = GetActiveDocument();
		if (pDoc != NULL)
			hMenuAlt = pDoc->GetDefaultMenu();
		// use default menu stored in frame if none from document
		if (hMenuAlt == NULL)
			hMenuAlt = m_hMenuDefault;
	}
	// finally, set the menu
	if (m_dwMenuBarState == AFX_MBS_VISIBLE)
	{
		::SetMenu(m_hWnd, hMenuAlt);
	}
	else if (m_dwMenuBarState == AFX_MBS_HIDDEN)
	{
		m_hMenu = hMenuAlt;
	}
}

void CFrameWnd::InitialUpdateFrame(CDocument* pDoc, BOOL bMakeVisible)
{
	// if the frame does not have an active view, set to first pane
	CView* pView = NULL;
	if (GetActiveView() == NULL)
	{
		CWnd* pWnd = GetDescendantWindow(AFX_IDW_PANE_FIRST, TRUE);
		if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		{
			pView = (CView*)pWnd;
			SetActiveView(pView, FALSE);
		}
	}

	if (bMakeVisible)
	{
		// send initial update to all views (and other controls) in the frame
		SendMessageToDescendants(WM_INITIALUPDATE, 0, 0, TRUE, TRUE);

		// give view a chance to save the focus (CFormView needs this)
		if (pView != NULL)
			pView->OnActivateFrame(WA_INACTIVE, this);

		// finally, activate the frame
		// (send the default show command unless the main desktop window)
		int nCmdShow = -1;      // default
		CWinApp* pApp = AfxGetApp();
		if (pApp != NULL && pApp->m_pMainWnd == this)
		{
			nCmdShow = pApp->m_nCmdShow; // use the parameter from WinMain
			pApp->m_nCmdShow = -1; // set to default after first time
		}
		ActivateFrame(nCmdShow);
		if (pView != NULL)
			pView->OnActivateView(TRUE, pView, pView);
	}

	// update frame counts and frame title (may already have been visible)
	if (pDoc != NULL)
		pDoc->UpdateFrameCounts();
	OnUpdateFrameTitle(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd closing down

void CFrameWnd::OnClose()
{
	if (m_lpfnCloseProc != NULL)
	{
		// if there is a close proc, then defer to it, and return
		// after calling it so the frame itself does not close.
		(*m_lpfnCloseProc)(this);
		return;
	}

	// Note: only queries the active document
	CDocument* pDocument = GetActiveDocument();
	if (pDocument != NULL && !pDocument->CanCloseFrame(this))
	{
		// document can't close right now -- don't close it
		return;
	}
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd == this)
	{
		CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
		if ((pHandler != NULL) && (pHandler->GetShutdownByRestartManager()))
		{
			// If the application is being shut down by the Restart Manager, do
			// a final autosave.  This will mark all the documents as not dirty,
			// so the SaveAllModified call below won't prompt for save.
			pHandler->AutosaveAllDocumentInfo();
			pHandler->SaveOpenDocumentList();
		}

		// attempt to save all documents
		if (pDocument == NULL && !pApp->SaveAllModified())
			return;     // don't close it

		if ((pHandler != NULL) && (!pHandler->GetShutdownByRestartManager()))
		{
			// If the application is not being shut down by the Restart Manager,
			// delete any autosaved documents since everything is now fully saved.
			pHandler->DeleteAllAutosavedFiles();
		}

		// hide the application's windows before closing all the documents
		pApp->HideApplication();

		// close all documents first
		pApp->CloseAllDocuments(FALSE);

		// don't exit if there are outstanding component objects
		if (!AfxOleCanExitApp())
		{
			// take user out of control of the app
			AfxOleSetUserCtrl(FALSE);

			// don't destroy the main window and close down just yet
			//  (there are outstanding component (OLE) objects)
			return;
		}

		// there are cases where destroying the documents may destroy the
		//  main window of the application.
		if (!afxContextIsDLL && pApp->m_pMainWnd == NULL)
		{
			AfxPostQuitMessage(0);
			return;
		}
	}

	// detect the case that this is the last frame on the document and
	// shut down with OnCloseDocument instead.
	if (pDocument != NULL && pDocument->m_bAutoDelete)
	{
		BOOL bOtherFrame = FALSE;
		POSITION pos = pDocument->GetFirstViewPosition();
		while (pos != NULL)
		{
			CView* pView = pDocument->GetNextView(pos);
			ENSURE_VALID(pView);
			if (pView->GetParentFrame() != this)
			{
				bOtherFrame = TRUE;
				break;
			}
		}
		if (!bOtherFrame)
		{
			pDocument->OnCloseDocument();
			return;
		}

		// allow the document to cleanup before the window is destroyed
		pDocument->PreCloseFrame(this);
	}

	// then destroy the window
	DestroyWindow();
}

void CFrameWnd::OnDestroy()
{
	DestroyDockBars();

	// reset menu to default before final shutdown
	if (m_hMenuDefault != NULL && ::GetMenu(m_hWnd) != m_hMenuDefault)
	{
		::SetMenu(m_hWnd, m_hMenuDefault);
		ASSERT(::GetMenu(m_hWnd) == m_hMenuDefault);
	}

	// Automatically quit when the main window is destroyed.
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd == this && pApp->m_eHelpType == afxWinHelp)
	{
		// closing the main application window
		::WinHelp(m_hWnd, NULL, HELP_QUIT, 0L);

		// will call PostQuitMessage in CWnd::OnNcDestroy
	}
	CWnd::OnDestroy();
}

void CFrameWnd::RemoveControlBar(CControlBar *pBar)
{
	POSITION pos = m_listControlBars.Find(pBar);
	if (pos != NULL)
		m_listControlBars.RemoveAt(pos);
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd command/message routing

BOOL CFrameWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	CPushRoutingFrame push(this);

	// pump through current view FIRST
	CView* pView = GetActiveView();
	if (pView != NULL && pView->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// then pump through frame
	if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// last but not least, pump through app
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	return FALSE;
}

// Delegate scroll messages to active view as well
void CFrameWnd::OnHScroll(UINT, UINT, CScrollBar*)
{
	CWnd* pActiveView = GetActiveView();
	if (pActiveView != NULL)
	{
		const MSG* pMsg = GetCurrentMessage();
		pActiveView->SendMessage(WM_HSCROLL, pMsg->wParam, pMsg->lParam);
	}
}

void CFrameWnd::OnVScroll(UINT, UINT, CScrollBar*)
{
	CWnd* pActiveView = GetActiveView();
	if (pActiveView != NULL)
	{
		const MSG* pMsg = GetCurrentMessage();
		pActiveView->SendMessage(WM_VSCROLL, pMsg->wParam, pMsg->lParam);
	}
}

LRESULT CFrameWnd::OnActivateTopLevel(WPARAM wParam, LPARAM lParam)
{
	CWnd::OnActivateTopLevel(wParam, lParam);

	// exit Shift+F1 help mode on activation changes
	ExitHelpMode();

#ifndef _AFX_NO_OLE_SUPPORT
	// allow OnFrameWindowActivate to be sent to in-place items
	if (m_pNotifyHook != NULL)
	{
		// activate when active and when not minimized
		m_pNotifyHook->OnActivate(
			LOWORD(wParam) != WA_INACTIVE && !HIWORD(wParam));
	}
#endif

	// deactivate current active view
	CWinThread *pThread = AfxGetThread();
	ASSERT(pThread);
	if (pThread->m_pMainWnd == this)
	{
		CView* pActiveView = GetActiveView();
		if (pActiveView == NULL)
			pActiveView = GetActiveFrame()->GetActiveView();
		if (pActiveView != NULL)
			pActiveView->OnActivateView(FALSE, pActiveView, pActiveView);
	}

	// force idle processing to update any key state indicators
	PostMessage(WM_KICKIDLE);

	return 0;
}

void CFrameWnd::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	CWnd::OnActivate(nState, pWndOther, bMinimized);

	// hide the menu bar
	if (nState == WA_INACTIVE && (m_dwMenuBarVisibility & AFX_MBV_KEEPVISIBLE) == 0)
	{
		SetMenuBarState(AFX_MBS_HIDDEN);
	}

	// get top level frame unless this is a child window
	// determine if window should be active or not
	CFrameWnd* pTopLevel = (GetStyle() & WS_CHILD) ? this : GetTopLevelFrame();
	ENSURE_VALID(pTopLevel);
	CWnd* pActive = (nState == WA_INACTIVE ? pWndOther : this);
	BOOL bStayActive = (pActive != NULL) ?
		(pTopLevel == pActive ||
		(pTopLevel == pActive->GetTopLevelFrame() &&
		(pActive == pTopLevel ||
			pActive->SendMessage(WM_FLOATSTATUS, FS_SYNCACTIVE) != 0)))
			: FALSE;
	pTopLevel->m_nFlags &= ~WF_STAYACTIVE;
	if (bStayActive)
		pTopLevel->m_nFlags |= WF_STAYACTIVE;

	// sync floating windows to the new state
	NotifyFloatingWindows(bStayActive ? FS_ACTIVATE : FS_DEACTIVATE);

	// get active view (use active frame if no active view)
	CView* pActiveView = GetActiveView();
	if (pActiveView == NULL)
		pActiveView = GetActiveFrame()->GetActiveView();

	// when frame gets activated, re-activate current view
	if (pActiveView != NULL)
	{
		if (nState != WA_INACTIVE && !bMinimized)
			pActiveView->OnActivateView(TRUE, pActiveView, pActiveView);

		// always notify the view of frame activations
		pActiveView->OnActivateFrame(nState, this);
	}
}

BOOL CFrameWnd::OnNcActivate(BOOL bActive)
{
	// stay active if WF_STAYACTIVE bit is on
	if (m_nFlags & WF_STAYACTIVE)
		bActive = TRUE;

	// but do not stay active if the window is disabled
	if (!IsWindowEnabled())
		bActive = FALSE;

	// do not call the base class because it will call Default()
	//  and we may have changed bActive.
	return (BOOL)DefWindowProc(WM_NCACTIVATE, bActive, 0L);
}

void CFrameWnd::OnSysCommand(UINT nID, LPARAM lParam)
{
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	ENSURE_VALID(pFrameWnd);

	// set status bar as appropriate
	UINT nItemID = (nID & 0xFFF0);

	// don't interfere with system commands if not in help mode
	if (pFrameWnd->m_bHelpMode)
	{
		switch (nItemID)
		{
		case SC_SIZE:
		case SC_MOVE:
		case SC_MINIMIZE:
		case SC_MAXIMIZE:
		case SC_NEXTWINDOW:
		case SC_PREVWINDOW:
		case SC_CLOSE:
		case SC_RESTORE:
		case SC_TASKLIST:
			if (!SendMessage(WM_COMMANDHELP, 0,
			  HID_BASE_COMMAND+ID_COMMAND_FROM_SC(nItemID)))
				SendMessage(WM_COMMAND, ID_DEFAULT_HELP);
			return;
		}
	}

	// call default functionality
	CWnd::OnSysCommand(nID, lParam);
}

/////////////////////////////////////////////////////////////////////////////
// default frame processing

// default drop processing will attempt to open the file
void CFrameWnd::OnDropFiles(HDROP hDropInfo)
{
	SetActiveWindow();      // activate us first !
	UINT nFiles = ::DragQueryFile(hDropInfo, (UINT)-1, NULL, 0);

	CWinApp* pApp = AfxGetApp();
	ASSERT(pApp != NULL);
	for (UINT iFile = 0; iFile < nFiles; iFile++)
	{
		TCHAR szFileName[_MAX_PATH];
		::DragQueryFile(hDropInfo, iFile, szFileName, _MAX_PATH);
		pApp->OpenDocumentFile(szFileName);
	}
	::DragFinish(hDropInfo);
}

// query end session for main frame will attempt to close it all down
BOOL CFrameWnd::OnQueryEndSession()
{
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd == this)
	{
		if (AfxGetThreadState()->m_lastSentMsg.lParam & ENDSESSION_CLOSEAPP)
		{
			// Restart Manager is querying about restarting the application
			return pApp->SupportsRestartManager();
		}

		return pApp->SaveAllModified();
	}

	return TRUE;
}

// when Windows session ends, close all documents
void CFrameWnd::OnEndSession(BOOL bEnding)
{
	if (!bEnding)
		return;

	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && pApp->m_pMainWnd == this)
	{
		if (AfxGetThreadState()->m_lastSentMsg.lParam & ENDSESSION_CLOSEAPP)
		{
			// Restart Manager is restarting the application
			CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
			if (pHandler)
			{
				pHandler->SetShutdownByRestartManager(TRUE);

				// Just return here rather than doing more processing.
				// The final autosave will be handled in the WM_CLOSE handler,
				// because the Restart Manager allows 30 seconds for processing
				// that message, and only 5 seconds for processing WM_ENDSESSION.
				return;
			}
		}

		AfxOleSetUserCtrl(TRUE);    // keeps from randomly shutting down
		pApp->CloseAllDocuments(TRUE);

		// allow application to save settings, etc.
		pApp->ExitInstance();
	}
}

/////////////////////////////////////////////////////////////////////////////
// Support for Shell DDE Execute messages

LRESULT CFrameWnd::OnDDEInitiate(WPARAM wParam, LPARAM lParam)
{
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL && 
		LOWORD(lParam) != 0 && HIWORD(lParam) != 0 &&
		(ATOM)LOWORD(lParam) == pApp->m_atomApp &&
		(ATOM)HIWORD(lParam) == pApp->m_atomSystemTopic)
	{
		// make duplicates of the incoming atoms (really adding a reference)
		TCHAR szAtomName[_MAX_PATH];
		VERIFY(GlobalGetAtomName(pApp->m_atomApp,
			szAtomName, _MAX_PATH - 1) != 0);
		VERIFY(GlobalAddAtom(szAtomName) == pApp->m_atomApp);
		VERIFY(GlobalGetAtomName(pApp->m_atomSystemTopic,
			szAtomName, _MAX_PATH - 1) != 0);
		VERIFY(GlobalAddAtom(szAtomName) == pApp->m_atomSystemTopic);

		// send the WM_DDE_ACK (caller will delete duplicate atoms)
		::SendMessage((HWND)wParam, WM_DDE_ACK, (WPARAM)m_hWnd,
			MAKELPARAM(pApp->m_atomApp, pApp->m_atomSystemTopic));
	}
	return 0L;
}

// always ACK the execute command - even if we do nothing
LRESULT CFrameWnd::OnDDEExecute(WPARAM wParam, LPARAM lParam)
{
	// unpack the DDE message
   UINT_PTR unused;
	HGLOBAL hData;
	VERIFY(UnpackDDElParam(WM_DDE_EXECUTE, lParam, &unused, (UINT_PTR*)&hData));

	// get the command string
	LPCTSTR lpsz = (LPCTSTR)GlobalLock(hData);
	CString strCommand;
	TRY
	{
		strCommand = lpsz;
		GlobalUnlock(hData);
	}
	CATCH(CMemoryException, e)
	{
		GlobalUnlock(hData);
		DELETE_EXCEPTION(e);
	}
	END_CATCH

	// acknowledge now - before attempting to execute
	::PostMessage((HWND)wParam, WM_DDE_ACK, (WPARAM)m_hWnd,
		ReuseDDElParam(lParam, WM_DDE_EXECUTE, WM_DDE_ACK,
		(UINT)0x8000, (UINT_PTR)hData));

	// don't execute the command when the window is disabled
	if (!IsWindowEnabled())
	{
		TRACE(traceAppMsg, 0, _T("Warning: DDE command '%s' ignored because window is disabled.\n"),
			strCommand.GetString());
		return 0;
	}

	// execute the command
	LPTSTR lpszCommand = strCommand.GetBuffer();
	if (!AfxGetApp()->OnDDECommand(lpszCommand))
		TRACE(traceAppMsg, 0, _T("Error: failed to execute DDE command '%s'.\n"), lpszCommand);
	strCommand.ReleaseBuffer();
	return 0L;
}

LRESULT CFrameWnd::OnDDETerminate(WPARAM wParam, LPARAM lParam)
{
	::PostMessage((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)m_hWnd, lParam);
	return 0L;
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd attributes

CView* CFrameWnd::GetActiveView() const
{
	ASSERT(m_pViewActive == NULL ||
		m_pViewActive->IsKindOf(RUNTIME_CLASS(CView)));
	return m_pViewActive;
}

void CFrameWnd::SetActiveView(CView* pViewNew, BOOL bNotify)
{
#ifdef _DEBUG
	if (pViewNew != NULL)
	{
		ASSERT(IsChild(pViewNew));
		ASSERT_KINDOF(CView, pViewNew);
	}
#endif //_DEBUG

	CView* pViewOld = m_pViewActive;
	if (pViewNew == pViewOld)
		return;     // do not re-activate if SetActiveView called more than once

	m_pViewActive = NULL;   // no active for the following processing

	// deactivate the old one
	if (pViewOld != NULL)
		pViewOld->OnActivateView(FALSE, pViewNew, pViewOld);

	// if the OnActivateView moves the active window,
	//    that will veto this change
	if (m_pViewActive != NULL)
		return;     // already set
	m_pViewActive = pViewNew;

	// activate
	if (pViewNew != NULL && bNotify)
		pViewNew->OnActivateView(TRUE, pViewNew, pViewOld);
}

void CFrameWnd::SetActivePreviewView(CView* pViewNew)
{
#ifdef _DEBUG
	if (pViewNew != NULL)
	{
		ASSERT(IsChild(pViewNew));
		ASSERT_KINDOF(CView, pViewNew);
	}
#endif //_DEBUG

	m_pViewActive = pViewNew;
}

/////////////////////////////////////////////////////////////////////////////
// Special view swapping/activation

void CFrameWnd::OnSetFocus(CWnd* pOldWnd)
{
	if (m_pViewActive != NULL)
		m_pViewActive->SetFocus();
	else
		CWnd::OnSetFocus(pOldWnd);
}

CDocument* CFrameWnd::GetActiveDocument()
{
	ASSERT_VALID(this);
	CView* pView = GetActiveView();
	if (pView != NULL)
		return pView->GetDocument();
	return NULL;
}

void CFrameWnd::ShowControlBar(CControlBar* pBar, BOOL bShow, BOOL bDelay)
{
	ENSURE_VALID(pBar);
	CFrameWnd* pParentFrame = pBar->GetDockingFrame();
	ASSERT(pParentFrame->GetTopLevelParent() == GetTopLevelParent());
		// parent frame of bar must be related

	if (bDelay)
	{
		pBar->DelayShow(bShow);
		pParentFrame->DelayRecalcLayout();
	}
	else
	{
		pBar->SetWindowPos(NULL, 0, 0, 0, 0,
			SWP_NOZORDER|SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|
			(bShow ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
		// call DelayShow to clear any contradictory DelayShow
		pBar->DelayShow(bShow);
		if (bShow || !pBar->IsFloating())
			pParentFrame->RecalcLayout(FALSE);
	}

	// show or hide the floating frame as appropriate
	if (pBar->IsFloating())
	{
		int nVisCount = pBar->m_pDockBar != NULL ?
			pBar->m_pDockBar->GetDockedVisibleCount() : bShow ? 1 : 0;
		if (nVisCount == 1 && bShow)
		{
			pParentFrame->m_nShowDelay = -1;
			if (bDelay)
			{
				pParentFrame->m_nShowDelay = SW_SHOWNA;
				pParentFrame->RecalcLayout(FALSE);
			}
			else
				pParentFrame->ShowWindow(SW_SHOWNA);
		}
		else if (nVisCount == 0)
		{
			ASSERT(!bShow);
			pParentFrame->m_nShowDelay = -1;
			if (bDelay)
				pParentFrame->m_nShowDelay = SW_HIDE;
			else
				pParentFrame->ShowWindow(SW_HIDE);
		}
		else if (!bDelay)
		{
			pParentFrame->RecalcLayout(FALSE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Command prompts

void CFrameWnd::OnInitMenu(CMenu* pMenu)
{
#ifndef _AFX_NO_OLE_SUPPORT
	// allow hook to consume message
	if (m_pNotifyHook != NULL)
		m_pNotifyHook->OnInitMenu(pMenu);
#endif

	Default();
}

void CFrameWnd::OnInitMenuPopup(CMenu* pMenu, UINT nIndex, BOOL bSysMenu)
{
	AfxCancelModes(m_hWnd);

	if (bSysMenu)
		return;     // don't support system menu

#ifndef _AFX_NO_OLE_SUPPORT
	// allow hook to consume message
	if (m_pNotifyHook != NULL &&
		m_pNotifyHook->OnInitMenuPopup(pMenu, nIndex, bSysMenu))
	{
		return;
	}
#endif

	ENSURE_VALID(pMenu);
	
	// check the enabled state of various menu items

	CCmdUI state;
	state.m_pMenu = pMenu;
	ASSERT(state.m_pOther == NULL);
	ASSERT(state.m_pParentMenu == NULL);

	// determine if menu is popup in top-level menu and set m_pOther to
	//  it if so (m_pParentMenu == NULL indicates that it is secondary popup)
	HMENU hParentMenu;
	if (AfxGetThreadState()->m_hTrackingMenu == pMenu->m_hMenu)
		state.m_pParentMenu = pMenu;    // parent == child for tracking popup
	else if ((hParentMenu = (m_dwMenuBarState == AFX_MBS_VISIBLE) ? ::GetMenu(m_hWnd) : m_hMenu) != NULL)
	{
		CWnd* pParent = GetTopLevelParent();
			// child windows don't have menus -- need to go to the top!
		if (pParent != NULL &&
			(hParentMenu = pParent->GetMenu()->GetSafeHmenu()) != NULL)
		{
			int nIndexMax = ::GetMenuItemCount(hParentMenu);
			for (int nItemIndex = 0; nItemIndex < nIndexMax; nItemIndex++)
			{
				if (::GetSubMenu(hParentMenu, nItemIndex) == pMenu->m_hMenu)
				{
					// when popup is found, m_pParentMenu is containing menu
					state.m_pParentMenu = CMenu::FromHandle(hParentMenu);
					break;
				}
			}
		}
	}

	state.m_nIndexMax = pMenu->GetMenuItemCount();
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;
	  state.m_nIndex++)
	{
		state.m_nID = pMenu->GetMenuItemID(state.m_nIndex);
		if (state.m_nID == 0)
			continue; // menu separator or invalid cmd - ignore it

		ASSERT(state.m_pOther == NULL);
		ASSERT(state.m_pMenu != NULL);
		if (state.m_nID == (UINT)-1)
		{
			// possibly a popup menu, route to first item of that popup
			state.m_pSubMenu = pMenu->GetSubMenu(state.m_nIndex);
			if (state.m_pSubMenu == NULL ||
				(state.m_nID = state.m_pSubMenu->GetMenuItemID(0)) == 0 ||
				state.m_nID == (UINT)-1)
			{
				continue;       // first item of popup can't be routed to
			}
			state.DoUpdate(this, FALSE);    // popups are never auto disabled
		}
		else
		{
			// normal menu item
			// Auto enable/disable if frame window has 'm_bAutoMenuEnable'
			//    set and command is _not_ a system command.
			state.m_pSubMenu = NULL;
			state.DoUpdate(this, m_bAutoMenuEnable && state.m_nID < 0xF000);
		}

		// adjust for menu deletions and additions
		UINT nCount = pMenu->GetMenuItemCount();
		if (nCount < state.m_nIndexMax)
		{
			state.m_nIndex -= (state.m_nIndexMax - nCount);
			while (state.m_nIndex < nCount &&
				pMenu->GetMenuItemID(state.m_nIndex) == state.m_nID)
			{
				state.m_nIndex++;
			}
		}
		state.m_nIndexMax = nCount;
	}
}

void CFrameWnd::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu)
{
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	ENSURE_VALID(pFrameWnd);

#ifndef _AFX_NO_OLE_SUPPORT
	// allow hook to consume message
	if (m_pNotifyHook != NULL &&
		m_pNotifyHook->OnMenuSelect(nItemID, nFlags, hSysMenu))
	{
		return;
	}
#endif

	// set the tracking state (update on idle)
	if (nFlags == 0xFFFF)
	{
		// cancel menu operation (go back to idle now)
		m_nFlags &= ~WF_NOPOPMSG;
		if (!pFrameWnd->m_bHelpMode)
			m_nIDTracking = AFX_IDS_IDLEMESSAGE;
		else
			m_nIDTracking = AFX_IDS_HELPMODEMESSAGE;
		SendMessage(WM_SETMESSAGESTRING, (WPARAM)m_nIDTracking);
		ASSERT(m_nIDTracking == m_nIDLastMessage);

		// update right away
		CWnd* pWnd = GetMessageBar();
		if (pWnd != NULL)
			pWnd->UpdateWindow();

		if (hSysMenu == 0 && // the menu has been closed
			(m_dwMenuBarVisibility & AFX_MBV_KEEPVISIBLE) == 0 &&
			::GetKeyState(VK_F10) >= 0 && // not pressed
			::GetKeyState(VK_MENU) >= 0 &&
			!m_bMouseHitMenu)
		{
			SetMenuBarState(AFX_MBS_HIDDEN);
		}
	}
	else
	{
		if (m_bTempShowMenu)
		{
			m_bTempShowMenu = FALSE;
			if ((nFlags & MF_SYSMENU) &&
				(m_dwMenuBarVisibility & AFX_MBV_KEEPVISIBLE) == 0)
			{
				SetMenuBarState(AFX_MBS_HIDDEN);
			}
		}

		if (nItemID == 0 || nFlags & (MF_SEPARATOR|MF_POPUP))
		{
			// nothing should be displayed
			m_nIDTracking = 0;
		}
		else if (nItemID >= 0xF000 && nItemID < 0xF1F0) // max of 31 SC_s
		{
			// special strings table entries for system commands
			m_nIDTracking = ID_COMMAND_FROM_SC(nItemID);
			ASSERT(m_nIDTracking >= AFX_IDS_SCFIRST &&
				m_nIDTracking < AFX_IDS_SCFIRST + 31);
		}
		else if (nItemID >= AFX_IDM_FIRST_MDICHILD)
		{
			// all MDI Child windows map to the same help id
			m_nIDTracking = AFX_IDS_MDICHILD;
		}
		else
		{
			// track on idle
			m_nIDTracking = nItemID;
		}
		pFrameWnd->m_nFlags |= WF_NOPOPMSG;
	}

	// when running in-place, it is necessary to cause a message to
	//  be pumped through the queue.
	if (m_nIDTracking != m_nIDLastMessage && GetParent() != NULL)
		PostMessage(WM_KICKIDLE);
}

void CFrameWnd::GetMessageString(UINT nID, CString& rMessage) const
{
	// load appropriate string
	LPTSTR lpsz = rMessage.GetBuffer(255);
	if (AfxLoadString(nID, lpsz) != 0)
	{
		// first newline terminates actual string
		lpsz = _tcschr(lpsz, '\n');
		if (lpsz != NULL)
			*lpsz = '\0';
	}
	else
	{
		// not found
		TRACE(traceAppMsg, 0, "Warning: no message line prompt for ID 0x%04X.\n", nID);
	}
	rMessage.ReleaseBuffer();
}

LRESULT CFrameWnd::OnPopMessageString(WPARAM wParam, LPARAM lParam)
{
	if (m_nFlags & WF_NOPOPMSG)
		return 0;

	return SendMessage(WM_SETMESSAGESTRING, wParam, lParam);
}

LRESULT CFrameWnd::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{
	UINT nIDLast = m_nIDLastMessage;
	m_nFlags &= ~WF_NOPOPMSG;

	CWnd* pMessageBar = GetMessageBar();
	if (pMessageBar != NULL)
	{
		LPCTSTR lpsz = NULL;
		CString strMessage;

		// set the message bar text
		if (lParam != 0)
		{
			ASSERT(wParam == 0);    // can't have both an ID and a string
			lpsz = (LPCTSTR)lParam; // set an explicit string
		}
		else if (wParam != 0)
		{
			// map SC_CLOSE to PREVIEW_CLOSE when in print preview mode
			if (wParam == AFX_IDS_SCCLOSE && m_lpfnCloseProc != NULL)
				wParam = AFX_IDS_PREVIEW_CLOSE;

			// get message associated with the ID indicated by wParam
		 //NT64: Assume IDs are still 32-bit
			GetMessageString((UINT)wParam, strMessage);
			lpsz = strMessage;
		}
		pMessageBar->SetWindowText(lpsz);

		// update owner of the bar in terms of last message selected
		CFrameWnd* pFrameWnd = pMessageBar->GetParentFrame();
		if (pFrameWnd != NULL)
		{
			pFrameWnd->m_nIDLastMessage = (UINT)wParam;
			pFrameWnd->m_nIDTracking = (UINT)wParam;
		}
	}

	m_nIDLastMessage = (UINT)wParam;    // new ID (or 0)
	m_nIDTracking = (UINT)wParam;       // so F1 on toolbar buttons work
	return nIDLast;
}

LRESULT CFrameWnd::OnHelpPromptAddr(WPARAM, LPARAM)
{
	return (LRESULT)&m_dwPromptContext;
}

CWnd* CFrameWnd::GetMessageBar()
{
	return GetDescendantWindow(AFX_IDW_STATUS_BAR, TRUE);
}

void CFrameWnd::OnEnterIdle(UINT nWhy, CWnd* pWho)
{
	CWnd::OnEnterIdle(nWhy, pWho);

	if (nWhy != MSGF_MENU || m_nIDTracking == m_nIDLastMessage)
		return;

	SetMessageText(m_nIDTracking);
	ASSERT(m_nIDTracking == m_nIDLastMessage);
}

void CFrameWnd::SetMessageText(LPCTSTR lpszText)
{
	SendMessage(WM_SETMESSAGESTRING, 0, (LPARAM)lpszText);
}

void CFrameWnd::SetMessageText(UINT nID)
{
	SendMessage(WM_SETMESSAGESTRING, (WPARAM)nID);
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd standard control bar management


void CFrameWnd::DestroyDockBars()
{
	// create a list of all the dock bars
	// this is necessary because m_listControlBars will change
	// as the dock bars and floating frames are destroyed
	CList<HWND,HWND> listDockBars, listCtrlBars;
	POSITION pos = m_listControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		CControlBar* pBar= (CControlBar*)m_listControlBars.GetNext(pos);
		ASSERT(pBar != NULL);
		if (pBar->IsDockBar())
		{
			listDockBars.AddTail( pBar->GetSafeHwnd() );
		}
		else
		{
			listCtrlBars.AddTail( pBar->GetSafeHwnd() );
		}
	}
	pos = listDockBars.GetHeadPosition();
	while (pos != NULL)
	{
		HWND hwndDock = listDockBars.GetNext(pos);		
		CDockBar* pDockBar = DYNAMIC_DOWNCAST(CDockBar,CWnd::FromHandlePermanent(hwndDock));
		if (pDockBar)
		{
			ASSERT(IsWindow(hwndDock));
		if (pDockBar->m_bFloating)
		{
			CFrameWnd* pFrameWnd = pDockBar->EnsureParentFrame();
			pFrameWnd->DestroyWindow();
		}
		else
			{
			pDockBar->DestroyWindow();
	}
		}
	}

	pos = listCtrlBars.GetHeadPosition();
	while (pos != NULL)
	{
		HWND hwndCtrlBar = listCtrlBars.GetNext(pos);
		//pDockBar->DestroyWindow() (see listDockBars) will destroy all child windows of this dockbar, 
		//including control bars, so check if HWND is still valid. We do not want to destroy a second time. 		
		CControlBar *pCtrlBar  = DYNAMIC_DOWNCAST(CControlBar,CWnd::FromHandlePermanent(hwndCtrlBar));
		if (pCtrlBar)
		{
			ASSERT(IsWindow(hwndCtrlBar));
			pCtrlBar->DestroyWindow();
		}
	}
}

CControlBar* CFrameWnd::GetControlBar(UINT nID)
{
	if (nID == 0)
		return NULL;
	POSITION pos = m_listControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		CControlBar* pBar = (CControlBar*)m_listControlBars.GetNext(pos);
		ASSERT(pBar != NULL);
		if (_AfxGetDlgCtrlID(pBar->m_hWnd) == nID)
		{
			ASSERT_KINDOF(CControlBar, pBar);
			return pBar;
		}
	}
	return NULL;
}

void CFrameWnd::OnUpdateControlBarMenu(CCmdUI* pCmdUI)
{
	ASSERT(ID_VIEW_STATUS_BAR == AFX_IDW_STATUS_BAR);
	ASSERT(ID_VIEW_TOOLBAR == AFX_IDW_TOOLBAR);
	ASSERT(ID_VIEW_REBAR == AFX_IDW_REBAR);
	ENSURE_ARG(pCmdUI != NULL);

	CControlBar* pBar = GetControlBar(pCmdUI->m_nID);
	if (pBar != NULL)
	{
		pCmdUI->SetCheck((pBar->GetStyle() & WS_VISIBLE) != 0);
		return;
	}
	pCmdUI->ContinueRouting();
}

BOOL CFrameWnd::OnBarCheck(UINT nID)
{
	ASSERT(ID_VIEW_STATUS_BAR == AFX_IDW_STATUS_BAR);
	ASSERT(ID_VIEW_TOOLBAR == AFX_IDW_TOOLBAR);
	ASSERT(ID_VIEW_REBAR == AFX_IDW_REBAR);

	CControlBar* pBar = GetControlBar(nID);
	if (pBar != NULL)
	{
		ShowControlBar(pBar, (pBar->GetStyle() & WS_VISIBLE) == 0, FALSE);
		return TRUE;
	}
	return FALSE;
}

BOOL CFrameWnd::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT* pResult)
{
	ENSURE_ARG(pNMHDR != NULL);
	ENSURE_ARG(pResult != NULL);
	ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);

	// need to handle both ANSI and UNICODE versions of the message
	TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
	TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;
	TCHAR szFullText[256];
	CString strTipText;
	UINT_PTR nID = pNMHDR->idFrom;
	if (pNMHDR->code == TTN_NEEDTEXTA && (pTTTA->uFlags & TTF_IDISHWND) ||
		pNMHDR->code == TTN_NEEDTEXTW && (pTTTW->uFlags & TTF_IDISHWND))
	{
		// idFrom is actually the HWND of the tool
		nID = _AfxGetDlgCtrlID((HWND)nID);
	}

	if (nID != 0) // will be zero on a separator
	{
		// don't handle the message if no string resource found
		if (AfxLoadString((UINT)nID, szFullText) == 0)
			return FALSE;

		// this is the command id, not the button index
		AfxExtractSubString(strTipText, szFullText, 1, '\n');
	}
#ifndef _UNICODE
	if (pNMHDR->code == TTN_NEEDTEXTA)
		Checked::strncpy_s(pTTTA->szText, _countof(pTTTA->szText), strTipText, _TRUNCATE);
	else
		_mbstowcsz(pTTTW->szText, strTipText, _countof(pTTTW->szText));
#else
	if (pNMHDR->code == TTN_NEEDTEXTA)
		_wcstombsz(pTTTA->szText, strTipText, _countof(pTTTA->szText));
	else
		Checked::wcsncpy_s(pTTTW->szText, _countof(pTTTW->szText), strTipText, _TRUNCATE);
#endif
	*pResult = 0;

	// bring the tooltip window above other popup windows
	::SetWindowPos(pNMHDR->hwndFrom, HWND_TOP, 0, 0, 0, 0,
		SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE|SWP_NOOWNERZORDER);

	return TRUE;    // message was handled
}

/////////////////////////////////////////////////////////////////////////////
// Support for standard status bar

void CFrameWnd::OnUpdateKeyIndicator(CCmdUI* pCmdUI)
{
	ENSURE_ARG(pCmdUI != NULL);
	UINT nVK;
	UINT flag = 0x0001;

	switch (pCmdUI->m_nID)
	{
	case ID_INDICATOR_CAPS:
		nVK = VK_CAPITAL;
		break;

	case ID_INDICATOR_NUM:
		nVK = VK_NUMLOCK;
		break;

	case ID_INDICATOR_SCRL:
		nVK = VK_SCROLL;
		break;

	case ID_INDICATOR_KANA:
		nVK = VK_KANA;
		break;

	default:
		TRACE(traceAppMsg, 0, "Warning: OnUpdateKeyIndicator - unknown indicator 0x%04X.\n",
			pCmdUI->m_nID);
		pCmdUI->ContinueRouting();
		return; // not for us
	}

	pCmdUI->Enable(::GetKeyState(nVK) & flag);
		// enable static text based on toggled key state
	ASSERT(pCmdUI->m_bEnableChanged);
}

void CFrameWnd::OnUpdateContextHelp(CCmdUI* pCmdUI)
{
	ENSURE_ARG(pCmdUI != NULL);
	if (AfxGetMainWnd() == this)
		pCmdUI->SetCheck(!!m_bHelpMode);
	else
		pCmdUI->ContinueRouting();
}

/////////////////////////////////////////////////////////////////////////////
// Setting title of frame window - UISG standard

void CFrameWnd::OnUpdateFrameTitle(BOOL bAddToTitle)
{
	if ((GetStyle() & FWS_ADDTOTITLE) == 0)
		return;     // leave it alone!

#ifndef _AFX_NO_OLE_SUPPORT
	// allow hook to set the title (used for OLE support)
	if (m_pNotifyHook != NULL && m_pNotifyHook->OnUpdateFrameTitle())
		return;
#endif

	CDocument* pDocument = GetActiveDocument();
	if (bAddToTitle && pDocument != NULL)
		UpdateFrameTitleForDocument(pDocument->GetTitle());
	else
		UpdateFrameTitleForDocument(NULL);
}

void CFrameWnd::UpdateFrameTitleForDocument(LPCTSTR lpszDocName)
{
	CString WindowText;

	if (GetStyle() & FWS_PREFIXTITLE)
	{
		// get name of currently active view
		if (lpszDocName != NULL)
		{
			WindowText += lpszDocName;

			// add current window # if needed
			if (m_nWindow > 0)
			{
				TCHAR szText[32];
				
				// :%d will produce a maximum of 11 TCHARs
				_stprintf_s(szText, _countof(szText), _T(":%d"), m_nWindow);
				WindowText += szText;
			}
			WindowText += _T(" - ");
		}
		WindowText += m_strTitle;
	}
	else
	{
		// get name of currently active view
		WindowText += m_strTitle;
		if (lpszDocName != NULL)
		{
			WindowText += _T(" - ");
			WindowText += lpszDocName;

			// add current window # if needed
			if (m_nWindow > 0)
			{
				TCHAR szText[32];
				
				// :%d will produce a maximum of 11 TCHARs
				_stprintf_s(szText, _countof(szText), _T(":%d"), m_nWindow);
				WindowText += szText;
			}
		}
	}

	// set title if changed, but don't remove completely
	// Note: will be excessive for MDI Frame with maximized child
	AfxSetWindowText(m_hWnd, (LPCTSTR) WindowText);
}

/////////////////////////////////////////////////////////////////////////////

void CFrameWnd::OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState)
{
	ENSURE_ARG(pState != NULL);
	// default implementation changes control bars, menu and main pane window

#ifndef _AFX_NO_OLE_SUPPORT
	CFrameWnd* pActiveFrame = GetActiveFrame();
	ENSURE_VALID(pActiveFrame);
	if (bPreview && pActiveFrame->m_pNotifyHook != NULL)
		pActiveFrame->m_pNotifyHook->OnDocActivate(FALSE);
#endif

	// Set visibility of standard ControlBars (only the first 32)
	DWORD dwOldStates = 0;
	POSITION pos = m_listControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		CControlBar* pBar = (CControlBar*)m_listControlBars.GetNext(pos);
		ENSURE_VALID(pBar);
		UINT_PTR nID = _AfxGetDlgCtrlID(pBar->m_hWnd);
		if (nID >= AFX_IDW_CONTROLBAR_FIRST && nID <= AFX_IDW_CONTROLBAR_FIRST+31)
		{
			DWORD dwMask = 1L << (UINT)(nID - AFX_IDW_CONTROLBAR_FIRST);
			if (pBar->IsVisible())
				dwOldStates |= dwMask;      // save if previously visible
			if (!pBar->IsDockBar() || nID != AFX_IDW_DOCKBAR_FLOAT)
				ShowControlBar(pBar, (pState->dwStates & dwMask), TRUE);
		}
	}
	pState->dwStates = dwOldStates; // save for restore

	if (bPreview)
	{
		// Entering Print Preview

		ASSERT(m_lpfnCloseProc == NULL);    // no chaining
		m_lpfnCloseProc = pState->lpfnCloseProc;

		// show any modeless dialogs, popup windows, float tools, etc
		ShowOwnedWindows(FALSE);

		// Hide the main pane
		HWND hWnd = ::GetDlgItem(m_hWnd, pState->nIDMainPane);
		ASSERT(hWnd != NULL);       // must be one that we are hiding!
		::ShowWindow(hWnd, SW_HIDE);

		// Get rid of the menu first (will resize the window)
		pState->hMenu = m_dwMenuBarState == AFX_MBS_VISIBLE ? ::GetMenu(m_hWnd) : m_hMenu;

		if (pState->hMenu != NULL)
		{
			// Invalidate before SetMenu since we are going to replace
			//  the frame's client area anyway
			Invalidate();
			SetMenu(NULL);
			m_nIdleFlags &= ~idleMenu;  // avoid any idle menu processing
		}

		// Save the accelerator table and remove it.
		pState->hAccelTable = m_hAccelTable;
		m_hAccelTable = NULL;
		LoadAccelTable(ATL_MAKEINTRESOURCE(AFX_IDR_PREVIEW_ACCEL));

		// Make room for the PreviewView by changing AFX_IDW_PANE_FIRST's ID
		//  to AFX_IDW_PREVIEW_FIRST
		if (pState->nIDMainPane != AFX_IDW_PANE_FIRST)
			hWnd = ::GetDlgItem(m_hWnd, AFX_IDW_PANE_FIRST);
		if (hWnd != NULL)
			_AfxSetDlgCtrlID(hWnd, AFX_IDW_PANE_SAVE);

#ifdef _DEBUG
		if ((::GetWindowLong(m_hWnd, GWL_STYLE) & (WS_HSCROLL|WS_VSCROLL)) != 0)
			TRACE(traceAppMsg, 0, "Warning: scroll bars in frame windows may cause unusual behaviour.\n");
#endif
	}
	else
	{
		// Leaving Preview
		m_lpfnCloseProc = NULL;

		// shift original AFX_IDW_PANE_FIRST back to its rightful ID
		HWND hWnd = ::GetDlgItem(m_hWnd, AFX_IDW_PANE_SAVE);
		if (hWnd != NULL)
		{
			HWND hWndTemp = ::GetDlgItem(m_hWnd, AFX_IDW_PANE_FIRST);
			if (hWndTemp != NULL)
				_AfxSetDlgCtrlID(hWndTemp, AFX_IDW_PANE_SAVE);
			_AfxSetDlgCtrlID(hWnd, AFX_IDW_PANE_FIRST);
		}

		// put the menu back in place if it was removed before
		if (pState->hMenu != NULL)
		{
			// Invalidate before SetMenu since we are going to replace
			//  the frame's client area anyway
			Invalidate();
			if (m_dwMenuBarState == AFX_MBS_VISIBLE)
			{
				::SetMenu(m_hWnd, pState->hMenu);
			}
			else if (m_dwMenuBarState == AFX_MBS_HIDDEN)
			{
				m_hMenu = pState->hMenu;
			}
		}

		// recalc layout now, before showing the main pane
#ifndef _AFX_NO_OLE_SUPPORT
		if (pActiveFrame->m_pNotifyHook != NULL)
			pActiveFrame->m_pNotifyHook->OnDocActivate(TRUE);
#endif
		RecalcLayout();

		// now show main pane that was hidden
		if (pState->nIDMainPane != AFX_IDW_PANE_FIRST)
			hWnd = ::GetDlgItem(m_hWnd, pState->nIDMainPane);
		ASSERT(hWnd != NULL);
		::ShowWindow(hWnd, SW_SHOW);

		// Restore the Accelerator table
		m_hAccelTable = pState->hAccelTable;

		// show any modeless dialogs, popup windows, float tools, etc
		ShowOwnedWindows(TRUE);
	}
}

void CFrameWnd::DelayUpdateFrameMenu(HMENU hMenuAlt)
{
	m_hMenuAlt = hMenuAlt;
	m_nIdleFlags |= idleMenu;
}

void CFrameWnd::OnIdleUpdateCmdUI()
{
	// update menu if necessary
	if (m_nIdleFlags & idleMenu)
	{
		m_nIdleFlags &= ~idleMenu;
		OnUpdateFrameMenu(m_hMenuAlt);
	}

	// update title if necessary
	if (m_nIdleFlags & idleTitle)
		OnUpdateFrameTitle(TRUE);

	// recalc layout if necessary
	if (m_nIdleFlags & idleLayout)
	{
		RecalcLayout(m_nIdleFlags & idleNotify);
		UpdateWindow();
	}

	// set the current message string if necessary
	if (m_nIDTracking != m_nIDLastMessage)
	{
		SetMessageText(m_nIDTracking);
		ASSERT(m_nIDTracking == m_nIDLastMessage);
	}
	m_nIdleFlags = 0;
}

CFrameWnd* CFrameWnd::GetActiveFrame()
{
	// by default, the active frame is the frame itself (MDI is different)
	return this;
}

void CFrameWnd::RecalcLayout(BOOL bNotify)
{
	if (m_bInRecalcLayout)
		return;

	m_bInRecalcLayout = TRUE;
	// clear idle flags for recalc layout if called elsewhere
	if (m_nIdleFlags & idleNotify)
		bNotify = TRUE;
	m_nIdleFlags &= ~(idleLayout|idleNotify);

#ifndef _AFX_NO_OLE_SUPPORT
	// call the layout hook -- OLE support uses this hook
	if (bNotify && m_pNotifyHook != NULL)
		m_pNotifyHook->OnRecalcLayout();
#endif

	// reposition all the child windows (regardless of ID)
	if (GetStyle() & FWS_SNAPTOBARS)
	{
		CRect rect(0, 0, 32767, 32767);
		RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposQuery,
			&rect, &rect, FALSE);
		RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposExtra,
			&m_rectBorder, &rect, TRUE);
		CalcWindowRect(&rect);
		SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(),
			SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);
	}
	else
		RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposExtra, &m_rectBorder);
	m_bInRecalcLayout = FALSE;
}

// CFrameWnd implementation of OLE border space negotiation
BOOL CFrameWnd::NegotiateBorderSpace(UINT nBorderCmd, LPRECT lpRectBorder)
{
	CRect border, request;

	switch (nBorderCmd)
	{
	case borderGet:
		ASSERT(lpRectBorder != NULL);
		RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposQuery,
			lpRectBorder);
		break;

	case borderRequest:
		return TRUE;

	case borderSet:
		if (lpRectBorder == NULL)
		{
			if (!m_rectBorder.IsRectNull())
			{
				// releasing all border space -- recalc needed
				m_rectBorder.SetRectEmpty();
				return TRUE;
			}
			// original rect is empty & lpRectBorder is NULL, no recalc needed
			return FALSE;
		}
		if (!::EqualRect(m_rectBorder, lpRectBorder))
		{
			// the rects are different -- recalc needed
			m_rectBorder.CopyRect(lpRectBorder);
			return TRUE;
		}
		return FALSE;   // no recalc needed

	default:
		ASSERT(FALSE);  // invalid CFrameWnd::BorderCmd
	}

	return TRUE;
}

void CFrameWnd::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);    // important for MDI Children
	if (nType != SIZE_MINIMIZED)
		RecalcLayout();
}

BOOL CFrameWnd::OnEraseBkgnd(CDC* pDC)
{
	if (m_pViewActive != NULL)
		return TRUE;        // active view will erase/paint itself
	// for view-less frame just use the default background fill
	return CWnd::OnEraseBkgnd(pDC);
}

BOOL CFrameWnd::OnChevronPushed(UINT id, NMHDR *pnm, LRESULT *pResult) 
{
	NMREBARCHEVRON *pnmReBarChevron = (NMREBARCHEVRON *) pnm;
	CReBar *pReBar;
	CToolBar *pToolBar;
	CString strClassName;
	int nLen;

	// Note: If your program is asserting here make sure that you only use a CToolBar control in
	// the band in which the chevron is used.  For chevron processing, MFC only handles rebar bands
	// that contain toolbar controls - any other control will assert.  If you wish to use another
	// control with the chevron you must provide your own implementation of OnChevronPushed.
	nLen = ::lstrlen(REBARCLASSNAME) + 1;
	::GetClassName(pnmReBarChevron->hdr.hwndFrom, strClassName.GetBuffer(nLen), nLen);
	strClassName.ReleaseBuffer();
	pReBar = (CReBar *) CReBar::FromHandlePermanent(pnmReBarChevron->hdr.hwndFrom);
	ASSERT(strClassName == REBARCLASSNAME && pReBar && pReBar->IsKindOf(RUNTIME_CLASS(CReBar)));
	if(strClassName == REBARCLASSNAME && pReBar && pReBar->IsKindOf(RUNTIME_CLASS(CReBar)))
	{
		// Make sure it's our rebar
		CFrameWnd *pFrameWnd = pReBar->GetParentFrame();
		if(pFrameWnd && this != pFrameWnd)
			return pFrameWnd->OnChevronPushed(id, pnm, pResult);

		// Yep, it's ours
		REBARBANDINFO BandInfo;
		IMAGEINFO ImageInfo;
		MENUITEMINFO MenuInfo;
		CRect rcBand, rcBtn, rcInt;
		DWORD dwBtnCount, i, nItemCount;
		CChevronOwnerDrawMenu menu;
		CString strRes, strMenu;
		UINT nID, nStyle;
		int iImage;
		CImageList *imgActive;
		CDC dcDest;
		CClientDC dcClient(this);
		CPoint pt(0, 0);

		BandInfo.cbSize = pReBar->GetReBarBandInfoSize();
		BandInfo.fMask = RBBIM_CHILD;

		pReBar->GetReBarCtrl().GetBandInfo(pnmReBarChevron->uBand, &BandInfo);
		pReBar->GetReBarCtrl().GetRect(pnmReBarChevron->uBand, &rcBand);

		nLen = ::lstrlen(TOOLBARCLASSNAME) + 1;
		::GetClassName(BandInfo.hwndChild, strClassName.GetBuffer(nLen), nLen);
		strClassName.ReleaseBuffer();
		pToolBar = (CToolBar *) CToolBar::FromHandlePermanent(BandInfo.hwndChild);
		ASSERT(strClassName == TOOLBARCLASSNAME && pToolBar && pToolBar->IsKindOf(RUNTIME_CLASS(CToolBar)));
		if(strClassName == TOOLBARCLASSNAME && pToolBar && pToolBar->IsKindOf(RUNTIME_CLASS(CToolBar)))
		{
			rcBand.right = pnmReBarChevron->rc.left;
			pReBar->ClientToScreen(&rcBand);
			pToolBar->ScreenToClient(&rcBand);

			i = dwBtnCount = pToolBar->GetToolBarCtrl().GetButtonCount();
			do
			{
				i--;
				pToolBar->GetToolBarCtrl().GetItemRect(i, &rcBtn);
			}
			while(!rcInt.IntersectRect(rcBand, rcBtn) && i > 0);

			ZeroMemory(&MenuInfo, sizeof(MENUITEMINFO));
			MenuInfo.cbSize = sizeof(MENUITEMINFO);

			imgActive = pToolBar->GetToolBarCtrl().GetImageList();
			CTypedPtrArray<CObArray, CBitmap*> bmp;
			bmp.SetSize(dwBtnCount - i);

			menu.CreatePopupMenu();
			dcDest.CreateCompatibleDC(&dcClient);

			nItemCount = 0;
			for(; i < dwBtnCount; i++)
			{
				pToolBar->GetButtonInfo(i, nID, nStyle, iImage);
				if(!(nStyle & BTNS_SEP))
				{
					MenuInfo.fMask = MIIM_FTYPE | MIIM_ID | MIIM_DATA | MIIM_STRING;

					// Menu Text
					if (strRes.LoadString(nID))
					{
						AfxExtractSubString(strMenu, strRes, 1, _T('\n'));
					}
					else
					{
						strMenu.Empty();
					}

					// Menu Bitmap
					bmp.SetAtGrow(nItemCount,new CBitmap);
					if (imgActive != NULL && imgActive->GetImageInfo(iImage, &ImageInfo)!= 0)
					{
						CRect rc(ImageInfo.rcImage);
						rc.OffsetRect(-rc.TopLeft());
						bmp[nItemCount]->CreateCompatibleBitmap(&dcClient, rc.right, rc.bottom);
						bmp[nItemCount] = dcDest.SelectObject(bmp[nItemCount]);
						dcDest.FillSolidRect(rc, ::GetSysColor(COLOR_MENU));
						imgActive->Draw(&dcDest, iImage, pt, ILD_TRANSPARENT);
						bmp[nItemCount] = dcDest.SelectObject(bmp[nItemCount]);

						//set the info
						MenuInfo.dwItemData = (ULONG_PTR) bmp[nItemCount];
					}
					else
					{
						// dont set the info
						MenuInfo.dwItemData = (ULONG_PTR) 0;
					}

					// Set the info
					MenuInfo.dwTypeData = const_cast<LPTSTR>(static_cast<LPCTSTR>(strMenu));
					MenuInfo.wID = nID;
					MenuInfo.fType = MFT_OWNERDRAW;

					nItemCount++;
				}
				else
				{
					// don't add a separator as the first item in the menu
					if(nItemCount == 0)
						continue;

					MenuInfo.fMask = MIIM_FTYPE;
					MenuInfo.fType = MFT_SEPARATOR;
				}
				menu.InsertMenuItem(i, &MenuInfo, TRUE);
			}

			CRect rc = pnmReBarChevron->rc;
			ClientToScreen(&rc);
			menu.TrackPopupMenu(TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON, 
				rc.left, rc.bottom, this);

			*pResult = 0;
			for(i = 0; i < nItemCount; i++)
				delete bmp[i];

			return TRUE;
		}
	}
	return FALSE;
}

void CFrameWnd::ActivateFrame(int nCmdShow)
	// nCmdShow is the normal show mode this frame should be in
{
	// translate default nCmdShow (-1)
	if (nCmdShow == -1)
	{
		if (!IsWindowVisible())
			nCmdShow = SW_SHOWNORMAL;
		else if (IsIconic())
			nCmdShow = SW_RESTORE;
	}

	// bring to top before showing
	BringToTop(nCmdShow);

	if (nCmdShow != -1)
	{
		// show the window as specified
		ShowWindow(nCmdShow);

		// and finally, bring to top after showing
		BringToTop(nCmdShow);
	}
}

void CFrameWnd::BringToTop(int nCmdShow)
{
	// place the window on top except for certain nCmdShow
	if (nCmdShow != SW_HIDE &&
		nCmdShow != SW_MINIMIZE && nCmdShow != SW_SHOWMINNOACTIVE &&
		nCmdShow != SW_SHOWNA && nCmdShow != SW_SHOWNOACTIVATE)
	{
		// if no last active popup, it will return m_hWnd
		HWND hWndLastPop = ::GetLastActivePopup(m_hWnd);
		::BringWindowToTop(hWndLastPop);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd Diagnostics

#ifdef _DEBUG
void CFrameWnd::AssertValid() const
{
	CWnd::AssertValid();
	if (m_pViewActive != NULL)
		ASSERT_VALID(m_pViewActive);
}

void CFrameWnd::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);

	dc << "m_hAccelTable = " << (void*)m_hAccelTable;
	dc << "\nm_nWindow = " << m_nWindow;
	dc << "\nm_nIDHelp = " << m_nIDHelp;
	dc << "\nm_nIDTracking = " << m_nIDTracking;
	dc << "\nm_nIDLastMessage = " << m_nIDLastMessage;
	if (m_pViewActive != NULL)
		dc << "\nwith active view: " << m_pViewActive;
	else
		dc << "\nno active view";

	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CControlBar segmentation

CFrameWnd* CControlBar::GetDockingFrame() const
{
	CFrameWnd* pFrameWnd = GetParentFrame();
	if (pFrameWnd == NULL)
		pFrameWnd = m_pDockSite;

	ASSERT(pFrameWnd != NULL);
	ASSERT_KINDOF(CFrameWnd, pFrameWnd);
	return pFrameWnd;
}

BOOL CControlBar::IsFloating() const
{
	if (IsDockBar())
		return ((CDockBar*)this)->m_bFloating;
	else
		return m_pDockBar != NULL && m_pDockBar->m_bFloating;
}


// in this file for IsKindOf library granularity (IsKindOf references these)
IMPLEMENT_DYNCREATE(CFrameWnd, CWnd)
IMPLEMENT_DYNAMIC(CView, CWnd)
IMPLEMENT_DYNAMIC(CControlBar, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd implementation of hide/unhide menu bar to confirm to Windows 
// Vista Experience

void CFrameWnd::SetMenuBarVisibility(DWORD dwStyle)
{
	ENSURE_ARG(dwStyle == AFX_MBV_KEEPVISIBLE ||
			dwStyle == AFX_MBV_DISPLAYONFOCUS ||
			dwStyle == (AFX_MBV_DISPLAYONFOCUS | AFX_MBV_DISPLAYONF10));

	if (m_dwMenuBarVisibility != dwStyle)
		switch (dwStyle)
		{
		case AFX_MBV_KEEPVISIBLE:
			m_dwMenuBarVisibility = dwStyle;
			SetMenuBarState(AFX_MBS_VISIBLE);
			break;
		case AFX_MBV_DISPLAYONFOCUS:
		case AFX_MBV_DISPLAYONFOCUS | AFX_MBV_DISPLAYONF10:		
			m_dwMenuBarVisibility = dwStyle;
			SetMenuBarState(AFX_MBS_HIDDEN);
			break;
		default:
			ASSERT(FALSE);
		}
}

DWORD CFrameWnd::GetMenuBarVisibility() const
{
	return m_dwMenuBarVisibility;
}

BOOL CFrameWnd::SetMenuBarState(DWORD dwState)
{
	ENSURE_ARG(dwState == AFX_MBS_VISIBLE ||
				dwState == AFX_MBS_HIDDEN);

	if (m_dwMenuBarState == dwState)
	{
		return FALSE;
	}

	if (dwState == AFX_MBS_VISIBLE)
	{
		OnShowMenuBar();
		::SetMenu(m_hWnd, m_hMenu);
	}
	else
	{
		m_hMenu = ::GetMenu(m_hWnd);
		OnHideMenuBar();
		::SetMenu(m_hWnd, NULL);
	}

	m_dwMenuBarState = dwState;
	return TRUE;
}

DWORD CFrameWnd::GetMenuBarState() const
{
	return m_dwMenuBarState;
}

void CFrameWnd::OnShowMenuBar()
{
	return ;
}

void CFrameWnd::OnHideMenuBar()
{
	return ;
}

LRESULT CFrameWnd::OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu)
{
	if (m_bTempShowMenu)
	{
		m_bTempShowMenu = FALSE;
		if ((m_dwMenuBarVisibility & AFX_MBV_KEEPVISIBLE) == 0)
		{
			SetMenuBarState(AFX_MBS_HIDDEN);
		}
	}
	return CWnd::OnMenuChar(nChar, nFlags, pMenu);
}

CMenu* CFrameWnd::GetMenu() const
{
	ASSERT(::IsWindow(m_hWnd));
	if (m_dwMenuBarState == AFX_MBS_VISIBLE)
	{
		return CMenu::FromHandle(::GetMenu(m_hWnd));
	}
	else
	{
		ENSURE(m_dwMenuBarState == AFX_MBS_HIDDEN);
		return CMenu::FromHandle(m_hMenu);
	}	
}

BOOL CFrameWnd::SetMenu(CMenu* pMenu)
{
	ASSERT(::IsWindow(m_hWnd));
	if (m_dwMenuBarState == AFX_MBS_VISIBLE)
	{
		return ::SetMenu(m_hWnd, pMenu->GetSafeHmenu());
	}
	else
	{
		ENSURE(m_dwMenuBarState == AFX_MBS_HIDDEN);
		m_hMenu = pMenu->GetSafeHmenu();
		return TRUE;
	}
}

BOOL CFrameWnd::GetMenuBarInfo(LONG idObject, LONG idItem, PMENUBARINFO pmbi) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pmbi != NULL);
	if (m_dwMenuBarState == AFX_MBS_HIDDEN && idObject == OBJID_MENU)
	{
		CFrameWnd* pFrameWnd = new CFrameWnd;
		ENSURE(pFrameWnd->Create(NULL, NULL));
		ENSURE(::SetMenu(pFrameWnd->m_hWnd, m_hMenu));
		BOOL bResult = ::GetMenuBarInfo(pFrameWnd->m_hWnd, idObject, idItem, pmbi);
		ENSURE(::SetMenu(pFrameWnd->m_hWnd, NULL));
		ENSURE(pFrameWnd->DestroyWindow());

		return bResult;
	}
	
	return ::GetMenuBarInfo(m_hWnd, idObject, idItem, pmbi);
}
/////////////////////////////////////////////////////////////////////////////
#if (WINVER >= 0x0601)
void CFrameWnd::SetProgressBarRange(int nRangeMin, int nRangeMax)
{
	m_nProgressBarRangeMin = nRangeMin;
	m_nProgressBarRangeMax = nRangeMax;
}
void CFrameWnd::SetProgressBarPosition(int nProgressPos)
{
	ASSERT_VALID(this);

	if (!afxGlobalData.bIsWindows7)
	{
		return;
	}

	ITaskbarList3* pTaskbarList = afxGlobalData.GetITaskbarList3();
	ENSURE(pTaskbarList != NULL);

	pTaskbarList->SetProgressValue(GetSafeHwnd(), nProgressPos - m_nProgressBarRangeMin, 
		m_nProgressBarRangeMax - m_nProgressBarRangeMin);
}
void CFrameWnd::SetProgressBarState(TBPFLAG tbpFlags)
{
	ASSERT(::IsWindow(m_hWnd)); 

	if (!afxGlobalData.bIsWindows7)
	{
		return;
	}

	ITaskbarList3* pTaskbarList = afxGlobalData.GetITaskbarList3();
	ENSURE(pTaskbarList != NULL);

	pTaskbarList->SetProgressState(GetSafeHwnd(), tbpFlags);
}
BOOL CFrameWnd::SetTaskbarOverlayIcon(UINT nIDResource, LPCTSTR lpcszDescr)
{
	ASSERT(::IsWindow(m_hWnd));

	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}

	HICON hIcon = (HICON) LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(nIDResource), 
		IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);

	if (hIcon == NULL)
	{
		TRACE1("Can't load image from the resource with ID %d.", nIDResource);
		return FALSE;
	}

	BOOL bResult = SetTaskbarOverlayIcon(hIcon, lpcszDescr);
	DestroyIcon(hIcon);

	return bResult;
}
BOOL CFrameWnd::SetTaskbarOverlayIcon(HICON hIcon, LPCTSTR lpcszDescr)
{
	ASSERT(::IsWindow(m_hWnd));

	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}

	ITaskbarList3* pTaskbarList = afxGlobalData.GetITaskbarList3();
	ENSURE(pTaskbarList != NULL);

	// TODO uncomment lpcszDescr for latest SDK

#ifdef UNICODE
	return SUCCEEDED(pTaskbarList->SetOverlayIcon(GetSafeHwnd(), hIcon, lpcszDescr));
#else
	USES_CONVERSION;
	LPWSTR lpwszDescr = A2W(lpcszDescr);
	return SUCCEEDED(pTaskbarList->SetOverlayIcon(GetSafeHwnd(), hIcon, lpwszDescr));
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\wingdi.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Diagnostic Output
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, SIZE size)
{
	return dc << "(" << size.cx << " x " << size.cy << ")";
}

CDumpContext& AFXAPI operator<<(CDumpContext& dc, POINT point)
{
	return dc << "(" << point.x << ", " << point.y << ")";
}

CDumpContext& AFXAPI operator<<(CDumpContext& dc, const RECT& rect)
{
	return dc << "(L " << rect.left << ", T " << rect.top << ", R " <<
		rect.right << ", B " << rect.bottom << ")";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDC

CDC::CDC()
{
	m_hDC = NULL;
	m_hAttribDC = NULL;
	m_bPrinting = FALSE;
}

#ifdef _DEBUG
void CDC::AssertValid() const
{
	CObject::AssertValid();
}

void CDC::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_hDC = " << m_hDC;
	dc << "\nm_hAttribDC = " << m_hAttribDC;
	dc << "\nm_bPrinting = " << m_bPrinting;

	dc << "\n";
}
#endif //_DEBUG

CHandleMap* PASCAL afxMapHDC(BOOL bCreate)
{
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	if (pState->m_pmapHDC == NULL && bCreate)
	{
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
#ifndef _AFX_PORTABLE
		_PNH pnhOldHandler = AfxSetNewHandler(&AfxCriticalNewHandler);
#endif
		pState->m_pmapHDC = new CHandleMap(RUNTIME_CLASS(CDC),
			ConstructDestruct<CDC>::Construct, ConstructDestruct<CDC>::Destruct, 
			offsetof(CDC, m_hDC), 2);

#ifndef _AFX_PORTABLE
		AfxSetNewHandler(pnhOldHandler);
#endif
		AfxEnableMemoryTracking(bEnable);
	}
	return pState->m_pmapHDC;
}

CDC* PASCAL CDC::FromHandle(HDC hDC)
{
	CHandleMap* pMap = afxMapHDC(TRUE); //create map if not exist
	ASSERT(pMap != NULL);
	CDC* pDC = (CDC*)pMap->FromHandle(hDC);
	ASSERT(pDC == NULL || pDC->m_hDC == hDC);
	return pDC;
}

BOOL CDC::Attach(HDC hDC)
{
	ASSERT(m_hDC == NULL);      // only attach once, detach on destroy
	ASSERT(m_hAttribDC == NULL);    // only attach to an empty DC

	if (hDC == NULL)
	{
		return FALSE;
	}
	// remember early to avoid leak
	m_hDC = hDC;
	CHandleMap* pMap = afxMapHDC(TRUE); // create map if not exist
	ASSERT(pMap != NULL);
	pMap->SetPermanent(m_hDC, this);

	SetAttribDC(m_hDC);     // Default to same as output
	return TRUE;
}

HDC CDC::Detach()
{
	HDC hDC = m_hDC;
	if (hDC != NULL)
	{
		CHandleMap* pMap = afxMapHDC(); // don't create if not exist
		if (pMap != NULL)
			pMap->RemoveHandle(m_hDC);
	}

	ReleaseAttribDC();
	m_hDC = NULL;
	return hDC;
}

BOOL CDC::DeleteDC()
{
	if (m_hDC == NULL)
		return FALSE;

	return ::DeleteDC(Detach());
}

CDC::~CDC()
{
	if (m_hDC != NULL)
		::DeleteDC(Detach());
}


void CDC::SetAttribDC(HDC hDC)  // Set the Attribute DC
{
	m_hAttribDC = hDC;
}

void CDC::SetOutputDC(HDC hDC)  // Set the Output DC
{
#ifdef _DEBUG
	CHandleMap* pMap = afxMapHDC();
	if (pMap != NULL && pMap->LookupPermanent(m_hDC) == this)
	{
		TRACE(traceAppMsg, 0, "Cannot Set Output hDC on Attached CDC.\n");
		ASSERT(FALSE);
	}
#endif
	m_hDC = hDC;
}

void CDC::ReleaseAttribDC()     // Release the Attribute DC
{
	m_hAttribDC = NULL;
}

void CDC::ReleaseOutputDC()     // Release the Output DC
{
#ifdef _DEBUG
	CHandleMap* pMap = afxMapHDC();
	if (pMap != NULL && pMap->LookupPermanent(m_hDC) == this)
	{
		TRACE(traceAppMsg, 0, "Cannot Release Output hDC on Attached CDC.\n");
		ASSERT(FALSE);
	}
#endif
	m_hDC = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// Out-of-line routines

int CDC::StartDoc(LPCTSTR lpszDocName)
{
	DOCINFO di;
	memset(&di, 0, sizeof(DOCINFO));
	di.cbSize = sizeof(DOCINFO);
	di.lpszDocName = lpszDocName;
	return StartDoc(&di);
}

int CDC::SaveDC()
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0;
	if (m_hAttribDC != NULL)
		nRetVal = ::SaveDC(m_hAttribDC);
	if (m_hDC != m_hAttribDC && ::SaveDC(m_hDC) != 0)
		nRetVal = -1;   // -1 is the only valid restore value for complex DCs
	return nRetVal;
}

BOOL CDC::RestoreDC(int nSavedDC)
{
	// if two distinct DCs, nSavedDC can only be -1
	ASSERT(m_hDC != NULL);
	ASSERT(m_hDC == m_hAttribDC || nSavedDC == -1);

	BOOL bRetVal = TRUE;
	if (m_hDC != m_hAttribDC)
		bRetVal = ::RestoreDC(m_hDC, nSavedDC);
	if (m_hAttribDC != NULL)
		bRetVal = (bRetVal && ::RestoreDC(m_hAttribDC, nSavedDC));
	return bRetVal;
}

CGdiObject* PASCAL CDC::SelectGdiObject(HDC hDC, HGDIOBJ h)
{
	return CGdiObject::FromHandle(::SelectObject(hDC, h));
}

CGdiObject* CDC::SelectStockObject(int nIndex)
{
	ASSERT(m_hDC != NULL);

	HGDIOBJ hObject = ::GetStockObject(nIndex);
	HGDIOBJ hOldObj = NULL;

	ASSERT(hObject != NULL);
	if (m_hDC != m_hAttribDC)
		hOldObj = ::SelectObject(m_hDC, hObject);
	if (m_hAttribDC != NULL)
		hOldObj = ::SelectObject(m_hAttribDC, hObject);
	return CGdiObject::FromHandle(hOldObj);
}

CPen* CDC::SelectObject(CPen* pPen)
{
	ASSERT(m_hDC != NULL);
	HGDIOBJ hOldObj = NULL;

	if (m_hDC != m_hAttribDC)
		hOldObj = ::SelectObject(m_hDC, pPen->GetSafeHandle());
	if (m_hAttribDC != NULL)
		hOldObj = ::SelectObject(m_hAttribDC, pPen->GetSafeHandle());
	return (CPen*)CGdiObject::FromHandle(hOldObj);
}

CBrush* CDC::SelectObject(CBrush* pBrush)
{
	ASSERT(m_hDC != NULL);
	HGDIOBJ hOldObj = NULL;

	if (m_hDC != m_hAttribDC)
		hOldObj = ::SelectObject(m_hDC, pBrush->GetSafeHandle());
	if (m_hAttribDC != NULL)
		hOldObj = ::SelectObject(m_hAttribDC, pBrush->GetSafeHandle());
	return (CBrush*)CGdiObject::FromHandle(hOldObj);
}

CFont* CDC::SelectObject(CFont* pFont)
{
	ASSERT(m_hDC != NULL);
	HGDIOBJ hOldObj = NULL;

	if (m_hDC != m_hAttribDC)
		hOldObj = ::SelectObject(m_hDC, pFont->GetSafeHandle());
	if (m_hAttribDC != NULL)
		hOldObj = ::SelectObject(m_hAttribDC, pFont->GetSafeHandle());
	return (CFont*)CGdiObject::FromHandle(hOldObj);
}

int CDC::SelectObject(CRgn* pRgn)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = GDI_ERROR;

	if (m_hDC != m_hAttribDC)
		nRetVal = (int)(INT_PTR)::SelectObject(m_hDC, pRgn->GetSafeHandle());
	if (m_hAttribDC != NULL)
		nRetVal = (int)(INT_PTR)::SelectObject(m_hAttribDC, pRgn->GetSafeHandle());
	return nRetVal;
}

CPalette* CDC::SelectPalette(CPalette* pPalette, BOOL bForceBackground)
{
	ASSERT(m_hDC != NULL);

	return (CPalette*) CGdiObject::FromHandle(::SelectPalette(m_hDC,
		(HPALETTE)pPalette->GetSafeHandle(), bForceBackground));
}

COLORREF CDC::SetBkColor(COLORREF crColor)
{
	ASSERT(m_hDC != NULL);
	COLORREF crRetVal = CLR_INVALID;

	if (m_hDC != m_hAttribDC)
		crRetVal = ::SetBkColor(m_hDC, crColor);
	if (m_hAttribDC != NULL)
		crRetVal = ::SetBkColor(m_hAttribDC, crColor);
	return crRetVal;
}

int CDC::SetBkMode(int nBkMode)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::SetBkMode(m_hDC, nBkMode);
	if (m_hAttribDC != NULL)
		nRetVal = ::SetBkMode(m_hAttribDC, nBkMode);
	return nRetVal;
}

int CDC::SetPolyFillMode(int nPolyFillMode)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::SetPolyFillMode(m_hDC, nPolyFillMode);
	if (m_hAttribDC != NULL)
		nRetVal = ::SetPolyFillMode(m_hAttribDC, nPolyFillMode);
	return nRetVal;
}

int CDC::SetROP2(int nDrawMode)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::SetROP2(m_hDC, nDrawMode);
	if (m_hAttribDC != NULL)
		nRetVal = ::SetROP2(m_hAttribDC, nDrawMode);
	return nRetVal;
}

int CDC::SetStretchBltMode(int nStretchMode)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::SetStretchBltMode(m_hDC, nStretchMode);
	if (m_hAttribDC != NULL)
		nRetVal = ::SetStretchBltMode(m_hAttribDC, nStretchMode);
	return nRetVal;
}

COLORREF CDC::SetTextColor(COLORREF crColor)
{
	ASSERT(m_hDC != NULL);
	COLORREF crRetVal = CLR_INVALID;

	if (m_hDC != m_hAttribDC)
		crRetVal = ::SetTextColor(m_hDC, crColor);
	if (m_hAttribDC != NULL)
		crRetVal = ::SetTextColor(m_hAttribDC, crColor);
	return crRetVal;
}

int CDC::SetGraphicsMode(int iMode)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0;

	if (m_hDC != m_hAttribDC)
	{
		nRetVal = ::SetGraphicsMode(m_hDC, iMode);
	}

	if (m_hAttribDC != NULL)
	{
		nRetVal = ::SetGraphicsMode(m_hAttribDC, iMode);
	}

	return nRetVal;
}

BOOL CDC::SetWorldTransform(const XFORM* pXform)
{
	ASSERT(m_hDC != NULL);
	BOOL nRetVal = 0;

	if (m_hDC != m_hAttribDC)
	{
		nRetVal = ::SetWorldTransform(m_hDC, pXform);
	}

	if (m_hAttribDC != NULL)
	{
		nRetVal = ::SetWorldTransform(m_hAttribDC, pXform);
	}

	return nRetVal;
}

BOOL CDC::ModifyWorldTransform(const XFORM* pXform,DWORD iMode)
{
	ASSERT(m_hDC != NULL);
	BOOL nRetVal = 0;

	if (m_hDC != m_hAttribDC)
	{
		nRetVal = ::ModifyWorldTransform(m_hDC, pXform, iMode);
	}

	if (m_hAttribDC != NULL)
	{
		nRetVal = ::ModifyWorldTransform(m_hAttribDC, pXform, iMode);
	}

	return nRetVal;
}

int CDC::SetMapMode(int nMapMode)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::SetMapMode(m_hDC, nMapMode);
	if (m_hAttribDC != NULL)
		nRetVal = ::SetMapMode(m_hAttribDC, nMapMode);
	return nRetVal;
}

CPoint CDC::SetViewportOrg(int x, int y)
{
	ASSERT(m_hDC != NULL);
	CPoint point;

	if (m_hDC != m_hAttribDC)
		VERIFY(::SetViewportOrgEx(m_hDC, x, y, &point));
	if (m_hAttribDC != NULL)
		VERIFY(::SetViewportOrgEx(m_hAttribDC, x, y, &point));
	return point;
}

CPoint CDC::OffsetViewportOrg(int nWidth, int nHeight)
{
	ASSERT(m_hDC != NULL);
	CPoint point;

	if (m_hDC != m_hAttribDC)
		VERIFY(::OffsetViewportOrgEx(m_hDC, nWidth, nHeight, &point));
	if (m_hAttribDC != NULL)
		VERIFY(::OffsetViewportOrgEx(m_hAttribDC, nWidth, nHeight, &point));
	return point;
}

CSize CDC::SetViewportExt(int x, int y)
{
	ASSERT(m_hDC != NULL);
	CSize size;

	if (m_hDC != m_hAttribDC)
		VERIFY(::SetViewportExtEx(m_hDC, x, y, &size));
	if (m_hAttribDC != NULL)
		VERIFY(::SetViewportExtEx(m_hAttribDC, x, y, &size));
	return size;
}

CSize CDC::ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom)
{
	ASSERT(m_hDC != NULL);
	CSize size;

	if (m_hDC != m_hAttribDC)
		VERIFY(::ScaleViewportExtEx(m_hDC, xNum, xDenom, yNum, yDenom, &size));
	if (m_hAttribDC != NULL)
		VERIFY(::ScaleViewportExtEx(m_hAttribDC, xNum, xDenom, yNum, yDenom, &size));
	return size;
}

CPoint CDC::SetWindowOrg(int x, int y)
{
	ASSERT(m_hDC != NULL);
	CPoint point;

	if (m_hDC != m_hAttribDC)
		VERIFY(::SetWindowOrgEx(m_hDC, x, y, &point));
	if (m_hAttribDC != NULL)
		VERIFY(::SetWindowOrgEx(m_hAttribDC, x, y, &point));
	return point;
}

CPoint CDC::OffsetWindowOrg(int nWidth, int nHeight)
{
	ASSERT(m_hDC != NULL);
	CPoint point;

	if (m_hDC != m_hAttribDC)
		VERIFY(::OffsetWindowOrgEx(m_hDC, nWidth, nHeight, &point));
	if (m_hAttribDC != NULL)
		VERIFY(::OffsetWindowOrgEx(m_hAttribDC, nWidth, nHeight, &point));
	return point;
}

CSize CDC::SetWindowExt(int x, int y)
{
	ASSERT(m_hDC != NULL);
	CSize size;

	if (m_hDC != m_hAttribDC)
		VERIFY(::SetWindowExtEx(m_hDC, x, y, &size));
	if (m_hAttribDC != NULL)
		VERIFY(::SetWindowExtEx(m_hAttribDC, x, y, &size));
	return size;
}

CSize CDC::ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom)
{
	ASSERT(m_hDC != NULL);
	CSize size;

	if (m_hDC != m_hAttribDC)
		VERIFY(::ScaleWindowExtEx(m_hDC, xNum, xDenom, yNum, yDenom, &size));
	if (m_hAttribDC != NULL)
		VERIFY(::ScaleWindowExtEx(m_hAttribDC, xNum, xDenom, yNum, yDenom, &size));
	return size;
}

int CDC::GetClipBox(LPRECT lpRect) const
{
	ASSERT(m_hDC != NULL);
	return ::GetClipBox(m_hDC, lpRect);
}

int CDC::SelectClipRgn(CRgn* pRgn)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = ERROR;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::SelectClipRgn(m_hDC, (HRGN)pRgn->GetSafeHandle());
	if (m_hAttribDC != NULL)
		nRetVal = ::SelectClipRgn(m_hAttribDC, (HRGN)pRgn->GetSafeHandle());
	return nRetVal;
}

int CDC::ExcludeClipRect(int x1, int y1, int x2, int y2)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = ERROR;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::ExcludeClipRect(m_hDC, x1, y1, x2, y2);
	if (m_hAttribDC != NULL)
		nRetVal = ::ExcludeClipRect(m_hAttribDC, x1, y1, x2, y2);
	return nRetVal;
}

int CDC::ExcludeClipRect(LPCRECT lpRect)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = ERROR;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::ExcludeClipRect(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom);
	if (m_hAttribDC != NULL)
		nRetVal = ::ExcludeClipRect(m_hAttribDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom);
	return nRetVal;
}

int CDC::IntersectClipRect(int x1, int y1, int x2, int y2)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = ERROR;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::IntersectClipRect(m_hDC, x1, y1, x2, y2);
	if (m_hAttribDC != NULL)
		nRetVal = ::IntersectClipRect(m_hAttribDC, x1, y1, x2, y2);
	return nRetVal;
}

int CDC::IntersectClipRect(LPCRECT lpRect)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = ERROR;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::IntersectClipRect(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom);
	if (m_hAttribDC != NULL)
		nRetVal = ::IntersectClipRect(m_hAttribDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom);
	return nRetVal;
}

int CDC::OffsetClipRgn(int x, int y)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = ERROR;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::OffsetClipRgn(m_hDC, x, y);
	if (m_hAttribDC != NULL)
		nRetVal = ::OffsetClipRgn(m_hAttribDC, x, y);
	return nRetVal;
}

int CDC::OffsetClipRgn(SIZE size)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = ERROR;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::OffsetClipRgn(m_hDC, size.cx, size.cy);
	if (m_hAttribDC != NULL)
		nRetVal = ::OffsetClipRgn(m_hAttribDC, size.cx, size.cy);
	return nRetVal;
}

CPoint CDC::MoveTo(int x, int y)
{
	ASSERT(m_hDC != NULL);
	CPoint point;

	if (m_hDC != m_hAttribDC)
		VERIFY(::MoveToEx(m_hDC, x, y, &point));
	if (m_hAttribDC != NULL)
		VERIFY(::MoveToEx(m_hAttribDC, x, y, &point));
	return point;
}

BOOL CDC::LineTo(int x, int y)
{
	ASSERT(m_hDC != NULL);
	if (m_hAttribDC != NULL && m_hDC != m_hAttribDC)
		::MoveToEx(m_hAttribDC, x, y, NULL);
	return ::LineTo(m_hDC, x, y);
}

UINT CDC::SetTextAlign(UINT nFlags)
{
	ASSERT(m_hDC != NULL);
	UINT nRetVal = GDI_ERROR;

	if (m_hDC != m_hAttribDC)
		::SetTextAlign(m_hDC, nFlags);
	if (m_hAttribDC != NULL)
		nRetVal = ::SetTextAlign(m_hAttribDC, nFlags);
	return nRetVal;
}

int CDC::SetTextJustification(int nBreakExtra, int nBreakCount)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0;

	if (m_hDC != m_hAttribDC)
		nRetVal = ::SetTextJustification(m_hDC, nBreakExtra, nBreakCount);
	if (m_hAttribDC != NULL)
		nRetVal = ::SetTextJustification(m_hAttribDC, nBreakExtra, nBreakCount);
	return nRetVal;
}

int CDC::SetTextCharacterExtra(int nCharExtra)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = 0x8000000;
	if (m_hDC != m_hAttribDC)
		nRetVal = ::SetTextCharacterExtra(m_hDC, nCharExtra);
	if (m_hAttribDC != NULL)
		nRetVal = ::SetTextCharacterExtra(m_hAttribDC, nCharExtra);
	return nRetVal;
}

DWORD CDC::SetMapperFlags(DWORD dwFlag)
{
	ASSERT(m_hDC != NULL);
	DWORD dwRetVal = GDI_ERROR;
	if (m_hDC != m_hAttribDC)
		dwRetVal = ::SetMapperFlags(m_hDC, dwFlag);
	if (m_hAttribDC != NULL)
		dwRetVal = ::SetMapperFlags(m_hAttribDC, dwFlag);
	return dwRetVal;
}

DWORD CDC::GetLayout() const
{
	ASSERT(m_hDC != NULL);

	DWORD dwGetLayout = ::GetLayout(m_hDC);

	return dwGetLayout;
}

DWORD CDC::SetLayout(DWORD dwSetLayout)
{
	ASSERT(m_hDC != NULL);

	DWORD dwGetLayout = ::SetLayout(m_hDC, dwSetLayout);

	return dwGetLayout;
}

void CWnd::ScreenToClient(LPRECT lpRect) const
{
	ASSERT(::IsWindow(m_hWnd));
	::ScreenToClient(m_hWnd, (LPPOINT)lpRect);
	::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1);
	if (GetExStyle() & WS_EX_LAYOUTRTL)
		CRect::SwapLeftRight(lpRect);
}

void CWnd::ClientToScreen(LPRECT lpRect) const
{
	ASSERT(::IsWindow(m_hWnd));
	::ClientToScreen(m_hWnd, (LPPOINT)lpRect);
	::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1);
	if (GetExStyle() & WS_EX_LAYOUTRTL)
		CRect::SwapLeftRight(lpRect);
}

/////////////////////////////////////////////////////////////////////////////
// Advanced Win32 GDI functions

BOOL CDC::ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
{
	ASSERT(m_hDC != NULL);
	BOOL bResult = ::ArcTo(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	if (m_hDC != m_hAttribDC)
	{
		CPoint pt;
		VERIFY(::GetCurrentPositionEx(m_hDC, &pt));
		VERIFY(::MoveToEx(m_hAttribDC, pt.x, pt.y, NULL));
	}
	return bResult;
}

int CDC::SetArcDirection(int nArcDirection)
{
	ASSERT(m_hDC != NULL);
	int nResult = 0;
	if (m_hDC != m_hAttribDC)
		nResult = ::SetArcDirection(m_hDC, nArcDirection);
	if (m_hAttribDC != NULL)
		nResult = ::SetArcDirection(m_hAttribDC, nArcDirection);
	return nResult;
}

BOOL CDC::PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount)
{
	ASSERT(m_hDC != NULL);
	BOOL bResult = ::PolyDraw(m_hDC, lpPoints, lpTypes, nCount);
	if (m_hDC != m_hAttribDC)
	{
		CPoint pt;
		VERIFY(::GetCurrentPositionEx(m_hDC, &pt));
		VERIFY(::MoveToEx(m_hAttribDC, pt.x, pt.y, NULL));
	}
	return bResult;
}

BOOL CDC::PolylineTo(const POINT* lpPoints, int nCount)
{
	ASSERT(m_hDC != NULL);
	BOOL bResult = ::PolylineTo(m_hDC, lpPoints, nCount);
	if (m_hDC != m_hAttribDC)
	{
		CPoint pt;
		VERIFY(::GetCurrentPositionEx(m_hDC, &pt));
		VERIFY(::MoveToEx(m_hAttribDC, pt.x, pt.y, NULL));
	}
	return bResult;
}

BOOL CDC::SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust)
{
	ASSERT(m_hDC != NULL);
	BOOL bResult = FALSE;
	if (m_hDC != m_hAttribDC)
		bResult = ::SetColorAdjustment(m_hDC, lpColorAdjust);
	if (m_hAttribDC != NULL)
		bResult = ::SetColorAdjustment(m_hAttribDC, lpColorAdjust);
	return bResult;
}

BOOL CDC::PolyBezierTo(const POINT* lpPoints, int nCount)
{
	ASSERT(m_hDC != NULL);
	BOOL bResult = ::PolyBezierTo(m_hDC, lpPoints, nCount);
	if (m_hDC != m_hAttribDC)
	{
		CPoint pt;
		VERIFY(::GetCurrentPositionEx(m_hDC, &pt));
		VERIFY(::MoveToEx(m_hAttribDC, pt.x, pt.y, NULL));
	}
	return bResult;
}

BOOL CDC::SelectClipPath(int nMode)
{
	ASSERT(m_hDC != NULL);

	// output DC always holds the current path
	if (!::SelectClipPath(m_hDC, nMode))
		return FALSE;

	// transfer clipping region into the attribute DC
	BOOL bResult = TRUE;
	if (m_hDC != m_hAttribDC)
	{
		HRGN hRgn = ::CreateRectRgn(0, 0, 0, 0);
		if (::GetClipRgn(m_hDC, hRgn) < 0 || !::SelectClipRgn(m_hAttribDC, hRgn))
		{
			TRACE(traceAppMsg, 0, "Error: unable to transfer clip region in CDC::SelectClipPath!\n");
			bResult = FALSE;
		}
		DeleteObject(hRgn);
	}
	return bResult;
}

int CDC::SelectClipRgn(CRgn* pRgn, int nMode)
{
	ASSERT(m_hDC != NULL);
	int nRetVal = ERROR;
	if (m_hDC != m_hAttribDC)
		nRetVal = ::ExtSelectClipRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), nMode);
	if (m_hAttribDC != NULL)
		nRetVal = ::ExtSelectClipRgn(m_hAttribDC, (HRGN)pRgn->GetSafeHandle(), nMode);
	return nRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// Special handling for metafile playback

int CALLBACK AfxEnumMetaFileProc(HDC hDC,
	HANDLETABLE* pHandleTable, METARECORD* pMetaRec, int nHandles, LPARAM lParam)
{
	CDC* pDC = (CDC*)lParam;
	ASSERT_VALID(pDC);

	switch (pMetaRec->rdFunction)
	{
	// these records have effects different for each CDC derived class
	case META_SETMAPMODE:
		pDC->SetMapMode((int)(short)pMetaRec->rdParm[0]);
		break;
	case META_SETWINDOWEXT:
		pDC->SetWindowExt(
			(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
		break;
	case META_SETWINDOWORG:
		pDC->SetWindowOrg(
			(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
		break;
	case META_SETVIEWPORTEXT:
		pDC->SetViewportExt(
			(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
		break;
	case META_SETVIEWPORTORG:
		pDC->SetViewportOrg(
			(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
		break;
	case META_SCALEWINDOWEXT:
		pDC->ScaleWindowExt(
			(int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
			(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
		break;
	case META_SCALEVIEWPORTEXT:
		pDC->ScaleViewportExt(
			(int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
			(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
		break;
	case META_OFFSETVIEWPORTORG:
		pDC->OffsetViewportOrg(
			(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
		break;
	case META_SAVEDC:
		pDC->SaveDC();
		break;
	case META_RESTOREDC:
		pDC->RestoreDC((int)(short)pMetaRec->rdParm[0]);
		break;
	case META_SETBKCOLOR:
		pDC->SetBkColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
		break;
	case META_SETTEXTCOLOR:
		pDC->SetTextColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
		break;

	// need to watch out for SelectObject(HFONT), for custom font mapping
	case META_SELECTOBJECT:
		{
			HGDIOBJ hObject = pHandleTable->objectHandle[pMetaRec->rdParm[0]];
			UINT nObjType = GetObjectType(hObject);
			if (nObjType == 0)
			{
				// object type is unknown, determine if it is a font
				HFONT hStockFont = (HFONT)::GetStockObject(SYSTEM_FONT);
				HFONT hFontOld = (HFONT)::SelectObject(pDC->m_hDC, hStockFont);
				HGDIOBJ hObjOld = ::SelectObject(pDC->m_hDC, hObject);
				if (hObjOld == hStockFont)
				{
					// got the stock object back, so must be selecting a font
					pDC->SelectObject(CFont::FromHandle((HFONT)hObject));
					break;  // don't play the default record
				}
				else
				{
					// didn't get the stock object back, so restore everything
					::SelectObject(pDC->m_hDC, hFontOld);
					::SelectObject(pDC->m_hDC, hObjOld);
				}
				// and fall through to PlayMetaFileRecord...
			}
			else if (nObjType == OBJ_FONT)
			{
				// play back as CDC::SelectObject(CFont*)
				pDC->SelectObject(CFont::FromHandle((HFONT)hObject));
				break;  // don't play the default record
			}
		}
		// fall through...

	default:
		::PlayMetaFileRecord(hDC, pHandleTable, pMetaRec, nHandles);
		break;
	}

	return 1;
}

BOOL CDC::PlayMetaFile(HMETAFILE hMF)
{
	if (::GetDeviceCaps(m_hDC, TECHNOLOGY) == DT_METAFILE)
	{
		// playing metafile in metafile, just use core windows API
		return ::PlayMetaFile(m_hDC, hMF);
	}

	// for special playback, lParam == pDC
	return ::EnumMetaFile(m_hDC, hMF, AfxEnumMetaFileProc, (LPARAM)this);
}

/////////////////////////////////////////////////////////////////////////////
// Coordinate transforms

void CDC::LPtoDP(LPSIZE lpSize) const
{
	ASSERT(AfxIsValidAddress(lpSize, sizeof(SIZE)));

	CSize sizeWinExt = GetWindowExt();
	CSize sizeVpExt = GetViewportExt();
	lpSize->cx = MulDiv(lpSize->cx, abs(sizeVpExt.cx), abs(sizeWinExt.cx));
	lpSize->cy = MulDiv(lpSize->cy, abs(sizeVpExt.cy), abs(sizeWinExt.cy));
}

void CDC::DPtoLP(LPSIZE lpSize) const
{
	ASSERT(AfxIsValidAddress(lpSize, sizeof(SIZE)));

	CSize sizeWinExt = GetWindowExt();
	CSize sizeVpExt = GetViewportExt();
	lpSize->cx = MulDiv(lpSize->cx, abs(sizeWinExt.cx), abs(sizeVpExt.cx));
	lpSize->cy = MulDiv(lpSize->cy, abs(sizeWinExt.cy), abs(sizeVpExt.cy));
}

/////////////////////////////////////////////////////////////////////////////
// Helper DCs

#ifdef _DEBUG
void CClientDC::AssertValid() const
{
	CDC::AssertValid();
	ASSERT(m_hWnd == NULL || ::IsWindow(m_hWnd));
}

void CClientDC::Dump(CDumpContext& dc) const
{
	CDC::Dump(dc);

	dc << "m_hWnd = " << m_hWnd;
	dc << "\n";
}
#endif

CClientDC::CClientDC(CWnd* pWnd)
{
	ASSERT(pWnd == NULL || ::IsWindow(pWnd->m_hWnd));

	if (!Attach(::GetDC(m_hWnd = pWnd->GetSafeHwnd())))
		AfxThrowResourceException();
}

CClientDC::~CClientDC()
{
	ASSERT(m_hDC != NULL);
	::ReleaseDC(m_hWnd, Detach());
}

#ifdef _DEBUG
void CWindowDC::AssertValid() const
{
	CDC::AssertValid();
	ASSERT(m_hWnd == NULL || ::IsWindow(m_hWnd));
}

void CWindowDC::Dump(CDumpContext& dc) const
{
	CDC::Dump(dc);

	dc << "m_hWnd = " << m_hWnd;
	dc << "\n";
}
#endif

CWindowDC::CWindowDC(CWnd* pWnd)
{
	ASSERT(pWnd == NULL || ::IsWindow(pWnd->m_hWnd));

	if (!Attach(::GetWindowDC(m_hWnd = pWnd->GetSafeHwnd())))
		AfxThrowResourceException();
}

CWindowDC::~CWindowDC()
{
	ASSERT(m_hDC != NULL);
	::ReleaseDC(m_hWnd, Detach());
}

#ifdef _DEBUG
void CPaintDC::AssertValid() const
{
	CDC::AssertValid();
	ASSERT(::IsWindow(m_hWnd));
}

void CPaintDC::Dump(CDumpContext& dc) const
{
	CDC::Dump(dc);

	dc << "m_hWnd = " << m_hWnd;
	dc << "\nm_ps.hdc = " << m_ps.hdc;
	dc << "\nm_ps.fErase = " << m_ps.fErase;
	dc << "\nm_ps.rcPaint = " << (CRect)m_ps.rcPaint;

	dc << "\n";
}
#endif

CPaintDC::CPaintDC(CWnd* pWnd)
{
	ASSERT_VALID(pWnd);
	ASSERT(::IsWindow(pWnd->m_hWnd));

	if (!Attach(::BeginPaint(m_hWnd = pWnd->m_hWnd, &m_ps)))
		AfxThrowResourceException();
}

CPaintDC::~CPaintDC()
{
	ASSERT(m_hDC != NULL);
	ASSERT(::IsWindow(m_hWnd));

	::EndPaint(m_hWnd, &m_ps);
	Detach();
}

/////////////////////////////////////////////////////////////////////////////
// CGdiObject

#ifdef _DEBUG
void CGdiObject::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_hObject = " << m_hObject;
	dc << "\n";
}

void CGdiObject::AssertValid() const
{
	CObject::AssertValid();
	ASSERT(m_hObject == NULL || ::GetObjectType(m_hObject) != 0);
}
#endif

CHandleMap* PASCAL afxMapHGDIOBJ(BOOL bCreate)
{
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	if (pState->m_pmapHGDIOBJ == NULL && bCreate)
	{
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
#ifndef _AFX_PORTABLE
		_PNH pnhOldHandler = AfxSetNewHandler(&AfxCriticalNewHandler);
#endif
		pState->m_pmapHGDIOBJ = new CHandleMap(RUNTIME_CLASS(CGdiObject),
			ConstructDestruct<CGdiObject>::Construct, ConstructDestruct<CGdiObject>::Destruct, 
			offsetof(CGdiObject, m_hObject));

#ifndef _AFX_PORTABLE
		AfxSetNewHandler(pnhOldHandler);
#endif
		AfxEnableMemoryTracking(bEnable);
	}
	return pState->m_pmapHGDIOBJ;
}

CGdiObject* PASCAL CGdiObject::FromHandle(HGDIOBJ h)
{
	CHandleMap* pMap = afxMapHGDIOBJ(TRUE); //create map if not exist
	ASSERT(pMap != NULL);
	CGdiObject* pObject = (CGdiObject*)pMap->FromHandle(h);
	ASSERT(pObject == NULL || pObject->m_hObject == h);
	return pObject;
}

BOOL CGdiObject::Attach(HGDIOBJ hObject)
{
	ASSERT(m_hObject == NULL);      // only attach once, detach on destroy
	if (hObject == NULL)
	{
		return FALSE;
	}
	// remember early to avoid leak
	m_hObject = hObject;
	CHandleMap* pMap = afxMapHGDIOBJ(TRUE); // create map if not exist
	ASSERT(pMap != NULL);
	pMap->SetPermanent(m_hObject, this);
	return TRUE;
}

HGDIOBJ CGdiObject::Detach()
{
	HGDIOBJ hObject = m_hObject;
	if (hObject != NULL)
	{
		CHandleMap* pMap = afxMapHGDIOBJ(); // don't create if not exist
		if (pMap != NULL)
			pMap->RemoveHandle(m_hObject);
	}

	m_hObject = NULL;
	return hObject;
}

BOOL CGdiObject::DeleteObject()
{
	if (m_hObject == NULL)
		return FALSE;
	return ::DeleteObject(Detach());
}

/////////////////////////////////////////////////////////////////////////////
// Standard GDI objects

/////////////////////////////////////////////////////////////////////////////
// CPen

CPen::CPen(int nPenStyle, int nWidth, COLORREF crColor)
{
	if (!Attach(::CreatePen(nPenStyle, nWidth, crColor)))
		AfxThrowResourceException();
}

CPen::CPen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
	int nStyleCount, const DWORD* lpStyle)
{
	if (!Attach(::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount,
			lpStyle)))
		AfxThrowResourceException();
}

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CPen::Dump(CDumpContext& dc) const
{
	CGdiObject::Dump(dc);

	if (m_hObject == NULL)
		return;

	if (::GetObjectType(m_hObject) != OBJ_PEN)
	{
		// not a valid object
		dc << "has ILLEGAL HPEN!";
		return;
	}

	LOGPEN lp;
	VERIFY(GetObject(sizeof(lp), &lp));
	dc << "lgpn.lopnStyle = " << lp.lopnStyle;
	dc << "\nlgpn.lopnWidth.x (width) = " << lp.lopnWidth.x;
	dc << "\nlgpn.lopnColor = " << (void*)(DWORD_PTR)lp.lopnColor;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrush

CBrush::CBrush(COLORREF crColor)
{
	if (!Attach(::CreateSolidBrush(crColor)))
		AfxThrowResourceException();
}

CBrush::CBrush(int nIndex, COLORREF crColor)
{
	if (!Attach(::CreateHatchBrush(nIndex, crColor)))
		AfxThrowResourceException();
}

CBrush::CBrush(CBitmap* pBitmap)
{
	ASSERT_VALID(pBitmap);

	if (!Attach(::CreatePatternBrush((HBITMAP)pBitmap->m_hObject)))
		AfxThrowResourceException();
}

BOOL CBrush::CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage)
{
	ASSERT(hPackedDIB != NULL);
	const void* lpPackedDIB = ::GlobalLock(hPackedDIB);
	ASSERT(lpPackedDIB != NULL);
	BOOL bResult = Attach(::CreateDIBPatternBrushPt(lpPackedDIB, nUsage));
	::GlobalUnlock(hPackedDIB);
	return bResult;
}

#ifdef _DEBUG
void CBrush::Dump(CDumpContext& dc) const
{
	CGdiObject::Dump(dc);

	if (m_hObject == NULL)
		return;

	if (::GetObjectType(m_hObject) != OBJ_BRUSH)
	{
		// not a valid window
		dc << "has ILLEGAL HBRUSH!";
		return;
	}

	LOGBRUSH lb;
	VERIFY(GetObject(sizeof(lb), &lb));
	dc << "lb.lbStyle = " << lb.lbStyle;
	dc << "\nlb.lbHatch = " << lb.lbHatch;
	dc << "\nlb.lbColor = " << (void*)(DWORD_PTR)lb.lbColor;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CFont::Dump(CDumpContext& dc) const
{
	CGdiObject::Dump(dc);

	if (m_hObject == NULL)
		return;

	if (::GetObjectType(m_hObject) != OBJ_FONT)
	{
		// not a valid GDI object
		dc << "has ILLEGAL HFONT!";
		return;
	}

	LOGFONT lf;
	VERIFY(GetObject(sizeof(lf), &lf));
	dc << "lf.lfHeight = " << lf.lfHeight;
	dc << "\nlf.lfWidth = " << lf.lfWidth;
	dc << "\nlf.lfEscapement = " << lf.lfEscapement;
	dc << "\nlf.lfOrientation = " << lf.lfOrientation;
	dc << "\nlf.lfWeight = " << lf.lfWeight;
	dc << "\nlf.lfItalic = " << (int)lf.lfItalic;
	dc << "\nlf.lfUnderline = " << (int)lf.lfUnderline;
	dc << "\nlf.lfStrikeOut = " << (int)lf.lfStrikeOut;
	dc << "\nlf.lfCharSet = " << (int)lf.lfCharSet;
	dc << "\nlf.lfOutPrecision = " << (int)lf.lfOutPrecision;
	dc << "\nlf.lfClipPrecision = " << (int)lf.lfClipPrecision;
	dc << "\nlf.lfQuality = " << (int)lf.lfQuality;
	dc << "\nlf.lfPitchAndFamily = " << (int)lf.lfPitchAndFamily;
	dc << "\nlf.lfFaceName = " << (LPCTSTR)lf.lfFaceName;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CBitmap::Dump(CDumpContext& dc) const
{
	CGdiObject::Dump(dc);

	if (m_hObject == NULL)
		return;

	if (::GetObjectType(m_hObject) != OBJ_BITMAP)
	{
		// not a valid object
		dc << "has ILLEGAL HBITMAP!";
		return;
	}

	BITMAP bm;
	VERIFY(GetObject(sizeof(bm), &bm));
	dc << "bm.bmType = " << bm.bmType;
	dc << "\nbm.bmHeight = " << bm.bmHeight;
	dc << "\nbm.bmWidth = " << bm.bmWidth;
	dc << "\nbm.bmWidthBytes = " << bm.bmWidthBytes;
	dc << "\nbm.bmPlanes = " << bm.bmPlanes;
	dc << "\nbm.bmBitsPixel = " << bm.bmBitsPixel;

	dc << "\n";
}
#endif


IMPLEMENT_DYNAMIC(CResourceException, CSimpleException)
CResourceException _simpleResourceException(FALSE, AFX_IDS_RESOURCE_EXCEPTION);

IMPLEMENT_DYNAMIC(CUserException, CSimpleException)
CUserException _simpleUserException(FALSE, AFX_IDS_USER_EXCEPTION);

IMPLEMENT_DYNCREATE(CDC, CObject)
IMPLEMENT_DYNAMIC(CClientDC, CDC)
IMPLEMENT_DYNAMIC(CWindowDC, CDC)
IMPLEMENT_DYNAMIC(CPaintDC, CDC)
IMPLEMENT_DYNCREATE(CGdiObject, CObject)

IMPLEMENT_DYNAMIC(CPen, CGdiObject)
IMPLEMENT_DYNAMIC(CBrush, CGdiObject)
IMPLEMENT_DYNAMIC(CFont, CGdiObject)
IMPLEMENT_DYNAMIC(CBitmap, CGdiObject)
IMPLEMENT_DYNAMIC(CPalette, CGdiObject)
IMPLEMENT_DYNAMIC(CRgn, CGdiObject)

/////////////////////////////////////////////////////////////////////////////
// Standard exception processing


// resource failure
void AFXAPI AfxThrowResourceException()
{
	THROW((CResourceException*)&_simpleResourceException);
}

// user alert
void AFXAPI AfxThrowUserException()
{
	THROW((CUserException*)&_simpleUserException);
}

void AFXAPI AfxGetGrayBitmap(const CBitmap &rSrc, CBitmap *pDest, COLORREF crBackground)
{
	ASSERT(pDest);
	ASSERT_KINDOF(CBitmap, pDest);

	BITMAP bm;
	CDC dcMem, dcMask;
	COLORREF cr;
	CBitmap bmpMask, *pOldMask, *pOldMem;
	const DWORD	CP_ROP = 0xE20746;
	CBrush brHighLight(::GetSysColor(COLOR_3DHIGHLIGHT)),
		brShadow(::GetSysColor(COLOR_3DSHADOW)), *pbr;

	if(dcMem.CreateCompatibleDC(NULL) &&
		dcMask.CreateCompatibleDC(NULL))
	{
		const_cast<CBitmap &>(rSrc).GetBitmap(&bm);
		pDest->DeleteObject();
		if(pDest->CreateBitmap(bm.bmWidth, bm.bmHeight, bm.bmPlanes, bm.bmBitsPixel, NULL) &&
			bmpMask.CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL))
		{
			pOldMem = dcMem.SelectObject(const_cast<CBitmap *>(&rSrc));
			pOldMask = dcMask.SelectObject(&bmpMask);

			ASSERT(pOldMem && pOldMask);
			if(!pOldMem || !pOldMask)
				return;

			// Make the upper left corner pixel the "transparent" pixel
			cr = dcMem.SetBkColor(dcMem.GetPixel(0, 0));
			dcMask.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcMem, 0, 0, SRCCOPY);
			// Make white pixels transparent too
			dcMem.SetBkColor(RGB(255, 255, 255));
			dcMask.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcMem, 0, 0, NOTSRCERASE);

			if(dcMem.SelectObject(pDest))
			{
				dcMem.FillSolidRect(0, 0, bm.bmWidth, bm.bmHeight, crBackground);

				dcMem.SetBkColor(RGB(255, 255, 255));

				pbr = dcMem.SelectObject(&brHighLight);
				dcMem.BitBlt(1, 1, bm.bmWidth, bm.bmHeight, &dcMask, 0, 0, CP_ROP);

				dcMem.SelectObject(&brShadow);
				dcMem.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcMask, 0, 0, CP_ROP);

				dcMem.SelectObject(pbr);

				dcMem.SetBkColor(cr);
			}
			dcMask.SelectObject(pOldMask);
			dcMem.SelectObject(pOldMem);
		}
	}
}

void AFXAPI AfxDrawGrayBitmap(CDC *pDC, int x, int y, const CBitmap &rSrc, COLORREF crBackground)
{
	ASSERT(pDC);
	ASSERT_KINDOF(CDC, pDC);

	BITMAP bm;
	CDC dcMem, dcMask;
	COLORREF cr;
	CBitmap bmpMask, *pOldMask, *pOldMem;
	const DWORD	CP_ROP = 0xE20746;
	CBrush brHighLight(::GetSysColor(COLOR_3DHIGHLIGHT)),
		brShadow(::GetSysColor(COLOR_3DSHADOW)), *pbr;

	if(dcMem.CreateCompatibleDC(pDC) &&
		dcMask.CreateCompatibleDC(pDC) &&
		const_cast<CBitmap &>(rSrc).GetBitmap(&bm) &&
		bmpMask.CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL))
	{
		pOldMem = dcMem.SelectObject(const_cast<CBitmap *>(&rSrc));
		pOldMask = dcMask.SelectObject(&bmpMask);

		ASSERT(pOldMem && pOldMask);
		if(!pOldMem || !pOldMask)
			return;

		cr = dcMem.SetBkColor(dcMem.GetPixel(0, 0));
		dcMask.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcMem, 0, 0, SRCCOPY);
		dcMem.SetBkColor(RGB(255, 255, 255));
		dcMask.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcMem, 0, 0, NOTSRCERASE);

		pDC->FillSolidRect(x, y, bm.bmWidth, bm.bmHeight, crBackground);

		pDC->SetBkColor(RGB(255, 255, 255));

		pbr = pDC->SelectObject(&brHighLight);
		pDC->BitBlt(x + 1, y + 1, bm.bmWidth, bm.bmHeight, &dcMask, 0, 0, CP_ROP);

		pDC->SelectObject(&brShadow);
		pDC->BitBlt(x, y, bm.bmWidth, bm.bmHeight, &dcMask, 0, 0, CP_ROP);

		pDC->SelectObject(pbr);

		pDC->SetBkColor(cr);
		dcMask.SelectObject(pOldMask);
	}
}

void AFXAPI AfxGetDitheredBitmap(const CBitmap &rSrc, CBitmap *pDest, COLORREF cr1, COLORREF cr2)
{
	ASSERT(pDest);
	ASSERT_KINDOF(CBitmap, pDest);

	BITMAP bm;
	CDC dcSrc, dcMask, dcDest;
	COLORREF cr;
	CBitmap bmpMask, *pOldMask, *pOldSrc;
	CBrush brChecker;
	static const WORD wPat[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};

	if(dcSrc.CreateCompatibleDC(NULL) &&
		dcMask.CreateCompatibleDC(NULL) &&
		dcDest.CreateCompatibleDC(NULL))
	{
		if(const_cast<CBitmap &>(rSrc).GetBitmap(&bm))
		{
			pDest->DeleteObject();
			if(pDest->CreateBitmap(bm.bmWidth, bm.bmHeight, bm.bmPlanes, bm.bmBitsPixel, NULL))
			{
				// Create checker brush
				bmpMask.CreateBitmap(8, 8, 1, 1, wPat);
				brChecker.CreatePatternBrush(&bmpMask);
				bmpMask.DeleteObject();

				// Mask
				bmpMask.CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);

				pOldSrc = dcSrc.SelectObject(const_cast<CBitmap *>(&rSrc));
				pOldMask = dcMask.SelectObject(&bmpMask);

				ASSERT(pOldSrc && pOldMask);
				if(!pOldSrc || !pOldMask)
					return;

				// Make the upper left corner pixel of the source a "transparent" color
				cr = dcSrc.SetBkColor(dcSrc.GetPixel(0, 0));
				dcMask.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcSrc, 0, 0, SRCCOPY);
				// Make white pixels of the source "transparent" too
				dcSrc.SetBkColor(RGB(255, 255, 255));
				dcMask.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcSrc, 0, 0, SRCPAINT);
				dcSrc.SetBkColor(cr);

				// Checker the background with white and crBackground
				pDest = dcDest.SelectObject(pDest);
				ASSERT(pDest);
				if(pDest)
				{
					cr1 = dcDest.SetTextColor(cr1);
					cr2 = dcDest.SetBkColor(cr2);
					dcDest.FillRect(CRect(0, 0, bm.bmWidth, bm.bmHeight), &brChecker);
					dcDest.SetTextColor(cr1);
					dcDest.SetBkColor(cr2);

					// Blt it
					dcDest.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcSrc, 0, 0, SRCINVERT);
					dcDest.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcMask, 0, 0, SRCAND);
					dcDest.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcSrc, 0, 0, SRCINVERT);
				}
				dcDest.SelectObject(pDest);
				dcMask.SelectObject(pOldMask);
				dcSrc.SelectObject(pOldSrc);
			}
		}
	}
}

void AFXAPI AfxDrawDitheredBitmap(CDC *pDC, int x, int y, const CBitmap &rSrc, COLORREF cr1, COLORREF cr2)
{
	ASSERT(pDC);
	ASSERT_KINDOF(CDC, pDC);

	BITMAP bm;
	CDC dcSrc, dcMask;
	COLORREF cr;
	CBitmap bmpMask, *pOldMask, *pOldSrc;
	CBrush brChecker;
	static const WORD wPat[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};

	if(dcSrc.CreateCompatibleDC(pDC) &&
		dcMask.CreateCompatibleDC(pDC) &&
		const_cast<CBitmap &>(rSrc).GetBitmap(&bm))
	{
		// Create checker brush
		bmpMask.CreateBitmap(8, 8, 1, 1, wPat);
		brChecker.CreatePatternBrush(&bmpMask);
		bmpMask.DeleteObject();

		// Mask
		bmpMask.CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);

		pOldSrc = dcSrc.SelectObject(const_cast<CBitmap *>(&rSrc));
		pOldMask = dcMask.SelectObject(&bmpMask);

		ASSERT(pOldSrc && pOldMask);
		if(!pOldSrc || !pOldMask)
			return;

		// Make the upper left corner pixel of the source a "transparent" color
		cr = dcSrc.SetBkColor(dcSrc.GetPixel(0, 0));
		dcMask.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcSrc, 0, 0, SRCCOPY);
		// Make white pixels of the source "transparent" too
		dcSrc.SetBkColor(RGB(255, 255, 255));
		dcMask.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcSrc, 0, 0, SRCPAINT);
		dcSrc.SetBkColor(cr);

		// Checker the background with white and crBackground
		cr1 = pDC->SetTextColor(cr1);
		cr2 = pDC->SetBkColor(cr2);
		pDC->FillRect(CRect(x, y, x + bm.bmWidth, y + bm.bmHeight), &brChecker);
		pDC->SetTextColor(cr1);
		pDC->SetBkColor(cr2);

		// Blt it
		pDC->BitBlt(x, y, bm.bmWidth, bm.bmHeight, &dcSrc, 0, 0, SRCINVERT);
		pDC->BitBlt(x, y, bm.bmWidth, bm.bmHeight, &dcMask, 0, 0, SRCAND);
		pDC->BitBlt(x, y, bm.bmWidth, bm.bmHeight, &dcSrc, 0, 0, SRCINVERT);

		dcMask.SelectObject(pOldMask);
		dcSrc.SelectObject(pOldSrc);
	}
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winhand_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CHandleMap
//
//  Note: Do not access the members of this class directly.
//      Use CWnd::FromHandle, CDC::FromHandle, etc.
//      The actual definition is only included because it is
//      necessary for the definition of CWinThread.
//
//  Most Windows objects are represented with a HANDLE, including
//      the most important ones, HWND, HDC, HPEN, HFONT etc.
//  We want C++ objects to wrap these handle based objects whenever we can.
//  Since Windows objects can be created outside of C++ (eg: calling
//      ::CreateWindow will return an HWND with no C++ wrapper) we must
//      support a reasonably uniform mapping from permanent handles
//      (i.e. the ones allocated in C++) and temporary handles (i.e.
//      the ones allocated in C, but passed through a C++ interface.
//  We keep two dictionaries for this purpose.  The permanent dictionary
//      stores those C++ objects that have been explicitly created by
//      the developer.  The C++ constructor for the wrapper class will
//      insert the mapping into the permanent dictionary and the C++
//      destructor will remove it and possibly free up the associated
//      Windows object.
//  When a handle passes through a C++ interface that doesn't exist in
//      the permanent dictionary, we allocate a temporary wrapping object
//      and store that mapping into the temporary dictionary.
//  At idle time the temporary wrapping objects are flushed (since you better
//      not be holding onto something you didn't create).
//

#pragma once

#include "fixalloc.h"

template<class TYPE>
struct ConstructDestruct
{
	static void PASCAL Construct(CObject* pObject)
	{ 
		new (pObject) TYPE; 
	}
	static void PASCAL Destruct(CObject* pObject)
	{
		TYPE* p = (TYPE*)pObject;
		p->~TYPE();
	}
};

class CWinThread;       // forward reference for friend declaration

class CHandleMap
{
private:    // implementation
	CFixedAllocNoSync m_alloc;
	void (PASCAL* m_pfnConstructObject)(CObject* pObject);
	void (PASCAL* m_pfnDestructObject)(CObject* pObject);
	CMapPtrToPtr m_permanentMap;
	CMapPtrToPtr m_temporaryMap;
	CRuntimeClass* m_pClass;
	size_t m_nOffset;       // offset of handles in the object
	int m_nHandles;         // 1 or 2 (for CDC)

// Constructor/Destructor
public:
	CHandleMap(CRuntimeClass* pClass, 
		void (PASCAL* pfnConstructObject)(CObject* pObject),
		void (PASCAL* pfnDestructObject)(CObject* pObject),
		size_t nOffset, int nHandles = 1);
#ifdef _AFXDLL
	~CHandleMap()
#else
	virtual ~CHandleMap()
#endif
		{ DeleteTemp(); }

// Operations
public:
	CObject* FromHandle(HANDLE h);
	void DeleteTemp();

	void SetPermanent(HANDLE h, CObject* permOb);
	void RemoveHandle(HANDLE h);

	CObject* LookupPermanent(HANDLE h);
	CObject* LookupTemporary(HANDLE h);


	friend class CWinThread;
};

// Note: out-of-line _DEBUG version is in winhand.cpp
#ifndef _DEBUG
inline void CHandleMap::SetPermanent(HANDLE h, CObject* permOb)
	{ m_permanentMap[(LPVOID)h] = permOb; }

inline void CHandleMap::RemoveHandle(HANDLE h)
{
	// remove only from permanent map -- temporary objects are removed
	//  at idle in CHandleMap::DeleteTemp, always!
	m_permanentMap.RemoveKey((LPVOID)h);
}
#endif

inline CObject* CHandleMap::LookupPermanent(HANDLE h)
	{ return (CObject*)m_permanentMap.GetValueAt((LPVOID)h); }
inline CObject* CHandleMap::LookupTemporary(HANDLE h)
	{ return (CObject*)m_temporaryMap.GetValueAt((LPVOID)h); }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winmain.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"


/////////////////////////////////////////////////////////////////////////////
// Standard WinMain implementation
//  Can be replaced as long as 'AfxWinInit' is called first

int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	_In_ LPTSTR lpCmdLine, int nCmdShow)
{
	ASSERT(hPrevInstance == NULL);

	int nReturnCode = -1;
	CWinThread* pThread = AfxGetThread();
	CWinApp* pApp = AfxGetApp();

	// AFX internal initialization
	if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))
		goto InitFailure;

	// App global initializations (rare)
	if (pApp != NULL && !pApp->InitApplication())
		goto InitFailure;

	// Perform specific initializations
	if (!pThread->InitInstance())
	{
		if (pThread->m_pMainWnd != NULL)
		{
			TRACE(traceAppMsg, 0, "Warning: Destroying non-NULL m_pMainWnd\n");
			pThread->m_pMainWnd->DestroyWindow();
		}
		nReturnCode = pThread->ExitInstance();
		goto InitFailure;
	}
	nReturnCode = pThread->Run();

InitFailure:
#ifdef _DEBUG
	// Check for missing AfxLockTempMap calls
	if (AfxGetModuleThreadState()->m_nTempMapLock != 0)
	{
		TRACE(traceAppMsg, 0, "Warning: Temp map lock count non-zero (%ld).\n",
			AfxGetModuleThreadState()->m_nTempMapLock);
	}
	AfxLockTempMaps();
	AfxUnlockTempMaps(-1);
#endif

	AfxWinTerm();
	return nReturnCode;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winhand.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Support for freeing the temp maps

void AFXAPI AfxLockTempMaps()
{
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	++pState->m_nTempMapLock;
}

BOOL AFXAPI AfxUnlockTempMaps(BOOL bDeleteTemps)
{
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	if (pState->m_nTempMapLock != 0 && --pState->m_nTempMapLock == 0)
	{
		if (bDeleteTemps)
		{
			if (bDeleteTemps != -1)
			{
				// allow COM libraries to be freed
				CWinThread* pThread = AfxGetThread();
				if (pThread != NULL && pThread->m_lpfnOleTermOrFreeLib != NULL)
					(*pThread->m_lpfnOleTermOrFreeLib)(FALSE, FALSE);
			}

			// clean up temp objects
			pState->m_pmapHGDIOBJ->DeleteTemp();
			pState->m_pmapHDC->DeleteTemp();
			pState->m_pmapHMENU->DeleteTemp();
			pState->m_pmapHWND->DeleteTemp();
			pState->m_pmapHIMAGELIST->DeleteTemp();
		}

#ifndef _AFX_PORTABLE
		CWinApp* pApp = AfxGetApp();
		_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetDataNA();
		if( pThreadState != NULL )
		{
			// restore safety pool after temp objects destroyed
			if (pApp != NULL &&
				 (pThreadState->m_pSafetyPoolBuffer == NULL ||
				 _msize(pThreadState->m_pSafetyPoolBuffer) < pApp->m_nSafetyPoolSize) &&
				pApp->m_nSafetyPoolSize != 0)
			{
				// attempt to restore the safety pool to its max size
				size_t nOldSize = 0;
				if (pThreadState->m_pSafetyPoolBuffer != NULL)
				{
					nOldSize = _msize(pThreadState->m_pSafetyPoolBuffer);
					free(pThreadState->m_pSafetyPoolBuffer);
				}

				// undo handler trap for the following allocation
				BOOL bEnable = AfxEnableMemoryTracking(FALSE);
				try
				{
					pThreadState->m_pSafetyPoolBuffer = malloc(pApp->m_nSafetyPoolSize);
					if (pThreadState->m_pSafetyPoolBuffer == NULL)
					{
						TRACE(traceAppMsg, 0, "Warning: failed to reclaim %d bytes for memory safety pool.\n",
							pApp->m_nSafetyPoolSize);
						// at least get the old buffer back
						if (nOldSize != 0)
						{
							//get it back
							pThreadState->m_pSafetyPoolBuffer = malloc(nOldSize);
							ASSERT(pThreadState->m_pSafetyPoolBuffer != NULL);
						}
					}
				}
				catch( CException * )
				{
					AfxEnableMemoryTracking(bEnable);
					throw;
				}
				AfxEnableMemoryTracking(bEnable);
			}
		}
#endif  // !_AFX_PORTABLE
	}

	// return TRUE if temp maps still locked
	return pState->m_nTempMapLock != 0;
}

/////////////////////////////////////////////////////////////////////////////
// CHandleMap implementation

CHandleMap::CHandleMap(CRuntimeClass* pClass, 
	void (PASCAL* pfnConstructObject)(CObject*), 
	void (PASCAL* pfnDestructObject)(CObject*),
	size_t nOffset, int nHandles) : 
		m_permanentMap(10), 
		m_temporaryMap(4), // small block size for temporary map
		m_alloc(pClass->m_nObjectSize, 64)
{
	ENSURE_ARG(pClass != NULL);
	ENSURE_ARG(pfnConstructObject != NULL);
	ENSURE_ARG(pfnDestructObject != NULL);
	ASSERT(nHandles == 1 || nHandles == 2);

	m_temporaryMap.InitHashTable(7, FALSE); // small table for temporary map
	m_pClass = pClass;
	m_pfnConstructObject = pfnConstructObject;
	m_pfnDestructObject = pfnDestructObject;
	m_nOffset = nOffset;
	m_nHandles = nHandles;
}

CObject* CHandleMap::FromHandle(HANDLE h)
{
	ASSERT(m_pClass != NULL);
	ASSERT(m_nHandles == 1 || m_nHandles == 2);

	if (h == NULL)
		return NULL;

	CObject* pObject = LookupPermanent(h);
	if (pObject != NULL)
		return pObject;   // return permanent one
	else if ((pObject = LookupTemporary(h)) != NULL)
	{
		HANDLE* ph = (HANDLE*)((BYTE*)pObject + m_nOffset);
		ASSERT(ph[0] == h || ph[0] == NULL);
		ph[0] = h;
		if (m_nHandles == 2)
		{
			ASSERT(ph[1] == h || ph[1] == NULL);
			ph[1] = h;
		}
		return pObject;   // return current temporary one
	}

	// This handle wasn't created by us, so we must create a temporary
	// C++ object to wrap it.  We don't want the user to see this memory
	// allocation, so we turn tracing off.

	BOOL bEnable = AfxEnableMemoryTracking(FALSE);
#ifndef _AFX_PORTABLE
	_PNH pnhOldHandler = AfxSetNewHandler(&AfxCriticalNewHandler);
#endif

	CObject* pTemp = NULL;
	TRY
	{
		// get memory for the object from the fixed allocator
		ASSERT((UINT)m_pClass->m_nObjectSize == m_alloc.GetAllocSize());
		pTemp = (CObject*)m_alloc.Alloc();
		if (pTemp == NULL)
			AfxThrowMemoryException();

		// now construct the object in place
		ASSERT(m_pfnConstructObject != NULL);
		(*m_pfnConstructObject)(pTemp);

		// set it in the map
		m_temporaryMap.SetAt((LPVOID)h, pTemp);
	}
	CATCH_ALL(e)
	{
#ifndef _AFX_PORTABLE
		AfxSetNewHandler(pnhOldHandler);
#endif
		AfxEnableMemoryTracking(bEnable);
		THROW_LAST();
	}
	END_CATCH_ALL

#ifndef _AFX_PORTABLE
	AfxSetNewHandler(pnhOldHandler);
#endif
	AfxEnableMemoryTracking(bEnable);

	// now set the handle in the object
	HANDLE* ph = (HANDLE*)((BYTE*)pTemp + m_nOffset);  // after CObject
	ph[0] = h;
	if (m_nHandles == 2)
		ph[1] = h;

	return pTemp;
}

#ifdef _DEBUG   // out-of-line version for memory tracking
void CHandleMap::SetPermanent(HANDLE h, CObject* permOb)
{
	BOOL bEnable = AfxEnableMemoryTracking(FALSE);
	m_permanentMap[(LPVOID)h] = permOb;
	AfxEnableMemoryTracking(bEnable);
}
#endif //_DEBUG

#ifdef _DEBUG
void CHandleMap::RemoveHandle(HANDLE h)
{
	// make sure the handle entry is consistent before deleting
	CObject* pTemp = LookupTemporary(h);
	if (pTemp != NULL)
	{
		// temporary objects must have correct handle values
		HANDLE* ph = (HANDLE*)((BYTE*)pTemp + m_nOffset);  // after CObject
		ASSERT(ph[0] == h || ph[0] == NULL);
		if (m_nHandles == 2)
			ASSERT(ph[1] == h);
	}
	pTemp = LookupPermanent(h);
	if (pTemp != NULL)
	{
		HANDLE* ph = (HANDLE*)((BYTE*)pTemp + m_nOffset);  // after CObject
		ASSERT(ph[0] == h);
		// permanent object may have secondary handles that are different
	}
	// remove only from permanent map -- temporary objects are removed
	//  at idle in CHandleMap::DeleteTemp, always!
	m_permanentMap.RemoveKey((LPVOID)h);
}
#endif

void CHandleMap::DeleteTemp()
{
	if (this == NULL)
		return;

	POSITION pos = m_temporaryMap.GetStartPosition();
	while (pos != NULL)
	{
		HANDLE h; // just used for asserts
		CObject* pTemp;
		m_temporaryMap.GetNextAssoc(pos, (LPVOID&)h, (void*&)pTemp);

		// zero out the handles
		ASSERT(m_nHandles == 1 || m_nHandles == 2);
		HANDLE* ph = (HANDLE*)((BYTE*)pTemp + m_nOffset);  // after CObject
		ASSERT(ph[0] == h || ph[0] == NULL);
		ph[0] = NULL;
		if (m_nHandles == 2)
		{
			ASSERT(ph[1] == h || ph[1] == NULL);
			ph[1] = NULL;
		}

		ASSERT(m_pfnDestructObject != NULL);
		(*m_pfnDestructObject)(pTemp);	// destruct the object
	}

	m_temporaryMap.RemoveAll();       // free up dictionary links etc
	m_alloc.FreeAll();	// free all the memory used for these temp objects
}

/////////////////////////////////////////////////////////////////////////////

void PASCAL CWnd::DeleteTempMap()
{
	CHandleMap* pMap = AfxGetModuleThreadState()->m_pmapHWND;
	pMap->DeleteTemp();
}

void PASCAL CImageList::DeleteTempMap()
{
	CHandleMap* pMap = AfxGetModuleThreadState()->m_pmapHIMAGELIST;
	pMap->DeleteTemp();
}

void PASCAL CDC::DeleteTempMap()
{
	CHandleMap* pMap = AfxGetModuleThreadState()->m_pmapHDC;
	pMap->DeleteTemp();
}

void PASCAL CGdiObject::DeleteTempMap()
{
	CHandleMap* pMap = AfxGetModuleThreadState()->m_pmapHGDIOBJ;
	pMap->DeleteTemp();
}

void PASCAL CMenu::DeleteTempMap()
{
	CHandleMap* pMap = AfxGetModuleThreadState()->m_pmapHMENU;
	pMap->DeleteTemp();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winocc.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"
#include "sal.h"



#define new DEBUG_NEW

#ifndef _AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// CWnd overridable for ambient properties

BOOL CWnd::OnAmbientProperty(COleControlSite* pSite, DISPID dispid,
	VARIANT* pvar)
{
	ASSERT(m_pCtrlCont != NULL);
	return m_pCtrlCont->GetAmbientProp(pSite, dispid, pvar);
}

/////////////////////////////////////////////////////////////////////////////
// CWnd access to underlying OLE control interface

LPUNKNOWN CWnd::GetControlUnknown()
{
	if (m_pCtrlSite == NULL)
		return NULL;

	return m_pCtrlSite->m_pObject;
}

/////////////////////////////////////////////////////////////////////////////
// CWnd functions with special cases for OLE Control containment

BOOL CWnd::PaintWindowlessControls(CDC *pDC)
{
   if (m_pCtrlCont != NULL)
   {
	  // Paint windowless controls
	  return m_pCtrlCont->OnPaint(pDC);
   }
   return FALSE;
}

COleControlSite* CWnd::GetOleControlSite(UINT idControl) const
{
   if (m_pCtrlCont != NULL )
   {
	  return( m_pCtrlCont->FindItem(idControl) );
   }
   else
   {
	  return( NULL );
   }
}

void CWnd::CheckDlgButton(int nIDButton, UINT nCheck)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		::CheckDlgButton(m_hWnd, nIDButton, nCheck);
	else
		m_pCtrlCont->CheckDlgButton(nIDButton, nCheck);
}

void CWnd::CheckRadioButton(int nIDFirstButton, int nIDLastButton,
	int nIDCheckButton)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton,
			nIDCheckButton);
	else
		m_pCtrlCont->CheckRadioButton(nIDFirstButton, nIDLastButton,
			nIDCheckButton);
}

CWnd* CWnd::GetDlgItem(int nID) const
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		return CWnd::FromHandle(::GetDlgItem(m_hWnd, nID));
	else
		return m_pCtrlCont->GetDlgItem(nID);
}

void CWnd::GetDlgItem(int nID, HWND* phWnd) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(phWnd != NULL);

	if (m_pCtrlCont == NULL)
		*phWnd = ::GetDlgItem(m_hWnd, nID);
	else
		m_pCtrlCont->GetDlgItem(nID, phWnd);
}

UINT CWnd::GetDlgItemInt(int nID, BOOL* lpTrans, BOOL bSigned) const
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);
	else
		return m_pCtrlCont->GetDlgItemInt(nID, lpTrans, bSigned);
}

int CWnd::GetDlgItemText(_In_ int nID, _Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpStr, _In_ int nMaxCount) const
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);
	else
		return m_pCtrlCont->GetDlgItemText(nID, lpStr, nMaxCount);
}

LRESULT CWnd::SendDlgItemMessage(int nID, UINT message, WPARAM wParam,
	LPARAM lParam)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam);
	else
		return m_pCtrlCont->SendDlgItemMessage(nID, message, wParam, lParam);
}

void CWnd::SetDlgItemInt(int nID, UINT nValue, BOOL bSigned)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		::SetDlgItemInt(m_hWnd, nID, nValue, bSigned);
	else
		m_pCtrlCont->SetDlgItemInt(nID, nValue, bSigned);
}

void CWnd::SetDlgItemText(int nID, LPCTSTR lpszString)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		::SetDlgItemText(m_hWnd, nID, lpszString);
	else
		m_pCtrlCont->SetDlgItemText(nID, lpszString);
}

UINT CWnd::IsDlgButtonChecked(int nIDButton) const
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCtrlCont == NULL)
		return ::IsDlgButtonChecked(m_hWnd, nIDButton);
	else
		return m_pCtrlCont->IsDlgButtonChecked(nIDButton);
}

int CWnd::ScrollWindowEx(int dx, int dy, LPCRECT lpRectScroll,
	LPCRECT lpRectClip, CRgn* prgnUpdate, LPRECT lpRectUpdate,
	UINT flags)
{
	ASSERT(::IsWindow(m_hWnd));

	int iReturn = ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip,
			(HRGN)prgnUpdate->GetSafeHandle(), lpRectUpdate, flags);

	if ((m_pCtrlCont == NULL) || !(flags & SW_SCROLLCHILDREN))
		return iReturn;

	// the following code is for OLE control containers only

	m_pCtrlCont->ScrollChildren(dx, dy);
	return iReturn;
}

BOOL CWnd::IsDialogMessage(LPMSG lpMsg)
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_nFlags & WF_OLECTLCONTAINER)
		return afxOccManager->IsDialogMessage(this, lpMsg);
	else
		return ::IsDialogMessage(m_hWnd, lpMsg);
}

/////////////////////////////////////////////////////////////////////////////
// CWnd functions with special cases for OLE Control wrappers

DWORD CWnd::GetStyle() const
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return (DWORD)GetWindowLong(m_hWnd, GWL_STYLE);
	else
		return m_pCtrlSite->GetStyle();
}

DWORD CWnd::GetExStyle() const
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return (DWORD)GetWindowLong(m_hWnd, GWL_EXSTYLE);
	else
		return m_pCtrlSite->GetExStyle();
}

BOOL CWnd::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ModifyStyle(m_hWnd, dwRemove, dwAdd, nFlags);
	else
		return m_pCtrlSite->ModifyStyle(dwRemove, dwAdd, nFlags);
}

BOOL CWnd::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ModifyStyleEx(m_hWnd, dwRemove, dwAdd, nFlags);
	else
		return m_pCtrlSite->ModifyStyleEx(dwRemove, dwAdd, nFlags);
}

void CWnd::SetWindowText(LPCTSTR lpszString)
{
	ENSURE(this);
	ENSURE(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		::SetWindowText(m_hWnd, lpszString);
	else
		m_pCtrlSite->SetWindowText(lpszString);
}

int CWnd::GetWindowText(_Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpszString, _In_ int nMaxCount) const
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ::GetWindowText(m_hWnd, lpszString, nMaxCount);
	else
	{
		CString str;

		m_pCtrlSite->GetWindowText(str);
		Checked::tcsncpy_s(lpszString, nMaxCount, str, _TRUNCATE);
		return lstrlen(lpszString);
	}
}

int CWnd::GetWindowTextLength() const
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ::GetWindowTextLength(m_hWnd);
	else
	{
		CString str;

		m_pCtrlSite->GetWindowText(str);
		return (int)str.GetLength();
	}
}

int CWnd::GetDlgCtrlID() const
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ::GetDlgCtrlID(m_hWnd);
	else
		return m_pCtrlSite->GetDlgCtrlID();
}

int CWnd::SetDlgCtrlID(int nID)
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return (int)::SetWindowLong(m_hWnd, GWL_ID, nID);
	else
		return m_pCtrlSite->SetDlgCtrlID(nID);
}

void CWnd::MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint)
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint);
	else
		m_pCtrlSite->MoveWindow(x, y, nWidth, nHeight);
}

BOOL CWnd::SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx,
	int cy, UINT nFlags)
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ::SetWindowPos(m_hWnd, pWndInsertAfter->GetSafeHwnd(),
			x, y, cx, cy, nFlags);
	else
		return m_pCtrlSite->SetWindowPos(pWndInsertAfter, x, y, cx, cy, nFlags);
}

BOOL CWnd::ShowWindow(int nCmdShow)
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ::ShowWindow(m_hWnd, nCmdShow);
	else
		return m_pCtrlSite->ShowWindow(nCmdShow);
}

BOOL CWnd::IsWindowEnabled() const
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ::IsWindowEnabled(m_hWnd);
	else
		return m_pCtrlSite->IsWindowEnabled();
}

BOOL CWnd::EnableWindow(BOOL bEnable)
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
		return ::EnableWindow(m_hWnd, bEnable);
	else
		return m_pCtrlSite->EnableWindow(bEnable);
}

CWnd* CWnd::SetFocus()
{
	ASSERT(::IsWindow(m_hWnd) || (m_pCtrlSite != NULL));

	if (m_pCtrlSite == NULL)
	{
		if (GetParent() && GetParent()->GetControlContainer())
		{
			GetParent()->GetControlContainer()->m_pSiteFocus = NULL;
		}
		return CWnd::FromHandle(::SetFocus(m_hWnd));
	}
	else
	{
		return m_pCtrlSite->SetFocus();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWnd invoke helpers for OLE Control wrappers

void AFX_CDECL CWnd::InvokeHelper(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
	void* pvRet, const BYTE* pbParamInfo, ...)
{
	ASSERT(m_pCtrlSite != NULL);    // not an OLE control (not yet, at least)

	if (m_pCtrlSite == NULL)
		return;

	va_list argList;
	va_start(argList, pbParamInfo);
	m_pCtrlSite->InvokeHelperV(dwDispID, wFlags, vtRet, pvRet, pbParamInfo,
		argList);
	va_end(argList);
}

void CWnd::GetProperty(DISPID dwDispID, VARTYPE vtProp,
	void* pvProp) const
{
	ASSERT(m_pCtrlSite != NULL);    // not an OLE control (not yet, at least)

	if (m_pCtrlSite == NULL)
		return;

	const_cast<CWnd*>(this)->InvokeHelper(dwDispID, DISPATCH_PROPERTYGET,
		vtProp, pvProp, NULL);
}

void AFX_CDECL CWnd::SetProperty(DISPID dwDispID, VARTYPE vtProp, ...)
{
	ASSERT(m_pCtrlSite != NULL);    // not an OLE control (not yet, at least)

	if (m_pCtrlSite == NULL)
		return;

	va_list argList;    // really only one arg, but...
	va_start(argList, vtProp);
	m_pCtrlSite->SetPropertyV(dwDispID, vtProp, argList);
	va_end(argList);
}

IUnknown* CWnd::GetDSCCursor()
{
	ASSERT(m_pCtrlSite != NULL);    // not an OLE control (not yet, at least)
	if (m_pCtrlSite == NULL)
		return NULL;

	m_pCtrlSite->EnableDSC();

	IUnknown* pCursor = m_pCtrlSite->m_pDataSourceControl->GetCursor();
	ASSERT(pCursor != NULL);  // data source control has no cursor

	return pCursor;
}

void CWnd::BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd)
{
	ASSERT(m_pCtrlSite != NULL); // not an OLE control (not yet, at least)
	m_pCtrlSite->BindDefaultProperty(dwDispID, vtProp, szFieldName, pDSCWnd);
}

void CWnd::BindProperty(DISPID dwDispId, CWnd* pWndDSC)
{
	ASSERT(m_pCtrlSite != NULL); // not an OLE control (not yet, at least)
	m_pCtrlSite->BindProperty(dwDispId, pWndDSC);
}

/////////////////////////////////////////////////////////////////////////////
// CWnd implementation helpers

void CWnd::AttachControlSite(CHandleMap* pMap)
{
	if (this != NULL && m_pCtrlSite == NULL)
	{
		// Determine if parent is an OLE control container
		CWnd* pWndParent = (CWnd*)pMap->LookupPermanent(::GetParent(m_hWnd));
		if (pWndParent != NULL && pWndParent->m_pCtrlCont != NULL)
		{
			// delegate through helper in COleControlSite
			pWndParent->m_pCtrlCont->AttachControlSite(this);
		}
	}
}

void CWnd::AttachControlSite(CWnd* pWndParent, UINT nIDC)
{
	ASSERT(this != NULL);
	ASSERT(pWndParent != NULL);

	if (m_pCtrlSite == NULL && pWndParent->m_pCtrlCont != NULL)
	{
		// delegate through helper in COleControlSite
		pWndParent->m_pCtrlCont->AttachControlSite(this, nIDC);
	}
}

DWORD COleControlSiteOrWnd::GetStyle() const
{
	if(m_pSite)
		return m_pSite->GetStyle();
	else
		return (DWORD) ::GetWindowLong(m_hWnd, GWL_STYLE);
}

COleControlSiteOrWnd* CWnd::GetNextDlgTabItem(COleControlSiteOrWnd *pCurSiteOrWnd, BOOL bPrevious) const
{
	if(!m_pCtrlCont)
		return NULL;
	if ((m_nFlags & WF_NOWIN32ISDIALOGMSG)==0)
	{
		CWnd * pChildWnd = GetWindow(GW_CHILD);
		while (NULL != pChildWnd)
		{
			if ( (pChildWnd->GetExStyle() & WS_EX_CONTROLPARENT) 
				&& (pChildWnd->GetStyle() & WS_VISIBLE) 
				&& !(pChildWnd->GetStyle() & WS_DISABLED) )
			{
				return NULL;
			}
			pChildWnd = pChildWnd->GetNextWindow(GW_HWNDNEXT);
		}
	}

	DWORD dwStyle;
	COleControlSiteOrWnd *pSiteOrWnd, *pSiteOrWndFocus = NULL;

	POSITION pos;
	typedef CTypedPtrList<CPtrList, COleControlSiteOrWnd *> coll_t;
	COleControlSiteOrWnd *&(coll_t::*Next)(POSITION &);
	POSITION (coll_t::*Head)() const;

	if(bPrevious)
	{
		Next = &coll_t::GetPrev;
		Head = &coll_t::GetTailPosition;
	}
	else
	{
		Next = &coll_t::GetNext;
		Head = &coll_t::GetHeadPosition;
	}

	pos = (m_pCtrlCont->m_listSitesOrWnds.*Head)();
	// Find current control
	while(pos)
	{
		pSiteOrWnd = (m_pCtrlCont->m_listSitesOrWnds.*Next)(pos);
		ASSERT(pSiteOrWnd);
		if (pCurSiteOrWnd)
		{
			if (pCurSiteOrWnd == pSiteOrWnd)
			{
				pSiteOrWndFocus = pSiteOrWnd;
				break;
			}
		}
		else
		{
			HWND hwndControl=pSiteOrWnd->m_pSite ? pSiteOrWnd->m_pSite->m_hWnd : pSiteOrWnd->m_hWnd;
			if((hwndControl && hwndControl == ::GetFocus()) ||
				(pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite == m_pCtrlCont->m_pSiteFocus))
			{
				pSiteOrWndFocus = pSiteOrWnd;
				break;
			}
		}
	}

	// Didn't find current control
	if(!pSiteOrWndFocus)
		return NULL;

	// Search for the next control with the WS_TABSTOP style.
	
	
	do
	{
		// Start over if we've reached the "end". pos is NULL if pSiteOrWndFocus
		// is last in m_listSitesOrWnds.
		if(!pos)
		{
			pos = (m_pCtrlCont->m_listSitesOrWnds.*Head)();
		}
		pSiteOrWnd = (m_pCtrlCont->m_listSitesOrWnds.*Next)(pos);
		dwStyle = pSiteOrWnd->GetStyle();

		// if we've wrapped or there's only one control OR
		// the control has the tabstop style set and it's
		// not disabled and it is also visible.
		if(pSiteOrWnd == pSiteOrWndFocus ||
			((dwStyle & WS_TABSTOP) && !(dwStyle & WS_DISABLED) && (dwStyle & WS_VISIBLE) ))
		{
			return pSiteOrWnd;
		}
	}
	while(true);

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

template<class BASE_CLASS, class TYPE>
class CTypedPtrListIterator
{
	typedef CTypedPtrList<BASE_CLASS, TYPE> CCollection;

	const CCollection *m_pList;
	POSITION m_pos;

public:
	CTypedPtrListIterator(const CCollection &list) : 
		m_pList(&list), m_pos(m_pList->GetHeadPosition()) {}
	
	CTypedPtrListIterator(const CCollection &list, POSITION position) : 
		m_pList(&list), m_pos(position) {}
	
	CTypedPtrListIterator(const CTypedPtrListIterator &iterator) : m_pList(iterator.m_pList)
	{
		ENSURE(m_pList == iterator.m_pList);
		m_pos = iterator.m_pos;
	}

	CTypedPtrListIterator &operator=(const CTypedPtrListIterator &iterator)
	{
		ENSURE(m_pList == iterator.m_pList);
		m_pos = iterator.m_pos;
		return *this;
	}

	POSITION GetPosition() const
	{
		return m_pos;
	}

	bool IsEnd() const 
	{
		return !m_pos;
	}
	
	bool operator!() const
	{
		return IsEnd();
	}

	bool operator==(const CTypedPtrListIterator &iterator) const
	{
		ENSURE(m_pList == iterator.m_pList);
		return m_pos == iterator.m_pos;
	}

	void MoveNext() 
	{ 
		if (m_pos)
		{
			m_pList->GetNext(m_pos); 
		}
	}

	void MovePrev() 
	{
		if (m_pos)
		{
			m_pList->GetPrev(m_pos);
		}
	}

	CTypedPtrListIterator Skip(int nSteps) const
	{
		CTypedPtrListIterator iterator(*this);
		if (nSteps < 0)
		{
			for (; nSteps > 0 && !IsEnd(); --nSteps)
			{
				iterator.MovePrev();
			}
		}
		else
		{
			for (; nSteps > 0 && !IsEnd(); --nSteps)
			{
				iterator.MoveNext();
			}
		}
		return iterator;
	}

	TYPE operator*()
	{ 
		ENSURE(m_pos != NULL);
		return m_pList->GetAt(m_pos); 
	}

	const TYPE operator*() const
	{ 
		return const_cast<CTypedPtrListIterator*>(this)->operator*();
	}
};

class CDlgControlIterator : public CTypedPtrListIterator<CPtrList, COleControlSiteOrWnd*>
{
	typedef CTypedPtrListIterator<CPtrList, COleControlSiteOrWnd*> CBase;

public:
	CDlgControlIterator(const COleControlContainer &controls) : 
		CBase(controls.m_listSitesOrWnds) {}

	CDlgControlIterator(const COleControlContainer &controls, POSITION position) : 
		CBase(controls.m_listSitesOrWnds, position) {}
	
	CDlgControlIterator(const CDlgControlIterator &iterator) : CBase(iterator) {}
	
protected:
	CDlgControlIterator(const CBase &iterator) : CBase(iterator) {}

public:
	CDlgControlIterator Skip(int nSteps) const { return CBase::Skip(nSteps); }
};

/////////////////////////////////////////////////////////////////////////////

class CDlgGroupRadioButtonIterator
{
	CDlgControlIterator m_iterator;

public:
	CDlgGroupRadioButtonIterator(COleControlContainer &controls, POSITION position) : 
		m_iterator(controls, position) {}

	CDlgGroupRadioButtonIterator(const CDlgGroupRadioButtonIterator &iterator) : 
		m_iterator(iterator.m_iterator) {}

	bool IsEnd() const 
	{
		return m_iterator.IsEnd();
	}
	
	void MoveNext()
	{
		CDlgControlIterator iterator = m_iterator;
		BOOL bLoop = FALSE;
		while (TRUE)
		{
			iterator.MoveNext();
			if (iterator.IsEnd() || IsGroup(*iterator))
			{
				iterator = GetFirstButton();
				if (iterator.IsEnd() || bLoop)
				{
					return;
				}
				bLoop = TRUE;
			}
			if (!IsDisabled(*iterator))
			{
				break;
			}
		}
		m_iterator = iterator;
	}

	void MovePrev()
	{
		CDlgControlIterator iterator = m_iterator;
		BOOL bLoop = FALSE;
		while (TRUE)
		{
			if (iterator.IsEnd() || IsGroup(*iterator))
			{
				iterator = GetLastButton();
				if (!iterator || bLoop)
				{
					return;
				}
				bLoop = TRUE;
			}
			else
			{
				iterator.MovePrev();
			}
			if (!iterator.IsEnd() && !IsDisabled(*iterator))
			{
				break;
			}
		}
		m_iterator = iterator;
	}
	
	operator COleControlSiteOrWnd*() const
	{ 
		ENSURE(!m_iterator.IsEnd());
		return *m_iterator; 
	}
	
	static bool IsDisabled(const COleControlSiteOrWnd *pButton)
	{
		if (pButton->m_hWnd && SendMessage(pButton->m_hWnd, WM_GETDLGCODE, 0, 0) & DLGC_STATIC)
		{
			return true;
		}
		DWORD dwStyle = pButton->GetStyle();
		return !(dwStyle & WS_VISIBLE) || !!(dwStyle & WS_DISABLED);
	}
	
	static bool IsGroup(const COleControlSiteOrWnd *pButton)
	{
		return !!(pButton->GetStyle() & WS_GROUP);
	}
	
	CDlgControlIterator GetFirstButton() const
	{
		// The first button in a group is marked with WS_GROUP
		// If there is no button marked this way, the first button on the dialog is selected
		CDlgControlIterator iterator = m_iterator, lastPosition = iterator;
		while (!iterator.IsEnd() && !IsGroup(*iterator))
		{
			lastPosition = iterator;
			iterator.MovePrev();
		}
		if (!iterator)
		{
			return lastPosition;
		}
		return iterator;
	}
	
	CDlgControlIterator GetLastButton() const
	{
		// The last button in a group is one button prior to the next button 
		// marked with WS_GROUP, if such exists, or otherwise, the last button 
		// on the dialog
		CDlgControlIterator iterator = m_iterator, nextPosition = iterator.Skip(1);
		while (!nextPosition.IsEnd() && !IsGroup(*nextPosition))
		{
			nextPosition.MoveNext();
			iterator.MoveNext();
		}
		return iterator;
	}
};

/////////////////////////////////////////////////////////////////////////////

POSITION CWnd::FindSiteOrWnd(const COleControlSiteOrWnd *pSiteOrWnd) const
{
	if (!m_pCtrlCont)
	{
		return NULL;
	}
	CDlgControlIterator iterCtl = *m_pCtrlCont;
	while (!iterCtl.IsEnd())
	{
		if (*iterCtl == pSiteOrWnd)
		{
			return iterCtl.GetPosition();
		}
		iterCtl.MoveNext();
	}
	return NULL;
}

POSITION CWnd::FindSiteOrWndWithFocus() const
{
	if (!m_pCtrlCont)
	{
		return NULL;
	}
	CDlgControlIterator iterCtl= *m_pCtrlCont;
	while (!iterCtl.IsEnd())
	{
		COleControlSiteOrWnd *pSiteOrWnd = *iterCtl;
		HWND hwndControl = pSiteOrWnd->m_pSite ? pSiteOrWnd->m_pSite->m_hWnd : pSiteOrWnd->m_hWnd;
		if ((hwndControl && hwndControl == ::GetFocus()) ||
			(pSiteOrWnd->m_pSite && pSiteOrWnd->m_pSite == m_pCtrlCont->m_pSiteFocus))
		{
			return iterCtl.GetPosition();
		}
		iterCtl.MoveNext();
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

COleControlSiteOrWnd* CWnd::GetPrevDlgGroupItem(COleControlSiteOrWnd *pCurSiteOrWnd) const
{
	if (!m_pCtrlCont)
	{
		return NULL;
	}

	POSITION pos = pCurSiteOrWnd ? FindSiteOrWnd(pCurSiteOrWnd) : FindSiteOrWndWithFocus();
	if (!pos)
	{
		return NULL;
	}

	CDlgGroupRadioButtonIterator iterator(*m_pCtrlCont, pos);
	iterator.MovePrev();;
	if (!iterator.IsEnd())
	{
		return iterator;
	}
	return NULL;
}

COleControlSiteOrWnd* CWnd::GetNextDlgGroupItem(COleControlSiteOrWnd *pCurSiteOrWnd) const
{
	if (!m_pCtrlCont)
	{
		return NULL;
	}

	POSITION pos = pCurSiteOrWnd ? FindSiteOrWnd(pCurSiteOrWnd) : FindSiteOrWndWithFocus();
	if (!pos)
	{
		return NULL;
	}

	CDlgGroupRadioButtonIterator iterator(*m_pCtrlCont, pos);
	iterator.MoveNext();
	if (!iterator.IsEnd())
	{
		return iterator;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

void CWnd::RemoveRadioCheckFromGroup(const COleControlSiteOrWnd *pSiteOrWnd) const
{
	if(!m_pCtrlCont || !pSiteOrWnd)
		return;

	// Try a short cut (i.e., if this is the one that's checked uncheck it
	// and return)
	if(pSiteOrWnd->m_bAutoRadioButton &&
		BST_CHECKED == ::SendMessage(pSiteOrWnd->m_hWnd, BM_GETCHECK, 0, 0))
	{
		::SendMessage(pSiteOrWnd->m_hWnd, BM_SETCHECK, BST_UNCHECKED, 0);
		return;
	}

	// Dang.
	COleControlSiteOrWnd *pSite;
	POSITION pos, posCur =
		m_pCtrlCont->m_listSitesOrWnds.Find(const_cast<COleControlSiteOrWnd *>(pSiteOrWnd));

	// Start at the control after the passed in control and go "down" through the
	// control list looking for a checked auto-radio button.
	pos = posCur;
	m_pCtrlCont->m_listSitesOrWnds.GetNext(pos);
	while(pos)
	{
		pSite = m_pCtrlCont->m_listSitesOrWnds.GetNext(pos);
		if(pSite->GetStyle() & WS_GROUP)
			break;

		if(pSite->m_bAutoRadioButton &&
			BST_CHECKED == ::SendMessage(pSite->m_hWnd, BM_GETCHECK, 0, 0))
		{
			::SendMessage(pSite->m_hWnd, BM_SETCHECK, BST_UNCHECKED, 0);
			return;
		}
	}

	// Double dang.  Start at the control before the passed in control and go "up"
	// through the control list looking for a checked auto-radio button.
	pos = posCur;
	m_pCtrlCont->m_listSitesOrWnds.GetPrev(pos);
	while(pos)
	{
		pSite = m_pCtrlCont->m_listSitesOrWnds.GetPrev(pos);
		if(pSite->m_bAutoRadioButton &&
			BST_CHECKED == ::SendMessage(pSite->m_hWnd, BM_GETCHECK, 0, 0))
		{
			::SendMessage(pSite->m_hWnd, BM_SETCHECK, BST_UNCHECKED, 0);
			return;
		}
		if(pSite->GetStyle() & WS_GROUP)
			break;
	}
}

void COleControlContainer::AttachControlSite(CWnd* pWnd, UINT nIDC)
{
	ASSERT(this != NULL);
	ASSERT(pWnd != NULL);

   COleControlSite* pSite;

	// If a matching control site exists, it's an OLE control
   if (nIDC == 0)
   {
	   pSite = (COleControlSite*)m_siteMap.GetValueAt(pWnd->m_hWnd);
   }
   else
   {
	  pSite = FindItem(nIDC);
   }
	if (pSite != NULL)
	{
		// detach any existing CWnd from this site (last one wins)
		CWnd* pOldCtrl = pSite->m_pWndCtrl;
		if (pOldCtrl != NULL && pOldCtrl->m_pCtrlSite == pSite)
			pOldCtrl->m_pCtrlSite = NULL;

		// now wire the site and CWnd together
		pWnd->m_pCtrlSite = pSite;
		pSite->m_pWndCtrl = pWnd;
	}
}

#endif // !_AFX_NO_OCC_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winmini.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#pragma warning(disable: 4706) // assignment within conditional

/////////////////////////////////////////////////////////////////////////////
// CMiniFrameWnd

BEGIN_MESSAGE_MAP(CMiniFrameWnd, CFrameWnd)
	//{{AFX_MSG_MAP(CMiniFrameWnd)
	ON_WM_NCACTIVATE()
	ON_WM_NCHITTEST()
	ON_WM_SYSCOMMAND()
	ON_WM_GETMINMAXINFO()
	ON_WM_NCCREATE()
	ON_MESSAGE(WM_FLOATSTATUS, &CMiniFrameWnd::OnFloatStatus)
	ON_MESSAGE(WM_QUERYCENTERWND, &CMiniFrameWnd::OnQueryCenterWnd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CMiniFrameWnd constructors

CMiniFrameWnd::CMiniFrameWnd()
{
	m_bActive = FALSE;
}

CMiniFrameWnd::~CMiniFrameWnd()
{
	DestroyWindow();
}

BOOL CMiniFrameWnd::Create(LPCTSTR lpClassName, LPCTSTR lpszWindowName,
	DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	return CMiniFrameWnd::CreateEx(0, lpClassName, lpszWindowName, dwStyle,
		rect, pParentWnd, nID);
}

BOOL CMiniFrameWnd::CreateEx(DWORD dwExStyle, LPCTSTR lpClassName,
	LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID)
{
	m_strCaption = lpszWindowName;
	return CWnd::CreateEx(dwExStyle, lpClassName ? lpClassName :
		AfxRegisterWndClass(CS_DBLCLKS, ::LoadCursor(NULL, IDC_ARROW)),
		lpszWindowName, dwStyle, rect.left, rect.top, rect.right - rect.left,
		rect.bottom - rect.top, pParentWnd->GetSafeHwnd(), (HMENU)(UINT_PTR)nID);
}

/////////////////////////////////////////////////////////////////////////////
// CMiniFrameWnd message handlers

BOOL CMiniFrameWnd::OnNcCreate(LPCREATESTRUCT lpcs)
{
	if (!CFrameWnd::OnNcCreate(lpcs))
		return FALSE;

	if (GetStyle() & MFS_SYNCACTIVE)
	{
		// syncronize activation state with top level parent
		CWnd* pParentWnd = EnsureTopLevelParent();
		CWnd* pActiveWnd = GetForegroundWindow();
		BOOL bActive = (pParentWnd == pActiveWnd) ||
			(pParentWnd->GetLastActivePopup() == pActiveWnd &&
			 pActiveWnd->SendMessage(WM_FLOATSTATUS, FS_SYNCACTIVE) != 0);

		// the WM_FLOATSTATUS does the actual work
		SendMessage(WM_FLOATSTATUS, bActive ? FS_ACTIVATE : FS_DEACTIVATE);
	}

	return TRUE;
}

BOOL CMiniFrameWnd::PreCreateWindow(CREATESTRUCT& cs)
{
	// WS_4THICKFRAME and MFS_THICKFRAME imply WS_THICKFRAME
	if (cs.style & (MFS_4THICKFRAME | MFS_THICKFRAME))
		cs.style |= WS_THICKFRAME;

	// WS_CAPTION implies WS_EX_TOOLWINDOW
	if (cs.style & WS_CAPTION)
		cs.dwExStyle |= WS_EX_TOOLWINDOW;

	VERIFY(CFrameWnd::PreCreateWindow(cs));
	cs.dwExStyle &= ~(WS_EX_CLIENTEDGE);

	return TRUE;
}

void CMiniFrameWnd::OnGetMinMaxInfo(MINMAXINFO* pMMI)
{
	// allow Windows to fill in the defaults
	CFrameWnd::OnGetMinMaxInfo(pMMI);

	// don't allow sizing smaller than the non-client area
	CRect rectWindow, rectClient;
	GetWindowRect(rectWindow);
	GetClientRect(rectClient);
	pMMI->ptMinTrackSize.x = rectWindow.Width() - rectClient.right;
	pMMI->ptMinTrackSize.y = rectWindow.Height() - rectClient.bottom;
}

BOOL CMiniFrameWnd::OnNcActivate(BOOL /* bActive */)
{
	if ((GetStyle() & MFS_SYNCACTIVE) == 0)
		return Default() != 0;

	if(m_nFlags & WF_KEEPMINIACTIVE)
		return FALSE;

	return TRUE;
}

LRESULT CMiniFrameWnd::OnNcHitTest(CPoint point)
{
	DWORD dwStyle = GetStyle();
	CRect rectWindow;
	GetWindowRect(&rectWindow);

	CSize sizeFrame(GetSystemMetrics(SM_CXFRAME),
		GetSystemMetrics(SM_CYFRAME));

	LRESULT nHit = CFrameWnd::OnNcHitTest(point);

	// MFS_BLOCKSYSMENU translates system menu hit to caption hit
	if (dwStyle & MFS_BLOCKSYSMENU)
	{
		if (nHit == HTSYSMENU)
			nHit = HTCAPTION;
		if (GetKeyState(VK_RBUTTON) < 0)
			return HTNOWHERE;
	}

	if ((nHit < HTSIZEFIRST || nHit > HTSIZELAST) && nHit != HTGROWBOX)
		return nHit;

	// MFS_MOVEFRAME translates all size requests to move requests
	if (dwStyle & MFS_MOVEFRAME)
		return HTCAPTION;

	// MFS_4THICKFRAME does not allow diagonal sizing
	rectWindow.InflateRect(-sizeFrame.cx, -sizeFrame.cy);
	if (dwStyle & MFS_4THICKFRAME)
	{
		switch (nHit)
		{
		case HTTOPLEFT:
			return point.y < rectWindow.top ? HTTOP : HTLEFT;
		case HTTOPRIGHT:
			return point.y < rectWindow.top ? HTTOP : HTRIGHT;
		case HTBOTTOMLEFT:
			return point.y > rectWindow.bottom ? HTBOTTOM : HTLEFT;
		case HTGROWBOX:
		case HTBOTTOMRIGHT:
			return point.y > rectWindow.bottom ? HTBOTTOM : HTRIGHT;
		}
	}
	return nHit;    // no special translation
}

void CMiniFrameWnd::OnSysCommand(UINT nID, LPARAM lParam)
{
	DWORD dwStyle = GetStyle();
	if ((dwStyle & WS_POPUP) &&
		((nID & 0xFFF0) != SC_CLOSE ||
		(GetKeyState(VK_F4) < 0 && GetKeyState(VK_MENU) < 0 &&
		(dwStyle & MFS_SYNCACTIVE))))
	{
		if (HandleFloatingSysCommand(nID, lParam))
			return;
	}
	CFrameWnd::OnSysCommand(nID, lParam);
}

void PASCAL CMiniFrameWnd::CalcBorders(
	LPRECT lpClientRect, DWORD dwStyle, DWORD dwExStyle)
{
	UNUSED_ALWAYS(dwExStyle);

	AdjustWindowRectEx(lpClientRect, dwStyle, FALSE, WS_EX_PALETTEWINDOW);
}

LRESULT CMiniFrameWnd::OnFloatStatus(WPARAM wParam, LPARAM)
{
	// these asserts make sure no conflicting actions are requested
	ASSERT(!((wParam & FS_SHOW) && (wParam & FS_HIDE)));
	ASSERT(!((wParam & FS_ENABLE) && (wParam & FS_DISABLE)));
	ASSERT(!((wParam & FS_ACTIVATE) && (wParam & FS_DEACTIVATE)));

	// FS_SYNCACTIVE is used to detect MFS_SYNCACTIVE windows
	LRESULT lResult = 0;
	if ((GetStyle() & MFS_SYNCACTIVE) && (wParam & FS_SYNCACTIVE))
		lResult = 1;

	if (wParam & (FS_SHOW|FS_HIDE))
	{
		SetWindowPos(NULL, 0, 0, 0, 0,
			((wParam & FS_SHOW) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW) | SWP_NOZORDER |
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
	}
	if (wParam & (FS_ENABLE|FS_DISABLE))
		EnableWindow((wParam & FS_ENABLE) != 0);

	if ((wParam & (FS_ACTIVATE|FS_DEACTIVATE)) &&
		GetStyle() & MFS_SYNCACTIVE)
	{
		ModifyStyle(MFS_SYNCACTIVE, 0);
		SendMessage(WM_NCACTIVATE, (wParam & FS_ACTIVATE) != 0);
		ModifyStyle(0, MFS_SYNCACTIVE);
	}

	return lResult;
}

LRESULT CMiniFrameWnd::OnQueryCenterWnd(WPARAM, LPARAM)
{
	// forward WM_QUERYCENTERWND to parent window
	HWND hWndParent = ::GetParent(m_hWnd);
	LRESULT lResult = ::SendMessage(hWndParent, WM_QUERYCENTERWND, 0, 0);
	if (lResult == 0)
		lResult = (LRESULT)hWndParent;
	return lResult;
}


IMPLEMENT_DYNCREATE(CMiniFrameWnd, CFrameWnd)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winmdi.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxmdichildwndex.h"
#include "afxmdiframewndex.h"

/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWnd

BEGIN_MESSAGE_MAP(CMDIFrameWnd, CFrameWnd)
	//{{AFX_MSG_MAP(CMDIFrameWnd)
	ON_MESSAGE_VOID(WM_IDLEUPDATECMDUI, CMDIFrameWnd::OnIdleUpdateCmdUI)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_ARRANGE, &CMDIFrameWnd::OnUpdateMDIWindowCmd)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_CASCADE, &CMDIFrameWnd::OnUpdateMDIWindowCmd)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_TILE_HORZ, &CMDIFrameWnd::OnUpdateMDIWindowCmd)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_TILE_VERT, &CMDIFrameWnd::OnUpdateMDIWindowCmd)
	ON_WM_SIZE()
	ON_COMMAND_EX(ID_WINDOW_ARRANGE, &CMDIFrameWnd::OnMDIWindowCmd)
	ON_COMMAND_EX(ID_WINDOW_CASCADE, &CMDIFrameWnd::OnMDIWindowCmd)
	ON_COMMAND_EX(ID_WINDOW_TILE_HORZ, &CMDIFrameWnd::OnMDIWindowCmd)
	ON_COMMAND_EX(ID_WINDOW_TILE_VERT, &CMDIFrameWnd::OnMDIWindowCmd)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_NEW, &CMDIFrameWnd::OnUpdateMDIWindowCmd)
	ON_COMMAND(ID_WINDOW_NEW, &CMDIFrameWnd::OnWindowNew)
	ON_WM_DESTROY()
	ON_MESSAGE(WM_COMMANDHELP, &CMDIFrameWnd::OnCommandHelp)
	ON_WM_MENUCHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMDIFrameWnd::CMDIFrameWnd()
{
	m_hWndMDIClient = NULL;
}

BOOL CMDIFrameWnd::OnCommand(WPARAM wParam, LPARAM lParam)
{
	// send to MDI child first - will be re-sent through OnCmdMsg later
	CMDIChildWnd* pActiveChild = MDIGetActive();
	if (pActiveChild != NULL && AfxCallWndProc(pActiveChild,
	  pActiveChild->m_hWnd, WM_COMMAND, wParam, lParam) != 0)
		return TRUE; // handled by child

	if (CFrameWnd::OnCommand(wParam, lParam))
		return TRUE; // handled through normal mechanism (MDI child or frame)

	HWND hWndCtrl = (HWND)lParam;

	ASSERT(AFX_IDM_FIRST_MDICHILD == 0xFF00);
	if (hWndCtrl == NULL && (LOWORD(wParam) & 0xf000) == 0xf000)
	{
		// menu or accelerator within range of MDI children
		// default frame proc will handle it
		DefWindowProc(WM_COMMAND, wParam, lParam);
		return TRUE;
	}

	return FALSE;   // not handled
}

BOOL CMDIFrameWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	CMDIChildWnd* pActiveChild = MDIGetActive();
	// pump through active child FIRST
	if (pActiveChild != NULL)
	{
		CPushRoutingFrame push(this);
		if (pActiveChild->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
			return TRUE;
	}

	// then pump through normal frame
	return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

LRESULT CMDIFrameWnd::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	if (lParam == 0 && IsTracking())
		lParam = HID_BASE_COMMAND+m_nIDTracking;

	CMDIChildWnd* pActiveChild = MDIGetActive();
	if (pActiveChild != NULL && AfxCallWndProc(pActiveChild,
	  pActiveChild->m_hWnd, WM_COMMANDHELP, wParam, lParam) != 0)
	{
		// handled by child
		return TRUE;
	}

	if (CFrameWnd::OnCommandHelp(wParam, lParam))
	{
		// handled by our base
		return TRUE;
	}

	if (lParam != 0)
	{
		CWinApp* pApp = AfxGetApp();
		if (pApp != NULL)
		{
			AfxGetApp()->WinHelpInternal(lParam);
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CMDIFrameWnd::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext*)
{
	CMenu* pMenu = NULL;
	if (m_hMenuDefault == NULL)
	{
		// default implementation for MFC V1 backward compatibility
		pMenu = GetMenu();
		ASSERT(pMenu != NULL);
		// This is attempting to guess which sub-menu is the Window menu.
		// The Windows user interface guidelines say that the right-most
		// menu on the menu bar should be Help and Window should be one
		// to the left of that.
		int iMenu = pMenu->GetMenuItemCount() - 2;

		// If this assertion fails, your menu bar does not follow the guidelines
		// so you will have to override this function and call CreateClient
		// appropriately or use the MFC V2 MDI functionality.
		ASSERT(iMenu >= 0);
		pMenu = pMenu->GetSubMenu(iMenu);
		ASSERT(pMenu != NULL);
	}

	return CreateClient(lpcs, pMenu);
}

BOOL CMDIFrameWnd::CreateClient(LPCREATESTRUCT lpCreateStruct,
	CMenu* pWindowMenu)
{
	ASSERT(m_hWnd != NULL);
	ASSERT(m_hWndMDIClient == NULL);
	DWORD dwStyle = WS_VISIBLE | WS_CHILD | WS_BORDER |
		WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
		MDIS_ALLCHILDSTYLES;    // allow children to be created invisible
	DWORD dwExStyle = 0;
	// will be inset by the frame

	// special styles for 3d effect on Win4
	dwStyle &= ~WS_BORDER;
	dwExStyle = WS_EX_CLIENTEDGE;

	CLIENTCREATESTRUCT ccs;
	ccs.hWindowMenu = pWindowMenu->GetSafeHmenu();
		// set hWindowMenu for MFC V1 backward compatibility
		// for MFC V2, window menu will be set in OnMDIActivate
	ccs.idFirstChild = AFX_IDM_FIRST_MDICHILD;

	if (lpCreateStruct->style & (WS_HSCROLL|WS_VSCROLL))
	{
		// parent MDIFrame's scroll styles move to the MDICLIENT
		dwStyle |= (lpCreateStruct->style & (WS_HSCROLL|WS_VSCROLL));

		// fast way to turn off the scrollbar bits (without a resize)
		ModifyStyle(WS_HSCROLL|WS_VSCROLL, 0, SWP_NOREDRAW|SWP_FRAMECHANGED);
	}

	// Create MDICLIENT control with special IDC
	if ((m_hWndMDIClient = ::AfxCtxCreateWindowEx(dwExStyle, _T("mdiclient"), NULL,
		dwStyle, 0, 0, 0, 0, m_hWnd, (HMENU)AFX_IDW_PANE_FIRST,
		AfxGetInstanceHandle(), (LPVOID)&ccs)) == NULL)
	{
		TRACE(traceAppMsg, 0, _T("Warning: CMDIFrameWnd::OnCreateClient: failed to create MDICLIENT.")
			_T(" GetLastError returns 0x%8.8X\n"), ::GetLastError());
		return FALSE;
	}
	// Move it to the top of z-order
	::BringWindowToTop(m_hWndMDIClient);

	return TRUE;
}

LRESULT CMDIFrameWnd::DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	return ::DefFrameProc(m_hWnd, m_hWndMDIClient, nMsg, wParam, lParam);
}

BOOL CMDIFrameWnd::PreTranslateMessage(MSG* pMsg)
{
	// check for special cancel modes for ComboBoxes
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_NCLBUTTONDOWN)
		AfxCancelModes(pMsg->hwnd);    // filter clicks

	// allow tooltip messages to be filtered
	if (CWnd::PreTranslateMessage(pMsg))
		return TRUE;

#ifndef _AFX_NO_OLE_SUPPORT
	// allow hook to consume message
	if (m_pNotifyHook != NULL && m_pNotifyHook->OnPreTranslateMessage(pMsg))
		return TRUE;
#endif

	CMDIChildWnd* pActiveChild = MDIGetActive();

	// current active child gets first crack at it
	if (pActiveChild != NULL && pActiveChild->PreTranslateMessage(pMsg))
		return TRUE;

	if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
	{
		// translate accelerators for frame and any children
		if (m_hAccelTable != NULL &&
			::TranslateAccelerator(m_hWnd, m_hAccelTable, pMsg))
		{
			return TRUE;
		}

		// special processing for MDI accelerators last
		// and only if it is not in SDI mode (print preview)
		if (GetActiveView() == NULL)
		{
			if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN)
			{
				// the MDICLIENT window may translate it
				if (::TranslateMDISysAccel(m_hWndMDIClient, pMsg))
					return TRUE;
			}
		}
	}

	return FALSE;
}

void CMDIFrameWnd::DelayUpdateFrameMenu(HMENU hMenuAlt)
{
	OnUpdateFrameMenu(hMenuAlt);

	m_nIdleFlags |= idleMenu;
}

void CMDIFrameWnd::OnIdleUpdateCmdUI()
{
	if (m_nIdleFlags & idleMenu)
	{
		DrawMenuBar();
		m_nIdleFlags &= ~idleMenu;
	}
	CFrameWnd::OnIdleUpdateCmdUI();
}

CFrameWnd* CMDIFrameWnd::GetActiveFrame()
{
	CMDIChildWnd* pActiveChild = MDIGetActive();
	if (pActiveChild == NULL)
		return this;
	return pActiveChild;
}

BOOL CMDIFrameWnd::PreCreateWindow(CREATESTRUCT& cs)
{
	if (cs.lpszClass == NULL)
	{
		VERIFY(AfxDeferRegisterClass(AFX_WNDMDIFRAME_REG));
		cs.lpszClass = _afxWndMDIFrame;
	}
	return TRUE;
}

BOOL CMDIFrameWnd::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
	CWnd* pParentWnd, CCreateContext* pContext)
{
	if (!CFrameWnd::LoadFrame(nIDResource, dwDefaultStyle,
	  pParentWnd, pContext))
		return FALSE;

	// save menu to use when no active MDI child window is present
	ASSERT(m_hWnd != NULL);
	m_hMenuDefault = ::GetMenu(m_hWnd);
	return TRUE;
}

void CMDIFrameWnd::OnDestroy()
{
	CFrameWnd::OnDestroy();     // exit and misc cleanup

	// owned menu stored in shared slot for MDIFRAME
	if (m_hMenuDefault != NULL && ::GetMenu(m_hWnd) != m_hMenuDefault)
	{
		// must go through MDI client to get rid of MDI menu additions
		::SendMessage(m_hWndMDIClient, WM_MDISETMENU,
			(WPARAM)m_hMenuDefault, NULL);
		ASSERT(::GetMenu(m_hWnd) == m_hMenuDefault);
	}
}

void CMDIFrameWnd::OnSize(UINT nType, int, int)
{
	// do not call default - it will reposition the MDICLIENT
	if (nType != SIZE_MINIMIZED)
		RecalcLayout();
}

LRESULT CMDIFrameWnd::OnMenuChar(UINT nChar, UINT, CMenu*)
{
	// do not call Default() for Alt+(-) when in print preview mode
	if (m_lpfnCloseProc != NULL && nChar == (UINT)'-')
		return 0;
	else
		return Default();
}

CMDIChildWnd* CMDIFrameWnd::MDIGetActive(BOOL* pbMaximized) const
{
	// check first for MDI client window not created
	if (m_hWndMDIClient == NULL)
	{
		if (pbMaximized != NULL)
			*pbMaximized = FALSE;
		return NULL;
	}

	// MDI client has been created, get active MDI child
	HWND hWnd = (HWND)::SendMessage(m_hWndMDIClient, WM_MDIGETACTIVE, 0,
		(LPARAM)pbMaximized);
	CMDIChildWnd* pWnd = (CMDIChildWnd*)CWnd::FromHandlePermanent(hWnd);
	ASSERT(pWnd == NULL || pWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)));

	// check for special pseudo-inactive state
	if (pWnd != NULL && pWnd->m_bPseudoInactive &&
		(pWnd->GetStyle() & WS_VISIBLE) == 0)
	{
		// Window is hidden, active, but m_bPseudoInactive -- return NULL
		pWnd = NULL;
		// Ignore maximized flag if pseudo-inactive and maximized
		if (pbMaximized != NULL)
			*pbMaximized = FALSE;
	}
	return pWnd;
}


CMDIChildWnd* CMDIFrameWnd::CreateNewChild(CRuntimeClass* pClass,
		UINT nResources, HMENU hMenu /* = NULL */, HACCEL hAccel /* = NULL */)
{
	ASSERT(pClass != NULL);
	CMDIChildWnd* pFrame = (CMDIChildWnd*) pClass->CreateObject();
	ASSERT_KINDOF(CMDIChildWnd, pFrame);

	// load the frame
	CCreateContext context;
	context.m_pCurrentFrame = this;

	pFrame->SetHandles(hMenu, hAccel);
	if (!pFrame->LoadFrame(nResources,
			WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, NULL, &context))
	{
		TRACE(traceAppMsg, 0, "Couldn't load frame window.\n");
		return NULL;
	}

	CString strFullString, strTitle;
	if (strFullString.LoadString(nResources))
		AfxExtractSubString(strTitle, strFullString, CDocTemplate::docName);

	// redraw the frame and parent
	pFrame->SetTitle(strTitle);
	pFrame->InitialUpdateFrame(NULL, TRUE);

	return pFrame;
}

/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWnd Diagnostics

#ifdef _DEBUG
void CMDIFrameWnd::AssertValid() const
{
	CFrameWnd::AssertValid();
	ASSERT(m_hWndMDIClient == NULL || ::IsWindow(m_hWndMDIClient));
	ASSERT(m_hMenuDefault == NULL || ::IsMenu(m_hMenuDefault));
}

void CMDIFrameWnd::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);

	dc << "m_hWndMDIClient = " << (void*)m_hWndMDIClient;
	dc << "\nm_hMenuDefault = " << (void*)m_hMenuDefault;

	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMDIChildWnd

BEGIN_MESSAGE_MAP(CMDIChildWnd, CFrameWnd)
	//{{AFX_MSG_MAP(CMDIChildWnd)
	ON_WM_MOUSEACTIVATE()
	ON_WM_NCACTIVATE()
	ON_WM_MDIACTIVATE()
	ON_WM_SIZE()
	ON_WM_WINDOWPOSCHANGING()
	ON_WM_NCCREATE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, &CMDIChildWnd::OnToolTipText)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, &CMDIChildWnd::OnToolTipText)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMDIChildWnd::CMDIChildWnd()
{
	m_hMenuShared = NULL;
	m_bPseudoInactive = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CMDIChildWnd special processing

LRESULT CMDIChildWnd::DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	return ::DefMDIChildProc(m_hWnd, nMsg, wParam, lParam);
}

BOOL CMDIChildWnd::DestroyWindow()
{
	if (m_hWnd == NULL)
		return FALSE;

	// avoid changing the caption during the destroy message(s)
	CMDIFrameWnd* pFrameWnd = GetMDIFrame();
	HWND hWndFrame = pFrameWnd->m_hWnd;
	ASSERT(::IsWindow(hWndFrame));
	DWORD dwStyle = SetWindowLong(hWndFrame, GWL_STYLE,
		GetWindowLong(hWndFrame, GWL_STYLE) & ~FWS_ADDTOTITLE);

	MDIDestroy();

	if (::IsWindow(hWndFrame))
	{
		ASSERT(hWndFrame == pFrameWnd->m_hWnd);
		SetWindowLong(hWndFrame, GWL_STYLE, dwStyle);
		pFrameWnd->OnUpdateFrameTitle(TRUE);
	}

	return TRUE;
}

BOOL CMDIChildWnd::PreTranslateMessage(MSG* pMsg)
{
	// check for special cancel modes for combo boxes
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_NCLBUTTONDOWN)
		AfxCancelModes(pMsg->hwnd);    // filter clicks

	// allow tooltip messages to be filtered
	if (CWnd::PreTranslateMessage(pMsg))
		return TRUE;

	// we can't call 'CFrameWnd::PreTranslate' since it will translate
	//  accelerators in the context of the MDI Child - but since MDI Child
	//  windows don't have menus this doesn't work properly.  MDI Child
	//  accelerators must be translated in context of their MDI Frame.

	if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
	{
		// use document specific accelerator table over m_hAccelTable
		HACCEL hAccel = GetDefaultAccelerator();
		return hAccel != NULL &&
		   ::TranslateAccelerator(GetMDIFrame()->m_hWnd, hAccel, pMsg);
	}
	return FALSE;
}

BOOL CMDIChildWnd::PreCreateWindow(CREATESTRUCT& cs)
{
	ASSERT(cs.style & WS_CHILD);
		// MFC V2 requires that MDI Children are created with proper styles,
		//  usually: WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW.
		// See Technical note TN019 for more details on MFC V1->V2 migration.

	return CFrameWnd::PreCreateWindow(cs);
}

BOOL CMDIChildWnd::Create(LPCTSTR lpszClassName,
	LPCTSTR lpszWindowName, DWORD dwStyle,
	const RECT& rect, CMDIFrameWnd* pParentWnd,
	CCreateContext* pContext)
{
	if (pParentWnd == NULL)
	{
		CWinThread *pThread = AfxGetThread();
		ENSURE_VALID(pThread);
		CWnd* pMainWnd = pThread->m_pMainWnd;
		ENSURE_VALID(pMainWnd);
		ASSERT_KINDOF(CMDIFrameWnd, pMainWnd);
		pParentWnd = (CMDIFrameWnd*)pMainWnd;
	}
	ASSERT(::IsWindow(pParentWnd->m_hWndMDIClient));

	// insure correct window positioning
	pParentWnd->RecalcLayout();

	// first copy into a CREATESTRUCT for PreCreate
	CREATESTRUCT cs;
	cs.dwExStyle = 0L;
	cs.lpszClass = lpszClassName;
	cs.lpszName = lpszWindowName;
	cs.style = dwStyle;
	cs.x = rect.left;
	cs.y = rect.top;
	cs.cx = rect.right - rect.left;
	cs.cy = rect.bottom - rect.top;
	cs.hwndParent = pParentWnd->m_hWnd;
	cs.hMenu = NULL;
	cs.hInstance = AfxGetInstanceHandle();
	cs.lpCreateParams = (LPVOID)pContext;

	if (!PreCreateWindow(cs))
	{
		PostNcDestroy();
		return FALSE;
	}
	// extended style must be zero for MDI Children (except under Win4)
	ASSERT(cs.hwndParent == pParentWnd->m_hWnd);    // must not change

	// now copy into a MDICREATESTRUCT for real create
	MDICREATESTRUCT mcs;
	mcs.szClass = cs.lpszClass;
	mcs.szTitle = cs.lpszName;
	mcs.hOwner = cs.hInstance;
	mcs.x = cs.x;
	mcs.y = cs.y;
	mcs.cx = cs.cx;
	mcs.cy = cs.cy;
	mcs.style = cs.style & ~(WS_MAXIMIZE | WS_VISIBLE);
	mcs.lParam = (LPARAM)cs.lpCreateParams;

	// create the window through the MDICLIENT window
	AfxHookWindowCreate(this);
	HWND hWnd = (HWND)::SendMessage(pParentWnd->m_hWndMDIClient,
		WM_MDICREATE, 0, (LPARAM)&mcs);
	if (!AfxUnhookWindowCreate())
		PostNcDestroy();        // cleanup if MDICREATE fails too soon

	if (hWnd == NULL)
		return FALSE;

	// special handling of visibility (always created invisible)
	if (cs.style & WS_VISIBLE)
	{
		// place the window on top in z-order before showing it
		::BringWindowToTop(hWnd);

		// show it as specified
		if (cs.style & WS_MINIMIZE)
			ShowWindow(SW_SHOWMINIMIZED);
		else if (cs.style & WS_MAXIMIZE)
			ShowWindow(SW_SHOWMAXIMIZED);
		else
			ShowWindow(SW_SHOWNORMAL);

		// make sure it is active (visibility == activation)
		pParentWnd->MDIActivate(this);

		// refresh MDI Window menu
		::SendMessage(pParentWnd->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
	}

	ASSERT(hWnd == m_hWnd);
	return TRUE;
}

BOOL CMDIChildWnd::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
		CWnd* pParentWnd, CCreateContext* pContext)
{
	// only do this once
	ASSERT_VALID_IDR(nIDResource);
	ASSERT(m_nIDHelp == 0 || m_nIDHelp == nIDResource);

	m_nIDHelp = nIDResource;    // ID for help context (+HID_BASE_RESOURCE)

	// parent must be MDI Frame (or NULL for default)
	ASSERT(pParentWnd == NULL || pParentWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));
	// will be a child of MDIClient
	ASSERT(!(dwDefaultStyle & WS_POPUP));
	dwDefaultStyle |= WS_CHILD;

	// if available - get MDI child menus from doc template
	CMultiDocTemplate* pTemplate;
	if (pContext != NULL &&
		(pTemplate = (CMultiDocTemplate*)pContext->m_pNewDocTemplate) != NULL)
	{
		ASSERT_KINDOF(CMultiDocTemplate, pTemplate);
		// get shared menu from doc template
		m_hMenuShared = pTemplate->m_hMenuShared;
		m_hAccelTable = pTemplate->m_hAccelTable;
	}
	else
	{
		TRACE(traceAppMsg, 0, "Warning: no shared menu/acceltable for MDI Child window.\n");
			// if this happens, programmer must load these manually
	}

	CString strFullString, strTitle;
	if (strFullString.LoadString(nIDResource))
		AfxExtractSubString(strTitle, strFullString, 0);    // first sub-string

	ASSERT(m_hWnd == NULL);
	if (!Create(GetIconWndClass(dwDefaultStyle, nIDResource),
	  strTitle, dwDefaultStyle, rectDefault,
	  (CMDIFrameWnd*)pParentWnd, pContext))
	{
		return FALSE;   // will self destruct on failure normally
	}

	// it worked !
	return TRUE;
}

void CMDIChildWnd::OnSize(UINT nType, int cx, int cy)
{
	CFrameWnd::OnSize(nType, cx, cy);

	// update our parent frame - in case we are now maximized or not
	GetMDIFrame()->OnUpdateFrameTitle(TRUE);
}

BOOL CMDIChildWnd::UpdateClientEdge(LPRECT lpRect)
{
	// only adjust for active MDI child window
	CMDIFrameWnd* pFrameWnd = GetMDIFrame();
	CMDIChildWnd* pChild = pFrameWnd->MDIGetActive();

	// Only adjust for regular MDI child windows, not tabbed windows.  Attempting to set WS_EX_CLIENTEDGE on the tabbed
	// MDI client area window is subverted by CMDIClientAreaWnd::OnStyleChanging, so we always try to reset the style and
	// always repaint, none of which is necessary since the tabbed MDI children never change from maximized to restored.
	CMDIChildWndEx* pChildEx = (pChild == NULL) ? NULL : DYNAMIC_DOWNCAST(CMDIChildWndEx, pChild);
	BOOL bIsTabbedMDIChild = (pChildEx == NULL) ? FALSE : pChildEx->GetMDIFrameWndEx() != NULL && pChildEx->GetMDIFrameWndEx()->AreMDITabs();
	if ((pChild == NULL || pChild == this) && !bIsTabbedMDIChild)
	{
		// need to adjust the client edge style as max/restore happens
		DWORD dwStyle = ::GetWindowLong(pFrameWnd->m_hWndMDIClient, GWL_EXSTYLE);
		DWORD dwNewStyle = dwStyle;
		if (pChild != NULL && !(GetExStyle() & WS_EX_CLIENTEDGE) && (GetStyle() & WS_MAXIMIZE))
		{
			dwNewStyle &= ~(WS_EX_CLIENTEDGE);
		}
		else
		{
			dwNewStyle |= WS_EX_CLIENTEDGE;
		}

		if (dwStyle != dwNewStyle)
		{
			// SetWindowPos will not move invalid bits
			::RedrawWindow(pFrameWnd->m_hWndMDIClient, NULL, NULL, RDW_INVALIDATE | RDW_ALLCHILDREN);

			// remove/add WS_EX_CLIENTEDGE to MDI client area
			::SetWindowLong(pFrameWnd->m_hWndMDIClient, GWL_EXSTYLE, dwNewStyle);
			::SetWindowPos(pFrameWnd->m_hWndMDIClient, NULL, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOCOPYBITS);

			// return new client area
			if (lpRect != NULL)
			{
				::GetClientRect(pFrameWnd->m_hWndMDIClient, lpRect);
			}

			return TRUE;
		}
	}

	return FALSE;
}

void CMDIChildWnd::OnWindowPosChanging(LPWINDOWPOS lpWndPos)
{
	if (!(lpWndPos->flags & SWP_NOSIZE))
	{
		CRect rectClient;
		if (UpdateClientEdge(rectClient) && (GetStyle() & WS_MAXIMIZE))
		{
			// adjust maximized window size and position based on new
			//  size/position of the MDI client area.
			::AdjustWindowRectEx(rectClient, GetStyle(), FALSE, GetExStyle());
			lpWndPos->x = rectClient.left;
			lpWndPos->y = rectClient.top;
			lpWndPos->cx = rectClient.Width();
			lpWndPos->cy = rectClient.Height();
		}
	}

	CFrameWnd::OnWindowPosChanging(lpWndPos);
}

void CMDIChildWnd::OnDestroy()
{
	UpdateClientEdge();

	CFrameWnd::OnDestroy();
}

BOOL CMDIChildWnd::OnNcActivate(BOOL bActive)
{
	// bypass CFrameWnd::OnNcActivate()
	return CWnd::OnNcActivate(bActive);
}

int CMDIChildWnd::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	int nResult = CFrameWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
	if (nResult == MA_NOACTIVATE || nResult == MA_NOACTIVATEANDEAT)
		return nResult;   // frame does not want to activate

	// activate this window if necessary
	CMDIFrameWnd* pFrameWnd = GetMDIFrame();
	ENSURE_VALID(pFrameWnd);
	CMDIChildWnd* pActive = pFrameWnd->MDIGetActive();
	if (pActive != this)
		MDIActivate();

	return nResult;
}

BOOL CMDIChildWnd::OnToolTipText(UINT msg, NMHDR* pNMHDR, LRESULT* pResult)
{
	ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);
	UNUSED(pNMHDR);

	// check to see if the message is going directly to this window or not
	const MSG* pMsg = GetCurrentMessage();
	if (pMsg->hwnd != m_hWnd)
	{
		// let top level frame handle this for us
		return FALSE;
	}

	// otherwise, handle it ourselves
	return CFrameWnd::OnToolTipText(msg, pNMHDR, pResult);
}

void CMDIChildWnd::ActivateFrame(int nCmdShow)
{
	BOOL bVisibleThen = (GetStyle() & WS_VISIBLE) != 0;
	CMDIFrameWnd* pFrameWnd = GetMDIFrame();
	ASSERT_VALID(pFrameWnd);

	// determine default show command
	if (nCmdShow == -1)
	{
		// get maximized state of frame window (previously active child)
		BOOL bMaximized;
		pFrameWnd->MDIGetActive(&bMaximized);

		// convert show command based on current style
		DWORD dwStyle = GetStyle();
		if (bMaximized || (dwStyle & WS_MAXIMIZE))
			nCmdShow = SW_SHOWMAXIMIZED;
		else if (dwStyle & WS_MINIMIZE)
			nCmdShow = SW_SHOWMINIMIZED;
	}

	// finally, show the window
	CFrameWnd::ActivateFrame(nCmdShow);

	// update the Window menu to reflect new child window
	CMDIFrameWnd* pFrame = GetMDIFrame();
	::SendMessage(pFrame->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);

	// Note: Update the m_bPseudoInactive flag.  This is used to handle the
	//  last MDI child getting hidden.  Windows provides no way to deactivate
	//  an MDI child window.

	BOOL bVisibleNow = (GetStyle() & WS_VISIBLE) != 0;
	if (bVisibleNow == bVisibleThen)
		return;

	if (!bVisibleNow)
	{
		// get current active window according to Windows MDI
		HWND hWnd = (HWND)::SendMessage(pFrameWnd->m_hWndMDIClient,
			WM_MDIGETACTIVE, 0, 0);
		if (hWnd != m_hWnd)
		{
			// not active any more -- window must have been deactivated
			ASSERT(!m_bPseudoInactive);
			return;
		}

		// check next window
		ASSERT(hWnd != NULL);
		pFrameWnd->MDINext();

		// see if it has been deactivated now...
		hWnd = (HWND)::SendMessage(pFrameWnd->m_hWndMDIClient,
			WM_MDIGETACTIVE, 0, 0);
		if (hWnd == m_hWnd)
		{
			// still active -- fake deactivate it
			ASSERT(hWnd != NULL);
			::SendMessage(pFrameWnd->m_hWndMDIClient, WM_MDIACTIVATE, (WPARAM)m_hWnd, NULL);
			m_bPseudoInactive = TRUE;   // so MDIGetActive returns NULL
		}
	}
	else if (m_bPseudoInactive)
	{
		// if state transitioned from not visible to visible, but
		//  was pseudo deactivated -- send activate notify now
		::SendMessage(pFrameWnd->m_hWndMDIClient, WM_MDIACTIVATE, NULL, (LPARAM)m_hWnd);
		ASSERT(!m_bPseudoInactive); // should get set in OnMDIActivate!
	}
}

void CMDIChildWnd::SetHandles(HMENU hMenu, HACCEL hAccel)
{
	m_hMenuShared = hMenu;
	m_hAccelTable = hAccel;
}

/////////////////////////////////////////////////////////////////////////////
// CMDIChildWnd Diagnostics

#ifdef _DEBUG
void CMDIChildWnd::AssertValid() const
{
	CFrameWnd::AssertValid();
	ASSERT(m_hMenuShared == NULL || ::IsMenu(m_hMenuShared));
}

void CMDIChildWnd::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);

	dc << "m_hMenuShared = " << (void*)m_hMenuShared;
	dc << "\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Smarts for the "Window" menu

HMENU CMDIFrameWnd::GetWindowMenuPopup(HMENU hMenuBar)
	// find which popup is the "Window" menu
{
	if (hMenuBar == NULL)
		return NULL;

	ASSERT(::IsMenu(hMenuBar));

	int iItem = ::GetMenuItemCount(hMenuBar);
	while (iItem--)
	{
		HMENU hMenuPop = ::GetSubMenu(hMenuBar, iItem);
		if (hMenuPop != NULL)
		{
			int iItemMax = ::GetMenuItemCount(hMenuPop);
			for (int iItemPop = 0; iItemPop < iItemMax; iItemPop++)
			{
				UINT nID = GetMenuItemID(hMenuPop, iItemPop);
				if (nID >= AFX_IDM_WINDOW_FIRST && nID <= AFX_IDM_WINDOW_LAST)
					return hMenuPop;
			}
		}
	}

	// no default menu found
	TRACE(traceAppMsg, 0, "Warning: GetWindowMenuPopup failed!\n");
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// Smarts for updating the window menu based on the current child

void CMDIFrameWnd::OnUpdateFrameMenu(HMENU hMenuAlt)
{
	CMDIChildWnd* pActiveWnd = MDIGetActive();
	if (pActiveWnd != NULL)
	{
		// let child update the menu bar
		pActiveWnd->OnUpdateFrameMenu(TRUE, pActiveWnd, hMenuAlt);
	}
	else
	{
		// no child active, so have to update it ourselves
		//  (we can't send it to a child window, since pActiveWnd is NULL)
		if (hMenuAlt == NULL)
			hMenuAlt = m_hMenuDefault;  // use default
		::SendMessage(m_hWndMDIClient, WM_MDISETMENU, (WPARAM)hMenuAlt, NULL);
	}
}

/////////////////////////////////////////////////////////////////////////////
// MDI Child Extensions

// walk up two parents for MDIFrame that owns MDIChild (skip MDIClient)
CMDIFrameWnd* CMDIChildWnd::GetMDIFrame()
{
	ASSERT_KINDOF(CMDIChildWnd, this);
	ASSERT(m_hWnd != NULL);
	HWND hWndMDIClient = ::GetParent(m_hWnd);
	ASSERT(hWndMDIClient != NULL);

	CMDIFrameWnd* pMDIFrame;
	pMDIFrame = (CMDIFrameWnd*)CWnd::FromHandle(::GetParent(hWndMDIClient));
	ASSERT(pMDIFrame != NULL);
	ASSERT_KINDOF(CMDIFrameWnd, pMDIFrame);
	ASSERT(pMDIFrame->m_hWndMDIClient == hWndMDIClient);
	ASSERT_VALID(pMDIFrame);
	return pMDIFrame;
}

CWnd* CMDIChildWnd::GetMessageBar()
{
	// status bar/message bar owned by parent MDI frame
	return GetMDIFrame()->GetMessageBar();
}

void CMDIChildWnd::OnUpdateFrameTitle(BOOL bAddToTitle)
{
	// update our parent window first
	GetMDIFrame()->OnUpdateFrameTitle(bAddToTitle);

	if ((GetStyle() & FWS_ADDTOTITLE) == 0)
		return;     // leave child window alone!

	CDocument* pDocument = GetActiveDocument();
	if (bAddToTitle)
	{
		TCHAR szText[256+_MAX_PATH];
		if (pDocument == NULL)
			Checked::tcsncpy_s(szText, _countof(szText), m_strTitle, _TRUNCATE);
		else
			Checked::tcsncpy_s(szText, _countof(szText), pDocument->GetTitle(), _TRUNCATE);
		if (m_nWindow > 0)
		{
			TCHAR szWinNumber[16+1];
			_stprintf_s(szWinNumber, _countof(szWinNumber), _T(":%d"), m_nWindow);
			
			if( lstrlen(szText) + lstrlen(szWinNumber) < _countof(szText) )
			{
				Checked::tcscat_s( szText, _countof(szText), szWinNumber ); 
			}
		}

		// set title if changed, but don't remove completely
		AfxSetWindowText(m_hWnd, szText);
	}
}

void CMDIChildWnd::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd*)
{
	m_bPseudoInactive = FALSE;  // must be happening for real

	// make sure MDI client window has correct client edge
	UpdateClientEdge();

	// send deactivate notification to active view
	CView* pActiveView = GetActiveView();
	if (!bActivate && pActiveView != NULL)
		pActiveView->OnActivateView(FALSE, pActiveView, pActiveView);

	// allow hook to short circuit normal activation
	BOOL bHooked = FALSE;
#ifndef _AFX_NO_OLE_SUPPORT
	if (m_pNotifyHook != NULL && m_pNotifyHook->OnDocActivate(bActivate))
		bHooked = TRUE;
#endif

	// update titles (don't AddToTitle if deactivate last)
	if (!bHooked)
		OnUpdateFrameTitle(bActivate || (pActivateWnd != NULL));

	// re-activate the appropriate view
	if (bActivate)
	{
		if (pActiveView != NULL && GetMDIFrame() == GetActiveWindow())
			pActiveView->OnActivateView(TRUE, pActiveView, pActiveView);
	}

	// update menus
	if (!bHooked)
	{
		OnUpdateFrameMenu(bActivate, pActivateWnd, NULL);
		GetMDIFrame()->DrawMenuBar();
	}
}

void CMDIChildWnd::OnUpdateFrameMenu(BOOL bActivate, CWnd* pActivateWnd,
	HMENU hMenuAlt)
{
	CMDIFrameWnd* pFrame = GetMDIFrame();

	if (hMenuAlt == NULL && bActivate)
	{
		// attempt to get default menu from document
		CDocument* pDoc = GetActiveDocument();
		if (pDoc != NULL)
			hMenuAlt = pDoc->GetDefaultMenu();
	}

	// use default menu stored in frame if none from document
	if (hMenuAlt == NULL)
		hMenuAlt = m_hMenuShared;

	if (hMenuAlt != NULL && bActivate)
	{
		ASSERT(pActivateWnd == this);

		// activating child, set parent menu
		::SendMessage(pFrame->m_hWndMDIClient, WM_MDISETMENU,
			(WPARAM)hMenuAlt, (LPARAM)pFrame->GetWindowMenuPopup(hMenuAlt));
	}
	else if (hMenuAlt != NULL && !bActivate && pActivateWnd == NULL)
	{
		// destroying last child
		HMENU hMenuLast = NULL;
		::SendMessage(pFrame->m_hWndMDIClient, WM_MDISETMENU,
			(WPARAM)pFrame->m_hMenuDefault, (LPARAM)hMenuLast);
	}
	else
	{
		// refresh MDI Window menu (even if non-shared menu)
		::SendMessage(pFrame->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
	}
}

BOOL CMDIChildWnd::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (!CFrameWnd::OnNcCreate(lpCreateStruct))
		return FALSE;

	// handle extended styles under Win4
	// call PreCreateWindow again just to get dwExStyle
	VERIFY(PreCreateWindow(*lpCreateStruct));
	SetWindowLong(m_hWnd, GWL_EXSTYLE, lpCreateStruct->dwExStyle);

	return TRUE;
}

int CMDIChildWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	// call base class with lParam context (not MDI one)
	MDICREATESTRUCT* lpmcs;
	lpmcs = (MDICREATESTRUCT*)lpCreateStruct->lpCreateParams;
	CCreateContext* pContext = (CCreateContext*)lpmcs->lParam;

	return OnCreateHelper(lpCreateStruct, pContext);
}

/////////////////////////////////////////////////////////////////////////////
// Special UI processing depending on current active child

void CMDIFrameWnd::OnUpdateFrameTitle(BOOL bAddToTitle)
{
	if ((GetStyle() & FWS_ADDTOTITLE) == 0)
		return;     // leave it alone!

#ifndef _AFX_NO_OLE_SUPPORT
	// allow hook to set the title (used for OLE support)
	if (m_pNotifyHook != NULL && m_pNotifyHook->OnUpdateFrameTitle())
		return;
#endif

	CMDIChildWnd* pActiveChild = NULL;
	CDocument* pDocument = GetActiveDocument();
	if (bAddToTitle &&
	  (pActiveChild = MDIGetActive()) != NULL &&
	  (pActiveChild->GetStyle() & WS_MAXIMIZE) == 0 &&
	  (pDocument != NULL ||
	   (pDocument = pActiveChild->GetActiveDocument()) != NULL))
		UpdateFrameTitleForDocument(pDocument->GetTitle());
	else
	{
		LPCTSTR lpstrTitle = NULL;
		CString strTitle;

		if (pActiveChild != NULL &&
			(pActiveChild->GetStyle() & WS_MAXIMIZE) == 0)
		{
			strTitle = pActiveChild->GetTitle();
			if (!strTitle.IsEmpty())
				lpstrTitle = strTitle;
		}
		UpdateFrameTitleForDocument(lpstrTitle);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Standard MDI Commands

// Two function for all standard MDI "Window" commands
void CMDIFrameWnd::OnUpdateMDIWindowCmd(CCmdUI* pCmdUI)
{
	ASSERT(m_hWndMDIClient != NULL);
	pCmdUI->Enable(MDIGetActive() != NULL);
}

BOOL CMDIFrameWnd::OnMDIWindowCmd(UINT nID)
{
	ASSERT(m_hWndMDIClient != NULL);

	UINT msg;
	UINT wParam = 0;
	switch (nID)
	{
	default:
		return FALSE;       // not for us
	case ID_WINDOW_ARRANGE:
		msg = WM_MDIICONARRANGE;
		break;
	case ID_WINDOW_CASCADE:
		msg = WM_MDICASCADE;
		break;
	case ID_WINDOW_TILE_HORZ:
		wParam = MDITILE_HORIZONTAL;
		// fall through
	case ID_WINDOW_TILE_VERT:
		ASSERT(MDITILE_VERTICAL == 0);
		msg = WM_MDITILE;
		break;
	}

	::SendMessage(m_hWndMDIClient, msg, wParam, 0);
	return TRUE;
}

void CMDIFrameWnd::OnWindowNew()
{
	CMDIChildWnd* pActiveChild = MDIGetActive();
	CDocument* pDocument;
	if (pActiveChild == NULL ||
	  (pDocument = pActiveChild->GetActiveDocument()) == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: No active document for WindowNew command.\n");
		AfxMessageBox(AFX_IDP_COMMAND_FAILURE);
		return;     // command failed
	}

	// otherwise we have a new frame !
	CDocTemplate* pTemplate = pDocument->GetDocTemplate();
	ASSERT_VALID(pTemplate);
	CFrameWnd* pFrame = pTemplate->CreateNewFrame(pDocument, pActiveChild);
	if (pFrame == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: failed to create new frame.\n");
		return;     // command failed
	}

	pTemplate->InitialUpdateFrame(pFrame, pDocument);
}

void CMDIFrameWnd::SetMenuBarVisibility(DWORD dwStyle)
{
	ENSURE_ARG(dwStyle == AFX_MBV_KEEPVISIBLE);
	ASSERT(m_dwMenuBarVisibility == AFX_MBV_KEEPVISIBLE);
}

BOOL CMDIFrameWnd::SetMenuBarState(DWORD dwState)
{
	return m_dwMenuBarState == AFX_MBS_HIDDEN ? FALSE : CFrameWnd::SetMenuBarState(dwState);
}

IMPLEMENT_DYNCREATE(CMDIFrameWnd, CFrameWnd)
IMPLEMENT_DYNCREATE(CMDIChildWnd, CFrameWnd)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winstr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

#ifndef _AFXDLL
int AFXAPI AfxLoadString(_In_ UINT nID, _Out_z_cap_post_count_(nMaxBuf, return + 1) LPSTR lpszBuf, _In_ UINT nMaxBuf)
{
	ASSERT(AfxIsValidAddress(lpszBuf, nMaxBuf*sizeof(CHAR)));
	if( lpszBuf == NULL || nMaxBuf == 0)
		AfxThrowInvalidArgException();

	const ATLSTRINGRESOURCEIMAGE* pImage;
	int nBytes;

	pImage = AtlGetStringResourceImage(AfxGetResourceHandle(), nID);
	if (pImage == NULL)
	{
		lpszBuf[0] = '\0';
		return 0;
	}
	ASSERT(pImage->nLength != 0);
	nBytes = ::WideCharToMultiByte(CP_ACP, 0, pImage->achString, pImage->nLength, lpszBuf, nMaxBuf-1, NULL, NULL);
	lpszBuf[nBytes] = '\0';

	return nBytes;
}

int AFXAPI AfxLoadString(_In_ UINT nID, _Out_z_cap_post_count_(nMaxBuf, return + 1) LPWSTR lpszBuf, _In_ UINT nMaxBuf)
{
	ASSERT(AfxIsValidAddress(lpszBuf, nMaxBuf*sizeof(WCHAR)));
	if( lpszBuf == NULL || nMaxBuf == 0)
		AfxThrowInvalidArgException();

	const ATLSTRINGRESOURCEIMAGE* pImage;
	int nCharsToCopy;

	pImage = AtlGetStringResourceImage(AfxGetResourceHandle(), nID);
	if (pImage == NULL)
	{
		lpszBuf[0] = L'\0';
		return 0;
	}
	ASSERT(pImage->nLength != 0);
	nCharsToCopy = min(nMaxBuf-1, pImage->nLength);
	Checked::memcpy_s(lpszBuf, (nMaxBuf-1)*sizeof(WCHAR), pImage->achString, nCharsToCopy*sizeof(WCHAR));
	lpszBuf[nCharsToCopy] = L'\0';

	return nCharsToCopy;
}

HINSTANCE AFXAPI AfxFindStringResourceHandle(UINT /* nID */)
{
	return AfxGetResourceHandle();
}

#endif

/////////////////////////////////////////////////////////////////////////////

BOOL AFXAPI AfxExtractSubString(CString& rString, LPCTSTR lpszFullString,
	int iSubString, TCHAR chSep)
{
	if (lpszFullString == NULL)
		return FALSE;

	while (iSubString--)
	{
		lpszFullString = _tcschr(lpszFullString, chSep);
		if (lpszFullString == NULL)
		{
			rString.Empty();        // return empty string as well
			return FALSE;
		}
		lpszFullString++;       // point past the separator
	}
	LPCTSTR lpchEnd = _tcschr(lpszFullString, chSep);
	int nLen = (lpchEnd == NULL) ?
		lstrlen(lpszFullString) : (int)(lpchEnd - lpszFullString);
	ASSERT(nLen >= 0);
	Checked::memcpy_s(rString.GetBufferSetLength(nLen), nLen*sizeof(TCHAR),
		lpszFullString, nLen*sizeof(TCHAR));
	rString.ReleaseBuffer();	// Need to call ReleaseBuffer 
								// after calling GetBufferSetLength
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winsplit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <atlimage.h>


/////////////////////////////////////////////////////////////////////////////
// Visual attributes and other constants

// HitTest return values (values and spacing between values is important)
enum HitTestValue
{
	noHit                   = 0,
	vSplitterBox            = 1,
	hSplitterBox            = 2,
	bothSplitterBox         = 3,        // just for keyboard
	vSplitterBar1           = 101,
	vSplitterBar15          = 115,
	hSplitterBar1           = 201,
	hSplitterBar15          = 215,
	splitterIntersection1   = 301,
	splitterIntersection225 = 525
};

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd

BEGIN_MESSAGE_MAP(CSplitterWnd, CWnd)
	//{{AFX_MSG_MAP(CSplitterWnd)
	ON_WM_SETCURSOR()
	ON_WM_MOUSEMOVE()
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_KEYDOWN()
	ON_WM_SIZE()
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_NCCREATE()
	ON_WM_SYSCOMMAND()
	ON_WM_CANCELMODE()
	ON_MESSAGE_VOID(WM_DISPLAYCHANGE,CSplitterWnd::OnDisplayChange)
	ON_MESSAGE_VOID(WM_WININICHANGE, CSplitterWnd::OnDisplayChange)
	ON_MESSAGE_VOID(WM_SETTINGCHANGE,CSplitterWnd::OnDisplayChange)
	ON_MESSAGE(WM_PRINTCLIENT, &CSplitterWnd::OnPrintClient)
	ON_WM_MOUSEWHEEL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd construction/destruction

CSplitterWnd::CSplitterWnd()
{
	m_pDynamicViewClass = NULL;

	m_nMaxRows = 0;
	m_nMaxCols = 0;
	m_nRows = 0;
	m_nCols = 0;

	m_bHasHScroll = FALSE;
	m_bHasVScroll = FALSE;

	m_pColInfo = NULL;
	m_pRowInfo = NULL;

	m_bTracking = FALSE;
	m_bTracking2 = FALSE;

	m_ptTrackOffset.x = m_ptTrackOffset.y = 0;

	m_rectLimit.top    = m_rectLimit.bottom    = m_rectLimit.left    = m_rectLimit.right    = 0;
	m_rectTracker.top  = m_rectTracker.bottom  = m_rectTracker.left  = m_rectTracker.right  = 0;
	m_rectTracker2.top = m_rectTracker2.bottom = m_rectTracker2.left = m_rectTracker2.right = 0;

	m_htTrack = 0;

	// default splitter box/bar sizes (includes borders)
	m_cxSplitter = m_cySplitter = 3 + 2 + 2;
	m_cxBorderShare = m_cyBorderShare = 0;
	m_cxSplitterGap = m_cySplitterGap = 3 + 2 + 2;
	m_cxBorder = m_cyBorder = 2;

#ifdef _DEBUG
	if (GetSystemMetrics(SM_CXBORDER) != 1 ||
		GetSystemMetrics(SM_CYBORDER) != 1)
	{
		TRACE(traceAppMsg, 0, "Warning: CSplitterWnd assumes 1 pixel border.\n");
		// will look ugly if borders are not 1 pixel wide and 1 pixel high
	}
#endif
}

CSplitterWnd::~CSplitterWnd()
{
	delete[] m_pRowInfo;
	delete[] m_pColInfo;
}

BOOL CSplitterWnd::Create(CWnd* pParentWnd,
	int nMaxRows, int nMaxCols, SIZE sizeMin,
	CCreateContext* pContext, DWORD dwStyle, UINT nID)
{
	ASSERT(pParentWnd != NULL);
	ASSERT(sizeMin.cx > 0 && sizeMin.cy > 0);   // minimum must be non-zero

	ASSERT(pContext != NULL);
	ASSERT(pContext->m_pNewViewClass != NULL);
	ASSERT(dwStyle & WS_CHILD);
	ASSERT(dwStyle & SPLS_DYNAMIC_SPLIT);   // must have dynamic split behavior

	// Dynamic splitters are limited to 2x2
	ASSERT(nMaxRows >= 1 && nMaxRows <= 2);
	ASSERT(nMaxCols >= 1 && nMaxCols <= 2);
	ASSERT(nMaxCols > 1 || nMaxRows > 1);       // 1x1 is not permitted

	m_nMaxRows = nMaxRows;
	m_nMaxCols = nMaxCols;
	ASSERT(m_nRows == 0 && m_nCols == 0);       // none yet
	m_nRows = m_nCols = 1;      // start off as 1x1
	if (!CreateCommon(pParentWnd, sizeMin, dwStyle, nID))
		return FALSE;
	ASSERT(m_nRows == 1 && m_nCols == 1);       // still 1x1

	ASSERT(pContext->m_pNewViewClass->IsDerivedFrom(RUNTIME_CLASS(CWnd)));
	m_pDynamicViewClass = pContext->m_pNewViewClass;
		// save for later dynamic creations

	// add the first initial pane
	if (!CreateView(0, 0, m_pDynamicViewClass, sizeMin, pContext))
	{
		DestroyWindow(); // will clean up child windows
		return FALSE;
	}
	m_pColInfo[0].nIdealSize = sizeMin.cx;
	m_pRowInfo[0].nIdealSize = sizeMin.cy;

	return TRUE;
}

// simple "wiper" splitter
BOOL CSplitterWnd::CreateStatic(CWnd* pParentWnd,
	int nRows, int nCols, DWORD dwStyle, UINT nID)
{
	ASSERT(pParentWnd != NULL);
	ASSERT(nRows >= 1 && nRows <= 16);
	ASSERT(nCols >= 1 && nCols <= 16);
	ASSERT(nCols > 1 || nRows > 1);     // 1x1 is not permitted
	ASSERT(dwStyle & WS_CHILD);
	ASSERT(!(dwStyle & SPLS_DYNAMIC_SPLIT)); // can't have dynamic split

	ASSERT(m_nRows == 0 && m_nCols == 0);       // none yet
	m_nRows = m_nMaxRows = nRows;
	m_nCols = m_nMaxCols = nCols;

	// create with zero minimum pane size
	if (!CreateCommon(pParentWnd, CSize(0, 0), dwStyle, nID))
		return FALSE;

	// all panes must be created with explicit calls to CreateView
	return TRUE;
}

BOOL CSplitterWnd::CreateCommon(CWnd* pParentWnd,
	SIZE sizeMin, DWORD dwStyle, UINT nID)
{
	ASSERT(pParentWnd != NULL);
	ASSERT(sizeMin.cx >= 0 && sizeMin.cy >= 0);
	ASSERT(dwStyle & WS_CHILD);
	ASSERT(nID != 0);

	ASSERT(m_pColInfo == NULL && m_pRowInfo == NULL);   // only do once
	ASSERT(m_nMaxCols > 0 && m_nMaxRows > 0);

	// the Windows scroll bar styles bits turn on the smart scrollbars
	DWORD dwCreateStyle = dwStyle & ~(WS_HSCROLL|WS_VSCROLL);
	dwCreateStyle &= ~WS_BORDER;

	VERIFY(AfxDeferRegisterClass(AFX_WNDMDIFRAME_REG));

	// create with the same wnd-class as MDI-Frame (no erase bkgnd)
	if (!CreateEx(0, _afxWndMDIFrame, NULL, dwCreateStyle, 0, 0, 0, 0,
	  pParentWnd->m_hWnd, (HMENU)(UINT_PTR)nID, NULL))
		return FALSE;       // create invisible

	// attach the initial splitter parts
	TRY
	{
		m_pColInfo = new CRowColInfo[m_nMaxCols];
		for (int col = 0; col < m_nMaxCols; col++)
		{
			m_pColInfo[col].nMinSize = m_pColInfo[col].nIdealSize = sizeMin.cx;
			m_pColInfo[col].nCurSize = -1; // will be set in RecalcLayout
		}
		m_pRowInfo = new CRowColInfo[m_nMaxRows];
		for (int row = 0; row < m_nMaxRows; row++)
		{
			m_pRowInfo[row].nMinSize = m_pRowInfo[row].nIdealSize = sizeMin.cy;
			m_pRowInfo[row].nCurSize = -1; // will be set in RecalcLayout
		}

		// create scroll bars by setting the style
		SetScrollStyle(dwStyle);
	}
	CATCH_ALL(e)
	{
		DestroyWindow(); // will clean up child windows
		// Note: DELETE_EXCEPTION(e) not required
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE;
}

BOOL CSplitterWnd::OnNcCreate(LPCREATESTRUCT lpcs)
{
	if (!CWnd::OnNcCreate(lpcs))
		return FALSE;

	// remove WS_EX_CLIENTEDGE style from parent window
	//  (the splitter itself will provide the 3d look)
	CWnd* pParent = GetParent();
	ASSERT_VALID(pParent);
	pParent->ModifyStyleEx(WS_EX_CLIENTEDGE, 0, SWP_DRAWFRAME);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd default creation of parts

// You must create ALL panes unless DYNAMIC_SPLIT is defined!
//  Usually the splitter window is invisible when creating a pane
BOOL CSplitterWnd::CreateView(int row, int col,
	CRuntimeClass* pViewClass, SIZE sizeInit, CCreateContext* pContext)
{
#ifdef _DEBUG
	ASSERT_VALID(this);
	ASSERT(row >= 0 && row < m_nRows);
	ASSERT(col >= 0 && col < m_nCols);
	ASSERT(pViewClass != NULL);
	ASSERT(pViewClass->IsDerivedFrom(RUNTIME_CLASS(CWnd)));
	ASSERT(AfxIsValidAddress(pViewClass, sizeof(CRuntimeClass), FALSE));

	if (GetDlgItem(IdFromRowCol(row, col)) != NULL)
	{
		TRACE(traceAppMsg, 0, "Error: CreateView - pane already exists for row %d, col %d.\n",
			row, col);
		ASSERT(FALSE);
		return FALSE;
	}
#endif

	// set the initial size for that pane
	m_pColInfo[col].nIdealSize = sizeInit.cx;
	m_pRowInfo[row].nIdealSize = sizeInit.cy;

	BOOL bSendInitialUpdate = FALSE;

	CCreateContext contextT;
	if (pContext == NULL)
	{
		// if no context specified, generate one from the currently selected
		//  client if possible
		CView* pOldView = (CView*)GetActivePane();
		if (pOldView != NULL && pOldView->IsKindOf(RUNTIME_CLASS(CView)))
		{
			// set info about last pane
			ASSERT(contextT.m_pCurrentFrame == NULL);
			contextT.m_pLastView = pOldView;
			contextT.m_pCurrentDoc = pOldView->GetDocument();
			if (contextT.m_pCurrentDoc != NULL)
				contextT.m_pNewDocTemplate =
				  contextT.m_pCurrentDoc->GetDocTemplate();
		}
		pContext = &contextT;
		bSendInitialUpdate = TRUE;
	}

	CWnd* pWnd;
	TRY
	{
		pWnd = (CWnd*)pViewClass->CreateObject();
		if (pWnd == NULL)
			AfxThrowMemoryException();
	}
	CATCH_ALL(e)
	{
		TRACE(traceAppMsg, 0, "Out of memory creating a splitter pane.\n");
		// Note: DELETE_EXCEPTION(e) not required
		return FALSE;
	}
	END_CATCH_ALL

	ASSERT_KINDOF(CWnd, pWnd);
	ASSERT(pWnd->m_hWnd == NULL);       // not yet created

	DWORD dwStyle = AFX_WS_DEFAULT_VIEW & ~WS_BORDER;

	// Create with the right size (wrong position)
	CRect rect(CPoint(0,0), sizeInit);
	if (!pWnd->Create(NULL, NULL, dwStyle,
		rect, this, IdFromRowCol(row, col), pContext))
	{
		TRACE(traceAppMsg, 0, "Warning: couldn't create client pane for splitter.\n");
			// pWnd will be cleaned up by PostNcDestroy
		return FALSE;
	}
	ASSERT((int)_AfxGetDlgCtrlID(pWnd->m_hWnd) == IdFromRowCol(row, col));

	// send initial notification message
	if (bSendInitialUpdate)
		pWnd->SendMessage(WM_INITIALUPDATE);

	return TRUE;
}

BOOL CSplitterWnd::CreateScrollBarCtrl(DWORD dwStyle, UINT nID)
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);

	HWND hWnd = ::CreateWindow(_T("SCROLLBAR"), NULL,
		dwStyle | WS_VISIBLE | WS_CHILD,
		0, 0, 1, 1, m_hWnd, (HMENU)(UINT_PTR)nID,
		AfxGetInstanceHandle(), NULL);

#ifdef _DEBUG
	if (hWnd == NULL)
		TRACE(traceAppMsg, 0, "Warning: Window creation failed: GetLastError returns 0x%8.8X\n", 
			GetLastError());
#endif

	return hWnd != NULL;
}

int CSplitterWnd::IdFromRowCol(int row, int col) const
{
	ASSERT_VALID(this);
	ASSERT(row >= 0);
	ASSERT(row < m_nRows);
	ASSERT(col >= 0);
	ASSERT(col < m_nCols);

	return AFX_IDW_PANE_FIRST + row * 16 + col;
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd attributes

CWnd* CSplitterWnd::GetPane(int row, int col) const
{
	ASSERT_VALID(this);

	CWnd* pView = GetDlgItem(IdFromRowCol(row, col));
	ASSERT(pView != NULL);  // panes can be a CWnd, but are usually CViews
	return pView;
}

BOOL CSplitterWnd::IsChildPane(CWnd* pWnd, int* pRow, int* pCol)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWnd);

	UINT nID = _AfxGetDlgCtrlID(pWnd->m_hWnd);
	if (IsChild(pWnd) && nID >= AFX_IDW_PANE_FIRST && nID <= AFX_IDW_PANE_LAST)
	{
		if (pRow != NULL)
			*pRow = (nID - AFX_IDW_PANE_FIRST) / 16;
		if (pCol != NULL)
			*pCol = (nID - AFX_IDW_PANE_FIRST) % 16;
		ASSERT(pRow == NULL || *pRow < m_nRows);
		ASSERT(pCol == NULL || *pCol < m_nCols);
		return TRUE;
	}
	else
	{
		if (pRow != NULL)
			*pRow = -1;
		if (pCol != NULL)
			*pCol = -1;
		return FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd information access

// The get routines return the current size
// The set routines set the ideal size
//  RecalcLayout must be called to update current size

void CSplitterWnd::GetRowInfo(int row, int& cyCur, int& cyMin) const
{
	ASSERT_VALID(this);
	ASSERT(row >= 0 && row < m_nMaxRows);

	cyCur = m_pRowInfo[row].nCurSize;
	cyMin = m_pRowInfo[row].nMinSize;
}

void CSplitterWnd::SetRowInfo(int row, int cyIdeal, int cyMin)
{
	ASSERT_VALID(this);
	ASSERT(row >= 0 && row < m_nMaxRows);
	ASSERT(cyIdeal >= 0);
	ASSERT(cyMin >= 0);

	m_pRowInfo[row].nIdealSize = cyIdeal;
	m_pRowInfo[row].nMinSize = cyMin;
}

void CSplitterWnd::GetColumnInfo(int col, int& cxCur, int& cxMin) const
{
	ASSERT_VALID(this);
	ASSERT(col >= 0 && col < m_nMaxCols);

	cxCur = m_pColInfo[col].nCurSize;
	cxMin = m_pColInfo[col].nMinSize;
}

void CSplitterWnd::SetColumnInfo(int col, int cxIdeal, int cxMin)
{
	ASSERT_VALID(this);
	ASSERT(col >= 0 && col < m_nMaxCols);
	ASSERT(cxIdeal >= 0);
	ASSERT(cxMin >= 0);

	m_pColInfo[col].nIdealSize = cxIdeal;
	m_pColInfo[col].nMinSize = cxMin;
}

DWORD CSplitterWnd::GetScrollStyle() const
{
	DWORD dwStyle = 0;
	if (m_bHasHScroll)
		dwStyle |= WS_HSCROLL;
	if (m_bHasVScroll)
		dwStyle |= WS_VSCROLL;
	return dwStyle;
}

void CSplitterWnd::SetScrollStyle(DWORD dwStyle)
{
	// optimize for scroll info already set correctly
	dwStyle &= (WS_HSCROLL|WS_VSCROLL);
	if (GetScrollStyle() == dwStyle)
		return;

	// update to new state
	m_bHasHScroll = (dwStyle & WS_HSCROLL) != 0;
	m_bHasVScroll = (dwStyle & WS_VSCROLL) != 0;

	CWnd* pScrollBar;

	// show/hide all the shared horz scroll bars
	for (int col = 0; col < m_nCols; col++)
	{
		pScrollBar = GetDlgItem(AFX_IDW_HSCROLL_FIRST + col);
		if (pScrollBar == NULL)
		{
			// create the scroll bar when necessary
			if (!CreateScrollBarCtrl(SBS_HORZ, AFX_IDW_HSCROLL_FIRST + col))
				AfxThrowResourceException();
			pScrollBar = GetDlgItem(AFX_IDW_HSCROLL_FIRST + col);
		}
		pScrollBar->ShowWindow(m_bHasHScroll ? SW_SHOW : SW_HIDE);
	}

	// show/hide all the shared vert scroll bars
	for (int row = 0; row < m_nRows; row++)
	{
		pScrollBar = GetDlgItem(AFX_IDW_VSCROLL_FIRST + row);
		if (pScrollBar == NULL)
		{
			// create the scroll bar when necessary
			if (!CreateScrollBarCtrl(SBS_VERT, AFX_IDW_VSCROLL_FIRST + row))
				AfxThrowResourceException();
			pScrollBar = GetDlgItem(AFX_IDW_VSCROLL_FIRST + row);
		}
		pScrollBar->ShowWindow(m_bHasVScroll ? SW_SHOW : SW_HIDE);
	}

	// show/destroy size box if necessary
	if (m_bHasVScroll && m_bHasHScroll)
	{
		pScrollBar = GetDlgItem(AFX_IDW_SIZE_BOX);
		if (pScrollBar == NULL)
		{
			// create size box when necessary
			if (!CreateScrollBarCtrl(SBS_SIZEBOX|WS_DISABLED, AFX_IDW_SIZE_BOX))
				AfxThrowResourceException();
			pScrollBar = GetDlgItem(AFX_IDW_SIZE_BOX);
		}
		pScrollBar->ShowWindow(SW_SHOW);
	}
	else
	{
		// the size box can be destroyed instead of hidden
		pScrollBar = GetDlgItem(AFX_IDW_SIZE_BOX);
		if (pScrollBar != NULL)
			pScrollBar->DestroyWindow();
	}

	// Note: call RecalcLayout for the new layout to take effect
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd client operations/overridables

void CSplitterWnd::DeleteView(int row, int col)
{
	ASSERT_VALID(this);

	// if active child is being deleted - activate next
	CWnd* pPane = GetPane(row, col);
	ASSERT_KINDOF(CView, pPane);
	if (GetActivePane() == pPane)
		ActivateNext(FALSE);

	// default implementation assumes view will auto delete in PostNcDestroy
	pPane->DestroyWindow();
}

void CSplitterWnd::OnDrawSplitter(CDC* pDC, ESplitType nType,
	const CRect& rectArg)
{
	// if pDC == NULL, then just invalidate
	if (pDC == NULL)
	{
		RedrawWindow(rectArg, NULL, RDW_INVALIDATE|RDW_NOCHILDREN);
		return;
	}
	ASSERT_VALID(pDC);

	// otherwise, actually draw
	CRect rect = rectArg;
	switch (nType)
	{
	case splitBorder:
		pDC->Draw3dRect(rect, afxData.clrBtnShadow, afxData.clrBtnHilite);
		rect.InflateRect(-AFX_CX_BORDER, -AFX_CY_BORDER);
		pDC->Draw3dRect(rect, afxData.clrWindowFrame, afxData.clrBtnFace);
		return;

	case splitIntersection:
		break;

	case splitBox:
		pDC->Draw3dRect(rect, afxData.clrBtnFace, afxData.clrWindowFrame);
		rect.InflateRect(-AFX_CX_BORDER, -AFX_CY_BORDER);
		pDC->Draw3dRect(rect, afxData.clrBtnHilite, afxData.clrBtnShadow);
		rect.InflateRect(-AFX_CX_BORDER, -AFX_CY_BORDER);
		break;

	case splitBar:
		break;

	default:
		ASSERT(FALSE);  // unknown splitter type
	}

	// fill the middle
	COLORREF clr = afxData.clrBtnFace;
	pDC->FillSolidRect(rect, clr);
}

/////////////////////////////////////////////////////////////////////////////
// Dynamic row/col split etc

AFX_STATIC int AFXAPI _AfxCanSplitRowCol(CSplitterWnd::CRowColInfo* pInfoBefore,
	int nBeforeSize, int nSizeSplitter)
	// request to split Before row at point nBeforeSize
	// returns size of new pane (nBeforeSize will be new size of Before pane)
	// return -1 if not big enough
{
	ASSERT(pInfoBefore->nCurSize > 0);
	ASSERT(pInfoBefore->nMinSize > 0);
	ASSERT(nBeforeSize <= pInfoBefore->nCurSize);

	// space gets take from before pane (weird UI for > 2 splits)
	if (nBeforeSize < pInfoBefore->nMinSize)
	{
		TRACE(traceAppMsg, 0, "Warning: split too small to fit in a new pane.\n");
		return -1;
	}

	int nNewSize = pInfoBefore->nCurSize - nBeforeSize - nSizeSplitter;
	if (nBeforeSize < pInfoBefore->nMinSize)
	{
		TRACE(traceAppMsg, 0, "Warning: split too small to shrink old pane.\n");
		return -1;
	}
	if (nNewSize < (pInfoBefore+1)->nMinSize)
	{
		TRACE(traceAppMsg, 0, "Warning: split too small to create new pane.\n");
		return -1;
	}
	return nNewSize;
}

BOOL CSplitterWnd::SplitRow(int cyBefore)
{
	ASSERT_VALID(this);
	ASSERT(GetStyle() & SPLS_DYNAMIC_SPLIT);
	ASSERT(m_pDynamicViewClass != NULL);
	ASSERT(m_nRows < m_nMaxRows);

	cyBefore -= m_cyBorder;
	int rowNew = m_nRows;
	int cyNew = _AfxCanSplitRowCol(&m_pRowInfo[rowNew-1], cyBefore, m_cySplitter);
	if (cyNew == -1)
		return FALSE;   // too small to split

	// create the scroll bar first (so new views can see that it is there)
	if (m_bHasVScroll &&
		!CreateScrollBarCtrl(SBS_VERT, AFX_IDW_VSCROLL_FIRST + rowNew))
	{
		TRACE(traceAppMsg, 0, "Warning: SplitRow failed to create scroll bar.\n");
		return FALSE;
	}

	m_nRows++;  // bump count during view creation

	// create new views to fill the new row (RecalcLayout will position)
	for (int col = 0; col < m_nCols; col++)
	{
		CSize size(m_pColInfo[col].nCurSize, cyNew);
		if (!CreateView(rowNew, col, m_pDynamicViewClass, size, NULL))
		{
			TRACE(traceAppMsg, 0, "Warning: SplitRow failed to create new row.\n");
			// delete anything we partially created 'col' = # columns created
			while (col > 0)
				DeleteView(rowNew, --col);
			if (m_bHasVScroll)
				GetDlgItem(AFX_IDW_VSCROLL_FIRST + rowNew)->DestroyWindow();
			m_nRows--;      // it didn't work out
			return FALSE;
		}
	}

	// new parts created - resize and re-layout
	m_pRowInfo[rowNew-1].nIdealSize = cyBefore;
	m_pRowInfo[rowNew].nIdealSize = cyNew;
	ASSERT(m_nRows == rowNew+1);
	RecalcLayout();

	return TRUE;
}

BOOL CSplitterWnd::SplitColumn(int cxBefore)
{
	ASSERT_VALID(this);
	ASSERT(GetStyle() & SPLS_DYNAMIC_SPLIT);
	ASSERT(m_pDynamicViewClass != NULL);
	ASSERT(m_nCols < m_nMaxCols);

	cxBefore -= m_cxBorder;
	int colNew = m_nCols;
	int cxNew = _AfxCanSplitRowCol(&m_pColInfo[colNew-1], cxBefore, m_cxSplitter);
	if (cxNew == -1)
		return FALSE;   // too small to split

	// create the scroll bar first (so new views can see that it is there)
	if (m_bHasHScroll &&
		!CreateScrollBarCtrl(SBS_HORZ, AFX_IDW_HSCROLL_FIRST + colNew))
	{
		TRACE(traceAppMsg, 0, "Warning: SplitRow failed to create scroll bar.\n");
		return FALSE;
	}

	m_nCols++;  // bump count during view creation

	// create new views to fill the new column (RecalcLayout will position)
	for (int row = 0; row < m_nRows; row++)
	{
		CSize size(cxNew, m_pRowInfo[row].nCurSize);
		if (!CreateView(row, colNew, m_pDynamicViewClass, size, NULL))
		{
			TRACE(traceAppMsg, 0, "Warning: SplitColumn failed to create new column.\n");
			// delete anything we partially created 'col' = # columns created
			while (row > 0)
				DeleteView(--row, colNew);
			if (m_bHasHScroll)
				GetDlgItem(AFX_IDW_HSCROLL_FIRST + colNew)->DestroyWindow();
			m_nCols--;      // it didn't work out
			return FALSE;
		}
	}

	// new parts created - resize and re-layout
	m_pColInfo[colNew-1].nIdealSize = cxBefore;
	m_pColInfo[colNew].nIdealSize = cxNew;
	ASSERT(m_nCols == colNew+1);
	RecalcLayout();

	return TRUE;
}

void CSplitterWnd::DeleteRow(int rowDelete)
{
	ASSERT_VALID(this);
	ASSERT(GetStyle() & SPLS_DYNAMIC_SPLIT);

	ASSERT(m_nRows > 1);
	ASSERT(rowDelete < m_nRows);

	int rowActive, colActive;
	if (GetActivePane(&rowActive, &colActive) != NULL && rowActive == rowDelete)
	{
		if (++rowActive >= m_nRows)
			rowActive = 0;
		SetActivePane(rowActive, colActive);
	}

	CWnd* pScrollDel = m_bHasVScroll ?
		GetDlgItem(AFX_IDW_VSCROLL_FIRST+rowDelete) : NULL;
	for (int col = 0; col < m_nCols; col++)
	{
		DeleteView(rowDelete, col);
		for (int row = rowDelete+1; row < m_nRows; row++)
		{
			CWnd* pPane = GetPane(row, col);
			ASSERT(pPane != NULL);
			pPane->SetDlgCtrlID(IdFromRowCol(row-1, col));
			if (m_bHasVScroll && col == m_nCols-1)
			{
				CWnd* pScroll = GetDlgItem(AFX_IDW_VSCROLL_FIRST+row);
				if (pScroll != NULL)
					pScroll->SetDlgCtrlID(AFX_IDW_VSCROLL_FIRST+row-1);
			}
		}
	}
	m_nRows--;
	if (pScrollDel != NULL)
		pScrollDel->DestroyWindow();

	RecalcLayout();     // re-assign the space
}

void CSplitterWnd::DeleteColumn(int colDelete)
{
	ASSERT_VALID(this);
	ASSERT(GetStyle() & SPLS_DYNAMIC_SPLIT);

	ASSERT(m_nCols > 1);
	ASSERT(colDelete < m_nCols);

	int rowActive, colActive;
	if (GetActivePane(&rowActive, &colActive) != NULL && colActive == colDelete)
	{
		if (++colActive >= m_nCols)
			colActive = 0;
		SetActivePane(rowActive, colActive);
	}

	CWnd* pScrollDel = m_bHasHScroll ?
		GetDlgItem(AFX_IDW_HSCROLL_FIRST+colDelete) : NULL;
	for (int row = 0; row < m_nRows; row++)
	{
		DeleteView(row, colDelete);
		for (int col = colDelete+1; col < m_nCols; col++)
		{
			CWnd* pPane = GetPane(row, col);
			ASSERT(pPane != NULL);
			pPane->SetDlgCtrlID(IdFromRowCol(row, col-1));
			if (m_bHasHScroll && row == m_nRows-1)
			{
				CWnd* pScroll = GetDlgItem(AFX_IDW_HSCROLL_FIRST+col);
				if (pScroll != NULL)
					pScroll->SetDlgCtrlID(AFX_IDW_HSCROLL_FIRST+col-1);
			}
		}
	}
	m_nCols--;
	if (pScrollDel != NULL)
		pScrollDel->DestroyWindow();

	RecalcLayout();     // re-assign the space
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd tracking support

// like GetClientRect but inset by shared scrollbars
void CSplitterWnd::GetInsideRect(CRect& rect) const
{
	ASSERT_VALID(this);

	GetClientRect(rect);
	ASSERT(rect.left == 0 && rect.top == 0);

	// subtract space for 3d borders
	rect.InflateRect(-m_cxBorder, -m_cyBorder);

	// subtract scrollbar clearance
	if (m_bHasVScroll)
		rect.right -= afxData.cxVScroll - AFX_CX_BORDER;
	if (m_bHasHScroll)
		rect.bottom -= afxData.cyHScroll - AFX_CY_BORDER;
}

void CSplitterWnd::StartTracking(int ht)
{
	ASSERT_VALID(this);
	if (ht == noHit)
		return;

	// GetHitRect will restrict 'm_rectLimit' as appropriate
	GetInsideRect(m_rectLimit);

	if (ht >= splitterIntersection1 && ht <= splitterIntersection225)
	{
		// split two directions (two tracking rectangles)
		int row = (ht - splitterIntersection1) / 15;
		int col = (ht - splitterIntersection1) % 15;

		GetHitRect(row + vSplitterBar1, m_rectTracker);
		int yTrackOffset = m_ptTrackOffset.y;
		m_bTracking2 = TRUE;
		GetHitRect(col + hSplitterBar1, m_rectTracker2);
		m_ptTrackOffset.y = yTrackOffset;
	}
	else if (ht == bothSplitterBox)
	{
		// hit on splitter boxes (for keyboard)
		GetHitRect(vSplitterBox, m_rectTracker);
		int yTrackOffset = m_ptTrackOffset.y;
		m_bTracking2 = TRUE;
		GetHitRect(hSplitterBox, m_rectTracker2);
		m_ptTrackOffset.y = yTrackOffset;

		// center it
		m_rectTracker.OffsetRect(0, m_rectLimit.Height()/2);
		m_rectTracker2.OffsetRect(m_rectLimit.Width()/2, 0);
	}
	else
	{
		// only hit one bar
		GetHitRect(ht, m_rectTracker);
	}

	// allow active view to preserve focus before taking it away
	CView* pView = (CView*)GetActivePane();
	if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CView)))
	{
		ASSERT_VALID(pView);
		CFrameWnd* pFrameWnd = EnsureParentFrame();
		pView->OnActivateFrame(WA_INACTIVE, pFrameWnd);
	}

	// steal focus and capture
	SetCapture();
	SetFocus();

	// make sure no updates are pending
	RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW);

	// set tracking state and appropriate cursor
	m_bTracking = TRUE;
	OnInvertTracker(m_rectTracker);
	if (m_bTracking2)
		OnInvertTracker(m_rectTracker2);
	m_htTrack = ht;
	SetSplitCursor(ht);
}

void CSplitterWnd::TrackRowSize(int y, int row)
{
	ASSERT_VALID(this);
	ASSERT(m_nRows > 1);

	CPoint pt(0, y);
	ClientToScreen(&pt);
	GetPane(row, 0)->ScreenToClient(&pt);
	m_pRowInfo[row].nIdealSize = pt.y;      // new size
	if (pt.y < m_pRowInfo[row].nMinSize)
	{
		// resized too small
		m_pRowInfo[row].nIdealSize = 0; // make it go away
		if (GetStyle() & SPLS_DYNAMIC_SPLIT)
			DeleteRow(row);
	}
	else if (m_pRowInfo[row].nCurSize + m_pRowInfo[row+1].nCurSize
			< pt.y + m_pRowInfo[row+1].nMinSize)
	{
		// not enough room for other pane
		if (GetStyle() & SPLS_DYNAMIC_SPLIT)
			DeleteRow(row + 1);
	}
}

void CSplitterWnd::TrackColumnSize(int x, int col)
{
	ASSERT_VALID(this);
	ASSERT(m_nCols > 1);

	CPoint pt(x, 0);
	ClientToScreen(&pt);
	GetPane(0, col)->ScreenToClient(&pt);
	m_pColInfo[col].nIdealSize = pt.x;      // new size
	if (pt.x < m_pColInfo[col].nMinSize)
	{
		// resized too small
		m_pColInfo[col].nIdealSize = 0; // make it go away
		if (GetStyle() & SPLS_DYNAMIC_SPLIT)
			DeleteColumn(col);
	}
	else if (m_pColInfo[col].nCurSize + m_pColInfo[col+1].nCurSize
			< pt.x + m_pColInfo[col+1].nMinSize)
	{
		// not enough room for other pane
		if (GetStyle() & SPLS_DYNAMIC_SPLIT)
			DeleteColumn(col + 1);
	}
}

void CSplitterWnd::StopTracking(BOOL bAccept)
{
	ASSERT_VALID(this);

	if (!m_bTracking)
		return;

	ReleaseCapture();

	// erase tracker rectangle
	OnInvertTracker(m_rectTracker);
	if (m_bTracking2)
		OnInvertTracker(m_rectTracker2);
	m_bTracking = m_bTracking2 = FALSE;

	// save old active view
	CWnd* pOldActiveView = GetActivePane();

	// m_rectTracker is set to the new splitter position (without border)
	// (so, adjust relative to where the border will be)
	m_rectTracker.OffsetRect(-AFX_CX_BORDER , -AFX_CY_BORDER);
	m_rectTracker2.OffsetRect(-AFX_CX_BORDER, -AFX_CY_BORDER);

	if (bAccept)
	{
		if (m_htTrack == vSplitterBox)
		{
			SplitRow(m_rectTracker.top);
		}
		else if (m_htTrack >= vSplitterBar1 && m_htTrack <= vSplitterBar15)
		{
			// set row height
			TrackRowSize(m_rectTracker.top, m_htTrack - vSplitterBar1);
			RecalcLayout();
		}
		else if (m_htTrack == hSplitterBox)
		{
			SplitColumn(m_rectTracker.left);
		}
		else if (m_htTrack >= hSplitterBar1 && m_htTrack <= hSplitterBar15)
		{
			// set column width
			TrackColumnSize(m_rectTracker.left, m_htTrack - hSplitterBar1);
			RecalcLayout();
		}
		else if (m_htTrack >= splitterIntersection1 &&
			m_htTrack <= splitterIntersection225)
		{
			// set row height and column width
			int row = (m_htTrack - splitterIntersection1) / 15;
			int col = (m_htTrack - splitterIntersection1) % 15;

			TrackRowSize(m_rectTracker.top, row);
			TrackColumnSize(m_rectTracker2.left, col);
			RecalcLayout();
		}
		else if (m_htTrack == bothSplitterBox)
		{
			// rectTracker is vSplitter (splits rows)
			// rectTracker2 is hSplitter (splits cols)
			SplitRow(m_rectTracker.top);
			SplitColumn(m_rectTracker2.left);
		}
	}

	if (pOldActiveView == GetActivePane())
	{
		if (pOldActiveView != NULL)
		{
			SetActivePane(-1, -1, pOldActiveView); // re-activate
			pOldActiveView->SetFocus(); // make sure focus is restored
		}
	}
}

void CSplitterWnd::GetHitRect(int ht, CRect& rectHit)
{
	ASSERT_VALID(this);

	CRect rectClient;
	GetClientRect(&rectClient);
	rectClient.InflateRect(-m_cxBorder, -m_cyBorder);
	int cx = rectClient.Width();
	int cy = rectClient.Height();
	int x = rectClient.top;
	int y = rectClient.left;

	// hit rectangle does not include border
	// m_rectLimit will be limited to valid tracking rect
	// m_ptTrackOffset will be set to appropriate tracking offset
	m_ptTrackOffset.x = 0;
	m_ptTrackOffset.y = 0;

	if (ht == vSplitterBox)
	{
		cy = m_cySplitter - (2*m_cyBorder - 1);
		m_ptTrackOffset.y = -(cy / 2);
		ASSERT(m_pRowInfo[0].nCurSize > 0);
		m_rectLimit.bottom -= cy;
	}
	else if (ht == hSplitterBox)
	{
		cx = m_cxSplitter - (2*m_cxBorder - 1);
		m_ptTrackOffset.x = -(cx / 2);
		ASSERT(m_pColInfo[0].nCurSize > 0);
		m_rectLimit.right -= cx;
	}
	else if (ht >= vSplitterBar1 && ht <= vSplitterBar15)
	{
		cy = m_cySplitter - (2*m_cyBorder - 1);
		m_ptTrackOffset.y = -(cy / 2);
		int row;
		for (row = 0; row < ht - vSplitterBar1; row++)
			y += m_pRowInfo[row].nCurSize + m_cySplitterGap;
		m_rectLimit.top = y;
		y += m_pRowInfo[row].nCurSize + m_cyBorderShare + 1;
		m_rectLimit.bottom -= cy;
	}
	else if (ht >= hSplitterBar1 && ht <= hSplitterBar15)
	{
		cx = m_cxSplitter - (2*m_cxBorder - 1);
		m_ptTrackOffset.x = -(cx / 2);
		int col;
		for (col = 0; col < ht - hSplitterBar1; col++)
			x += m_pColInfo[col].nCurSize + m_cxSplitterGap;
		m_rectLimit.left = x;
		x += m_pColInfo[col].nCurSize + m_cxBorderShare + 1;
		m_rectLimit.right -= cx;
	}
	else
	{
		TRACE(traceAppMsg, 0, "Error: GetHitRect(%d): Not Found!\n", ht);
		ASSERT(FALSE);
	}

	rectHit.right = (rectHit.left = x) + cx;
	rectHit.bottom = (rectHit.top = y) + cy;
}

int CSplitterWnd::HitTest(CPoint pt) const
{
	ASSERT_VALID(this);

	CRect rectClient;
	GetClientRect(&rectClient);
	rectClient.InflateRect(-m_cxBorder, -m_cyBorder);

	CRect rectInside;
	GetInsideRect(rectInside);

	if (m_bHasVScroll && m_nRows < m_nMaxRows &&
		CRect(rectInside.right, rectClient.top, rectClient.right,
		rectClient.top + m_cySplitter - 1).PtInRect(pt))
	{
		return vSplitterBox;
	}

	if (m_bHasHScroll && m_nCols < m_nMaxCols &&
		CRect(rectClient.left, rectInside.bottom,
		 rectClient.left + m_cxSplitter - 1,
		 rectClient.bottom).PtInRect(pt))
	{
		return hSplitterBox;
	}

	// for hit detect, include the border of splitters
	CRect rect;
	rect = rectClient;
	int col = 0;
	if (m_nCols > 0)
	{
		for (col = 0; col < m_nCols - 1; col++)
		{
			rect.left += m_pColInfo[col].nCurSize;
			rect.right = rect.left + m_cxSplitterGap;
			if (rect.PtInRect(pt))
				break;
			rect.left = rect.right;
		}
	}

	rect = rectClient;
	int row = 0;
	if (m_nRows > 0)
	{
		for (row = 0; row < m_nRows - 1; row++)
		{
			rect.top += m_pRowInfo[row].nCurSize;
			rect.bottom = rect.top + m_cySplitterGap;
			if (rect.PtInRect(pt))
				break;
			rect.top = rect.bottom;
		}
	}

	// row and col set for hit splitter (if not hit will be past end)
	if (col != m_nCols - 1)
	{
		if (row != m_nRows - 1)
			return splitterIntersection1 + row * 15 + col;
		return hSplitterBar1 + col;
	}

	if (row != m_nRows - 1)
		return vSplitterBar1 + row;

	return noHit;
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd tracking visuals

void CSplitterWnd::OnInvertTracker(const CRect& rect)
{
	ASSERT_VALID(this);
	ASSERT(!rect.IsRectEmpty());
	ASSERT((GetStyle() & WS_CLIPCHILDREN) == 0);

	// pat-blt without clip children on
	CDC* pDC = GetDC();
	// invert the brush pattern (looks just like frame window sizing)
	CBrush* pBrush = CDC::GetHalftoneBrush();
	HBRUSH hOldBrush = NULL;
	if (pBrush != NULL)
		hOldBrush = (HBRUSH)SelectObject(pDC->m_hDC, pBrush->m_hObject);
	pDC->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);
	if (hOldBrush != NULL)
		SelectObject(pDC->m_hDC, hOldBrush);
	ReleaseDC(pDC);
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd commands

// Keyboard interface
BOOL CSplitterWnd::DoKeyboardSplit()
{
	ASSERT_VALID(this);

	int ht;
	if (m_nRows > 1 && m_nCols > 1)
		ht = splitterIntersection1; // split existing row+col
	else if (m_nRows > 1)
		ht = vSplitterBar1;         // split existing row
	else if (m_nCols > 1)
		ht = hSplitterBar1;         // split existing col
	else if (m_nMaxRows > 1 && m_nMaxCols > 1)
		ht = bothSplitterBox;       // we can split both
	else if (m_nMaxRows > 1)
		ht = vSplitterBox;          // we can split rows
	else if (m_nMaxCols > 1)
		ht = hSplitterBox;          // we can split columns
	else
		return FALSE;               // can't split

	// start tracking
	StartTracking(ht);

	CRect rect;
	rect.left = m_rectTracker.Width() / 2;
	rect.top = m_rectTracker.Height() / 2;
	if (m_ptTrackOffset.y != 0)
		rect.top = m_rectTracker.top;
	if (m_ptTrackOffset.x != 0)
		rect.left = m_bTracking2 ? m_rectTracker2.left :m_rectTracker.left;
	rect.OffsetRect(-m_ptTrackOffset.x, -m_ptTrackOffset.y);
	ClientToScreen(&rect);
	SetCursorPos(rect.left, rect.top);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Main drawing and layout

void CSplitterWnd::OnDisplayChange()
{
	if (!IsIconic() && IsWindowVisible())
		RecalcLayout();
}

void CSplitterWnd::OnSize(UINT nType, int cx, int cy)
{
	if (nType != SIZE_MINIMIZED && cx > 0 && cy > 0)
		RecalcLayout();

	CWnd::OnSize(nType, cx, cy);
}

// Generic routine:
//  for X direction: pInfo = m_pColInfo, nMax = m_nMaxCols, nSize = cx
//  for Y direction: pInfo = m_pRowInfo, nMax = m_nMaxRows, nSize = cy
AFX_STATIC void AFXAPI _AfxLayoutRowCol(CSplitterWnd::CRowColInfo* pInfoArray,
	int nMax, int nSize, int nSizeSplitter)
{
	ASSERT(pInfoArray != NULL);
	ASSERT(nMax > 0);
	ASSERT(nSizeSplitter > 0);

	CSplitterWnd::CRowColInfo* pInfo;
	int i;

	if (nSize < 0)
		nSize = 0;  // if really too small, layout as zero size

	// start with ideal sizes
	for (i = 0, pInfo = pInfoArray; i < nMax-1; i++, pInfo++)
	{
		if (pInfo->nIdealSize < pInfo->nMinSize)
			pInfo->nIdealSize = 0;      // too small to see
		pInfo->nCurSize = pInfo->nIdealSize;
	}
	pInfo->nCurSize = INT_MAX;  // last row/column takes the rest

	for (i = 0, pInfo = pInfoArray; i < nMax; i++, pInfo++)
	{
		ASSERT(nSize >= 0);
		if (nSize == 0)
		{
			// no more room (set pane to be invisible)
			pInfo->nCurSize = 0;
			continue;       // don't worry about splitters
		}
		else if (nSize < pInfo->nMinSize && i != 0)
		{
			// additional panes below the recommended minimum size
			//   aren't shown and the size goes to the previous pane
			pInfo->nCurSize = 0;

			// previous pane already has room for splitter + border
			//   add remaining size and remove the extra border
			ASSERT(afxData.cxBorder2 == afxData.cyBorder2);
			(pInfo-1)->nCurSize += nSize + afxData.cxBorder2;
			nSize = 0;
		}
		else
		{
			// otherwise we can add the second pane
			ASSERT(nSize > 0);
			if (pInfo->nCurSize == 0)
			{
				// too small to see
				if (i != 0)
					pInfo->nCurSize = 0;
			}
			else if (nSize < pInfo->nCurSize)
			{
				// this row/col won't fit completely - make as small as possible
				pInfo->nCurSize = nSize;
				nSize = 0;
			}
			else
			{
				// can fit everything
				nSize -= pInfo->nCurSize;
			}
		}

		// see if we should add a splitter
		ASSERT(nSize >= 0);
		if (i != nMax - 1)
		{
			// should have a splitter
			if (nSize > nSizeSplitter)
			{
				nSize -= nSizeSplitter; // leave room for splitter + border
				ASSERT(nSize > 0);
			}
			else
			{
				// not enough room - add left over less splitter size
				ASSERT(afxData.cxBorder2 == afxData.cyBorder2);
				pInfo->nCurSize += nSize;
				if (pInfo->nCurSize > (nSizeSplitter - afxData.cxBorder2))
					pInfo->nCurSize -= (nSizeSplitter - afxData.cyBorder2);
				nSize = 0;
			}
		}
	}
	ASSERT(nSize == 0); // all space should be allocated
}

// repositions client area of specified window
// assumes everything has WS_BORDER or is inset like it does
//  (includes scroll bars)
AFX_STATIC void AFXAPI _AfxDeferClientPos(AFX_SIZEPARENTPARAMS* lpLayout,
	CWnd* pWnd, int x, int y, int cx, int cy, BOOL bScrollBar)
{
	ASSERT(pWnd != NULL);
	ASSERT(pWnd->m_hWnd != NULL);

	if (bScrollBar)
	{
		// if there is enough room, draw scroll bar without border
		// if there is not enough room, set the WS_BORDER bit so that
		//   we will at least get a proper border drawn
		BOOL bNeedBorder = (cx <= AFX_CX_BORDER || cy <= AFX_CY_BORDER);
		pWnd->ModifyStyle(bNeedBorder ? 0 : WS_BORDER,
			bNeedBorder ? WS_BORDER : 0);
	}
	CRect rect(x, y, x+cx, y+cy);

	// adjust for 3d border (splitter windows have implied border)
	if ((pWnd->GetExStyle() & WS_EX_CLIENTEDGE) ||
		  pWnd->IsKindOf(RUNTIME_CLASS(CSplitterWnd)))
		rect.InflateRect(afxData.cxBorder2, afxData.cyBorder2);

	// first check if the new rectangle is the same as the current
	CRect rectOld;
	pWnd->GetWindowRect(rectOld);
	pWnd->GetParent()->ScreenToClient(&rectOld);
	if (rect != rectOld)
		AfxRepositionWindow(lpLayout, pWnd->m_hWnd, rect);
}

CWnd* CSplitterWnd::GetSizingParent()
{
	ASSERT_VALID(this);

	// size box is in lower right corner of this window
	CRect rectClient;
	GetClientRect(rectClient);

	// find sizeable parent window
	CWnd* pParent = this;
	if (!(pParent->GetStyle() & WS_THICKFRAME))
		pParent = GetParent();

	// only allow if not maximized and has thick frame
	ASSERT_VALID(pParent);
	if ((pParent->GetStyle() & (WS_THICKFRAME|WS_MAXIMIZE)) == WS_THICKFRAME)
	{
		// convert client area of frame window relative to splitter
		CRect rect;
		pParent->GetClientRect(rect);
		pParent->ClientToScreen(rect);
		ScreenToClient(rect);

		// must match exactly to get the size box
		if (rectClient.BottomRight() == rect.BottomRight())
			return pParent;
	}

	return NULL;    // no sizeable parent found
}

void CSplitterWnd::RecalcLayout()
{
	ASSERT_VALID(this);
	ASSERT(m_nRows > 0 && m_nCols > 0); // must have at least one pane

	CRect rectClient;
	GetClientRect(rectClient);
	rectClient.InflateRect(-m_cxBorder, -m_cyBorder);

	CRect rectInside;
	GetInsideRect(rectInside);

	// layout columns (restrict to possible sizes)
	_AfxLayoutRowCol(m_pColInfo, m_nCols, rectInside.Width(), m_cxSplitterGap);
	_AfxLayoutRowCol(m_pRowInfo, m_nRows, rectInside.Height(), m_cySplitterGap);

	// adjust the panes (and optionally scroll bars)

	// give the hint for the maximum number of HWNDs
	AFX_SIZEPARENTPARAMS layout;
	layout.hDWP = ::BeginDeferWindowPos((m_nCols + 1) * (m_nRows + 1) + 1);

	// size of scrollbars
	int cxScrollbar = rectClient.right - rectInside.right;
	int cyScrollbar = rectClient.bottom - rectInside.bottom;

	// reposition size box
	if (m_bHasHScroll && m_bHasVScroll)
	{
		CWnd* pScrollBar = GetDlgItem(AFX_IDW_SIZE_BOX);
		ASSERT(pScrollBar != NULL);

		// fix style if necessary
		BOOL bSizingParent = (GetSizingParent() != NULL);
		// modifyStyle returns TRUE if style changes
		if (pScrollBar->ModifyStyle(SBS_SIZEGRIP|SBS_SIZEBOX,
				bSizingParent ? SBS_SIZEGRIP : SBS_SIZEBOX))
			pScrollBar->Invalidate();
		pScrollBar->EnableWindow(bSizingParent);

		// reposition the size box
		_AfxDeferClientPos(&layout, pScrollBar,
			rectInside.right, rectInside.bottom, cxScrollbar, cyScrollbar, TRUE);
	}

	// reposition scroll bars
	if (m_bHasHScroll)
	{
		int cxSplitterBox = m_cxSplitter;// split box bigger
		int x = rectClient.left;
		int y = rectInside.bottom;
		for (int col = 0; col < m_nCols; col++)
		{
			CWnd* pScrollBar = GetDlgItem(AFX_IDW_HSCROLL_FIRST + col);
			ASSERT(pScrollBar != NULL);
			int cxCol = m_pColInfo[col].nCurSize;
			if (col == 0 && m_nCols < m_nMaxCols)
				x += cxSplitterBox, cxCol -= cxSplitterBox;
			_AfxDeferClientPos(&layout, pScrollBar, x, y, cxCol, cyScrollbar, TRUE);
			x += cxCol + m_cxSplitterGap;
		}
	}

	if (m_bHasVScroll)
	{
		int cySplitterBox = m_cySplitter;// split box bigger
		int x = rectInside.right;
		int y = rectClient.top;
		for (int row = 0; row < m_nRows; row++)
		{
			CWnd* pScrollBar = GetDlgItem(AFX_IDW_VSCROLL_FIRST + row);
			ASSERT(pScrollBar != NULL);
			int cyRow = m_pRowInfo[row].nCurSize;
			if (row == 0 && m_nRows < m_nMaxRows)
				y += cySplitterBox, cyRow -= cySplitterBox;
			_AfxDeferClientPos(&layout, pScrollBar, x, y, cxScrollbar, cyRow, TRUE);
			y += cyRow + m_cySplitterGap;
		}
	}

	//BLOCK: Reposition all the panes
	{
		int x = rectClient.left;
		for (int col = 0; col < m_nCols; col++)
		{
			int cxCol = m_pColInfo[col].nCurSize;
			int y = rectClient.top;
			for (int row = 0; row < m_nRows; row++)
			{
				int cyRow = m_pRowInfo[row].nCurSize;
				CWnd* pWnd = GetPane(row, col);
				_AfxDeferClientPos(&layout, pWnd, x, y, cxCol, cyRow, FALSE);
				y += cyRow + m_cySplitterGap;
			}
			x += cxCol + m_cxSplitterGap;
		}
	}

	// move and resize all the windows at once!
	if (layout.hDWP == NULL || !::EndDeferWindowPos(layout.hDWP))
		TRACE(traceAppMsg, 0, "Warning: DeferWindowPos failed - low system resources.\n");

	// invalidate all the splitter bars (with NULL pDC)
	DrawAllSplitBars(NULL, rectInside.right, rectInside.bottom);
}

void CSplitterWnd::DrawAllSplitBars(CDC* pDC, int cxInside, int cyInside)
{
	ASSERT_VALID(this);

	int col;
	int row;

	// draw column split bars
	CRect rect;
	GetClientRect(rect);
	rect.left += m_cxBorder;
	for (col = 0; col < m_nCols - 1; col++)
	{
		rect.left += m_pColInfo[col].nCurSize + m_cxBorderShare;
		rect.right = rect.left + m_cxSplitter;
		if (rect.left > cxInside)
			break;      // stop if not fully visible
		OnDrawSplitter(pDC, splitBar, rect);
		rect.left = rect.right + m_cxBorderShare;
	}

	// draw row split bars
	GetClientRect(rect);
	rect.top += m_cyBorder;
	for (row = 0; row < m_nRows - 1; row++)
	{
		rect.top += m_pRowInfo[row].nCurSize + m_cyBorderShare;
		rect.bottom = rect.top + m_cySplitter;
		if (rect.top > cyInside)
			break;      // stop if not fully visible
		OnDrawSplitter(pDC, splitBar, rect);
		rect.top = rect.bottom + m_cyBorderShare;
	}

	// draw pane borders
	GetClientRect(rect);
	int x = rect.left;
	for (col = 0; col < m_nCols; col++)
	{
		int cx = m_pColInfo[col].nCurSize + 2*m_cxBorder;
		if (col == m_nCols-1 && m_bHasVScroll)
			cx += afxData.cxVScroll - AFX_CX_BORDER;
		int y = rect.top;
		for (row = 0; row < m_nRows; row++)
		{
			int cy = m_pRowInfo[row].nCurSize + 2*m_cyBorder;
			if (row == m_nRows-1 && m_bHasHScroll)
				cy += afxData.cyHScroll - AFX_CX_BORDER;
			OnDrawSplitter(pDC, splitBorder, CRect(x, y, x+cx, y+cy));
			y += cy + m_cySplitterGap - 2*m_cyBorder;
		}
		x += cx + m_cxSplitterGap - 2*m_cxBorder;
	}
}

void CSplitterWnd::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CRect rectClient;
	GetClientRect(&rectClient);
	rectClient.InflateRect(-m_cxBorder, -m_cyBorder);

	CRect rectInside;
	GetInsideRect(rectInside);

	// draw the splitter boxes
	if (m_bHasVScroll && m_nRows < m_nMaxRows)
	{
		OnDrawSplitter(pDC, splitBox,
			CRect(rectInside.right, rectClient.top,
			rectClient.right, rectClient.top + m_cySplitter));
	}

	if (m_bHasHScroll && m_nCols < m_nMaxCols)
	{
		OnDrawSplitter(pDC, splitBox,
			CRect(rectClient.left, rectInside.bottom,
			rectClient.left + m_cxSplitter, rectClient.bottom));
	}

	// extend split bars to window border (past margins)
	DrawAllSplitBars(pDC, rectInside.right, rectInside.bottom);
}

void CSplitterWnd::OnPaint()
{
	ASSERT_VALID(this);
	CPaintDC dc(this);

	OnDraw(&dc);
}

LRESULT CSplitterWnd::OnPrintClient(WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	ASSERT_VALID(this);

	HDC hdc = (HDC) wParam;
	CDC* pDC = CDC::FromHandle(hdc);

	ASSERT_VALID(pDC);

	if (pDC == NULL)
	{
		return -1L;
	}

	OnDraw(pDC);

	return 0L;
}

BOOL CSplitterWnd::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (nHitTest == HTCLIENT && pWnd == this && !m_bTracking)
		return TRUE;    // we will handle it in the mouse move

	return CWnd::OnSetCursor(pWnd, nHitTest, message);
}

// cache of last needed cursor
AFX_STATIC_DATA HCURSOR _afx_hcurLast = NULL;
AFX_STATIC_DATA HCURSOR _afx_hcurDestroy = NULL;
AFX_STATIC_DATA UINT _afx_idcPrimaryLast = 0; // store the primary IDC

void CSplitterWnd::SetSplitCursor(int ht)
{
	UINT idcPrimary;        // app supplied cursor
	LPCTSTR idcSecondary;    // system supplied cursor (ATL_MAKEINTRESOURCE)

	AfxLockGlobals(CRIT_SPLITTERWND);
	if (ht == vSplitterBox ||
		ht >= vSplitterBar1 && ht <= vSplitterBar15)
	{
		idcPrimary = AFX_IDC_VSPLITBAR;
		idcSecondary = IDC_SIZENS;
	}
	else if (ht == hSplitterBox ||
		ht >= hSplitterBar1 && ht <= hSplitterBar15)
	{
		idcPrimary = AFX_IDC_HSPLITBAR;
		idcSecondary = IDC_SIZEWE;
	}
	else if (ht == bothSplitterBox ||
		(ht >= splitterIntersection1 && ht <= splitterIntersection225))
	{
		idcPrimary = AFX_IDC_SMALLARROWS;
		idcSecondary = IDC_SIZEALL;
	}
	else
	{
		SetCursor(afxData.hcurArrow);
		idcPrimary = 0;     // don't use it
		idcSecondary = 0;   // don't use it
	}

	if (idcPrimary != 0)
	{
		HCURSOR hcurToDestroy = NULL;
		if (idcPrimary != _afx_idcPrimaryLast)
		{
			HINSTANCE hInst = AfxFindResourceHandle(
				ATL_MAKEINTRESOURCE(idcPrimary), ATL_RT_GROUP_CURSOR);

			// load in another cursor
			hcurToDestroy = _afx_hcurDestroy;

			// Note: If this LoadCursor call fails, it is likely that
			//  _AFX_NO_SPLITTER_RESOURCES is defined in your .RC file.
			// To correct the situation, remove the following line from your
			//  resource script:
			//      #define _AFX_NO_SPLITTER_RESOURCES
			// This should be done using the Resource.Set Includes... command.

			if ((_afx_hcurDestroy = _afx_hcurLast =
			   ::LoadCursorW(hInst, ATL_MAKEINTRESOURCEW(idcPrimary))) == NULL)
			{
				// will not look as good
				TRACE(traceAppMsg, 0, "Warning: Could not find splitter cursor - "
					"using system provided alternative.\n");

				ASSERT(_afx_hcurDestroy == NULL);    // will not get destroyed
				_afx_hcurLast = ::LoadCursor(NULL, idcSecondary);
				ASSERT(_afx_hcurLast != NULL);
			}
			_afx_idcPrimaryLast = idcPrimary;
		}
		ASSERT(_afx_hcurLast != NULL);
		::SetCursor(_afx_hcurLast);
		ASSERT(_afx_hcurLast != hcurToDestroy);
		if (hcurToDestroy != NULL)
			::DestroyCursor(hcurToDestroy); // destroy after being set
	}
	AfxUnlockGlobals(CRIT_SPLITTERWND);
}

void CSplitterWnd::OnMouseMove(UINT /*nFlags*/, CPoint pt)
{
	if (GetCapture() != this)
		StopTracking(FALSE);

	if (m_bTracking)
	{
		// move tracker to current cursor position

		pt.Offset(m_ptTrackOffset); // pt is the upper right of hit detect
		// limit the point to the valid split range
		if (pt.y < m_rectLimit.top)
			pt.y = m_rectLimit.top;
		else if (pt.y > m_rectLimit.bottom)
			pt.y = m_rectLimit.bottom;
		if (pt.x < m_rectLimit.left)
			pt.x = m_rectLimit.left;
		else if (pt.x > m_rectLimit.right)
			pt.x = m_rectLimit.right;

		if (m_htTrack == vSplitterBox ||
			m_htTrack >= vSplitterBar1 && m_htTrack <= vSplitterBar15)
		{
			if (m_rectTracker.top != pt.y)
			{
				OnInvertTracker(m_rectTracker);
				m_rectTracker.OffsetRect(0, pt.y - m_rectTracker.top);
				OnInvertTracker(m_rectTracker);
			}
		}
		else if (m_htTrack == hSplitterBox ||
			m_htTrack >= hSplitterBar1 && m_htTrack <= hSplitterBar15)
		{
			if (m_rectTracker.left != pt.x)
			{
				OnInvertTracker(m_rectTracker);
				m_rectTracker.OffsetRect(pt.x - m_rectTracker.left, 0);
				OnInvertTracker(m_rectTracker);
			}
		}
		else if (m_htTrack == bothSplitterBox ||
		   (m_htTrack >= splitterIntersection1 &&
			m_htTrack <= splitterIntersection225))
		{
			if (m_rectTracker.top != pt.y)
			{
				OnInvertTracker(m_rectTracker);
				m_rectTracker.OffsetRect(0, pt.y - m_rectTracker.top);
				OnInvertTracker(m_rectTracker);
			}
			if (m_rectTracker2.left != pt.x)
			{
				OnInvertTracker(m_rectTracker2);
				m_rectTracker2.OffsetRect(pt.x - m_rectTracker2.left, 0);
				OnInvertTracker(m_rectTracker2);
			}
		}
	}
	else
	{
		// simply hit-test and set appropriate cursor

		int ht = HitTest(pt);
		SetSplitCursor(ht);
	}
}

void CSplitterWnd::OnLButtonDown(UINT /*nFlags*/, CPoint pt)
{
	if (m_bTracking)
		return;

	StartTracking(HitTest(pt));
}

void CSplitterWnd::OnLButtonDblClk(UINT /*nFlags*/, CPoint pt)
{
	int ht = HitTest(pt);
	CRect rect;

	StopTracking(FALSE);

	if ((GetStyle() & SPLS_DYNAMIC_SPLIT) == 0)
		return;     // do nothing if layout is static

	if (ht == vSplitterBox)
	{
		// half split
		SplitRow(m_pRowInfo[0].nCurSize / 2);
	}
	else if (ht == hSplitterBox)
	{
		// half split
		SplitColumn(m_pColInfo[0].nCurSize / 2);
	}
	else if (ht >= vSplitterBar1 && ht <= vSplitterBar15)
	{
		int rowDelete = ht - vSplitterBar1;
		// don't delete the active row
		int row;
		if (GetActivePane(&row, NULL) != NULL && rowDelete == row)
			++rowDelete;
		DeleteRow(rowDelete);
	}
	else if (ht >= hSplitterBar1 && ht <= hSplitterBar15)
	{
		int colDelete = ht - hSplitterBar1;
		// don't delete the active column
		int col;
		if (GetActivePane(NULL, &col) != NULL && colDelete == col)
			++colDelete;
		DeleteColumn(colDelete);
	}
	else if (ht >= splitterIntersection1 && ht <= splitterIntersection225)
	{
		int rowDelete = (ht - splitterIntersection1) / 15;
		int colDelete = (ht - splitterIntersection1) % 15;
		int row, col;
		if (GetActivePane(&row, &col) != NULL)
		{
			// don't delete the active row or column
			if (col == colDelete)
				++colDelete;
			if (row == rowDelete)
				++rowDelete;
		}
		DeleteRow(rowDelete);
		DeleteColumn(colDelete);
	}
}

void CSplitterWnd::OnLButtonUp(UINT /*nFlags*/, CPoint /*pt*/)
{
	StopTracking(TRUE);
}

void CSplitterWnd::OnCancelMode()
{
	StopTracking(FALSE);
}

void CSplitterWnd::OnKeyDown(UINT nChar, UINT /*nRepCnt*/, UINT /*nFlags*/)
{
	CPoint pt;
	GetCursorPos(&pt);

	int cz = GetKeyState(VK_CONTROL) < 0 ? 1 : 16;
	int dx = 0;
	int dy = 0;

	switch (nChar)
	{
	case VK_ESCAPE:
		StopTracking(FALSE);
		return;
	case VK_RETURN:
		StopTracking(TRUE);
		return;

	case VK_LEFT:
		dx = -1;
		break;
	case VK_RIGHT:
		dx = +1;
		break;
	case VK_UP:
		dy = -1;
		break;
	case VK_DOWN:
		dy = +1;
		break;

	default:
		Default();  // pass other keys through
		return;
	}

	if (m_htTrack == vSplitterBox ||
		m_htTrack >= vSplitterBar1 && m_htTrack <= vSplitterBar15)
	{
		// no movement along X axis
		dx = 0;
	}
	if (m_htTrack == hSplitterBox ||
		m_htTrack >= hSplitterBar1 && m_htTrack <= hSplitterBar15)
	{
		// no movement along Y axis
		dy = 0;
	}

	// adjust to new position
	pt.x += dx * cz;
	pt.y += dy * cz;

	// make sure within valid limits
	ScreenToClient(&pt);
	if (pt.y < m_rectLimit.top)
		pt.y = m_rectLimit.top;
	else if (pt.y > m_rectLimit.bottom)
		pt.y = m_rectLimit.bottom;
	if (pt.x < m_rectLimit.left)
		pt.x = m_rectLimit.left;
	else if (pt.x > m_rectLimit.right)
		pt.x = m_rectLimit.right;
	ClientToScreen(&pt);

	// cause WM_MOUSEMOVE to filter through
	SetCursorPos(pt.x, pt.y);
}

void CSplitterWnd::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == SC_SIZE)
	{
		CWnd* pParent = GetSizingParent();
		if (pParent != NULL)
		{
			pParent->SendMessage(WM_SYSCOMMAND, (WPARAM)nID, lParam);
			return;
		}
	}
	CWnd::OnSysCommand(nID, lParam);
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd command routing

BOOL CSplitterWnd::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (CWnd::OnCommand(wParam, lParam))
		return TRUE;

	// route commands to the splitter to the parent frame window
	CFrameWnd *pFrameWnd=EnsureParentFrame();
	return !pFrameWnd->SendMessage(WM_COMMAND, wParam, lParam);
}

BOOL CSplitterWnd::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	if (CWnd::OnNotify(wParam, lParam, pResult))
		return TRUE;

	// route commands to the splitter to the parent frame window
	*pResult = EnsureParentFrame()->SendMessage(WM_NOTIFY, wParam, lParam);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Scroll messages

BOOL CSplitterWnd::OnMouseWheel(UINT fFlags, short zDelta, CPoint point)
{
	BOOL bRetVal = FALSE;
	int row;
	int col;


	BOOL bHasVert = FALSE;

	// determine if any of the panes have a vertical scroll bar
	for (row = 0; row < m_nRows; row++)
	{
		for (col = 0; col < m_nCols; col++)
		{
			CWnd* pPane = GetPane(row, col);
			CScrollView* pView = DYNAMIC_DOWNCAST(CScrollView, pPane);
			if (pView != NULL)
			{
				CScrollBar* pBar = pView->GetScrollBarCtrl(SB_VERT);
				if (pBar != NULL && pBar->IsWindowEnabled())
				{
					bHasVert = TRUE;
					break;
				}
			}
		}
		if (bHasVert)
			break;
	}		

	// find panes in the splitter that have scroll bars
	// and have them do their scrolling

	for (row = 0; row < m_nRows; row++)
	{
		for (col = 0; col < m_nCols; col++)
		{
			// only do the scrolling if the window is-a CScrollView

			CWnd* pPane = GetPane(row, col);
			CScrollView* pView = DYNAMIC_DOWNCAST(CScrollView, pPane);
			if (pView != NULL)
			{
				// prefer to scroll vertically if available

				CScrollBar* pBar = NULL;
				if (bHasVert)
					pBar = pView->GetScrollBarCtrl(SB_VERT);
				else
					pBar = pView->GetScrollBarCtrl(SB_HORZ);
				if (pBar == NULL || !pBar->IsWindowEnabled())
				{
					continue;
				}

				// get the old position, do the scrolling, and
				// then trigger the repaint

				int nOldPos = pBar->GetScrollPos();

				if (pView->DoMouseWheel(fFlags, zDelta, point))
					bRetVal = TRUE;

				if (bHasVert && col < m_nCols -1)
					pBar->SetScrollPos(nOldPos, FALSE);
				else if (!bHasVert && row < m_nRows -1)
					pBar->SetScrollPos(nOldPos, FALSE);

			}
		}
	}

	return TRUE;
}

void CSplitterWnd::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	ASSERT(pScrollBar != NULL);
	int col = _AfxGetDlgCtrlID(pScrollBar->m_hWnd) - AFX_IDW_HSCROLL_FIRST;
	ASSERT(col >= 0 && col < m_nMaxCols);

	ASSERT(m_nRows > 0);
	int nOldPos = pScrollBar->GetScrollPos();
#ifdef _DEBUG
	int nNewPos;
#endif
	for (int row = 0; row < m_nRows; row++)
	{
		GetPane(row, col)->SendMessage(WM_HSCROLL,
			MAKELONG(nSBCode, nPos), (LPARAM)pScrollBar->m_hWnd);
#ifdef _DEBUG
		if (row == 0)
		{
			nNewPos = pScrollBar->GetScrollPos();
			if (pScrollBar->GetScrollPos() != nNewPos)
			{
				TRACE(traceAppMsg, 0, "Warning: scroll panes setting different scroll positions.\n");
				// stick with the last one set
			}
		}
#endif //_DEBUG
		// set the scroll pos to the value it was originally for the next pane
		if (row < m_nRows - 1)
			pScrollBar->SetScrollPos(nOldPos, FALSE);
	}
}

void CSplitterWnd::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	ASSERT(pScrollBar != NULL);
	int row = _AfxGetDlgCtrlID(pScrollBar->m_hWnd) - AFX_IDW_VSCROLL_FIRST;
	ASSERT(row >= 0 && row < m_nMaxRows);

	ASSERT(m_nCols > 0);
	int nOldPos = pScrollBar->GetScrollPos();
#ifdef _DEBUG
	int nNewPos;
#endif
	for (int col = 0; col < m_nCols; col++)
	{
		GetPane(row, col)->SendMessage(WM_VSCROLL,
			MAKELONG(nSBCode, nPos), (LPARAM)pScrollBar->m_hWnd);
#ifdef _DEBUG
		if (col == 0)
		{
			nNewPos = pScrollBar->GetScrollPos();
			if (pScrollBar->GetScrollPos() != nNewPos)
			{
				TRACE(traceAppMsg, 0, "Warning: scroll panes setting different scroll positions.\n");
				// stick with the last one set
			}
		}
#endif //_DEBUG
		// set the scroll pos to the value it was originally for the next pane
		if (col < m_nCols - 1)
			pScrollBar->SetScrollPos(nOldPos, FALSE);
	}
}

// synchronized scrolling
BOOL CSplitterWnd::DoScroll(CView* pViewFrom, UINT nScrollCode, BOOL bDoScroll)
{
	ASSERT_VALID(pViewFrom);

	int rowFrom, colFrom;
	if (!IsChildPane(pViewFrom, &rowFrom, &colFrom))
		return FALSE;

	BOOL bResult = FALSE;

	// save original positions
	int nOldVert = 0;
	CScrollBar* pScrollVert = pViewFrom->GetScrollBarCtrl(SB_VERT);
	if (pScrollVert != NULL)
		nOldVert = pScrollVert->GetScrollPos();
	int nOldHorz = 0;
	CScrollBar* pScrollHorz = pViewFrom->GetScrollBarCtrl(SB_HORZ);
	if (pScrollHorz != NULL)
		nOldHorz = pScrollHorz->GetScrollPos();

	// scroll the view from which the message is from
	if (pViewFrom->OnScroll(nScrollCode, 0, bDoScroll))
		bResult = TRUE;

	if (pScrollVert != NULL)
	{
#ifdef _DEBUG
		int nNewVert = pScrollVert->GetScrollPos();
#endif
		// scroll related columns
		for (int col = 0; col < m_nCols; col++)
		{
			if (col == colFrom)
				continue;

			// set the scroll pos to the value it was originally
			pScrollVert->SetScrollPos(nOldVert, FALSE);

			// scroll the pane
			CView* pView = (CView*)GetPane(rowFrom, col);
			ASSERT_KINDOF(CView, pView);
			ASSERT(pView != pViewFrom);
			if (pView->OnScroll(MAKEWORD(0xff, HIBYTE(nScrollCode)), 0,
				bDoScroll))
			{
				bResult = TRUE;
			}

#ifdef _DEBUG
			if (pScrollVert->GetScrollPos() != nNewVert)
			{
				TRACE(traceAppMsg, 0, "Warning: scroll panes setting different scroll positions.\n");
				// stick with the last one set
			}
#endif
		}
	}

	if (pScrollHorz != NULL)
	{
#ifdef _DEBUG
		int nNewHorz = pScrollHorz->GetScrollPos();
#endif
		// scroll related rows
		for (int row = 0; row < m_nRows; row++)
		{
			if (row == rowFrom)
				continue;

			// set the scroll pos to the value it was originally
			pScrollHorz->SetScrollPos(nOldHorz, FALSE);

			// scroll the pane
			CView* pView = (CView*)GetPane(row, colFrom);
			ASSERT_KINDOF(CView, pView);
			ASSERT(pView != pViewFrom);
			if (pView->OnScroll(MAKEWORD(LOBYTE(nScrollCode), 0xff), 0,
				bDoScroll))
			{
				bResult = TRUE;
			}

#ifdef _DEBUG
			if (pScrollHorz->GetScrollPos() != nNewHorz)
			{
				TRACE(traceAppMsg, 0, "Warning: scroll panes setting different scroll positions.\n");
				// stick with the last one set
			}
#endif
		}
	}

	return bResult;
}

BOOL CSplitterWnd::DoScrollBy(CView* pViewFrom, CSize sizeScroll, BOOL bDoScroll)
{
	int rowFrom, colFrom;
	if (!IsChildPane(pViewFrom, &rowFrom, &colFrom))
		return FALSE;

	BOOL bResult = FALSE;

	// save original positions
	int nOldVert = 0;
	CScrollBar* pScrollVert = pViewFrom->GetScrollBarCtrl(SB_VERT);
	if (pScrollVert != NULL)
		nOldVert = pScrollVert->GetScrollPos();
	int nOldHorz = 0;
	CScrollBar* pScrollHorz = pViewFrom->GetScrollBarCtrl(SB_HORZ);
	if (pScrollHorz != NULL)
		nOldHorz = pScrollHorz->GetScrollPos();

	// scroll the view from which the message is from
	if (pViewFrom->OnScrollBy(sizeScroll, bDoScroll))
		bResult = TRUE;

	if (pScrollVert != NULL)
	{
#ifdef _DEBUG
		int nNewVert = pScrollVert->GetScrollPos();
#endif
		// scroll related columns
		for (int col = 0; col < m_nCols; col++)
		{
			if (col == colFrom)
				continue;

			// set the scroll pos to the value it was originally for the next pane
			pScrollVert->SetScrollPos(nOldVert, FALSE);

			// scroll the pane
			CView* pView = (CView*)GetPane(rowFrom, col);
			ASSERT_KINDOF(CView, pView);
			ASSERT(pView != pViewFrom);
			if (pView->OnScrollBy(CSize(0, sizeScroll.cy), bDoScroll))
				bResult = TRUE;

#ifdef _DEBUG
			if (pScrollVert->GetScrollPos() != nNewVert)
			{
				TRACE(traceAppMsg, 0, "Warning: scroll panes setting different scroll positions.\n");
				// stick with the last one set
			}
#endif
		}
	}

	if (pScrollHorz != NULL)
	{
#ifdef _DEBUG
	int nNewHorz = pScrollHorz->GetScrollPos();
#endif
		// scroll related rows
		for (int row = 0; row < m_nRows; row++)
		{
			if (row == rowFrom)
				continue;

			// set the scroll pos to the value it was originally for the next pane
			pScrollHorz->SetScrollPos(nOldHorz, FALSE);

			// scroll the pane
			CView* pView = (CView*)GetPane(row, colFrom);
			ASSERT_KINDOF(CView, pView);
			ASSERT(pView != pViewFrom);
			if (pView->OnScrollBy(CSize(sizeScroll.cx, 0), bDoScroll))
				bResult = TRUE;

#ifdef _DEBUG
			if (pScrollHorz->GetScrollPos() != nNewHorz)
			{
				TRACE(traceAppMsg, 0, "Warning: scroll panes setting different scroll positions.\n");
				// stick with the last one set
			}
#endif
		}
	}

	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// Focus control and control over the current pane/child

BOOL CSplitterWnd::CanActivateNext(BOOL)
{
	ASSERT_VALID(this);

	if (GetActivePane() == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: Can't go to next pane - there is no current pane.\n");
		return FALSE;
	}
	ASSERT(m_nRows != 0);
	ASSERT(m_nCols != 0);
	// if more than 1x1 we can go to the next or prev pane
	return (m_nRows > 1) || (m_nCols > 1);
}

void CSplitterWnd::ActivateNext(BOOL bPrev)
{
	ASSERT_VALID(this);

	// find the coordinate of the current pane
	int row, col;
	if (GetActivePane(&row, &col) == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: Cannot go to next pane - there is no current view.\n");
		return;
	}
	ASSERT(row >= 0 && row < m_nRows);
	ASSERT(col >= 0 && col < m_nCols);

	// determine next pane
	if (bPrev)
	{
		// prev
		if (--col < 0)
		{
			col = m_nCols - 1;
			if (--row < 0)
				row = m_nRows - 1;
		}
	}
	else
	{
		// next
		if (++col >= m_nCols)
		{
			col = 0;
			if (++row >= m_nRows)
				row = 0;
		}
	}

	// set newly active pane
	SetActivePane(row, col);
}

void CSplitterWnd::SetActivePane(int row, int col, CWnd* pWnd)
{
	// set the focus to the pane
	CWnd* pPane = pWnd == NULL ? GetPane(row, col) : pWnd;
	if (pPane->IsKindOf(RUNTIME_CLASS(CView)))
	{
		CFrameWnd* pFrameWnd = EnsureParentFrame();
		pFrameWnd->SetActiveView((CView*)pPane);
	}
	else
	{
		TRACE(traceAppMsg, 0, "Warning: Next pane is not a view - calling SetFocus.\n");
		pPane->SetFocus();
	}
}

CWnd* CSplitterWnd::GetActivePane(int* pRow, int* pCol)
	// return active view, NULL when no active view
{
	ASSERT_VALID(this);

	// attempt to use active view of frame window
	CWnd* pView = NULL;
	CFrameWnd* pFrameWnd = EnsureParentFrame();
	pView = pFrameWnd->GetActiveView();

	// failing that, use the current focus
	if (pView == NULL)
		pView = GetFocus();

	// make sure the pane is a child pane of the splitter
	if (pView != NULL && !IsChildPane(pView, pRow, pCol))
		pView = NULL;

	return pView;
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd diagnostics

#ifdef _DEBUG
void CSplitterWnd::AssertValid() const
{
	CWnd::AssertValid();
	ASSERT(m_nMaxRows >= 1);
	ASSERT(m_nMaxCols >= 1);
	ASSERT(m_nMaxCols > 1 || m_nMaxRows > 1);       // 1x1 is not permitted
	ASSERT(m_nRows >= 1);
	ASSERT(m_nCols >= 1);
	ASSERT(m_nRows <= m_nMaxRows);
	ASSERT(m_nCols <= m_nMaxCols);
}

void CSplitterWnd::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);

	if (m_pDynamicViewClass != NULL)
		dc << "m_pDynamicViewClass = " << m_pDynamicViewClass->m_lpszClassName;
	dc << "\nm_nMaxRows = " << m_nMaxRows;
	dc << "\nm_nMaxCols = " << m_nMaxCols;
	dc << "\nm_nRows = " << m_nRows;
	dc << "\nm_nCols = " << m_nCols;
	dc << "\nm_bHasHScroll = " << m_bHasHScroll;
	dc << "\nm_bHasVScroll = " << m_bHasVScroll;
	dc << "\nm_cxSplitter = " << m_cxSplitter;
	dc << "\nm_cySplitter = " << m_cySplitter;
	if (m_bTracking)
	{
		dc << "\nTRACKING: m_htTrack = " << m_htTrack;
		dc << "\nm_rectLimit = " << m_rectLimit;
		dc << "\nm_ptTrackOffset = " << m_ptTrackOffset;
		dc << "\nm_rectTracker = " << m_rectTracker;
		if (m_bTracking2)
			dc << "\nm_rectTracker2 = " << m_rectTracker2;
	}

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winutil.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <malloc.h>



/////////////////////////////////////////////////////////////////////////////
// Other helpers

BOOL AFXAPI AfxCustomLogFont(UINT nIDS, LOGFONT* pLogFont)
{
	ENSURE_ARG(pLogFont != NULL);
	ASSERT(nIDS != 0);

	TCHAR szFontInfo[256];
	if (!AfxLoadString(nIDS, szFontInfo,_countof(szFontInfo)))
		return FALSE;

	LPTSTR lpszSize = _tcschr(szFontInfo, '\n');
	if (lpszSize != NULL)
	{
		// get point size and convert to pixels
		pLogFont->lfHeight = _ttoi(lpszSize+1);
		pLogFont->lfHeight =
			MulDiv(pLogFont->lfHeight, afxData.cyPixelsPerInch, 72);
		*lpszSize = '\0';
	}
	Checked::tcsncpy_s(pLogFont->lfFaceName, _countof(pLogFont->lfFaceName), szFontInfo, _TRUNCATE);
	return TRUE;
}

BOOL AFXAPI _AfxIsComboBoxControl(HWND hWnd, UINT nStyle)
{
	if (hWnd == NULL)
		return FALSE;
	// do cheap style compare first
	if ((UINT)(::GetWindowLong(hWnd, GWL_STYLE) & 0x0F) != nStyle)
		return FALSE;

	// do expensive classname compare next
	TCHAR szCompare[_countof("combobox")+1];
	::GetClassName(hWnd, szCompare, _countof(szCompare));
	return ::AfxInvariantStrICmp(szCompare, _T("combobox")) == 0;
}

BOOL AFXAPI _AfxCompareClassName(HWND hWnd, LPCTSTR lpszClassName)
{
	ASSERT(::IsWindow(hWnd));
	TCHAR szTemp[32];
	::GetClassName(hWnd, szTemp, _countof(szTemp));
	return ::AfxInvariantStrICmp(szTemp, lpszClassName) == 0;
}

HWND AFXAPI _AfxChildWindowFromPoint(HWND hWnd, POINT pt)
{
	ASSERT(hWnd != NULL);

	// check child windows
	::ClientToScreen(hWnd, &pt);
	HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
	for (; hWndChild != NULL; hWndChild = ::GetWindow(hWndChild, GW_HWNDNEXT))
	{
		if (_AfxGetDlgCtrlID(hWndChild) != (WORD)-1 &&
			(::GetWindowLong(hWndChild, GWL_STYLE) & WS_VISIBLE))
		{
			// see if point hits the child window
			CRect rect;
			::GetWindowRect(hWndChild, rect);
			if (rect.PtInRect(pt))
				return hWndChild;
		}
	}

	return NULL;    // not found
}

HWND AFXAPI _AfxTopChildWindowFromPoint(HWND hWnd, POINT pt)
{
	ASSERT(hWnd != NULL);

	// ask Windows for the child window at the point
	HWND hWndRet = ::RealChildWindowFromPoint(hWnd, pt);
	if (hWndRet != NULL)
	{
		return ((hWndRet == hWnd) ? NULL : hWndRet);
	}

	// fallback: check child windows, return the topmost child that contains the point
	::ClientToScreen(hWnd, &pt);
	HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
	for (; hWndChild != NULL; hWndChild = ::GetWindow(hWndChild, GW_HWNDNEXT))
	{
		if (_AfxGetDlgCtrlID(hWndChild) != (WORD)-1 && (::GetWindowLong(hWndChild, GWL_STYLE) & WS_VISIBLE))
		{
			// see if point hits the child window
			CRect rect;
			::GetWindowRect(hWndChild, rect);
			if (rect.PtInRect(pt))
			{
				hWndRet = hWndChild;
			}
		}
	}

	return hWndRet;    // not found
}

void AFXAPI AfxSetWindowText(HWND hWndCtrl, LPCTSTR lpszNew)
{
	ENSURE(hWndCtrl);
	ENSURE(lpszNew);

	int nNewLen = lstrlen(lpszNew);
	TCHAR szOld[256]=_T("");
	// fast check to see if text really changes (reduces flash in controls)
	if (nNewLen > _countof(szOld) ||
		::GetWindowText(hWndCtrl, szOld, _countof(szOld)) != nNewLen ||
		lstrcmp(szOld, lpszNew) != 0)
	{
		// change it
		::SetWindowText(hWndCtrl, lpszNew);
	}
}

void AFXAPI AfxDeleteObject(HGDIOBJ* pObject)
{
	ENSURE_ARG(pObject != NULL);	
	if (*pObject != NULL)
	{
		DeleteObject(*pObject);
		*pObject = NULL;
	}
}

void AFXAPI AfxCancelModes(HWND hWndRcvr)
{
	// if we receive a message destined for a window, cancel any combobox
	//  popups that could be in toolbars or dialog bars
	HWND hWndCancel = ::GetFocus();
	if (hWndCancel == NULL)
		return;     // nothing to cancel

	if (hWndCancel == hWndRcvr)
		return;     // let input go to window with focus

	// focus is in part of a combo-box
	if (!_AfxIsComboBoxControl(hWndCancel, (UINT)CBS_DROPDOWNLIST))
	{
		// check as a dropdown
		hWndCancel = ::GetParent(hWndCancel);   // parent of edit is combo
		if (hWndCancel == hWndRcvr)
			return;     // let input go to part of combo

		if (!_AfxIsComboBoxControl(hWndCancel, (UINT)CBS_DROPDOWN))
			return;     // not a combo-box that is active
	}

	// combo-box is active, but if receiver is a popup, do nothing
	if (hWndRcvr != NULL &&
	  (::GetWindowLong(hWndRcvr, GWL_STYLE) & WS_CHILD) != 0 &&
	  ::GetParent(hWndRcvr) == ::GetDesktopWindow())
		return;

	// finally, we should cancel the mode!
	::SendMessage(hWndCancel, CB_SHOWDROPDOWN, FALSE, 0L);
}

void AFXAPI AfxGlobalFree(HGLOBAL hGlobal)
{
	if (hGlobal == NULL)
		return;

	// avoid bogus warning error messages from various debugging tools
	ASSERT(GlobalFlags(hGlobal) != GMEM_INVALID_HANDLE);
	UINT nCount = GlobalFlags(hGlobal) & GMEM_LOCKCOUNT;
	while (nCount--)
		GlobalUnlock(hGlobal);

	// finally, really free the handle
	GlobalFree(hGlobal);
}

/////////////////////////////////////////////////////////////////////////////
// Special new handler for safety pool on temp maps

#ifndef _AFX_PORTABLE

#define MIN_MALLOC_OVERHEAD 4   // LocalAlloc or other overhead

int AFX_CDECL AfxCriticalNewHandler(size_t nSize)
	// nSize is already rounded
{
	// called during critical memory allocation
	//  free up part of the app's safety cache
	TRACE(traceMemory, 0, "Warning: Critical memory allocation failed!\n");
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (pThreadState != NULL && pThreadState->m_pSafetyPoolBuffer != NULL)
	{
		size_t nOldBufferSize = _msize(pThreadState->m_pSafetyPoolBuffer);
		if (nOldBufferSize <= nSize + MIN_MALLOC_OVERHEAD)
		{
			// give it all up
			TRACE(traceMemory, 0, "Warning: Freeing application's memory safety pool!\n");
			free(pThreadState->m_pSafetyPoolBuffer);
			pThreadState->m_pSafetyPoolBuffer = NULL;
		}
		else
		{
			BOOL bEnable = AfxEnableMemoryTracking(FALSE);
			_expand(pThreadState->m_pSafetyPoolBuffer,
				nOldBufferSize - (nSize + MIN_MALLOC_OVERHEAD));
			AfxEnableMemoryTracking(bEnable);
			TRACE(traceMemory, 0, "Warning: Shrinking safety pool from %d to %d to satisfy request of %d bytes.\n",
				 nOldBufferSize, _msize(pThreadState->m_pSafetyPoolBuffer), nSize);
		}
		return 1;       // retry it
	}

	TRACE(traceMemory, 0, "ERROR: Critical memory allocation from safety pool failed!\n");
	AfxThrowMemoryException();      // oops
}
#endif // !_AFX_PORTABLE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\winmenu.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Map from HMENU to CMenu *

CHandleMap* PASCAL afxMapHMENU(BOOL bCreate)
{
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	if (pState->m_pmapHMENU == NULL && bCreate)
	{
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
#ifndef _AFX_PORTABLE
		_PNH pnhOldHandler = AfxSetNewHandler(&AfxCriticalNewHandler);
#endif
		pState->m_pmapHMENU = new CHandleMap(RUNTIME_CLASS(CMenu),
			ConstructDestruct<CMenu>::Construct, ConstructDestruct<CMenu>::Destruct, 
			offsetof(CMenu, m_hMenu)),

#ifndef _AFX_PORTABLE
		AfxSetNewHandler(pnhOldHandler);
#endif
		AfxEnableMemoryTracking(bEnable);
	}
	return pState->m_pmapHMENU;
}

CMenu* PASCAL CMenu::FromHandle(HMENU hMenu)
{
	CHandleMap* pMap = afxMapHMENU(TRUE); // create map if not exist
	ASSERT(pMap != NULL);
	CMenu* pMenu = (CMenu*)pMap->FromHandle(hMenu);
	ASSERT(pMenu == NULL || pMenu->m_hMenu == hMenu);
	return pMenu;
}

CMenu* PASCAL CMenu::FromHandlePermanent(HMENU hMenu)
{
	CHandleMap* pMap = afxMapHMENU();
	CMenu* pMenu = NULL;
	if (pMap != NULL)
	{
		// only look in the permanent map - does no allocations
		pMenu = (CMenu*)pMap->LookupPermanent(hMenu);
		ASSERT(pMenu == NULL || pMenu->m_hMenu == hMenu);
	}
	return pMenu;
}

/////////////////////////////////////////////////////////////////////////////
// CMenu

#ifdef _DEBUG
void CMenu::AssertValid() const
{
	CObject::AssertValid();
	ASSERT(m_hMenu == NULL || ::IsMenu(m_hMenu));
}

void CMenu::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "m_hMenu = " << m_hMenu;
	dc << "\n";
}
#endif

BOOL CMenu::Attach(HMENU hMenu)
{
	ASSERT(m_hMenu == NULL);        // only attach once, detach on destroy
	if (hMenu == NULL)
	{
		return FALSE;
	}
    
	// Capture menu in object first to ensure it does not leak if the map cannot be allocated/expanded 
	m_hMenu=hMenu;

	CHandleMap* pMap = afxMapHMENU(TRUE); // create map if not exist
	ASSERT(pMap != NULL);
	pMap->SetPermanent(m_hMenu, this);
	return TRUE;
}

HMENU CMenu::Detach()
{
	HMENU hMenu;
	if ((hMenu = m_hMenu) != NULL)
	{
		CHandleMap* pMap = afxMapHMENU(); // don't create if not exist
		if (pMap != NULL)
			pMap->RemoveHandle(m_hMenu);
	}
	m_hMenu = NULL;
	return hMenu;
}

BOOL CMenu::DestroyMenu()
{
	if (m_hMenu == NULL)
		return FALSE;
	return ::DestroyMenu(Detach());
}

int CMenu::GetMenuString(UINT nIDItem, CString& rString, UINT nFlags) const
{
	ASSERT(::IsMenu(m_hMenu)); 

	// offer no buffer first
	int nStringLen = ::GetMenuString(m_hMenu, nIDItem, NULL, 0, nFlags);

	// use exact buffer length
	if (nStringLen > 0)
	{
		LPTSTR pstrString = rString.GetBufferSetLength(nStringLen+1);
		::GetMenuString(m_hMenu, nIDItem, pstrString, nStringLen+1, nFlags);
		rString.ReleaseBuffer();
	}
	else
		rString.Empty();

	return nStringLen;
}

/////////////////////////////////////////////////////////////////////////////
// Self-drawing menu items
void CMenu::DrawItem(LPDRAWITEMSTRUCT /*pdis*/)
{
	// default does nothing
}

void CMenu::MeasureItem(LPMEASUREITEMSTRUCT /*pmis*/)
{
	// default does nothing
}

CChevronOwnerDrawMenu::CChevronOwnerDrawMenu()
{
	struct AFX_OLDNONCLIENTMETRICS
	{
		UINT    cbSize;
		int     iBorderWidth;
		int     iScrollWidth;
		int     iScrollHeight;
		int     iCaptionWidth;
		int     iCaptionHeight;
		LOGFONT lfCaptionFont;
		int     iSmCaptionWidth;
		int     iSmCaptionHeight;
		LOGFONT lfSmCaptionFont;
		int     iMenuWidth;
		int     iMenuHeight;
		LOGFONT lfMenuFont;
		LOGFONT lfStatusFont;
		LOGFONT lfMessageFont;
	};

	const UINT cbProperSize = (_AfxGetComCtlVersion() < MAKELONG(1, 6))
		? sizeof(AFX_OLDNONCLIENTMETRICS) : sizeof(NONCLIENTMETRICS);

	NONCLIENTMETRICS NonClientMetrics;
	NonClientMetrics.cbSize = cbProperSize;

	::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, cbProperSize, &NonClientMetrics, 0);

	m_MenuFont.CreateFontIndirect(&NonClientMetrics.lfMenuFont);
}

void CChevronOwnerDrawMenu::DrawItem(LPDRAWITEMSTRUCT pdis)
{
	ASSERT(pdis->CtlType == ODT_MENU);

	CString strText(_T(""));
	CSize Size;   

	CDC *pDC;
	pDC = CDC::FromHandle(pdis->hDC);
	int nSave = pDC->SaveDC();
	
	// getting the text (on the right of the bitmap)
	MENUITEMINFO info;
	ZeroMemory(&info, sizeof(MENUITEMINFO));
	info.cbSize = sizeof(MENUITEMINFO);
	info.fMask = MIIM_STRING;
	BOOL bGotText = FALSE;
	if(GetMenuItemInfo(pdis->itemID, &info))
	{
		LPTSTR pszText;

		pszText = strText.GetBuffer(info.cch);
		info.dwTypeData = pszText;
		info.cch++; // space for zero terminator
		bGotText = GetMenuItemInfo(pdis->itemID, &info);
		strText.ReleaseBuffer();
	}

	CBitmap *pBmp;
	pBmp = (CBitmap *) pdis->itemData;

	// Find the rect that will center the bitmap in the menu item
	CRect rc, rcItem(pdis->rcItem);
	BOOL bGotBitmap = FALSE;
	int nBitmapHeight = 0;
	int nBitmapWidth = 0;
	if(pBmp && pBmp->IsKindOf(RUNTIME_CLASS(CBitmap)))
	{
		BITMAP bitmap;
		bGotBitmap = TRUE;
		pBmp->GetObject(sizeof(BITMAP), &bitmap);
		nBitmapHeight = bitmap.bmHeight;
		nBitmapWidth = bitmap.bmWidth;
	}
	else
	{
		// using default icon size
		bGotBitmap = FALSE;
		nBitmapHeight = ::GetSystemMetrics(SM_CYSMICON);
		nBitmapWidth = ::GetSystemMetrics(SM_CXSMICON);
	}
	rc.top = rcItem.Height() / 2 - nBitmapHeight / 2 + rcItem.top - 1;
	rc.left = 0;
	rc.right = nBitmapWidth + 1;
	rc.bottom = nBitmapHeight + 1;
	rc.bottom += rc.top;
	rc.right += rc.left;

	
	//the actual drawing begins
	COLORREF crMenu = ::GetSysColor(COLOR_MENU);
	CDC dcMem;
	dcMem.CreateCompatibleDC(NULL);

	pDC->SelectObject(&m_MenuFont);
	Size = pDC->GetTextExtent(strText);

	// Selected (possibly grayed)
	if(pdis->itemState & ODS_SELECTED)
	{
		// MenuColor
		CRect rcFill(pdis->rcItem);
		rcFill.left = rc.right + 2;
		pDC->FillSolidRect(rcFill, ::GetSysColor(COLOR_HIGHLIGHT));

		// if not grayed and not checked, raise the button
		if (bGotBitmap)
		{
			if(!(pdis->itemState & (ODS_GRAYED | ODS_CHECKED)))
			{
				pDC->Draw3dRect(rc.left, rc.top, rc.Width() + 1, rc.Height() + 1,
					::GetSysColor(COLOR_BTNHIGHLIGHT), ::GetSysColor(COLOR_BTNSHADOW));
			}
		}
		
		// Text
		if (bGotText)
		{
			pDC->SetBkColor(::GetSysColor(COLOR_HIGHLIGHT));
			pDC->SetTextColor(
				(pdis->itemState & ODS_GRAYED) ? crMenu : ::GetSysColor(COLOR_HIGHLIGHTTEXT));

			pDC->ExtTextOut(rc.right + 3, rc.top + rc.Height() / 2 - Size.cy / 2,
				ETO_OPAQUE, NULL, strText, NULL);
		}
	}
	else
	{
		pDC->FillSolidRect(&pdis->rcItem, crMenu);
		pDC->SetBkColor(crMenu);

		// Grayed (disabled)
		if(pdis->itemState & ODS_GRAYED)
		{
			pDC->SetTextColor(::GetSysColor(COLOR_3DHILIGHT));
			pDC->SetBkMode(TRANSPARENT);

			// Text
			if (bGotText)
			{
				pDC->ExtTextOut(rc.right + 4, rc.top + rc.Height() / 2 - Size.cy / 2 + 1, ETO_OPAQUE, NULL, strText, NULL);
				pDC->SetTextColor(::GetSysColor(COLOR_GRAYTEXT));
				pDC->ExtTextOut(rc.right + 3, rc.top + rc.Height() / 2 - Size.cy / 2, 0, NULL, strText, NULL);
			}
		}
		// Everything else
		else
		{
			// if checked draw as pushed
			if (bGotBitmap)
			{
				if(pdis->itemState & ODS_CHECKED)
				{
					pDC->Draw3dRect(rc.left, rc.top, rc.Width() + 1, rc.Height() + 1,
						::GetSysColor(COLOR_BTNSHADOW), ::GetSysColor(COLOR_BTNHIGHLIGHT));
				}
			}
			
			// text
			if (bGotText)
			{
				pDC->SetBkColor(crMenu);
				pDC->SetTextColor(::GetSysColor(COLOR_MENUTEXT));
				pDC->ExtTextOut(rc.right + 3, rc.top + rc.Height() / 2 - Size.cy / 2, ETO_OPAQUE, NULL, strText, NULL);
			}
		}
	}

	// The bitmap...
	if (bGotBitmap)
	{
		CBitmap bmp;
		int x = 0, y = 0;
		if(pdis->itemState & ODS_GRAYED)
		{
			::AfxGetGrayBitmap(*pBmp, &bmp, crMenu);
			pBmp = &bmp;
		}
		else
		{
			if(pdis->itemState & ODS_CHECKED)
			{
				::AfxGetDitheredBitmap(*pBmp, &bmp, crMenu, RGB(255, 255, 255));
				pBmp = &bmp;
			}
		}

		CDC dcMem;
		dcMem.CreateCompatibleDC(NULL);
		dcMem.SelectObject(pBmp);

		rc.InflateRect(-1, -1);

		pDC->BitBlt(rc.left, rc.top, rc.right, rc.bottom, &dcMem, x, y, SRCCOPY);
	}
	
	pDC->RestoreDC(nSave);
}

void CChevronOwnerDrawMenu::MeasureItem(LPMEASUREITEMSTRUCT pmis)
{
	// measuring the bitmp
	int nWidth =0;
	int nHeight =0;

	if(pmis->itemData)
	{
		CBitmap *pBmp = (CBitmap *) pmis->itemData;
		ASSERT_KINDOF(CBitmap, pBmp);

		BITMAP bitmap;
		
		pBmp->GetBitmap(&bitmap);
		
		// 2 pixel of padding
		nHeight=bitmap.bmHeight + 2;
		nWidth += bitmap.bmWidth+2;
	}
	else
	{
		// use the default size of the pixels
		// 2 pixel of padding
		nHeight = ::GetSystemMetrics(SM_CYSMICON) + 2;
		nWidth = ::GetSystemMetrics(SM_CXSMICON) + 2;
	}

	// measuring the text
	CString strText;
	LPTSTR pszText;
	MENUITEMINFO info;

	ZeroMemory(&info, sizeof(MENUITEMINFO));
	info.cbSize = sizeof(MENUITEMINFO);
	info.fMask = MIIM_STRING;
	if(GetMenuItemInfo(pmis->itemID, &info))
	{
		pszText = strText.GetBuffer(info.cch);
		info.dwTypeData = pszText;
		info.cch++;
		BOOL bCheck = GetMenuItemInfo(pmis->itemID, &info);
		strText.ReleaseBuffer();

		if(bCheck)
		{
			CWindowDC dc(NULL);

			CFont *pFont = dc.SelectObject(&m_MenuFont);
			CSize size = dc.GetTextExtent(strText);
			dc.SelectObject(pFont);

			// 1 pixel for gap, 2 for menu item = 3
			// (disregard checkmark gap)
			nWidth +=  size.cx + 3;
		}
	}

	//setting the info
	pmis->itemHeight= max(::GetSystemMetrics(SM_CYMENU), nHeight);
	pmis->itemWidth = nWidth;
}


IMPLEMENT_DYNCREATE(CMenu, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\mfcm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// mfcm.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <afxdllx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#ifdef _M_CEE
#error This file must not be built managed because it contains DllMain.
#endif

static AFX_EXTENSION_MODULE mfcmDLL = { NULL, NULL };
//Adds extension dll library item to linked list of current module state.
extern "C" void InitMfcmDll()
{
	new CDynLinkLibrary(mfcmDLL);
}

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	UNREFERENCED_PARAMETER(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		
		// Extension DLL one-time initialization
		if (!AfxInitExtensionModule(mfcmDLL, hInstance))
			return 0;

		InitMfcmDll();

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxTermExtensionModule(mfcmDLL);
	}
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\afxwfrmcmd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_WINFORMS_COMMAND_TARGET_INTERFACES_H__
#define __AFX_WINFORMS_COMMAND_TARGET_INTERFACES_H__
////////////////////////////////////////////////////////////////////////////////
// Implements the ICommandSource and ICommandUI interfaces for CWinFromsView
// WM_COMMAND Routing support.

/////////////////////////////////////////////////////////////////////////////
// CCommandSource - WinForms form hosted as MFC View uses a reference to an instance
// of CCommandSource to add and remove command handler, thus participating in MFC
// Command Routing mechanism
namespace Microsoft{
	namespace VisualC{
		namespace MFC{

public ref class CCommandSource : public ICommandSource
{
	ref struct Range
	{
		const unsigned int m_min;
		const unsigned int m_max;
		System::MulticastDelegate ^const m_pHandler;

		Range(unsigned int min, unsigned int max,
			System::MulticastDelegate ^ pHandler)
			: m_min(min), m_max(max), m_pHandler(pHandler) {}
	};

	ref struct ExactRange : public Range
	{
		ExactRange(unsigned int min, unsigned int max)
			: Range(min, max, nullptr) {}
		virtual bool Equals(Object ^o) override;	//used by IndexOf		
	};

	ref struct ContainedRange : public Range
	{
		ContainedRange(unsigned int id)
			: Range(id, id, nullptr) {}
		virtual bool Equals(Object ^o) override;	//used by IndexOf		
	};

	System::Collections::ArrayList ^m_alCmd;
	System::Collections::ArrayList ^m_alCmdUI;

	static System::MulticastDelegate^ FindHandler(System::Collections::ArrayList ^al, UINT nID);
	
public:
	CCommandSource();
	//Command Handlers
	virtual void AddCommandHandler(unsigned int cmdID, CommandHandler^ cmdHandler);	
	virtual void AddCommandRangeHandler(unsigned int cmdIDMin, unsigned int cmdIDMax, 
								CommandHandler^ cmdHandler);	
	virtual void RemoveCommandHandler(unsigned int cmdID);
	virtual void RemoveCommandRangeHandler(unsigned int cmdIDMin, unsigned int cmdIDMax);
	CommandHandler^ FindCommandHandler(UINT nID);
	//Update Command Handlers
	virtual void AddCommandUIHandler(unsigned int cmdID, CommandUIHandler^ cmdUIHandler);
	virtual void AddCommandRangeUIHandler(unsigned int cmdIDMin, unsigned int cmdIDMax, 
								  CommandUIHandler^ cmdUIHandler);
	virtual void RemoveCommandUIHandler(unsigned int cmdID);	
	virtual void RemoveCommandRangeUIHandler(unsigned int cmdIDMin, unsigned int cmdIDMax);	
	CommandUIHandler^ FindCommandUIHandler(UINT nID);	

	virtual void PostCommand(unsigned int command );	
	virtual void SendCommand(unsigned int command );	
};


/////////////////////////////////////////////////////////////////////////////
// CCmdUI wrapper
//
public ref class CCommandUI : public ICommandUI
{
	CCmdUI &m_CmdUI;
public:
	CCommandUI(CCmdUI &CmdUI) : m_CmdUI(CmdUI) {}

	virtual void ContinueRouting();	
	property bool  Enabled 
	{
		virtual void set(bool value);
	}
	property UICheckState Check
	{	
		virtual void set(UICheckState value);
	}
	property bool  Radio
	{
		virtual void set(bool value);
	}
	property System::String^  Text
	{
		virtual void set(System::String^ value);
	}
	property UINT  ID
	{
		virtual UINT get();
	}
	property UINT  Index
	{
		virtual UINT get();
	}				
	
};
		} //MFC
	} //VisualC
} //Microsoft

#endif //__AFX_WINFORMS_COMMAND_TARGET_INTERFACES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\amd64\inetcal_.s ===
; This is a part of the Microsoft Foundation Classes C++ library.
; Copyright (C) 1992-1997 Microsoft Corporation
; All rights reserved.
;
; This source code is only intended as a supplement to the
; Microsoft Foundation Classes Reference and related
; electronic documentation provided with the library.
; See these sources for detailed information regarding the
; Microsoft Foundation Classes product.

PUBLIC	_AfxParseCall

_TEXT	SEGMENT

; void AFXISAPI _AfxParseCall( AFX_PMSG pfn, void* pStack, UINT nSizeArgs )

_AfxParseCall PROC

	; at this point RCX contains value of pfn, RDX contains value of pArgs 
	; and R8 contains value of nSizeArgs.
	
	; get the return address
	mov rax, qword ptr [rsp]

	; save the return address
	mov qword ptr [rdx-8], rax

	; set the new stack pointer
	lea rsp, qword ptr [rdx-8]

	; save the pfn
	mov rax, rcx

	; set the first four float/double arguments
	movsd xmm0, qword ptr [rdx]
	movsd xmm1, qword ptr [rdx+8]
	movsd xmm2, qword ptr [rdx+16]
	movsd xmm3, qword ptr [rdx+24]

	; set the first four integer arguments [except for RDX]
	mov rcx, qword ptr [rdx]
	mov r8,  qword ptr [rdx+16]
	mov r9,  qword ptr [rdx+24]

	; Finally load up RDX
	mov rdx, qword ptr [rdx+8]

	; jump to the function
	jmp rax

_AfxParseCall ENDP

_TEXT	ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\postdllmain.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Helper class to initialize a user dll compiler managed (_M_CEE defined).
// Used in afxdisp.h (check the pragma include).
// This helper code is added to the mfcmXX* import library.

// Note: This file may not contain any inclusion of or reference to any WIN32 or AFX types
// lest we get metadata mismatches when the user sets WIN32_WINNT differently.

/* redeclare here to avoid including any afx or windows headers */
#ifndef AFXAPI
#define AFXAPI __stdcall
#endif

#ifndef WINAPI
#define WINAPI __stdcall
#endif

#ifndef WINBASEAPI
#define WINBASEAPI __declspec(dllimport)
#endif

#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;

#define DLL_PROCESS_ATTACH   1    
#define DLL_PROCESS_DETACH   0    

typedef int BOOL;

__declspec(dllimport) BOOL AFXAPI AfxIsModuleDll();
__declspec(dllimport) BOOL AFXAPI AfxInitCurrentStateApp();

extern "C"
{
	BOOL WINAPI InternalDllMain(HINSTANCE hInstance, unsigned int dwReason, void *lpReserved);
}

__declspec(dllimport) HINSTANCE AFXAPI AfxGetInstanceHandleHelper();

class PostDllMain
{
public:
	PostDllMain(): m_bDLL(0)
	{
		// check if we are in a dll
		m_bDLL = AfxIsModuleDll();
		m_hInstance = AfxGetInstanceHandleHelper();

		if (m_bDLL)
		{
			InternalDllMain(m_hInstance, DLL_PROCESS_ATTACH, 0);
		}
	}

	~PostDllMain()
	{
		if (m_bDLL)
		{
			InternalDllMain(m_hInstance, DLL_PROCESS_DETACH, 0);
		}
	}

private:
	BOOL m_bDLL;  // TRUE if module is a DLL, FALSE if it is an EXE (from AFX_MODULE_STATE)
	HINSTANCE m_hInstance;
};

#pragma warning(push)
#pragma warning(disable:4378)
#pragma init_seg(".CRTMP$XCY")
#pragma warning(pop)

const PostDllMain postDllMain;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\amd64\olecall_.s ===
; This is a part of the Microsoft Foundation Classes C++ library.
; Copyright (C) 1992-1997 Microsoft Corporation
; All rights reserved.
;
; This source code is only intended as a supplement to the
; Microsoft Foundation Classes Reference and related
; electronic documentation provided with the library.
; See these sources for detailed information regarding the
; Microsoft Foundation Classes product.

PUBLIC	_AfxDispatchCall

_TEXT	SEGMENT

;_AfxDispatchCall(AFX_PMSG /*pfn*/, void* /*pArgs*/, UINT /*nSizeArgs*/)

_AfxDispatchCall PROC

	; at this point RCX contains value of pfn, RDX contains value of pArgs 
	; and R8 contains value of nSizeArgs.
	
	; get the return address
	mov rax, qword ptr [rsp]

	; save the return address
	mov qword ptr [rdx-8], rax

	; set the new stack pointer
	lea rsp, qword ptr [rdx-8]

	; save the pfn
	mov rax, rcx

	; set the first four float/double arguments
	movsd xmm0, qword ptr [rdx]
	movsd xmm1, qword ptr [rdx+8]
	movsd xmm2, qword ptr [rdx+16]
	movsd xmm3, qword ptr [rdx+24]

	; set the first four integer arguments [except for RDX]
	mov rcx, qword ptr [rdx]
	mov r8,  qword ptr [rdx+16]
	mov r9,  qword ptr [rdx+24]

	; Finally load up RDX
	mov rdx, qword ptr [rdx+8]

	; jump to the function
	jmp rax

_AfxDispatchCall ENDP

_TEXT	ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\afxwfrminl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifndef _AFX_ENABLE_INLINES

#define _AFXWIN_INLINE
#include <afxwinforms.inl>

#endif //!_AFX_ENABLE_INLINES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\postrawdllmain.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Helper class to initialize a user dll compiler managed (_M_CEE defined).
// Used in afxdisp.h (check the pragma include).
// This helper code is added to the mfcmXX* import library.

// Note: This file may not contain any inclusion of or reference to any WIN32 or AFX types
// lest we get metadata mismatches when the user sets WIN32_WINNT differently.

/* redeclare here to avoid including any afx or windows headers */
#ifndef AFXAPI
#define AFXAPI __stdcall
#endif

#ifndef WINAPI
#define WINAPI __stdcall
#endif

#ifndef WINBASEAPI
#define WINBASEAPI __declspec(dllimport)
#endif

#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;

#define DLL_PROCESS_ATTACH   1    
#define DLL_PROCESS_DETACH   0    

typedef int BOOL;

extern "C"
{
	BOOL WINAPI RawDllMain(HINSTANCE hInstance, unsigned int dwReason, void *lpReserved);
}

class PostRawDllMain
{
public:
	PostRawDllMain()
	{
		RawDllMain(0, DLL_PROCESS_ATTACH, 0);
	}

	~PostRawDllMain()
	{
		RawDllMain(0, DLL_PROCESS_DETACH, 0);
	}
};

#pragma warning(push)
#pragma warning(disable:4378)
#pragma const_seg(".CRTMA$XCB")
#pragma init_seg(".CRTMP$XCB")
#pragma warning(pop)

const PostRawDllMain postRawDllMain;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\stdafx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// stdafx.cpp : source file that includes just the standard includes
// mfcmXX.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\interfaces\stdafx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\interfaces\mfcm80.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#using <mscorlib.dll>
#using <system.dll>


using namespace System;
using namespace System::ComponentModel;


namespace Microsoft{
	namespace VisualC{
		namespace MFC{
			public interface class IView
			{
				void OnInitialUpdate();
				void OnUpdate();
				void OnActivateView(bool activate);
				
			};
			//public enum UICheckState : byte { Unchecked, Checked, Indeterminate };
			public enum class UICheckState
			{
				[DefaultValue(Microsoft::VisualC::MFC::UICheckState::typeid, "Checked")]
				Unchecked, 
					Checked, 
					Indeterminate 
			};

			public interface class ICommandUI
			{
				void ContinueRouting();
				property bool  Enabled 
				{
					void set(bool value);
				}
				property UICheckState Check
				{	
					void set(UICheckState value);
				}
				property bool  Radio
				{
					void set(bool value);
				}
				property String^  Text
				{
					void set(String^ value);
				}
				property unsigned int  ID
				{
					unsigned int get();
				}
				property unsigned int  Index
				{
					unsigned int get();
				}				
			};

			public delegate void CommandHandler(unsigned int cmdID);
			public delegate void CommandUIHandler(unsigned int cmdID, ICommandUI^ cmdUI);

			public interface class ICommandSource
			{
				void AddCommandHandler(unsigned int cmdID, CommandHandler^ cmdHandler);
				void AddCommandRangeHandler(unsigned int cmdIDMin, unsigned int cmdIDMax, CommandHandler^ cmdHandler);
				void RemoveCommandHandler(unsigned int cmdID);
				void RemoveCommandRangeHandler(unsigned int cmdIDMin, unsigned int cmdIDMax);

				void AddCommandUIHandler(unsigned int cmdID, CommandUIHandler^ cmdUIHandler);
				void AddCommandRangeUIHandler(unsigned int cmdIDMin, unsigned int cmdIDMax, CommandUIHandler^ cmdUIHandler);
				void RemoveCommandUIHandler(unsigned int cmdID);
				void RemoveCommandRangeUIHandler(unsigned int cmdIDMin, unsigned int cmdIDMax);

				void PostCommand(unsigned int command );
				void SendCommand(unsigned int command);
			};

			public  interface class ICommandTarget
			{
				void Initialize(ICommandSource^ cmdSource);
			};


		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\wfrmcmd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxwfrmcmd.h"

namespace Microsoft {
	namespace VisualC {
			namespace MFC {

//////////////////////////////////////////////////////////////////////////
//CCommandSource
//

System::MulticastDelegate ^ CCommandSource::FindHandler(System::Collections::ArrayList ^al, UINT nID)
{
	int i = 0;
	System::Collections::IEnumerator^ cmdEnum = al->GetEnumerator();
	while ( cmdEnum->MoveNext() )
	{
		Range ^r = safe_cast<Range^>(cmdEnum->Current);
		if ( r->m_min <= nID && r->m_max >= nID )
		{
			return safe_cast<Range^>(al[i])->m_pHandler;
		}
		i++;
	}
	return nullptr;
}

bool CCommandSource::ExactRange::Equals(Object ^o)	//used by IndexOf
{
	Range ^r = safe_cast <Range^>(o);
	return m_min == r->m_min && m_max == r->m_max;
}

bool CCommandSource::ContainedRange::Equals(Object ^o)	//used by IndexOf
{
	Range ^r = safe_cast<Range^>(o);
	return m_min >= r->m_min && m_min <= r->m_max;
}

CCommandSource::CCommandSource()
{
	m_alCmd = gcnew System::Collections::ArrayList;
	m_alCmdUI = gcnew System::Collections::ArrayList;
}

void CCommandSource::AddCommandHandler(unsigned int cmdID, CommandHandler^ cmdHandler)
{
	ENSURE_ARG(cmdHandler!=nullptr);
	m_alCmd->Add(gcnew Range(cmdID, cmdID, cmdHandler));
}

void CCommandSource::AddCommandRangeHandler(unsigned int cmdIDMin, unsigned int cmdIDMax, 
								CommandHandler^ cmdHandler)
{
	ENSURE_ARG(cmdHandler!=nullptr);
	m_alCmd->Add(gcnew Range(cmdIDMin, cmdIDMax, cmdHandler));
}

void CCommandSource::RemoveCommandHandler(unsigned int cmdID)
{
	int i = 0;
	System::Collections::IEnumerator^ cmdEnum = m_alCmd->GetEnumerator();
	while ( cmdEnum->MoveNext() )
	{
		Range ^r = safe_cast<Range^>(cmdEnum->Current);
		if ( r->m_min == cmdID )
		{
			break;
		}
		i++;
	}
	m_alCmd->RemoveAt(i);
}

void CCommandSource::RemoveCommandRangeHandler(unsigned int cmdIDMin, unsigned int cmdIDMax)
{
	int i = 0;
	System::Collections::IEnumerator^ cmdEnum = m_alCmd->GetEnumerator();
	while ( cmdEnum->MoveNext() )
	{
		Range ^r = safe_cast<Range^>(cmdEnum->Current);
		if ( r->m_min == cmdIDMin && r->m_max == cmdIDMax )
		{
			break;
		}
		i++;
	}
	m_alCmd->RemoveAt(i);
}

void CCommandSource::AddCommandUIHandler(unsigned int cmdID, CommandUIHandler^ cmdUIHandler)
{
	ENSURE_ARG(cmdUIHandler!=nullptr);
	m_alCmdUI->Add(gcnew Range(cmdID, cmdID, cmdUIHandler));
}
void CCommandSource::AddCommandRangeUIHandler(unsigned int cmdIDMin, unsigned int cmdIDMax, 
							  CommandUIHandler^ cmdUIHandler)
{
	ENSURE_ARG(cmdUIHandler!=nullptr);
	m_alCmdUI->Add(gcnew Range(cmdIDMin, cmdIDMax, cmdUIHandler));
}
void CCommandSource::RemoveCommandUIHandler(unsigned int cmdID)
{
	int i = 0;
	System::Collections::IEnumerator^ cmdEnum = m_alCmdUI->GetEnumerator();
	while ( cmdEnum->MoveNext() )
	{
		Range ^r = safe_cast<Range^>(cmdEnum->Current);
		if ( r->m_min == cmdID )
		{
			break;
		}
		i++;
	}
	m_alCmdUI->RemoveAt(i);
}

void CCommandSource::RemoveCommandRangeUIHandler(unsigned int cmdIDMin, unsigned int cmdIDMax)
{
	int i = 0;
	System::Collections::IEnumerator^ cmdEnum = m_alCmdUI->GetEnumerator();
	while ( cmdEnum->MoveNext() )
	{
		Range ^r = safe_cast<Range^>(cmdEnum->Current);
		if ( r->m_min == cmdIDMin && r->m_max == cmdIDMax )
		{
			break;
		}
		i++;
	}
	m_alCmdUI->RemoveAt(i);
}

void CCommandSource::PostCommand(unsigned int command )
{
	AfxGetMainWnd()->PostMessage(WM_COMMAND, command);
}
void CCommandSource::SendCommand(unsigned int command )
{
	AfxGetMainWnd()->SendMessage(WM_COMMAND, command);
}

CommandHandler^ CCommandSource::FindCommandHandler(UINT nID)
{
	return safe_cast<CommandHandler^>(FindHandler(m_alCmd, nID));
}

CommandUIHandler^ CCommandSource::FindCommandUIHandler(UINT nID)
{
	return safe_cast<CommandUIHandler^>(FindHandler(m_alCmdUI, nID));
}

/////////////////////////////////////////////////////////////////////////////
// CCommandUI
//
void CCommandUI::ContinueRouting()
{
	m_CmdUI.ContinueRouting();
}

void CCommandUI::Enabled::set(bool bOn)
{
	m_CmdUI.Enable(bOn);
}
void CCommandUI::Check::set(UICheckState Check)
{
	m_CmdUI.SetCheck((System::Int32)Check);
}
void CCommandUI::Radio::set(bool bOn)
{
	m_CmdUI.SetRadio(bOn);
}
void CCommandUI::Text::set(System::String ^text)
{
	m_CmdUI.SetText(CString(text));
}
unsigned int CCommandUI::ID::get()
{
	return m_CmdUI.m_nID;
}
unsigned int CCommandUI::Index::get()
{
	return m_CmdUI.m_nIndex;
}
		} //MFC
	} //VisualC
} //Microsoft

// Calling this function ensures that managed code is executed in this module
// This in turn ensures that the module constructor (.cctor) is executed and global
// objects are correctly initialized.
extern "C" void AfxmEnsureManagedInitialization()
{
    // Just need some cheap managed code that won't be optimized away
    System::GC::KeepAlive(System::Int32::MaxValue);
}

// Calling this function ensures that all managed references to the specified
// object are released.
extern "C" void AfxmReleaseManagedReferences(IUnknown* pIUnknown)
{
	System::IntPtr pUnknAsInt = static_cast<System::IntPtr>(pIUnknown);
	System::Object^ oManagedWrapper = System::Runtime::InteropServices::Marshal::GetObjectForIUnknown( pUnknAsInt );
	while( System::Runtime::InteropServices::Marshal::ReleaseComObject( oManagedWrapper ) );
}

/////////////////////////////////////////////////////////////////////////////
// Assembly Information

#include <atlbuild.h>

using namespace System::Reflection;

#ifdef BUILD_PREBUILT

// TEMP (alecont)
#define _MFC_FILENAME_VER_DOT "9.0"

[assembly: AssemblyTitle("mfcm" _MFC_FILENAME_VER)];
[assembly: AssemblyDescription("MFC " _MFC_FILENAME_VER_DOT " Managed Interoperability")];
[assembly: AssemblyConfiguration("")];
[assembly: AssemblyCompany("Microsoft")];
[assembly: AssemblyProduct("Visual Studio 9.0")];
[assembly: AssemblyCopyright("Microsoft Corporation")];
[assembly: AssemblyTrademark("")];
[assembly: AssemblyCulture("")];

[assembly: AssemblyVersion(_LIBS_USER_FULL_VER)];

[assembly: AssemblyDelaySign(true)];
[assembly: AssemblyKeyFile("..\\finalpublickey.snk")];
[assembly: AssemblyKeyName("")];

#else

#error Following information required to build private version


[assembly: AssemblyTitle("")];
[assembly: AssemblyDescription("MFC " "9.0" " Managed Interoperability")];
[assembly: AssemblyConfiguration("")];
[assembly: AssemblyCompany("")];
[assembly: AssemblyProduct("")];
[assembly: AssemblyCopyright("")];
[assembly: AssemblyTrademark("")];
[assembly: AssemblyCulture("")];

[assembly: AssemblyVersion("1.0.0.0")];

[assembly: AssemblyDelaySign(true)];
[assembly: AssemblyKeyFile("")];
[assembly: AssemblyKeyName("")];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\wfrmsite.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

namespace Microsoft {
	namespace VisualC {
			namespace MFC {

//////////////////////////////////////////////////////////////////////////
//CWinFormsControlSite
//

HRESULT CWinFormsControlSite::DoVerb(LONG nVerb, LPMSG lpMsg)
{
	HRESULT hr=S_OK;
	switch(nVerb)
	{
		case OLEIVERB_SHOW:
			get_Control()->Visible = true;
			break;
		case OLEIVERB_HIDE:
			get_Control()->Visible = false;
			break;
		default:
			hr=__super::DoVerb(nVerb, lpMsg);
	} //End switch
	return hr;
}

HRESULT CWinFormsControlSite::CreateOrLoad(const CControlCreationInfo& creationInfo)
{
	typedef System::Runtime::InteropServices::GCHandle GCHandle;
	HRESULT hr=E_FAIL;
	//Create an instance of the managed object and set the m_gcEventHelper
	//to reference it and hook HWND related events.
	ASSERT(creationInfo.IsManaged());
	System::Windows::Forms::Control^ pControl=nullptr;
	if (creationInfo.m_hk == CControlCreationInfo::ReflectionType)
	{
		System::Type^ pType=safe_cast<System::Type^>( (GCHandle::operator GCHandle(System::IntPtr(creationInfo.m_nHandle))).Target );
		System::Object^ pObj = System::Activator::CreateInstance(pType);		
		pControl=safe_cast<System::Windows::Forms::Control^>(pObj);
		
	} else if (creationInfo.m_hk == CControlCreationInfo::ControlInstance)
	{
			pControl=safe_cast<System::Windows::Forms::Control^>( (GCHandle::operator GCHandle(System::IntPtr(creationInfo.m_nHandle))).Target );
	}

	if (pControl!=nullptr)
	{
		m_gcEventHelper->Control::set( pControl );
		//Marshal the control into IUnknown for usage of MFC Native ActiveX code.
		System::IntPtr pUnknAsInt = System::Runtime::InteropServices::Marshal::GetIUnknownForObject(get_Control());
		IUnknown* pUnkn = static_cast<IUnknown*>(pUnknAsInt.ToPointer());
		if (pUnkn!=NULL)
		{
			hr=pUnkn->QueryInterface(IID_IOleObject, (void**)&m_pObject);
			System::Runtime::InteropServices::Marshal::Release(pUnknAsInt);
		}
		if (SUCCEEDED(hr))
		{   //Now that m_pObject is set, call the original CreateOrLoad method.
			hr=__super::CreateOrLoad(GUID_NULL, NULL,FALSE, NULL);
		}
	}
	return hr;		
}


HRESULT CWinFormsControlSite::CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,const CControlCreationInfo& creationInfo,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize, UINT nID,
		CFile* pPersist, BOOL bStorage, BSTR bstrLicKey)
{
	HRESULT hr=COleControlSite::CreateControlCommon(pWndCtrl, clsid,creationInfo,
								  				lpszWindowName, dwStyle, ppt, 
												psize, nID, pPersist, bStorage, bstrLicKey);
	if (SUCCEEDED(hr))
	{
		get_Control()->TabStop = m_dwStyle & WS_TABSTOP ? true : false;	
	}
	return hr;
}

void CWinFormsControlSite::GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const
{
	switch(dwDispID)
	{
	case DISPID_ENABLED:
		ENSURE_ARG(vtProp==VT_BOOL);
		ENSURE_ARG(pvProp!=NULL);
		*(bool*)pvProp = get_Control()->Enabled;
		break;		
	default:
		__super::GetProperty(dwDispID, vtProp, pvProp);
	}		
}

#pragma warning( push )
#pragma warning( disable : 4793 )

void CWinFormsControlSite::SetPropertyV(DISPID dwDispID, VARTYPE vtProp, va_list argList)
{
	switch(dwDispID)
	{
		case DISPID_ENABLED:
		{
			ENSURE(vtProp==VT_BOOL);
			BOOL bEnable=va_arg(argList, BOOL);
			SetControlEnabled(bEnable ? true : false);
			break;		
		}
	default:
		__super::SetPropertyV(dwDispID, vtProp, argList);

	}		
}

#pragma warning( pop )

DWORD CWinFormsControlSite::GetStyle() const
{
	DWORD dwStyle = __super::GetStyle();		
	dwStyle = get_Control()->Visible ? dwStyle | WS_VISIBLE : dwStyle & ~WS_VISIBLE;
	dwStyle = get_Control()->TabStop ? dwStyle | WS_TABSTOP : dwStyle & ~WS_TABSTOP;
	return dwStyle;
}

void CWinFormsControlSite::OnHandleCreatedHandler()
{
		AttachWindow();			
	//Fix Z-order after WinForms ReCreate a control (Ex: Button style changed).
	//First find current site in the list, and then
	//iterate backward, until a valid hWnd is found. Insert the recreated control
	//in the correct Win32 z-order pos - after the found hWnd.
	COleControlSiteOrWnd *pSiteOrWnd = NULL,*pPrevZorderSiteWnd=NULL;		
	ENSURE(m_pCtrlCont != NULL);
	POSITION currentPos = NULL;
	POSITION pos = m_pCtrlCont->m_listSitesOrWnds.GetHeadPosition();
	BOOL bFoundSelf=FALSE;
	while(pos)
	{
		currentPos = pos;
		pSiteOrWnd = m_pCtrlCont->m_listSitesOrWnds.GetNext(pos);
		if (pSiteOrWnd && pSiteOrWnd->m_pSite == this)
		{
			bFoundSelf = TRUE;
			break;
		}

	}//End while(pos)

	//Move backward to find valid hWnd to insert after in Z-order.
	if (bFoundSelf)
	{
		m_pCtrlCont->m_listSitesOrWnds.GetPrev(currentPos);

		HWND hWndBeforeInOrder = NULL;				
		while(currentPos)
		{
			pPrevZorderSiteWnd = m_pCtrlCont->m_listSitesOrWnds.GetPrev(currentPos);
			if (pPrevZorderSiteWnd)
			{ 							
				if (pPrevZorderSiteWnd->m_hWnd!=NULL)
				{
					hWndBeforeInOrder = pPrevZorderSiteWnd->m_hWnd;
				} else if (pPrevZorderSiteWnd->m_pSite && pPrevZorderSiteWnd->m_pSite->m_hWnd!=NULL)
				{
					hWndBeforeInOrder=pPrevZorderSiteWnd->m_pSite->m_hWnd;
				}

				if (hWndBeforeInOrder!=NULL)
				{								
					break;
				}
			}
		}//End while(currentPos)

		if (hWndBeforeInOrder == NULL)
		{
			//If first on z-order, there is no valid hWnd in the m_listSitesOrWnds before
			//this control.
			hWndBeforeInOrder = HWND_TOP;
		}
		BOOL ok=::SetWindowPos(m_hWnd, hWndBeforeInOrder, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
		ASSERT(ok);

	} //End if (bFoundSelf)
}

void CWinFormsControlSite::OnHandleCreated( gcroot<System::Object^> , gcroot<System::EventArgs^> )
{					
	OnHandleCreatedHandler();
}


class CWinFormsControlSiteFactory : public IControlSiteFactory
{
public:
	CWinFormsControlSiteFactory() { }
	COleControlSite* CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo)
	{
		COleControlSite* pSite=NULL;
		if (InlineIsEqualGUID(creationInfo.m_clsid , CLSID_WinFormsControl))
		{		
			pSite=new CWinFormsControlSite(pCtrlCont);
		}
		return pSite;
	}	

};


struct CRegisterWinFormsFactory
{
	IControlSiteFactory* m_pFactory;
	CRegisterWinFormsFactory()
	{				
		m_pFactory=new CWinFormsControlSiteFactory();
		AfxRegisterSiteFactory(m_pFactory);
	}
	~CRegisterWinFormsFactory()
	{		
		delete m_pFactory;
	}
};

//Register our WinForms control site factory
extern "C" {  CRegisterWinFormsFactory g_registerWinFormsFactory; }

#if defined(_M_IX86)
#pragma comment(linker, "/INCLUDE:_g_registerWinFormsFactory")
#elif defined(_M_AMD64)
#pragma comment(linker, "/INCLUDE:g_registerWinFormsFactory")
#else
#pragma message("Unknown platform.  Make sure the linker includes g_registerWinFormsFactory")
#endif





		} //MFC
	} //VisualC
} //Microsoft
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\interfaces\mfcm80.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// mfcm80ifaces.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "mfcm80.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\interfaces\AssemblyInfo.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#using <mscorlib.dll>
#using <System.dll>



using namespace System::Reflection;

#ifdef BUILD_PREBUILT
//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("mfcm80ifaces")];
[assembly: AssemblyDescription("MFC interoperability")];
[assembly: AssemblyConfiguration("")];
[assembly: AssemblyCompany("Microsoft")];
[assembly: AssemblyProduct("MFC")];
[assembly: AssemblyCopyright("")];
[assembly: AssemblyTrademark("")];
[assembly: AssemblyCulture("")];

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.0.0")];

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(true)];
[assembly: AssemblyKeyFile("finalpublickey.snk")];
[assembly: AssemblyKeyName("")];
#else

#error Following information required to build private version

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")];
[assembly: AssemblyDescription("MFC interoperability")];
[assembly: AssemblyConfiguration("")];
[assembly: AssemblyCompany("")];
[assembly: AssemblyProduct("")];
[assembly: AssemblyCopyright("")];
[assembly: AssemblyTrademark("")];
[assembly: AssemblyCulture("")];

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.0.0")];

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(true)];
[assembly: AssemblyKeyFile("")];
[assembly: AssemblyKeyName("")];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// STDAFX.H is the header that includes the standard includes that are used
//  for most of the project.  These are compiled into a pre-compiled header

#pragma once

#include <winsdkver.h>

#undef _WIN32_WINNT
#define _WIN32_WINNT _WIN32_WINNT_MAXVER

#include <sdkddkver.h>

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#endif

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes

#if defined(_M_CEE)
#include <afxwinforms.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\wfrmview.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxwfrmcmd.h>

namespace Microsoft{
	namespace VisualC{
		namespace MFC {


IMPLEMENT_DYNAMIC(CWinFormsView,CView)

BEGIN_MESSAGE_MAP(CWinFormsView,CView)
	ON_WM_SIZE()
END_MESSAGE_MAP()

void CWinFormsView::OnInitialUpdate()
{
	System::Windows::Forms::ScrollableControl ^scrlCtrl = dynamic_cast<System::Windows::Forms::ScrollableControl^>(GetControl());
	if (scrlCtrl != nullptr)
	{	
		CRect rcView;
		GetClientRect(&rcView);
		System::Drawing::Size size(rcView.Width(),rcView.Height());
		scrlCtrl->AutoScrollMinSize = size;			
		scrlCtrl->AutoScroll = true;
	}

	IView ^pIView = dynamic_cast<IView^>(GetControl());
	if (pIView != nullptr)
	{
		pIView->OnInitialUpdate();
	}

	__super::OnInitialUpdate();
}


BOOL CWinFormsView::OnCmdMsg(UINT nID, int nCode, void* pExtra,
						AFX_CMDHANDLERINFO* pHandlerInfo)
{
	System::Object^ p=static_cast<System::Object^>(m_CmdSource);
	if (p!=nullptr)
	{		
		CCommandSource^ pCmdSource = safe_cast<CCommandSource^>(p);
		if (nCode == CN_UPDATE_COMMAND_UI)
		{
			CommandUIHandler^ handler = pCmdSource->FindCommandUIHandler(nID);

			if (handler)
			{
				ENSURE_ARG(pExtra != NULL);
				CCmdUI &cmdUIMFC = *(CCmdUI*)pExtra;
				ASSERT(!cmdUIMFC.m_bContinueRouting);    // idle - not set
				CCommandUI^ cmdUI = gcnew CCommandUI(cmdUIMFC);
				handler->Invoke(nID, cmdUI);
				BOOL bResult = !cmdUIMFC.m_bContinueRouting;
				cmdUIMFC.m_bContinueRouting = FALSE;

				return bResult;
			}
		}
		else
			if (nCode == CN_COMMAND)
			{

				CommandHandler^ handler = pCmdSource->FindCommandHandler(nID);
				if (handler)
				{
					if (pHandlerInfo == NULL)
					{
						handler->Invoke(nID);
					}
					else
					{
						//
						// ensure the menu entry is enabled
						//
						pHandlerInfo->pTarget = NULL; //we don't have target
						pHandlerInfo->pmf = NULL;    // and pfnHandler
					}
					return TRUE;
				}
			}
	}

	return __super::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}


BOOL CWinFormsView::Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext)
{
	m_nFlags |= WF_ISWINFORMSVIEWWND;
	BOOL fSucceeded=__super::Create(lpszClassName, lpszWindowName, dwStyle, rect,pParentWnd, nID, pContext);
	ASSERT(fSucceeded);
	fSucceeded=fSucceeded && m_control.CreateManagedControl(m_pManagedViewType,WS_VISIBLE, rect, this,nID);
	ASSERT(fSucceeded);	
	if(fSucceeded)
	{
		ICommandTarget^ pICmdTarget = dynamic_cast<ICommandTarget^>(GetControl());
		if (pICmdTarget)
		{
			CCommandSource^ p=gcnew CCommandSource;
			m_CmdSource = p;		
			pICmdTarget->Initialize(p);
		}
	}
	return fSucceeded;
}

void CWinFormsView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
	IView ^pIView = dynamic_cast<IView^>(GetControl());
	if (pIView != nullptr)
	{
		pIView->OnUpdate();
	}
	__super::OnUpdate(pSender, lHint, pHint);
}

void CWinFormsView::OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView)
{
	IView ^pIView = dynamic_cast<IView^>(GetControl());
			
	if (pIView != nullptr)
	{
		pIView->OnActivateView(bActivate ? true : false);
	}
	__super::OnActivateView(bActivate, pActivateView,
		pDeactiveView);
}	

BOOL CWinFormsView::PreTranslateMessage(MSG* pMsg)
{
	ASSERT(pMsg != NULL);
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);

	// allow tooltip messages to be filtered
	if (__super::PreTranslateMessage(pMsg))
		return TRUE;

	// don't translate dialog messages when in Shift+F1 help mode
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	if (pFrameWnd != NULL && pFrameWnd->m_bHelpMode)
		return FALSE;

	// since 'IsDialogMessage' will eat frame window accelerators,
	//   we call all frame windows' PreTranslateMessage first
	pFrameWnd = GetParentFrame();   // start with first parent frame
	while (pFrameWnd != NULL)
	{
		// allow owner & frames to translate before IsDialogMessage does
		if (pFrameWnd->PreTranslateMessage(pMsg))
			return TRUE;

		// try parent frames until there are no parent frames
		pFrameWnd = pFrameWnd->GetParentFrame();
	}

	// don't call IsDialogMessage if form is empty
	if (::GetWindow(m_hWnd, GW_CHILD) == NULL)
		return FALSE;

	// filter both messages to dialog and from children
	return PreTranslateInput(pMsg);
}

BOOL CWinFormsView::PreCreateWindow(CREATESTRUCT& cs)
{
	BOOL bRet = __super::PreCreateWindow(cs);
	cs.style |= WS_CLIPCHILDREN;
	return bRet;
}

void CWinFormsView::OnSize(UINT nType, int cx, int cy)
{		
	__super::OnSize(nType, cx, cy);

	//When view size changes, adjust the WinForms control (which is child of the view) 
	//size to occupy the entire client area of the view.
	CRect rcView;
	GetClientRect(&rcView);
	System::Drawing::Size size(rcView.Width(), rcView.Height());

	if (GetControl()!=nullptr)
	{
		GetControl()->Size = size;
	}

}

		} //MFC
	} //VisualC
} //Microsoft
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfcm\interfaces\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\abort.c ===
/***
*abort.c - abort a program by raising SIGABRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines abort() - print a message and raise SIGABRT.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <internal.h>
#include <rterr.h>
#include <signal.h>
#include <oscalls.h>
#include <mtdll.h>
#include <dbgint.h>

#ifdef _DEBUG
#define _INIT_ABORT_BEHAVIOR _WRITE_ABORT_MSG
#else  /* _DEBUG */
#define _INIT_ABORT_BEHAVIOR _CALL_REPORTFAULT
#endif  /* _DEBUG */

unsigned int __abort_behavior = _INIT_ABORT_BEHAVIOR;

/***
*void abort() - abort the current program by raising SIGABRT
*
*Purpose:
*   print out an abort message and raise the SIGABRT signal.  If the user
*   hasn't defined an abort handler routine, terminate the program
*   with exit status of 3 without cleaning up.
*
*   Multi-thread version does not raise SIGABRT -- this isn't supported
*   under multi-thread.
*
*Entry:
*   None.
*
*Exit:
*   Does not return.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl abort (
        void
        )
{
    _PHNDLR sigabrt_act = SIG_DFL;

#ifdef _DEBUG
    if (__abort_behavior & _WRITE_ABORT_MSG)
    {
        /* write the abort message */
        _NMSG_WRITE(_RT_ABORT);
    }
#endif  /* _DEBUG */


    /* Check if the user installed a handler for SIGABRT.
     * We need to read the user handler atomically in the case
     * another thread is aborting while we change the signal
     * handler.
     */
    sigabrt_act = __get_sigabrt();
    if (sigabrt_act != SIG_DFL)
    {
        raise(SIGABRT);
    }

    /* If there is no user handler for SIGABRT or if the user
     * handler returns, then exit from the program anyway
     */

    if (__abort_behavior & _CALL_REPORTFAULT)
    {
        _call_reportfault(_CRT_DEBUGGER_ABORT, STATUS_FATAL_APP_EXIT, EXCEPTION_NONCONTINUABLE);
    }


    /* If we don't want to call ReportFault, then we call _exit(3), which is the
     * same as invoking the default handler for SIGABRT
     */


    _exit(3);
}

/***
*unsigned int _set_abort_behavior(unsigned int, unsigned int) - set the behavior on abort
*
*Purpose:
*
*Entry:
*   unsigned int flags - the flags we want to set
*   unsigned int mask - mask the flag values
*
*Exit:
*   Return the old behavior flags
*
*Exceptions:
*   None
*
*******************************************************************************/

unsigned int __cdecl _set_abort_behavior(unsigned int flags, unsigned int mask)
{
    unsigned int oldflags = __abort_behavior;
    __abort_behavior = oldflags & (~mask) | flags & mask;
    return oldflags;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\align.h ===
// ==++==
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// align.h
//
// Alignment / Packing definitions
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#define WORD_ALIGN 1
#define DWORD_ALIGN 3
#define QWORD_ALIGN 7
#define DQWORD_ALIGN 15

#ifdef _WIN64
#define P2_ALIGN 15
#else // !_WIN64
#define P2_ALIGN 7
#endif // _WIN64

#define ALIGNED_SIZE(size, alignment) (((size) + (alignment)) & ~(alignment))

#ifndef SIZEOF_ARRAY
#define SIZEOF_ARRAY(x) ((sizeof(x))/(sizeof(x[0])))
#endif // SIZEOF_ARRAY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\abs.c ===
/***
*abs.c - find absolute value
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines abs() - find the absolute value of an int.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

#pragma function(abs, _abs64)

/***
*int abs(number) - find absolute value of number
*
*Purpose:
*       Returns the absolute value of number (if number >= 0, returns number,
*       else returns -number).
*
*Entry:
*       int number - number to find absolute value of
*
*Exit:
*       returns the aboslute value of number
*
*Exceptions:
*
*******************************************************************************/

int __cdecl abs (
        int number
        )
{
        return( number>=0 ? number : -number );
}
__int64 __cdecl _abs64(
        __int64 num
        )
{
        return (num >=0 ? num : -num);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\access.c ===
/***
*access.c - access function
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _access() function which checks on file accessability.
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <oscalls.h>
#include <stdlib.h>
#include <errno.h>
#include <msdos.h>
#include <internal.h>
#include <tchar.h>

/***
*int _access(path, amode) - check whether file can be accessed under mode
*
*Purpose:
*       Checks to see if the specified file exists and can be accessed
*       in the given mode.
*
*Entry:
*       _TSCHAR *path - pathname
*       int amode -     access mode
*                       (0 = exist only, 2 = write, 4 = read, 6 = read/write)
*
*Exit:
*       returns 0 if file has given mode
*       returns -1 and sets errno if file does not have given mode or
*       does not exist
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _taccess (
        const _TSCHAR *path,
        int amode
        )
{
    errno_t e;
    e = _taccess_s(path,amode);

    return e ? -1 : 0 ;
}

/***
*errno_t _access_s(path, amode) - check whether file can be accessed under mode
*
*Purpose:
*       Checks to see if the specified file exists and can be accessed
*       in the given mode.
*
*Entry:
*       _TSCHAR *path - pathname
*       int amode -     access mode
*                       (0 = exist only, 2 = write, 4 = read, 6 = read/write)
*
*Exit:
*       returns 0 if file has given mode
*       returns errno_t for any other errors
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _taccess_s (
        const _TSCHAR *path,
        int amode
        )
{

        DWORD attr;

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE( (path != NULL), EINVAL);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE( ((amode & (~6)) == 0), EINVAL);

        attr = GetFileAttributes((LPTSTR)path);
        if (attr  == 0xffffffff) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return errno;
        }

        if(attr & FILE_ATTRIBUTE_DIRECTORY)
        {
            /* All directories have read & write access */
            return 0;
        }

        /* no error; see if returned premission settings OK */
        if ( (attr & FILE_ATTRIBUTE_READONLY) && (amode & 2) ) {
                /* no write permission on file, return error */
                _doserrno = E_access;
                errno = EACCES;
                return errno;
        }
        else
                /* file exists and has requested permission setting */
                return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\agents.h ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* agents.h
*
* Main public header file for ConcRT's asynchronous agents layer. This is the only header file a
* C++ program should have to include in order to avail itself of asynchronous agents.
*
* The core runtime, PPL, and resource manager are in separate headers.
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

#pragma once

#include <crtdefs.h>
#include <concrt.h>
#include <stdexcept>
#include <functional>
#include <tuple>
#include <type_traits>
#include <vector>

#pragma pack(push,_CRT_PACKING)

// Forward declarations

/// <summary>
///     The <c>Concurrency</c> namespace provides classes and functions that give you access to the Concurrency Runtime,
///     a concurrent programming framework for C++. For more information, see <see cref="Concurrency Runtime"/>.
/// </summary>
/**/
namespace Concurrency
{
/// <summary>
///     Each message instance has an identity that follows it as it is
///     cloned and passed between messaging components. This cannot be the
///     address of the message object.
/// </summary>
/**/
typedef __int32 runtime_object_identity;

/// <summary>
///     A lock holder that acquires a non-reentrant lock on instantiation and releases
///     it on destruction.
/// </summary>
/**/
typedef ::Concurrency::details::_NonReentrantPPLLock::_Scoped_lock _NR_lock;

/// <summary>
///     A lock holder that acquires a reentrant lock on instantiation and releases
///     it on destruction
/// </summary>
/**/
typedef ::Concurrency::details::_ReentrantPPLLock::_Scoped_lock _R_lock;


//***************************************************************************
// Internal namespace:
//
// Concurrency::details contains definitions to support routines in the public namespaces and macros.
// Clients should not directly interact with this namespace.
//***************************************************************************

namespace details
{
    //**************************************************************************
    // Core Messaging Support:
    //**************************************************************************

    //
    // A base class to derive from that keeps unique ids on its derived classes
    //
    class _Runtime_object : public _AllocBase
    {
    public:
        // Creates a new runtime object.
        _CRTIMP2 _Runtime_object();

        // Creates a runtime object from an identity.
        _CRTIMP2 _Runtime_object(::Concurrency::runtime_object_identity _Id);

        // Gets the runtime object identity.
        virtual ::Concurrency::runtime_object_identity _GetId() const
        {
            return _M_id;
        }

    protected:
        // The runtime object identity.
        ::Concurrency::runtime_object_identity _M_id;
    };

    // A queue used to hold the messages for the messaging blocks
    template<class _Message>
    class _Queue : public _AllocBase
    {
    protected:
        // A pointer to the head of the queue.
        _Message * _M_pHead;

        // A pointer to a pointer to the tail of the queue.
        _Message ** _M_ppTail;

        // The number of elements presently stored in the queue.
        size_t _M_count;

    public:
        typedef typename _Message type;

        // Create a Queue
        _Queue() : _M_pHead(NULL), _M_ppTail(&_M_pHead), _M_count(0)
        {
        }

        // Destroy the queue
        ~_Queue()
        {
            // Delete any messages that may be remaining in the queue
            _Message * _Msg = _Dequeue();
            while (_Msg != NULL)
            {
                delete _Msg;
                _Msg = _Dequeue();
            }
        }

        // Returns the count of items in the queue
        size_t _Count() const
        {
            return _M_count;
        }

        // Add an item to the tail of the queue
        //
        // Returns a Boolean indicating whether the operation succeeded.
        bool _Enqueue(_Message *_Element)
        {
            _ASSERTE(_Element->_M_pNext == NULL);
            _ASSERTE(*_M_ppTail == NULL);

            *_M_ppTail = _Element;
            _Element->_M_pNext = NULL;
            _M_ppTail = &(_Element->_M_pNext);
            _M_count++;

            return true;
        }

        // Remove the specified element from the queue
        //
        // Returns a Boolean indicating whether the operation succeeded, i.e. that the message was found in the queue.
        bool _Remove(_Message * _OldElement)
        {
            bool _Result = false;

            _ASSERTE(_OldElement != NULL);

            if (_M_pHead == _OldElement)
            {
                _M_pHead = _OldElement->_M_pNext;
                if (_M_pHead == NULL)
                {
                    _M_ppTail = &_M_pHead;
                }

                _OldElement->_M_pNext = NULL;
                _M_count--;
                _Result = true;
            }
            else
            {
                _Message * _Next = NULL;
                for (_Message * _Node = _M_pHead; _Node != NULL; _Node = _Next)
                {
                    _Next = _Node->_M_pNext;

                    if (_Node->_M_pNext == _OldElement)
                    {
                        _Node->_M_pNext = _OldElement->_M_pNext;
                        // if this is the last element of the _Queue
                        if (_Node->_M_pNext == NULL && _M_count == 1)
                        {
                            _M_ppTail = &_M_pHead;
                        }

                        _OldElement->_M_pNext = NULL;
                        _M_count--;
                        _Result = true;
                        break;
                    }
                }
            }

            return _Result;
        }

        // Dequeue an item from the head of queue
        //
        // Returns a pointer to the message found at the head of the queue.
        _Message * _Dequeue()
        {
            if (_M_pHead == NULL)
            {
                return NULL;
            }

            _Message * _Result = _M_pHead;

            _M_pHead = _Result->_M_pNext;
            if (_M_pHead == NULL)
            {
                _M_ppTail = &_M_pHead;
            }

            _Result->_M_pNext = NULL;
            _M_count--;
            return _Result;
        }

        // Return the item at the head of the queue, without dequeuing
        //
        // Returns a pointer to the message found at the head of the queue.
        _Message * _Peek()
        {
            return _M_pHead;
        }

        // Return true if the id matches the message at the head of the queue
        bool _Is_head(runtime_object_identity _MsgId)
        {
            // Peek at the next message in the message buffer.  Use it to
            // check if the ids match
            _Message * _Msg = _M_pHead;

            if (_Msg == NULL || _Msg->msg_id() != _MsgId)
            {
                return false;
            }

            return true;
        }
    };

    //
    // The async_send_queue class puts a lock around the Enqueue/Dequeue operations on
    // a Queue.  This class is here mainly to support the message propagation queue
    // It holds incoming messages and will be written to on async_send(). Messages in
    // this queue will be moved to the internal storage of the block within an LWT.
    //
    template<class _Message>
    class _Async_send_queue
    {
    public:
        // Create an async send queue
        _Async_send_queue()
        {
        }

        // Return the count of items in the async send queue
        size_t _Count() const
        {
            return _M_queue._Count();
        }

        // Add an item to the back of the async send queue
        //
        // Returns a Boolean indicating whether the operation succeeded.
        bool _Enqueue(_Message * _Element)
        {
            _NR_lock _Lock(_M_lock);

            return (_M_queue._Enqueue(_Element));
        }

        // Remove an item from the async send queue
        //
        // Returns a Boolean indicating whether the operation succeeded, i.e. that the message was found in the async send queue.
        bool _Remove(_Message * _OldElement)
        {
            _NR_lock _Lock(_M_lock);

            return (_M_queue._Remove(_OldElement));
        }

        // Remove an item from the head of the async send queue
        //
        // Returns a pointer to the message found at the head of the async send queue.
        _Message * _Dequeue()
        {
            _NR_lock _Lock(_M_lock);

            return (_M_queue._Dequeue());
        }

        // Return the item at the head of the async send queue, without dequeuing
        //
        // Returns a pointer to the message found at the head of the async send queue.
        _Message * _Peek()
        {
            return _M_queue._Peek();
        }

    private:
        // A lock to guard the queue
        ::Concurrency::details::_NonReentrantPPLLock _M_lock;

        // Underlying queue
        _Queue<_Message> _M_queue;
    };


    //
    // _Dynamic_array implements a container very similar to std::vector.
    // However, it exposes a reduced subset of functionality that is
    // geared towards use in network_link_registry. The array acess is not
    // thread-safe.
    //
    template<class _Type>
    class _Dynamic_array
    {
    public:

        typedef _Dynamic_array<_Type> _Myt;

        typedef _Type& reference;
        typedef _Type const& const_reference;

        //
        // Construct a dynamic array
        //
        _Dynamic_array()
        {
            _Init();
        }

        //
        // Release any resources used by dynamic array
        //
        ~_Dynamic_array()
        {
            _Clear();
        }

        //
        // Assignment operator. Copy the contents of _Right
        //
        _Myt& operator=(const _Myt& _Right)
        {
            if (this != &_Right)
            {
                // Remove all the elements
                _Clear();

                // Allocate space for the new elements
                size_t _Size = _Right._Size();
                _Grow(_Size);

                // Copy over the new elements
                for (size_t _I=0; _I < _Size; _I++)
                {
                    _Push_back(_Right[_I]);
                }
            }

            return *this;
        }

        //
        // Clear all the elements in the array
        //
        void _Clear()
        {
            if (_M_array != NULL)
            {
                delete [] _M_array;
                _Init();
            }
        }

        //
        // Add an element to the end of the array
        //
        void _Push_back(_Type const& _Element)
        {
            if (_M_index >= _M_size)
            {
                // Not enough space. Grow the array
                size_t _NewSize = (_M_index + 1) * _S_growthFactor;
                _Grow(_NewSize);
            }

            _ASSERTE(_M_index < _M_size);
            _M_array[_M_index] = _Element;
            _M_index++;
        }

        //
        // Index operation. Retrieve an element at the specified index. No bounds check is done.
        //
        reference operator[](size_t _Pos)
        {
            _ASSERTE(_Pos < _M_size);
            return _M_array[_Pos];
        }

        //
        // Index operation. Retrieve an element at the specified index. No bounds check is done.
        //
        const_reference operator[](size_t _Pos) const
        {
            _ASSERTE(_Pos < _M_size);
            return _M_array[_Pos];
        }

        //
        // Returns the count of elements in the array
        //
        size_t _Size() const
        {
            return _M_index;
        }

        //
        // Swap the contents of this array with _Right
        //
        void _Swap(_Myt& _Right)
        {
            if (this != &_Right)
            {
                // Swap the details.
                _Type * _Array = _M_array;
                size_t _Index = _M_index;
                size_t _Size = _M_size;

                _M_array = _Right._M_array;
                _M_index = _Right._M_index;
                _M_size = _Right._M_size;

                _Right._M_array = _Array;
                _Right._M_index = _Index;
                _Right._M_size = _Size;
            }
        }

    private:
        //
        // Initialize the array
        //
        void _Init()
        {
            _M_array = NULL;
            _M_index = 0;
            _M_size = 0;
        }

        //
        // Grow the array to the given size. The old elements are copied over.
        //
        void _Grow(size_t _NewSize)
        {
            _ASSERTE(_NewSize > _M_size);

            _Type * _Array = new _Type[_NewSize];

            if (_M_array != NULL)
            {
                // Copy over the elememts
                for (size_t _I = 0; _I < _M_size; _I++)
                {
                    _Array[_I] = _M_array[_I];
                }

                delete [] _M_array;
            }

            _M_array = _Array;
            _M_size = _NewSize;
        }

        // Private data members

        // Array of elements
        _Type * _M_array;

        // Index where the next element should be inserted
        size_t  _M_index;

        // Capacity of the array.
        size_t  _M_size;

        static const int _S_growthFactor = 2;
    };
} // namespace details

//**************************************************************************
// Public Namespace:
//
// Anything in the Concurrency namespace is intended for direct client consumption.
//
//**************************************************************************

//
// Forward declarations:
//
template<class _Type> class ISource;
template<class _Type> class ITarget;

//**************************************************************************
// Network link registry
//**************************************************************************

// Forward declaration for use in the iterator
template<class _Block> class network_link_registry;

/// <summary>
///     Const iterator for network link registry. Message blocks should use
///     the link_registry::iterator type for iteration.
/// </summary>
/// <typeparam name="_Block">
///     The network block type
/// </typeparam>
/**/
template<class _Block>
class _Network_link_iterator
{
public:

    typedef _Network_link_iterator<_Block> _Myt;
    typedef network_link_registry<_Block>  _MyContainer;

    // Element type
    typedef _Block* _EType;

    // Const iterator - iterator shall not be used to modify the links
    typedef _EType const& const_reference;
    typedef _EType const* const_pointer;

    /// <summary>
    ///     Construct iterator
    /// </summary>
    /**/
    _Network_link_iterator(_MyContainer * _PNetwork_link, size_t _Index) : _M_pNetwork_link(_PNetwork_link), _M_index(_Index), _M_value(NULL)
    {
        _M_pNetwork_link->_Next_index(_M_index);
    }

    /// <summary>
    ///     Copy construct an iterator
    /// </summary>
    /**/
    _Network_link_iterator(_Myt const& _Right)
    {
        _M_pNetwork_link = _Right._M_pNetwork_link;
        _M_index = _Right._M_index;
    }

    /// <summary>
    ///     Copy assign an iterator
    /// </summary>
    /**/
    _Myt const& operator=(_Myt const& _Right)
    {
        _M_pNetwork_link = _Right._M_pNetwork_link;
        _M_index = _Right._M_index;
        return *this;
    }

    /// <summary>
    ///     Returns the object pointed to by the iterator
    /// </summary>
    /// <returns>
    ///     Reference to the object pointed to by the iterator
    /// </returns>
    /**/
    const_reference operator*()
    {
        _M_value = _M_pNetwork_link->_Get_element(_M_index);
        return _M_value;
    }

    /// <summary>
    ///     Returns a pointer to the class object
    /// </summary>
    /// <returns>
    ///     Returns a pointer to the class object
    /// </returns>
    /**/
    const_pointer operator->() const
    {
        return (&**this);
    }

    /// <summary>
    ///     Pre-increment the iterator to point to the next element
    /// </summary>
    /// <returns>
    ///     Reference to the object pointer to by the iterator after
    ///     incrementing it
    /// </returns>
    /**/
    _Myt& operator++()
    {
        ++_M_index;
        _M_pNetwork_link->_Next_index(_M_index);
        return (*this);
    }

    /// <summary>
    ///     Post-increment the iterator to point to the next element
    /// </summary>
    /// <returns>
    ///     Reference to the object pointer to by the iterator before
    ///     incrementing it
    /// </returns>
    /**/
    _Myt operator++(int)
    {
        _Myt _Tmp = *this;
        ++*this;
        return (_Tmp);
    }

private:

    // Pointer to the underlying container (network link registry)
    _MyContainer * _M_pNetwork_link;

    // Current index
    size_t _M_index;

    // Current value
    _EType _M_value;
};

/// <summary>
///     The <c>network_link_registry</c> abstract base class manages the links between source
///     and target blocks.
/// </summary>
/// <typeparam name="_Block">
///     The block data type being stored in the <c>network_link_registry</c>.
/// </typeparam>
/// <remarks>
///     The <c>network link registry</c> is not safe for concurrent access.
/// </remarks>
/// <seealso cref="single_link_registry Class"/>
/// <seealso cref="multi_link_registry Class"/>
/**/
template<class _Block>
class network_link_registry
{
public:

    /// <summary>
    ///     A type that represents the block type stored in the <c>network_link_registry</c> object.
    /// </summary>
    /**/
    typedef typename _Block type;

    /// <summary>
    ///     A type that represents an element pointer stored in the <c>network_link_registry</c> object.
    /// </summary>
    /**/
    typedef _Block * _EType;

    /// <summary>
    ///     A type that provides a reference to a <c>const</c> element stored in a
    ///     <c>network_link_registry</c> object for reading and performing const operations.
    /// </summary>
    /**/
    typedef _EType const& const_reference;

    /// <summary>
    ///     A type that provides a pointer to a <c>const</c> element in a
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /**/
    typedef _EType const* const_pointer;

    // Make the iterators friends so that they can access some of the
    // private routines such as _Get_element.
    /**/
    friend class _Network_link_iterator<_Block>;

    /// <summary>
    ///     A type that provides an iterator that can read or modify any element in a
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /**/
    typedef _Network_link_iterator<_Block> iterator;

    /// <summary>
    ///     When overridden in a derived class, adds a link to the <c>network_link_registry</c>
    ///     object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /**/
    virtual void add(_EType _Link) = 0;

    /// <summary>
    ///     When overridden in a derived class, removes a specified block from the
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool remove(_EType _Link) = 0;

    /// <summary>
    ///     When overridden in a derived class, searches the <c>network_link_registry</c> object
    ///     for a specified block.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is being searched for in the <c>network_link_registry</c>
    ///     object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the block was found, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool contains(_EType _Link) = 0;

    /// <summary>
    ///     When overridden in a derived class, returns the number of items in the
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /// <returns>
    ///     The number of items in the <c>network_link_registry</c> object.
    /// </returns>
    /**/
    virtual size_t count() = 0;

    /// <summary>
    ///     When overridden in a derived class, returns an iterator to the first element in the
    ///     <c>network_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The end state of the iterator is indicated by a <c>NULL</c> link.
    /// </remarks>
    /// <returns>
    ///     An iterator addressing the first element in the <c>network_link_registry</c> object.
    /// </returns>
    /**/
    virtual iterator begin() = 0;

protected:

    /// <summary>
    ///     Skips empty slots and updates the index to the next
    ///     non-empty slot. This is called by the iterator.
    /// </summary>
    /// <param name="_Index">
    ///     A reference to the index that is to be updated.
    /// </param>
    /**/
    virtual void _Next_index(size_t& _Index) = 0;

    /// <summary>
    ///     Retrieves the element at the given index. If the index is out of bounds,
    ///     <c>NULL</c> is returned. Users need to use the iterator to access the links.
    /// </summary>
    /// <param name="_Index">
    ///     Index of the link to be retrieved.
    /// </param>
    /// <returns>
    ///     The element in the registry at  the index specified by the <paramref name="_Index"/> parameter.
    /// </returns>
    /**/
    virtual _EType _Get_element(size_t _Index) const = 0;
};

/// <summary>
///     The <c>single_link_registry</c> object is a <c>network_link_registry</c> that manages
///     only a single source or target block.
/// </summary>
/// <typeparam name="_Block">
///     The block data type being stored in the <c>single_link_registry</c> object.
/// </typeparam>
/// <seealso cref="multi_link_registry Class"/>
/**/
template<class _Block>
class single_link_registry : public network_link_registry<_Block>
{
public:

    /// <summary>
    ///     Constructs a <c>single_link_registry</c> object.
    /// </summary>
    /**/
    single_link_registry() : _M_connectedLink(NULL)
    {
    }

    /// <summary>
    ///     Destroys the <c>single_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The method throws an <see cref="invalid_operation Class">invalid_operation</see> exception if
    ///     it is called before the link is removed.
    /// </remarks>
    /**/
    virtual ~single_link_registry()
    {
        // It is an error to delete link registry with links
        // still present
        if (count() != 0)
        {
            throw invalid_operation("Deleting link registry before removing all the links");
        }
    }

    /// <summary>
    ///     Adds a link to the <c>single_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /// <remarks>
    ///     The method throws an <see cref="invalid_link_target Class">invalid_link_target</see> exception
    ///     if there is already a link in this registry.
    /// </remarks>
    /**/
    virtual void add(_EType _Link)
    {
        if (_Link == NULL)
        {
            return;
        }

        // Only one link can be added.
        if (_M_connectedLink != NULL)
        {
            throw invalid_link_target("_Link");
        }

        _M_connectedLink = _Link;
    }

    /// <summary>
    ///     Removes a link from the <c>single_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool remove(_EType _Link)
    {
        if ((_Link != NULL) && (_M_connectedLink == _Link))
        {
            _M_connectedLink = NULL;
            return true;
        }

        return false;
    }

    /// <summary>
    ///     Searches the <c>single_link_registry</c> object for a specified block.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is to be searched for in the <c>single_link_registry</c> object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool contains(_EType _Link)
    {
        return ((_Link != NULL) && (_M_connectedLink == _Link));
    }

    /// <summary>
    ///     Counts the number of items in the <c>single_link_registry</c> object.
    /// </summary>
    /// <returns>
    ///     The number of items in the <c>single_link_registry</c> object.
    /// </returns>
    /**/
    virtual size_t count()
    {
        return (_M_connectedLink == NULL) ? 0 : 1;
    }

    /// <summary>
    ///     Returns an iterator to the first element in the <c>single_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The end state is indicated by a <c>NULL</c> link.
    /// </remarks>
    /// <returns>
    ///     An iterator addressing the first element in the <c>single_link_registry</c> object.
    /// </returns>
    /**/
    virtual iterator begin()
    {
        return (iterator(this, 0));
    }

protected:

    /// <summary>
    ///     Skips empty slots and updates the index to the next
    ///     non-empty slot. This is called by the iterator.
    /// </summary>
    /// <param name="_Index">
    ///     A reference to the index that is to be updated.
    /// </param>
    /**/
    virtual void _Next_index(size_t& _Index)
    {
        if (_M_connectedLink == NULL)
        {
            _Index++;
        }
    }

    /// <summary>
    ///     Retrieves the element at the given index. If the index is out of bounds,
    ///     <c>NULL</c> is returned. Users need to use the iterator to access the links.
    /// </summary>
    /// <param name="_Index">
    ///     The index of the link to be retrieved.
    /// </param>
    /// <returns>
    ///     The element in the registry at  the index specified by the <paramref name="_Index"/> parameter.
    /// </returns>
    /**/
    virtual _EType _Get_element(size_t _Index) const
    {
        if (_Index == 0)
        {
            return _M_connectedLink;
        }

        return NULL;
    }

private:

    // A single pointer is used to hold the link
    _EType _M_connectedLink;
};

/// <summary>
///     The <c>multi_link_registry</c> object is a <c>network_link_registry</c> that manages multiple
///     source blocks or multiple target blocks.
/// </summary>
/// <typeparam name="_Block">
///     The block data type being stored in the <c>multi_link_registry</c> object.
/// </typeparam>
/// <seealso cref="single_link_registry Class"/>
/**/
template<class _Block>
class multi_link_registry : public network_link_registry<_Block>
{
public:

    /// <summary>
    ///     Constructs a <c>multi_link_registry</c> object.
    /// </summary>
    /**/
    multi_link_registry() : _M_maxLinks(_NOT_SET)
    {
    }

    /// <summary>
    ///     Destroys the <c>multi_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The method throws an <see cref="invalid_operation Class">invalid_operation</see> exception if
    ///     called before all links are removed.
    /// </remarks>
    /**/
    virtual ~multi_link_registry()
    {
        // It is an error to delete link registry with links
        // still present
        if (count() != 0)
        {
            throw invalid_operation("Deleting link registry before removing all the links");
        }
    }

    /// <summary>
    ///     Sets an upper bound on the number of links that the <c>multi_link_registry</c> object
    ///     can hold.
    /// </summary>
    /// <param name="_MaxLinks">
    ///     The maximum number of links that the <c>multi_link_registry</c> object can hold.
    /// </param>
    /// <remarks>
    ///     Once a bound is set, unlinking an entry will cause the <c>multi_link_registry</c>
    ///     object to enter an immutable state where further calls to <c>add</c> will throw an
    ///     <c>invalid_link_target</c> exception.
    /// </remarks>
    /**/
    void set_bound(size_t _MaxLinks)
    {
        _ASSERTE(count() == 0);
        _M_maxLinks = _MaxLinks;
    }

    /// <summary>
    ///     Adds a link to the <c>multi_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /// <remarks>
    ///     The method throws an <see cref="invalid_link_target Class">invalid_link_target</see> exception if
    ///     the link is already present in the registry, or if a bound has already been set with the <c>set_bound</c>
    ///     function and a link has since been removed.
    /// </remarks>
    /**/
    virtual void add(_EType _Link)
    {
        if (_Link == NULL)
        {
            return;
        }

        _Add(_Link);
    }

    /// <summary>
    ///     Removes a link from the <c>multi_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool remove(_EType _Link)
    {
        if (_Link == NULL)
        {
            return false;
        }

        return (_Remove(_Link));
    }

    /// <summary>
    ///     Searches the <c>multi_link_registry</c> object for a specified block.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is to be searched for in the <c>multi_link_registry</c> object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the specified block was found, <c>false</c> otherwise.
    /// </returns>
    /**/
    virtual bool contains(_EType _Link)
    {
        if (_Link == NULL)
        {
            return false;
        }

        return (_Find(_Link) < _M_vector._Size());
    }

    /// <summary>
    ///     Counts the number of items in the <c>multi_link_registry</c> object.
    /// </summary>
    /// <returns>
    ///     The number of items in the <c>multi_link_registry</c> object.
    /// </returns>
    /**/
    virtual size_t count()
    {
        return _Count();
    }

    /// <summary>
    ///     Returns an iterator to the first element in the <c>multi_link_registry</c> object.
    /// </summary>
    /// <remarks>
    ///     The end state is indicated by a <c>NULL</c> link.
    /// </remarks>
    /// <returns>
    ///     An iterator addressing the first element in the <c>multi_link_registry</c> object.
    /// </returns>
    /**/
    virtual iterator begin()
    {
        return (iterator(this, 0));
    }

protected:

    /// <summary>
    ///     Skips empty slots and updates the index to the next
    ///     non-empty slot. This is called by the iterator.
    /// </summary>
    /// <param name="_Index">
    ///     A reference to the index that is to be updated.
    /// </param>
    /**/
    virtual void _Next_index(size_t& _Index)
    {
        size_t _Size = _M_vector._Size();
        while (_Index < _Size)
        {
            if (_M_vector[_Index] != NULL)
            {
                break;
            }

            ++_Index;
        }
    }

    /// <summary>
    ///     Retrieves the element at the given index. If the index is out of bounds,
    ///     <c>NULL</c> is returned. Users need to use the iterator to access the links
    /// </summary>
    /// <param name="_Index">
    ///     Index of the link to be retrieved.
    /// </param>
    /// <returns>
    ///     The element in the registry at the index specified by the <paramref name="_Index"/> parameter.
    /// </returns>
    /**/
    virtual _EType _Get_element(size_t _Index) const
    {
        if (_Index < _M_vector._Size())
        {
            return _M_vector[_Index];
        }

        return NULL;
    }

private:

    /// <summary>
    ///     Adds a link to the <c>multi_link_registry</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /**/
    void _Add(_EType _Link)
    {
        size_t _Size = _M_vector._Size();
        size_t _Insert_pos = 0;

        _ASSERTE(_Link != NULL);

        // If max links is set, ensure that inserting the new
        // link will not exceed the bound.
        if ((_M_maxLinks != _NOT_SET) && ((_Size+1) > (size_t) _M_maxLinks))
        {
            throw invalid_link_target("_Link");
        }

        for (size_t _Index = 0; _Index < _Size; _Index++)
        {
            if (_M_vector[_Index] != NULL)
            {
                // We want to find the first NULL entry after all the
                // non-NULL entries.
                _Insert_pos = _Index + 1;

                // Throw if dupiclate entry is found
                if (_M_vector[_Index] == _Link)
                {
                    throw invalid_link_target("_Link");
                }
            }
        }

        if (_Insert_pos < _Size)
        {
            _M_vector[_Insert_pos] = _Link;
        }
        else
        {
            _M_vector._Push_back(_Link);
        }
    }

    /// <summary>
    ///     Removes a link from the <c>multi_link_registry</c>
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the specified link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool _Remove(_EType _Link)
    {
        _ASSERTE(_Link != NULL);

        for (size_t _Index = 0; _Index < _M_vector._Size(); _Index++)
        {
            if (_M_vector[_Index] == _Link)
            {
                _M_vector[_Index] = NULL;

                // If max links is set, prevent new additions to the registry
                if (_M_maxLinks != _NOT_SET && _M_maxLinks > 0)
                {
                    // Setting the bound to 0. This causes add to always throw.
                    _M_maxLinks = 0;
                }

                return true;
            }
        }

        return false;
    }


    /// <summary>
    ///     Searches the registry for the given link
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is to be searched.
    /// </param>
    /// <returns>
    ///     Index of the entry if found.
    /// </returns>
    /**/
    virtual size_t _Find(_EType _Link)
    {
        size_t _Index = 0;
        for (_Index = 0; _Index < _M_vector._Size(); _Index++)
        {
            if (_M_vector[_Index] == _Link)
            {
                break;
            }
        }

        return _Index;
    }

    /// <summary>
    ///     Returns the count of items in the registry.
    /// </summary>
    /// <returns>
    ///     The count of items in the registry.
    /// </returns>
    /**/
    size_t _Count() const
    {
        size_t _Count = 0;

        for (size_t _Index = 0; _Index < _M_vector._Size(); _Index++)
        {
            if (_M_vector[_Index] != NULL)
            {
                _Count++;
            }
        }

        return _Count;
    }

    static const size_t _NOT_SET = SIZE_MAX;

    // Maximum number of links allowed.
    size_t _M_maxLinks;

    // ::Concurrency::details::_Dynamic_array is used to hold the links
    ::Concurrency::details::_Dynamic_array<_EType> _M_vector;
};

// Forward declaration for the iterator
template<class _LinkRegistry> class source_link_manager;

/// <summary>
///     Const Iterator for referenced link manager.
/// </summary>
/// <typeparam name="_LinkRegistry">
///     The underlying network link registry
/// </typeparam>
/**/
template<class _LinkRegistry>
class _Source_link_iterator
{
public:

    typedef typename _LinkRegistry::type  _Block;

    typedef _Source_link_iterator<_LinkRegistry> _Myt;
    typedef source_link_manager<_LinkRegistry>  _MyContainer;

    // Element type
    typedef _Block* _EType;

    // Const iterator - iterator shall not be used to modify the links
    typedef _EType const& const_reference;
    typedef _EType const* const_pointer;

    /// <summary>
    ///     Construct iterator
    /// </summary>
    /**/
    _Source_link_iterator(_MyContainer * _PNetwork_link, size_t _Index) : _M_pNetwork_link(_PNetwork_link), _M_index(_Index), _M_sentinel(NULL)
    {
        // Take a snapshot of the link registry. This will reference the registry.
        _M_pNetwork_link->_To_array(_M_array);
    }

    /// <summary>
    ///     Destruct iterator
    /// </summary>
    /**/
    virtual ~_Source_link_iterator()
    {
        if (_M_pNetwork_link != NULL)
        {
            _M_pNetwork_link->release();
        }
    }
    /// <summary>
    ///     Copy construct an iterator
    /// </summary>
    /**/
    _Source_link_iterator(_Myt const& _Right)
    {
        _M_pNetwork_link = _Right._M_pNetwork_link;
        _M_index = _Right._M_index;
        _M_array = _Right._M_array;

        _M_pNetwork_link->reference();
    }

    /// <summary>
    ///     Copy assign an iterator
    /// </summary>
    /**/
    _Myt const& operator=(_Myt const& _Right)
    {
        _MyContainer * _OldContainer = _M_pNetwork_link;
        _ASSERTE(_OldContainer != NULL);

        _M_pNetwork_link = _Right._M_pNetwork_link;
        _M_index = _Right._M_index;
        _M_array = _Right._M_array;

        if (_OldContainer != _M_pNetwork_link)
        {
            _OldContainer->release();
            _M_pNetwork_link->reference();
        }

        return *this;
    }

    /// <summary>
    ///     Returns the object pointed to by the iterator
    /// </summary>
    /// <returns>
    ///     Reference to the object pointed to by the iterator
    /// </returns>
    /**/
    const_reference operator*()
    {
        return _Get(0);
    }

    /// <summary>
    ///     Returns a pointer to the class object
    /// </summary>
    /// <returns>
    ///     Returns a pointer to the class object
    /// </returns>
    /**/
    const_pointer operator->() const
    {
        return (&**this);
    }

    /// <summary>
    ///     Index operation. Retrieve an element at the specified index.
    /// </summary>
    /**/
    const_reference operator[](size_t _Pos) const
    {
        return _Get(_Pos);
    }

    /// <summary>
    ///     Pre-increment the iterator to point to the next element
    /// </summary>
    /// <returns>
    ///     Reference to the object pointer to by the iterator after incrementing it
    /// </returns>
    /**/
    _Myt& operator++()
    {
        ++_M_index;
        return (*this);
    }

    /// <summary>
    ///     Post-increment the iterator to point to the next element
    /// </summary>
    /// <returns>
    ///     Reference to the object pointer to by the iterator before incrementing it
    /// </returns>
    /**/
    _Myt operator++(int)
    {
        _Myt _Tmp = *this;
        ++*this;
        return (_Tmp);
    }

private:

    // Get the element at the given offset.
    const_reference _Get(size_t _Pos) const
    {
        size_t _Index = _M_index + _Pos;
        if (_Index >= _M_array._Size())
        {
            return _M_sentinel;
        }

        return _M_array[_Index];
    }

    // Array to hold the snapshot of the link registry
    ::Concurrency::details::_Dynamic_array<_EType> _M_array;

    // Pointer to the underlying container (network link registry)
    _MyContainer * _M_pNetwork_link;

    // Current index
    size_t _M_index;

    // Sentinel value to return on bounds overflow
    _EType _M_sentinel;
};

/// <summary>
///     The <c>source_link_manager</c> object manages messaging block network links
///     to <c>ISource</c> blocks.
/// </summary>
/// <typeparam name="_LinkRegistry">
///     The network link registry.
/// </typeparam>
/// <remarks>
///     Currently, the source blocks are reference counted. This is a wrapper on a
///     <c>network_link_registry</c> object that allows concurrent access to the links and
///     provides the ability to reference the links through callbacks. Message
///     blocks (<c>target_block</c>s or <c>propagator_block</c>s) should use this class
///     for their source links.
/// </remarks>
/// <seealso cref="single_link_registry Class"/>
/// <seealso cref="multi_link_registry Class"/>
/**/
template<class _LinkRegistry>
class source_link_manager
{
public:

    /// <summary>
    ///     The type of link registry being managed by the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef _LinkRegistry type;

    /// <summary>
    ///     The type of the blocks being managed by the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef typename _LinkRegistry::type _Block;

    /// <summary>
    ///     The method signature for a callback method for this <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef std::tr1::function<void(_Block *, bool)>  _Callback_method;

    /// <summary>
    ///     A type that represents a pointer to an element stored in the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef _Block * _EType;

    /// <summary>
    ///     A type that provides a reference to a <c>const</c> element stored in a <c>source_link_manager</c> object
    ///     for reading and performing const operations.
    /// </summary>
    /**/
    typedef _EType const& const_reference;

    /// <summary>
    ///     A type that provides a pointer to a <c>const</c> element in a <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef _EType const* const_pointer;

    // Iterator
    friend class _Source_link_iterator<_LinkRegistry>;

    /// <summary>
    ///     A type that provides an iterator that can read or modify any element in the
    ///     <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef _Source_link_iterator<_LinkRegistry> iterator;

    /// <summary>
    ///     A type that provides a reentrant lock for the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    typedef ::Concurrency::details::_ReentrantPPLLock _LockType;

    /// <summary>
    ///     A type that provides a RAII scoped lock holder for a lock.
    /// </summary>
    /**/
    typedef _LockType::_Scoped_lock _LockHolder;

    /// <summary>
    ///     Constructs a <c>source_link_manager</c> object.
    /// </summary>
    /**/
    source_link_manager() : _M_iteratorCount(0), _M_pLinkedTarget(NULL)
    {
    }

    /// <summary>
    ///     Destroys the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    ~source_link_manager()
    {
        _ASSERTE(_M_pendingRemove._Size() == 0);
    }

    /// <summary>
    ///     Registers the target block that holds this <c>source_link_manager</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     The target block holding this <c>source_link_manager</c> object.
    /// </param>
    /**/
    void register_target_block(ITarget<typename _Block::source_type> * _PTarget)
    {
        _M_pLinkedTarget = _PTarget;
    }

    /// <summary>
    ///     Sets the maximum number of source links that can be added to this
    ///     <c>source_link_manager</c> object.
    /// </summary>
    /// <param name="_MaxLinks">
    ///     The maximum number of links.
    /// </param>
    /**/
    void set_bound(size_t _MaxLinks)
    {
        _M_links.set_bound(_MaxLinks);
    }

    /// <summary>
    ///     Adds a source link to the <c>source_link_manager</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be added.
    /// </param>
    /**/
    void add(_EType _Link)
    {
        if (_Link == NULL)
        {
            return;
        }

        {
            _LockHolder _Lock(_M_lock);
            _M_links.add(_Link);

            // We need to add the _Link first and then invoke the
            // callback since _Add could throw.

            // As soon as the above lock is released, remove would
            // find the link that was added and could unlink it before
            // we are able to invoke the notification below. Keeping an
            // active iterator would prevent that from happening.
            _M_iteratorCount++;
        }

        // Acquire a reference on this link by the target
        _Link->acquire_ref(_M_pLinkedTarget);

        // Release the active iterator
        release();
    }

    /// <summary>
    ///     Removes a link from the <c>source_link_manager</c> object.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block to be removed, if found.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the link was found and removed, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool remove(_EType _Link)
    {
        bool _Removed = false;
        _EType _RemovedLink = NULL;
        ITarget<typename _Block::source_type> * _LinkedTarget = _M_pLinkedTarget;

        if (_Link == NULL)
        {
            return false;
        }

        {
             _LockHolder _Lock(_M_lock);
             _Removed = _M_links.remove(_Link);

             if (!_Removed)
             {
                 // No change was made
                 return _Removed;
             }

             if (_M_iteratorCount == 0)
             {
                 // Set the removed link to indicate that
                 // notification callback needs to be invoked.
                 _RemovedLink = _Link;
             }
             else
             {
                 // The iterator will complete the pending operation
                 _M_pendingRemove._Push_back(_Link);
             }
        }

        // NOTE: touching "this" pointer is dangerous as soon as the above lock is released

        // Release the reference for this link
        if (_RemovedLink != NULL)
        {
            _RemovedLink->release_ref(_LinkedTarget);
        }

         return _Removed;
    }

    /// <summary>
    ///     Acquires a reference on the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    void reference()
    {
        _LockHolder _Lock(_M_lock);
        _M_iteratorCount++;
    }

    /// <summary>
    ///     Releases the reference on the <c>source_link_manager</c> object.
    /// </summary>
    /**/
    void release()
    {
        ITarget<typename _Block::source_type> * _LinkedTarget = _M_pLinkedTarget;
        ::Concurrency::details::_Dynamic_array<_EType> _LinksToRemove;

        {
            _LockHolder _Lock(_M_lock);
            _ASSERTE(_M_iteratorCount > 0);
            _M_iteratorCount--;

            if (_M_iteratorCount == 0)
            {
                if (_M_pendingRemove._Size() > 0)
                {
                    // Snap the pending remove list with the lock held
                    _M_pendingRemove._Swap(_LinksToRemove);
                }
            }
        }

        // NOTE: touching "this" pointer is dangerous as soon as the above lock is released

        // Release the references
        size_t _Size = _LinksToRemove._Size();

        for (size_t _I=0; _I < _Size; _I++)
        {
            _LinksToRemove[_I]->release_ref(_LinkedTarget);
        }
    }

    /// <summary>
    ///     Searches the <c>network_link_registry</c> within this <c>source_link_manager</c>
    ///     object for a specified block.
    /// </summary>
    /// <param name="_Link">
    ///     A pointer to a block that is to be searched for in the <c>source_link_manager</c> object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the specified block was found, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool contains(_EType _Link)
    {
        _LockHolder _Lock(_M_lock);
        return _M_links.contains(_Link);
    }

    /// <summary>
    ///     Counts the number of linked blocks in the <c>source_link_manager</c> object.
    /// </summary>
    /// <returns>
    ///     The number of linked blocks in the <c>source_link_manager</c> object.
    /// </returns>
    /**/
    size_t count()
    {
        _LockHolder _Lock(_M_lock);
        return _M_links.count();
    }


    /// <summary>
    ///     Returns an iterator to the first element in the <c>source_link_manager</c> object.
    /// </summary>
    /// <remarks>
    ///     The end state of the iterator is indicated by a <c>NULL</c> link.
    /// </remarks>
    /// <returns>
    ///     An iterator addressing the first element in the <c>source_link_manager</c> object.
    /// </returns>
    /**/
    iterator begin()
    {
        return (iterator(this, 0));
    }

private:

    // Called by the iterator. This routine takes a snapshot of the links
    // in the registry and copies it to the array provided.
    void _To_array(::Concurrency::details::_Dynamic_array<_EType>& _Array)
    {
        _LockHolder _Lock(_M_lock);
        _M_iteratorCount++;

        for(_LinkRegistry::iterator _Link = _M_links.begin(); *_Link != NULL; _Link++)
        {
            _Array._Push_back(*_Link);
        }
    }

    // Internal lock used for synchronization
    _LockType _M_lock;

    // Count to indicate that an iterator is active
    volatile long _M_iteratorCount;

    // A vector of all pending link remove operations
    ::Concurrency::details::_Dynamic_array<_EType> _M_pendingRemove;

    // Underlying link registry
    _LinkRegistry _M_links;

    // Target block holding this source link manager
    ITarget<typename _Block::source_type> * volatile _M_pLinkedTarget;
};

/// <summary>
///     The valid responses for an offer of a <c>message</c> object to a block.
/// </summary>
/**/
enum message_status
{
    /// <summary>
    ///     The target accepted the message.
    /// </summary>
    /**/
    accepted,
    /// <summary>
    ///     The target did not accept the message.
    /// </summary>
    /**/
    declined,
    /// <summary>
    ///     The target postponed the message.
    /// </summary>
    /**/
    postponed,
    /// <summary>
    ///     The target tried to accept the message, but it was no longer available.
    /// </summary>
    /**/
    missed
};

/// <summary>
///     The basic message envelope containing the data payload being passed between
///     messaging blocks.
/// </summary>
/// <typeparam name="_Type">
///     The data type of the payload within the message.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/**/
template<class _Type>
class message : public ::Concurrency::details::_Runtime_object
{
    friend class ::Concurrency::details::_Queue<message<_Type>>;
    friend class ::Concurrency::details::_Async_send_queue<message<_Type>>;

public:
    /// <summary>
    ///     Constructs a <c>message</c> object.
    /// </summary>
    /// <param name="_P">
    ///     The payload of this message.
    /// </param>
    /// <remarks>
    ///     This method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if the parameter <paramref name="_Msg"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    message(_Type const &_P) : payload(_P), _M_pNext(NULL), _M_refCount(0) { }

    /// <summary>
    ///     Constructs a <c>message</c> object.
    /// </summary>
    /// <param name="_Msg">
    ///     A reference or pointer to a <c>message</c> object.
    /// </param>
    /// <remarks>
    ///     This method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if the parameter <paramref name="_Msg"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    message(message const & _Msg) : payload(_Msg.payload), _M_pNext(NULL), _M_refCount(0) { }

    /// <summary>
    ///     Constructs a <c>message</c> object.
    /// </summary>
    /// <param name="_Msg">
    ///     A reference or pointer to a <c>message</c> object.
    /// </param>
    /// <remarks>
    ///     This method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if the parameter <paramref name="_Msg"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    message(message const * _Msg) : payload((_Msg == NULL) ? NULL : _Msg->payload), _M_pNext(NULL), _M_refCount(0)
    {
        if (_Msg == NULL)
        {
            throw std::invalid_argument("_Msg");
        }
    }

    /// <summary>
    ///     Destroys the <c>message</c> object.
    /// </summary>
    /**/
    virtual ~message() { }

    /// <summary>
    ///     Returns the ID of the <c>message</c> object.
    /// </summary>
    /// <returns>
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object.
    /// </returns>
    /**/
    runtime_object_identity msg_id() const
    {
        return _M_id;
    }

    /// <summary>
    ///     The payload of the <c>message</c> object.
    /// </summary>
    /**/
    _Type const payload;

    /// <summary>
    ///     Adds to the reference count for the <c>message</c> object.  Used for message blocks that
    ///     need reference counting to determine message lifetimes.
    /// </summary>
    /// <returns>
    ///     The new value of the reference count.
    /// </returns>
    /**/
    long add_ref()
    {
        return _InterlockedIncrement(&_M_refCount);
    }

    /// <summary>
    ///     Subtracts from the reference count for the <c>message</c> object.  Used for message blocks that
    ///     need reference counting to determine message lifetimes.
    /// </summary>
    /// <returns>
    ///     The new value of the reference count.
    /// </returns>
    /**/
    long remove_ref()
    {
        return _InterlockedDecrement(&_M_refCount);
    }

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

private:
    // The intrusive next pointer used by blocks that need
    // to chain messages it's holding together
    message * _M_pNext;

    // Avoid warnings about not generating assignment operators.
    message<_Type> const &operator =(message<_Type> const &);

    // A reference count for the message
    volatile long _M_refCount;
};

//**************************************************************************
// Message processor:
//**************************************************************************

/// <summary>
///     The <c>message_processor</c> class is the abstract base class for processing of
///     <c>message</c> objects.  There is no guarantee on the ordering of the messages.
/// </summary>
/// <typeparam name="_Type">
///     The data type of the payload within messages handled by this <c>message_processor</c> object.
/// </typeparam>
/// <seealso cref="ordered_message_processor Class"/>
/**/
template<class _Type>
class message_processor
{
public:

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

    /// <summary>
    ///     When overridden in a derived class, places messages into the block asynchronously.
    /// </summary>
    /// <param name="_Msg">
    ///     A <c>message</c> object to send asynchronously.
    /// </param>
    /// <remarks>
    ///     Processor implementations should override this method.
    /// </remarks>
    /**/
    virtual void async_send(message<_Type> * _Msg) = 0;

    /// <summary>
    ///     When overridden in a derived class, places messages into the block synchronously.
    /// </summary>
    /// <param name="_Msg">
    ///     A <c>message</c> object to send synchronously.
    /// </param>
    /// <remarks>
    ///     Processor implementations should override this method.
    /// </remarks>
    /**/
    virtual void sync_send(message<_Type> * _Msg) = 0;

    /// <summary>
    ///     When overridden in a derived class, waits for all asynchronous operations to complete.
    /// </summary>
    /// <remarks>
    ///     Processor implementations should override this method.
    /// </remarks>
    /**/
    virtual void wait() = 0;

protected:

    /// <summary>
    ///     When overridden in a derived class, performs the forward processing of
    ///     messages into the block. Called once every time a new message is added and
    ///     the queue is found to be empty.
    /// </summary>
    /// <remarks>
    ///     Message block implementations should override this method.
    /// </remarks>
    /**/
    virtual void process_incoming_message() = 0;

    /// <summary>
    ///     Wrapper for <c>process_incoming_message</c> suitable for use as a argument to
    ///     <c>CreateThread</c> and other similar methods.
    /// </summary>
    /// <param name="_Data">
    ///     A pointer to a message processor passed as a void pointer.
    /// </param>
    /**/
    static void __cdecl _Process_incoming_message_wrapper(void * _Data)
    {
       message_processor<_Type> * _PMessageProcessor = (message_processor<_Type> *) _Data;
       _PMessageProcessor->process_incoming_message();
    }
};

/// <summary>
///     An <c>ordered_message_processor</c> is a <c>message_processor</c> that allows message blocks
///     to process messages in the order they were received.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of messages handled by the processor.
/// </typeparam>
/**/
template<class _Type>
class ordered_message_processor : public message_processor<_Type>
{
public:

    /// <summary>
    ///     The signature of the callback method invoked while processing messages.
    /// </summary>
    /**/
    typedef std::tr1::function<void(message<_Type> *)>  _Handler_method;

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef _Type type;

    /// <summary>
    ///     Constructs an <c>ordered_message_processor</c> object.
    /// </summary>
    /// <remarks>
    ///     This <c>ordered_message_processor</c> will not schedule asynchronous or synchronous
    ///     handlers until the <c>initialize</c> function is called.
    /// </remarks>
    /**/
    ordered_message_processor() :
      _M_queuedDataCount(0),
      _M_stopProcessing(1),
      _M_lwtCount(0),
      _M_pScheduler(NULL),
      _M_pScheduleGroup(NULL),
      _M_handler(NULL)
    {
    }

    /// <summary>
    ///     Destroys the <c>ordered_message_processor</c> object.
    /// </summary>
    /// <remarks>
    ///     Waits for all outstanding asynchronous operations before destroying the processor.
    /// </remarks>
    /**/
    virtual ~ordered_message_processor()
    {
        wait();
    }

    /// <summary>
    ///     Initializes the <c>ordered_message_processor</c> object with the appropriate
    ///     callback function, scheduler and schedule group.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A pointer to the scheduler to be used for scheduling light-weight tasks.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     A pointer to the schedule group to be used for scheduling light-weight tasks.
    /// </param>
    /// <param name="_Handler">
    ///     The handler functor invoked during callback.
    /// </param>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    void initialize(Scheduler * _PScheduler, ScheduleGroup * _PScheduleGroup, _Handler_method const& _Handler)
    {
        _M_pScheduler = _PScheduler;
        _M_pScheduleGroup = _PScheduleGroup;
        _M_handler = _Handler;
        _M_stopProcessing = 0;
    }

    /// <summary>
    ///     Synchronously queues up messages and starts a processing task, if this has not been done
    ///     already.
    /// </summary>
    /// <param name="_Msg">
    ///     A pointer to a message.
    /// </param>
    /**/
    virtual void sync_send(message<_Type> * _Msg)
    {
         if (_M_handler == NULL)
         {
             throw invalid_operation("sync_send called without registering a callback");
         }

        // Indicate that an LWT is in progress. This will cause the
        // destructor to block.
        _InterlockedIncrement(&_M_lwtCount);

        // Message block destructors sets the _M_stopProcessing flag to stop
        // processing any more messages. This is required to guarantee
        // that the destructor's wait_for_async_sends will complete

        if (_M_stopProcessing != 0)
        {
            // Destructor is running. Do not process the message
            // Delete the msg, if any.
            if (_Msg != NULL)
            {
                delete _Msg;
            }
        }
        else
        {
            if (_Msg != NULL)
            {
                _M_queuedMessages._Enqueue(_Msg);
            }

            _InterlockedIncrement(&_M_queuedDataCount);

            _Process_message_helper();
        }

        // If we get there then no task was scheduled. Decrement LWT count to reflect this fact
        _InterlockedDecrement(&_M_lwtCount);
    }

    /// <summary>
    ///     Asynchronously queues up messages and starts a processing task, if this has not been done
    ///     already.
    /// </summary>
    /// <param name="_Msg">
    ///     A pointer to a message.
    /// </param>
    /**/
    virtual void async_send(message<_Type> * _Msg)
    {
         if (_M_handler == NULL)
         {
             throw invalid_operation("async_send called without registering a callback");
         }

        // Indicate that an LWT is in progress. This will cause the
        // destructor to block.
        _InterlockedIncrement(&_M_lwtCount);

        // Message block destructors sets the _M_stopProcessing flag to stop
        // processing any more messages. This is required to guarantee
        // that the destructor's wait_for_async_Sends will complete
        if (_M_stopProcessing != 0)
        {
            // Destructor is running. Do not scheduler an LWT.
            // Delete the msg, if any.
            if (_Msg != NULL)
            {
                delete _Msg;
            }
        }
        else
        {
            //
            // If there is a message to send, enqueue it in the processing queue.
            // async_send can be sent a NULL message if the block wishes to reprocess
            // the messages that are in its queue.  For example, an unbounded_buffer
            // that has its head node released after reservation.
            //
            if (_Msg != NULL)
            {
                _M_queuedMessages._Enqueue(_Msg);
            }

            if (_InterlockedIncrement(&_M_queuedDataCount) == 1)
            {

                _ASSERTE(_M_lwtCount > 0);

                TaskProc _Proc = &::Concurrency::ordered_message_processor<_Type>::_Process_incoming_message_wrapper;
                if (_M_pScheduleGroup != NULL)
                {
                    _M_pScheduleGroup->ScheduleTask(_Proc, this);
                }
                else if (_M_pScheduler != NULL)
                {
                    _M_pScheduler->ScheduleTask(_Proc, this);
                }
                else
                {
                    CurrentScheduler::ScheduleTask(_Proc, this);
                }

                // The LWT will decrement _M_lwtCount.
                return;
            }

        }

        // If we get here then no task was scheduled. Decrement LWT count to reflect this fact
        _InterlockedDecrement(&_M_lwtCount);
    }

    /// <summary>
    ///     A processor-specific spin wait used in destructors of message blocks to make sure
    ///     that all asynchronous processing tasks have time to finish before destroying the block.
    /// </summary>
    /**/
    virtual void wait()
    {
        // Cease processing of any new messages
        _InterlockedIncrement(&_M_stopProcessing);

        // This spin is here waiting to make sure all previously initiated message processings
        // will still correctly process.  As soon as this count reaches zero, we can
        // procede with the message block destructor.
        ::Concurrency::details::_SpinWaitBackoffNone spinWait(Context::Yield);
        while(_M_lwtCount != 0)
        {
            spinWait._SpinOnce();
        }
    }

protected:
    /// <summary>
    ///     The processing function that is called asynchronously.  It dequeues messages and begins
    ///     processing them.
    /// </summary>
    /**/
    virtual void process_incoming_message()
    {
        _Process_message_helper();

        // Indicate that an LWT completed
        _InterlockedDecrement(&_M_lwtCount);

        // Do not access any members here. If the count goes to
        // 0 as a result of the above decrement, the object
        // could be immediately deleted.
    }

 private:

    // Helper function to dequeue and process messages to any targets
    void _Process_message_helper()
    {
        _NR_lock _Lock(_M_internalLock);

        // This count could be 0 if there was both a synchronous and asynchronous
        // send occuring.  One of them could have sent all of the messages for the other
        if (_M_queuedDataCount == 0)
        {
            return;
        }

        do
        {
            message<_Type> * _Msg = _M_queuedMessages._Dequeue();
            _M_handler(_Msg);
        }
        while(_InterlockedDecrement(&_M_queuedDataCount) > 0);
    }

private:
    /// <summary>
    ///     The scheduler to process messages on
    /// </summary>
    /**/
    Scheduler * _M_pScheduler;

    /// <summary>
    ///     The schedule group to process messages on
    /// </summary>
    /**/
    ScheduleGroup * _M_pScheduleGroup;

    /// <summary>
    ///     A queue of the messages
    /// </summary>
    /**/
    ::Concurrency::details::_Async_send_queue<message<_Type>> _M_queuedMessages;

    /// <summary>
    ///     A lock to use for queueing incoming messages.
    /// </summary>
    /**/
    ::Concurrency::details::_NonReentrantPPLLock _M_internalLock;

    /// <summary>
    ///     A count of the current number of messages to process.  Used as a flag
    ///     to see if a new process message task needs to be created.
    /// </summary>
    /**/
    volatile long _M_queuedDataCount;

    /// <summary>
    ///     A flag set in the destructor of a block to cease processing of new messages.
    ///     This is required to guarantee that _M_queuedDataCount will get to 0 eventually.
    /// </summary>
    /**/
    volatile long _M_stopProcessing;

    /// <summary>
    ///     A counter to indicate the number of outstanding LWTs
    /// </summary>
    /**/
    volatile long _M_lwtCount;

    /// <summary>
    ///     A message handler object which expose the callback to be invoked
    /// </summary>
    /**/
    _Handler_method _M_handler;
};

/// <summary>
///     The <c>ITarget</c> class is the interface for all target blocks.  Target blocks
///     consume messages offered to them by <c>ISource</c> blocks.
/// </summary>
/// <typeparam name="_Type">
///     The data type of the payload within the messages accepted by the target block.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="ISource Class"/>
/**/
template<class _Type>
class ITarget
{
    //
    // ISource<T> is a friend class because calls to Source->link_target()
    // and Source->unlink_target() need to call their respective
    // Target->link_source() and Target->unlink_source() on the block they are
    // linking/unlinking.  Those functions are private here because we don't
    // want users calling link_source() or unlink_source() directly.  link_source/
    // unlink_source don't call respective link_target/unlink_target because an
    // infinite loop would occur.
    //
    friend class ISource<_Type>;

public:
    /// <summary>
    ///     Destroys the <c>ITarget</c> object.
    /// </summary>
    /**/
    virtual ~ITarget() {}

    // It is important that calls to propagate do *not* take the same lock on an
    // internal message structure that is used by Consume and the LWT.  Doing so could
    // result in a deadlock with the Consume call.

    /// <summary>
    ///     When overridden in a derived class, asynchronously passes a message from a source block to
    ///     this target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.
    /// </remarks>
    /**/
    virtual message_status propagate(message<_Type> * _PMessage, ISource<_Type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, synchronously passes a message to the target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.
    ///     <para>Using the <c>send</c> method outside of message initiation and to propagate messages
    ///     within a network is dangerous and can lead to deadlock.</para>
    ///     <para>When <c>send</c> returns, the message has either already been accepted, and transferred into
    ///     the target block, or it has been declined by the target.</para>
    /// </remarks>
    /**/
    virtual message_status send(message<_Type> * _PMessage, ISource<_Type> * _PSource) = 0;

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

    /// <summary>
    ///     The signature of any method used by the block that returns a <c>bool</c> value to determine
    ///     whether an offered message should be accepted.
    /// </summary>
    /**/
    typedef std::tr1::function<bool(_Type const&)> filter_method;

protected:

    /// <summary>
    ///     When overridden in a derived class, links a specified source block to this <c>ITarget</c> block.
    /// </summary>
    /// <param name="_PSource">
    ///     The <c>ISource</c> block being linked to this <c>ITarget</c> block.
    /// </param>
    /// <remarks>
    ///     This function should not be called directly on an <c>ITarget</c> block. Blocks should be connected together
    ///     using the <c>link_target</c> method on <c>ISource</c> blocks, which will invoke the <c>link_source</c> method
    ///     on the corresponding target.
    /// </remarks>
    /**/
    virtual void link_source(ISource<_Type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, unlinks a specified source block from this <c>ITarget</c> block.
    /// </summary>
    /// <param name="_PSource">
    ///     The <c>ISource</c> block being unlinked from this <c>ITarget</c> block.
    /// </param>
    /// <remarks>
    ///     This function should not be called directly on an <c>ITarget</c> block. Blocks should be disconnected
    ///     using the <c>unlink_target</c> or <c>unlink_targets</c> methods on <c>ISource</c> blocks, which will invoke
    ///     the <c>unlink_source</c> method on the corresponding target.
    /// </remarks>
    /**/
    virtual void unlink_source(ISource<_Type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, unlinks all source blocks from this <c>ITarget</c> block.
    /// </summary>
    /**/
    virtual void unlink_sources() = 0;
};

/// <summary>
///     The <c>ISource</c> class is the interface for all source blocks.  Source blocks
///     propagate messages to <c>ITarget</c> blocks.
/// </summary>
/// <typeparam name="_Type">
///     The data type of the payload within the messages produced by the source block.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="ITarget Class"/>
/**/
template<class _Type>
class ISource
{
public:
    /// <summary>
    ///     Destroys the <c>ISource</c> object.
    /// </summary>
    /**/
    virtual ~ISource() {}

    /// <summary>
    ///     When overridden in a derived class, links a target block to this <c>ISource</c> block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block being linked to this <c>ISource</c> block.
    /// </param>
    /**/
    virtual void link_target(ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, unlinks a target block from this <c>ISource</c> block,
    ///     if found to be previously linked.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block being unlinked from this <c>ISource</c> block.
    /// </param>
    /**/
    virtual void unlink_target(ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, unlinks all target blocks from this
    ///     <c>ISource</c> block.
    /// </summary>
    /**/
    virtual void unlink_targets() = 0;

    /// <summary>
    ///     When overridden in a derived class, accepts a message that was offered by this <c>ISource</c> block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>accept</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>accept</c> method is called by a target while a message is being offered by this <c>ISource</c> block.
    ///     The message pointer returned may be different from the one passed into the <c>propagate</c> method
    ///     of the <c>ITarget</c> block, if this source decides to make a copy of the message.
    /// </remarks>
    /**/
    virtual message<_Type> * accept(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, reserves a message previously offered by this <c>ISource</c> block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>reserve</c> method.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise. Reservations can fail
    ///     for many reasons, including: the message was already reserved or accepted by another target, the source could
    ///     deny reservations, etc.
    /// </returns>
    /// <remarks>
    ///     After you call <c>reserve</c>, if it succeeds, you must call either <c>consume</c> or <c>release</c>
    ///     in order to take or give up possession of the message, respectively.
    /// </remarks>
    /**/
    virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, consumes a message previously offered by this <c>ISource</c> block
    ///     and successfully reserved by the target, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>consume</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>consume</c> method is similar to <c>accept</c>, but must always be preceded by a call to <c>reserve</c> that
    ///     returned <c>true</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, releases a previous successful message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>release</c> method.
    /// </param>
    /**/
    virtual void release(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, acquires a reference count on this <c>ISource</c> block, to prevent deletion.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being linked to this source
    ///     during the <c>link_target</c> method.
    /// </remarks>
    /**/
    virtual void acquire_ref(ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     When overridden in a derived class, releases a reference count on this <c>ISource</c> block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being unlinked from this source.
    ///     The source block is allowed to release any resources reserved for the target block.
    /// </remarks>
    /**/
    virtual void release_ref(ITarget<_Type> * _PTarget) = 0;

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type source_type;

protected:
    /// <summary>
    ///     Links this source to a target.
    /// </summary>
    /// <param name="_PLinkFrom">
    ///     A pointer to the target.
    /// </param>
    /// <remarks>
    ///     This function definition is required because ISource blocks need to call
    ///     Target->link_source(), which is a private memeber of ITarget.  ISource is
    ///     declared as a friend class, so this is an way for derived classes of ISource
    ///     to properly link/unlink their targets during link_target(), unlink_target() and
    ///     unlink_targets()
    /// </remarks>
    /**/
    void _Invoke_link_source(ITarget<_Type> * _PLinkFrom)
    {
        _PLinkFrom->link_source(this);
    }

    /// <summary>
    ///     Unlinks this source from a target.
    /// </summary>
    /// <param name="_PUnlinkFrom">
    ///     A pointer to the target.
    /// </param>
    /// <remarks>
    ///     This function definition is required because ISource blocks need to call
    ///     Target->unlink_source(), which is a private memeber of ITarget.  ISource is
    ///     declared as a friend class, so this is an way for derived classes of ISource
    ///     to properly link/unlink their targets during link_target(), unlink_target() and
    ///     unlink_targets()
    /// </remarks>
    /**/
    void _Invoke_unlink_source(ITarget<_Type> * _PUnlinkFrom)
    {
        _PUnlinkFrom->unlink_source(this);
    }
};

//**************************************************************************
// Target Block:
//**************************************************************************

/// <summary>
///     The <c>target_block</c> class is an abstract base class that provides basic link management
///     functionality and error checking for target only blocks.
/// </summary>
/// <typeparam name="_SourceLinkRegistry">
///     The link registry to be used for holding the source links.
/// </typeparam>
/// <typeparam name="_MessageProcessorType">
///     The processor type for message processing.
/// </typeparam>
/// <seealso cref="ITarget Class"/>
/**/
template<class _SourceLinkRegistry,
    class _MessageProcessorType = ordered_message_processor<typename _SourceLinkRegistry::type::source_type>>
class target_block : public ITarget<typename _SourceLinkRegistry::type::source_type>
{
public:

    /// <summary>
    ///     The type of the payload for the incoming messages to this <c>target_block</c> object.
    /// </summary>
    /**/
    typedef typename _SourceLinkRegistry::type::source_type _Source_type;

    /// <summary>
    ///     The type of the <c>source_link_manager</c> this <c>target_block</c> object.
    /// </summary>
    /**/
    typedef source_link_manager<_SourceLinkRegistry> _SourceLinkManager;

    /// <summary>
    ///     The type of the iterator for the <c>source_link_manager</c> for this <c>target_block</c> object.
    /// </summary>
    /**/
    typedef typename _SourceLinkManager::iterator source_iterator;

    /// <summary>
    ///     Constructs a <c>target_block</c> object.
    /// </summary>
    /**/
    target_block() : _M_pFilter(NULL), _M_fDeclineMessages(false)
    {
    }

    /// <summary>
    ///     Destroys the <c>target_block</c> object.
    /// </summary>
    /**/
    virtual ~target_block()
    {
        // All sources should have been unlinked
        _ASSERTE(_M_connectedSources.count() == 0);
        delete _M_pFilter;
    }

    /// <summary>
    ///     Asynchronously passes a message from a source block to this target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     <para> The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.</para>
    /// </remarks>
    /**/
    virtual message_status propagate(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by <c>consume</c> and the LWT.  Doing so could
        // result in a deadlock.

        if (_PMessage == NULL)
        {
            throw std::invalid_argument("_PMessage");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        if (_M_fDeclineMessages)
        {
            return declined;
        }

        if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
        {
            return declined;
        }

        return propagate_message(_PMessage, _PSource);
    }

    /// <summary>
    ///     Synchronously passes a message from a source block to this target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.
    ///     <para>Using the <c>send</c> method outside of message initiation and to propagate messages
    ///     within a network is dangerous and can lead to deadlock.</para>
    ///     <para>When <c>send</c> returns, the message has either already been accepted, and transferred into
    ///     the target block, or it has been declined by the target.</para>
    /// </remarks>
    /**/
    virtual message_status send(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource)
    {
        if (_PMessage == NULL)
        {
            throw std::invalid_argument("_PMessage");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        if (_M_fDeclineMessages)
        {
            return declined;
        }

        if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
        {
            return declined;
        }

        return send_message(_PMessage, _PSource);
    }

protected:

    /// <summary>
    ///     When overridden in a derived class, this method asynchronously passes a message from an <c>ISource</c>
    ///     block to this <c>target_block</c> object. It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, this method synchronously passes a message from an <c>ISource</c>
    ///     block to this <c>target_block</c> object. It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     By default, this block returns <c>declined</c> unless overridden by a derived class.
    /// </remarks>
    /**/
    virtual message_status send_message(message<_Source_type> *, ISource<_Source_type> *)
    {
        // By default we do not allow send()
        return declined;
    }

    /// <summary>
    ///     Links a specified source block to this <c>target_block</c> object.
    /// </summary>
    /// <param name="_PSource">
    ///     A pointer to the <c>ISource</c> block that is to be linked.
    /// </param>
    /// <remarks>
    ///     This function should not be called directly on a <c>target_block</c> object. Blocks should be connected together
    ///     using the <c>link_target</c> method on <c>ISource</c> blocks, which will invoke the <c>link_source</c> method
    ///     on the corresponding target.
    /// </remarks>
    /**/
    virtual void link_source(ISource<_Source_type> * _PSource)
    {
        _M_connectedSources.add(_PSource);
    }

    /// <summary>
    ///     Unlinks a specified source block from this <c>target_block</c> object.
    /// </summary>
    /// <param name="_PSource">
    ///     A pointer to the <c>ISource</c> block that is to be unlinked.
    /// </param>
    ///     This function should not be called directly on n <c>target_block</c> object. Blocks should be disconnected
    ///     using the <c>unlink_target</c> or <c>unlink_targets</c> methods on <c>ISource</c> blocks, which will invoke
    ///     the <c>unlink_source</c> method on the corresponding target.
    /**/
    virtual void unlink_source(ISource<_Source_type> * _PSource)
    {
        _M_connectedSources.remove(_PSource);
    }

    /// <summary>
    ///     Unlinks all source blocks from this <c>target_block</c> object.
    /// </summary>
    /**/
    virtual void unlink_sources()
    {
        for (source_iterator _Iter = _M_connectedSources.begin(); *_Iter != NULL; ++_Iter)
        {
             ISource<_Source_type> * _PSource = *_Iter;
             _PSource->unlink_target(this);
        }
    }

    /// <summary>
    ///     When overriden in a derived class, processes a message that was accepted by this <c>target_block</c> object.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message that is to be handled.
    /// </param>
    /**/
    virtual void process_message(message<_Source_type> *)
    {
    }

    //
    // Utility routines
    //

    /// <summary>
    ///     Registers a filter method that will be invoked on
    ///     every message received.
    /// </summary>
    /// <param name="_Filter">
    ///     The filter method.
    /// </param>
    /**/
    void register_filter(filter_method const& _Filter)
    {
        if (_Filter != NULL)
        {
            _M_pFilter = new filter_method(_Filter);
        }
    }

    /// <summary>
    ///     Indicates to the block that new messages should be declined.
    /// </summary>
    /// <remarks>
    ///     This method is called by the destructor to ensure that new messages are declined while destruction is in progress.
    /// </remarks>
    /**/
    void decline_incoming_messages()
    {
        _M_fDeclineMessages = true;
    }

    /// <summary>
    ///     Initializes the base object. Specifically, the <c>message_processor</c> object needs
    ///     to be initialized.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The scheduler to be used for scheduling tasks.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     The schedule group to be used for scheduling tasks.
    /// </param>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    void initialize_target(Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        // Register a callback with the processor
        _M_messageProcessor.initialize(_PScheduler, _PScheduleGroup, [this](message<_Source_type> * _PMessage)
        {
            this->process_message(_PMessage);
        });

        // Register this target block as the owner of the connected sources
        _M_connectedSources.register_target_block(this);
    }

    /// <summary>
    ///     Asynchronously sends a message for processing.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message being sent.
    /// </param>
    /**/
    void async_send(message<_Source_type> * _PMessage)
    {
        _M_messageProcessor.async_send(_PMessage);
    }

    /// <summary>
    ///     Synchronously send a message for processing.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message being sent.
    /// </param>
    /**/
    void sync_send(message<_Source_type> * _PMessage)
    {
        _M_messageProcessor.sync_send(_PMessage);
    }

    /// <summary>
    ///     Waits for all asynchronous propagations to complete.
    /// </summary>
    /// <remarks>
    ///     This method is used by message block destructors to ensure all asynchronous operations
    ///     have had time to finish before destroying the block.
    /// </remarks>
    /**/
    void wait_for_async_sends()
    {
        // Decline new messages to ensure that messages are not dropped during the wait
        decline_incoming_messages();

        _M_messageProcessor.wait();
    }

    /// <summary>
    ///     Unlinks all sources after waiting for outstanding asynchronous send operations to complete.
    /// </summary>
    /// <remarks>
    ///     All target blocks should call this routine to remove the sources in their destructor.
    /// </remarks>
    /**/
    void remove_sources()
    {
        wait_for_async_sends();

        unlink_sources();
    }

    /// <summary>
    ///     The container for all the sources connected to this block.
    /// </summary>
    /**/
    _SourceLinkManager _M_connectedSources;

    /// <summary>
    ///     The filter function which determines whether offered messages should be accepted.
    /// </summary>
    /**/
    filter_method * _M_pFilter;

    /// <summary>
    ///     A <c>bool</c> that is set to indicate that all messages should be declined
    ///     in preparation for deleting the block
    /// <summary>
    /**/
    bool _M_fDeclineMessages;

    /// <summary>
    ///     The <c>message_processor</c> for this <c>target_block</c>.
    /// <summary>
    /**/
    _MessageProcessorType _M_messageProcessor;
};

//**************************************************************************
// Source Block:
//**************************************************************************

/// <summary>
///     The <c>source_block</c> class is an abstract base class for source-only blocks. The class
///     provides basic link management functionality as well as common error checks.
/// </summary>
/// <typeparam name="_TargetLinkRegistry">
///     Link registry to be used for holding the target links.
/// </typeparam>
/// <typeparam name="_MessageProcessorType">
///     Processor type for message processing.
/// </typeparam>
/// <remarks>
///     Message blocks should derive from this block to take advantage of link management and
///     synchronization provided by this class.
/// </remarks>
/// <seealso cref="ISource Class"/>
/**/
template<class _TargetLinkRegistry,
    class _MessageProcessorType = ordered_message_processor<typename _TargetLinkRegistry::type::type>>
class source_block : public ISource<typename _TargetLinkRegistry::type::type>
{
public:

    /// <summary>
    ///     The payload type of messages handled by this <c>source_block</c>.
    /// </summary>
    /**/
    typedef typename _TargetLinkRegistry::type::type _Target_type;

    /// <summary>
    ///     The iterator to walk the connected targets.
    /// </summary>
    /**/
    typedef typename _TargetLinkRegistry::iterator target_iterator;

    /// <summary>
    ///     Constructs a <c>source_block</c> object.
    /// </summary>
    /**/
    source_block() :
      _M_pReservedFor(NULL),
      _M_reservedId(0),
      _M_referenceCount(0)
    {
    }

    /// <summary>
    ///     Destroys the <c>source_block</c> object.
    /// </summary>
    /**/
    virtual ~source_block()
    {
        // All targets should have been unlinked
        _ASSERTE(_M_connectedTargets.count() == 0);
    }

    /// <summary>
    ///     Links a target block to this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to link to this <c>source_block</c> object.
    /// </param>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    virtual void link_target(ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        _M_connectedTargets.add(_PTarget);
        _Invoke_link_source(_PTarget);
        link_target_notification(_PTarget);

    }

    /// <summary>
    ///     Unlinks a target block from this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to unlink from this <c>source_block</c> object.
    /// </param>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    /// </remarks>
    /**/
    virtual void unlink_target(ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        if (_M_connectedTargets.remove(_PTarget))
        {
            // We were able to remove the target from our list.
            // Inform the target to unlink from us
            _Invoke_unlink_source(_PTarget);
        }
    }

    /// <summary>
    ///     Unlinks all target blocks from this <c>source_block</c> object.
    /// </summary>
    /**/
    virtual void unlink_targets()
    {
        _R_lock _Lock(_M_internalLock);

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            ITarget<_Target_type> * _PTarget = *_Iter;
            _ASSERTE(_PTarget != NULL);

            unlink_target(_PTarget);
        }

        // All the targets should be unlinked.
        _ASSERTE(_M_connectedTargets.count() == 0);
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>source_block</c> object, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>accept</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    ///     <para>
    ///     The <c>accept</c> method is called by a target while a message is being offered by this <c>ISource</c> block.
    ///     The message pointer returned may be different from the one passed into the <c>propagate</c> method
    ///     of the <c>ITarget</c> block, if this source decides to make a copy of the message.
    ///     </para>
    /// </remarks>
    /**/
    virtual message<_Target_type> * accept(runtime_object_identity _MsgId, ITarget<_Target_type> * _PTarget)
    {
        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        // Assert if the target is not connected
        _ASSERTE(_M_connectedTargets.contains(_PTarget));

        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>source_block</c> object.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>reserve</c> method.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise. Reservations can fail
    ///     for many reasons, including: the message was already reserved or accepted by another target, the source could
    ///     deny reservations, etc.
    /// </returns>
    /// <remarks>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    ///     <para>
    ///     After you call <c>reserve</c>, if it succeeds, you must call either <c>consume</c> or <c>release</c>
    ///     in order to take or give up possession of the message, respectively.
    ///     </para>
    /// </remarks>
    /**/
    virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        if ( _M_pReservedFor != NULL)
        {
            // Someone else is holding the reservation
            return false;
        }

        if (!reserve_message(_MsgId))
        {
            // Failed to reserve the msg id
            return false;
        }

        // Save the reserving target and the msg id
        _M_pReservedFor = _PTarget;
        _M_reservedId = _MsgId;

        return true;
    }

    /// <summary>
    ///     Consumes a message previously offered by this <c>source_block</c> object and successfully reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>consume</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     <para>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    ///     </para>
    ///     <para>
    ///     The method throws a <see cref="bad_target Class">bad_target</see> exception if the parameter <paramref name="_PTarget"/>
    ///     does not represent the target that called <c>reserve</c>.
    ///     </para>
    ///     <para>
    ///     The <c>consume</c> method is similar to <c>accept</c>, but must always be preceded by a call to <c>reserve</c> that
    ///     returned <c>true</c>.
    ///     </para>
    /// </remarks>
    /**/
    virtual message<_Target_type> * consume(runtime_object_identity _MsgId, ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        if (_M_pReservedFor == NULL || _PTarget != _M_pReservedFor)
        {
            throw bad_target();
        }

        message<_Target_type> * _Msg = consume_message(_MsgId);

        if (_Msg != NULL)
        {
            // Clear the reservation
            // _M_pReservedId is intentionally not reset so that it can assist in debugging
            _M_pReservedFor = NULL;

            // Reservation is assumed to block propagation. Notify that propagation can now be resumed
            resume_propagation();
        }

        return _Msg;
    }

    /// <summary>
    ///     Releases a previous successful message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>release</c> method.
    /// </param>
    /// <remarks>
    ///     <para>
    ///     The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if the
    ///     parameter <paramref name="_PTarget"/> is <c>NULL</c>.
    ///     </para>
    ///     <para>
    ///     The method throws a <see cref="bad_target Class">bad_target</see> exception if the parameter <paramref name="_PTarget"/>
    ///     does not represent the target that called <c>reserve</c>.
    ///     </para>
    /// </remarks>
    /**/
    virtual void release(runtime_object_identity _MsgId, ITarget<_Target_type> * _PTarget)
    {
        _R_lock _Lock(_M_internalLock);

        if (_PTarget == NULL)
        {
            throw std::invalid_argument("_PTarget");
        }

        if (_PTarget != _M_pReservedFor)
        {
            throw bad_target();
        }

        release_message(_MsgId);

        // Clear the reservation
        // _M_pReservedId is intentionally not reset so that it can assist in debugging
        _M_pReservedFor = NULL;

        // Reservation is assumed to block propagation. Notify that propagation can now be resumed
        resume_propagation();
    }

    /// <summary>
    ///     Acquires a reference count on this <c>source_block</c> object, to prevent deletion.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being linked to this source
    ///     during the <c>link_target</c> method.
    /// </remarks>
    /**/
    virtual void acquire_ref(ITarget<_Target_type> *)
    {
        _InterlockedIncrement(&_M_referenceCount);
    }

    /// <summary>
    ///     Releases a reference count on this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being unlinked from this source.
    ///     The source block is allowed to release any resources reserved for the target block.
    /// </remarks>
    /**/
    virtual void release_ref(ITarget<_Target_type> * _PTarget)
    {
        if (_PTarget != NULL)
        {
            _R_lock _Lock(_M_internalLock);

            // We assume that each target would keep a single reference on its source, so
            // we call unlink target notification on every release. Otherwise, we would be
            // required to keep a reference count per target.
            // Note: unlink_target_notification can check the value of this _PTarget pointer, but
            // must not dereference it, as it may have already been deleted.
            unlink_target_notification(_PTarget);
        }

        _InterlockedDecrement(&_M_referenceCount);

        // It is *unsafe* to touch the "this" pointer after decrementing the reference count
    }

protected:

    //
    // Protected methods that a derived class can override to customize
    // the functionality
    //

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     The <c>ITarget</c> block that was linked.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Target_type> *)
    {
        // By default, we restart propagation if there is no pending resrvation
        if (_M_pReservedFor == NULL)
        {
            propagate_to_any_targets(NULL);
        }
    }

    /// <summary>
    ///     A callback that notifies that a target has been unlinked from this <c>source_block</c> object.
    /// </summary>
    /// <param name="_PTarget">
    ///     The <c>ITarget</c> block that was unlinked.
    /// </param>
    /**/
    virtual void unlink_target_notification(ITarget<_Target_type> * _PTarget)
    {
        // At this point, the target has already been disconnected from the
        // source.  It is safe to check the value of this pointer, but not
        // safe to dereference it, as it may have already been deleted.

        // If the target being unlinked is the one holding the reservation,
        // release the reservation
        if (_M_pReservedFor == _PTarget)
        {
            release(_M_reservedId, _PTarget);
        }
    }

    /// <summary>
    ///     When overridden in a derived class, accepts an offered message by the source.
    ///     Message blocks should override this method to validate the <paramref name="_MsgId"/> and
    ///     return a message.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     To transfer ownership, the original message pointer should be returned. To maintain
    ///     ownership, a copy of message payload needs to be made and returned.
    /// </remarks>
    /**/
    virtual message<_Target_type> * accept_message(runtime_object_identity _MsgId) = 0;

    /// <summary>
    ///     When overridden in a derived class, reserves a message previously offered by this
    ///     <c>source_block</c> object.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId) = 0;

    /// <summary>
    ///     When overridden in a derived class, consumes a message that was previously reserved.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Target_type> * consume_message(runtime_object_identity _MsgId) = 0;

    /// <summary>
    ///     When overridden in a derived class, releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId) = 0;

    /// <summary>
    ///     When overridden in a derived class, resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation() = 0;

    /// <summary>
    ///     When overridden in a derived class, propagates the given message to any or all of the linked targets.
    ///     This is the main propagation routine for message blocks.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message that is to be propagated.
    /// </param>
    /**/
    virtual void propagate_to_any_targets(message<_Target_type> * _PMessage) = 0;

    //
    // Utility routines
    //

    /// <summary>
    ///     Initializes the <c>message_propagator</c> within this <c>source_block</c>.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The scheduler to be used for scheduling tasks.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     The schedule group to be used for scheduling tasks.
    /// </param>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    void initialize_source(Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        // Register a callback
        _M_messageProcessor.initialize(_PScheduler, _PScheduleGroup, [this](message<_Target_type> * _PMessage)
        {
            this->_Handle_message(_PMessage);
        });
    }

    /// <summary>
    ///     Synchronously queues up messages and starts a propagation task, if this has not been done
    ///     already.
    /// </summary>
    /// <param name="_Msg">
    ///     A pointer to a <c>message</c> object to synchronously send.
    /// </param>
    /**/
    virtual void sync_send(message<_Target_type> * _Msg)
    {
        // Caller shall not be holding any locks when calling this routine
        _M_messageProcessor.sync_send(_Msg);
    }

    /// <summary>
    ///     Asynchronously queues up messages and starts a propagation task, if this has not been done
    ///     already
    /// </summary>
    /// <param name="_Msg">
    ///     A pointer to a <c>message</c> object to asynchronously send.
    /// </param>
    /**/
    virtual void async_send(message<_Target_type> * _Msg)
    {
        _M_messageProcessor.async_send(_Msg);
    }

    /// <summary>
    ///     Waits for all asynchronous propagations to complete. This propagator-specific spin wait is used
    ///     in destructors of message blocks to make sure that all asynchronous propagations have time to finish
    ///     before destroying the block.
    /// </summary>
    /**/
    void wait_for_outstanding_async_sends()
    {
        _M_messageProcessor.wait();
    }

    /// <summary>
    ///     Removes all target links for this source block. This should be called from the destructor.
    /// </summary>
    /**/
    void remove_targets()
    {
        // Wait for outstanding propagation to complete.
        wait_for_outstanding_async_sends();

        unlink_targets();

        _Wait_on_ref();
    }

    //
    // Protected members
    //

    /// <summary>
    ///     Connected target that is holding a reservation
    /// </summary>
    /**/
    ITarget<_Target_type> * _M_pReservedFor;

    /// <summary>
    ///     Reserved message ID
    /// </summary>
    /**/
    runtime_object_identity _M_reservedId;

    /// <summary>
    ///     Connected targets
    /// </summary>
    /**/
    _TargetLinkRegistry _M_connectedTargets;

    /// <summary>
    ///     Processor used for asynchronous message handling
    /// </summary>
    /**/
    _MessageProcessorType _M_messageProcessor;

private:

    /// Private methods


    // Message handler callback for the propagator. Invokes propagate_to_any_targets
    // which derived classes should implement.
    /**/
    void _Handle_message(message<_Target_type> * _PMessage)
    {
        // Hold a lock to synchronize with unlink targets
        _R_lock _Lock(_M_internalLock);
        propagate_to_any_targets(_PMessage);
    }

    // Wait for the reference on this block to drop to zero
    /**/
    void _Wait_on_ref(long _RefCount = 0)
    {
        ::Concurrency::details::_SpinWaitBackoffNone spinWait;
        while(_M_referenceCount != _RefCount)
        {
            spinWait._SpinOnce();
        }
    }

    // Private Data members

    /// <summary>
    ///     Internal lock used for the following synchronization:
    ///     1. Synchronize between link and unlink target
    ///     2. Synchronize between propagate_to_any_targets and unlink_target
    ///     3. Synchronize between reserve and consume/release
    /// </summary>
    /**/
    ::Concurrency::details::_ReentrantPPLLock _M_internalLock;

    volatile long _M_referenceCount;

};

//**************************************************************************
// Propagator (source and target) Block:
//**************************************************************************
/// <summary>
///     The <c>propagator_block</c> class is an abstract base class for message blocks that are both a source and target.
///     It combines the functionality of both the <c>source_block</c> and <c>target_block</c> classes.
/// </summary>
/// <typeparam name="_TargetLinkRegistry">
///     The link registry to be used for holding the target links.
/// </typeparam>
/// <typeparam name="_SourceLinkRegistry">
///     The link registry to be used for holding the source links.
/// </typeparam>
/// <typeparam name="_MessageProcessorType">
///     The processor type for message processing.
/// </typeparam>
/// <remarks>
///     To avoid multiple inheritance, the <c>propagator_block</c> class inherits from the <c>source_block</c> class and <c>ITarget</c>
///     abstract class.  Most of the functionality in the <c>target_block</c> class is replicated here.
/// </remarks>
/// <seealso cref="source_block Class"/>
/// <seealso cref="ITarget Class"/>
/**/
template<class _TargetLinkRegistry, class _SourceLinkRegistry,
    class _MessageProcessorType = ordered_message_processor<typename _TargetLinkRegistry::type::type>>
class propagator_block : public source_block<_TargetLinkRegistry, _MessageProcessorType>, public ITarget<typename _SourceLinkRegistry::type::source_type>
{
public:

    /// <summary>
    ///     The type of the payload for the incoming message to this <c>propagator_block</c>.
    /// </summary>
    /**/
    typedef typename _SourceLinkRegistry::type::source_type _Source_type;

    /// <summary>
    ///     The type of the <c>source_link_manager</c> this <c>propagator_block</c>.
    /// </summary>
    /**/
    typedef source_link_manager<_SourceLinkRegistry> _SourceLinkManager;

    /// <summary>
    ///     The type of the iterator for the <c>source_link_manager</c> for this <c>propagator_block</c>.
    /// </summary>
    /**/
    typedef typename _SourceLinkManager::iterator source_iterator;

    /// <summary>
    ///     Constructs a <c>propagator_block</c> object.
    /// </summary>
    /**/
    propagator_block() : _M_pFilter(NULL), _M_fDeclineMessages(false)
    {
    }

    /// <summary>
    ///     Destroys a <c>propagator_block</c> object.
    /// </summary>
    /**/
    virtual ~propagator_block()
    {
        remove_network_links();

        delete _M_pFilter;
    }

    /// <summary>
    ///     Asynchronously passes a message from a source block to this target block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     The <c>propagate</c> method is invoked on a target block by a linked source block. It queues up an
    ///     asynchronous task to handle the message, if one is not already queued or executing.
    ///     <para> The method throws an <see cref="invalid_argument Class">invalid_argument</see> exception
    ///     if either the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.</para>
    /// </remarks>
    /**/
    virtual message_status propagate(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by <c>consume</c> and the LWT.  Doing so could
        // result in a deadlock.

        if (_PMessage == NULL)
        {
            throw std::invalid_argument("_PMessage");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        if (_M_fDeclineMessages)
        {
            return declined;
        }

        if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
        {
            return declined;
        }

        return propagate_message(_PMessage, _PSource);
    }

    /// <summary>
    ///     Synchronously initiates a message to this block.  Called by an <c>ISource</c> block.
    ///     When this function completes, the message will already have propagated into the block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     This method throws an <see cref="invalid_argument Class">invalid_argument</see> exception if either
    ///     the <paramref name="_PMessage"/> or <paramref name="_PSource"/> parameter is <c>NULL</c>.
    /// </remarks>
    /**/
    virtual message_status send(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource)
    {
        if (_PMessage == NULL)
        {
            throw std::invalid_argument("_PMessage");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        if (_M_fDeclineMessages)
        {
            return declined;
        }

        if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
        {
            return declined;
        }

        return send_message(_PMessage, _PSource);
    }

protected:

    /// <summary>
    ///     When overridden in a derived class, this method asynchronously passes a message from an <c>ISource</c>
    ///     block to this <c>propagator_block</c> object. It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Source_type> * _PMessage, ISource<_Source_type> * _PSource) = 0;

    /// <summary>
    ///     When overridden in a derived class, this method synchronously passes a message from an <c>ISource</c>
    ///     block to this <c>propagator_block</c> object. It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     By default, this block returns <c>declined</c> unless overridden by a derived class.
    /// </remarks>
    /**/
    virtual message_status send_message(message<_Source_type> *, ISource<_Source_type> *)
    {
        // By default we do not allow send()
        return declined;
    }

    /// <summary>
    ///     Links a specified source block to this <c>propagator_block</c> object.
    /// </summary>
    /// <param name="_PSource">
    ///     A pointer to the <c>ISource</c> block that is to be linked.
    /// </param>
    /**/
    virtual void link_source(ISource<_Source_type> * _PSource)
    {
        _M_connectedSources.add(_PSource);
    }

    /// <summary>
    ///     Unlinks a specified source block from this <c>propagator_block</c> object.
    /// </summary>
    /// <param name="_PSource">
    ///     A pointer to the <c>ISource</c> block that is to be unlinked.
    /// </param>
    /**/
    virtual void unlink_source(ISource<_Source_type> * _PSource)
    {
        _M_connectedSources.remove(_PSource);
    }

    /// <summary>
    ///     Unlinks all source blocks from this <c>propagator_block</c> object.
    /// </summary>
    /**/
    virtual void unlink_sources()
    {
        for (source_iterator _Iter = _M_connectedSources.begin(); *_Iter != NULL; ++_Iter)
        {
             ISource<_Source_type> * _PSource = *_Iter;
             _PSource->unlink_target(this);
        }
    }

    //
    // Utility routines
    //

    /// <summary>
    ///     Initializes the base object. Specifically, the <c>message_processor</c> object needs
    ///     to be initialized.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The scheduler to be used for scheduling tasks.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     The schedule group to be used for scheduling tasks.
    /// </param>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    void initialize_source_and_target(Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        initialize_source(_PScheduler, _PScheduleGroup);

        // Register this propagator block as the owner of the connected sources
        _M_connectedSources.register_target_block(this);
    }

    /// <summary>
    ///     Registers a filter method that will be invoked on every received message.
    /// </summary>
    /// <param name="_Filter">
    ///     The filter method.
    /// </param>
    /**/
    void register_filter(filter_method const& _Filter)
    {
        if (_Filter != NULL)
        {
            _M_pFilter = new filter_method(_Filter);
        }
    }

    /// <summary>
    ///     Indicates to the block that new messages should be declined.
    /// </summary>
    /// <remarks>
    ///     This method is called by the destructor to ensure that new messages are declined while destruction is in progress.
    /// </remarks>
    /**/
    void decline_incoming_messages()
    {
        _M_fDeclineMessages = true;
    }

    /// <summary>
    ///     Removes all the source and target network links from this <c>propagator_block</c> object.
    /// </summary>
    /**/
    void remove_network_links()
    {
        // Decline messages while the links are being removed
        decline_incoming_messages();

        // Remove all the target links. This waits for
        // all outstanding async propagation operations.
        remove_targets();

        // unlink all sources. The above steps guarantee that
        // they can be removed safely.
        unlink_sources();
    }

    /// <summary>
    ///     The container for all the sources connected to this block.
    /// </summary>
    /**/
    _SourceLinkManager _M_connectedSources;

    /// <summary>
    ///     The filter function which determines whether offered messages should be accepted.
    /// </summary>
    /**/
    filter_method * _M_pFilter;

    /// <summary>
    ///     A <c>bool</c> that is set to indicate that all messages should be declined
    ///     in preparation for deleting the block
    /// <summary>
    /**/
    volatile bool _M_fDeclineMessages;
};

//**************************************************************************
// Unbounded Buffers:
//**************************************************************************

/// <summary>
///     An <c>unbounded_buffer</c> messaging block is a multi-target, multi-source, ordered
///     <c>propagator_block</c> capable of storing an unbounded number of messages.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the messages stored and propagated by the buffer.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="overwrite_buffer Class"/>
/// <seealso cref="single_assignment Class"/>
/**/
template<class _Type>
class unbounded_buffer : public propagator_block<multi_link_registry<ITarget<_Type>>, multi_link_registry<ISource<_Type>>>
{
public:
    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer()
    {
        initialize_source_and_target();
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(filter_method const& _Filter)
    {
        initialize_source_and_target();
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>unbounded_buffer</c> object is scheduled.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(Scheduler& _PScheduler)
    {
        initialize_source_and_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>unbounded_buffer</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(Scheduler& _PScheduler, filter_method const& _Filter)
    {
        initialize_source_and_target(&_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>unbounded_buffer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(ScheduleGroup& _PScheduleGroup)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs an <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>unbounded_buffer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>unbounded_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    unbounded_buffer(ScheduleGroup& _PScheduleGroup, filter_method const& _Filter)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Destroys the <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /**/
    ~unbounded_buffer()
    {
        // Remove all links
        remove_network_links();
    }

    /// <summary>
    ///     Adds an item to the <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_Item">
    ///     The item to add.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the item was accepted, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool enqueue(_Type const& _Item)
    {
        return Concurrency::send<_Type>(this, _Item);
    }

    /// <summary>
    ///     Removes an item from the <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <returns>
    ///     The payload of the message removed from the <c>unbounded_buffer</c>.
    /// </returns>
    /**/
    _Type dequeue()
    {
        return receive<_Type>(this);
    }


protected:

    //
    // propagator_block protected function implementations
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>unbounded_buffer</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by <c>consume</c> and the LWT.  Doing so could
        // result in a deadlock.

        message_status _Result = accepted;

        // Accept the message being propagated
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            async_send(_PMessage);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>unbounded_buffer</c> messaging block.
    ///     It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            sync_send(_PMessage);
        }
        else
        {
            return missed;
        }

        return accepted;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>unbounded_buffer</c> messaging block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Type> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // Peek at the head message in the message buffer.  If the IDs match
        // dequeue and transfer ownership
        //
        message<_Type> * _Msg = NULL;

        if (_M_messageBuffer._Is_head(_MsgId))
        {
            _Msg = _M_messageBuffer._Dequeue();
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Allow reservation if this is the head message
        return _M_messageBuffer._Is_head(_MsgId);
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>unbounded_buffer</c> messaging block and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume_message(runtime_object_identity _MsgId)
    {
        // By default, accept the message
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        // The head message is the one reserved.
        if (!_M_messageBuffer._Is_head(_MsgId))
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // If there are any messages in the buffer, propagate them out
        if (_M_messageBuffer._Count() > 0)
        {
            async_send(NULL);
        }
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>unbounded_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Type> * _PTarget)
    {
        // If the message queue is blocked due to reservation
        // there is no need to do any message propagation
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        message<_Type> * _Msg = _M_messageBuffer._Peek();

        if (_Msg != NULL)
        {
            // Propagate the head message to the new target
            message_status _Status = _PTarget->propagate(_Msg, this);

            if (_Status == accepted)
            {
                // The target accepted the message, restart propagation.
                propagate_to_any_targets(NULL);
            }

            // If the status is anything other than accepted, then leave
            // the message queue blocked.
        }
    }

    /// <summary>
    ///     Places the <c>message</c> <paramref name="_PMessage"/> in this <c>unbounded_buffer</c> messaging block and
    ///     tries to offer it to all of the linked targets.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a <c>message</c> object that this <c>unbounded_buffer</c> has taken ownership of.
    /// </param>
    /// <remarks>
    ///     If another message is already ahead of this one in the <c>unbounded_buffer</c>,
    ///     propagation to linked targets will not occur until any earlier messages have been accepted
    ///     or consumed. The first linked target to successfully <c>accept</c> or <c>consume</c> the
    ///     message takes ownership, and no other target can then get the message.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<_Type> * _PMessage)
    {
        // Move the message from the queuedMessages Buffer to the internal storage
        // Enqueue pMessage to the internal unbounded_buffer queue if it is non-NULL.
        // pMessage can be NULL if this LWT was the result of a repropagate call
        // out of a Consume or Release (where no new message is queued up, but
        // everything remaining in the unboundedbuffer needs to be propagated out)
        if (_PMessage != NULL)
        {
            _M_messageBuffer._Enqueue(_PMessage);

            // If the incoming pMessage is not the head message, we can safely assume that
            // the head message is blocked and waiting on Consume(), Release() or a new
            // link_target()
            if (!_M_messageBuffer._Is_head(_PMessage->msg_id()))
            {
                return;
            }
        }

        // Attempt to propagate messages to all the targets
        _Propagate_priority_order(_M_messageBuffer);
    }

private:

    /// <summary>
    ///     Propagates messages in priority order.
    /// </summary>
    /// <param name="_MessageBuffer">
    ///     Reference to a message queue with messages to be propagated
    /// </param>
    /**/
    void _Propagate_priority_order(::Concurrency::details::_Queue<message<_Target_type>> & _MessageBuffer)
    {
        message<_Target_type> * _Msg = _MessageBuffer._Peek();

        // If someone has reserved the _Head message, don't propagate anymore
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        while (_Msg != NULL)
        {
            message_status _Status = declined;

            // Always start from the first target that linked
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Target_type> * _PTarget = *_Iter;
                _Status = _PTarget->propagate(_Msg, this);

                // Ownership of message changed. Do not propagate this
                // message to any other target.
                if (_Status == accepted)
                {
                    break;
                }

                // If the target just propagated to reserved this message, stop
                // propagating it to others
                if (_M_pReservedFor != NULL)
                {
                    break;
                }
            }

            // If status is anything other than accepted, then the head message
            // was not propagated out.  Thus, nothing after it in the queue can
            // be propagated out.  Cease propagation.
            if (_Status != accepted)
            {
                break;
            }

            // Get the next message
            _Msg = _MessageBuffer._Peek();
        }
    }

    /// <summary>
    ///     Message queue used to store messages
    /// </summary>
    /**/
    ::Concurrency::details::_Queue<message<_Type>> _M_messageBuffer;

private:
    //
    // Hide assignment operator and copy constructor
    //
    unbounded_buffer const &operator =(unbounded_buffer const&);  // no assignment operator
    unbounded_buffer(unbounded_buffer const &);                   // no copy constructor
};

//**************************************************************************
// Overwrite Buffers:
//**************************************************************************

/// <summary>
///     An <c>overwrite_buffer</c> messaging block is a multi-target, multi-source, ordered
///     <c>propagator_block</c> capable of storing a single message at
///     a time. New messages overwrite previously held ones.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the messages stored and propagated by the buffer.
/// </typeparam>
/// <remarks>
///     An <c>overwrite_buffer</c> messaging block propagates out copies of its stored message to each of its targets.
///     <para>For more information, see <see cref="Asynchronous Message Blocks"/>.</para>
/// </remarks>
/// <seealso cref="unbounded_buffer Class"/>
/// <seealso cref="single_assignment Class"/>
/**/
template<class _Type>
class overwrite_buffer : public propagator_block<multi_link_registry<ITarget<_Type>>, multi_link_registry<ISource<_Type>>>
{
public:
    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer() :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target();
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target();
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>overwrite_buffer</c> messaging block is scheduled.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(Scheduler& _PScheduler) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>overwrite_buffer</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(Scheduler& _PScheduler,
        filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target(&_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>overwrite_buffer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(ScheduleGroup& _PScheduleGroup) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs an <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>overwrite_buffer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>overwrite_buffer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    overwrite_buffer(ScheduleGroup& _PScheduleGroup,
        filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL), _M_pReservedMessage(NULL)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Destroys the <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /**/
    ~overwrite_buffer()
    {
        // Remove all links that are targets of this overwrite_buffer
        remove_network_links();

        // The messages for an overwrite buffer are deleted when overwritten
        // through reference counting.  This final check is put in place in
        // case any message still exists in the buffer when the overwrite_buffer
        // is deleted.  The reference count of this message has not yet reached
        // zero since it hasn't been overwritten yet.  It is safe because of
        // we have finished all propagation.
        if (_M_pMessage != NULL)
        {
            // A block can only have a reserved message after receiving a message
            // at some point, so it must be within the above if-clause.
            // Now delete the reserved message if it is non-NULL and different from
            // the saved internal message
            if (_M_pReservedMessage != NULL && _M_pReservedMessage != _M_pMessage)
            {
                delete _M_pReservedMessage;
            }
            delete _M_pMessage;
        }
    }

    /// <summary>
    ///     Checks whether this <c>overwrite_buffer</c> messaging block has a value yet.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the block has received a value, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool has_value() const
    {
        return _M_fIsInitialized != 0;
    }

    /// <summary>
    ///     Gets a reference to the current payload of the message being stored in the <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <returns>
    ///     The payload of the currently stored message.
    /// </returns>
    /// <remarks>
    ///     The value stored in the <c>overwrite_buffer</c> could change immediately after this method returns. This method will
    ///     wait until a message arrives if no message is currently stored in the <c>overwrite_buffer</c>.
    /// </remarks>
    /**/
    _Type value()
    {
        return receive<_Type>(this);
    }

protected:

    //
    // propagator_block protected function implementation
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>overwrite_buffer</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Result = accepted;

        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        //
        // If message was accepted, set the member variables for
        // this block and start the asynchronous propagation task
        //
        if (_PMessage != NULL)
        {
            // Add a reference for the async_send holding the message
            _PMessage->add_ref();

            async_send(_PMessage);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>overwrite_buffer</c> messaging block.
    ///     It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        //
        // If message was accepted, set the member variables for
        // this block and start the asynchronous propagation task
        //
        if (_PMessage != NULL)
        {
            // Add a reference for the sync_send holding the message
            _PMessage->add_ref();

            sync_send(_PMessage);
        }
        else
        {
            return missed;
        }

        return accepted;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>overwrite_buffer</c> messaging block,
    ///     returning a copy of the message to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>overwrite_buffer</c> messaging block returns copies of the message
    ///     to its targets, rather than transferring ownership of the currently
    ///     held message.
    /// </remarks>
    /**/
    virtual message<_Type> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // If the internal message has not yet been initialized yet, return NULL
        //
        if (_M_pMessage == NULL)
        {
            return NULL;
        }

        //
        // Instead of returning the internal message, we return a copy of the
        // message stored.
        //
        // Since we are returning a copy, the accept routine for an overwritebuffer
        // does not need to grab the internalLock
        //
        message<_Type> * _Msg = NULL;
        if (_M_pMessage->msg_id() == _MsgId)
        {
            _Msg = new message<_Type>(_M_pMessage->payload);
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Ensure that this message currently exists in the overwrite buffer
        if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
        {
            return false;
        }

        // Can only reserve one message, any other blocks trying to reserve
        // will return false
        _ASSERTE(_M_pReservedMessage == NULL);

        // Save this message away
        _M_pReservedMessage = _M_pMessage;

        // Add a reference for this message to prevent deletion
        _M_pReservedMessage->add_ref();

        return true;
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>overwrite_buffer</c> messaging block and reserved by the target,
    ///     returning a copy of the message to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume_message(runtime_object_identity _MsgId)
    {
        // Leave and return NULL if this msgId doesn't match the reserved message
        // Otherwise this is a pull of a later overwritten message, and messages
        // could them appear out of order.
        if (_M_pReservedMessage != NULL && _M_pReservedMessage->msg_id() != _MsgId)
        {
            return NULL;
        }

        _Type _Payload = _M_pReservedMessage->payload;

        // Take the reserved message
        message<_Type> * _Result =  new message<_Type>(_Payload);

        if (_M_pReservedMessage->remove_ref() == 0)
        {
            delete _M_pReservedMessage;
        }
        _M_pReservedMessage = NULL;

        return _Result;
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        _ASSERTE(_M_fIsInitialized);
        _ASSERTE(_M_pReservedMessage != NULL);

        if (_MsgId != _M_pReservedMessage->msg_id())
        {
            throw message_not_found();
        }

        if (_M_pReservedMessage->remove_ref() == 0)
        {
            delete _M_pReservedMessage;
        }
        _M_pReservedMessage = NULL;
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // On reservation we do not stop propagation. So there
        // is nothing to be done to resume propagation.
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>overwrite_buffer</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Type> * _PTarget)
    {
        // If there is a message available already, propagate it
        if (_M_pMessage != NULL)
        {
            _PTarget->propagate(_M_pMessage, this);
        }
    }

    /// <summary>
    ///     Places the <c>message</c> <paramref name="_PMessage"/> in this <c>overwrite_buffer</c> messaging block and
    ///     offers it to all of the linked targets.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a <c>message</c> object that this <c>overwrite_buffer</c> has taken ownership of.
    /// </param>
    /// <remarks>
    ///     This method overwrites the current message in the <c>overwrite_buffer</c> with the newly
    ///     accepted message <paramref name="_PMessage"/>.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<_Type> * _PMessage)
    {
        // Move the message from the queuedMessages Buffer to the internal storage

        // Add a reference for the overwrite_buffer holding the message
        _PMessage->add_ref();

        if (_M_pMessage != NULL)
        {
            if (_M_pMessage->remove_ref() == 0)
            {
                delete _M_pMessage;
            }
        }

        _M_pMessage = _PMessage;

        // Now that message has been received, set this block as initialized
        _M_fIsInitialized = true;

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            // Overwrite buffers can propagate its message out
            // to any number of Targets

            ITarget<_Type> * _PTarget = *_Iter;
            _PTarget->propagate(_PMessage, this);
        }

        if (_PMessage->remove_ref() == 0)
        {
            delete _PMessage;
        }
    }

private:

    //
    //  Private Data Members
    //

    // The message being stored
    message<_Type> * _M_pMessage;

    // The message being reserved
    message<_Type> * _M_pReservedMessage;

    // The marker for whether the overwrite buffer has already been initialized
    volatile bool _M_fIsInitialized;

private:
    //
    // Hide assignment operator and copy constructor
    //
    overwrite_buffer const &operator =(overwrite_buffer const&);  // no assignment operator
    overwrite_buffer(overwrite_buffer const &);                   // no copy constructor
};

//**************************************************************************
// Call:
//**************************************************************************

/// <summary>
///     A <c>call</c> messaging block is a multi-source, ordered <c>target_block</c> that
///     invokes a specified function when receiving a message.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the messages propagated to this block.
/// </typeparam>
/// <typeparam name="_FunctorType">
///     The signature of functions that this block can accept.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="transformer Class"/>
/**/
template<class _Type, class _FunctorType = std::tr1::function<void(_Type const&)>>
class call : public target_block<multi_link_registry<ISource<_Type>>>
{
    /// <summary>
    ///     The function type that this block executes upon receiving a <c>message</c>.
    /// </summary>
    /**/
    typedef _FunctorType _Call_method;

public:
    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(_Call_method const& _Func) :
        _M_pFunc(_Func)
    {
        initialize_target();
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(_Call_method const& _Func,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_target();
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>call</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(Scheduler& _PScheduler,
        _Call_method const& _Func) :
        _M_pFunc(_Func)
    {
        initialize_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>call</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(Scheduler& _PScheduler,
        _Call_method const& _Func,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_target(&_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>call</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(ScheduleGroup& _PScheduleGroup,
        _Call_method const& _Func) :
        _M_pFunc(_Func)
    {
        initialize_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>call</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Call_method"/> is a functor with signature <c>void (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>call</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    call(ScheduleGroup& _PScheduleGroup,
        _Call_method const& _Func,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }
    /// <summary>
    ///    Destroys the <c>call</c> messaging block.
    /// </summary>
    /**/
    ~call()
    {
        remove_sources();
    }

protected:

    //
    // target_block protected function implementations
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>call</c> messaging block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Result = accepted;

        //
        // Accept the message being propagated
        // Note: depending on the source block propagating the message
        // this may not necessarily be the same message (pMessage) first
        // passed into the function.
        //
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            async_send(_PMessage);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>call</c> messaging block. It is invoked
    ///     by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        message_status _Result = accepted;

        //
        // Accept the message being propagated
        // Note: depending on the source block propagating the message
        // this may not necessarily be the same message (pMessage) first
        // passed into the function.
        //
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            sync_send(_PMessage);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Processes a message that was accepted by this <c>call</c> messaging block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the message that is to be handled.
    /// </param>
    /**/
    virtual void process_message(message<_Type> * _PMessage)
    {
        // Invoke the function provided by the user
        _ASSERTE(_PMessage != NULL);
        _M_pFunc(_PMessage->payload);
        delete _PMessage;
    }

private:

    //
    //  Private Data Members
    //

    // The call method called by this block
    _Call_method _M_pFunc;

private:
    //
    // Hide assignment operator and copy constructor
    //
    call const &operator =(call const&);  // no assignment operator
    call(call const &);                   // no copy constructor
};

//**************************************************************************
// Transformer:
//**************************************************************************

/// <summary>
///     A <c>transformer</c> messaging block is a single-target, multi-source, ordered
///     <c>propagator_block</c> which can accept messages of one type and is
///     capable of storing an unbounded number of messages of a different type.
/// </summary>
/// <typeparam name="_Input">
///     The payload type of the messages accepted by the buffer.
/// </typeparam>
/// <typeparam name="_Output">
///     The payload type of the messages stored and propagated out by the buffer.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="call Class"/>
/**/
template<class _Input, class _Output>
class transformer : public propagator_block<single_link_registry<ITarget<_Output>>, multi_link_registry<ISource<_Input>>>
{
    typedef std::tr1::function<_Output(_Input const&)> _Transform_method;

public:
    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(_Transform_method const& _Func,
        ITarget<_Output> * _PTarget = NULL) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target();

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transform.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(_Transform_method const& _Func,
        ITarget<_Output> * _PTarget,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target();
        register_filter(_Filter);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }


    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>transformer</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(Scheduler& _PScheduler,
        _Transform_method const& _Func,
        ITarget<_Output> * _PTarget = NULL) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target(&_PScheduler);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>transformer</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(Scheduler& _PScheduler,
        _Transform_method const& _Func,
        ITarget<_Output> * _PTarget,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target(&_PScheduler);
        register_filter(_Filter);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>transformer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(ScheduleGroup& _PScheduleGroup,
        _Transform_method const& _Func,
        ITarget<_Output> * _PTarget = NULL) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Constructs a <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>transformer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Func">
    ///     A function that will be invoked for each accepted message.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to a target block to link with the transformer.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="_Transform_method"/> is a functor with signature <c>_Output (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to process a message.</para>
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Input const &amp;)</c>
    ///     which is invoked by this <c>transformer</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    transformer(ScheduleGroup& _PScheduleGroup,
        _Transform_method const& _Func,
        ITarget<_Output> * _PTarget,
        filter_method const& _Filter) :
        _M_pFunc(_Func)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

    /// <summary>
    ///     Destroys the <c>transformer</c> messaging block.
    /// </summary>
    /**/
    ~transformer()
    {
        // Remove all links
        remove_network_links();
    }

protected:

    // Propagator_block protected function implementations

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>transformer</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Input> * _PMessage, ISource<_Input> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Result = accepted;

        //
        // Accept the message being propagated
        // Note: depending on the source block propagating the message
        // this may not necessarily be the same message (pMessage) first
        // passed into the function.
        //
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            // Enqueue the input message
            _M_inputMessages._Enqueue(_PMessage);
            async_send(NULL);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>transformer</c> messaging block.
    ///     It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Input> * _PMessage, ISource<_Input> * _PSource)
    {
        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        if (_PMessage != NULL)
        {
            // Enqueue the input message
            _M_inputMessages._Enqueue(_PMessage);
            sync_send(NULL);
        }
        else
        {
            return missed;
        }

        return accepted;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>transformer</c> messaging block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Output> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // Peek at the head message in the message buffer.  If the Ids match
        // dequeue and transfer ownership
        //
        message<_Output> * _Msg = NULL;

        if (_M_messageBuffer._Is_head(_MsgId))
        {
            _Msg = _M_messageBuffer._Dequeue();
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Allow reservation if this is the head message
        return _M_messageBuffer._Is_head(_MsgId);
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>transformer</c> and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Output> * consume_message(runtime_object_identity _MsgId)
    {
        // By default, accept the message
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        // The head message is the one reserved.
        if (!_M_messageBuffer._Is_head(_MsgId))
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // If there are any messages in the buffer, propagate them out
        if (_M_messageBuffer._Count() > 0)
        {
            async_send(NULL);
        }
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>transformer</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Output> *)
    {
        // If the message queue is blocked due to reservation
        // there is no need to do any message propagation
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

    /// <summary>
    ///     Executes the transformer function on the input message and
    ///     tries to offer the resulting message to all of the linked targets.
    /// </summary>
    /**/
    virtual void propagate_to_any_targets(message<_Output> *)
    {
        message<_Output> * _Msg = NULL;

        // Process input message.
        message<_Input> * _PInputMessage = _M_inputMessages._Dequeue();

        if (_PInputMessage != NULL)
        {
            // Invoke the TransformMethod on the data
            // Let exceptions flow
            _Output _Out = _M_pFunc(_PInputMessage->payload);

            _Msg = new message<_Output>(_Out);
            _M_messageBuffer._Enqueue(_Msg);

            // Message cleanup
            delete _PInputMessage;

            if (!_M_messageBuffer._Is_head(_Msg->msg_id()))
            {
                return;
            }
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

private:

    /// <summary>
    ///     Propagates messages in priority order.
    /// </summary>
    /// <param name="_MessageBuffer">
    ///     Reference to a message queue with messages to be propagated
    /// </param>
    /**/
    void _Propagate_priority_order(::Concurrency::details::_Queue<message<_Target_type>> & _MessageBuffer)
    {
        message<_Target_type> * _Msg = _MessageBuffer._Peek();

        // If someone has reserved the _Head message, don't propagate anymore
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        while (_Msg != NULL)
        {
            message_status _Status = declined;

            // Always start from the first target that linked
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Target_type> * _PTarget = *_Iter;
                _Status = _PTarget->propagate(_Msg, this);

                // Ownership of message changed. Do not propagate this
                // message to any other target.
                if (_Status == accepted)
                {
                    break;
                }

                // If the target just propagated to reserved this message, stop
                // propagating it to others
                if (_M_pReservedFor != NULL)
                {
                    break;
                }
            }

            // If status is anything other than accepted, then the head message
            // was not propagated out.  Thus, nothing after it in the queue can
            // be propagated out.  Cease propagation.
            if (_Status != accepted)
            {
                break;
            }

            // Get the next message
            _Msg = _MessageBuffer._Peek();
        }
    }

    //
    //  Private Data Members
    //

    // The transformer method called by this block
    _Transform_method _M_pFunc;

    // The queue of input messages for this Transformer block
    ::Concurrency::details::_Async_send_queue<message<_Input>> _M_inputMessages;

    /// <summary>
    ///    Message queue used to store messages
    /// </summary>
    /**/
    ::Concurrency::details::_Queue<message<_Output>> _M_messageBuffer;

private:
    //
    // Hide assignment operator and copy constructor
    //
    transformer const &operator =(transformer const &);  // no assignment operator
    transformer(transformer const &);                    // no copy constructor
};

//**************************************************************************
// Timer:
//**************************************************************************
/// <summary>
///     A <c>timer</c> messaging block is a single-target <c>source_block</c> capable of sending
///     a message to its target after a specified time period has elapsed
///     or at specific intervals.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the output messages of this block.
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/**/
template<class _Type>
class timer : public Concurrency::details::_Timer, public source_block<single_link_registry<ITarget<_Type>>>
{
private:

    /// <summary>
    ///     Tracks the state machine of the timer.
    /// </summary>
    /**/
    enum State
    {
        /// <summary>
        ///     The timer has been initialized, but not yet started.
        /// </summary>
        /**/
        Initialized,
        /// <summary>
        ///     The timer has been started.
        /// </summary>
        /**/
        Started,
        /// <summary>
        ///     The timer has started and been paused.
        /// </summary>
        /**/
        Paused,
        /// <summary>
        ///     The timer has been stopped.
        /// </summary>
        /**/
        Stopped
    };

public:

    /// <summary>
    ///     Constructs a <c>timer</c> messaging block that will fire a given message after a specified interval.
    /// </summary>
    /// <param name="_Ms">
    ///     The number of milliseconds that must elapse after the call to start for the specified message
    ///     to be propagated downstream.
    /// </param>
    /// <param name="_Value">
    ///     The value which will be propagated downstream when the timer elapses.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the timer will propagate its message.
    /// </param>
    /// <param name="_Repeating">
    ///     If true, indicates that the timer will fire periodically every <paramref name="_Ms"/> milliseconds.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_Scheduler"/>
    ///     or <paramref name="_ScheduleGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    timer(unsigned int _Ms, _Type const& _Value, ITarget<_Type> *_PTarget = NULL, bool _Repeating = false) :
        _Timer(_Ms, _Repeating)
    {
        _Initialize(_Value, _PTarget, _Repeating);
    }

    /// <summary>
    ///     Constructs a <c>timer</c> messaging block that will fire a given message after a specified interval.
    /// </summary>
    /// <param name="_Scheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>timer</c> messaging block is scheduled is scheduled.
    /// </param>
    /// <param name="_Ms">
    ///     The number of milliseconds that must elapse after the call to start for the specified message
    ///     to be propagated downstream.
    /// </param>
    /// <param name="_Value">
    ///     The value which will be propagated downstream when the timer elapses.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the timer will propagate its message.
    /// </param>
    /// <param name="_Repeating">
    ///     If true, indicates that the timer will fire periodically every <paramref name="_Ms"/> milliseconds.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_Scheduler"/>
    ///     or <paramref name="_ScheduleGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    timer(Scheduler& _Scheduler, unsigned int _Ms, _Type const& _Value, ITarget<_Type> *_PTarget = NULL, bool _Repeating = false) :
        _Timer(_Ms, _Repeating)
    {
        _Initialize(_Value, _PTarget, _Repeating, &_Scheduler);
    }

    /// <summary>
    ///     Constructs a <c>timer</c> messaging block that will fire a given message after a specified interval.
    /// </summary>
    /// <param name="_ScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>timer</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Ms">
    ///     The number of milliseconds that must elapse after the call to start for the specified message
    ///     to be propagated downstream.
    /// </param>
    /// <param name="_Value">
    ///     The value which will be propagated downstream when the timer elapses.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the timer will propagate its message.
    /// </param>
    /// <param name="_Repeating">
    ///     If true, indicates that the timer will fire periodically every <paramref name="_Ms"/> milliseconds.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_Scheduler"/>
    ///     or <paramref name="_ScheduleGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    timer(ScheduleGroup& _ScheduleGroup, unsigned int _Ms, _Type const& _Value, ITarget<_Type> *_PTarget = NULL, bool _Repeating = false) :
        _Timer(_Ms, _Repeating)
    {
        _Initialize(_Value, _PTarget, _Repeating, NULL, &_ScheduleGroup);
    }

    /// <summary>
    ///     Destroys a <c>timer</c> messaging block.
    /// </summary>
    /**/
    ~timer()
    {
        //
        // Make sure there are no more outstanding timer fires.  Note that this does not mean that the LWT that was queued is finished, it only
        // means that no more timers will fire after the return from _Stop.  We still *MUST* wait on any outstanding LWTs.
        //
        if (_M_state == Started)
            _Stop();

        // Remove all the targets. This will wait for any outstanding LWTs
        remove_targets();

        //
        // No more asynchronous operations can happen as of this point.
        //
        if (_M_pMessage != NULL)
        {
            delete _M_pMessage;
        }

        if (_M_fReferencedScheduler)
        {
            _M_pScheduler->Release();
        }
    }

    /// <summary>
    ///     Starts the <c>timer</c> messaging block.  The specified number of milliseconds after this is called, the specified value will be propagated
    ///     downstream as a <c>message</c>.
    /// </summary>
    /**/
    void start()
    {
        if (_M_state == Initialized || _M_state == Paused)
        {
            _M_state = Started;
            _Start();
        }
    }

    /// <summary>
    ///     Stops the <c>timer</c> messaging block.
    /// </summary>
    /**/
    void stop()
    {
        if (_M_state == Started)
            _Stop();

        _M_state = Stopped;
    }

    /// <summary>
    ///     Stops the <c>timer</c> messaging block.  If it is a repeating <c>timer</c> messaging block, it can be restarted with a subsequent
    ///     <c>start()</c> call.  For non-repeating timers, this has the same effect as a <c>stop</c> call.
    /// </summary>
    /**/
    void pause()
    {
        //
        // Non repeating timers cannot pause.  They go to a final stopped state on pause.
        //
        if (!_M_fRepeating)
        {
            stop();
        }
        else
        {
            // Pause only a started timer.

            if (_M_state == Started)
            {
                _Stop();
                _M_state = Paused;
            }
        }
    }

protected:

    /// <summary>
    ///     Accepts a message that was offered by this <c>timer</c> messaging block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Type> * accept_message(runtime_object_identity _MsgId)
    {
        if (_M_pMessage == NULL || _MsgId != _M_pMessage->msg_id())
        {
            return NULL;
        }

        message<_Type> *_PMessage = _M_pMessage;
        _M_pMessage = NULL;

        return _PMessage;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>timer</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        //
        // Semantically, every timer tick is the same value -- it doesn't matter the message id.  Since we can only
        // have one target as well, we do not need to track anything here.
        //
        if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>timer</c> and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume_message(runtime_object_identity _MsgId)
    {
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
        {
            throw message_not_found();
        }

        delete _M_pMessage;
        _M_pMessage = NULL;
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // Since reservation doesn't prevent propagation there is
        // no need to resume on consume/release.
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>timer</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Type> * _PTarget)
    {
        // If there is a timer message sitting around, it must be propagated to the target now.

        if (_M_pMessage != NULL)
        {
            _PTarget->propagate(_M_pMessage, this);
        }
    }

    /// <summary>
    ///     Tries to offer the message produced by the <c>timer</c> block to all of the linked targets.
    /// </summary>
    /**/
    virtual void propagate_to_any_targets(message<_Type> *)
    {
        if (_M_pMessage == NULL)
        {
            _M_pMessage = _NewMessage();
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Type> * _PTarget = *_Iter;
                _PTarget->propagate(_M_pMessage, this);
            }
        }
    }

private:

    // The timer message we contain
    message<_Type> *_M_pMessage;

    // Current state of the timer.
    State _M_state;

    // The value to send on elapse of the timer.
    _Type _M_value;

    // An indication of whether the timer is repeating.
    bool _M_fRepeating;

    // A flag for whether we need to release a reference on the scheduler.
    bool _M_fReferencedScheduler;

    // Scheduler used for the timer
    Scheduler * _M_pScheduler;

    /// <summary>
    ///     Allocates a new message.
    /// </summary>
    /**/
    message<_Type>* _NewMessage() const
    {
        return new message<_Type>(_M_value);
    }

    /// <summary>
    ///     Called when the timer fires.
    /// </summary>
    /**/
    virtual void _Fire()
    {
        async_send(NULL);
    }

    /// <summary>
    ///     Common initialization.
    /// </summary>
    /// <param name="_Value">
    ///     The value which will be propagated downstream when the timer elapses.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the timer will propagate its message.
    /// </param>
    /// <param name="_Repeating">
    ///     If true, indicates that the timer will fire periodically every _Ms milliseconds.
    /// </param>
    /**/
    void _Initialize(const _Type& _Value, ITarget<_Type> *_PTarget, bool _Repeating, Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        _M_pMessage = NULL;
        _M_value = _Value;
        _M_fRepeating = _Repeating;
        _M_state = Initialized;
        _M_fReferencedScheduler = false;

        //
        // If we are going to utilize the current scheduler for timer firing, we need to capture it now.  Otherwise,
        // the timer threads fired from Windows (what _Fire executes within) will wind up with a default scheduler
        // attached -- probably not the semantic we want.
        //
        if (_PScheduleGroup == NULL && _PScheduler == NULL)
        {
            _PScheduler = CurrentScheduler::Get();
            _PScheduler->Reference();
            _M_fReferencedScheduler = true;
        }

        _M_pScheduler = _PScheduler;
        initialize_source(_PScheduler, _PScheduleGroup);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }
    }

private:
    //
    // Hide assignment operator and copy constructor
    //
    timer const &operator =(timer const &);  // no assignment operator
    timer(timer const &);                    // no copy constructor
};

//**************************************************************************
// Single assignment:
//**************************************************************************

/// <summary>
///     A <c>single_assignment</c> messaging block is a multi-target, multi-source, ordered
///     <c>propagator_block</c> capable of storing a single, write-once
///     <c>message</c>.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the message stored and propagated by the buffer.
/// </typeparam>
/// <remarks>
///     A <c>single_assignment</c> messaging block propagates out copies of its message to each target.
///     <para>For more information, see <see cref="Asynchronous Message Blocks"/>.</para>
/// </remarks>
/// <seealso cref="overwrite_buffer Class"/>
/// <seealso cref="unbounded_buffer Class"/>
/**/
template<class _Type>
class single_assignment : public propagator_block<multi_link_registry<ITarget<_Type>>, multi_link_registry<ISource<_Type>>>
{
public:

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment() :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target();
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target();
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>single_assignment</c> messaging block is scheduled.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(Scheduler& _PScheduler) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>single_assignment</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(Scheduler& _PScheduler, filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target(&_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>single_assignment</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(ScheduleGroup& _PScheduleGroup) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>single_assignment</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>single_assignment</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    single_assignment(ScheduleGroup& _PScheduleGroup, filter_method const& _Filter) :
        _M_fIsInitialized(false), _M_pMessage(NULL)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Destroys the <c>single_assignment</c> messaging block.
    /// </summary>
    /**/
    ~single_assignment()
    {
        // Remove all links
        remove_network_links();

        // The messages for a single_assignment are deleted at the end when
        // single_assignment is deleted.
        delete _M_pMessage;
    }

    /// <summary>
    ///     Checks whether this <c>single_assignment</c> messaging block has been initialized with a value yet.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the block has received a value, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool has_value() const
    {
        return (_M_pMessage != NULL);
    }


    /// <summary>
    ///     Gets a reference to the current payload of the message being stored in the <c>single_assignment</c> messaging block.
    /// </summary>
    /// <returns>
    ///     The payload of the stored message.
    /// </returns>
    /// <remarks>
    ///     This method will wait until a message arrives if no message is currently stored in the <c>single_assignment</c> messaging block.
    /// </remarks>
    /**/
    _Type const & value()
    {
        if (_M_pMessage == NULL)
        {
            receive<_Type>(this);
        }
        _ASSERTE(_M_pMessage != NULL);

        return _M_pMessage->payload;
    }


protected:

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>single_assignment</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Result = accepted;

        // single_assignment messaging block can be initialized only once
        if (_M_fIsInitialized)
        {
            return declined;
        }

        {
            _NR_lock _Lock(_M_propagationLock);

            if (_M_fIsInitialized)
            {
                _Result = declined;
            }
            else
            {
                _PMessage = _PSource->accept(_PMessage->msg_id(), this);

                // Set initialized flag only if we have a message
                if (_PMessage != NULL)
                {
                    _M_fIsInitialized = true;
                }
                else
                {
                    _Result = missed;
                }
            }
        }

        //
        // If message was accepted, set the member variables for
        // this block and start the asynchronous propagation task
        //
        if (_Result == accepted)
        {
            async_send(_PMessage);
        }

        return _Result;
    }

    /// <summary>
    ///     Synchronously passes a message from an <c>ISource</c> block to this <c>single_assignment</c> messaging block.
    ///     It is invoked by the <c>send</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status send_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        message_status _Result = accepted;

        // single_assignment messaging block can be initialized only once
        if (_M_fIsInitialized)
        {
            return declined;
        }

        {
            _NR_lock _Lock(_M_propagationLock);

            if (_M_fIsInitialized)
            {
                _Result = declined;
            }
            else
            {
                _PMessage = _PSource->accept(_PMessage->msg_id(), this);

                // Set initialized flag only if we have a message
                if (_PMessage != NULL)
                {
                    _M_fIsInitialized = true;
                }
                else
                {
                    _Result = missed;
                }
            }
        }

        //
        // If message was accepted, set the member variables for
        // this block and start the asynchronous propagation task
        //
        if (_Result == accepted)
        {
            sync_send(_PMessage);
        }

        return _Result;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>single_assignment</c> messaging block,
    ///     returning a copy of the message to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>single_assignment</c> messaging block returns copies of the message
    ///     to its targets, rather than transferring ownership of the currently
    ///     held message.
    /// </remarks>
    /**/
    virtual message<_Type> * accept_message(runtime_object_identity _MsgId)
    {
        // This check is to prevent spoofing and verify that the propagated message is
        // the one that is accepted at the end.
        if (_M_pMessage == NULL || _MsgId != _M_pMessage->msg_id())
        {
            return NULL;
        }

        //
        // Instead of returning the internal message, we return a copy of the
        // message passed in.
        //
        // Since we are returning a copy, the accept routine for a single_assignment
        // does not need to grab the internal lock.
        //
        return (new message<_Type>(_M_pMessage->payload));
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        if (_M_pMessage == NULL)
        {
            return false;
        }

        if (_M_pMessage->msg_id() != _MsgId)
        {
            throw message_not_found();
        }

        return true;
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>single_assignment</c> and reserved by the target,
    ///     returning a copy of the message to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Type> * consume_message(runtime_object_identity _MsgId)
    {
        _ASSERTE(_M_fIsInitialized);

        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        _ASSERTE(_M_fIsInitialized);

        if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // Since reservation doesn't stop propagation, we don't
        // need to do anything on resume after consume/release.
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>single_assignment</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Type> * _PTarget)
    {
        // If there is a message available already, propagate it.

        if (_M_pMessage != NULL)
        {
            _PTarget->propagate(_M_pMessage, this);
        }
    }
    /// <summary>
    ///     Places the <c>message</c> <paramref name="_PMessage"/> in this <c>single_assignment</c> messaging block and
    ///     offers it to all of the linked targets.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a <c>message</c> that this <c>single_assignment</c> messaging block has taken ownership of.
    /// </param>
    /**/
    virtual void propagate_to_any_targets(message<_Type> * _PMessage)
    {
        // Initialized flag should have been set by the propagate function using interlocked operation.
        _ASSERTE(_M_fIsInitialized);

        // Move the message to the internal storage

        _ASSERTE(_M_pMessage == NULL);
        _M_pMessage = _PMessage;

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            // Single assignment can propagate its message out
            // to any number of Targets

            ITarget<_Type> * _PTarget = *_Iter;
            _PTarget->propagate(_PMessage, this);
        }
    }

private:

    //
    //  Private Data Members
    //

    // The message being stored
    message<_Type> * _M_pMessage;

    // The lock used to protect propagation
    ::Concurrency::details::_NonReentrantPPLLock _M_propagationLock;

    // The marker for whether the single_assignment has already been initialized
    volatile bool _M_fIsInitialized;

private:
    //
    // Hide assignment operator and copy constructor
    //
    single_assignment const & operator=(single_assignment const &);  // no assignment operator
    single_assignment(single_assignment const &);                    // no copy constructor
};

//**************************************************************************
// Join (single-type)
//**************************************************************************

/// <summary>
///     The type of a <c>join</c> messaging block.
/// </summary>
/**/
enum join_type {
    /// <summary>
    ///     Greedy <c>join</c> messaging blocks immediately accept a message upon propagation.  This is more efficient,
    ///     but has the possibility for live-lock, depending on the network configuration.
    /// </summary>
    /**/
    greedy = 0,
    /// <summary>
    ///     Non-greedy <c>join</c> messaging blocks postpone messages and try and consume them after all have arrived.
    ///     These are guaranteed to work, but slower.
    /// </summary>
    /**/
    non_greedy = 1
};

/// <summary>
///     A <c>join</c> messaging block  is a single-target, multi-source, ordered
///     <c>propagator_block</c> which combines together messages of type <typeparamref name="_Type"/> from each
///     of its sources.
/// </summary>
/// <typeparam name="_Type">
///     The payload type of the messages joined and propagated by the block.
/// </typeparam>
/// <typeparam name="_Jtype">
///     The kind of <c>join</c> block this is, either <c>greedy</c> or <c>non_greedy</c>
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="choice Class"/>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="join_type Enumeration"/>
/**/
template<class _Type, join_type _Jtype = non_greedy>
class join : public propagator_block<single_link_registry<ITarget<std::vector<_Type>>>, multi_link_registry<ISource<_Type>>>
{
public:
    typedef typename std::vector<_Type> _OutputType;

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(size_t _NumInputs)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(size_t _NumInputs, filter_method const& _Filter)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>join</c> messaging block is scheduled.
    /// </param>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(Scheduler& _PScheduler, size_t _NumInputs)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>join</c> messaging block is scheduled.
    /// </param>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(Scheduler& _PScheduler, size_t _NumInputs, filter_method const& _Filter)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs, &_PScheduler);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>join</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(ScheduleGroup& _PScheduleGroup, size_t _NumInputs)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>join</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_NumInputs">
    ///     The number of inputs this <c>join</c> block will be allowed.
    /// </param>
    /// <param name="_Filter">
    ///     A filter function which determines whether offered messages should be accepted.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PScheduleGroup"/> parameters.
    ///     <para>The type <typeparamref name="filter_method"/> is a functor with signature <c>bool (_Type const &amp;)</c>
    ///     which is invoked by this <c>join</c> messaging block to determine whether or not it should accept
    ///     an offered message.</para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    join(ScheduleGroup& _PScheduleGroup, size_t _NumInputs, filter_method const& _Filter)
        : _M_messageArray(_NumInputs),
          _M_savedMessageIdArray(_NumInputs)
    {
        _Initialize(_NumInputs, NULL, &_PScheduleGroup);
        register_filter(_Filter);
    }

    /// <summary>
    ///     Destroys the <c>join</c> block.
    /// </summary>
    /**/
    ~join()
    {
        // Remove all links that are targets of this join
        remove_network_links();

        delete [] _M_savedIdBuffer;
    }

protected:
    //
    // propagator_block protected function implementations
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>join</c> messaging block.
    ///     It is invoked by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        // It is important that calls to propagate do *not* take the same lock on the
        // internal structure that is used by Consume and the LWT.  Doing so could
        // result in a deadlock with the Consume call.

        message_status _Ret_val = accepted;

        //
        // Find the slot index of this source
        //
        size_t _Slot = 0;
        bool _Found = false;
        for (source_iterator _Iter = _M_connectedSources.begin(); *_Iter != NULL; ++_Iter)
        {
            if (*_Iter == _PSource)
            {
                _Found = true;
                break;
            }

            _Slot++;
        }

        if (!_Found)
        {
            // If this source was not found in the array, this is not a connected source
            // decline the message
            return declined;
        }

        _ASSERTE(_Slot < _M_messageArray._M_count);

        bool fIsGreedy = (_Jtype == greedy);

        if (fIsGreedy)
        {
            //
            // Greedy type joins immediately accept the message.
            //
            {
                _NR_lock lockHolder(_M_propagationLock);
                if (_M_messageArray._M_messages[_Slot] != NULL)
                {
                    _M_savedMessageIdArray._M_savedIds[_Slot] = _PMessage->msg_id();
                    _Ret_val = postponed;
                }
            }

            if (_Ret_val != postponed)
            {
                _M_messageArray._M_messages[_Slot] = _PSource->accept(_PMessage->msg_id(), this);

                if (_M_messageArray._M_messages[_Slot] != NULL)
                {
                    if (_InterlockedDecrementSizeT(&_M_messagesRemaining) == 0)
                    {
                        // If messages have arrived on all links, start a propagation
                        // of the current message
                        async_send(NULL);
                    }
                }
                else
                {
                    _Ret_val = missed;
                }
            }
        }
        else
        {
            //
            // Non-greedy type joins save the message ids until they have all arrived
            //

            if (_InterlockedExchange((volatile long *) &_M_savedMessageIdArray._M_savedIds[_Slot], _PMessage->msg_id()) == -1)
            {
                // Decrement the message remaining count if this thread is switching
                // the saved id from -1 to a valid value.
                if (_InterlockedDecrementSizeT(&_M_messagesRemaining) == 0)
                {
                    async_send(NULL);
                }
            }

            // Always return postponed.  This message will be consumed
            // in the LWT
            _Ret_val = postponed;
        }

        return _Ret_val;
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>join</c> messaging block,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_OutputType> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // Peek at the head message in the message buffer.  If the Ids match
        // dequeue and transfer ownership
        //
        message<_OutputType> * _Msg = NULL;

        if (_M_messageBuffer._Is_head(_MsgId))
        {
            _Msg = _M_messageBuffer._Dequeue();
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>join</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Allow reservation if this is the head message
        return _M_messageBuffer._Is_head(_MsgId);
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>join</c> messaging block and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being consumed.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_OutputType> * consume_message(runtime_object_identity _MsgId)
    {
        // By default, accept the message
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        // The head message is the one reserved.
        if (!_M_messageBuffer._Is_head(_MsgId))
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released.
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // If there are any messages in the buffer, propagate them out
        if (_M_messageBuffer._Count() > 0)
        {
            async_send(NULL);
        }
    }

    /// <summary>
    ///     A callback that notifies that a new target has been linked to this <c>join</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<std::vector<_Type>> *)
    {
        // If the message queue is blocked due to reservation
        // there is no need to do any message propagation
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

    /// <summary>
    ///     Constructs an output message containing an input message from each source when
    ///     they have all propagated a message.  Sends this output message out to each of
    ///     its targets.
    /// </summary>
    /**/
    void propagate_to_any_targets(message<_OutputType> *)
    {
        message<_OutputType> * _Msg = NULL;
        // Create a new message from the input sources
        // If messagesRemaining == 0, we have a new message to create.  Otherwise, this is coming from
        // a consume or release from the target.  In that case we don't want to create a new message.
        if (_M_messagesRemaining == 0)
        {
            // A greedy join can immediately create the message, a non-greedy
            // join must try and consume all the messages it has postponed
            _Msg = _Create_new_message();
        }

        if (_Msg == NULL)
        {
            // Create message failed.  This happens in non_greedy joins when the
            // reserve/consumption of a postponed message failed.
            _Propagate_priority_order(_M_messageBuffer);
            return;
        }

        bool fIsGreedy = (_Jtype == greedy);

        // For a greedy join, reset the number of messages remaining
        // Check to see if multiple messages have been passed in on any of the links,
        // and postponed. If so, try and reserve/consume them now
        if (fIsGreedy)
        {
            // Look at the saved ids and reserve/consume any that have passed in while
            // this join was waiting to complete
            _ASSERTE(_M_messageArray._M_count == _M_savedMessageIdArray._M_count);

            for (size_t i = 0; i < _M_messageArray._M_count; i++)
            {
                for(;;)
                {
                    runtime_object_identity _Saved_id;
                    // Grab the current saved id value.  This value could be changing from based on any
                    // calls of source->propagate(this).  If the message id is different than what is snapped
                    // here, that means, the reserve below must fail.  This is because reserve is trying
                    // to get the same source lock the propagate(this) call must be holding.
                    {
                        _NR_lock lockHolder(_M_propagationLock);

                        _ASSERTE(_M_messageArray._M_messages[i] != NULL);

                        _Saved_id = _M_savedMessageIdArray._M_savedIds[i];

                        if (_Saved_id == -1)
                        {
                            _M_messageArray._M_messages[i] = NULL;
                            break;
                        }
                        else
                        {
                            _M_savedMessageIdArray._M_savedIds[i] = -1;
                        }
                    }

                    if (_Saved_id != -1)
                    {
                        source_iterator _Iter = _M_connectedSources.begin();

                        ISource<_Type> * _PSource = _Iter[i];
                        if ((_PSource != NULL) && _PSource->reserve(_Saved_id, this))
                        {
                            _M_messageArray._M_messages[i] = _PSource->consume(_Saved_id, this);
                            _InterlockedDecrementSizeT(&_M_messagesRemaining);
                            break;
                        }
                    }
                }
            }

            // If messages have all been received, async_send again, this will start the
            // LWT up to create a new message
            if (_M_messagesRemaining == 0)
            {
                async_send(NULL);
            }
        }

        // Add the new message to the outbound queue
        _M_messageBuffer._Enqueue(_Msg);

        if (!_M_messageBuffer._Is_head(_Msg->msg_id()))
        {
            // another message is at the head of the outbound message queue and blocked
            // simply return
            return;
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

private:

    //
    //  Private Methods
    //

    /// <summary>
    ///     Propagate messages in priority order.
    /// </summary>
    /// <param name="_MessageBuffer">
    ///     Reference to a message queue with messages to be propagated
    /// </param>
    /**/
    void _Propagate_priority_order(::Concurrency::details::_Queue<message<_Target_type>> & _MessageBuffer)
    {
        message<_Target_type> * _Msg = _MessageBuffer._Peek();

        // If someone has reserved the _Head message, don't propagate anymore
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        while (_Msg != NULL)
        {
            message_status _Status = declined;

            // Always start from the first target that linked
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Target_type> * _PTarget = *_Iter;
                _Status = _PTarget->propagate(_Msg, this);

                // Ownership of message changed. Do not propagate this
                // message to any other target.
                if (_Status == accepted)
                {
                    break;
                }

                // If the target just propagated to reserved this message, stop
                // propagating it to others
                if (_M_pReservedFor != NULL)
                {
                    break;
                }
            }

            // If status is anything other than accepted, then the head message
            // was not propagated out.  Thus, nothing after it in the queue can
            // be propagated out.  Cease propagation.
            if (_Status != accepted)
            {
                break;
            }

            // Get the next message
            _Msg = _MessageBuffer._Peek();
        }
    }

    /// <summary>
    ///     Constructs a new message from the data output.
    /// </summary>
    /// <returns>
    ///     The created message (NULL if creation failed)
    /// </returns>
    /**/
    message<std::vector<_Type>> * __cdecl _Create_new_message()
    {
        bool fIsNonGreedy = (_Jtype == non_greedy);

        // If this is a non-greedy join, check each source and try to consume their message
        if (fIsNonGreedy)
        {

            // The iterator _Iter below will ensure that it is safe to touch
            // non-NULL source pointers. Take a snapshot.
            std::vector<ISource<_Type> *> _Sources;
            source_iterator _Iter = _M_connectedSources.begin();

            while (*_Iter != NULL)
            {
                ISource<_Type> * _PSource = *_Iter;

                if (_PSource == NULL)
                {
                    break;
                }

                _Sources.push_back(_PSource);
                ++_Iter;
            }

            if (_Sources.size() != _M_messageArray._M_count)
            {
                // Some of the sources were unlinked. The join is broken
                return NULL;
            }

            // First, try and reserve all the messages.  If a reservation fails,
            // then release any reservations that had been made.
            for (size_t i = 0; i < _M_savedMessageIdArray._M_count; i++)
            {
                // Snap the current saved id into a buffer.  This value can be changing behind the scenes from
                // other source->propagate(msg, this) calls, but if so, that just means the reserve below will
                // fail.
                _InterlockedIncrementSizeT(&_M_messagesRemaining);
                _M_savedIdBuffer[i] = _InterlockedExchange((volatile long *) &_M_savedMessageIdArray._M_savedIds[i], -1);

                _ASSERTE(_M_savedIdBuffer[i] != -1);

                if (!_Sources[i]->reserve(_M_savedIdBuffer[i], this))
                {
                    // A reservation failed, release all reservations made up until
                    // this block, and wait for another message to arrive on this link
                    for (size_t j = 0; j < i; j++)
                    {
                        _Sources[j]->release(_M_savedIdBuffer[j], this);
                        if (_InterlockedCompareExchange((volatile long *) &_M_savedMessageIdArray._M_savedIds[j], _M_savedIdBuffer[j], -1) == -1)
                        {
                            if (_InterlockedDecrementSizeT(&_M_messagesRemaining) == 0)
                            {
                                async_send(NULL);
                            }
                        }
                    }

                    // Return NULL to indicate that the create failed
                    return NULL;
                }
            }

            // Since everything has been reserved, consume all the messages.
            // This is guaranteed to return true.
            for (size_t i = 0; i < _M_messageArray._M_count; i++)
            {
                _M_messageArray._M_messages[i] = _Sources[i]->consume(_M_savedIdBuffer[i], this);
                _M_savedIdBuffer[i] = -1;
            }
        }

        if (!fIsNonGreedy)
        {
            // Reinitialize how many messages are being waited for.
            // This is safe because all messages have been received, thus no new async_sends for
            // greedy joins can be called.
            _M_messagesRemaining = _M_messageArray._M_count;
        }

        std::vector<_Type> _OutputVector;
        for (size_t i = 0; i < _M_messageArray._M_count; i++)
        {
            _ASSERTE(_M_messageArray._M_messages[i] != NULL);
            _OutputVector.push_back(_M_messageArray._M_messages[i]->payload);

            delete _M_messageArray._M_messages[i];
            if (fIsNonGreedy)
            {
                _M_messageArray._M_messages[i] = NULL;
            }
        }
        return (new message<std::vector<_Type>>(_OutputVector));
    }

    /// <summary>
    ///     Initializes the <c>join</c> messaging block.
    /// </summary>
    /// <param name="_NumInputs">
    ///     The number of inputs.
    /// </param>
    /// <param name="_PScheduler">
    ///     The scheduler onto which the task to propagate the <c>join</c> block's message will be scheduled.
    ///     If unspecified, the <c>join</c> messaging block uses the default scheduler.
    /// </param>
    /// <param name="_PScheduleGroup">
    ///     The schedule group into which the task to propagate the <c>join</c> block's message will be scheduled.
    ///     The scheduler used is implied by the schedule group.  If unspecified, the <c>join</c> uses a schedule
    ///     group of the scheduler's choosing.
    /// </param>
    /**/
    void _Initialize(size_t _NumInputs, Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        initialize_source_and_target(_PScheduler, _PScheduleGroup);

        _M_connectedSources.set_bound(_NumInputs);
        _M_messagesRemaining = _NumInputs;

        bool fIsNonGreedy = (_Jtype == non_greedy);

        if (fIsNonGreedy)
        {
            // Non greedy joins need a buffer to snap off saved message ids to.
            _M_savedIdBuffer = new runtime_object_identity[_NumInputs];
            memset(_M_savedIdBuffer, -1, sizeof(runtime_object_identity) * _NumInputs);
        }
        else
        {
            _M_savedIdBuffer = NULL;
        }
    }

    // The current number of messages remaining
    volatile size_t _M_messagesRemaining;

    // An array containing the accepted messages of this join.
    // Wrapped in a struct to enable debugger visualization.
    struct _MessageArray
    {
        size_t _M_count;
        message<_Type>** _M_messages;

        _MessageArray(size_t _NumInputs)
            : _M_count(_NumInputs),
              _M_messages(new message<_Type>*[_NumInputs])
        {
            memset(_M_messages,  0, sizeof(message<_Type> *) * _NumInputs);
        }

        ~_MessageArray()
        {
            for (size_t i = 0; i < _M_count; i++)
                delete _M_messages[i];
            delete [] _M_messages;
        }
    };
    _MessageArray _M_messageArray;

    // An array containing the msg ids of messages propagated to the array
    // For greedy joins, this contains a log of other messages passed to this
    // join after the first has been accepted
    // For non-greedy joins, this contains the message id of any message
    // passed to it.
    // Wrapped in a struct to enable debugger visualization.
    struct _SavedMessageIdArray
    {
        size_t _M_count;
        runtime_object_identity * _M_savedIds;

        _SavedMessageIdArray(size_t _NumInputs)
            : _M_count(_NumInputs),
              _M_savedIds(new runtime_object_identity[_NumInputs])
        {
            memset(_M_savedIds, -1, sizeof(runtime_object_identity) * _NumInputs);
        }

        ~_SavedMessageIdArray()
        {
            delete [] _M_savedIds;
        }
    };
    _SavedMessageIdArray _M_savedMessageIdArray;

    // Buffer for snapping saved ids in non-greedy joins
    runtime_object_identity * _M_savedIdBuffer;

    // A lock for modifying the buffer or the connected blocks
    ::Concurrency::details::_NonReentrantPPLLock _M_propagationLock;

    // Queue to hold output messages
    ::Concurrency::details::_Queue<message<std::vector<_Type>>> _M_messageBuffer;
};


//**************************************************************************
// Multi-Type Choice and Join helper node:
//**************************************************************************

/// <summary>
///     Base class for Helper node used in multi-type join and choice blocks
///     Order node is a single-target, single-source ordered propagator block
///     The main property of an order node is that it accepts a message of _Type
///     and outputs a message of int, with some unique assigned index number.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/**/
template<class _Type>
class _Order_node_base: public propagator_block<single_link_registry<ITarget<size_t>>, multi_link_registry<ISource<_Type>>>
{
public:

    /// <summary>
    ///     Constructs a _Order_node_base within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /**/
    _Order_node_base() :
        _M_index(0),
        _M_pReceiveMessage(NULL),
        _M_pSendMessage(NULL)
    {
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the _Order_node.
    /// </summary>
    /**/
    ~_Order_node_base()
    {
        // The messages for an _Order_node_base are deleted at the end when
        // _Order_node_base is deleted.
        delete _M_pReceiveMessage;
        delete _M_pSendMessage;
    }

    /// <summary>
    ///     Checks whether this block has been initialized yet.
    /// </summary>
    /// <returns>
    ///     true, if the block has received a value, false otherwise.
    /// </returns>
    /**/
    bool has_value() const
    {
        return (_M_pReceiveMessage != NULL);
    }

    /// <summary>
    ///     Gets a reference to the current payload of the message being stored.
    /// </summary>
    /// <returns>
    ///     The incoming payload.
    /// </returns>
    /**/
    _Type const & value()
    {
        _ASSERTE(_M_pReceiveMessage != NULL);

        return _M_pReceiveMessage->payload;
    }

    /// <summary>
    ///     Resets the _Order_node_base and prepares it for the next propagation
    /// </summary>
    /// <remarks>
    ///     _Reset is called from Populate_destination_tuple through propagate_to_any_targets()
    ///     thus, it always has the internal lock held.  This is only used for _Greedy_node and
    ///     _Non_greedy_node.
    /// </remarks>
    /**/
    virtual void _Reset() = 0;

    /// <summary>
    ///     Reserves a message previously offered by the source.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A bool indicating whether the reservation worked or not
    /// </returns>
    /// <remarks>
    ///     After 'reserve' is called, either 'consume' or 'release' must be called.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity)
    {
        // reserve should never be called for this block.
        _ASSERTE(false);

        return false;
    }

    /// <summary>
    ///     Consumes a message previously offered by the source and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     Similar to 'accept', but is always preceded by a call to 'reserve'
    /// </remarks>
    /**/
    virtual message<size_t> * consume_message(runtime_object_identity)
    {
        // consume should never be called for this block.
        _ASSERTE(false);

        return NULL;
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity)
    {
        // release should never be called for this block.
        _ASSERTE(false);
    }

protected:


    /// <summary>
    ///     Resumes propagation after a reservation has been released
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // Since there is only a single target, nothing needs
        // to be done on resume
    }

    /// <summary>
    /// Notification that a target was linked to this source.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<size_t> *)
    {
        if (_M_pSendMessage != NULL)
        {
            propagate_to_any_targets(NULL);
        }
    }

    /// <summary>
    ///     Create a message that contains an index used to determine the source message
    /// </summary>
    /**/
    void _Create_send_message()
    {
        _M_pSendMessage = new message<size_t>(_M_index);
    }

    /// <summary>
    ///     Validate constructor arguments and fully connect this _Order_node_base.
    /// </summary>
    /**/
    void _Initialize_order_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, Scheduler * _PScheduler = NULL, ScheduleGroup * _PScheduleGroup = NULL)
    {
        if (_Index < 0)
        {
            throw std::invalid_argument("_Index");
        }

        if (_PSource == NULL)
        {
            throw std::invalid_argument("_PSource");
        }

        _M_index = _Index;

        initialize_source_and_target(_PScheduler, _PScheduleGroup);

        // Allow only a single source and ensure that they
        // cannot be unlinked and relinked.
        _M_connectedSources.set_bound(1);

        if (_PTarget != NULL)
        {
            link_target(_PTarget);
        }

        _PSource->link_target(this);
    }

    //
    //  Private Data Members
    //

    // The message to be received from the source
    message<_Type> * _M_pReceiveMessage;

    // The message to be sent to all targets
    message<size_t> * _M_pSendMessage;

    // The index of the _Order_node_base in the user's construct
    size_t _M_index;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Order_node_base const & operator=(_Order_node_base const &);  // no assignment operator
    _Order_node_base(_Order_node_base const &);                    // no copy constructor
};


/// <summary>
///     Helper class used in multi-type choice blocks
///     Ordered node is a single-target, single-source ordered propagator block
/// </summary>
///
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/**/
template<class _Type>
class _Reserving_node: public _Order_node_base<_Type>
{
public:
    /// <summary>
    ///     Constructs a _Reserving_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Reserving_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Reserving_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Reserving_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Reserving_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Reserving_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Reserving_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Reserving_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Order_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Reserving_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a _Order_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Reserving_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_fIsInitialized(false),
        _M_savedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the _Reserving_node.
    /// </summary>
    /**/
    ~_Reserving_node()
    {
        if (_M_pReservedSource != NULL)
        {
            _M_pReservedSource = NULL;
            _M_connectedSources.release();
        }

        // Remove all links
        remove_network_links();
    }


    /// <summary>
    ///     Resets the _Reserving_node and prepares it for the next propagation
    /// </summary>
    /// <remarks>
    ///     This function is not used in a _Reserving_node, which is only used for choice blocks
    /// </remarks>
    /**/
    virtual void _Reset()
    {
    }

protected:

    //
    // propagator_block protected function implementation
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>ITarget</c> block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     It is important that calls to propagate do *not* take the same lock on the
    ///     internal structure that is used by Consume and the light-weight task.  Doing so could
    ///     result in a deadlock with the Consume call.
    /// </remarks>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        message_status _Result = postponed;

        // _Order_node messaging block can be initialized only once, just like single_assignment.
        if (_M_fIsInitialized)
        {
            return declined;
        }

        // Reserve a message on the source until this _Order_node gets the feedback from
        // the single_assignment on whether it has been selected.
        _M_fIsInitialized = _PSource->reserve(_PMessage->msg_id(), this);

        //
        // If message was successfully reserved, set the member variables for
        // this messaging block and start the asynchronous propagation task.
        //
        if (_M_fIsInitialized)
        {
            _M_savedId = _PMessage->msg_id();
            async_send(NULL);
        }
        else
        {
            _Result = missed;
        }

        return _Result;
    }

    /// <summary>
    ///     Accept the message by making a copy of the payload.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<size_t> * accept_message(runtime_object_identity _MsgId)
    {
        // This check is to prevent spoofing and verify that the propagated message is
        // the one that is accepted at the end.
        if (_M_pSendMessage == NULL || _MsgId != _M_pSendMessage->msg_id())
        {
            return NULL;
        }

        // If the source has disconnected then we can't allow for accept to succeed.
        source_iterator _Iter = _M_connectedSources.begin();
        ISource<_Type>* _PSource = *_Iter;

        if (_PSource == NULL)
        {
            // source was disconnected. Fail accept.
            return NULL;
        }

        _M_pReceiveMessage = _PSource->consume(_M_savedId, this);

        _ASSERTE(_M_pReceiveMessage != NULL);

        //
        // Instead of returning the internal message, we return a copy of the
        // message passed in.
        //
        // Since we are returning a copy, the accept routine for a _Order_node
        // does not need to grab the internal lock.
        //
        return (new message<size_t>(_M_pSendMessage->payload));
    }

    /// <summary>
    ///     Takes the message and propagates it to all the targets of this _Order_node
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a new message.
    /// </param>
    /// <remarks>
    ///     This function packages its _M_index into a message and immediately sends it to the targets.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<size_t> *)
    {
        if (_M_pSendMessage == NULL)
        {
            _Create_send_message();
        }

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            ITarget<size_t> * _PTarget = *_Iter;
            _Propagate_to_target(_PTarget);
        }
    }

private:

    /// <summary>
    ///     Propagate messages to the given target
    /// </summary>
    /**/
    message_status _Propagate_to_target(ITarget<size_t> * _PTarget)
    {
        message_status _Status = _PTarget->propagate(_M_pSendMessage, this);

        // If the message got rejected we have to release the hold on the source message.
        if (_Status != accepted)
        {
            if (_M_savedId != -1)
            {
                // Release the reservation
                source_iterator _Iter = _M_connectedSources.begin();
                ISource<_Type> * _PSource = *_Iter;

                if (_PSource != NULL)
                {
                    _PSource->release(_M_savedId, this);
                }

                // If the source was disconnected, then it would
                // automatically release any reservation. So we
                // should reset our savedId regardless.
                _M_savedId = -1;
            }

        }

        return _Status;
    }

    //
    //  Private Data Members
    //

    // The source where we have reserved a message
    ISource<_Type> * _M_pReservedSource;

    // For greedy order-nodes, the message id of subsequent messages sent to this node
    // For non-greedy order nodes, the message id of the message to reserve/consume
    runtime_object_identity _M_savedId;

    // The marker that indicates that _Reserving_node has reserved a message
    volatile bool _M_fIsInitialized;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Reserving_node const & operator=(_Reserving_node const &);  // no assignment operator
    _Reserving_node(_Reserving_node const &);                    // no copy constructor
};


/// <summary>
///     Helper class used in multi-type greedy join blocks
///     Ordered node is a single-target, single-source ordered propagator block
/// </summary>
///
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/**/
template<class _Type>
class _Greedy_node: public _Order_node_base<_Type>
{
public:
    /// <summary>
    ///     Constructs a _Greedy_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Greedy_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Greedy_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Greedy_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Greedy_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Greedy_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a _Greedy_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Greedy_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_pGreedyMessage(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the _Greedy_node.
    /// </summary>
    /**/
    ~_Greedy_node()
    {
        // Remove all links
        remove_network_links();

        if (_M_pGreedyMessage != _M_pReceiveMessage)
        {
            delete _M_pGreedyMessage;
        }
    }

    /// <summary>
    ///     Resets the _Greedy_node and prepares it for the next propagation
    /// </summary>
    /// <remarks>
    ///     _Reset is called from Populate_destination_tuple through propagate_to_any_targets()
    ///     thus, it always has the internal lock held.
    /// </remarks>
    /**/
    void _Reset()
    {
        _R_lock _Lock(_M_resetLock);

        delete _M_pReceiveMessage;
        _M_pReceiveMessage = NULL;

        delete _M_pSendMessage;
        _M_pSendMessage = NULL;

        //
        // For greedy type joins, look to see if any other messages have been
        // passed to this _Greedy_node while the join was waiting for other
        // messages to arrive.  This function is already called with _M_resetLock
        // held through propagate_to_any_targets().
        //
        for(;;)
        {
            // Set the current saved id as -1.  Check to see if something was ready for consumption
            // (if _Saved_id != -1) and consume it if possible.
            runtime_object_identity _Saved_id;

            {
                _NR_lock lockHolder(_M_propagationLock);

                _Saved_id = _M_savedId;

                if (_Saved_id == -1)
                {
                    _M_pGreedyMessage = NULL;
                    break;
                }
                else
                {
                    _M_savedId = -1;
                }
            }

            if (_Saved_id != -1)
            {
                source_iterator _Iter = _M_connectedSources.begin();

                ISource<_Type> * _PSource = *_Iter;
                if ((_PSource != NULL) && _PSource->reserve(_Saved_id, this))
                {
                    _M_pGreedyMessage = _PSource->consume(_Saved_id, this);
                    async_send(NULL);
                    break;
                }
            }
        }
    }

protected:

    //
    // propagator_block protected function implementation
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>ITarget</c> block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     It is important that calls to propagate do *not* take the same lock on the
    ///     internal structure that is used by Consume and the light-weight task.  Doing so could
    ///     result in a deadlock with the Consume call.
    /// </remarks>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> * _PSource)
    {
        message_status _Result = postponed;

        bool _FDone = false;

        {
            _NR_lock lockHolder(_M_propagationLock);
            if (_M_pGreedyMessage != NULL)
            {
                _M_savedId = _PMessage->msg_id();
                _Result = postponed;
                _FDone = true;
            }
        }

        if (!_FDone)
        {
            _M_pGreedyMessage = _PSource->accept(_PMessage->msg_id(), this);

            if (_M_pGreedyMessage != NULL)
            {
                _Result = accepted;
                async_send(NULL);
            }
            else
            {
                _Result = missed;
            }
        }

        return _Result;
    }

    /// <summary>
    ///     Accept the message by making a copy of the payload.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<size_t> * accept_message(runtime_object_identity _MsgId)
    {
        // This check is to prevent spoofing and verify that the propagated message is
        // the one that is accepted at the end.
        if (_M_pSendMessage == NULL || _MsgId != _M_pSendMessage->msg_id())
        {
            return NULL;
        }

        //
        // Instead of returning the internal message, we return a copy of the
        // message passed in.
        //
        // Since we are returning a copy, the accept routine for a _Greedy_node
        // does not need to grab the internal lock.
        //
        return (new message<size_t>(_M_pSendMessage->payload));
    }


    /// <summary>
    ///     Takes the message and propagates it to all the targets of this _Greedy_node
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a new message.
    /// </param>
    /// <remarks>
    ///     This function packages its _M_index into a message and immediately sends it to the targets.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<size_t> *)
    {
        _R_lock _Lock(_M_resetLock);

        if (_M_pSendMessage == NULL)
        {
            // Save the incoming message so that it can be consumed in the accept function
            _M_pReceiveMessage = _M_pGreedyMessage;
            _Create_send_message();
        }

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            ITarget<size_t> * _PTarget = *_Iter;
            _PTarget->propagate(_M_pSendMessage, this);
        }
    }

private:

    //
    //  Private Data Members
    //

    // The message to be saved by a greedy order node
    message<_Type> * _M_pGreedyMessage;

    // The lock used to protect propagation
    ::Concurrency::details::_NonReentrantPPLLock _M_propagationLock;

    // The lock used to protect modification during a reset
    ::Concurrency::details::_ReentrantPPLLock _M_resetLock;

    // For greedy order-nodes, the message id of subsequent messages sent to this node
    // For non-greedy order nodes, the message id of the message to reserve/consume
    runtime_object_identity _M_savedId;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Greedy_node const & operator=(_Greedy_node const &);  // no assignment operator
    _Greedy_node(_Greedy_node const &);                    // no copy constructor
};


/// <summary>
///     Helper class used in multi-type non-greedy join blocks
///     Ordered node is a single-target, single-source ordered propagator block
/// </summary>
///
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/**/
template<class _Type>
class _Non_greedy_node: public _Order_node_base<_Type>
{
public:
    /// <summary>
    ///     Constructs a _Non_greedy_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Non_greedy_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Non_greedy_node(ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Non_greedy_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Non_greedy_node(Scheduler& _PScheduler, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, &_PScheduler);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /**/
    _Non_greedy_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget = NULL) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Constructs a _Non_greedy_node within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /// <param name="_PSource">
    ///     The source of data passed into the node
    /// </param>
    /// <param name="_Index">
    ///     The node's index, assigned from the outside.
    /// </param>
    /// <param name="_PTarget">
    ///     The target to which the node will signal about having received its input data
    /// </param>
    /// <param name="_Filter">
    ///     A reference to a filter function.
    /// </param>
    /**/
    _Non_greedy_node(ScheduleGroup& _PScheduleGroup, ISource<_Type> * _PSource, size_t _Index, ITarget<size_t> * _PTarget, filter_method const& _Filter) :
        _M_savedId(-1),
        _M_reservedId(-1),
        _M_pReservedSource(NULL)
    {
        register_filter(_Filter);
        _Initialize_order_node(_PSource, _Index, _PTarget, NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the _Order_node.
    /// </summary>
    /**/
    ~_Non_greedy_node()
    {
        if (_M_pReservedSource != NULL)
        {
            _M_pReservedSource = NULL;
            _M_connectedSources.release();
        }

        // Remove all links
        remove_network_links();
    }

    /// <summary>
    ///     Resets the _Order_node and prepares it for the next propagation
    /// </summary>
    /// <remarks>
    ///     _Reset is called from Populate_destination_tuple through propagate_to_any_targets()
    ///     thus, it always has the internal lock held.
    /// </remarks>
    /**/
    void _Reset()
    {
        _R_lock _Lock(_M_resetLock);

        delete _M_pReceiveMessage;
        _M_pReceiveMessage = NULL;

        delete _M_pSendMessage;
        _M_pSendMessage = NULL;
    }

    /// <summary>
    ///     Called for a non_greedy type join block in order to reserve the message
    ///     in this join block
    /// </summary>
    /// <returns>
    ///     A bool indicating whether the reservation worked
    /// </returns>
    /**/
    bool _Reserve_received_message()
    {
        bool _Ret_val = false;

        // Order node has only  a single source.
        // Obtain an iterator to the first source. It will guarantee that the reference
        // count on the source is maintained
        source_iterator _Iter = _M_connectedSources.begin();
        ISource<_Type> * _PSource = *_Iter;

        if (_PSource != NULL)
        {
            // CAS out the current saved id, in order to try and reserve it
            runtime_object_identity _SavedId = _InterlockedExchange((volatile long *) &_M_savedId, -1);

            _Ret_val = _PSource->reserve(_SavedId, this);
            //
            // If this reserved failed, that means we need to wait for another message
            // to come in on this link.  _M_savedID was set to -1 to indicate to the _Order_node
            // that it needs to async_send when that next message comes through
            //
            // If the reserve succeeds, save away the reserved ID.  This will be use later in
            // consume
            //
            if (_Ret_val)
            {
                _M_reservedId = _SavedId;

                // Acquire a reference on the source
                _M_connectedSources.reference();
                _M_pReservedSource = _PSource;
            }
        }

        return _Ret_val;
    }

    /// <summary>
    ///     Called for a non_greedy type join block in order to consume the message
    ///     in this join block that has been reserved
    /// </summary>
    /**/
    void _Consume_received_message()
    {
        if (_M_pReservedSource != NULL)
        {
            runtime_object_identity _SavedId = _M_reservedId;
            _M_pReceiveMessage = _M_pReservedSource->consume(_SavedId, this);

            runtime_object_identity _OldId = NULL;
            _OldId = _InterlockedExchange((volatile long *) &_M_reservedId, -1);

            _ASSERTE(_OldId == _SavedId);

            // Release the reference on the source
            _M_pReservedSource = NULL;
            _M_connectedSources.release();
        }
    }

    /// <summary>
    ///     Called for a non_greedy type join block release a reservation on this block
    /// </summary>
    /**/
    bool _Release_received_message()
    {
        bool retVal = false;

        if (_M_pReservedSource != NULL)
        {
            runtime_object_identity _SavedId = _M_reservedId;
            // If the _M_savedId is still -1, then swap the succeeded one back
            _M_pReservedSource->release(_SavedId, this);

            if (_InterlockedCompareExchange((volatile long *) &_M_savedId, _SavedId, -1) == -1)
            {
                retVal = true;
            }

            // Release the reference on the source
            _M_pReservedSource = NULL;
            _M_connectedSources.release();
        }

        return retVal;
    }

protected:

    //
    // propagator_block protected function implementation
    //

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>ITarget</c> block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /// <remarks>
    ///     It is important that calls to propagate do *not* take the same lock on the
    ///     internal structure that is used by Consume and the light-weight task.  Doing so could
    ///     result in a deadlock with the Consume call.
    /// </remarks>
    /**/
    virtual message_status propagate_message(message<_Type> * _PMessage, ISource<_Type> *)
    {
        // Change the message id.  If it was -1, that means an async-send needs to occur
        if (_InterlockedExchange((volatile long *) &_M_savedId, _PMessage->msg_id()) == -1)
        {
            async_send(NULL);
        }

        // Always return postponed.  This message will be consumed
        // in the LWT

        return postponed;
    }

    /// <summary>
    ///     Accept the message by making a copy of the payload.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<size_t> * accept_message(runtime_object_identity _MsgId)
    {
        // This check is to prevent spoofing and verify that the propagated message is
        // the one that is accepted at the end.
        if (_M_pSendMessage == NULL || _MsgId != _M_pSendMessage->msg_id())
        {
            return NULL;
        }

        //
        // Instead of returning the internal message, we return a copy of the
        // message passed in.
        //
        // Since we are returning a copy, the accept routine for a _Non_greedy_node
        // does not need to grab the internal lock.
        //
        return (new message<size_t>(_M_pSendMessage->payload));
    }

    /// <summary>
    ///     Takes the message and propagates it to all the targets of this _Order_node
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a new message.
    /// </param>
    /// <remarks>
    ///     This function packages its _M_index into a message and immediately sends it to the targets.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<size_t> *)
    {
        _R_lock _Lock(_M_resetLock);

        if (_M_pSendMessage == NULL)
        {
            _Create_send_message();
        }

        for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
        {
            ITarget<size_t> * _PTarget = *_Iter;
            _PTarget->propagate(_M_pSendMessage, this);
        }
    }

private:

    //
    //  Private Data Members
    //

    // The source where we have reserved a message
    ISource<_Type> * _M_pReservedSource;

    // The lock used to protect modification during a reset
    ::Concurrency::details::_ReentrantPPLLock _M_resetLock;

    // For non-greedy order nodes, the message id of the message to reserve/consume
    runtime_object_identity _M_savedId;

    // For non-greedy order nodes, the reserved id of the message that was reserved
    runtime_object_identity _M_reservedId;

    // The marker that indicates that _Non_greedy_node has reserved a message
    volatile bool _M_fIsInitialized;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Non_greedy_node const & operator=(_Non_greedy_node const &);  // no assignment operator
    _Non_greedy_node(_Non_greedy_node const &);                    // no copy constructor
};

//**************************************************************************
// Choice:
//**************************************************************************

/// <summary>
///     A <c>choice</c> messaging block is a multi-source, single-target block that represents a control-flow
///     interaction with a set of sources. The choice block will wait for any one of multiple sources to
///     produce a message and will propagate the index of the source that produced the message.
/// </summary>
/// <typeparam name="_Type">
///     A <c>tuple</c>-based type representing the payloads of the input sources.
/// </typeparam>
/// <remarks>
///     The choice block ensures that only one of the incoming messages is consumed.
///     <para>For more information, see <see cref="Asynchronous Message Blocks"/>.</para>
/// </remarks>
/// <seealso cref="join Class"/>
/// <seealso cref="single_assignment Class"/>
/// <seealso cref="make_choice Function"/>
/// <seealso cref="tuple Class"/>
/**/
template<class _Type>
class choice: public ISource<size_t>
{
public:

    /// <summary>
    ///     Constructs a <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for the choice.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    explicit choice(_Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(NULL), _M_pScheduleGroup(NULL)
    {
        _M_pSingleAssignment = new single_assignment<size_t>();
        _Initialize_choices<0>();
    }

    /// <summary>
    ///     Constructs a <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for the choice.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    choice(Scheduler& _PScheduler, _Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(&_PScheduler), _M_pScheduleGroup(NULL)
    {
        _M_pSingleAssignment = new single_assignment<size_t>(_PScheduler);
        _Initialize_choices<0>();
    }

    /// <summary>
    ///     Constructs a <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for the choice.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    choice(ScheduleGroup& _PScheduleGroup, _Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(NULL), _M_pScheduleGroup(&_PScheduleGroup)
    {
        _M_pSingleAssignment = new single_assignment<size_t>(_PScheduleGroup);
        _Initialize_choices<0>();
    }

    /// <summary>
    ///     Constructs a <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_Choice">
    ///     A <c>choice</c> messaging block to copy from.
    ///     Note that the original object is orphaned, making this a move constructor.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    choice(choice && _Choice)
    {
        // Copy scheduler group or scheduler to the new object.
        _M_pScheduleGroup = _Choice._M_pScheduleGroup;
        _M_pScheduler = _Choice._M_pScheduler;

        // Single assignment is heap allocated, so simply copy the pointer. If it already has
        // a value, it will be preserved.
        _M_pSingleAssignment = _Choice._M_pSingleAssignment;
        _Choice._M_pSingleAssignment = NULL;

        // Invoke copy assignment for tuple to copy pointers to message blocks.
        _M_sourceTuple = _Choice._M_sourceTuple;

        // Copy the pointers to order nodes to a new object and zero out in the old object.
        memcpy(_M_pSourceChoices, _Choice._M_pSourceChoices, sizeof(_M_pSourceChoices));
        memset(_Choice._M_pSourceChoices, 0, sizeof(_M_pSourceChoices));
    }

    /// <summary>
    ///     Destroys the <c>choice</c> messaging block.
    /// </summary>
    /**/
    ~choice()
    {
        delete _M_pSingleAssignment;
        _Delete_choices<0>();
    }

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

    /// <summary>
    ///     Checks whether this <c>choice</c> messaging block has been initialized with a value yet.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the block has received a value, <c>false</c> otherwise.
    /// </returns>
    /**/
    bool has_value() const
    {
        return _M_pSingleAssignment->has_value();
    }

    /// <summary>
    ///     Returns an index into the <c>tuple</c> representing the element selected by the
    ///     <c>choice</c> messaging block.
    /// </summary>
    /// <returns>
    ///     The message index.
    /// </returns>
    /// <remarks>
    ///      The message payload can be extracted using the <c>get</c> method.
    /// </remarks>
    /**/
    size_t index()
    {
        return _M_pSingleAssignment->value();
    }

    /// <summary>
    ///     Gets the message whose index was selected by the <c>choice</c> messaging block.
    /// </summary>
    /// <typeparam name="_Payload_type">
    ///     The type of the message payload.
    /// </typeparam>
    /// <returns>
    ///     The payload of the message.
    /// </returns>
    /// <remarks>
    ///     Since a <c>choice</c> messaging block can take inputs with different payload types, you must specify
    ///     the type of the payload at the point of retrieval. You can determine the type based on the result of
    ///     the <c>index</c> method.
    /// </remarks>
    /**/
    template <typename _Payload_type>
    _Payload_type const & value()
    {
        return reinterpret_cast<_Reserving_node<_Payload_type> *>(_M_pSourceChoices[_M_pSingleAssignment->value()])->value();
    }

    //
    // ISource public function implementations
    //

    /// <summary>
    ///     Links a target block to this <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to link to this <c>choice</c> messaging block.
    /// </param>
    /**/
    virtual void link_target(ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->link_target(_PTarget);
    }

    /// <summary>
    ///     Unlinks a target block from this <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to unlink from this <c>choice</c> messaging block.
    /// </param>
    /**/
    virtual void unlink_target(ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->unlink_target(_PTarget);
    }

    /// <summary>
    ///     Unlinks all targets from this <c>choice</c> messaging block.
    /// </summary>
    /// <remarks>
    ///     This method does not need to be called from the destructor because destructor for the internal
    ///     <c>single_assignment</c> block will unlink properly.
    /// </remarks>
    /**/
    virtual void unlink_targets()
    {
        _M_pSingleAssignment->unlink_targets();
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>choice</c> block, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>accept</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<size_t> * accept(runtime_object_identity _MsgId, ITarget<size_t> * _PTarget)
    {
        return _M_pSingleAssignment->accept(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>reserve</c> method.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise. Reservations can fail
    ///     for many reasons, including: the message was already reserved or accepted by another target, the source could
    ///     deny reservations, etc.
    /// </returns>
    /// <remarks>
    ///     After you call <c>reserve</c>, if it succeeds, you must call either <c>consume</c> or <c>release</c>
    ///     in order to take or give up possession of the message, respectively.
    /// </remarks>
    /**/
    virtual bool reserve(runtime_object_identity _MsgId, ITarget<size_t> * _PTarget)
    {
        return _M_pSingleAssignment->reserve(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Consumes a message previously offered by this <c>choice</c> messaging block and successfully reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>consume</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>consume</c> method is similar to <c>accept</c>, but must always be preceded by a call to <c>reserve</c> that
    ///     returned <c>true</c>.
    /// </remarks>
    /**/
    virtual message<size_t> * consume(runtime_object_identity _MsgId, ITarget<size_t> * _PTarget)
    {
        return _M_pSingleAssignment->consume(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Releases a previous successful message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>release</c> method.
    /// </param>
    /**/
    virtual void release(runtime_object_identity _MsgId, ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->release(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Acquires a reference count on this <c>choice</c> messaging block, to prevent deletion.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being linked to this source
    ///     during the <c>link_target</c> method.
    /// </remarks>
    /**/
    virtual void acquire_ref(ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->acquire_ref(_PTarget);
    }

    /// <summary>
    ///     Releases a reference count on this <c>choice</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being unlinked from this source.
    ///     The source block is allowed to release any resources reserved for the target block.
    /// </remarks>
    /**/
    virtual void release_ref(ITarget<size_t> * _PTarget)
    {
        _M_pSingleAssignment->release_ref(_PTarget);
    }

private:

    /// <summary>
    ///     Constructs and initializes a _Reserving_node for each tuple messaging block passed in.
    /// </summary>
    /// <typeparam>The highest-number index of the choice's sources</typeparam>
    /**/
    template<int _Index>
    void _Initialize_choices()
    {
        std::tr1::tuple_element<_Index, _Type>::type _Item = std::tr1::get<_Index>(_M_sourceTuple);
        _Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> * _Order_node_element = NULL;

        if (_M_pScheduleGroup != NULL)
        {
            _Order_node_element = new _Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduleGroup, _Item, _Index);
        }
        else if (_M_pScheduler != NULL)
        {
            _Order_node_element = new _Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduler, _Item, _Index);
        }
        else
        {
            _Order_node_element = new _Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (_Item, _Index);
        }

        _M_pSourceChoices[_Index] = _Order_node_element;
        _Order_node_element->link_target(_M_pSingleAssignment);
        _Initialize_choices<_Index + 1>();
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Initialize_choices recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Initialize_choices<std::tr1::tuple_size<_Type>::value>()
    {
    }

    /// <summary>
    ///     Deletes all _Reserving_node elements that were created in _Initialize_choices.
    /// </summary>
    /// <typeparam>The highest-number index of the choice's sources</typeparam>
    /**/
    template<int _Index>
    void _Delete_choices()
    {
        delete reinterpret_cast<_Reserving_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> *>(_M_pSourceChoices[_Index]);
        _M_pSourceChoices[_Index] = NULL;
        _Delete_choices<_Index + 1>();
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Delete_choices recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Delete_choices<std::tr1::tuple_size<_Type>::value>()
    {
    }

    // Array of pointers to _Reserving_node elements representing each source
    void * _M_pSourceChoices[std::tr1::tuple_size<_Type>::value];

    // Single assignment which chooses between source messaging blocks
    single_assignment<size_t> * _M_pSingleAssignment;

    // Tuple of messaging blocks that are sources to this choice
    _Type _M_sourceTuple;

    // The scheduler to propagate messages on
    Scheduler * _M_pScheduler;

    // The schedule group to propagate messages on
    ScheduleGroup * _M_pScheduleGroup;

private:
    //
    // Hide assignment operator
    //
    choice const &operator =(choice const &);                      // no assignment operator
    choice(choice const &);                                        // no copy constructor
};

// Up to 10 templated factory functions that create a choice, three flavors

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2>
choice<std::tr1::tuple<_Type1, _Type2>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2)
{
    return choice<std::tr1::tuple<_Type1, _Type2>>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
choice<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3>>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_choice(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1>
choice<std::tr1::tuple<_Type1>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1)
{
    return choice<std::tr1::tuple<_Type1>>(_PScheduleGroup, std::tr1::make_tuple(_Item1));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2>
choice<std::tr1::tuple<_Type1, _Type2>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2)
{
    return choice<std::tr1::tuple<_Type1, _Type2>>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
choice<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3>>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>choice</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_choice(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1>
choice<std::tr1::tuple<_Type1>>
make_choice(_Type1 _Item1)
{
    return choice<std::tr1::tuple<_Type1>>(std::tr1::make_tuple(_Item1));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2>
choice<std::tr1::tuple<_Type1, _Type2>>
make_choice(_Type1 _Item1, _Type2 _Item2)
{
    return choice<std::tr1::tuple<_Type1, _Type2>>(std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <summary>
/// Create a choice from a schedule group and three input sources
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
choice<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3>>(std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>choice</c> messaging block from an optional <c>Scheduler</c> or <c>ScheduleGroup</c>
///     and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>choice</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="choice Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_choice(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return choice<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

//**************************************************************************
// Join:
//**************************************************************************

// Template specialization used to unwrap the types from within a tuple.

/**/
template <typename _Tuple> struct _Unwrap;

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/**/
template <typename _T1>
struct _Unwrap<std::tr1::tuple<_T1>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2>
struct _Unwrap<std::tr1::tuple<_T1, _T2>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_Type3">
///     The type of the third element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/// <typeparam name="_T7">
///     The type of the seventh element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6, _T7>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type, typename std::tr1::remove_pointer<_T7>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/// <typeparam name="_T7">
///     The type of the seventh element of the tuple.
/// </typeparam>
/// <typeparam name="_T8">
///     The type of the eighth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type, typename std::tr1::remove_pointer<_T7>::type::source_type, typename std::tr1::remove_pointer<_T8>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/// <typeparam name="_T7">
///     The type of the seventh element of the tuple.
/// </typeparam>
/// <typeparam name="_T8">
///     The type of the eighth element of the tuple.
/// </typeparam>
/// <typeparam name="_T9">
///     The type of the ninth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type, typename std::tr1::remove_pointer<_T7>::type::source_type, typename std::tr1::remove_pointer<_T8>::type::source_type,
        typename std::tr1::remove_pointer<_T9>::type::source_type> type;
};

/// <summary>
///     Template specialization used to unwrap the types from within a tuple.
/// </summary>
/// <typeparam name="_T1">
///     The type of the first element of the tuple.
/// </typeparam>
/// <typeparam name="_T2">
///     The type of the second element of the tuple.
/// </typeparam>
/// <typeparam name="_T3">
///     The type of the third element of the tuple.
/// </typeparam>
/// <typeparam name="_T4">
///     The type of the fourth element of the tuple.
/// </typeparam>
/// <typeparam name="_T5">
///     The type of the fifth element of the tuple.
/// </typeparam>
/// <typeparam name="_T6">
///     The type of the sixth element of the tuple.
/// </typeparam>
/// <typeparam name="_T7">
///     The type of the seventh element of the tuple.
/// </typeparam>
/// <typeparam name="_T8">
///     The type of the eighth element of the tuple.
/// </typeparam>
/// <typeparam name="_T9">
///     The type of the ninth element of the tuple.
/// </typeparam>
/// <typeparam name="_T10">
///     The type of the tenth element of the tuple.
/// </typeparam>
/**/
template <typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10>
struct _Unwrap<std::tr1::tuple<_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10>>
{
    typedef std::tr1::tuple<typename std::tr1::remove_pointer<_T1>::type::source_type, typename std::tr1::remove_pointer<_T2>::type::source_type,
        typename std::tr1::remove_pointer<_T3>::type::source_type, typename std::tr1::remove_pointer<_T4>::type::source_type, typename std::tr1::remove_pointer<_T5>::type::source_type,
        typename std::tr1::remove_pointer<_T6>::type::source_type, typename std::tr1::remove_pointer<_T7>::type::source_type, typename std::tr1::remove_pointer<_T8>::type::source_type,
        typename std::tr1::remove_pointer<_T9>::type::source_type, typename std::tr1::remove_pointer<_T10>::type::source_type> type;
};

/// <summary>
///     Defines a block allowing sources of distinct types to be joined.
///     Join node is a single-target, multi-source ordered propagator block
/// </summary>
/// <typeparam name="_Type">
///     The payload tuple type
/// </typeparam>
/// <typeparam name="_Jtype">
///     The kind of join this is, either 'greedy' or 'non-greedy'
/// </typeparam>
/**/
template<typename _Type, typename _Destination_type, join_type _Jtype>
class _Join_node: public propagator_block<single_link_registry<ITarget<_Destination_type>>, multi_link_registry<ISource<size_t>>>
{
public:

    /// <summary>
    ///     Constructs a join within the default scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /**/
    _Join_node() : _M_counter(std::tr1::tuple_size<_Destination_type>::value)
    {
        initialize_source_and_target();
    }

    /// <summary>
    ///     Constructs a join within the specified scheduler, and places it on any schedule
    ///     group of the schedulers choosing.
    /// </summary>
    /// <param name="_PScheduler">
    ///     A reference to a scheduler instance.
    /// </param>
    /**/
    _Join_node(Scheduler& _PScheduler) : _M_counter(std::tr1::tuple_size<_Destination_type>::value)
    {
        initialize_source_and_target(&_PScheduler);
    }

    /// <summary>
    ///     Constructs a join within the specified schedule group.  The scheduler is implied
    ///     by the schedule group.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     A reference to a schedule group.
    /// </param>
    /**/
    _Join_node(ScheduleGroup& _PScheduleGroup) : _M_counter(std::tr1::tuple_size<_Destination_type>::value)
    {
        initialize_source_and_target(NULL, &_PScheduleGroup);
    }

    /// <summary>
    ///     Cleans up any resources that may have been created by the join.
    /// </summary>
    /**/
    ~_Join_node()
    {
        // Remove all links
        remove_network_links();
    }

protected:

    /// <summary>
    ///     Asynchronously passes a message from an <c>ISource</c> block to this <c>ITarget</c> block. It is invoked
    ///     by the <c>propagate</c> method, when called by a source block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to the <c>message</c> object.
    /// </param>
    /// <param name="_PSource">
    ///     A pointer to the source block offering the message.
    /// </param>
    /// <returns>
    ///     A <see cref="message_status Enumeration">message_status</see> indication of what
    ///     the target decided to do with the message.
    /// </returns>
    /**/
    virtual message_status propagate_message(message<size_t> * _PMessage, ISource<size_t> * _PSource)
    {
        // This join block is connected to the _Order_node sources, which know not to send
        // any more messages until join propagates them further. That is why join can
        // always accept the incoming messages.

        _PMessage = _PSource->accept(_PMessage->msg_id(), this);

        //
        // Source block created an int message only to notify join that the real
        // payload is available. There is no need to keep this message around.
        //
        _ASSERTE(_PMessage != NULL);
        delete _PMessage;

        long _Ret_val = _InterlockedDecrement(&_M_counter);

        _ASSERTE(_Ret_val >= 0);

        if (_Ret_val == 0)
        {
            //
            // All source messages are now received so join can propagate them further
            //
            async_send(NULL);
        }

        return accepted;
    }

    /// <summary>
    ///     Accepts an offered message by the source, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Destination_type> * accept_message(runtime_object_identity _MsgId)
    {
        //
        // Peek at the head message in the message buffer.  If the Ids match
        // dequeue and transfer ownership
        //
        message<_Destination_type> * _Msg = NULL;

        if (_M_messageBuffer._Is_head(_MsgId))
        {
            _Msg = _M_messageBuffer._Dequeue();
        }

        return _Msg;
    }

    /// <summary>
    ///     Reserves a message previously offered by the source.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A bool indicating whether the reservation worked or not.
    /// </returns>
    /// <remarks>
    ///     After <c>reserve</c> is called, if it returns <c>true</c>, either <c>consume</c> or <c>release</c> must be called
    ///     to either take or release ownership of the message.
    /// </remarks>
    /**/
    virtual bool reserve_message(runtime_object_identity _MsgId)
    {
        // Allow reservation if this is the head message
        return _M_messageBuffer._Is_head(_MsgId);
    }

    /// <summary>
    ///     Consumes a message previously offered by the source and reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     <c>consume_message</c> is similar to <c>accept</c>, but is always preceded by a call to <c>reserve</c>.
    /// </remarks>
    /**/
    virtual message<_Destination_type> * consume_message(runtime_object_identity _MsgId)
    {
        // By default, accept the message
        return accept_message(_MsgId);
    }

    /// <summary>
    ///     Releases a previous message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The runtime object identity of the message.
    /// </param>
    /**/
    virtual void release_message(runtime_object_identity _MsgId)
    {
        // The head message is the one reserved.
        if (!_M_messageBuffer._Is_head(_MsgId))
        {
            throw message_not_found();
        }
    }

    /// <summary>
    ///     Resumes propagation after a reservation has been released
    /// </summary>
    /**/
    virtual void resume_propagation()
    {
        // If there are any messages in the buffer, propagate them out
        if (_M_messageBuffer._Count() > 0)
        {
            async_send(NULL);
        }
    }

    /// <summary>
    ///     Notification that a target was linked to this source.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the newly linked target.
    /// </param>
    /**/
    virtual void link_target_notification(ITarget<_Destination_type> *)
    {
        // There is only a single target.
        _Propagate_priority_order(_M_messageBuffer);
    }

    /// <summary>
    ///     Takes the message and propagates it to all the targets of this <c>join</c> block.
    /// </summary>
    /// <param name="_PMessage">
    ///     A pointer to a new message.
    /// </param>
    /// <remarks>
    ///     This function packages source payloads into a tuple message and immediately sends it to the targets.
    /// </remarks>
    /**/
    virtual void propagate_to_any_targets(message<_Destination_type> *)
    {
        message<_Destination_type> * _Msg = NULL;

        if (_M_counter == 0)
        {
            bool fIsNonGreedy = (_Jtype == non_greedy);

            if (fIsNonGreedy)
            {
                if (!_Non_greedy_acquire_messages())
                {
                    return;
                }
            }

            if (!fIsNonGreedy)
            {
                // Since a greedy join has captured all input, we can reset
                // the counter to the total number of inputs
                _InterlockedExchange(&_M_counter, std::tr1::tuple_size<_Destination_type>::value);
            }

            _Msg = _Create_send_message();
        }

        if (_Msg != NULL)
        {
            _M_messageBuffer._Enqueue(_Msg);

            if (!_M_messageBuffer._Is_head(_Msg->msg_id()))
            {
                // another message is at the head of the outbound message queue and blocked
                // simply return
                return;
            }
        }

        _Propagate_priority_order(_M_messageBuffer);
    }

private:

    /// <summary>
    ///     Tries to reserve from all sources.  If successful, it will consume all the messages
    /// </summary>
    /// <returns>
    ///     A bool indicating whether the consumption attempt worked.
    /// </returns>
    /// <typeparam name="_Index">
    ///     The highest-number index of the join's sources
    /// </typeparam>
    /**/
    template<int _Index>
    bool _Try_consume_source_messages(_Destination_type & _Destination_tuple, ISource<size_t> ** _Sources)
    {
        _Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> * _Node =
            static_cast<_Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> *>(_Sources[_Index]);

        // Increment the counter once for each reservation
        _InterlockedIncrement(&_M_counter);

        if (_Node->_Reserve_received_message())
        {
            bool _Ret_val = _Try_consume_source_messages<_Index + 1>(_Destination_tuple, _Sources);

            if (_Ret_val)
            {
                _Node->_Consume_received_message();
            }
            else
            {
                if (_Node->_Release_received_message())
                {
                    // If _Release_received_message() restored the ID, decrement the count for that
                    // restoration
                    if (_InterlockedDecrement(&_M_counter) == 0)
                    {
                        async_send(NULL);
                    }
                }
            }

            return _Ret_val;
        }

        return false;
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Try_consume_source_messages recursive
    ///     template expansion.
    /// </summary>
    /// <returns>
    ///     A bool indicating whether the consumption attempt worked.
    /// </returns>
    /**/
    template<> bool _Try_consume_source_messages<std::tr1::tuple_size<_Type>::value>(_Destination_type &, ISource<size_t> **)
    {
        return true;
    }

    /// <summary>
    ///     Tries to acquire all of the messages from the _Non_greedy_nodes.  Each node has already
    ///     indicated that it has received a message that it can try to reserve.  This function
    ///     starts the reservation and consume process.
    /// </summary>
    /// <returns>
    ///     A bool indicating whether the reserve/consume of all messages succeeded.
    /// </returns>
    /**/
    bool _Non_greedy_acquire_messages()
    {
        _Destination_type _Destination_tuple;

        // Populate the sources buffer
        ISource<size_t> * _Sources[std::tr1::tuple_size<_Type>::value];
        size_t _Index = 0;

        // Get an iterator which will keep a reference on the connected sources
        source_iterator _Iter = _M_connectedSources.begin();

        while (*_Iter != NULL)
        {
            ISource<size_t> * _PSource = *_Iter;

            if (_PSource == NULL)
            {
                // One of the sources disconnected
                break;
            }

            if (_Index >= std::tr1::tuple_size<_Type>::value)
            {
                // More sources that we expect
                break;
            }

            _Sources[_Index] = _PSource;
            _Index++;
            ++_Iter;
        }

        // The order nodes should not have unlinked while the join node is
        // active.

        if (_Index != std::tr1::tuple_size<_Type>::value)
        {
            // On debug build assert to help debugging
            _ASSERTE(_Index == std::tr1::tuple_size<_Type>::value);
            return false;
        }

        bool _IsAcquireSuccessful = _Try_consume_source_messages<0>(_Destination_tuple, _Sources);

        return _IsAcquireSuccessful;
    }

    /// <summary>
    ///     Propagate messages in priority order
    /// </summary>
    /// <param name="_MessageBuffer">
    ///     Reference to a message queue with messages to be propagated
    /// </param>
    /**/
    void _Propagate_priority_order(::Concurrency::details::_Queue<message<_Target_type>> & _MessageBuffer)
    {
        message<_Target_type> * _Msg = _MessageBuffer._Peek();

        // If someone has reserved the _Head message, don't propagate anymore
        if (_M_pReservedFor != NULL)
        {
            return;
        }

        while (_Msg != NULL)
        {
            message_status _Status = declined;

            // Always start from the first target that linked
            for (target_iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Target_type> * _PTarget = *_Iter;
                _Status = _PTarget->propagate(_Msg, this);

                // Ownership of message changed. Do not propagate this
                // message to any other target.
                if (_Status == accepted)
                {
                    break;
                }

                // If the target just propagated to reserved this message, stop
                // propagating it to others
                if (_M_pReservedFor != NULL)
                {
                    break;
                }
            }

            // If status is anything other than accepted, then the head message
            // was not propagated out.  Thus, nothing after it in the queue can
            // be propagated out.  Cease propagation.
            if (_Status != accepted)
            {
                break;
            }

            // Get the next message
            _Msg = _MessageBuffer._Peek();
        }
    }

    /// <summary>
    ///     Called when all the source messaging blocks have received their messages. The payloads are copied
    ///     into local tuple and then packaged into a message to be propagated: _M_pSendMessage.
    /// </summary>
    /**/
    message<_Destination_type> * _Create_send_message()
    {
        _Destination_type _Destination_tuple;

        // Populate the sources buffer
        ISource<size_t> * _Sources[std::tr1::tuple_size<_Type>::value];
        size_t _Index = 0;

        // Get an iterator which will keep a reference on the connected sources
        source_iterator _Iter = _M_connectedSources.begin();

        while (*_Iter != NULL)
        {
            ISource<size_t> * _PSource = *_Iter;

            if (_PSource == NULL)
            {
                // One of the sources disconnected
                break;
            }

            // Avoid buffer overrun
            if (_Index >= std::tr1::tuple_size<_Type>::value)
            {
                // More sources that we expect
                break;
            }

            _Sources[_Index] = *_Iter;
            _Index++;
            ++_Iter;
        }

        // The order nodes should not have unlinked while the join node is
        // active.
        if (_Index != std::tr1::tuple_size<_Type>::value)
        {
            // On debug build assert to help debugging
            _ASSERTE(_Index == std::tr1::tuple_size<_Type>::value);
            return NULL;
        }

        _Populate_destination_tuple<0>(_Destination_tuple, _Sources);

        return new message<_Destination_type>(_Destination_tuple);
    }

    /// <summary>
    ///     Copies payloads from all sources to destination tuple.
    /// </summary>
    /**/
    template<int _Index>
    void _Populate_destination_tuple(_Destination_type & _Destination_tuple, ISource<size_t> ** _Sources)
    {
        _Order_node_base<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> * _Node =
            static_cast<_Order_node_base<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> *>(_Sources[_Index]);

        std::tr1::get<_Index>(_Destination_tuple) = _Node->value();
        _Node->_Reset();

        _Populate_destination_tuple<_Index + 1>(_Destination_tuple, _Sources);
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Populate_destination_tuple recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Populate_destination_tuple<std::tr1::tuple_size<_Type>::value>(_Destination_type &, ISource<size_t> **)
    {
    }

    // A tuple containing a collection of source messaging blocks
    _Type _M_sourceTuple;

    // Counts messages received by sources of this node and is used to trigger propagation to targets
    // This value starts at the total number of inputs and counts down to zero.  When it reaches zero,
    // a join of the inputs is started.
    volatile long _M_counter;

    // Buffer to hold outgoing messages
    ::Concurrency::details::_Queue<message<_Destination_type>> _M_messageBuffer;

private:
    //
    // Hide assignment operator and copy constructor
    //
    _Join_node(const _Join_node & _Join);                                  // no copy constructor
    _Join_node const &operator =(_Join_node const &);                      // no assignment operator
};

/// <summary>
///     A <c>multitype_join</c> messaging block is a multi-source, single-target messaging block that
///     combines together messages of different types from each of its sources and offers a tuple
///     of the combined messages to its targets.
/// </summary>
/// <typeparam name="_Type">
///     The <c>tuple</c> payload type of the messages joined and propagated by the block.
/// </typeparam>
/// <typeparam name="_Jtype">
///     The kind of <c>join</c> block this is, either <c>greedy</c> or <c>non_greedy</c>
/// </typeparam>
/// <remarks>
///     For more information, see <see cref="Asynchronous Message Blocks"/>.
/// </remarks>
/// <seealso cref="choice Class"/>
/// <seealso cref="join Class"/>
/// <seealso cref="join_type Enumeration"/>
/// <seealso cref="make_join Function"/>
/// <seealso cref="make_greedy_join Function"/>
/// <seealso cref="tuple Class"/>
/**/
template<typename _Type, join_type _Jtype = non_greedy>
class multitype_join: public ISource<typename _Unwrap<_Type>::type>
{
public:

    typedef typename _Unwrap<_Type>::type _Destination_type;

    /// <summary>
    ///     Constructs a <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for this <c>multitype_join</c> messaging block.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    explicit multitype_join(_Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(NULL), _M_pScheduleGroup(NULL)
    {
        _M_pJoinNode = new _Join_node<_Type, _Destination_type, _Jtype>();
        _Initialize_joins<0>();
    }

    /// <summary>
    ///     Constructs a <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
    /// </param>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for this <c>multitype_join</c> messaging block.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    multitype_join(Scheduler& _PScheduler, _Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(&_PScheduler), _M_pScheduleGroup(NULL)
    {
        _M_pJoinNode = new _Join_node<_Type, _Destination_type, _Jtype>(_PScheduler);
        _Initialize_joins<0>();
    }

    /// <summary>
    ///     Constructs a <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_PScheduleGroup">
    ///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <param name="_Tuple">
    ///     A <c>tuple</c> of sources for this <c>multitype_join</c> messaging block.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    multitype_join(ScheduleGroup& _PScheduleGroup, _Type _Tuple) : _M_sourceTuple(_Tuple), _M_pScheduler(NULL), _M_pScheduleGroup(&_PScheduleGroup)
    {
        _M_pJoinNode = new _Join_node<_Type, _Destination_type, _Jtype>(_PScheduleGroup);
        _Initialize_joins<0>();
    }

    /// <summary>
    ///     Constructs a <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_Join">
    ///     A <c>multitype_join</c> messaging block to copy from.
    ///     Note that the original object is orphaned, making this a move constructor.
    /// </param>
    /// <remarks>
    ///     <para>
    ///         The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///         or <paramref name="_PScheduleGroup"/> parameters.
    ///     </para>
    ///     <para>
    ///         Move construction is not performed under a lock, which means that it is up to the user
    ///         to make sure that there are no light-weight tasks in flight at the time of moving.
    ///         Otherwise, numerous races can occur, leading to exceptions or inconsistent state.
    ///     </para>
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    multitype_join(multitype_join && _Join)
    {
        // Copy scheduler group or scheduler to the new object.
        _M_pScheduleGroup = _Join._M_pScheduleGroup;
        _M_pScheduler = _Join._M_pScheduler;

        // Single assignment is heap allocated, so simply copy the pointer. If it already has
        // a value, it will be preserved.
        _M_pJoinNode = _Join._M_pJoinNode;
        _Join._M_pJoinNode = NULL;

        // Invoke copy assignment for tuple to copy pointers to message blocks.
        _M_sourceTuple = _Join._M_sourceTuple;

        // Copy the pointers to order nodes to a new object and zero out in the old object.
        memcpy(_M_pSourceJoins, _Join._M_pSourceJoins, sizeof(_M_pSourceJoins));
        memset(_Join._M_pSourceJoins, 0, sizeof(_M_pSourceJoins));
    }

    /// <summary>
    ///     Destroys the <c>multitype_join</c> messaging block.
    /// </summary>
    /**/
    ~multitype_join()
    {
        delete _M_pJoinNode;
        _Delete_joins<0>();
    }

    /// <summary>
    ///     A type alias for <typeparamref name="_Type"/>.
    /// </summary>
    /**/
    typedef typename _Type type;

    //
    // ISource public function implementations
    //

    /// <summary>
    ///     Links a target block to this <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to link to this <c>multitype_join</c> messaging block.
    /// </param>
    /**/
    virtual void link_target(ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->link_target(_PTarget);
    }

    /// <summary>
    ///     Unlinks a target block from this <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to an <c>ITarget</c> block to unlink from this <c>multitype_join</c> messaging block.
    /// </param>
    /**/
    virtual void unlink_target(ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->unlink_target(_PTarget);
    }

    /// <summary>
    ///     Unlinks all targets from this <c>multitype_join</c> messaging block.
    /// </summary>
    /**/
    virtual void unlink_targets()
    {
        _M_pJoinNode->unlink_targets();
    }

    /// <summary>
    ///     Accepts a message that was offered by this <c>multitype_join</c> block, transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the offered <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>accept</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the message that the caller now has ownership of.
    /// </returns>
    /**/
    virtual message<_Destination_type> * accept(runtime_object_identity _MsgId, ITarget<_Destination_type> * _PTarget)
    {
        return _M_pJoinNode->accept(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Reserves a message previously offered by this <c>multitype_join</c> messaging block.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being reserved.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>reserve</c> method.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the message was successfully reserved, <c>false</c> otherwise. Reservations can fail
    ///     for many reasons, including: the message was already reserved or accepted by another target, the source could
    ///     deny reservations, etc.
    /// </returns>
    /// <remarks>
    ///     After you call <c>reserve</c>, if it succeeds, you must call either <c>consume</c> or <c>release</c>
    ///     in order to take or give up possession of the message, respectively.
    /// </remarks>
    /**/
    virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Destination_type> * _PTarget)
    {
        return _M_pJoinNode->reserve(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Consumes a message previously offered by the <c>multitype_join</c> messaging block and successfully reserved by the target,
    ///     transferring ownership to the caller.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the reserved <c>message</c> object.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>consume</c> method.
    /// </param>
    /// <returns>
    ///     A pointer to the <c>message</c> object that the caller now has ownership of.
    /// </returns>
    /// <remarks>
    ///     The <c>consume</c> method is similar to <c>accept</c>, but must always be preceded by a call to <c>reserve</c> that
    ///     returned <c>true</c>.
    /// </remarks>
    /**/
    virtual message<_Destination_type> * consume(runtime_object_identity _MsgId, ITarget<_Destination_type> * _PTarget)
    {
        return _M_pJoinNode->consume(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Releases a previous successful message reservation.
    /// </summary>
    /// <param name="_MsgId">
    ///     The <c>runtime_object_identity</c> of the <c>message</c> object being released.
    /// </param>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling the <c>release</c> method.
    /// </param>
    /**/
    virtual void release(runtime_object_identity _MsgId, ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->release(_MsgId, _PTarget);
    }

    /// <summary>
    ///     Acquires a reference count on this <c>multitype_join</c> messaging block, to prevent deletion.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being linked to this source
    ///     during the <c>link_target</c> method.
    /// </remarks>
    /**/
    virtual void acquire_ref(ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->acquire_ref(_PTarget);
    }

    /// <summary>
    ///     Releases a reference count on this <c>multiple_join</c> messaging block.
    /// </summary>
    /// <param name="_PTarget">
    ///     A pointer to the target block that is calling this method.
    /// </param>
    /// <remarks>
    ///     This method is called by an <c>ITarget</c> object that is being unlinked from this source.
    ///     The source block is allowed to release any resources reserved for the target block.
    /// </remarks>
    /**/
    virtual void release_ref(ITarget<_Destination_type> * _PTarget)
    {
        _M_pJoinNode->release_ref(_PTarget);
    }

private:

    /// <summary>
    ///     Constructs and initializes a _Order_node for each tuple messaging block passed in.
    /// </summary>
    /// <typeparam name="_Index">
    ///     The highest-number index of the multitype_join's sources
    /// </typeparam>
    /**/
    template<int _Index>
    void _Initialize_joins()
    {
        std::tr1::tuple_element<_Index, _Type>::type _Item = std::tr1::get<_Index>(_M_sourceTuple);
        _Order_node_base<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> * _Order_node_element = NULL;

        bool fIsNonGreedy = (_Jtype == non_greedy);

        if (fIsNonGreedy)
        {
            if (_M_pScheduleGroup != NULL)
            {
                _Order_node_element = new _Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduleGroup, _Item, _Index);
            }
            else if (_M_pScheduler != NULL)
            {
                _Order_node_element = new _Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduler, _Item, _Index);
            }
            else
            {
                _Order_node_element = new _Non_greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (_Item, _Index);
            }
        }
        else
        {
            if (_M_pScheduleGroup != NULL)
            {
                _Order_node_element = new _Greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduleGroup, _Item, _Index);
            }
            else if (_M_pScheduler != NULL)
            {
                _Order_node_element = new _Greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (*_M_pScheduler, _Item, _Index);
            }
            else
            {
                _Order_node_element = new _Greedy_node<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> (_Item, _Index);
            }
        }
        _M_pSourceJoins[_Index] = _Order_node_element;
        _Order_node_element->link_target(_M_pJoinNode);
        _Initialize_joins<_Index + 1>();
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Initialize_joins recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Initialize_joins<std::tr1::tuple_size<_Type>::value>()
    {
    }

    /// <summary>
    ///     Deletes all _Order_node elements that were created in _Initialize_joins.
    /// </summary>
    /// <typeparam name="_Index">
    ///     The highest-number index of the multitype_join's sources
    /// </typeparam>
    /**/
    template<int _Index>
    void _Delete_joins()
    {
        delete reinterpret_cast<_Order_node_base<std::tr1::remove_pointer<std::tr1::tuple_element<_Index, _Type>::type>::type::source_type> *>(_M_pSourceJoins[_Index]);
        _M_pSourceJoins[_Index] = NULL;
        _Delete_joins<_Index + 1>();
    }

    /// <summary>
    ///     Provides a sentinel template specialization for _Delete_joins recursive
    ///     template expansion.
    /// </summary>
    /**/
    template<> void _Delete_joins<std::tr1::tuple_size<_Type>::value>()
    {
    }

    // Array of pointers to _Order_node elements representing each source
    void * _M_pSourceJoins[std::tr1::tuple_size<_Type>::value];

    // Join node that collects source messaging block messages
    _Join_node<_Type, _Destination_type, _Jtype> * _M_pJoinNode;

    // Tuple of messaging blocks that are sources to this multitype_join
    _Type _M_sourceTuple;

    // The scheduler to propagate messages on
    Scheduler * _M_pScheduler;

    // The schedule group to propagate messages on
    ScheduleGroup * _M_pScheduleGroup;

private:
    //
    // Hide assignment operator
    //
    multitype_join const &operator =(multitype_join const &);                      // no assignment operator
    multitype_join(multitype_join const &);                                        // no copy constructor
};

// Up to 10 templated factory functions that create a join, three flavors

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>>
make_join(_Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>>(std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>>(std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>non_greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>non_greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
make_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

// Up to 10 templated factory functions that create a *greedy* join, three flavors

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block
///     is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>(_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}


/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduler">
///     The <c>Scheduler</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="Scheduler Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
make_greedy_join(Scheduler& _PScheduler, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
        (_PScheduler, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>(_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_PScheduleGroup">
///     The <c>ScheduleGroup</c> object within which the propagation task for the <c>multitype_join</c> messaging block is scheduled.
///     The <c>Scheduler</c> object used is implied by the schedule group.
/// </param>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/// <seealso cref="ScheduleGroup Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
make_greedy_join(ScheduleGroup& _PScheduleGroup, _Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
        (_PScheduleGroup, std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2>
multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2>, greedy>(std::tr1::make_tuple(_Item1, _Item2));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3>, greedy>(std::tr1::make_tuple(_Item1, _Item2, _Item3));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9));
}

/// <summary>
///     Constructs a <c>greedy multitype_join</c> messaging block from an optional <c>Scheduler</c>
///     or <c>ScheduleGroup</c> and between two and ten input sources.
/// </summary>
/// <typeparam name="_Type1">
///     The message block type of the first source.
/// </typeparam>
/// <typeparam name="_Type2">
///     The message block type of the second source.
/// </typeparam>
/// <typeparam name="_Type3">
///     The message block type of the third source.
/// </typeparam>
/// <typeparam name="_Type4">
///     The message block type of the fourth source.
/// </typeparam>
/// <typeparam name="_Type5">
///     The message block type of the fifth source.
/// </typeparam>
/// <typeparam name="_Type6">
///     The message block type of the sixth source.
/// </typeparam>
/// <typeparam name="_Type7">
///     The message block type of the seventh source.
/// </typeparam>
/// <typeparam name="_Type8">
///     The message block type of the eighth source.
/// </typeparam>
/// <typeparam name="_Type9">
///     The message block type of the ninth source.
/// </typeparam>
/// <typeparam name="_Type10">
///     The message block type of the tenth source.
/// </typeparam>
/// <param name="_Item1">
///     The first source.
/// </param>
/// <param name="_Item2">
///     The second source.
/// </param>
/// <param name="_Item3">
///     The third source.
/// </param>
/// <param name="_Item4">
///     The fourth source.
/// </param>
/// <param name="_Item5">
///     The fifth source.
/// </param>
/// <param name="_Item6">
///     The sixth source.
/// </param>
/// <param name="_Item7">
///     The seventh source.
/// </param>
/// <param name="_Item8">
///     The eighth source.
/// </param>
/// <param name="_Item9">
///     The ninth source.
/// </param>
/// <param name="_Item10">
///     The tenth source.
/// </param>
/// <returns>
///     A <c>greedy multitype_join</c> message block with between two and ten input sources.
/// </returns>
/// <seealso cref="multitype_join Class"/>
/**/
template<typename _Type1, typename _Type2, typename _Type3, typename _Type4, typename _Type5, typename _Type6,
    typename _Type7, typename _Type8, typename _Type9, typename _Type10>
multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
make_greedy_join(_Type1 _Item1, _Type2 _Item2, _Type3 _Item3, _Type4 _Item4, _Type5 _Item5, _Type6 _Item6, _Type7 _Item7,
        _Type8 _Item8, _Type9 _Item9, _Type10 _Item10)
{
    return multitype_join<std::tr1::tuple<_Type1, _Type2, _Type3, _Type4, _Type5, _Type6, _Type7, _Type8, _Type9, _Type10>, greedy>
        (std::tr1::make_tuple(_Item1, _Item2, _Item3, _Item4, _Item5, _Item6, _Item7, _Item8, _Item9, _Item10));
}

//**************************************************************************
// Agents:
//**************************************************************************

/// <summary>
///     The valid states for an <c>agent</c>.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Asynchronous Agents"/>.
/// </remarks>
/**/
enum agent_status {
    /// <summary>
    ///     The <c>agent</c> has been created but not started.
    /// </summary>
    /**/
    agent_created,
    /// <summary>
    ///     The <c>agent</c> has been started, but not entered its <c>run</c> method.
    /// </summary>
    /**/
    agent_runnable,
    /// <summary>
    ///     The <c>agent</c> has started.
    /// </summary>
    /**/
    agent_started,
    /// <summary>
    ///     The <c>agent</c> finished without being canceled.
    /// </summary>
    /**/
    agent_done,
    /// <summary>
    ///     The <c>agent</c> was canceled.
    /// </summary>
    /**/
    agent_canceled
};

/// <summary>
///     A class intended to be used as a base class for all independent agents. It is used to hide
///     state from other agents and interact via message-passing.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Asynchronous Agents"/>.
/// </remarks>
/**/
class agent
{
public:
    /// <summary>
    ///     Constructs an agent.
    /// </summary>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP2 agent();

    /// <summary>
    ///     Constructs an agent.
    /// </summary>
    /// <param name="_PScheduler">
    ///     The <c>Scheduler</c> object within which the execution task of the agent is scheduled.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP2 agent(Scheduler& _PScheduler);

    /// <summary>
    ///     Constructs an agent.
    /// </summary>
    /// <param name="_PGroup">
    ///     The <c>ScheduleGroup</c> object within which the execution task of the agent is scheduled.
    ///     The <c>Scheduler</c> object used is implied by the schedule group.
    /// </param>
    /// <remarks>
    ///     The runtime uses the default scheduler if you do not specify the <paramref name="_PScheduler"/>
    ///     or <paramref name="_PGroup"/> parameters.
    /// </remarks>
    /// <seealso cref="Scheduler Class"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP2 agent(ScheduleGroup& _PGroup);

    /// <summary>
    ///     Destroys the agent.
    /// </summary>
    /// <remarks>
    ///     It is an error to destroy an agent that is not in a terminal state (either <c>agent_done</c> or
    ///     <c>agent_canceled</c>). This can be avoided by waiting for the agent to reach a terminal state
    ///     in the destructor of a class that inherits from the <c>agent</c> class.
    /// </remarks>
    /**/
    _CRTIMP2 virtual ~agent();

    /// <summary>
    ///     An asynchronous source of status information from the agent.
    /// </summary>
    /// <returns>
    ///     Returns a message source that can send messages about the current state of the agent.
    /// </returns>
    /**/
    _CRTIMP2 ISource<agent_status> * status_port();

    /// <summary>
    ///     A synchronous source of status information from the agent.
    /// </summary>
    /// <returns>
    ///     Returns the current state of the agent.  Note that this returned state could change
    ///     immediately after being returned.
    /// </returns>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 agent_status status();

    /// <summary>
    ///     Moves an agent from the <c>agent_created</c> state to the <c>agent_runnable</c> state, and schedules it for execution.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the agent started correctly, <c>false</c> otherwise. An agent that has been canceled cannot be started.
    /// </returns>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 bool start();

    /// <summary>
    ///     Moves an agent from either the <c>agent_created</c> or <c>agent_runnable</c> states to the <c>agent_canceled</c> state.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the agent was canceled, <c>false</c> otherwise. An agent cannot be canceled if it has already started
    ///     running or has already completed.
    /// </returns>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 bool cancel();

    /// <summary>
    ///     Waits for an agent to complete its task.
    /// </summary>
    /// <param name="_PAgent">
    ///     A pointer to the agent to wait for.
    /// </param>
    /// <param name="_Timeout">
    ///     The maximum time for which to wait, in milliseconds.
    /// </param>
    /// <returns>
    ///     The <c>agent_status</c> of the agent when the wait completes. This can either be <c>agent_canceled</c>
    ///     or <c>agent_done</c>.
    /// </returns>
    /// <remarks>
    ///     An agent task is completed when the agent enters the <c>agent_canceled</c> or <c>agent_done</c> states.
    ///     <para>If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
    ///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
    ///     of time expires before the agent has completed its task.</para>
    /// </remarks>
    /// <seealso cref="agent::wait_for_all Method"/>
    /// <seealso cref="agent::wait_for_one Method"/>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 static agent_status __cdecl wait(agent * _PAgent, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

    /// <summary>
    ///     Waits for all of the specified agents to complete their tasks.
    /// </summary>
    /// <param name="_Count">
    ///     The number of agent pointers present in the array <paramref name="_PAgents"/>.
    /// </param>
    /// <param name="_PAgents">
    ///     An array of pointers to the agents to wait for.
    /// </param>
    /// <param name="_PStatus">
    ///     A pointer to an array of agent statuses. Each status value will represent the status of the corresponding
    ///     agent when the method returns.
    /// </param>
    /// <param name="_Timeout">
    ///     The maximum time for which to wait, in milliseconds.
    /// </param>
    /// <remarks>
    ///     An agent task is completed when the agent enters the <c>agent_canceled</c> or <c>agent_done</c> states.
    ///     <para>If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
    ///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
    ///     of time expires before the agent has completed its task.</para>
    /// </remarks>
    /// <seealso cref="agent::wait Method"/>
    /// <seealso cref="agent::wait_for_one Method"/>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 static void __cdecl wait_for_all(size_t _Count, __in_ecount(_Count) agent ** _PAgents,
        __out_ecount_opt(_Count) agent_status * _PStatus = NULL, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

    /// <summary>
    ///     Waits for any one of the specified agents to complete its task.
    /// </summary>
    /// <param name="_Count">
    ///     The number of agent pointers present in the array <paramref name="_PAgents"/>.
    /// </param>
    /// <param name="_PAgents">
    ///     An array of pointers to the agents to wait for.
    /// </param>
    /// <param name="_Status">
    ///     A reference to a variable where the agent status will be placed.
    /// </param>
    /// <param name="_Index">
    ///     A reference to a variable where the agent index will be placed.
    /// </param>
    /// <param name="_Timeout">
    ///     The maximum time for which to wait, in milliseconds.
    /// </param>
    /// <remarks>
    ///     An agent task is completed when the agent enters the <c>agent_canceled</c> or <c>agent_done</c> states.
    ///     <para>If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
    ///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
    ///     of time expires before the agent has completed its task.</para>
    /// </remarks>
    /// <seealso cref="agent::wait Method"/>
    /// <seealso cref="agent::wait_for_all Method"/>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 static void __cdecl wait_for_one(size_t _Count, agent ** _PAgents, agent_status& _Status,
                                      size_t& _Index, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

protected:
    /// <summary>
    ///     Represents the main task of an agent. <c>run</c> should be overridden in a derived class, and specifies what
    ///     the agent should do after it has been started.
    /// </summary>
    /// <remarks>
    ///     The agent status is changed to <c>agent_started</c> right before this method is invoked. The method should
    ///     invoke <c>done</c> on the agent with an appropriate status before returning, and may not throw any
    ///     exceptions.
    /// </remarks>
    /**/
    virtual void run() = 0;

    /// <summary>
    ///     Moves an agent into the <c>agent_done</c> state, indicating that the agent has completed.
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the agent is moved to the <c>agent_done</c> state, <c>false</c> otherwise. An agent that has
    ///     been canceled cannot be moved to the <c>agent_done</c> state.
    /// </returns>
    /// <remarks>
    ///     This method should be called at the end of the <c>run</c> method, when you know the execution of your agent
    ///     has completed.
    /// </remarks>
    /// <seealso cref="agent_status Enumeration"/>
    /**/
    _CRTIMP2 bool done();

    /// <summary>
    ///     Holds the current status of the agent.
    /// </summary>
    /**/
    overwrite_buffer<agent_status> _M_status;

private:

    // A flag to check of whether the agent can be started
    // This is initialized to TRUE and there is a race between Start() and Cancel() to set it
    // to FALSE.  Once Started or Canceled, further calls to Start() or Cancel() will return false.
    /**/
    volatile long _M_fStartable;

    // A flag to check of whether the agent can be canceled
    // This is initailized to TRUE and there is a race between Cancel() and the LWT executing
    // a task that has been started to set it to FALSE.  If Cancel() wins, the task will not be
    // executed.  If the LWT wins, Cancel() will return false.
    /**/
    volatile long _M_fCancelable;

    // A static wrapper function that calls the Run() method.  Used for scheduling of the task
    /**/
    static void __cdecl _Agent_task_wrapper(void * data);

    Scheduler * _M_pScheduler;
    ScheduleGroup * _M_pScheduleGroup;
};

//**************************************************************************
// Direct Messaging APIs:
//**************************************************************************

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.  If the specified timeout is not
///     COOPERATIVE_TIMEOUT_INFINITE, an exception (operation_timed_out) will be thrown if the specified amount
///     of time expires before a message is received.  Note that zero length timeouts should likely use
///     try_receive as opposed to receive with a timeout of zero as it is more efficient and does not
///     throw exceptions on timeouts.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/// <param name="_Src">
///     A pointer to the source from which data is expected.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <param name="_Filter_proc">
///     A pointer to a filter which will indicate whether to accept the data or not.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/**/
template <class _Type>
_Type _receive_impl(ISource<_Type> * _Src, unsigned int _Timeout, typename ITarget<_Type>::filter_method const* _Filter_proc)
{
    // The Blocking Recipient messaging block class is internal to the receive function
    class _Blocking_recipient : public ITarget<_Type>
    {
    public:
        // Create an Blocking Recipient
        _Blocking_recipient(ISource<_Type> * _PSource,
            unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE) :
            _M_pFilter(NULL), _M_pConnectedTo(NULL), _M_pMessage(NULL), _M_fState(_NotInitialized), _M_timeout(_Timeout)
        {
            _Connect(_PSource);
        }

        // Create an Blocking Recipient
        _Blocking_recipient(ISource<_Type> * _PSource,
            filter_method const& _Filter,
            unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE) :
            _M_pFilter(NULL), _M_pConnectedTo(NULL), _M_pMessage(NULL), _M_fState(_NotInitialized), _M_timeout(_Timeout)
        {
            if (_Filter != NULL)
            {
                _M_pFilter = new filter_method(_Filter);
            }

            _Connect(_PSource);
        }

        // Cleans up any resources that may have been created by the BlockingRecipient.
        ~_Blocking_recipient()
        {
            _Disconnect();

            delete _M_pFilter;
            delete _M_pMessage;
        }

        // Gets the value of the message sent to this BlockingRecipient.  Blocks by
        // spinning until a message has arrived.
        _Type _Value()
        {
            _Wait_for_message();

            return _M_pMessage->payload;
        }

        // The main propagation function for ITarget blocks.  Called by a source
        // block, generally within an asynchronous task to send messages to its targets.
        virtual message_status propagate(message<_Type> * _PMessage, ISource<_Type> * _PSource)
        {
            // Throw exception if the message being propagated to this block is NULL
            if (_PMessage == NULL)
            {
                throw std::invalid_argument("_PMessage");
            }

            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            // Reject if the message does not meet the filter requirements
            if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
            {
                return declined;
            }

            // Reject if the recipient has already received a message
            if (_M_fState == _Initialized)
            {
                return declined;
            }

            // Accept the message
            _ASSERTE(_PSource != NULL);
            _M_pMessage = _PSource->accept(_PMessage->msg_id(), this);

            if (_M_pMessage != NULL)
            {
                // Set the initialized flag on this block
                if (_InterlockedExchange(&_M_fState, _Initialized) == _Blocked)
                {
                    _M_ev.set();
                }

                return accepted;
            }

            return missed;
        }

        // Synchronously sends a message to this block.  When this function completes the message will
        // already have propagated into the block.
        virtual message_status send(message<_Type> * _PMessage, ISource<_Type> * _PSource)
        {
            if (_PMessage == NULL)
            {
                throw std::invalid_argument("_PMessage");
            }

            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            // Only the connected source is allowed to send messages
            // to the blocking recepient. Decline messages without
            // a source.

            return declined;
        }

    private:

        // Link a source block
        virtual void link_source(ISource<_Type> * _PSrc)
        {
            _M_pConnectedTo = _PSrc;
            _PSrc->acquire_ref(this);
        }

        // Remove a source messaging block for this BlockingRecipient
        virtual void unlink_source(ISource<_Type> * _PSource)
        {
            if (_InterlockedCompareExchangePointer(reinterpret_cast<void *volatile *>(&_M_pConnectedTo), (void *)NULL, _PSource) == _PSource)
            {
                _PSource->release_ref(this);
            }
        }

        // Remove the source messaging block for this BlockingRecipient
        virtual void unlink_sources()
        {
            ISource<_Type> * _PSource = reinterpret_cast<ISource<_Type> *>(_InterlockedExchangePointer(reinterpret_cast<void *volatile *>(&_M_pConnectedTo), (void *)NULL));
            if (_PSource != NULL)
            {
                _PSource->unlink_target(this);
                _PSource->release_ref(this);
            }
        }


        // Connect the blocking recipient to the source
        void _Connect(ISource<_Type> * _PSource)
        {
            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            _PSource->link_target(this);
        }

        // Cleanup the connection to the blocking recipient's source. There is no need
        // to do anything about the associated context.
        void _Disconnect()
        {
            unlink_sources();
        }

        // Internal function used to block while waiting for a message to arrive
        // at this BlockingRecipient
        void _Wait_for_message()
        {
            bool _Timeout = false;

            // If we haven't received a message yet, cooperatively block.
            if (_InterlockedCompareExchange(&_M_fState, _Blocked, _NotInitialized) == _NotInitialized)
            {
                if (_M_ev.wait(_M_timeout) == COOPERATIVE_WAIT_TIMEOUT)
                {
                    _Timeout = true;
                }
            }

            // Unlinking from our source guarantees that there are no threads in propagate
            _Disconnect();

            if (_M_fState != _Initialized)
            {
                // We had to have timed out if we came out of the wait
                // without being initialized.
                _ASSERTE(_Timeout);

                throw operation_timed_out();
            }
        }

        // States for this block
        enum
        {
            _NotInitialized,
            _Blocked,
            _Initialized
        };

        volatile long _M_fState;

        // The source messaging block connected to this Recipient
        ISource<_Type> * _M_pConnectedTo;

        // The message that was received
        message<_Type> * volatile _M_pMessage;

        // The timeout.
        unsigned int _M_timeout;

        // The event we wait upon
        event _M_ev;

        // The filter that is called on this block before accepting a message
        filter_method * _M_pFilter;
    };

    if (_Filter_proc != NULL)
    {
        _Blocking_recipient _Recipient(_Src, *_Filter_proc, _Timeout);
        return _Recipient._Value();
    }
    else
    {
        _Blocking_recipient _Recipient(_Src, _Timeout);
        return _Recipient._Value();
    }
}

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/// <remarks>
///     If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
///     of time expires before a message is received.  If you want a zero length timeout, you should use the
///     <see cref="try_receive Function">try_receive</see> function, as opposed to calling <c>receive</c> with a timeout
///     of <c>0</c> (zero), as it is more efficient and does not throw exceptions on timeouts.
///     <para>For more information, see <see cref="Message Passing Functions"/>.</para>
/// </remarks>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
_Type receive(ISource<_Type> * _Src, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE)
{
    return _receive_impl(_Src, _Timeout, NULL);
}

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_Filter_proc">
///     A filter function which determines whether messages should be accepted.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/// <remarks>
///     If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
///     of time expires before a message is received.  If you want a zero length timeout, you should use the
///     <see cref="try_receive Function">try_receive</see> function, as opposed to calling <c>receive</c> with a timeout
///     of <c>0</c> (zero), as it is more efficient and does not throw exceptions on timeouts.
///     <para>For more information, see <see cref="Message Passing Functions"/>.</para>
/// </remarks>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
_Type receive(ISource<_Type> * _Src, typename ITarget<_Type>::filter_method const& _Filter_proc, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE)
{
    return _receive_impl(_Src, _Timeout, &_Filter_proc);
}

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/// <remarks>
///     If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
///     of time expires before a message is received.  If you want a zero length timeout, you should use the
///     <see cref="try_receive Function">try_receive</see> function, as opposed to calling <c>receive</c> with a timeout
///     of <c>0</c> (zero), as it is more efficient and does not throw exceptions on timeouts.
///     <para>For more information, see <see cref="Message Passing Functions"/>.</para>
/// </remarks>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
_Type receive(ISource<_Type> &_Src, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE)
{
    return _receive_impl(&_Src, _Timeout, NULL);
}

/// <summary>
///     A general receive implementation, allowing a context to wait for data from
///     exactly one source and filter the values that are accepted.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_Filter_proc">
///     A filter function which determines whether messages should be accepted.
/// </param>
/// <param name="_Timeout">
///     The maximum time for which the method should for the data, in milliseconds.
/// </param>
/// <returns>
///     A value from the source, of the payload type.
/// </returns>
/// <remarks>
///     If the parameter <paramref name="_Timeout"/> has a value other than the constant <c>COOPERATIVE_TIMEOUT_INFINITE</c>,
///     the exception <see cref="operation_timed_out Class">operation_timed_out</see> is thrown if the specified amount
///     of time expires before a message is received.  If you want a zero length timeout, you should use the
///     <see cref="try_receive Function">try_receive</see> function, as opposed to calling <c>receive</c> with a timeout
///     of <c>0</c> (zero), as it is more efficient and does not throw exceptions on timeouts.
///     <para>For more information, see <see cref="Message Passing Functions"/>.</para>
/// </remarks>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
_Type receive(ISource<_Type> &_Src, typename ITarget<_Type>::filter_method const& _Filter_proc, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE)
{
    return _receive_impl(&_Src, _Timeout, &_Filter_proc);
}

/// <summary>
///     Helper function that implements try_receive
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, try_receive will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/// <param name="_Src">
///     A pointer to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <param name="_Filter_proc">
///     A pointer to a filter which will indicate whether to accept the data or not.
/// </param>
/// <returns>
///     A bool indicating whether a payload was placed in <paramref name="_value"/> or not.
/// </returns>
/**/
template <class _Type>
bool _try_receive_impl(ISource<_Type> * _Src, _Type & _value, typename ITarget<_Type>::filter_method const * _Filter_proc)
{
    // The Immediate Recipient messaging block class is internal to the receive function
    class _Immediate_recipient : public ITarget<_Type>
    {
    public:
        // Create an Immediate Recipient
        _Immediate_recipient(ISource<_Type> * _PSource) :
            _M_pFilter(NULL), _M_pConnectedTo(NULL), _M_pMessage(NULL), _M_fIsInitialized(0)
        {
            _Connect(_PSource);
        }

        // Create an Immediate Recipient
        _Immediate_recipient(ISource<_Type> * _PSource,
            filter_method const& _Filter) :
            _M_pFilter(NULL), _M_pConnectedTo(NULL), _M_pMessage(NULL), _M_fIsInitialized(0)
        {
            if (_Filter != NULL)
            {
                _M_pFilter = new filter_method(_Filter);
            }

            _Connect(_PSource);
        }

        // Cleans up any resources that may have been created by the ImmediateRecipient.
        ~_Immediate_recipient()
        {
            _Disconnect();

            delete _M_pFilter;
            delete _M_pMessage;
        }

        // Gets the value of the message sent to this ImmediateRecipient.
        bool _Value(_Type & _value)
        {
            // Unlinking from our source guarantees that there are no threads in propagate
            _Disconnect();

            if (_M_pMessage != NULL)
            {
                _value = _M_pMessage->payload;
                return true;
            }

            return false;
        }

        // The main propagation function for ITarget blocks.  Called by a source
        // block, generally within an asynchronous task to send messages to its targets.
        virtual message_status propagate(message<_Type> * _PMessage, ISource<_Type> * _PSource)
        {
            message_status _Result = accepted;

            // Throw exception if the message being propagated to this block is NULL
            if (_PMessage == NULL)
            {
                throw std::invalid_argument("_PMessage");
            }

            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            // Reject if the message does not meet the filter requirements
            if (_M_pFilter != NULL && !(*_M_pFilter)(_PMessage->payload))
            {
                return declined;
            }

            // Reject if the recipient has already received a message
            if (_M_fIsInitialized == 1)
            {
                return declined;
            }

            // Accept the message
            _ASSERTE(_PSource != NULL);
            _M_pMessage = _PSource->accept(_PMessage->msg_id(), this);

            // Set the initialized flag on this block

            if (_M_pMessage != NULL)
            {
                // Fence to ensure that the above update to _M_pMessage is visible
                _InterlockedExchange(&_M_fIsInitialized, 1);
                _Result = accepted;
            }
            else
            {
                _Result = missed;
            }

            return _Result;
        }


        // Synchronously sends a message to this block.  When this function completes the message will
        // already have propagated into the block.
        virtual message_status send(message<_Type> * _PMessage, ISource<_Type> * _PSource)
        {
            if (_PMessage == NULL)
            {
                throw std::invalid_argument("_PMessage");
            }

            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            // Only the connected source is allowed to send messages
            // to the blocking recepient. Decline messages without
            // a source.

            return declined;
        }

    private:

        // Add a source messaging block
        virtual void link_source(ISource<_Type> * _PSrc)
        {
            _M_pConnectedTo = _PSrc;
            _PSrc->acquire_ref(this);
        }

        // Remove a source messaging block for this BlockingRecipient
        virtual void unlink_source(ISource<_Type> * _PSource)
        {
            if (_InterlockedCompareExchangePointer(reinterpret_cast<void *volatile *>(&_M_pConnectedTo), (void *)NULL, _PSource) == _PSource)
            {
                _PSource->release_ref(this);
            }
        }

        // Remove the source messaging block for this BlockingRecipient
        virtual void unlink_sources()
        {
            ISource<_Type> * _PSource = reinterpret_cast<ISource<_Type> *>(_InterlockedExchangePointer(reinterpret_cast<void *volatile *>(&_M_pConnectedTo), (void *)NULL));
            if (_PSource != NULL)
            {
                _PSource->unlink_target(this);
                _PSource->release_ref(this);
            }
        }

        // Connect to a source block
        void _Connect(ISource<_Type> * _PSource)
        {
            if (_PSource == NULL)
            {
                throw std::invalid_argument("_PSource");
            }

            _ASSERTE(_M_fIsInitialized == 0);

            _PSource->link_target(this);
        }

        //
        // Cleanup the connection to the trigger's source. There is no need
        // to do anything about the associated context.
        //
        void _Disconnect()
        {
            unlink_sources();
        }

        // The source messaging block connected to this Recipient
        ISource<_Type> * _M_pConnectedTo;

        // The message that was received
        message<_Type> * volatile _M_pMessage;

        // A flag for whether or not this block has been initialized with a value
        volatile long _M_fIsInitialized;

        // The filter that is called on this block before accepting a message
        filter_method * _M_pFilter;
    };

    if (_Filter_proc != NULL)
    {
        _Immediate_recipient _Recipient(_Src, *_Filter_proc);
        return _Recipient._Value(_value);
    }
    else
    {
        _Immediate_recipient _Recipient(_Src);
        return _Recipient._Value(_value);
    }
}

/// <summary>
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, the method will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <returns>
///     A <c>bool</c> value indicating whether or not a payload was placed in <paramref name="_value"/>.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool try_receive(ISource<_Type> * _Src, _Type & _value)
{
    return _try_receive_impl(_Src, _value, NULL);
}

/// <summary>
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, the method will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <param name="_Filter_proc">
///     A filter function which determines whether messages should be accepted.
/// </param>
/// <returns>
///     A <c>bool</c> value indicating whether or not a payload was placed in <paramref name="_value"/>.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool try_receive(ISource<_Type> * _Src, _Type & _value, typename ITarget<_Type>::filter_method const& _Filter_proc)
{
    return _try_receive_impl(_Src, _value, &_Filter_proc);
}

/// <summary>
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, the method will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <returns>
///     A <c>bool</c> value indicating whether or not a payload was placed in <paramref name="_value"/>.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool try_receive(ISource<_Type> & _Src, _Type & _value)
{
    return _try_receive_impl(&_Src, _value, NULL);
}

/// <summary>
///     A general try-receive implementation, allowing a context to look for data from
///     exactly one source and filter the values that are accepted. If the data is not
///     ready, the method will return false.
/// </summary>
/// <typeparam name="_Type">
///     The payload type
/// </typeparam>
/// <param name="_Src">
///     A pointer or reference to the source from which data is expected.
/// </param>
/// <param name="_value">
///     A reference to a location where the result will be placed.
/// </param>
/// <param name="_Filter_proc">
///     A filter function which determines whether messages should be accepted.
/// </param>
/// <returns>
///     A <c>bool</c> value indicating whether or not a payload was placed in <paramref name="_value"/>.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="send Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool try_receive(ISource<_Type> & _Src, _Type & _value, typename ITarget<_Type>::filter_method const& _Filter_proc)
{
    return _try_receive_impl(&_Src, _value, &_Filter_proc);
}

/// <summary>
///     A synchronous send operation, which waits until the target either accepts or declines the message.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Trg">
///     A pointer or reference to the target to which data is sent.
/// </param>
/// <param name="_Data">
///     A reference to the data to be sent.
/// </param>
/// <returns>
///     <c>true</c> if the message was accepted, <c>false</c> otherwise.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool send(ITarget<_Type> * _Trg, const _Type& _Data)
{
    // The Originator messaging block class is internal to the send function.
    class _Originator : public ISource<_Type>
    {
    public:

        typedef single_link_registry<ITarget<_Type>> _Target_registry;

        // Create an Originator
        _Originator() :
          _M_pMessage(NULL),
          _M_fStatus(postponed),
          _M_referenceCount(0)
        {
        }

        // Cleans up any resources that may have been created by the Originator.
        virtual ~_Originator()
        {
            unlink_targets();

            _Wait_on_ref();

            delete _M_pMessage;
        }

        // Removes a target messaging block for this Originator
        virtual void unlink_target(ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }
            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);
                if (_M_connectedTargets.remove(_PTarget))
                {
                    _Invoke_unlink_source(_PTarget);

                    // Indicate that the send is complete
                    _Done(declined);
                }
            }
        }

        // Removes the target messaging block from this Originator
        virtual void unlink_targets()
        {
            // Hold the lock to ensure that the target doesn't unlink while
            // propagation is in progress.
            _R_lock _Lock(_M_internalLock);

            for (_Target_registry::iterator _Iter = _M_connectedTargets.begin(); *_Iter != NULL; ++_Iter)
            {
                ITarget<_Type> * _PTarget = *_Iter;
                if (_M_connectedTargets.remove(_PTarget))
                {
                    _Invoke_unlink_source(_PTarget);
                }
            }

            // All targets should be unlinked
            _ASSERTE(_M_connectedTargets.count() == 0);

            // Indicate that the send is complete
            _Done(declined);
        }

        // Accept on this Originator is called by a target to take ownership of a
        // propagated message
        virtual message<_Type> * accept(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                return NULL;
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                return NULL;
            }

            if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
            {
                return NULL;
            }

            // The Id's match, actaully transfer ownership of the message and
            // unlink away from the target
            message<_Type> * _Result = _M_pMessage;

            // The ownership of this message has changed.  Set the internal pointer to NULL
            // so it won't be deleted in the destructor
            _M_pMessage = NULL;

            // The message has been accepted/consumed, propagate indication that it has succeeded
            _Done(accepted);

            return _Result;
        }

        // Reserve needs to be defined for ISource blocks, but Originator doesn't need to
        // do anything for reservation since there can only be one target block to read
        // the data at a later time.
        virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                return false;
            }

            if (_M_pMessage->msg_id() != _MsgId)
            {
                return false;
            }

            return true;
        }

        // Consume is called by a target messaging block to take ownership of a
        // previously reserved message.
        virtual message<_Type> * consume(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                throw bad_target();
            }

            return accept(_MsgId, _PTarget);
        }

        // Release needs to be defined for ISource blocks, but Originator doesn't need to
        // do anything for reservation release since there can only be one target block to read
        // the data at a later time.
        virtual void release(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                throw bad_target();
            }

            if ((_M_pMessage == NULL) || (_M_pMessage->msg_id() != _MsgId))
            {
                throw message_not_found();
            }

            // If the previously reserved message is released, then propagate
            // declined  to indicate that the message was not accepted.
            _Done(declined);
        }

        virtual void acquire_ref(ITarget<_Type> *)
        {
            _InterlockedIncrement(&_M_referenceCount);
        }

        virtual void release_ref(ITarget<_Type> *)
        {
            _InterlockedDecrement(&_M_referenceCount);
        }

        // Send the given value to the target
        bool _send(ITarget<_Type> * _PTarget, _Type const & _Value)
        {
            // _send should only be called once.
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            message_status _Status = declined;
            message<_Type> * _Msg = new message<_Type>(_Value);

            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);

                // link to the target, create a message and send it
                link_target(_PTarget);

                _ASSERTE(_M_pMessage == NULL);
                _M_pMessage = _Msg;

                // Send the message synchronously to the target
                _Status = _PTarget->send(_M_pMessage, this);
            }

            if (_Status == postponed)
            {
                // If the target postponed the message, wait for it to
                // be accepted/declined.
                _Wait_for_completion();

                // Procure the final status
                _Status = _M_fStatus;
            }

            // status should not be postponed.
            _ASSERTE(_Status != postponed);


            return (_Status == accepted);
        }

    private:

        // Add a target messaging block for this Originator
        virtual void link_target(ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            _M_connectedTargets.add(_PTarget);
            _Invoke_link_source(_PTarget);

            // There should be no pending messages to propagate at this time.
            _ASSERTE(_M_pMessage == NULL);
        }

        // Wait for the status to reach one of the terminal
        // states (!= postponed)
        void _Wait_for_completion()
        {
            // Wait for the event to be signalled
            _M_ev.wait(COOPERATIVE_TIMEOUT_INFINITE);
            _ASSERTE(_M_fStatus != postponed);

        }

        void _Wait_on_ref()
        {
            ::Concurrency::details::_SpinWaitBackoffNone spinWait;
            while(_M_referenceCount != 0)
            {
                spinWait._SpinOnce();
            }
        }

        // Indicate that the send operation has completed
        void _Done(message_status _Status)
        {
            // postponed is not a done state
            _ASSERTE(_Status != postponed);

            _M_fStatus = _Status;
            _M_ev.set();
        }

        // The message that will be propagated by the Originator
        message<_Type> * _M_pMessage;

        // Event to indicate completion
        event _M_ev;

        // Final status of the send
        volatile message_status _M_fStatus;

        // A lock for modifying the buffer or the connected blocks
        ::Concurrency::details::_ReentrantPPLLock _M_internalLock;

        // Connected targets
        _Target_registry _M_connectedTargets;

        volatile long _M_referenceCount;
    };

    // Create a blocking originator on the stack. _send will block until the
    // message is accepted/rejected.
    _Originator _Orig;
    return _Orig._send(_Trg, _Data);
}


/// <summary>
///     A synchronous send operation, which waits until the target either accepts or declines the message.
/// </summary>
/// <typeparam name="_Type">
///     The payload type.
/// </typeparam>
/// <param name="_Trg">
///     A pointer or reference to the target to which data is sent.
/// </param>
/// <param name="_Data">
///     A reference to the data to be sent.
/// </param>
/// <returns>
///     <c>true</c> if the message was accepted, <c>false</c> otherwise.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="asend Function"/>
/**/
template <class _Type>
bool send(ITarget<_Type> &_Trg, const _Type &_Data)
{
    return send(&_Trg, _Data);
}

/// <summary>
///     An asynchronous send operation, which schedules a task to propagate the data to the target block.
/// </summary>
/// <typeparam name="_Type">
///     The type of the data to be sent.
/// </typeparam>
/// <param name="_Trg">
///     A pointer or reference to the target to which data is sent.
/// </param>
/// <param name="_Data">
///     A reference to the data to be sent.
/// </param>
/// <returns>
///     <c>true</c> if the message was accepted before the method returned, <c>false</c> otherwise.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/**/
template <class _Type>
bool asend(ITarget<_Type> * _Trg, const _Type& _Data)
{
    // The Originator messaging block class is internal to the send function.
    class _AsyncOriginator : public ISource<_Type>
    {
    public:

        typedef single_link_registry<ITarget<_Type>> _Target_registry;

        // The constructor is private to disallow allocation on the stack.
        static _AsyncOriginator * _create()
        {
            return new _AsyncOriginator;
        }

        // Cleans up any resources that may have been created by the AsyncOriginator.
        virtual ~_AsyncOriginator()
        {
            unlink_targets();

            delete _M_pMessage;
        }

        // Send the given value to the target
        message_status _send(ITarget<_Type> * _PTarget, _Type const & _Value)
        {
            // Keep a refcount so that this object doesn't get deleted if
            // the target decides to unlink before we release our lock
            _Acquire_ref();

            message_status _Status = declined;
            message<_Type> * _Msg = new message<_Type>(_Value);

            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);

                // link to the target, create a message and send it
                link_target(_PTarget);

                _ASSERTE(_M_pMessage == NULL);
                _M_pMessage = _Msg;

                _Status = _PTarget->propagate(_M_pMessage, this);
            }

            // If the status is anything other than postponed, unlink away
            // from the target and delete the AsyncOriginator.
            if (_Status != postponed)
            {
                unlink_target(_PTarget);
            }

            // Release the reference acquired above
            _Release_ref();

            return _Status;
        }

        // Removes a target messaging block for this AsyncOriginator
        virtual void unlink_target(ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            bool _Unlinked = false;
            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);

                if (_M_connectedTargets.remove(_PTarget))
                {
                    _Invoke_unlink_source(_PTarget);
                    _Unlinked = true;
                }
            }

            // Release the lock before decrementing the refcount. Otherwise, the
            // lock release could corrupt memory.
            if (_Unlinked)
            {
                _Release_ref();
            }
        }

        // Removes the target messaging block from this AsyncOriginator
        virtual void unlink_targets()
        {
            bool _Unlinked = false;
            {
                // Hold the lock to ensure that the target doesn't unlink while
                // propagation is in progress.
                _R_lock _Lock(_M_internalLock);

                for (_Target_registry::iterator _Iter = _M_connectedTargets.begin();
                    *_Iter != NULL;
                    ++_Iter)
                {
                    ITarget<_Type> * _PTarget = *_Iter;
                    if (_M_connectedTargets.remove(_PTarget))
                    {
                        _Invoke_unlink_source(_PTarget);
                        _Unlinked = true;
                    }

                }

                // All targets should be unlinked
                _ASSERTE(_M_connectedTargets.count() == 0);
            }

            // Release the lock before decrementing the refcount. Otherwise, the
            // lock release could corrupt memory.
            if (_Unlinked)
            {
                _Release_ref();
            }
        }

        // Accept on this AsyncOriginator is called by a target to take ownership of a
        // propagated message. This can only be called from propagate.
        virtual message<_Type> * accept(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                return NULL;
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                return NULL;
            }

            if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
            {
                return NULL;
            }

            //
            // If the Id's match, actaully transfer ownership of the message.
            //
            message<_Type> * _Result = _M_pMessage;
            _M_pMessage = NULL;

            return _Result;
        }

        // Reserve needs to be defined for ISource blocks, but AsyncOriginator doesn't need to
        // do anything for reservation since there can only be one target block to read
        // the data at a later time.
        virtual bool reserve(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                return false;
            }

            if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
            {
                return false;
            }

            return true;
        }

        // Consume is called by a target messaging block to take ownership of a
        // previously reserved message.
        virtual message<_Type> * consume(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                throw bad_target();
            }

            if (_M_pMessage == NULL || _M_pMessage->msg_id() != _MsgId)
            {
                return NULL;
            }

            // The ownership of this message has changed.  Set the internal pointer to NULL
            // so it won't be deleted in the destructor

            message<_Type> * _Result = _M_pMessage;
            _M_pMessage = NULL;

            // We are done. Unlink from the target. DO NOT TOUCH "this" pointer after unlink
            unlink_target(_PTarget);

            return _Result;
        }

        // Release needs to be defined for ISource blocks, but AsyncOriginator doesn't need to
        // do anything for reservation release since there can only be one target block to read
        // the data at a later time.
        virtual void release(runtime_object_identity _MsgId, ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            if (!_M_connectedTargets.contains(_PTarget))
            {
                throw bad_target();
            }

            if ((_M_pMessage == NULL) || (_M_pMessage->msg_id() != _MsgId))
            {
                throw message_not_found();
            }

            // We can be connected to only 1 target. Unlink from the target.
            // DO NOT TOUCH "this" pointer after unlink
            unlink_target(_PTarget);
        }

        virtual void acquire_ref(ITarget<_Type> *)
        {
            _Acquire_ref();
        }

        virtual void release_ref(ITarget<_Type> *)
        {
            _Release_ref();
        }

    private:

        // Create an AsyncOriginator (constructor is private to ensure that
        // it is allocated on the heap).
        _AsyncOriginator() :
          _M_pMessage(NULL),
          _M_refcount(0)
        {
        }

        // Add a target messaging block for this AsyncOriginator
        virtual void link_target(ITarget<_Type> * _PTarget)
        {
            if (_PTarget == NULL)
            {
                throw std::invalid_argument("_PTarget");
            }

            // Acquire a reference that will be released by unlink_target
            _Acquire_ref();
            _M_connectedTargets.add(_PTarget);
            _Invoke_link_source(_PTarget);

            // There should be no pending messages to propagate at this time.
            _ASSERTE(_M_pMessage == NULL);

        }

        // Acquire a reference on the async originator object
        void _Acquire_ref()
        {
            _InterlockedIncrement(&_M_refcount);
        }

        // Release the reference on the async originator object. The object
        // will be deleted when the reference count goes to 0.
        void _Release_ref()
        {
            _ASSERTE(_M_refcount > 0);
            if (_InterlockedDecrement(&_M_refcount) == 0)
            {
                delete this;
            }
        }

        // The message that will be propagated by the AsyncOriginator
        message<_Type> * _M_pMessage;

        // Reference count to manage object lifetime
        volatile long _M_refcount;

        // The internal lock for this block for its message
        ::Concurrency::details::_ReentrantPPLLock _M_internalLock;

        // connected targets
        _Target_registry _M_connectedTargets;
    };

    _AsyncOriginator * _AsyncOrig = _AsyncOriginator::_create();

    message_status _Status = _AsyncOrig->_send(_Trg, _Data);
    if (_Status != accepted)
    {
        return false;
    }

    return true;
}


/// <summary>
///     An asynchronous send operation, which schedules a task to propagate the value to the target block.
/// </summary>
/// <typeparam name="_Type">
///     The type of the data to be sent.
/// </typeparam>
/// <param name="_Trg">
///     A pointer or reference to the target to which data is sent.
/// </param>
/// <param name="_Data">
///     A reference to the data to be sent.
/// </param>
/// <returns>
///     <c>true</c> if the message was accepted, <c>false</c> otherwise.
/// </returns>
/// <remarks>
///     For more information, see <see cref="Message Passing Functions"/>.
/// </remarks>
/// <seealso cref="receive Function"/>
/// <seealso cref="try_receive Function"/>
/// <seealso cref="send Function"/>
/**/
template <class _Type>
bool asend(ITarget<_Type> &_Trg, const _Type &_Data)
{
    return asend(&_Trg, _Data);
}
} // namespace Concurrency

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\Agent.cpp ===
// ==++==
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// Agent.cpp
//
// Source file containing code for the agent creation APIs.  
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#include "concrtinternal.h"
#include <agents.h>

namespace Concurrency
{

// A Filter function for a filter_block to check if the Agent has completed
bool _IsDone(agent_status const &status) 
{ 
    return status == agent_done || status == agent_canceled;
}

// A Filter function for a filter_block to check if the Agent has started (or completed)
bool _IsStarted(agent_status const &status) 
{ 
    return _IsDone(status) || status == agent_started;
}

/// <summary>
///     Creates an agent within the default scheduler, and places it any schedule 
///     group of the schedulers choosing. 
/// </summary>
agent::agent() : 
    _M_fStartable(TRUE), _M_fCancelable(TRUE), _M_pScheduler(NULL), _M_pScheduleGroup(NULL)
{
    send<agent_status> (_M_status, agent_created);
}

/// <summary>
///     Create an agent within the specified scheduler, in a schedule group of the 
///     schedulers choosing.
/// </summary>
agent::agent(Scheduler& pScheduler) : 
    _M_fStartable(TRUE), _M_fCancelable(TRUE), _M_pScheduler(&pScheduler), _M_pScheduleGroup(NULL)
{
    send<agent_status> (_M_status, agent_created);
}

/// <summary>
///     Create an agent within the specified schedule group.  The scheduler is implied 
///     by the schedule group.
/// </summary>
agent::agent(ScheduleGroup& pGroup) : 
    _M_fStartable(TRUE), _M_fCancelable(TRUE), _M_pScheduler(NULL), _M_pScheduleGroup(&pGroup)
{
    send<agent_status> (_M_status, agent_created);
}

/// <summary>
///     Cleans up any resources that may have been created by the Agent.   
/// </summary>
agent::~agent()
{
}

/// <returns>
///     Returns a message source that can pass messages about the current state of the agent
/// </returns>
ISource<agent_status> * agent::status_port()
{
    return &_M_status;
}
    
/// <returns>
///     Returns the current state of the agent.  Note that this returned state could change 
///     immediately after being returned.
/// </returns>
agent_status agent::status()
{
    return receive<agent_status>(_M_status);
}

/// <summary>
///     Moves an Agent from the agent_created state to the agent_runnable state, and schedules it for execution.
/// </summary>
/// <returns>
///     true if the agent started correctly, false otherwise
/// </returns>
bool agent::start()
{
    if(_M_status.value() != agent_created)
    {
        return false;
    }

    //
    // Check if the agent is Startable.  If the agent had already called start() or
    // this variable was set to FALSE in cancel(), return false.
    //
    if(InterlockedCompareExchange(&_M_fStartable, FALSE, TRUE) == FALSE)
    {
        return false;
    }

    send<agent_status> (_M_status, agent_runnable);

    TaskProc proc = &Concurrency::agent::_Agent_task_wrapper;
    if(_M_pScheduleGroup != NULL)
    {                    
        _M_pScheduleGroup->ScheduleTask(proc, this);
    }
    else if(_M_pScheduler != NULL)
    {
        _M_pScheduler->ScheduleTask(proc, this);
    }
    else
    {
        CurrentScheduler::ScheduleTask(proc, this);
    }

    return true;
}

/// <summary>
///     Moves an agent into the done state, indicating the completion of the agent
/// </summary>
/// <returns>
///     true if the agent is moved to the agent_done state, false otherwise
/// </returns>
bool agent::done()
{     
    //
    // current status
    //
    agent_status currentStatus = this->status();

    //
    // Indicate that the agent can no longer be started.
    //
    if (InterlockedCompareExchange(&_M_fStartable, FALSE, TRUE) != TRUE)
    {
        //
        // agent is either canceled, started or completed run.
        //
        currentStatus = receive<agent_status>(_M_status, _IsStarted);
    }

    //
    // Agent is not cancelable anymore.
    //
    InterlockedExchange(&_M_fCancelable, FALSE);

    // 
    // Transition to agent_done state if it not already in one of
    // the terminal states. 
    //
    if ((currentStatus != agent_canceled) && (currentStatus != agent_done))
    {
        send<agent_status> (_M_status, agent_done);

        return true;
    }

    return false;
}

/// <summary>
///     Moves an agent from the agent_created or agent_runnable to the agent_canceled state.
/// </summary>
/// <returns>
///     true if the agent was canceled correctly, false otherwise
/// </returns>
bool agent::cancel()
{
    //
    // In case this agent has been canceled before it was even started
    // mark it as no longer Startable and send a agent_canceled message to the
    // status port
    //
    if(InterlockedCompareExchange(&_M_fStartable, FALSE, TRUE) == TRUE)
    {
        send<agent_status> (_M_status, agent_canceled);
    }

    //
    // Check to see if the agent is still Cancelable.  Agents are initialized
    // m_fCancelable == TRUE, and set to false either here in cancel(), so
    // cancel() will not be called twice, or in the LWT, once the execution
    // of the Agent task has begun.
    //
    if(InterlockedCompareExchange(&_M_fCancelable, FALSE, TRUE) == TRUE)
    {
        // Wait for the agent to reach a canceled state state
        receive<agent_status>(_M_status, _IsDone);

        // The above InterlockedCompareExchange marked this agent for cancelation
        // When the LWT that has been spun up tries to execute the task, it will
        // find it has been canceled and will propagate out the canceled state to
        // the state buffer.
        return true;
    }

    return false;
}


// Private helper class to order an input array of agents. This is used by
// wait_for_all and wait_for_one to create an array of appropriate order nodes.
// The template _OrderNode specifies an _Order_node_base that accepts agent_status.
// For example, _Reserving_node<agent_status>
template<class _OrderNode>
class _OrderBlock
{
public:

    // Constructs an orderBlock which has an array of ordernodes connected to the agents.
    // The ordernodes are given a filter method to filter out non-terminal agent states
    _OrderBlock(size_t _Count, agent ** _PAgents, ITarget<size_t> * _PTarget) : _M_count(_Count)
    {
        // Create an array of order nodes 
        _M_ppNodes = new _OrderNode*[_M_count];
        for (size_t i = 0; i < _M_count; i++)
        {
            _M_ppNodes[i] = new _OrderNode(_PAgents[i]->status_port(), i, _PTarget, _IsDone);
        }
    }

    // Destroys the block
    ~_OrderBlock()
    {
        for (size_t i = 0; i < _M_count; i++)
        {
            delete _M_ppNodes[i];
        }

        delete [] _M_ppNodes;
    }

    // Retrieve the agent status for the agent at the given index
    agent_status _Status(size_t _Index)
    {
        _ASSERTE(_M_ppNodes[_Index]->has_value());

        return _M_ppNodes[_Index]->value();
    }

private:

    // Number of order nodes
    size_t _M_count;

    // Array of order nodes
    _OrderNode ** _M_ppNodes;
};


/// <summary>
///     Wait for an agent to complete its task. A task is completed when it enters the agent_canceled, 
///     or agent_done states. 
/// </summary>
agent_status agent::wait(agent * pAgent, unsigned int timeout)
{
    if(pAgent == NULL)
    {
        throw std::invalid_argument("pAgent");
    }

    return receive<agent_status>(pAgent->status_port(), _IsDone, timeout);
}

/// <summary>
/// Wait for all agents in a given Agent array to complete their tasks. A task is completed 
/// when it enters the agent_canceled or agent_done states. 
/// </summary>
void agent::wait_for_all(size_t count, agent ** pAgents, agent_status * pStatus, unsigned int timeout)
{
    if ( pAgents == NULL )
    {
        throw std::invalid_argument("pAgents");
    }

    for (size_t i = 0; i < count; i++)
    {
        if ( pAgents[i] == NULL )
        {
            throw std::invalid_argument("pAgents");
        }
    }

    // Create the following network
    //
    //  agent - orderNode -
    //                     \
    //  agent - orderNode - --call ~~~ single_assignment
    //                     /
    //  agent - orderNode -

    single_assignment<size_t> _Sa;
    volatile size_t _CompletedAgents = 0;
    call<size_t> _Call([&](size_t const& _Index) 
    {
        // Safe to access without synchronization since call blocks
        // guarantee that the function is not called for multiple 
        // messages at the same time.
        _ASSERTE(_CompletedAgents < count);
        if (++_CompletedAgents == count)
        {
            // All the agents have completed. Indicate the same by sending a message
            // (initialize) to the single assignment.
            send<size_t>(_Sa, 1);
        }
    });

    _OrderBlock<_Greedy_node<agent_status>>  _OrderedAgents(count, pAgents, &_Call);

    receive(&_Sa, timeout);

    // single_assignment has a message => all agents completed
    // Retrieve their status messages.
    if(pStatus != NULL)
    {
        for (size_t i = 0; i < count; i++)
        {
            pStatus[i] = _OrderedAgents._Status(i);
        }
    }
}

/// <summary>
///     Wait for any one of the agents in a given AgentTask array to complete its task. A task is completed 
///     when it enters the agent_canceled or agent_done states. 
/// </summary>
void agent::wait_for_one(size_t count, agent ** pAgents, agent_status &status, size_t& index, unsigned int timeout)
{
    if ( pAgents == NULL )
    {
        throw std::invalid_argument("pAgents");
    }

    for (size_t i = 0; i < count; i++)
    {
        if ( pAgents[i] == NULL )
        {
            throw std::invalid_argument("pAgents");
        }
    }

    // Create the following network
    //
    //  agent - orderNode -
    //                     \
    //  agent - orderNode - --single_assignment
    //                     /
    //  agent - orderNode -

    single_assignment<size_t> _Sa;
    _OrderBlock<_Greedy_node<agent_status>>  _OrderedAgents(count, pAgents, &_Sa);

    index = receive(&_Sa, timeout);

    // We were able to receive the index. Get the message (agent_status)
    status = _OrderedAgents._Status(index);
}

// A static wrapper function that calls the Run() method.  Used for scheduling of the task
void agent::_Agent_task_wrapper(void* data)
{
    agent *pAgent = (agent *) data;

    if(InterlockedCompareExchange(&pAgent->_M_fCancelable, FALSE, TRUE) == TRUE)
    {
        send<agent_status> (pAgent->_M_status, agent_started);

        // Invoke the run() function of the agent.
        pAgent->run();
    }
    else
    {
        // This else path can be entered only if an agent was canceled before it
        // ran.  Send a agent_canceled message to the status.
        send<agent_status> (pAgent->_M_status, agent_canceled);
    }
}

// Implementation of agent APIs that should not be publicly exposed

namespace details
{
    static volatile runtime_object_identity s_RuntimeObjectIdentity = 0;

    _CRTIMP2 _Runtime_object::_Runtime_object()
    {
        // Increment the id by 2.  This is done because certain blocks (like join) need to have
        // a special message id to indicate a NULL id.  In this case, we use -1.  Incrementing by 2
        // will avoid any wrap-around issues causing us to hit -1.
        runtime_object_identity id = InterlockedExchangeAdd((volatile long *) &s_RuntimeObjectIdentity, 2);
        _ASSERTE(id != -1);
        _M_id = id;
    }

    _CRTIMP2 _Runtime_object::_Runtime_object(runtime_object_identity _Id) : _M_id(_Id)
    {
    }
} // namespace details
} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\align.c ===
/***
*align.c - Aligned allocation, reallocation or freeing of memory in the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _aligned_malloc(),
*                   _aligned_realloc(),
*                   _aligned_recalloc(),
*                   _aligned_offset_malloc(),
*                   _aligned_offset_realloc(),
*                   _aligned_offset_recalloc(),
*                   _aligned_free(),
*                   _aligned_msize() functions.
*
*******************************************************************************/

#include <dbgint.h>
#include <crtdbg.h>
#include <errno.h>
#include <string.h>
#include <malloc.h>
#include <stddef.h>
#include <stdlib.h>
#include <internal.h>

#define IS_2_POW_N(X)   (((X)&(X-1)) == 0)
#define PTR_SZ          sizeof(void *)
/***
*
* |1|___6___|2|3|4|_________5__________|_6_|
*
* 1 -> Pointer to start of the block allocated by malloc.
* 2 -> Value of 1.
* 3 -> Gap used to get 1 aligned on sizeof(void *).
* 4 -> Pointer to the start of data block.
* 4+5 -> Data block.
* 6 -> Wasted memory at rear of data block.
* 6 -> Wasted memory.
*
*******************************************************************************/

/***
* void *_aligned_malloc_base(size_t size, size_t alignment)
*       - Get a block of aligned memory from the heap.
*
* Purpose:
*       Allocate of block of aligned memory aligned on the alignment of at least
*       size bytes from the heap and return a pointer to it.
*
* Entry:
*       size_t size - size of block requested
*       size_t alignment - alignment of memory (needs to be a power of 2)
*
* Exit:
*       Success: Pointer to memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_malloc_base(
    size_t size,
    size_t alignment
    )
{
    return _aligned_offset_malloc_base(size, alignment, 0);
}
/***
* void *_aligned_offset_malloc_base(size_t size, size_t alignment, int offset)
*       - Get a block of memory from the heap.
*
* Purpose:
*       Allocate a block of memory which is shifted by offset from alignment of
*       at least size bytes from the heap and return a pointer to it.
*
* Entry:
*       size_t size - size of block of memory
*       size_t alignment - alignment of memory (needs to be a power of 2)
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Success: Pointer to memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/


void * __cdecl _aligned_offset_malloc_base(
    size_t size,
    size_t align,
    size_t offset
    )
{
    uintptr_t ptr, retptr, gap;
    size_t nonuser_size,block_size;

    /* validation section */
    _VALIDATE_RETURN(IS_2_POW_N(align), EINVAL, NULL);
    _VALIDATE_RETURN(offset == 0 || offset < size, EINVAL, NULL);

    align = (align > PTR_SZ ? align : PTR_SZ) -1;

    /* gap = number of bytes needed to round up offset to align with PTR_SZ*/
    gap = (0 - offset)&(PTR_SZ -1);

    nonuser_size = PTR_SZ +gap +align;
    block_size = nonuser_size + size;
    _VALIDATE_RETURN_NOEXC(size <= block_size, ENOMEM, NULL)

    if ( (ptr =(uintptr_t)malloc(block_size)) == (uintptr_t)NULL)
        return NULL;

    retptr =((ptr +nonuser_size+offset)&~align)- offset;
    ((uintptr_t *)(retptr - gap))[-1] = ptr;

    return (void *)retptr;
}

/***
*
* void *_aligned_realloc_base(void * memblock, size_t size, size_t alignment)
*       - Reallocate a block of aligned memory from the heap.
*
* Purpose:
*       Reallocates of block of aligned memory aligned on the alignment of at
*       least size bytes from the heap and return a pointer to it. Size can be
*       either greater or less than the original size of the block.
*       The reallocation may result in moving the block as well as changing the
*       size.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t size - size of block requested
*       size_t alignment - alignment of memory
*
* Exit:
*       Success: Pointer to re-allocated memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_realloc_base(
    void *memblock,
    size_t size,
    size_t alignment
    )
{
    return _aligned_offset_realloc_base(memblock, size, alignment, 0);
}

/***
*
* void *_aligned_recalloc_base(void * memblock, size_t count, size_t size, size_t alignment)
*       - Reallocate a block of aligned memory from the heap.
*
* Purpose:
*       Reallocates of block of aligned memory aligned on the alignment of at
*       least size bytes from the heap and return a pointer to it. Size can be
*       either greater or less than the original size of the block.
*       The reallocation may result in moving the block as well as changing the
*       size.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t count - count of items
*       size_t size - size of item
*       size_t alignment - alignment of memory
*
* Exit:
*       Success: Pointer to re-allocated memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_recalloc_base(
    void *memblock,
    size_t count,
    size_t size,
    size_t alignment
    )
{
    return _aligned_offset_recalloc_base(memblock, count, size, alignment, 0);
}

/***
*
* void *_aligned_offset_realloc_base (void * memblock, size_t size,
*                                     size_t alignment, int offset)
*       - Reallocate a block of memory from the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t size - size of block of memory
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Success: Pointer to re-allocated memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_offset_realloc_base(
    void *memblock,
    size_t size,
    size_t align,
    size_t offset
    )
{
    uintptr_t ptr, retptr, gap, stptr, diff;
    uintptr_t movsz, reqsz;
    int bFree = 0;

    /* special cases */
    if (memblock == NULL)
    {
        return _aligned_offset_malloc_base(size, align, offset);
    }
    if (size == 0)
    {
        _aligned_free_base(memblock);
        return NULL;
    }

    /* validation section */
    _VALIDATE_RETURN(IS_2_POW_N(align), EINVAL, NULL);
    _VALIDATE_RETURN(offset == 0 || offset < size, EINVAL, NULL);

    stptr = (uintptr_t)memblock;

    /* ptr points to the pointer to starting of the memory block */
    stptr = (stptr & ~(PTR_SZ -1)) - PTR_SZ;

    /* ptr is the pointer to the start of memory block*/
    stptr = *((uintptr_t *)stptr);

    align = (align > PTR_SZ ? align : PTR_SZ) -1;
    /* gap = number of bytes needed to round up offset to align with PTR_SZ*/
    gap = (0 -offset)&(PTR_SZ -1);

    diff = (uintptr_t)memblock - stptr;
    /* Mov size is min of the size of data available and sizw requested.
     */
    CRT_WARNING_DISABLE_PUSH(22018, "Silence prefast about overflow/underflow");
    movsz = _msize((void *)stptr) - ((uintptr_t)memblock - stptr);
    CRT_WARNING_POP
    movsz = movsz > size? size: movsz;
    reqsz = PTR_SZ +gap +align +size;

    _VALIDATE_RETURN_NOEXC(size <= reqsz, ENOMEM, NULL);

    /* First check if we can expand(reducing or expanding using expand) data
     * safely, ie no data is lost. eg, reducing alignment and keeping size
     * same might result in loss of data at the tail of data block while
     * expanding.
     *
     * If no, use malloc to allocate the new data and move data.
     *
     * If yes, expand and then check if we need to move the data.
     */
    if ((stptr +align +PTR_SZ +gap)<(uintptr_t)memblock)
    {
        if ((ptr = (uintptr_t)malloc(reqsz)) == (uintptr_t) NULL)
            return NULL;
        bFree = 1;
    }
    else
    {
        /* we need to save errno, which can be modified by _expand */
        errno_t save_errno = errno;
        if ((ptr = (uintptr_t)_expand((void *)stptr, reqsz)) == (uintptr_t)NULL)
        {
            errno = save_errno;
            if ((ptr = (uintptr_t)malloc(reqsz)) == (uintptr_t) NULL)
                return NULL;
            bFree = 1;
        }
        else
            stptr = ptr;
    }


    if ( ptr == ((uintptr_t)memblock - diff)
         && !( ((size_t)memblock + gap +offset) & ~(align) ))
    {
        return memblock;
    }

    retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;
    memmove((void *)retptr, (void *)(stptr + diff), movsz);
    if ( bFree)
        free ((void *)stptr);

    ((uintptr_t *)(retptr - gap))[-1] = ptr;
    return (void *)retptr;
}


/***
*
* size_t _aligned_msize_base(void *memblock, size_t align, size_t offset)
*
* Purpose:
*       Computes the size of an aligned block.
*
* Entry:
*       void * memblock - pointer to the aligned block of memory
*
* Exceptions:
*       None. If memblock == NULL 0 is returned.
*
*******************************************************************************/

size_t __cdecl _aligned_msize_base(void *memblock, size_t align, size_t offset)
{
    size_t header_size = 0; /* Size of the header block */
    size_t footer_size = 0; /* Size of the footer block */
    size_t total_size  = 0; /* total size of the allocated block */
    size_t user_size   = 0; /* size of the user block*/
    uintptr_t gap      = 0; /* keep the alignment of the data block */
                             /* after the sizeof(void*) aligned pointer */
                             /* to the beginning of the allocated block */
    uintptr_t ptr      = 0; /* computes the beginning of the allocated block */

    _VALIDATE_RETURN (memblock != NULL, EINVAL, -1);

    /* HEADER SIZE + FOOTER SIZE = GAP + ALIGN + SIZE OF A POINTER*/
    /* HEADER SIZE + USER SIZE + FOOTER SIZE = TOTAL SIZE */

    ptr = (uintptr_t)memblock;            /* ptr points to the start of the aligned memory block */
    ptr = (ptr & ~(PTR_SZ - 1)) - PTR_SZ; /* ptr is one position behind memblock */
                                          /* the value in ptr is the start of the real allocated block */
    ptr = *((uintptr_t *)ptr);            /* after dereference ptr points to the beginning of the allocated block */

    total_size = _msize((void*)ptr);
    header_size = (uintptr_t) memblock - ptr;
    gap = (0 - offset) & (PTR_SZ - 1);
    /* Alignment cannot be less than sizeof(void*) */
    align = (align > PTR_SZ ? align : PTR_SZ) -1;
    footer_size = gap + align + PTR_SZ - header_size;
    user_size = total_size - header_size - footer_size;

    return user_size;
}

/***
*
* void *_aligned_offset_recalloc_base (void * memblock, size_t size, size_t count, size_t alignment, int offset)
*       - Reallocate a block of memory from the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t count - count of items
*       size_t size - size of items
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Success: Pointer to re-allocated memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_offset_recalloc_base(
    void * memblock,
    size_t count,
    size_t size,
    size_t align,
    size_t offset
    )
{
    size_t user_size  = 0;    /* wanted size, passed to aligned realoc */
    size_t start_fill = 0;    /* location where aligned recalloc starts to fill with 0 */
                              /* filling must start from the end of the previous user block */
    void * retptr     = NULL; /* result of aligned recalloc*/
    uintptr_t ptr     = 0;    /* points to the beginning of the allocated block*/

    /* ensure that (size * num) does not overflow */
    if (count > 0)
    {
        _VALIDATE_RETURN_NOEXC((_HEAP_MAXREQ / count) >= size, ENOMEM, NULL);
    }

    user_size = size * count;

    if (memblock != NULL)
    {
        start_fill = _aligned_msize(memblock, align, offset);
    }

    retptr = _aligned_offset_realloc_base(memblock, user_size, align, offset);

    if (retptr != NULL)
    {
        if (start_fill < user_size)
        {
            memset ((char*)retptr + start_fill, 0, user_size - start_fill);
        }
    }
    return retptr;
}

/***
*
* void *_aligned_free_base(void *memblock)
*       - Free the memory which was allocated using _aligned_malloc or
*       _aligned_offset_memory
*
* Purpose:
*       Frees the aligned memory block which was allocated using _aligned_malloc.
*
* Entry:
*       void * memblock - pointer to the block of memory
*
* Exceptions:
*       None. If memblock == NULL we simply return without doing anything.
*
*******************************************************************************/

void  __cdecl _aligned_free_base(void *memblock)
{
    uintptr_t ptr;

    if (memblock == NULL)
        return;

    ptr = (uintptr_t)memblock;

    /* ptr points to the pointer to starting of the memory block */
    ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

    /* ptr is the pointer to the start of memory block*/
    ptr = *((uintptr_t *)ptr);
    free((void *)ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\asctime.c ===
/***
*asctime.c - convert date/time structure to ASCII string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Contains asctime() - convert a date/time structure to ASCII string.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <malloc.h>
#include <stddef.h>
#include <tchar.h>
#include <dbgint.h>

#define _ASCBUFSIZE   26
static _TSCHAR buf[_ASCBUFSIZE];

/*
** This prototype must be local to this file since the procedure is static
*/

static _TSCHAR * __cdecl store_dt(_TSCHAR *, int);

static _TSCHAR * __cdecl store_dt (
    REG1 _TSCHAR *p,
    REG2 int val
    )
{
    *p++ = (_TSCHAR)(_T('0') + val / 10);
    *p++ = (_TSCHAR)(_T('0') + val % 10);
    return(p);
}


/***
*errno_t asctime_s(buffer, sizeInChars, time) - convert a structure time to
*ascii string
*
*Purpose:
*   Converts a time stored in a struct tm to a charcater string.
*   The string is always exactly 26 characters of the form
*       Tue May 01 02:34:55 1984\n\0
*
*Entry:
*   struct tm *time - ptr to time structure
*   _TSCHAR *buffer - ptr to output buffer
*   size_t sizeInChars - size of the buffer in characters including sapce for
*                        NULL terminator
*
*Exit:
*   errno_t = 0 success
*       out buffer with time string.
*   errno_t = correct error code
*       out buffer NULL terminated if it is at least 1 character in size
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tasctime_s (
    _TSCHAR *buffer,
    size_t sizeInChars,
    REG1 const struct tm *tb
    )
{
    REG2 _TSCHAR *p = buffer;
    int day, mon;
    int i;

    _VALIDATE_RETURN_ERRCODE(
        ( buffer != NULL ) && ( sizeInChars > 0 ),
        EINVAL
    )

    _RESET_STRING(buffer, sizeInChars);

    _VALIDATE_RETURN_ERRCODE(
        ( sizeInChars >= _ASCBUFSIZE ),
        EINVAL
    )
    _VALIDATE_RETURN_ERRCODE(
        ( tb != NULL ),
        EINVAL
    )
    _VALIDATE_RETURN_ERRCODE(
        ( tb->tm_year >= 0 ),
        EINVAL
    )
    // month 0 based
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_mon  >= 0 ) && ( tb->tm_mon  <= 11 ) ),
        EINVAL
    )
    // hour/min/sec 0 based
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_hour >= 0 ) && ( tb->tm_hour <= 23 ) ),
        EINVAL
    )
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_min  >= 0 ) && ( tb->tm_min  <= 59 ) ),
        EINVAL
    )
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_sec  >= 0 ) && ( tb->tm_sec  <= 59 ) ),
        EINVAL
    )
    // day 1 based
    _VALIDATE_RETURN_ERRCODE(
        (
            ( tb->tm_mday >= 1 ) &&
            (
                // Day is in valid range for the month
                ( ( _days[ tb->tm_mon + 1 ] - _days[ tb->tm_mon ] ) >=
                        tb->tm_mday ) ||
                // Special case for Feb in a leap year
                (
                    ( IS_LEAP_YEAR( tb->tm_year + 1900 ) ) &&
                    ( tb->tm_mon == 1 ) &&
                    ( tb->tm_mday <= 29 )
                )
            )
        ),
        EINVAL
    )
    // week day 0 based
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_wday >= 0 ) && ( tb->tm_wday <= 6 ) ),
        EINVAL
    )


    /* copy day and month names into the buffer */

    day = tb->tm_wday * 3;      /* index to correct day string */
    mon = tb->tm_mon * 3;       /* index to correct month string */
    for (i=0; i < 3; i++,p++) {
        *p = *(__dnames + day + i);
        *(p+4) = *(__mnames + mon + i);
    }

    *p = _T(' ');           /* blank between day and month */

    p += 4;

    *p++ = _T(' ');
    p = store_dt(p, tb->tm_mday);   /* day of the month (1-31) */
    *p++ = _T(' ');
    p = store_dt(p, tb->tm_hour);   /* hours (0-23) */
    *p++ = _T(':');
    p = store_dt(p, tb->tm_min);    /* minutes (0-59) */
    *p++ = _T(':');
    p = store_dt(p, tb->tm_sec);    /* seconds (0-59) */
    *p++ = _T(' ');
    p = store_dt(p, 19 + (tb->tm_year/100)); /* year (after 1900) */
    p = store_dt(p, tb->tm_year%100);
    *p++ = _T('\n');
    *p = _T('\0');


    return 0;
}

/***
*char *asctime(time) - convert a structure time to ascii string
*
*Purpose:
*   Converts a time stored in a struct tm to a charcater string.
*   The string is always exactly 26 characters of the form
*       Tue May 01 02:34:55 1984\n\0
*
*Entry:
*   struct tm *time - ptr to time structure
*
*Exit:
*   returns pointer to static string with time string.
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tasctime (
    REG1 const struct tm *tb
    )
{
    REG2 _TSCHAR *p = buf;
    errno_t e = 0;

    _TSCHAR *retval;            /* holds retval pointer */
    _ptiddata ptd = _getptd_noexit();

    /* Use per thread buffer area (malloc space, if necessary) */
    if (ptd) {
#ifdef _UNICODE
        if ( (ptd->_wasctimebuf != NULL) || ((ptd->_wasctimebuf =
            (wchar_t *)_calloc_crt(_ASCBUFSIZE, sizeof(wchar_t))) != NULL) )
            p = ptd->_wasctimebuf;
#else  /* _UNICODE */
        if ( (ptd->_asctimebuf != NULL) || ((ptd->_asctimebuf =
            (char *)_calloc_crt(_ASCBUFSIZE, sizeof(char))) != NULL) )
            p = ptd->_asctimebuf;
#endif  /* _UNICODE */
    }

    retval = p;         /* save return value for later */

    e = _tasctime_s( p, _ASCBUFSIZE, tb );
    if ( e != 0 )
    {
        return NULL;
    }

    return (retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */
#ifndef _INTERNAL_IFSTRIP_
#ifndef _ASSERT_OK
#error assert.h not for CRT internal use, use dbgint.h
#endif  /* _ASSERT_OK */
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */
#include <crtdefs.h>

#undef  assert

#ifdef NDEBUG

#define assert(_Expression)     ((void)0)

#else  /* NDEBUG */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

_CRTIMP void __cdecl _wassert(_In_z_ const wchar_t * _Message, _In_z_ const wchar_t *_File, _In_ unsigned _Line);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#define assert(_Expression) (void)( (!!(_Expression)) || (_wassert(_CRT_WIDE(#_Expression), _CRT_WIDE(__FILE__), __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\assert.c ===
/***
*assert.c - Display a message and abort
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <file2.h>
#include <internal.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <string.h>
#include <signal.h>
#include <awint.h>
#include <limits.h>
#include <dbgint.h>

#ifdef NDEBUG
#undef NDEBUG
#endif  /* NDEBUG */
#define _ASSERT_OK
#include <assert.h>


/*
 * assertion format string for use with output to stderr
 */
static TCHAR _assertstring[] = _T("Assertion failed: %s, file %s, line %d\n");

/*      Format of MessageBox for assertions:
*
*       ================= Microsft Visual C++ Debug Library ================
*
*       Assertion Failed!
*
*       Program: c:\test\mytest\foo.exe
*       File: c:\test\mytest\bar.c
*       Line: 69
*
*       Expression: <expression>
*
*       For information on how your program can cause an assertion
*       failure, see the Visual C++ documentation on asserts
*
*       (Press Retry to debug the application - JIT must be enabled)
*
*       ===================================================================
*/

/*
 * assertion string components for message box
 */
#define BOXINTRO    _T("Assertion failed!")
#define PROGINTRO   _T("Program: ")
#define FILEINTRO   _T("File: ")
#define LINEINTRO   _T("Line: ")
#define EXPRINTRO   _T("Expression: ")
#define INFOINTRO   _T("For information on how your program can cause an assertion\n") \
                    _T("failure, see the Visual C++ documentation on asserts")
#define HELPINTRO   _T("(Press Retry to debug the application - JIT must be enabled)")

static TCHAR * dotdotdot = _T("...");
static TCHAR * newline = _T("\n");
static TCHAR * dblnewline = _T("\n\n");

#define DOTDOTDOTSZ 3
#define NEWLINESZ   1
#define DBLNEWLINESZ   2

#define MAXLINELEN  60 /* max length for line in message box */
#define ASSERTBUFSZ (MAXLINELEN * 9) /* 9 lines in message box */

#ifdef _UNICODE
void __cdecl _assert (const char *, const char *,unsigned);
#endif  /* _UNICODE */

/***
*_assert() - Display a message and abort
*
*Purpose:
*       The assert macro calls this routine if the assert expression is
*       true.  By placing the assert code in a subroutine instead of within
*       the body of the macro, programs that call assert multiple times will
*       save space.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
void __cdecl _wassert (
        const wchar_t *expr,
        const wchar_t *filename,
        unsigned lineno
        )
#else  /* _UNICODE */
void __cdecl _assert (

        const char *expr,
        const char *filename,
        unsigned lineno
        )
#endif  /* _UNICODE */
{
        /*
         * Build the assertion message, then write it out. The exact form
         * depends on whether it is to be written out via stderr or the
         * MessageBox API.
         */
        if ( (_set_error_mode(_REPORT_ERRMODE)== _OUT_TO_STDERR) ||
             ((_set_error_mode(_REPORT_ERRMODE) == _OUT_TO_DEFAULT) &&
              (__app_type == _CONSOLE_APP)) )
        {
#ifdef _UNICODE
            {
                TCHAR assertbuf[ASSERTBUFSZ];
                HANDLE hErr ;
                DWORD written;

                hErr = GetStdHandle(STD_ERROR_HANDLE);

                if(hErr!=INVALID_HANDLE_VALUE && hErr!=NULL)
                {
                    if(swprintf(assertbuf, ASSERTBUFSZ,_assertstring,expr,filename,lineno) >= 0)
                    {
                        if(GetFileType(hErr) == FILE_TYPE_CHAR)
                        {
                            if(WriteConsoleW(hErr, assertbuf, (unsigned long)wcslen(assertbuf), &written, NULL))
                            {
                                abort();
                            }
                        }
                    }
                }
            }

#endif  /* _UNICODE */

            /*
             * Build message and write it out to stderr. It will be of the
             * form:
             *        Assertion failed: <expr>, file <filename>, line <lineno>
             */
            if ( !anybuf(stderr) )
            /*
             * stderr is unused, hence unbuffered, as yet. set it to
             * single character buffering (to avoid a malloc() of a
             * stream buffer).
             */
             (void) setvbuf(stderr, NULL, _IONBF, 0);


            _ftprintf(stderr, _assertstring, expr, filename, lineno);
            fflush(stderr);

        }
        else {
            int nCode;
            TCHAR * pch;
            TCHAR assertbuf[ASSERTBUFSZ];
            TCHAR progname[MAX_PATH + 1];

            /*
             * Line 1: box intro line
             */
            _ERRCHECK(_tcscpy_s( assertbuf, ASSERTBUFSZ, BOXINTRO ));
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dblnewline ));

            /*
             * Line 2: program line
             */
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, PROGINTRO ));

            progname[MAX_PATH] = _T('\0');
            if ( !GetModuleFileName( NULL, progname, MAX_PATH ))
                _ERRCHECK(_tcscpy_s( progname, MAX_PATH + 1, _T("<program name unknown>")));

            pch = (TCHAR *)progname;

            /* sizeof(PROGINTRO) includes the NULL terminator */
            if ( (sizeof(PROGINTRO)/sizeof(TCHAR)) + _tcslen(progname) + NEWLINESZ > MAXLINELEN )
            {
                pch += ((sizeof(PROGINTRO)/sizeof(TCHAR)) + _tcslen(progname) + NEWLINESZ) - MAXLINELEN;
                _ERRCHECK(_tcsncpy_s( pch, (MAX_PATH + 1) - (pch - progname), dotdotdot, DOTDOTDOTSZ ));
            }

            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, pch ));
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, newline ));

            /*
             * Line 3: file line
             */
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, FILEINTRO ));

            /* sizeof(FILEINTRO) includes the NULL terminator */
            if ( (sizeof(FILEINTRO)/sizeof(TCHAR)) + _tcslen(filename) + NEWLINESZ > MAXLINELEN )
            {
                size_t p, len, ffn;

                pch = (TCHAR *) filename;
                ffn = MAXLINELEN - (sizeof(FILEINTRO)/sizeof(TCHAR)) - NEWLINESZ;

                for ( len = _tcslen(filename), p = 1;
                      pch[len - p] != _T('\\') && pch[len - p] != _T('/') && p < len;
                      p++ );

                /* keeping pathname almost 2/3rd of full filename and rest
                 * is filename
                 */
                if ( (ffn - ffn/3) < (len - p) && ffn/3 > p )
                {
                    /* too long. using first part of path and the
                       filename string */
                    _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, pch, ffn - DOTDOTDOTSZ - p ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, pch + len - p ));
                }
                else if ( ffn - ffn/3 > len - p )
                {
                    /* pathname is smaller. keeping full pathname and putting
                     * dotdotdot in the middle of filename
                     */
                    p = p/2;
                    _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, pch, ffn - DOTDOTDOTSZ - p ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, pch + len - p ));
                }
                else
                {
                    /* both are long. using first part of path. using first and
                     * last part of filename.
                     */
                    _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, pch, ffn - ffn/3 - DOTDOTDOTSZ ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
                    _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, pch + len - p, ffn/6 - 1 ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, pch + len - (ffn/3 - ffn/6 - 2) ));
                }

            }
            else
                /* plenty of room on the line, just append the filename */
                _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, filename ));

            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, newline ));

            /*
             * Line 4: line line
             */
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, LINEINTRO ));
            _ERRCHECK(_itot_s( lineno, assertbuf + _tcslen(assertbuf), ASSERTBUFSZ - _tcslen(assertbuf), 10 ));
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dblnewline ));

            /*
             * Line 5: message line
             */
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, EXPRINTRO ));

            /* sizeof(HELPINTRO) includes the NULL terminator */

            if (    _tcslen(assertbuf) +
                    _tcslen(expr) +
                    2*DBLNEWLINESZ +
                    (sizeof(INFOINTRO)/sizeof(TCHAR)) - 1 +
                    (sizeof(HELPINTRO)/sizeof(TCHAR)) > ASSERTBUFSZ )
            {
                _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, expr,
                    ASSERTBUFSZ -
                    (_tcslen(assertbuf) +
                    DOTDOTDOTSZ +
                    2*DBLNEWLINESZ +
                    (sizeof(INFOINTRO)/sizeof(TCHAR))-1 +
                    (sizeof(HELPINTRO)/sizeof(TCHAR)))));
                _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
            }
            else
                _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, expr ));

            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dblnewline ));

            /*
             * Line 6, 7: info line
             */

            _ERRCHECK(_tcscat_s(assertbuf, ASSERTBUFSZ, INFOINTRO));
            _ERRCHECK(_tcscat_s(assertbuf, ASSERTBUFSZ, dblnewline ));

            /*
             * Line 8: help line
             */
            _ERRCHECK(_tcscat_s(assertbuf, ASSERTBUFSZ, HELPINTRO));

            /*
             * Write out via MessageBox
             */

            nCode = __crtMessageBox(assertbuf,
                _T("Microsoft Visual C++ Runtime Library"),
                MB_ABORTRETRYIGNORE|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);

            /* Abort: abort the program */
            if (nCode == IDABORT)
            {
                /* raise abort signal */
                raise(SIGABRT);

                /* We usually won't get here, but it's possible that
                   SIGABRT was ignored.  So exit the program anyway. */

                _exit(3);
            }

            /* Retry: call the debugger */
            if (nCode == IDRETRY)
            {
                __debugbreak();
                /* return to user code */
                return;
            }

            /* Ignore: continue execution */
            if (nCode == IDIGNORE)
                return;
        }

        abort();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\atodbl.c ===
/***
*atodbl.c - convert a string to a floating point value
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Converts a string to a floating point value.
*
*******************************************************************************/

#include <fltintrn.h>
#include <float.h>
#include <math.h>
#include <mtdll.h>
#include <internal.h>
#include <setlocal.h>

#include <atodbl.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\atonexit.c ===
/***
*atonexit.c - _onexit/atexit for using the MSVCRT* model of C run-time
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       atexit and _onexit are handled differently for EXE's and DLL's linked
*       with MSVCRT.LIB to call MSVCRT*.DLL.  Specifically, the _onexit/atexit
*       list for DLL's must be maintained on a per-module basis and must be
*       processed at DLL process detach .  For EXE's the atexit/_onexit list
*       should be maintained by MSVCRT*.DLL and processed at process exit.
*
*******************************************************************************/

/*
 * SPECIAL BUILD MACRO! Note that atonexit.c is linked in with the client's
 * code. It does not go into crtdll.dll! Therefore, it must be built under
 * the _DLL switch (like user code) and CRTDLL must be undefined.
 */

#undef  CRTDLL
#ifndef _DLL
#define _DLL
#endif  /* _DLL */

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <stdlib.h>
#include <mtdll.h>

/*
 * Pointers to beginning and end of the table of function pointers manipulated
 * by _onexit()/atexit().  If this module is an EXE, _onexitbegin will be -1.
 * Otherwise _onexitbegin will point to a block of malloc-ed memory used to
 * maintain the DLL module's private onexit list of terminator routines.
 * NOTE - the pointers are stored encoded.
 */

_PVFV *__onexitbegin;
_PVFV *__onexitend;


/***
*_onexit, atexit - calls to _onexit & atexit in MSVCRT*.DLL
*
*Purpose:
*       A DLL linked with MSVCRT.LIB must not call the standard _onexit or
*       atexit exported from MSVCRT*.DLL, but an EXE linked with MSVCRT.LIB
*       will call the standard versions of those two routines.  The standard
*       names are not exported from MSVCRT*.DLL, but the _imp__* names are,
*       so this module can just invoke the standard versions if linked into
*       an EXE module (indicated by __onexitbegin == -1).  If this module is
*       linked into a DLL (indicated by __onexitbegin != -1), it will call a
*       helper routine in MSVCRT*.DLL called __dllonexit to manage the DLL's
*       private onexit list.
*
*Entry:
*       Same as the regular versions of _onexit, atexit.
*
*Exit:
*       Same as the regular versions of _onexit, atexit.
*
*Exceptions:
*
*******************************************************************************/

extern _onexit_t __dllonexit(_onexit_t, _PVFV**, _PVFV**);

#ifdef _M_IX86
extern _onexit_t (__cdecl *_imp___onexit)(_onexit_t func);
#else  /* _M_IX86 */
extern _onexit_t (__cdecl *__imp__onexit)(_onexit_t func);
#endif  /* _M_IX86 */

_onexit_t __cdecl _onexit (
        _onexit_t func
        )
{
        _PVFV * onexitbegin;
        _PVFV * onexitend;
        _onexit_t retval;

        onexitbegin = (_PVFV *) DecodePointer(__onexitbegin);

        if (onexitbegin == (_PVFV *)-1)
        {
            /* EXE */
#ifdef _M_IX86
            return (*_imp___onexit)(func);
#else  /* _M_IX86 */
            return (*__imp__onexit)(func);
#endif  /* _M_IX86 */
        }

        /*
         * Note that we decode/encode the onexit array pointers on the
         * client side, not the CRT DLL side, to ease backwards compatibility.
         * That means we have to take a lock on this side, making the lock
         * found in __dllonexit redundant.
         */

        _lock(_EXIT_LOCK1);

        __try
        {
            onexitbegin = (_PVFV *) DecodePointer(__onexitbegin);
            onexitend   = (_PVFV *) DecodePointer(__onexitend);

            retval = __dllonexit((_onexit_t) EncodePointer(func), &onexitbegin, &onexitend);

            __onexitbegin = (_PVFV *) EncodePointer(onexitbegin);
            __onexitend   = (_PVFV *) EncodePointer(onexitend);
        }
        __finally
        {
            _unlock(_EXIT_LOCK1);
        }

        return retval;
}

int __cdecl atexit (
        _PVFV func
        )
{
        return (_onexit((_onexit_t)func) == NULL) ? -1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\atox.c ===
/***
*atox.c - atoi and atol conversion
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into an int or long.
*
*******************************************************************************/

#include <cruntime.h>
#include <mtdll.h>
#include <stdlib.h>
#include <ctype.h>
#include <mbctype.h>
#include <tchar.h>
#include <setlocal.h>
#ifdef _MBCS
#undef _MBCS
#endif  /* _MBCS */
#include <tchar.h>

/***
*long atol(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       It behaves exactly like strtol(nptr, NULL, 10).
*       Please refer to the strtol implementation for details.
*
*Entry:
*       nptr = ptr to string to convert
*
*       string format: [whitespace] [sign] [digits]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               LONG_MAX or LONG_MIN
*               errno == ERANGE
*
*       No digits or other error condition return:
*               0
*
*Exceptions:
*       Input parameters are validated. Refer to the strtox function family.
*
*******************************************************************************/

long __cdecl _tstol(
        const _TCHAR *nptr
        )
{
    return _tcstol(nptr, NULL, 10);
}


long __cdecl _tstol_l(
        const _TCHAR *nptr,
        _locale_t plocinfo
        )
{
    return _tcstol_l(nptr, NULL, 10, plocinfo);
}


/***
*int atoi(char *nptr) - Convert string to int
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       It behaves exactly like (int)strtol(nptr, NULL, 10).
*       Please refer to the strtol implementation for details.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               INT_MAX or INT_MIN
*               errno == ERANGE
*
*       No digits or other error condition return:
*               0
*
*Exceptions:
*       Input parameters are validated. Refer to the strtox function family.
*
*******************************************************************************/

int __cdecl _tstoi(
        const _TCHAR *nptr
        )
{
    return (int)_tstol(nptr);
}

int __cdecl _tstoi_l(
        const _TCHAR *nptr,
        _locale_t plocinfo
        )
{
    return (int)_tstol_l(nptr, plocinfo);
}

#ifndef _NO_INT64

/***
*int atoi64(char *nptr) - Convert string to int64
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       It behaves exactly like (int)strtoi64(nptr, NULL, 10).
*       Please refer to the strtoi64 implementation for details.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               _I64_MAX or _I64_MIN
*               errno == ERANGE
*
*       No digits or other error condition return:
*               0
*
*Exceptions:
*       Input parameters are validated. Refer to the strtox function family.
*
*******************************************************************************/

__int64 __cdecl _tstoi64(
        const _TCHAR *nptr
        )
{
    return _tcstoi64(nptr, NULL, 10);
}

__int64 __cdecl _tstoi64_l(
        const _TCHAR *nptr,
        _locale_t plocinfo
        )
{
    return _tcstoi64_l(nptr, NULL, 10, plocinfo);
}

#endif  /* _NO_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\awint.h ===
/***
*awint.h - internal definitions for A&W Win32 wrapper routines.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains internal definitions/declarations for A&W wrapper functions.
*       Not included in internal.h since windows.h is required for these.
*
*       [Internal]
*
****/

#pragma once

#ifdef _WIN32

#ifndef _INC_AWINC
#define _INC_AWINC

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#include <sal.h>
#include <windows.h>

/* internal A&W routines */
struct  threadlocaleinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;

int __cdecl __crtCompareStringW
(
    _In_ LCID     _Locale,
    _In_ DWORD    _DwCmpFlags,
    _In_count_(_CchCount1) LPCWSTR  _LpString1,
    _In_ int      _CchCount1,
    _In_count_(_CchCount2) LPCWSTR  _LpString2,
    _In_ int      _CchCount2
);

int __cdecl __crtCompareStringA
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID     _Locale,
    _In_ DWORD    _DwCmpFlags,
    _In_count_(_CchCount1) LPCSTR   _LpString1,
    _In_ int      _CchCount1,
    _In_count_(_CchCount2) LPCSTR   _LpString2,
    _In_ int      _CchCount2,
    _In_ int      _Code_page
);

int __cdecl __crtGetLocaleInfoA
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID    _Locale,
    _In_ LCTYPE  _LCType,
    _Out_opt_cap_(_CchData) LPSTR   _LpLCData,
    _In_ int     _CchData
);

int __cdecl __crtLCMapStringW
(
    _In_ LCID _Locale,
    _In_ DWORD _DWMapFlag,
    _In_count_(_CchSrc) LPCWSTR _LpSrcStr ,
    _In_ int _CchSrc,
    _Out_opt_cap_(_CchDest) LPWSTR _LpDestStr,
    _In_ int _CchDest
);

int __cdecl __crtLCMapStringA
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID _Locale,
        _In_ DWORD _DwMapFlag,
    _In_count_(_CchSrc) LPCSTR _LpSrcStr,
    _In_ int _CchSrc,
    _Out_opt_cap_(_CchDest) LPSTR _LpDestStr,
    _In_ int _CchDest,
    _In_ int _Code_page,
    _In_ BOOL _BError
);

BOOL __cdecl __crtGetStringTypeA
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ DWORD _DWInfoType,
    _In_ LPCSTR _LpSrcStr,
    _In_ int _CchSrc,
    _Out_ LPWORD _LpCharType,
    _In_ int _Code_page,
    _In_ int _Lcid,
    _In_ BOOL _BError
);

LPVOID __cdecl __crtGetEnvironmentStringsW(VOID);
LPVOID __cdecl __crtGetEnvironmentStringsA(VOID);

int __cdecl __crtMessageBoxA
(
    _In_ LPCSTR _LpText,
    _In_ LPCSTR _LpCaption,
    _In_ UINT _UType
);

int __cdecl __crtMessageBoxW
(
    _In_ LPCWSTR _LpText,
    _In_ LPCWSTR _LpCaption,
    _In_ UINT _UType
);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_AWINC */

#endif  /* _WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\atof.c ===
/***
*atof.c - convert char string to floating point number
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into a floating point number.
*
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <cruntime.h>
#include <fltintrn.h>
#include <string.h>
#include <ctype.h>
#include <mbctype.h>
#include <locale.h>
#include <internal.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*double atof(nptr) - convert string to floating point number
*
*Purpose:
*       atof recognizes an optional string of whitespace, then
*       an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string.
*
*Entry:
*       nptr - pointer to string to convert
*
*Exit:
*       returns floating point value of character representation
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

double __cdecl _atof_l(
        REG1 const char *nptr,
        _locale_t plocinfo
        )
{

        struct _flt fltstruct;      /* temporary structure */
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(nptr != NULL, EINVAL, 0.0);

        /* scan past leading space/tab characters */

        while ( _isspace_l((int)(unsigned char)*nptr, _loc_update.GetLocaleT()) )
                nptr++;

        /* let _fltin routine do the rest of the work */

        return( *(double *)&(_fltin2( &fltstruct, nptr, _loc_update.GetLocaleT())->dval) );
}

double __cdecl atof(
        REG1 const char *nptr
        )
{
    return _atof_l(nptr, NULL);
}

unsigned int __strgtold12
(
    _LDBL12 *pld12,
    const char * *p_end_ptr,
    const char * str,
    int mult12,
    int scale,
    int decpt,
    int implicit_E
)
{
        _LocaleUpdate _loc_update(NULL);

        return __strgtold12_l(pld12, p_end_ptr, str, mult12, scale, decpt, implicit_E, _loc_update.GetLocaleT());
}

unsigned __STRINGTOLD
(
        _LDOUBLE *pld,
        const char  * *p_end_ptr,
        const char  *str,
        int mult12
)
{
        _LocaleUpdate _loc_update(NULL);

        return __STRINGTOLD_L(pld, p_end_ptr, str, mult12, _loc_update.GetLocaleT());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\atodbl.inl ===
/***
*atodbl.inl - convert a string to a floating point value
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Converts a string to a floating point value.
*
*******************************************************************************/

#ifdef _SAFECRT_IMPL
#define _LOCALE_DATA dec_point
#else  /* _SAFECRT_IMPL */
#define _LOCALE_DATA _loc_update.GetLocaleT()
#endif  /* _SAFECRT_IMPL */

/***
*int _atodbl(_CRT_DOUBLE *, char *) - char string to convert floating point
*
*Purpose:
*   _atodbl like atod converts string to floating point. but this function
*   tries to avoid floating point exceptions by using _CRT_DOUBLE struct
*   which keeps the value in normal register.
*
*Entry:
*   _CRT_DOUBLE * - number to be converted to.
*   char * - string to be converted.
*
*Exit:
*   returns 0, when sucessful or _UNDERFLOW, _OVERFLOW when applicable.
*
*Exceptions:
*
*******************************************************************************/
#ifdef _SAFECRT_IMPL
int  _safecrt_atodbl(_CRT_DOUBLE *d, char *str, char dec_point)
#else  /* _SAFECRT_IMPL */
int  _atodbl_l(_CRT_DOUBLE *d, char *str, _locale_t plocinfo)
#endif  /* _SAFECRT_IMPL */
{
    const char *EndPtr;
    _LDBL12 ld12;
    unsigned int retval1=0;
    INTRNCVT_STATUS retval2=INTRNCVT_OK;

#ifndef _SAFECRT_IMPL
    _LocaleUpdate _loc_update(plocinfo);
#endif  /* _SAFECRT_IMPL */

    /*
     * The return valued of this return is 0, _OVERFLOW or _UNDERFLOW
     * The reason behind this is once we make these routines public,
     * we need some return value that are defined in shiped headers.
     */
    retval1 = __strgtold12_l(&ld12, &EndPtr, str, 0, 0, 0, 0, _LOCALE_DATA);
    retval2 = _ld12tod(&ld12, d);
    if ((retval1 & (SLD_OVERFLOW|SLD_UNDERFLOW))==0) {
        if (retval2 == INTRNCVT_OVERFLOW) {
            return _OVERFLOW;
        } else if (retval2 == INTRNCVT_UNDERFLOW) {
            return _UNDERFLOW;
        }
    } else if (retval1 & SLD_UNDERFLOW){
        return _UNDERFLOW;
    } else if (retval1 & SLD_OVERFLOW) {
        return _OVERFLOW;
    }
    return 0;
}

#ifndef _SAFECRT_IMPL
int  _atodbl(_CRT_DOUBLE *d, char *str)
{
    return _atodbl_l(d, str, NULL);
}
#endif  /* _SAFECRT_IMPL */

#ifdef _SAFECRT_IMPL
int _safecrt_atoldbl(_LDOUBLE *d, char *str, char dec_point)
#else  /* _SAFECRT_IMPL */
int _atoldbl_l(_LDOUBLE *d, char *str, _locale_t plocinfo)
#endif  /* _SAFECRT_IMPL */
{
    const char *EndPtr;
    _LDBL12 ld12;
    unsigned int retval1=0;
    INTRNCVT_STATUS retval2=INTRNCVT_OK;

#ifndef _SAFECRT_IMPL
    _LocaleUpdate _loc_update(plocinfo);
#endif  /* _SAFECRT_IMPL */
    /*
     * The return valued of this return is 0, _OVERFLOW or _UNDERFLOW
     * The reason behind this is once we make these routines public,
     * we need some return value that are defined in shiped headers.
     */
    retval1 = __strgtold12_l(&ld12, &EndPtr, str, 1, 0, 0, 0, _LOCALE_DATA);
    retval2 = _ld12told(&ld12, d);
    if ((retval1 & (SLD_OVERFLOW|SLD_UNDERFLOW))==0) {
        if (retval2 == INTRNCVT_OVERFLOW) {
            return _OVERFLOW;
        } else if (retval2 == INTRNCVT_UNDERFLOW) {
            return _UNDERFLOW;
        }
    } else if (retval1 & SLD_UNDERFLOW){
        return _UNDERFLOW;
    } else if (retval1 & SLD_OVERFLOW) {
        return _OVERFLOW;
    }
    return 0;
}

#ifndef _SAFECRT_IMPL
int _atoldbl(_LDOUBLE *d, char *str)
{
    return _atoldbl_l(d, str, NULL);
}
#endif  /* _SAFECRT_IMPL */

#ifdef _SAFECRT_IMPL
int _safecrt_atoflt(_CRT_FLOAT *d, char *str, char dec_point)
#else  /* _SAFECRT_IMPL */
int _atoflt_l(_CRT_FLOAT *d, char *str, _locale_t plocinfo)
#endif  /* _SAFECRT_IMPL */
{
    const char *EndPtr;
    _LDBL12 ld12;
    unsigned int retval1=0;
    INTRNCVT_STATUS retval2=INTRNCVT_OK;

#ifndef _SAFECRT_IMPL
    _LocaleUpdate _loc_update(plocinfo);
#endif  /* _SAFECRT_IMPL */
    /*
     * The return valued of this return is 0, _OVERFLOW or _UNDERFLOW
     * The reason behind this is once we make these routines public,
     * we need some return value that are defined in shiped headers.
     */
    retval1 = __strgtold12_l(&ld12, &EndPtr, str, 0, 0, 0, 0, _LOCALE_DATA);
    retval2 = _ld12tof(&ld12, d);
    if ((retval1 & (SLD_OVERFLOW|SLD_UNDERFLOW))==0) {
        if (retval2 == INTRNCVT_OVERFLOW) {
            return _OVERFLOW;
        } else if (retval2 == INTRNCVT_UNDERFLOW) {
            return _UNDERFLOW;
        }
    } else if (retval1 & SLD_UNDERFLOW){
        return _UNDERFLOW;
    } else if (retval1 & SLD_OVERFLOW) {
        return _OVERFLOW;
    }
    return 0;
}

#ifndef _SAFECRT_IMPL
int _atoflt(_CRT_FLOAT *d, char *str)
{
    return _atoflt_l(d, str, NULL);
}
#endif  /* _SAFECRT_IMPL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\a_cmp.c ===
/***
*a_cmp.c - A version of CompareString.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either CompareStringA or CompareStringW depending on which is
*       available
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <dbgint.h>
#include <stdlib.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <awint.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*int __cdecl strncnt - count characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string before NULL.
*       If NULL not found in n chars, then return n.
*
*Entry:
*       const char *string   - start of string
*       int n                - byte count
*
*Exit:
*       returns number of bytes from start of string to
*       NULL (exclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl strncnt (
        const char *string,
        int cnt
        )
{
        int n = cnt;
        char *cp = (char *)string;

        while (n-- && *cp)
            cp++;

        return cnt - n - 1;
}

/***
*int __cdecl __crtCompareStringA - Get type information about an ANSI string.
*
*Purpose:
*       Internal support function. Assumes info in ANSI string format. Tries
*       to use NLS API call CompareStringA if available and uses CompareStringW
*       if it must. If neither are available it fails and returns 0.
*
*Entry:
*       LCID    Locale      - locale context for the comparison.
*       DWORD   dwCmpFlags  - see NT\Chicago docs
*       LPCSTR  lpStringn   - multibyte string to be compared
*       int     cchCountn   - char (byte) count (NOT including NULL)
*                             (-1 if NULL terminated)
*       int     code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*Exit:
*       Success: 1 - if lpString1 <  lpString2
*                2 - if lpString1 == lpString2
*                3 - if lpString1 >  lpString2
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl __crtCompareStringA_stat(
        _locale_t plocinfo,
        LCID     Locale,
        DWORD    dwCmpFlags,
        LPCSTR   lpString1,
        int      cchCount1,
        LPCSTR   lpString2,
        int      cchCount2,
        int      code_page
        )
{
    /*
     * CompareString will compare past NULL. Must find NULL if in string
     * before cchCountn chars.
     */

    if (cchCount1 > 0)
        cchCount1 = strncnt(lpString1, cchCount1);
    else if ( cchCount1 < -1 )
        return FALSE;
    if (cchCount2 > 0)
        cchCount2 = strncnt(lpString2, cchCount2);
    else if ( cchCount2 < -1 )
        return FALSE;


    int buff_size1;
    int buff_size2;
    wchar_t *wbuffer1;
    wchar_t *wbuffer2;
    int retcode = 0;

    /*
     * Use __lc_codepage for conversion if code_page not specified
     */

    if (0 == code_page)
        code_page = plocinfo->locinfo->lc_codepage;

    /*
     * Special case: at least one count is zero
     */

    if (!cchCount1 || !cchCount2)
    {
        unsigned char *cp;  // char pointer
        CPINFO lpCPInfo;    // struct for use with GetCPInfo

        /* both strings zero */
        if (cchCount1 == cchCount2)
            return 2;

        /* string 1 greater */
        if (cchCount2 > 1)
            return 1;

        /* string 2 greater */
        if (cchCount1 > 1)
            return 3;

        /*
         * one has zero count, the other has a count of one
         * - if the one count is a naked lead byte, the strings are equal
         * - otherwise it is a single character and they are unequal
         */

        if (GetCPInfo(code_page, &lpCPInfo) == FALSE)
            return 0;

        _ASSERTE(cchCount1==0 && cchCount2==1 || cchCount1==1 && cchCount2==0);

        /* string 1 has count of 1 */
        if (cchCount1 > 0)
        {
            if (lpCPInfo.MaxCharSize < 2)
                return 3;

            for ( cp = (unsigned char *)lpCPInfo.LeadByte ;
                  cp[0] && cp[1] ;
                  cp += 2 )
                if ( (*(unsigned char *)lpString1 >= cp[0]) &&
                     (*(unsigned char *)lpString1 <= cp[1]) )
                    return 2;

            return 3;
        }

        /* string 2 has count of 1 */
        if (cchCount2 > 0)
        {
            if (lpCPInfo.MaxCharSize < 2)
            return 1;

            for ( cp = (unsigned char *)lpCPInfo.LeadByte ;
                  cp[0] && cp[1] ;
                  cp += 2 )
                if ( (*(unsigned char *)lpString2 >= cp[0]) &&
                     (*(unsigned char *)lpString2 <= cp[1]) )
                    return 2;

            return 1;
        }
    }

    /*
     * Convert strings and return the requested information.
     */

    /* find out how big a buffer we need (includes NULL if any) */
    if ( 0 == (buff_size1 = MultiByteToWideChar( code_page,
                                                 MB_PRECOMPOSED |
                                                    MB_ERR_INVALID_CHARS,
                                                 lpString1,
                                                 cchCount1,
                                                 NULL,
                                                 0 )) )
        return 0;

    /* allocate enough space for chars */
    wbuffer1 = (wchar_t *)_calloca( buff_size1, sizeof(wchar_t) );
    if ( wbuffer1 == NULL ) {
        return 0;
    }

    /* do the conversion */
    if ( 0 == MultiByteToWideChar( code_page,
                                   MB_PRECOMPOSED,
                                   lpString1,
                                   cchCount1,
                                   wbuffer1,
                                   buff_size1 ) )
        goto error_cleanup;

    /* find out how big a buffer we need (includes NULL if any) */
    if ( 0 == (buff_size2 = MultiByteToWideChar( code_page,
                                                 MB_PRECOMPOSED |
                                                    MB_ERR_INVALID_CHARS,
                                                 lpString2,
                                                 cchCount2,
                                                 NULL,
                                                 0 )) )
        goto error_cleanup;

    /* allocate enough space for chars */
    wbuffer2 = (wchar_t *)_calloca( buff_size2, sizeof(wchar_t) );
    if ( wbuffer2 == NULL ) {
        goto error_cleanup;
    }

    /* do the conversion */
    if ( 0 != MultiByteToWideChar( code_page,
                                   MB_PRECOMPOSED,
                                   lpString2,
                                   cchCount2,
                                   wbuffer2,
                                   buff_size2 ) )
        retcode = CompareStringW( Locale,
                                  dwCmpFlags,
                                  wbuffer1,
                                  buff_size1,
                                  wbuffer2,
                                  buff_size2 );

    _freea(wbuffer2);

error_cleanup:
    _freea(wbuffer1);

    return retcode;
}

extern "C" int __cdecl __crtCompareStringA(
        _locale_t plocinfo,
        LCID     Locale,
        DWORD    dwCmpFlags,
        LPCSTR   lpString1,
        int      cchCount1,
        LPCSTR   lpString2,
        int      cchCount2,
        int      code_page
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return __crtCompareStringA_stat(
            _loc_update.GetLocaleT(),
            Locale,
            dwCmpFlags,
            lpString1,
            cchCount1,
            lpString2,
            cchCount2,
            code_page
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\a_env.c ===
/***
*a_env.c - A version of GetEnvironmentStrings.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Use GetEnvironmentStringsW if available, otherwise use A version.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>

/***
*LPVOID __cdecl __crtGetEnvironmentStringsA - Get normal environment block
*
*Purpose:
*       Internal support function. Since GetEnvironmentStrings returns in OEM
*       and we want ANSI (note that GetEnvironmentVariable returns ANSI!) and
*       SetFileApistoAnsi() does not affect it, we have no choice but to
*       obtain the block in wide character and convert to ANSI.
*
*Entry:
*       VOID
*
*Exit:
*       LPVOID - pointer to environment block
*
*Exceptions:
*
*******************************************************************************/

LPVOID __cdecl __crtGetEnvironmentStringsA(
        VOID
        )
{
        wchar_t *wEnv;
        wchar_t *wTmp;
        char *aEnv = NULL;
        int nSizeW;
        int nSizeA;

        /* obtain wide environment block */

        if ( NULL == (wEnv = GetEnvironmentStringsW()) )
            return NULL;

        /* look for double null that indicates end of block */
        wTmp = wEnv;
        while ( *wTmp != L'\0' ) {
            if ( *++wTmp == L'\0' )
                wTmp++;
        }

        /* calculate total size of block, including all nulls */
        nSizeW = (int)(wTmp - wEnv + 1);

        /* find out how much space needed for multi-byte environment */
        nSizeA = WideCharToMultiByte(   CP_ACP,
                                        0,
                                        wEnv,
                                        nSizeW,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );

        /* allocate space for multi-byte string */
        if ( (nSizeA == 0) ||
             ((aEnv = (char *)_malloc_crt(nSizeA)) == NULL) )
        {
            FreeEnvironmentStringsW( wEnv );
            return NULL;
        }

        /* do the conversion */
        if ( !WideCharToMultiByte(  CP_ACP,
                                    0,
                                    wEnv,
                                    nSizeW,
                                    aEnv,
                                    nSizeA,
                                    NULL,
                                    NULL ) )
        {
            _free_crt( aEnv );
            aEnv = NULL;
        }

        FreeEnvironmentStringsW( wEnv );
        return aEnv;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\a_map.c ===
/***
*a_map.c - A version of LCMapString.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Use either LCMapStringA or LCMapStringW depending on which is available
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*int __cdecl strncnt - count characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string before
*       null. If null is not found in n chars, then return n.
*
*Entry:
*       const char *string   - start of string
*       int n                - byte count
*
*Exit:
*       returns number of bytes from start of string to
*       null (exclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl strncnt (
        const char *string,
        int cnt
        )
{
        int n = cnt;
        char *cp = (char *)string;

        while (n-- && *cp)
            cp++;

        return cnt - n - 1;
}


/***
*int __cdecl __crtLCMapStringA - Get type information about an ANSI string.
*
*Purpose:
*       Internal support function. Assumes info in ANSI string format. Tries
*       to use NLS API call LCMapStringA if available and uses LCMapStringW
*       if it must. If neither are available it fails and returns 0.
*
*Entry:
*       LCID     Locale      - locale context for the comparison.
*       DWORD    dwMapFlags  - see NT\Chicago docs
*       LPCSTR   lpSrcStr    - pointer to string to be mapped
*       int      cchSrc      - wide char (word) count of input string
*                              (including NULL if any)
*                              (-1 if NULL terminated)
*       LPSTR    lpDestStr   - pointer to memory to store mapping
*       int      cchDest     - char (byte) count of buffer (including NULL)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*       BOOL     bError      - TRUE if MB_ERR_INVALID_CHARS set on call to
*                              MultiByteToWideChar when GetStringTypeW used.
*
*Exit:
*       Success: number of chars written to lpDestStr (including NULL)
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl __crtLCMapStringA_stat(
        _locale_t plocinfo,
        LCID     Locale,
        DWORD    dwMapFlags,
        LPCSTR   lpSrcStr,
        int      cchSrc,
        LPSTR    lpDestStr,
        int      cchDest,
        int      code_page,
        BOOL     bError
        )
{
    /*
     * LCMapString will map past NULL. Must find NULL if in string
     * before cchSrc characters.
     */
    if (cchSrc > 0) {
        int cchSrcCnt = strncnt(lpSrcStr, cchSrc);
        /*
         * Include NULL in cchSrc if lpSrcStr terminated within cchSrc bytes.
         */
        if (cchSrcCnt < cchSrc) {
            cchSrc = cchSrcCnt + 1;
        } else {
            cchSrc = cchSrcCnt;
        }
    }

    int retval = 0;
    int inbuff_size;
    int outbuff_size;
    wchar_t *inwbuffer = NULL;
    wchar_t *outwbuffer = NULL;

    /*
     * Convert string and return the requested information. Note that
     * we are converting to a wide string so there is not a
     * one-to-one correspondence between number of wide chars in the
     * input string and the number of *bytes* in the buffer. However,
     * there had *better be* a one-to-one correspondence between the
     * number of wide characters and the number of multibyte characters
     * or the resulting mapped string will be worthless to the user.
     */

    /*
     * Use __lc_codepage for conversion if code_page not specified
     */

    if (0 == code_page)
        code_page = plocinfo->locinfo->lc_codepage;

    /* find out how big a buffer we need (includes NULL if any) */
    if ( 0 == (inbuff_size =
               MultiByteToWideChar( code_page,
                                    bError ? MB_PRECOMPOSED |
                                        MB_ERR_INVALID_CHARS :
                                        MB_PRECOMPOSED,
                                    lpSrcStr,
                                    cchSrc,
                                    NULL,
                                    0 )) )
        return 0;

    /* allocate enough space for wide chars */
    inwbuffer = (wchar_t *)_calloca( inbuff_size, sizeof(wchar_t) );
    if ( inwbuffer == NULL ) {
        return 0;
    }

    /* do the conversion */
    if ( 0 == MultiByteToWideChar( code_page,
                                   MB_PRECOMPOSED,
                                   lpSrcStr,
                                   cchSrc,
                                   inwbuffer,
                                   inbuff_size) )
        goto error_cleanup;

    /* get size required for string mapping */
    if ( 0 == (retval = LCMapStringW( Locale,
                                      dwMapFlags,
                                      inwbuffer,
                                      inbuff_size,
                                      NULL,
                                      0 )) )
        goto error_cleanup;

    if (dwMapFlags & LCMAP_SORTKEY) {
        /* retval is size in BYTES */

        if (0 != cchDest) {

            if (retval > cchDest)
                goto error_cleanup;

            /* do string mapping */
            if ( 0 == LCMapStringW( Locale,
                                    dwMapFlags,
                                    inwbuffer,
                                    inbuff_size,
                                    (LPWSTR)lpDestStr,
                                    cchDest ) )
                goto error_cleanup;
        }
    }
    else {
        /* retval is size in wide chars */

        outbuff_size = retval;

        /* allocate enough space for wide chars (includes NULL if any) */
        outwbuffer = (wchar_t *)_calloca( outbuff_size, sizeof(wchar_t) );
        if ( outwbuffer == NULL ) {
            goto error_cleanup;
        }

        /* do string mapping */
        if ( 0 == LCMapStringW( Locale,
                                dwMapFlags,
                                inwbuffer,
                                inbuff_size,
                                outwbuffer,
                                outbuff_size ) )
            goto error_cleanup;

        if (0 == cchDest) {
            /* get size required */
            if ( 0 == (retval =
                       WideCharToMultiByte( code_page,
                                            0,
                                            outwbuffer,
                                            outbuff_size,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL )) )
                goto error_cleanup;
        }
        else {
            /* convert mapping */
            if ( 0 == (retval =
                       WideCharToMultiByte( code_page,
                                            0,
                                            outwbuffer,
                                            outbuff_size,
                                            lpDestStr,
                                            cchDest,
                                            NULL,
                                            NULL )) )
                goto error_cleanup;
        }
    }

error_cleanup:
    if ( outwbuffer != NULL )
        _freea(outwbuffer);

    _freea(inwbuffer);

    return retval;
}

extern "C" int __cdecl __crtLCMapStringA(
        _locale_t plocinfo,
        LCID     Locale,
        DWORD    dwMapFlags,
        LPCSTR   lpSrcStr,
        int      cchSrc,
        LPSTR    lpDestStr,
        int      cchDest,
        int      code_page,
        BOOL     bError
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return __crtLCMapStringA_stat(
            _loc_update.GetLocaleT(),
            Locale,
            dwMapFlags,
            lpSrcStr,
            cchSrc,
            lpDestStr,
            cchDest,
            code_page,
            bError
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\a_loc.c ===
/***
*a_loc.c - A versions of GetLocaleInfo.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either GetLocaleInfoA or GetLocaleInfoW depending on which is
*       available
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*int __cdecl __crtGetLocaleInfoA - Get locale info and return it as an ASCII
*       string
*
*Purpose:
*       Internal support function. Assumes info in ANSI string format. Tries
*       to use NLS API call GetLocaleInfoA if available (Chicago) and uses
*       GetLocaleInfoA if it must (NT). If neither are available it fails and
*       returns 0.
*
*Entry:
*       LCID     Locale      - locale context for the comparison.
*       LCTYPE   LCType      - see NT\Chicago docs
*       LPSTR    lpLCData    - pointer to memory to return data
*       int      cchData     - char (byte) count of buffer (including NULL)
*                              (if 0, lpLCData is not referenced, size needed
*                              is returned)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*Exit:
*       Success: the number of characters copied (including NULL).
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl __crtGetLocaleInfoA_stat(
        _locale_t plocinfo,
        LCID    Locale,
        LCTYPE  LCType,
        LPSTR   lpLCData,
        int     cchData
        )
{
    int retval = 0;
    int code_page;
    int buff_size;
    wchar_t *wbuffer;

    /*
     * Use __lc_codepage for conversion
     */

    code_page = plocinfo->locinfo->lc_codepage;

    /* find out how big buffer needs to be */
    if (0 == (buff_size = GetLocaleInfoW(Locale, LCType, NULL, 0)))
        return 0;

    /* allocate buffer */
    wbuffer = (wchar_t *)_calloca( buff_size, sizeof(wchar_t) );
    if ( wbuffer == NULL ) {
        return 0;
    }

    /* get the info in wide format */
    if (0 == GetLocaleInfoW(Locale, LCType, wbuffer, buff_size))
        goto error_cleanup;

    /* convert from Wide Char to ANSI */
    if (0 == cchData)
    {
        /* convert into local buffer */
        retval = WideCharToMultiByte( code_page,
                                      0,
                                      wbuffer,
                                      -1,
                                      NULL,
                                      0,
                                      NULL,
                                      NULL );
    }
    else {
        /* convert into user buffer */
        retval = WideCharToMultiByte( code_page,
                                      0,
                                      wbuffer,
                                      -1,
                                      lpLCData,
                                      cchData,
                                      NULL,
                                      NULL );
    }

error_cleanup:
    _freea(wbuffer);

    return retval;
}

extern "C" int __cdecl __crtGetLocaleInfoA(
        _locale_t plocinfo,
        LCID    Locale,
        LCTYPE  LCType,
        LPSTR   lpLCData,
        int     cchData
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return __crtGetLocaleInfoA_stat(
            _loc_update.GetLocaleT(),
            Locale,
            LCType,
            lpLCData,
            cchData
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\badfunction.cpp ===
// _Xfunc -- exception for tr1 function template
#include <yvals.h>

 #if _HAS_TR1
#include <functional>

_STD_BEGIN
	namespace tr1 {	// TR1 additions

void __CLRCALL_PURE_OR_CDECL _Xfunc()
	{	// throw bad_function_call object
	_THROW_NCEE(bad_function_call, 0);
	}

	}	// namespace tr1
_STD_END
 #endif /* _HAS_TR1 */

/*
 * Copyright (c) 1992-2008 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.05:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\binmode.c ===
/***
*binmode.c - set global file mode to binary
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file mode flag to binary.  Linking with this file
*       sets all files to be opened in binary mode.
*
*******************************************************************************/

#define SPECIAL_CRTEXE

#include <cruntime.h>
#include <fcntl.h>
#include <stdlib.h>

/* set default file mode */
int _fmode = _O_BINARY;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\badweakptr.cpp ===
// _Xweak -- standard exception for tr1 smart_ptr
#include <yvals.h>

 #if _HAS_TR1
#include <memory>

_STD_BEGIN
	namespace tr1 {	// TR1 additions

void __CLRCALL_PURE_OR_CDECL _Xweak()
	{	// throw bad_weak_ptr object
	_THROW_NCEE(bad_weak_ptr, 0);
	}

	}	// namespace tr1
_STD_END
 #endif /* _HAS_TR1 */

/*
 * Copyright (c) 1992-2008 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.05:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\a_str.c ===
/***
*a_str.c - A version of GetStringType.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either GetStringTypeA or GetStringTypeW depending on which is
*       unstubbed.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <awint.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*int __cdecl __crtGetStringTypeA - Get type information about an ANSI string.
*
*Purpose:
*       Internal support function. Assumes info in ANSI string format. Tries
*       to use NLS API call GetStringTypeA if available and uses GetStringTypeW
*       if it must. If neither are available it fails and returns FALSE.
*
*Entry:
*       DWORD    dwInfoType  - see NT\Chicago docs
*       LPCSTR   lpSrcStr    - char (byte) string for which character types
*                              are requested
*       int      cchSrc      - char (byte) count of lpSrcStr (including NULL
*                              if any)
*       LPWORD   lpCharType  - word array to receive character type information
*                              (must be twice the size of lpSrcStr)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*       int      lcid        - for A call, specify LCID, If 0, use
*                              __lc_handle[LC_CTYPE].
*       BOOL     bError      - TRUE if MB_ERR_INVALID_CHARS set on call to
*                              MultiByteToWideChar when GetStringTypeW used.
*
*Exit:
*       Success: TRUE
*       Failure: FALSE
*
*Exceptions:
*
*******************************************************************************/

static BOOL __cdecl __crtGetStringTypeA_stat(
        _locale_t plocinfo,
        DWORD    dwInfoType,
        LPCSTR   lpSrcStr,
        int      cchSrc,
        LPWORD   lpCharType,
        int      code_page,
        int      lcid,
        BOOL     bError
        )
{
    int retval1;
    int buff_size;
    wchar_t *wbuffer;
    BOOL retval2 = FALSE;

    /*
     * Convert string and return the requested information. Note that
     * we are converting to a wide character string so there is not a
     * one-to-one correspondence between number of multibyte chars in the
     * input string and the number of wide chars in the buffer. However,
     * there had *better be* a one-to-one correspondence between the
     * number of multibyte characters and the number of WORDs in the
     * return buffer.
     */

    /*
     * Use __lc_codepage for conversion if code_page not specified
     */

    if (0 == code_page)
        code_page = plocinfo->locinfo->lc_codepage;

    /* find out how big a buffer we need */
    if ( 0 == (buff_size = MultiByteToWideChar( code_page,
                                                bError ?
                                                    MB_PRECOMPOSED |
                                                    MB_ERR_INVALID_CHARS
                                                    : MB_PRECOMPOSED,
                                                lpSrcStr,
                                                cchSrc,
                                                NULL,
                                                0 )) )
        return FALSE;

    /* allocate enough space for wide chars */
    wbuffer = (wchar_t *)_calloca( sizeof(wchar_t), buff_size );
    if ( wbuffer == NULL ) {
        return FALSE;
    }
    (void)memset( wbuffer, 0, sizeof(wchar_t) * buff_size );

    /* do the conversion */
    if ( 0 != (retval1 = MultiByteToWideChar( code_page,
                                             MB_PRECOMPOSED,
                                             lpSrcStr,
                                             cchSrc,
                                             wbuffer,
                                             buff_size )) )
        /* obtain result */
        retval2 = GetStringTypeW( dwInfoType,
                                  wbuffer,
                                  retval1,
                                  lpCharType );

    _freea(wbuffer);

    return retval2;
}

extern "C" BOOL __cdecl __crtGetStringTypeA(
        _locale_t plocinfo,
        DWORD    dwInfoType,
        LPCSTR   lpSrcStr,
        int      cchSrc,
        LPWORD   lpCharType,
        int      code_page,
        int      lcid,
        BOOL     bError
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return __crtGetStringTypeA_stat(
            _loc_update.GetLocaleT(),
            dwInfoType,
            lpSrcStr,
            cchSrc,
            lpCharType,
            code_page,
            lcid,
            bError
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\bsearch_s.c ===
/***
*bsearch_s.c - do a binary search
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines bsearch_s() - do a binary search an an array
*
*******************************************************************************/

/***
*char *bsearch_s() - do a binary search on an array
*
*Purpose:
*   Does a binary search of a sorted array for a key.
*
*Entry:
*   const char *key    - key to search for
*   const char *base   - base of sorted array to search
*   unsigned int num   - number of elements in array
*   unsigned int width - number of bytes per element
*   int (*compare)()   - pointer to function that compares two array
*           elements, returning neg when #1 < #2, pos when #1 > #2, and
*           0 when they are equal. Function is passed pointers to two
*           array elements, together with a pointer to a context.
*   void *context - pointer to the context in which the function is
*           called. This context is passed to the comparison function.
*
*Exit:
*   if key is found:
*           returns pointer to occurrence of key in array
*   if key is not found:
*           returns NULL
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "bsearch.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\bswap.c ===
/***
*rotl.c - rotate an unsigned integer left
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _byteswap() - performs a byteswap on an unsigned integer.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

#pragma function(_byteswap_ulong, _byteswap_uint64, _byteswap_ushort)

/***
*unsigned long _byteswap_ulong(i) - long byteswap
*
*Purpose:
*       Performs a byte swap on an unsigned integer.
*
*Entry:
*       unsigned long i:        value to swap
*
*Exit:
*       returns swaped
*
*Exceptions:
*       None.
*
*******************************************************************************/


unsigned long __cdecl _byteswap_ulong(unsigned long i)
{
    unsigned int j;
    j =  (i << 24);
    j += (i <<  8) & 0x00FF0000;
    j += (i >>  8) & 0x0000FF00;
    j += (i >> 24);
    return j;
}

unsigned short __cdecl _byteswap_ushort(unsigned short i)
{
    unsigned short j;
    j =  (i << 8) ;
    j += (i >> 8) ;
    return j;
}

unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 i)
{
    unsigned __int64 j;
    j =  (i << 56);
    j += (i << 40)&0x00FF000000000000;
    j += (i << 24)&0x0000FF0000000000;
    j += (i <<  8)&0x000000FF00000000;
    j += (i >>  8)&0x00000000FF000000;
    j += (i >> 24)&0x0000000000FF0000;
    j += (i >> 40)&0x000000000000FF00;
    j += (i >> 56);
    return j;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\CacheLocalScheduleGroup.cpp ===
// ==++==
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// CacheLocalScheduleGroup.cpp
//
// Implementation file for CacheLocalScheduleGroup.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#include "concrtinternal.h"

namespace Concurrency
{
namespace details
{
    /// <summary>
    ///     Puts a runnable context into the runnables collection in the schedule group.
    /// </summary>
    void CacheLocalScheduleGroup::AddToRunnablesCollection(InternalContextBase* pContext)
    {
        m_runnableContexts.Enqueue(pContext);
    }

} // namespace details
} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\bsearch.c ===
/***
*bsearch.c - do a binary search
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines bsearch() - do a binary search an an array
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <search.h>
#include <internal.h>

#if defined (_M_CEE)
#define __fileDECL  __clrcall
#else  /* defined (_M_CEE) */
#define __fileDECL  __cdecl
#endif  /* defined (_M_CEE) */
/***
*char *bsearch() - do a binary search on an array
*
*Purpose:
*   Does a binary search of a sorted array for a key.
*
*Entry:
*   const char *key    - key to search for
*   const char *base   - base of sorted array to search
*   unsigned int num   - number of elements in array
*   unsigned int width - number of bytes per element
*   int (*compare)()   - pointer to function that compares two array
*           elements, returning neg when #1 < #2, pos when #1 > #2, and
*           0 when they are equal. Function is passed pointers to two
*           array elements.
*
*Exit:
*   if key is found:
*           returns pointer to occurrence of key in array
*   if key is not found:
*           returns NULL
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#define __COMPARE(context, p1, p2) (*compare)(context, p1, p2)
#else  /* __USE_CONTEXT */
#define __COMPARE(context, p1, p2) (*compare)(p1, p2)
#endif  /* __USE_CONTEXT */

#if !defined (_M_CEE)
_CRTIMP
#endif  /* !defined (_M_CEE) */

SECURITYSAFECRITICAL_ATTRIBUTE
#ifdef __USE_CONTEXT
void * __fileDECL bsearch_s (
    REG4 const void *key,
    const void *base,
    size_t num,
    size_t width,
    int (__fileDECL *compare)(void *, const void *, const void *),
    void *context
    )
#else  /* __USE_CONTEXT */
void * __fileDECL bsearch (
    REG4 const void *key,
    const void *base,
    size_t num,
    size_t width,
    int (__fileDECL *compare)(const void *, const void *)
    )
#endif  /* __USE_CONTEXT */
{
    REG1 char *lo = (char *)base;
    REG2 char *hi = (char *)base + (num - 1) * width;
    REG3 char *mid;
    size_t half;
    int result;

    /* validation section */
    _VALIDATE_RETURN(base != NULL || num == 0, EINVAL, NULL);
    _VALIDATE_RETURN(width > 0, EINVAL, NULL);
    _VALIDATE_RETURN(compare != NULL, EINVAL, NULL);

        /*
        We allow a NULL key here because it breaks some older code and because we do not dereference
        this ourselves so we can't be sure that it's a problem for the comparison function
        */

    while (lo <= hi)
    {
        if ((half = num / 2) != 0)
        {
            mid = lo + (num & 1 ? half : (half - 1)) * width;
            if (!(result = __COMPARE(context, key, mid)))
                return(mid);
            else if (result < 0)
            {
                hi = mid - width;
                num = num & 1 ? half : half-1;
            }
            else
            {
                lo = mid + width;
                num = half;
            }
        }
        else if (num)
            return (__COMPARE(context, key, lo) ? NULL : lo);
        else
            break;
    }

    return NULL;
}

#undef __fileDECL
#undef __COMPARE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\calloc.c ===
/***
*calloc.c - allocate storage for an array from the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the calloc() function.
*
*******************************************************************************/

#include <malloc.h>
#include <string.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>

void * __cdecl _calloc_impl (size_t num, size_t size, int * errno_tmp);

/***
*void *calloc(size_t num, size_t size) - allocate storage for an array from
*       the heap
*
*Purpose:
*       Allocate a block of memory from heap big enough for an array of num
*       elements of size bytes each, initialize all bytes in the block to 0
*       and return a pointer to it.
*
*Entry:
*       size_t num  - number of elements in the array
*       size_t size - size of each element
*
*Exit:
*       Success:  void pointer to allocated block
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _calloc_base (size_t num, size_t size)
{
    int errno_tmp = 0;
    void * pv = _calloc_impl(num, size, &errno_tmp);

    if ( pv == NULL && errno_tmp != 0 && _errno())
    {
        errno = errno_tmp; // recall, #define errno *_errno()
    }
    return pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\CacheLocalScheduleGroup.h ===
// ==++==
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// CacheLocalScheduleGroup.h
//
// Header file containing CacheLocalScheduleGroup related declarations.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#pragma once

namespace Concurrency
{
namespace details
{

    class CacheLocalScheduleGroup : public ScheduleGroupBase
    {

    public:

        //
        // Public Methods
        //

        /// <summary>
        ///     Constructs a fair schedule group
        /// </summary>
        CacheLocalScheduleGroup(SchedulingRing *pRing) 
            : ScheduleGroupBase(pRing)
        {
            m_kind = CacheLocalScheduling;
        }

    private:
        friend class SchedulerBase;
        friend class ContextBase;
        friend class ExternalContextBase;
        friend class InternalContextBase;
        friend class ThreadInternalContext;
        friend class SchedulingNode;
        friend class SchedulingRing;
        friend class VirtualProcessor;

        //
        // Private data
        //

        // Each schedule group has three stores of work. It has a collection of runnable contexts,
        // a FIFO queue of realized chores and a list of workqueues that hold unrealized chores.

        // A collection of Runnable contexts.
        SafeSQueue<InternalContextBase, _HyperNonReentrantLock> m_runnableContexts;

        //
        // Private methods
        //

        /// <summary>
        ///     Puts a runnable context into the runnables collection in the schedule group.
        /// </summary>
        void AddToRunnablesCollection(InternalContextBase *pContext);

        InternalContextBase *GetRunnableContext()
        {
            if (m_runnableContexts.Empty())
                return NULL;

            InternalContextBase *pContext = m_runnableContexts.Dequeue();
#if defined(_DEBUG)
            SetContextDebugBits(pContext, CTX_DEBUGBIT_REMOVEDFROMRUNNABLES);
#endif // _DEBUG
            return pContext;
        }

        void * operator new(size_t _Size)
        {
            return ::operator new(_Size);
        }

        void operator delete(void * _Ptr)
        {
            ::operator delete(_Ptr);
        }
    };
} // namespace details
} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cds_cache_aligned_allocator.cpp ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
* Microsoft would like to acknowledge that this concurrency data structure implementation
* is based on Intels implementation in its Threading Building Blocks ("Intel Material").
* 
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* cds_cache_aligned_allocator.cpp
*
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

/*
    Intel Material Copyright 2005-2008 Intel Corporation.  All Rights Reserved.
*/


#include "cds_cache_aligned_allocator.h"
#include <cstdlib>
#include <crtdbg.h>
#include <stdio.h>
#include <windows.h>

using namespace std;

namespace Concurrency
{

namespace details
{

    static size_t NFS_LineSize = 64;

    _CRTIMP2 size_t NFS_GetLineSize()
    {
        return NFS_LineSize;
    }

    #pragma warning( push )
    // unary minus operator applied to unsigned type, result still unsigned
    #pragma warning( disable: 4146 )

    _CRTIMP2 void* NFS_Allocate( size_t n, size_t element_size, void* hint )
    {
        size_t m = NFS_LineSize;
        _ASSERTE( m<=NFS_MaxLineSize ); // illegal value for NFS_LineSize
        _ASSERTE( (m & m-1)==0 ); // must be power of two
        size_t bytes = n*element_size;
        unsigned char* base;
        if( bytes<n || bytes+m<bytes || !(base=(unsigned char*)(malloc(m+bytes))) ) 
        {
            // Overflow
            throw bad_alloc();
        }
        // Round up to next line
        unsigned char* result = (unsigned char*)((size_t)(base+m)&-m);
        // Record where block actually starts.  
        ((size_t*)result)[-1] = size_t(base);
        _ASSERTE( ((size_t)result&(m-1)) == 0 );  // The address returned isn't aligned to cache line size
        return result;
    }

    _CRTIMP2 void NFS_Free( void* p ) {
        if( p )
        {
            // Recover where block actually starts
            unsigned char* base = ((unsigned char**)p)[-1];
            _ASSERTE( (void*)((size_t)(base+NFS_LineSize)&-NFS_LineSize)==p ); // not allocated by NFS_Allocate?
            free(base);
        }
    }

    #pragma warning( pop )

} // namespace details

} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\calloc_impl.c ===
/***
*calloc_impl.c - implementation of _calloc_impl
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _calloc_impl() function.
*
*******************************************************************************/

#include <malloc.h>
#include <string.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>

void * __cdecl _calloc_impl (size_t num, size_t size, int * errno_tmp)
{
        size_t  size_orig;
        void *  pvReturn;

        /* ensure that (size * num) does not overflow */
        if (num > 0)
        {
            _VALIDATE_RETURN_NOEXC((_HEAP_MAXREQ / num) >= size, ENOMEM, NULL);
        }
        size_orig = size = size * num;


        /* force nonzero size */
        if (size == 0)
            size = 1;

        for (;;)
        {
            pvReturn = NULL;

            if (size <= _HEAP_MAXREQ)
            {
                if (pvReturn == NULL)
                    pvReturn = HeapAlloc(_crtheap, HEAP_ZERO_MEMORY, size);
            }

            if (pvReturn || _newmode == 0)
            {
                RTCCALLBACK(_RTC_Allocate_hook, (pvReturn, size_orig, 0));
                if (pvReturn == NULL)
                {
                    if ( errno_tmp )
                        *errno_tmp = ENOMEM;
                }
                return pvReturn;
            }

            /* call installed new handler */
            if (!_callnewh(size))
            {
                if ( errno_tmp )
                    *errno_tmp = ENOMEM;
                return NULL;
            }

            /* new handler was successful -- try to allocate again */
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cerr.cpp ===
// cerr -- initialize standard error stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)
static std::_Init_locks  initlocks;

_STD_BEGIN
		// OBJECT DECLARATIONS

__PURE_APPDOMAIN_GLOBAL static filebuf ferr(_cpp_stderr);
#if defined(_M_CEE_PURE)
__PURE_APPDOMAIN_GLOBAL extern ostream cerr(&ferr);
#else
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream cerr(&ferr);
#endif

		// INITIALIZATION CODE
struct _Init_cerr
	{	// ensures that cerr is initialized
	__CLR_OR_THIS_CALL _Init_cerr()
		{	// initialize cerr
		_Ptr_cerr = &cerr;
		cerr.tie(_Ptr_cout);
		cerr.setf(ios_base::unitbuf);
		}
	};
__PURE_APPDOMAIN_GLOBAL static _Init_cerr init_cerr;

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cgetws.c ===
/***
*cgetws.c - buffered keyboard input
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cgetws() - read a string directly from console
*
*******************************************************************************/
#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <conio.h>
#include <stdlib.h>
#include <internal.h>
#include <internal_securecrt.h>

#define BUF_MAX_LEN 64

extern intptr_t _coninpfh;

/*
 * Use of the following buffer variables is primarily for syncronizing with
 * _cgets_s. _cget_s fills the MBCS buffer and if the user passes in single
 * character buffer and the unicode character is not converted to single byte
 * MBC, then _cget_s should buffer that character so that next call to
 * _cgetws_s can return the same character.
 */
wchar_t __console_wchar_buffer;
int __console_wchar_buffer_used = 0;

/***
*errno_t _cgetws_s(string, sizeInBytes, pSizeRead) - read string from console
*
*Purpose:
*       Reads a string from the console via ReadConsole on a cooked console
*       handle.
*
*Entry:
*       wchar_t *string - place to store read string
*       sizeInBytes  - max length to read
*       pSizeRead - sets the max read in this
*
*Exit:
*       returns error code or 0 if no error occurs
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _cgetws_s (
        wchar_t *string,
        size_t sizeInWords,
        size_t * pSizeRead
        )
{
        ULONG oldstate;
        ULONG num_read;
        errno_t err = 0;

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((string != NULL), EINVAL);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((sizeInWords > 0), EINVAL);
        _RESET_STRING(string, sizeInWords);

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((pSizeRead != NULL), EINVAL);

        _mlock(_CONIO_LOCK);            /* lock the console */
        __TRY

            /*
             * We need to decrement sizeInWords because ReadConsole reads as
             * many characters as the parameter passed, doesn't null terminate
             */

            --sizeInWords;
            *pSizeRead = 0;

            /*
             * If the __console_whcar_buffer_used is set, then first fill the
             * buffered character and then proceed.
             */
            if (__console_wchar_buffer_used != 0 && sizeInWords > 0)
            {
                *string++ = __console_wchar_buffer;
                __console_wchar_buffer = 0;
                --sizeInWords;
                (*pSizeRead)++;
                if (__console_wchar_buffer == L'\0')
                    sizeInWords = 0;
            }

            /* if the user only asked for one character, we have now filled their request
            */
            if (sizeInWords != 0)
            {
                /*
                * _coninpfh, the handle to the console input, is created the first
                * time that either _getch() or _cgets() or _kbhit() is called.
                */

                if ( _coninpfh == -2 )
                    __initconin();

                if ( _coninpfh != -1 ) {
                    GetConsoleMode( (HANDLE)_coninpfh, &oldstate );
                    SetConsoleMode( (HANDLE)_coninpfh, ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT );

                    // First try usual way just as _cgets

                    if (ReadConsoleW((HANDLE) _coninpfh,
                                     (LPVOID) string,
                                     (DWORD) sizeInWords,
                                     &num_read,
                                     NULL))
                    {
                        /* set length of string and null terminate it */

                        if (num_read >= 2 && string[num_read - 2] == L'\r') {
                            (*pSizeRead) += num_read - 2;
                            string[num_read - 2] = L'\0';
                        } else if ( (num_read == sizeInWords) &&
                                                (string[num_read - 1] == L'\r') ) {
                            /* special case 1 - \r\n straddles the boundary */
                            (*pSizeRead) += num_read -1;
                            string[num_read - 1] = L'\0';
                        } else if ( (num_read == 1) && (string[0] == L'\n') ) {
                            /* special case 2 - read a single '\n'*/
                            string[0] = L'\0';
                            (*pSizeRead) += 0;
                        } else {
                            (*pSizeRead) += num_read;
                            string[num_read] = L'\0';
                        }
                    }

                    SetConsoleMode( (HANDLE)_coninpfh, oldstate );
                } else {
                    _dosmaperr(GetLastError());
                    err = errno;
                }
            }

        __FINALLY
            _munlock(_CONIO_LOCK);          /* unlock the console */
        __END_TRY_FINALLY

        if (err != 0)
        {
            errno = err;
        }
        return err;
}

/***
*wchar_t *_cgetws(string) - read string from console
*
*Purpose:
*       Reads a string from the console via ReadConsoleW on a cooked console
*       handle.  string[0] must contain the maximum length of the
*       string.  Returns pointer to str[2].
*
*       NOTE: _cgetsw() does NOT check the pushback character buffer (i.e.,
*       _chbuf).  Thus, _cgetws() will not return any character that is
*       pushed back by the _ungetwch() call.
*Entry:
*       char *string - place to store read string, str[0] = max length.
*
*Exit:
*       returns pointer to str[2], where the string starts.
*       returns NULL if error occurs
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _cgetws (
        wchar_t *string)
{
        size_t sizeInWords;
        size_t sizeRead;
        errno_t err;

        _VALIDATE_CLEAR_OSSERR_RETURN((string != NULL), EINVAL, NULL);

        sizeInWords = (size_t)string[0];

        err = _cgetws_s(string + 2, sizeInWords, &sizeRead);

        if(err != 0)
        {
            return NULL;
        }

       string[1] = (wchar_t)sizeRead;

       return string + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cgets.c ===
/***
*cgets.c - buffered keyboard input
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cgets() - read a string directly from console
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <conio.h>
#include <stdlib.h>
#include <internal.h>
#include <internal_securecrt.h>

/*
 * mask to clear the bits required to be 0 in the handle state passed to
 * DOSSETFHSTATE.
 */
#define FHSTATEMASK 0xffd07888

/*
 * declaration for console handle
 */

extern intptr_t _coninpfh;

/*
 * Use of the following buffer variables is primarily for syncronizing with
 * _cgets_s. _cget_s fills the MBCS buffer and if the user passes in single
 * character buffer and the unicode character is not converted to single byte
 * MBC, then _cget_s should buffer that character so that next call to
 * _cgetws_s can return the same character.
 */
extern wchar_t __console_wchar_buffer;
extern int __console_wchar_buffer_used;

/***
*errno_t _cgets_s(string, sizeInBytes, pSizeRead) - read string from console
*
*Purpose:
*       Reads a string from the console. Always null-terminate the buffer.
*
*Entry:
*       char *string - place to store read string
*       sizeInBytes  - max length to read
*       pSizeRead - sets the max read in this
*
*Exit:
*       returns error code or 0 if no error occurs
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _cgets_s (
        char *string,
        size_t sizeInBytes,
        size_t * pSizeRead
        )
{
        errno_t err = 0;
        size_t available;

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((string != NULL), EINVAL);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((sizeInBytes > 0), EINVAL);
        _RESET_STRING(string, sizeInBytes);

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((pSizeRead != NULL), EINVAL);

        available = sizeInBytes - 1;

        _mlock(_CONIO_LOCK);            /* lock the console */
        __TRY
            /*
             * The implementation of cgets is slightly tricky. The reason being,
             * the code page for console is different from the CRT code page.
             * What this means is the program may interpret character
             * differently from it's acctual value. To fix this, what we really
             * want to do is read the input as unicode string and then convert
             * it to proper MBCS representation.
             *
             * This fix this we are really converting from Unicode to MBCS.
             * This adds performance problem as we may endup doing this
             * character by character. The basic problem here is that we have
             * no way to know how many UNICODE characters will be needed to fit
             * them in given size of MBCS buffer. To fix this issue we will be
             * converting one Unicode character at a time to MBCS. This makes
             * this slow, but then this is already console input,
             */
            *pSizeRead = 0;
            do {
                wchar_t wchar_buff[2];
                size_t sizeRead=0;
                if ((err = _cgetws_s(wchar_buff, _countof(wchar_buff), &sizeRead)) == 0)
                {
                    int sizeConverted = 0;
                    if (wchar_buff[0] == L'\0')
                    {
                        break;
                    }
                    else if ((err = wctomb_s(&sizeConverted, string, available, wchar_buff[0])) == 0)
                    {
                        string += sizeConverted;
                        (*pSizeRead) += sizeConverted;
                        available -= sizeConverted;
                    }
                    else
                    {
                        /*
                         * Put the wchar back to the buffer so that the
                         * unutilized wchar is still in the stream.
                         */
                        __console_wchar_buffer = wchar_buff[0];
                        __console_wchar_buffer_used = 1;
                        break;
                    }
                }
                else
                {
                    break;
                }
            } while (available > 0);

        __FINALLY
            _munlock(_CONIO_LOCK);          /* unlock the console */
        __END_TRY_FINALLY

        *string++ = '\0';

        if (err != 0)
        {
            errno = err;
        }
        return err;
}

/***
*char *_cgets(string) - read string from console
*
*Purpose:
*       Reads a string from the console via ReadConsole on a cooked console
*       handle.  string[0] must contain the maximum length of the
*       string.  Returns pointer to str[2].
*
*       NOTE: _cgets() does NOT check the pushback character buffer (i.e.,
*       _chbuf).  Thus, _cgets() will not return any character that is
*       pushed back by the _ungetch() call.
*
*Entry:
*       char *string - place to store read string, str[0] = max length.
*
*Exit:
*       returns pointer to str[2], where the string starts.
*       returns NULL if error occurs
*
*Exceptions:
*
*******************************************************************************/
char * __cdecl _cgets (
        char *string)
{
        size_t sizeInBytes;
        size_t sizeRead = 0;
        errno_t err;

        _VALIDATE_CLEAR_OSSERR_RETURN((string != NULL), EINVAL, NULL);

        sizeInBytes = (size_t)string[0];

        err = _cgets_s(string + 2, sizeInBytes, &sizeRead);

        string[1] = (char)(sizeRead);

        if (err != 0)
        {
            return NULL;
        }

        return string + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\charmax.c ===
/***
*charmax.c - definition of _charmax variable
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _charmax
*
*       According to ANSI, certain elements of the lconv structure must be
*       initialized to CHAR_MAX and the value of CHAR_MAX changes when
*       the user compiles -J.  To reflect this change in the lconv structure,
*       we initialize the structure to SCHAR_MAX, and when any of the users
*       modules are compiled -J, the structure is updated.
*
*       Note that this is not done for DLLs linked to the CRT DLL, because
*       we do not want such DLLs to override the -J setting for an EXE
*       linked to the CRT DLL.  See comments in crtexe.c.
*
*       Files involved:
*
*       locale.h - if -J, generates an unresolved external to _charmax
*       charmax.c - defines _charmax and sets to UCHAR_MAX (255), places
*               _lconv_init in startup initializer table if pulled in by -J
*       lconv.c - initializes lconv structure to SCHAR_MAX (127),
*               since libraries built without -J
*       lcnvinit.c - sets lconv members to 25.
**
*******************************************************************************/

#include <sect_attribs.h>
#include <internal.h>

int __lconv_init(void);

int _charmax = 255;

_CRTALLOC(".CRT$XIC") static _PIFV pinit = __lconv_init;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cds_cache_aligned_allocator.h ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
* Microsoft would like to acknowledge that this concurrency data structure implementation
* is based on Intels implementation in its Threading Building Blocks ("Intel Material").
* 
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* cds_cache_aligned_allocator.h
*
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

/*
    Intel Material Copyright 2005-2008 Intel Corporation.  All Rights Reserved.
*/

#pragma once

#include <new>

namespace Concurrency
{

namespace details
{

    // Compile-time constant that is upper bound on cache line/sector size.
    /** It should be used only in situations where having a compile-time upper 
        bound is more useful than a run-time exact answer. */
    const size_t NFS_MaxLineSize = 128;

    // Cache/sector line size.
    _CRTIMP2 size_t NFS_GetLineSize();

    // Allocate memory on cache/sector line boundary.
    _CRTIMP2 void* NFS_Allocate( size_t n_element, size_t element_size, void* hint );

    // Free memory allocated by NFS_Allocate.
    /** Freeing a NULL pointer is allowed, but has no effect. */
    _CRTIMP2 void NFS_Free( void* );

    // Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5
    /** The members are ordered the same way they are in section 20.4.1
        of the ISO C++ standard. */
    template<typename _Ty>
    class cache_aligned_allocator
    {
    public:
        typedef _Ty* pointer;
        typedef const _Ty* const_pointer;
        typedef _Ty& reference;
        typedef const _Ty& const_reference;
        typedef _Ty value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;

        template<typename _U> struct rebind
        {
            typedef cache_aligned_allocator<_U> other;
        };

        cache_aligned_allocator() throw()
        {
        }

        cache_aligned_allocator( const cache_aligned_allocator& ) throw()
        {
        }

        template<typename _U> cache_aligned_allocator(const cache_aligned_allocator<_U>&) throw()
        {
        }

        pointer address(reference x) const
        {
            return &x;
        }

        const_pointer address(const_reference x) const
        {
            return &x;
        }
        
        // Allocate space for n objects, starting on a cache/sector line.
        pointer allocate( size_type n, const void* hint=0 )
        {
            // The "hint" argument is always ignored in NFS_Allocate thus const_cast shouldn't hurt
            return pointer(details::NFS_Allocate( n, sizeof(_Ty), const_cast<void*>(hint) ));
        }

        // Free block of memory that starts on a cache line
        void deallocate( pointer p, size_type )
        {
            details::NFS_Free(p);
        }

        // Largest value for which method allocate might succeed.
        size_type max_size() const throw()
        {
            return (~size_t(0)-details::NFS_MaxLineSize)/sizeof(_Ty);
        }

        // Copy-construct value at location pointed to by p.
        void construct( pointer p, const _Ty& value ) 
        {
            new(static_cast<void*>(p)) _Ty(value);
        }

        // Destroy value at location pointed to by p.
        void destroy( pointer p )
        {
            p->~_Ty();
        }
    };

    // Analogous to std::allocator<void>, as defined in ISO C++ Standard, Section 20.4.1
    template<> 
    class cache_aligned_allocator<void> {
    public:
        typedef void* pointer;
        typedef const void* const_pointer;
        typedef void value_type;

        template<typename _U> struct rebind
        {
            typedef cache_aligned_allocator<_U> other;
        };
    };

    template<typename _Ty, typename _U>
    inline bool operator==( const cache_aligned_allocator<_Ty>&, const cache_aligned_allocator<_U>& )
    {
        return true;
    }

    template<typename _Ty, typename _U>
    inline bool operator!=( const cache_aligned_allocator<_Ty>&, const cache_aligned_allocator<_U>& ) 
    {
        return false;
    }

} // namespace details

} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\chdir.c ===
/***
*chdir.c - change directory
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _chdir() function - change current directory.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <direct.h>
#include <stdlib.h>
#include <tchar.h>
#include <malloc.h>
#include <dbgint.h>

/***
*int _chdir(path) - change current directory
*
*Purpose:
*       Changes the current working directory to that given in path.
*
*Entry:
*       _TSCHAR *path - directory to change to
*
*Exit:
*       returns 0 if successful,
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tchdir (
        const _TSCHAR *path
        )
{
        _TSCHAR env_var[4];
        _TSCHAR abspath[MAX_PATH+1];
        _TSCHAR *apath=abspath;
        int memfree=0;
        int r;
        int retval = -1;

        _VALIDATE_CLEAR_OSSERR_RETURN((path != NULL), EINVAL, -1);

        if ( SetCurrentDirectory((LPTSTR)path) )
        {
            /*
             * If the new current directory path is NOT a UNC path, we must
             * update the OS environment variable specifying the current
             * directory for what is now current drive. To do this, get the
             * full current directory, build the environment variable string
             * and call SetEnvironmentVariable(). We need to do this because
             * SetCurrentDirectory does not (i.e., does not update the
             * current-directory-on-drive environment variables) and other
             * functions (fullpath, spawn, etc) need them to be set.
             *
             * If associated with a 'drive', the current directory should
             * have the form of the example below:
             *
             *  D:\nt\private\mytests
             *
             * so that the environment variable should be of the form:
             *
             *  =D:=D:\nt\private\mytests
             *
             */
            r = GetCurrentDirectory(MAX_PATH+1,(LPTSTR)apath);
            if (r > MAX_PATH) {
                if ((apath = (_TSCHAR *)_calloc_crt(r+1, sizeof(_TSCHAR))) == NULL) {
                    r = 0;
                } else {
                    memfree = 1;
                }

                if (r)
                    r = GetCurrentDirectory(r+1,(LPTSTR)apath);
            }
            if (r)
            {
                /*
                 * check if it is a UNC name, just return if is
                 */
                if ( ((apath[0] == _T('\\')) || (apath[0] == _T('/'))) &&
                     (apath[0] == apath[1]) )
                    retval = 0;
                else {

                    env_var[0] = _T('=');
                    env_var[1] = (_TSCHAR) _totupper((_TUCHAR)apath[0]);
                    env_var[2] = _T(':');
                    env_var[3] = _T('\0');

                    if ( SetEnvironmentVariable(env_var, apath) )
                        retval = 0;
                }
            }
        }

        if( 0 != retval )
        {
            /* error occured -- map error code */
            _dosmaperr( GetLastError() );
        }

        if (memfree)
            _free_crt(apath);
        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cenvarg.c ===
/***
*cenvarg.c - set up environment, command line blocks
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cenvarg() - setup environment/command line blocks
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <errno.h>
#include <msdos.h>
#include <stdlib.h>
#include <stdarg.h>
#include <internal.h>
#include <string.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>

/* local tchar */
#ifdef WPRFLAG
#define _tenvptr    _wenvptr
#else  /* WPRFLAG */
#define _tenvptr    _aenvptr
#endif  /* WPRFLAG */

/***
*int _cenvarg(argv, envp, argblk, envblk, name) - set up cmd line/environ
*
*Purpose:
*       Set up the block forms of  the environment and the command line.
*       If "envp" is null, "_environ" is used instead.
*
*Entry:
*       _TSCHAR **argv   - argument vector
*       _TSCHAR **envp   - environment vector
*       _TSCHAR **argblk - pointer to pointer set to malloc'ed space for args
*       _TSCHAR **envblk - pointer to pointer set to malloc'ed space for env
*       _TSCHAR *name    - name of program being invoked
*
*Exit:
*       returns 0 if ok, -1 if fails
*       stores through argblk and envblk
*       (calls malloc)
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl _wcenvarg (
#else  /* WPRFLAG */
int __cdecl _cenvarg (
#endif  /* WPRFLAG */
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp,
        _TSCHAR **argblk,
        _TSCHAR **envblk,
        const _TSCHAR *name
        )
{
        REG1 const _TSCHAR * const *vp;
        REG2 unsigned tmp;
        REG3 _TSCHAR *cptr;
        unsigned arg_len;
        unsigned env_len;
        int cfi_len;            /* counts the number of file handles in CFI */
        int retval = 0;

        /*
         * Null environment pointer "envp" means use global variable,
         * "_environ"
         */

        int cwd_start;
        int cwd_end;            /* length of "cwd" strings in environment */

        _TSCHAR envpfx[] = _T("SystemRoot");
        _TSCHAR *envbuf = NULL;
        int envsize = 0;
        int defined = 0;

        /*
         * Allocate space for command line string
         *  tmp counts the number of bytes in the command line string
         *      including spaces between arguments
         *  An empty string is special -- 2 bytes
         */

        for (vp = argv, tmp = 2; *vp; tmp += (unsigned int)_tcslen(*vp++) + 1) ;

        arg_len = tmp;

        /*
         * Allocate space for the command line plus 2 null bytes
         */

        if ( (*argblk = _calloc_crt(tmp, sizeof(_TSCHAR))) == NULL)
        {
                *envblk = NULL;
                errno = ENOMEM;
                _doserrno = E_nomem;
                return(-1);
        }

        if (_ERRCHECK_EINVAL(_tdupenv_s_crt(&envbuf, NULL, envpfx)) != 0)
        {
                retval = -1;
                goto error;
        }

        envsize = (int)_tcslen(envpfx) + 2;
        if (envbuf != NULL)
        {
            envsize += (int)_tcslen(envbuf);
        }

        /*
         * Allocate space for environment strings
         *  tmp counts the number of bytes in the environment strings
         *      including nulls between strings
         *  Also add "_C_FILE_INFO=" string
         */
        if (envp)
                for (vp = envp, tmp = 2; *vp; tmp += (unsigned int)_tcslen(*vp++) + 1) ;

        /*
         * The _osfile and _osfhnd arrays are passed as binary data in
         * dospawn.c
         */
        cfi_len = 0;    /* no _C_FILE_INFO */

        if (!envp)
                *envblk = NULL;
        else {
                /*
                 * Now that we've decided to pass our own environment block,
                 * compute the size of the "current directory" strings to
                 * propagate to the new environment.
                 */

#ifdef WPRFLAG
                /*
                 * Make sure wide environment exists.
                 */
                if (!_wenvptr)
                {
                        if ((_wenvptr = (wchar_t *)__crtGetEnvironmentStringsW()) == NULL)
                        {
                                retval = -1;
                                goto error;
                        }
                }
#else  /* WPRFLAG */
                if (!_aenvptr)
                {
                        if ((_aenvptr = (char *)__crtGetEnvironmentStringsA()) == NULL)
                        {
                                retval = -1;
                                goto error;
                        }
                }
#endif  /* WPRFLAG */

                /*
                 * search for the first one
                 */
                for (cwd_start = 0;
                     _tenvptr[cwd_start] != _T('\0') &&
                       _tenvptr[cwd_start] != _T('=');
                     cwd_start += (int)_tcslen(&_tenvptr[cwd_start]) + 1)
                {
                }

                /* find the total size of all contiguous ones */
                cwd_end = cwd_start;
                while (_tenvptr[cwd_end+0] == _T('=') &&
                       _tenvptr[cwd_end+1] != _T('\0') &&
                       _tenvptr[cwd_end+2] == _T(':') &&
                       _tenvptr[cwd_end+3] == _T('='))
                {
                        cwd_end += 4 + (int)_tcslen(&_tenvptr[cwd_end+4]) + 1;
                }
                tmp += cwd_end - cwd_start;

                /*
                 * Allocate space for the environment strings plus extra null byte
                 */
                env_len = tmp;

                /*
                 * Check if SystemRoot is already defined in environment provided
                 */
                for (vp = envp; *vp; vp++) {
                        if (_tcsncicmp(*vp, envpfx, _tcslen(envpfx)) == 0) {
                                defined = 1;
                                break;
                        }
                }

                if (!defined)
                        tmp += envsize;

                if( !(*envblk = _calloc_crt(tmp, sizeof(_TSCHAR))) )
                {
                        _free_crt(*argblk);
                        *argblk = NULL;
                        errno = ENOMEM;
                        _doserrno = E_nomem;
                        retval = -1;
                        goto done;
                }
        }

        /*
         * Build the command line by concatenating the argument strings
         * with spaces between, and two null bytes at the end.
         * NOTE: The argv[0] argument is followed by a null.
         */

        cptr = *argblk;
        vp = argv;

        if (!*vp)       /* Empty argument list ? */
                ++cptr; /* just two null bytes */
        else {          /* argv[0] must be followed by a null */
                _ERRCHECK(_tcscpy_s(cptr, arg_len - (cptr - *argblk), *vp));
                cptr += (int)_tcslen(*vp++) + 1;
        }

        while( *vp ) {
                _ERRCHECK(_tcscpy_s(cptr, arg_len - (cptr - *argblk), *vp));
                cptr += (int)_tcslen(*vp++);
                *cptr++ = ' ';
        }

        *cptr = cptr[ -1 ] = _T('\0'); /* remove extra blank, add double null */

        /*
         * Build the environment block by concatenating the environment
         * strings with nulls between and two null bytes at the end
         */

        cptr = *envblk;

        if (envp != NULL) {
                /*
                 * Copy the "cwd" strings to the new environment.
                 */
                memcpy(cptr, &_tenvptr[cwd_start], (cwd_end - cwd_start) * sizeof(_TSCHAR));
                cptr += cwd_end - cwd_start;

                /*
                 * Copy the environment strings from "envp".
                 */
                vp = envp;
                while( *vp ) {
                        _ERRCHECK(_tcscpy_s(cptr, env_len - (cptr - *envblk), *vp));
                        cptr += 1 + (int)_tcslen(*vp++);
                }

                if (!defined) {
                        /*
                         * Copy SystemRoot to the new environment.
                         */
                        _ERRCHECK(_tcscpy_s(cptr, envsize, envpfx));
                        _ERRCHECK(_tcscat_s(cptr, envsize, _T("=")));
                        if (envbuf != NULL)
                        {
                            _ERRCHECK(_tcscat_s(cptr, envsize, envbuf));
                        }
                        cptr += envsize;
                }
        }

        if (cptr != NULL) {
                if (cptr == *envblk) {
                        /*
                         * Empty environment block ... this requires two
                         * nulls.
                         */
                        *cptr++ = _T('\0');
                }
                /*
                 * Extra null terminates the segment
                 */
                *cptr = _T('\0');
        }

        goto done;

error:
        _free_crt(*argblk);
        *argblk = NULL;
        *envblk = NULL;

done:

#ifdef WPRFLAG
        if (_wenvptr)
                _free_crt(_wenvptr);
        _wenvptr = NULL;
#else  /* WPRFLAG */
        if (_aenvptr)
                _free_crt(_aenvptr);
        _aenvptr = NULL;
#endif  /* WPRFLAG */
        if (envbuf)
                _free_crt(envbuf);

        return retval;
}


#ifndef _M_IX86

/***
*int _capture_argv(arglist, static_argv, max_static_entries) - set up argv array
*       for exec?? functions
*
*Purpose:
*       Set up the argv array for the exec?? functions by captures the
*       arguments from the passed va_list into the static_argv array.  If the
*       size of the static_argv array as specified by the max_static_entries
*       parameter is not large enough, then allocates a dynamic array to hold
*       the arguments. Return the address of the final argv array.  If NULL
*       then not enough memory to hold argument array.  If different from
*       static_argv parameter then call must free the return argv array when
*       done with it.
*
*       The scan of the arglist is terminated when a NULL argument is
*       reached. The terminating NULL parameter is stored in the resulting
*       argv array.
*
*Entry:
*       va_list *arglist          - pointer to variable length argument list.
*       _TSCHAR *firstarg            - first argument to store in array
*       _TSCHAR **static_argv        - pointer to static argv to use.
*       size_t max_static_entries - maximum number of entries that can be
*                                   placed in static_argv array.
*
*Exit:
*       returns NULL if no memory.
*       Otherwise returns pointer to argv array.
*       (sometimes calls malloc)
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
_TSCHAR ** __cdecl _wcapture_argv(
#else  /* WPRFLAG */
_TSCHAR ** __cdecl _capture_argv(
#endif  /* WPRFLAG */
        va_list *arglist,
        const _TSCHAR *firstarg,
        _TSCHAR **static_argv,
        size_t max_static_entries
        )
{
        _TSCHAR ** argv;
        _TSCHAR * nextarg;
        size_t i;
        size_t max_entries;

        nextarg = (_TSCHAR *)firstarg;
        argv = static_argv;
        max_entries = max_static_entries;
        i = 0;
        for (;;) {
            if (i >= max_entries) {
                /* The math here looks slightly odd. We really want (max_entries*2)*sizeof(_TSCHAR), but that can overflow
                   We take advantage of calloc's ability to catch overflow and the fact that sizeof(_TSCHAR)*2 cannot overflow
                */
                if (argv == static_argv)
                {
                    argv = _calloc_crt(max_entries, sizeof(_TSCHAR *)*2);
                }
                else
                {
                    argv = _recalloc_crt(argv, max_entries, sizeof(_TSCHAR *)*2);
                }

                if (argv == NULL) break;
                max_entries += max_entries;
            }

            argv[ i++ ] = nextarg;
            if (nextarg == NULL) break;
            nextarg = va_arg(*arglist, _TSCHAR *);
        }

        return argv;
}

#endif  /* _M_IX86 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\chmod.c ===
/***
*chmod.c - change file attributes
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _chmod() - change file attributes
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tchar.h>

/***
*int _chmod(path, mode) - change file mode
*
*Purpose:
*       Changes file mode permission setting to that specified in
*       mode.  The only XENIX mode bit supported is user write.
*
*Entry:
*       _TSCHAR *path - file name
*       int mode - mode to change to
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if not successful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tchmod (
        const _TSCHAR *path,
        int mode
        )
{
        DWORD attr;

        _VALIDATE_CLEAR_OSSERR_RETURN((path != NULL), EINVAL, -1);

        attr = GetFileAttributes((LPTSTR)path);
        if (attr  == 0xffffffff) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        if (mode & _S_IWRITE) {
                /* clear read only bit */
                attr &= ~FILE_ATTRIBUTE_READONLY;
        }
        else {
                /* set read only bit */
                attr |= FILE_ATTRIBUTE_READONLY;
        }

        /* set new attribute */
        if (!SetFileAttributes((LPTSTR)path, attr)) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\Chores.cpp ===
// ==++==
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// Chores.cpp
//
// Miscellaneous implementations of things related to individuals chores
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#include "concrtinternal.h"

namespace Concurrency
{
namespace details
{
    /// <summary>
    ///     Sets the attachment state of the chore at the time of stealing.
    /// </summary>
    void _UnrealizedChore::_SetDetached(bool _FDetached)
    {
        _M_fDetached = _FDetached;
    }

    /// <summary>
    ///     To free memory allocated with _InternalAlloc.
    /// </summary>
    void _UnrealizedChore::_InternalFree(_UnrealizedChore * _PChore)
    {
        if (_PChore->_M_fRuntimeOwnsLifetime)
        {
            delete _PChore;
        }
    }

    /// <summary>
    ///     Place associated task collection in a safe state.
    /// </summary>
    void _UnrealizedChore::_CheckTaskCollection()
    {
        //
        // If _M_pTaskCollection is non-NULL, the chore is still scheduled to a task collection.  This is only happening
        // from a handle destructor and we have blown back through a stack based handle while it's still scheduled.  We must
        // wait.  The semantic we choose is that this means cancellation too.
        //
        Concurrency::details::_TaskCollectionBase *pBase = _M_pTaskCollection;
        if (pBase != NULL)
        {
            bool fThrow = false;

            if (_M_pChoreFunction == &_UnrealizedChore::_StructuredChoreWrapper)
            {
                _StructuredTaskCollection *pTaskCollection = static_cast<_StructuredTaskCollection *>(pBase);
                fThrow = !pTaskCollection->_TaskCleanup();
            }
            else
            {
                _TaskCollection *pTaskCollection = static_cast<_TaskCollection *>(pBase);
                fThrow = !pTaskCollection->_TaskCleanup(true);
            }

            if (fThrow)
                throw missing_wait();
        }
    }

    /// <summary>
    ///     Wrapper around execution of a structured chore that performs appropriate notification
    ///     and exception handling semantics.
    /// </summary>
    __declspec(noinline)
    void __cdecl _UnrealizedChore::_StructuredChoreWrapper(_UnrealizedChore * pChore)
    {
        InternalContextBase *pContext = static_cast<InternalContextBase *> (SchedulerBase::FastCurrentContext());
        ASSERT(!pContext->IsCanceled());

        _StructuredTaskCollection *pTaskCollection = static_cast<_StructuredTaskCollection *> (pChore->_M_pTaskCollection);
        ContextBase *pOriginContext = reinterpret_cast <ContextBase *> (pTaskCollection->_M_pOwningContext);

        pContext->SetRootCollection(pTaskCollection);

        pOriginContext->AddStealer(pContext, false);

        try
        {
            //
            // We need to consider this a possible interruption point.  It's entirely possible that we stole and raced with a
            // cancellation thread.  The collection was canceled after we stole(e.g.: removed from the WSQ) but before we added ourselves
            // to the stealing chain list above.  In this case, the entire context will wait until completion (bad).  Immediately
            // after we go on the list (a memory barrier) we need to check the collection cancelation flag.  If the collection is going away,
            // we need to get out *NOW* otherwise the entire subtree executes.
            //
            if (pTaskCollection->_IsAbnormalExit())
                throw task_canceled();

            pChore->m_pFunction(pChore);
        }
        catch(const task_canceled &)
        {
            //
            // If someone manually threw the task_canceled exception, we will have a cancel count but not a canceled context.  This
            // means we need to apply the cancel one level up.  Normally, the act of throwing would do that via being caught in the
            // wait, but this is special "marshaling" for task_canceled.
            //
            if (pContext->IsCanceled() && !pContext->IsCanceledContext())
                pTaskCollection->_Cancel();
        }
        catch(...)
        {
            //
            // Track the exception that was thrown here.  _RaisedException makes the decision on what
            // exceptions to keep and what to discard.  The flags it sets will indicate to the thread calling ::Wait that it must rethrow.
            //
            pTaskCollection->_RaisedException();
            pTaskCollection->_Cancel();
        }

        pOriginContext->RemoveStealer(pContext);

        pContext->ClearCancel();
        pContext->SetRootCollection(NULL);
        pChore->_M_pTaskCollection = NULL;
        pTaskCollection->_CountUp();
    }

    /// <summary>
    ///     Wrapper around execution of an ustructured chore that performs appropriate notification
    ///     and exception handling semantics.
    /// </summary>
    __declspec(noinline)
    void __cdecl _UnrealizedChore::_UnstructuredChoreWrapper(_UnrealizedChore * pChore)
    {
        // assuming a task collection ctor has already been called

        InternalContextBase *pContext = static_cast<InternalContextBase *> (SchedulerBase::FastCurrentContext());
        ASSERT(pContext != NULL && !pContext->IsCanceled());

        _TaskCollection* pTaskCollection = static_cast<_TaskCollection *> (pChore->_M_pTaskCollection);
        ContextBase *pOriginContext = reinterpret_cast <ContextBase *> (pTaskCollection->_M_pOwningContext);

        pContext->SetRootCollection(pTaskCollection);

        //
        // pOriginContext is only safe to touch if the act of stealing from a non-detached context put a hold on that context
        // to block deletion until we are chained for cancellation.
        //
        SafeRWList<ListEntry> *pList = reinterpret_cast<SafeRWList<ListEntry> *> (pTaskCollection->_M_stealTracker);
        _ASSERTE(sizeof(pTaskCollection->_M_stealTracker) >= sizeof(*pList));


        if (pChore->_M_fDetached)
        {
            //
            // We cannot touch the owning context -- it was detached as of the steal.  The chain goes onto the task collection.
            //
            pContext->NotifyTaskCollectionChainedStealer();
            pList->AddTail(&(pContext->m_stealChain));
        }
        else
        {
            pList->AcquireWrite();
            pTaskCollection->_M_activeStealersForCancellation++;
            pList->ReleaseWrite();
            pOriginContext->AddStealer(pContext, true);
        }

        //
        // Waiting on the indirect alias may throw (e.g.: the entire context may have been canceled).  If it
        // throws, we need to deal with appropriate marshaling.
        //
        try
        {
            //
            // Set up an indirect alias for this task collection.  Any usage of the original task collection
            // within this stolen chore will automatically redirect through the indirect alias.  This allows
            // preservation of single-threaded semantics within the task collection while allowing it to be "accessed"
            // from stolen chores (multiple threads).
            //
            // This stack based collection will wait on stolen chores at destruction time.  In the event the collection is not
            // used during the steal, this doesn't do much.
            //
            _TaskCollection indirectAlias(pTaskCollection, false);

            pContext->SetIndirectAlias(&indirectAlias);

            try
            {
                //
                // We need to consider this a possible interruption point.  It's entirely possible that we stole and raced with a
                // cancellation thread.  The collection was canceled after we stole(e.g.: removed from the WSQ) but before we added ourselves 
                // to the stealing chain list above.  In this case, the entire context will wait until completion (bad).  Immediately
                // after we go on the list (a memory barrier), we need to check the collection cancellation flag.  If the collection is going away,
                // we need to get out *NOW* otherwise the entire subtree executes.
                //
                if (pTaskCollection->_M_pOriginalCollection->_M_exitCode != 0 ||
                    (pTaskCollection->_M_executionStatus != TASKCOLLECTION_EXECUTION_STATUS_CLEAR &&
                    pTaskCollection->_M_executionStatus != TASKCOLLECTION_EXECUTION_STATUS_INLINE &&
                    pTaskCollection->_M_executionStatus != TASKCOLLECTION_EXECUTION_STATUS_INLINE_WAIT_WITH_OVERFLOW_STACK)) 
                    throw task_canceled();

                pChore->m_pFunction(pChore);
            }
            catch(const task_canceled &)
            {
                //
                // If someone manually threw the task_canceled exception, we will have a cancel count but not a canceled context.  This
                // means we need to apply the cancel one level up.  Normally, the act of throwing would do that via being caught in the 
                // wait, but this is special "marshaling" for task_canceled.
                //
                if (pContext->IsCanceled() && !pContext->IsCanceledContext())
                    pTaskCollection->_Cancel();
            }
            catch(...)
            {
                //
                // Track the exception that was thrown here and subsequently cancel all work.  _RaisedException makes the decision on what
                // exceptions to keep and what to discard.  The flags it sets will indicate to the thread calling ::Wait that it must rethrow.
                //
                pTaskCollection->_RaisedException();
                pTaskCollection->_Cancel();
            }

            indirectAlias._Wait();
        }
        catch(const task_canceled &)
        {
            //
            // If someone manually threw the task canceled exception out of a task on the indirect alias, the same thing applies as to
            // a directly stolen chore (above).
            //
            if (pContext->IsCanceled() && !pContext->IsCanceledContext())
                pTaskCollection->_Cancel();
        }
        catch(...)
        {
            //
            // Track the exception that was thrown here and subsequently cancel all work.  _RaisedException makes the decision on what
            // exceptions to keep and what to discard.  The flags it sets will indicate to the thread calling ::Wait that it must rethrow.
            //
            pTaskCollection->_RaisedException();
            pTaskCollection->_Cancel();
        }

        pContext->SetIndirectAlias(NULL);

        if ( !pChore->_M_fDetached)
        {
            //
            // pOriginContext may die at any point (detachment).  When it does, it will transfer the stolen chore trace from the context to the
            // given task collection (us) under lock.  We can, therefore, take this lock and check if we are still okay to check the context.
            //
            pList->AcquireWrite();

            if (pContext->IsContextChainedStealer())
                pOriginContext->RemoveStealer(pContext);
            else
                pList->UnlockedRemove(&(pContext->m_stealChain));

            pTaskCollection->_M_activeStealersForCancellation--;
            
            pList->ReleaseWrite();

        } 
        else
        {
            pList->Remove(&(pContext->m_stealChain));
        }

        pContext->ClearCancel();
        pContext->ClearAliasTable();
        pContext->SetRootCollection(NULL);
        pChore->_M_pTaskCollection = NULL;

        //
        // This must come prior to the count-up.  If it's stack allocated, the countup will cause unwinding.
        //
        _UnrealizedChore::_InternalFree(pChore);

        pTaskCollection->_NotifyCompletedChore();
    }
} // namespace details

} // namespace Concurrency
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\chsize.c ===
/***
*chsize.c - change size of a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the _chsize() function - changes the size of a file.
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <dbgint.h>
#include <fcntl.h>
#include <msdos.h>
#include <io.h>
#include <string.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>

/***
*erccode _chsize_s(filedes, size) - change size of a file
*
*Purpose:
*       Change file size. Assume file is open for writing, or we can't do it.
*       The DOS way to do this is to go to the right spot and write 0 bytes. The
*       Xenix way to do this is to make a system call. We write '\0' bytes because
*       DOS won't do this for you if you lseek beyond eof, though Xenix will.
*
*Entry:
*       int filedes - file handle to change size of
*       __int64 size - new size of file
*
*Exit:
*       return 0 if successful
*       returns errno_t on failure
*
*Exceptions:
*
*******************************************************************************/

/* define normal version that locks/unlocks, validates fh */

errno_t __cdecl _chsize_s (
        REG1 int filedes,
        __int64 size
        )
{
        int r;                          /* return value */

        _CHECK_FH_CLEAR_OSSERR_RETURN_ERRCODE( filedes, EBADF );
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((_osfile(filedes) & FOPEN), EBADF);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((size >= 0), EINVAL);

        _lock_fh(filedes);

        __try {
                if ( _osfile(filedes) & FOPEN )
                        r = _chsize_nolock(filedes,size);
                else {
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                        r = errno = EBADF;
                }
        }
        __finally {
                _unlock_fh(filedes);
        }

        return r;
}

/* now define version that doesn't lock/unlock, validate fh */
errno_t __cdecl _chsize_nolock (
        REG1 int filedes,
        __int64 size
        )
{
        __int64 filend;
        __int64 extend;
        __int64 place;
        int cnt;
        int oldmode;
        __int64 retval = 0; /* assume good return */
        errno_t err = 0;

                /* Get current file position and seek to end */
        if ( ((place = _lseeki64_nolock(filedes, 0i64, SEEK_CUR)) == -1i64) ||
             ((filend = _lseeki64_nolock(filedes, 0i64, SEEK_END)) == -1i64) )
            return errno;

        extend = size - filend;

        /* Grow or shrink the file as necessary */

        if (extend > 0i64) {

            /* extending the file */
            char *bl = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, _INTERNAL_BUFSIZ);

            if (!bl) {
                err = errno = ENOMEM;
                retval= -1i64;
            } else {
                oldmode = _setmode_nolock(filedes, _O_BINARY);

                /* pad out with nulls */
                do  {
                    cnt = (extend >= (__int64)_INTERNAL_BUFSIZ ) ?
                          _INTERNAL_BUFSIZ : (int)extend;
                    if ( (cnt = _write_nolock( filedes,
                                           bl,
                                           (extend >= (__int64)_INTERNAL_BUFSIZ) ?
                                                _INTERNAL_BUFSIZ : (int)extend ))
                         == -1 )
                    {
                        /* Error on write */
                        if (_doserrno == ERROR_ACCESS_DENIED)
                            err = errno = EACCES;

                        retval = cnt;
                        break;  /* leave write loop */
                    }
                }
                while ((extend -= (__int64)cnt) > 0i64);

                _setmode_nolock(filedes, oldmode);

                HeapFree(GetProcessHeap(), 0, bl);
            }

            /* retval set correctly */
        }

        else  if ( extend < 0i64 ) {
            /* shortening the file */

            /*
             * Set file pointer to new eof...and truncate it there.
             */
            retval = _lseeki64_nolock(filedes, size, SEEK_SET);


            if(retval != -1i64)
            {
                if ( (retval = SetEndOfFile((HANDLE)_get_osfhandle(filedes)) ?
                     0 : -1) == -1 )
                {
                    err = errno = EACCES;
                    _doserrno = GetLastError();
                }
            }
        }

        /* else */
        /* no file change needed */
        /* retval = 0; */


/* Common return code */

        if(retval == -1 || (_lseeki64_nolock(filedes, place, SEEK_SET) == -1i64))
        {
            return errno;
        }

        return 0;
}

/***
*int _chsize(filedes, size) - change size of a file
*
*Purpose:
*       Change file size. Assume file is open for writing, or we can't do it.
*       The DOS way to do this is to go to the right spot and write 0 bytes. The
*       Xenix way to do this is to make a system call. We write '\0' bytes because
*       DOS won't do this for you if you lseek beyond eof, though Xenix will.
*
*Entry:
*       int filedes - file handle to change size of
*       long size - new size of file
*
*Exit:
*       return 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _chsize (
        REG1 int filedes,
        long size
        )
{
    errno_t e;
    e = _chsize_s(filedes, (__int64)size) ;

    return e == 0 ? 0 : -1 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\clearerr.c ===
/***
*clearerr.c - clear error and eof flags
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines clearerr() - clear error and eof flags from a stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <mtdll.h>
#include <internal.h>
#include <msdos.h>

/***
*errno_t clearerr(stream) - clear error and eof flags on a stream
*
*Purpose:
*       Resets the error and eof indicators for a stream to 0
*
*Entry:
*       FILE *stream - stream to set indicators on
*
*Exit:
*       0 on success, Otherwise error code
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl clearerr_s (FILE * stream)
{
        _VALIDATE_RETURN_ERRCODE((stream != NULL), EINVAL);

        _lock_str(stream);
        __try {
            /* Clear stdio level flags */
            stream->_flag &= ~(_IOERR|_IOEOF);

            /* Clear lowio level flags */

            _osfile_safe(_fileno(stream)) &= ~(FEOFLAG);
        }
        __finally {
            _unlock_str(stream);
        }

    return 0;
}

/***
*void clearerr(stream) - clear error and eof flags on a stream
*
*Purpose:
*       Resets the error and eof indicators for a stream to 0
*
*Entry:
*       FILE *stream - stream to set indicators on
*
*Exit:
*       No return value.
*       changes the _flag field of the FILE struct.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl clearerr (
        FILE *stream
        )
{
    clearerr_s(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cin.cpp ===
// cin -- initialize standard input stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)
static std::_Init_locks  initlocks;

_STD_BEGIN
		// OBJECT DECLARATIONS

__PURE_APPDOMAIN_GLOBAL static filebuf fin(_cpp_stdin);
#if defined(_M_CEE_PURE)
__PURE_APPDOMAIN_GLOBAL extern istream cin(&fin);
#else
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 istream cin(&fin);
#endif

		// INITIALIZATION CODE
struct _Init_cin
	{	// ensures that cin is initialized
	__CLR_OR_THIS_CALL _Init_cin()
		{	// initialize cin
		_Ptr_cin = &cin;
		cin.tie(_Ptr_cout);
		}
	};
__PURE_APPDOMAIN_GLOBAL static _Init_cin init_cin;

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\clog.cpp ===
// clog -- initialize standard log stream
#include <fstream>
#include <iostream>

#ifndef MRTDLL
#pragma warning(disable: 4074)
#pragma init_seg(compiler)
static std::_Init_locks  initlocks;
#endif

_STD_BEGIN
		// OBJECT DECLARATIONS

__PURE_APPDOMAIN_GLOBAL static filebuf flog(_cpp_stderr);
#if defined(_M_CEE_PURE)
__PURE_APPDOMAIN_GLOBAL extern ostream clog(&flog);
#else
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream clog(&flog);
#endif

		// INITIALIZATION CODE
struct _Init_clog
	{	// ensures that clog is initialized
	__CLR_OR_THIS_CALL _Init_clog()
		{	// initialize clog
		_Ptr_clog = &clog;
		clog.tie(_Ptr_cout);
		}
	};
__PURE_APPDOMAIN_GLOBAL static _Init_clog init_clog;

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cinitexe.c ===
/***
*cinitexe.c - C Run-Time Startup Initialization
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Do C++ initialization segment declarations for the EXE in CRT DLL
*       model
*
*Notes:
*       The C++ initializers will exist in the user EXE's data segment
*       so the special segments to contain them must be in the user EXE.
*
*******************************************************************************/

#include <stdio.h>
#include <internal.h>
#include <sect_attribs.h>

_CRTALLOC(".CRT$XIA") _PVFV __xi_a[] = { NULL };

_CRTALLOC(".CRT$XIZ") _PVFV __xi_z[] = { NULL };

_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };

_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };


#pragma comment(linker, "/merge:.CRT=.rdata")

#pragma comment(linker, "/defaultlib:kernel32.lib")

#pragma comment(linker, "/disallowlib:libcmt.lib")
#pragma comment(linker, "/disallowlib:libcmtd.lib")
#ifdef _DEBUG
#pragma comment(linker, "/disallowlib:msvcrt.lib")
#else  /* _DEBUG */
#pragma comment(linker, "/disallowlib:msvcrtd.lib")
#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\close.c ===
/***
*close.c - close file handle for Windows NT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _close() - close a file handle
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <io.h>
#include <mtdll.h>
#include <errno.h>
#include <stdlib.h>
#include <msdos.h>
#include <internal.h>

/***
*int _close(fh) - close a file handle
*
*Purpose:
*       Closes the file associated with the file handle fh.
*
*Entry:
*       int fh - file handle to close
*
*Exit:
*       returns 0 if successful, -1 (and sets errno) if fails
*
*Exceptions:
*
*******************************************************************************/

/* define normal version that locks/unlocks, validates fh */

int __cdecl _close (
        int fh
        )
{
        int r;                          /* return value */

        /* validate file handle */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        _lock_fh(fh);                   /* lock file */

        __try {
                if ( _osfile(fh) & FOPEN )
                        r = _close_nolock(fh);
                else {
                        errno = EBADF;
                        r = -1;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                _unlock_fh(fh);         /* unlock the file */
        }

        return r;
}

/* now define version that doesn't lock/unlock, validate fh */
int __cdecl _close_nolock (
        int fh
        )
{
        DWORD dosretval;

                /*
         * Close the underlying OS file handle. Special cases:
         *      1. If _get_osfhandle(fh) is INVALID_HANDLE_VALUE, don't try
         *         to actually close it. Just reset the lowio info so the
         *         handle can be reused. The standard handles are setup like
         *         this in Windows app, or a background app.
         *      2. If fh is STDOUT or STDERR, and if STDOUT and STDERR are
         *         mapped to the same OS file handle, skip the CloseHandle
         *         is skipped (without error). STDOUT and STDERR are the only
         *         handles for which this support is provided. Other handles
         *         are mapped to the same OS file handle only at the
         *         programmer's risk.
         */

        if ( (_get_osfhandle(fh) == (intptr_t)INVALID_HANDLE_VALUE) ||
             (((fh == 1 && (_osfile(2) & FOPEN)) ||
               (fh == 2 && (_osfile(1) & FOPEN))) &&
              (_get_osfhandle(1) == _get_osfhandle(2)) ) ||
             CloseHandle( (HANDLE)_get_osfhandle(fh) ) )
        {

                dosretval = 0L;
        }
        else
                dosretval = GetLastError();

        _free_osfhnd(fh);

        _osfile(fh) = 0;                /* clear file flags */

        if (dosretval) {
                /* OS error */
                _dosmaperr(dosretval);
                return -1;
        }

        return 0;                       /* good return */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\clock.c ===
/***
*clock.c - Contains the clock runtime
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The clock routine calculates the amount of elapsed time
*       since the current process was started.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <time.h>

#include <internal.h>
#include <sys\timeb.h>
#include <sys\types.h>



int __cdecl __inittime(void);

_CRTALLOC(".CRT$XIC") static _PIFV pinit = __inittime;

static unsigned __int64 start_tics;

/***
*clock_t clock() - Return the processor time used by this process.
*
*Purpose:
*       This routine calculates the amount of elapsed time
*       since the current process was started.
*       At startup time, startup calls __inittime which stores
*       the initial time.  The clock routine calculates the difference
*       between the current time and the initial time.
*
*       Clock must reference _cinitime so that _cinitim.asm gets linked in.
*       That routine, in turn, puts __inittime in the startup initialization
*       routine table.
*
*Entry:
*       No parameters.
*       itime is a static structure of type timeb.
*
*Exit:
*       If successful, clock returns the number of CLK_TCKs (milliseconds)
*       that have elapsed.  If unsuccessful, clock returns -1.
*
*Exceptions:
*       None.
*
*******************************************************************************/

clock_t __cdecl clock (
        void
        )
{
        unsigned __int64 current_tics;
        FILETIME ct;

        GetSystemTimeAsFileTime( &ct );

        current_tics = (unsigned __int64)ct.dwLowDateTime +
                       (((unsigned __int64)ct.dwHighDateTime) << 32);

        /* calculate the elapsed number of 100 nanosecond units */
        current_tics -= start_tics;

        /* return number of elapsed milliseconds */
        return (clock_t)(current_tics / 10000);
}

/***
*int __inittime() - Initialize the time location
*
*Purpose:
*       This routine stores the time of the process startup.
*       It is only linked in if the user issues a clock runtime call.
*
*Entry:
*       No arguments.
*
*Exit:
*       Returns 0 to indicate no error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl __inittime (
        void
        )
{
        FILETIME st;

        GetSystemTimeAsFileTime( &st );

        start_tics = (unsigned __int64)st.dwLowDateTime +
                     (((unsigned __int64)st.dwHighDateTime) << 32);

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\closeall.c ===
/***
*closeall.c - close all open files
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fcloseall() - closes all open files except stdin, stdout
*       stdprn, stderr, and stdaux.
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>


/***
*int _fcloseall() - close all open streams
*
*Purpose:
*       Closes all streams currently open except for stdin/out/err/aux/prn.
*       tmpfile() files are among those closed.
*
*Entry:
*       None.
*
*Exit:
*       returns number of streams closed if OK
*       returns EOF if fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fcloseall (
        void
        )
{
        REG2 int count = 0;
        REG1 i;

        _mlock(_IOB_SCAN_LOCK);
        __try {
            for ( i = 3 ; i < _nstream ; i++ ) {
                if ( __piob[i] != NULL ) {
                    /*
                     * if the stream is in use, close it
                     */
                    if ( inuse( (FILE *)__piob[i] ) && (fclose( __piob[i] ) !=
                             EOF) )
                        count++;

                    /*
                     * if stream is part of a _FILEX we allocated, free it.
                     */
                    if ( i >= _IOB_ENTRIES ) {
                        DeleteCriticalSection( &(((_FILEX *)__piob[i])->lock) );
                        _free_crt( __piob[i] );
                        __piob[i] = NULL;
                    }
                }
            }
        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }

        return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cmiscdat.c ===
/***
*cmiscdat.c - miscellaneous C run-time data
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Includes floating point conversion table (for C float output).
*
*       When floating point I/O conversions are done, but no floating-point
*       variables or expressions are used in the C program, we use the
*       _cfltcvt_tab[] to map these cases to the _fptrap entry point,
*       which prints "floating point not loaded" and dies.
*
*       This table is initialized to six copies of _fptrap by default.
*       If floating-point is linked in (_fltused), these table entries
*       are reset (see input.c, output.c, fltused.asm, and fltuseda.asm).
*
*******************************************************************************/

#if !defined (CRTDLL)

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <fltintrn.h>

/*-
 *  ... table of (model-dependent) code pointers ...
 *
 *  Entries all point to _fptrap by default,
 *  but are changed to point to the appropriate
 *  routine if the _fltused initializer (_cfltcvt_init)
 *  is linked in.
 *
 *  if the _fltused modules are linked in, then the
 *  _cfltcvt_init initializer sets the entries of
 *  _cfltcvt_tab.
-*/

PFV _cfltcvt_tab[10] = {
    _fptrap,    /*  _cfltcvt */
    _fptrap,    /*  _cropzeros */
    _fptrap,    /*  _fassign */
    _fptrap,    /*  _forcdecpt */
    _fptrap,    /*  _positive */
    _fptrap,    /*  _cldcvt */
    _fptrap,    /*  _cfltcvt_l */
    _fptrap,    /*  _fassign_l */
    _fptrap,    /*  _cropzeros_l */
    _fptrap     /*  _forcdecpt_l */
};

void __cdecl _initp_misc_cfltcvt_tab()
{
    int i;
    for (i = 0; i < _countof(_cfltcvt_tab); ++i)
    {
        _cfltcvt_tab[i] = (PFV) EncodePointer(_cfltcvt_tab[i]);
    }
}

#endif  /* !defined (CRTDLL) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\commode.c ===
/***
*commode.c - set global file commit mode to commit
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file commit mode flag to commit.  Linking with
*       this file sets all files to be opened in commit mode by default.
*
*******************************************************************************/

#define SPECIAL_CRTEXE

#include <cruntime.h>
#include <file2.h>
#include <internal.h>

/* set default file commit mode to commit */
int _commode = _IOCOMMIT;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\cmsgs.h ===
/***
*cmsgs.h - runtime errors
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The file defines, in one place, all error message strings used within
*       the C run-time library.
*
*       [Internal]
*
****/

#pragma once

#ifndef _INC_CMSGS
#define _INC_CMSGS

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/*
 * runtime error and termination messages
 */

#define EOL L"\r\n"

#define _RT_STACK_TXT      L"R6000" EOL L"- stack overflow" EOL

#define _RT_FLOAT_TXT      L"R6002" EOL L"- floating point support not loaded" EOL

#define _RT_INTDIV_TXT     L"R6003" EOL L"- integer divide by 0" EOL

#define _RT_SPACEARG_TXT   L"R6008" EOL L"- not enough space for arguments" EOL

#define _RT_SPACEENV_TXT   L"R6009" EOL L"- not enough space for environment" EOL

#define _RT_ABORT_TXT      L"R6010" EOL L"- abort() has been called" EOL

#define _RT_THREAD_TXT     L"R6016" EOL L"- not enough space for thread data" EOL

#define _RT_LOCK_TXT       L"R6017" EOL L"- unexpected multithread lock error" EOL

#define _RT_HEAP_TXT       L"R6018" EOL L"- unexpected heap error" EOL

#define _RT_OPENCON_TXT    L"R6019" EOL L"- unable to open console device" EOL

#define _RT_NONCONT_TXT    L"R6022" EOL L"- non-continuable exception" EOL

#define _RT_INVALDISP_TXT  L"R6023" EOL L"- invalid exception disposition" EOL

/*
 * _RT_ONEXIT_TXT is specific to Win32 and Dosx32 platforms
 */
#define _RT_ONEXIT_TXT     L"R6024" EOL L"- not enough space for _onexit/atexit table" EOL

#define _RT_PUREVIRT_TXT   L"R6025" EOL L"- pure virtual function call" EOL

#define _RT_STDIOINIT_TXT  L"R6026" EOL L"- not enough space for stdio initialization" EOL

#define _RT_LOWIOINIT_TXT  L"R6027" EOL L"- not enough space for lowio initialization" EOL

#define _RT_HEAPINIT_TXT   L"R6028" EOL L"- unable to initialize heap" EOL

#define _RT_CRT_NOTINIT_TXT L"R6030" EOL L"- CRT not initialized" EOL

#define _RT_CRT_INIT_CONFLICT_TXT L"R6031" EOL L"- Attempt to initialize the CRT more than once.\n" \
    L"This indicates a bug in your application." EOL

#define _RT_LOCALE_TXT L"R6032" EOL L"- not enough space for locale information" EOL

#define _RT_CRT_INIT_MANAGED_CONFLICT_TXT L"R6033" EOL L"- Attempt to use MSIL code from this assembly during native code initialization\n" \
    L"This indicates a bug in your application. It is most likely the result of calling an MSIL-compiled (/clr) function from a native constructor or from DllMain." EOL

/*
 * _RT_COOKIE_INIT_TXT is used directly as the argument to FatalAppExitW, since it is
 * used in __security_init_cookie when __crtMessageBox may not be available yet.
 */
#define _RT_COOKIE_INIT_TXT L"Microsoft Visual C++ Runtime Library, Error R6035 - " \
                            L"A module in this application is initializing the module's " \
                            L"global security cookie while a function relying on that " \
                            L"security cookie is active.  Call __security_init_cookie earlier."

/*
 * _RT_DOMAIN_TXT, _RT_SING_TXT and _RT_TLOSS_TXT are used by the floating
 * point library.
 */
#define _RT_DOMAIN_TXT     L"DOMAIN error" EOL

#define _RT_SING_TXT       L"SING error" EOL

#define _RT_TLOSS_TXT      L"TLOSS error" EOL


#define _RT_CRNL_TXT       EOL

#define _RT_BANNER_TXT     L"runtime error "


#endif  /* _INC_CMSGS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\crt\src\concrt.h ===
/***
* ==++==
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* concrt.h
*
* Main public header file for ConcRT. This is the only header file a C++ program should
* have to include in order to avail itself of the core concurrency runtime features.
*
* Agents and PPL live in separate headers.
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/

#pragma once

#include <crtdefs.h>

#if !(defined (_M_AMD64) || defined (_M_IX86))
    #error ERROR: Concurrency Runtime is supported only on X64 and X86 architectures.
#endif  /* !(defined (_M_AMD64) || defined (_M_IX86)) */

#if defined (_M_CEE)
    #error ERROR: Concurrency Runtime is not supported when compiling /clr.
#endif  /* defined (_M_CEE) */

#ifndef __cplusplus
    #error ERROR: Concurrency Runtime is supported only for C++.
#endif  /* __cplusplus */

#include <exception>
#include <sal.h>
#include <limits.h>
#include <crtdbg.h>
#include <guiddef.h>
#include <intrin.h>
#include <new>

#pragma pack(push,_CRT_PACKING)

// Forward declare structs needed from windows headers

struct _SECURITY_ATTRIBUTES;
typedef _SECURITY_ATTRIBUTES* LPSECURITY_ATTRIBUTES;

// Define essential types needed from windows headers

typedef unsigned long DWORD;
typedef long HRESULT;
typedef void * HANDLE;

// Undefine Yield that is possibly defined by windows.h, and _YieldProcessor just in case

#undef Yield
#undef _YieldProcessor

#define _YieldProcessor _mm_pause

// Make sure exchange pointer intrinsics work on x86

#if defined (_M_IX86)

#undef _InterlockedExchangePointer
#undef _InterlockedCompareExchangePointer

#define _InterlockedExchangePointer(_Target, _Value) reinterpret_cast<void *>(static_cast<__w64 long>(_InterlockedExchange( \
    static_cast<long volatile *>(reinterpret_cast<__w64 long volatile *>(static_cast<void * volatile *>(_Target))), \
    static_cast<long>(reinterpret_cast<__w64 long>(static_cast<void *>(_Value))))))

#define _InterlockedCompareExchangePointer(_Target, _Exchange, _Comparand) reinterpret_cast<void *>(static_cast<__w64 long>(_InterlockedCompareExchange( \
    static_cast<long volatile *>(reinterpret_cast<__w64 long volatile *>(static_cast<void * volatile *>(_Target))), \
    static_cast<long>(reinterpret_cast<__w64 long>(static_cast<void *>(_Exchange))), \
    static_cast<long>(reinterpret_cast<__w64 long>(static_cast<void *>(_Comparand))))))

#define _InterlockedIncrementSizeT(_Target) _InterlockedIncrement(reinterpret_cast<long volatile *>(_Target))
#define _InterlockedDecrementSizeT(_Target) _InterlockedDecrement(reinterpret_cast<long volatile *>(_Target))
#define _InterlockedCompareExchangeSizeT(_Target, _Exchange, _Comparand) _InterlockedCompareExchange( \
    reinterpret_cast<long volatile *>(_Target), \
    static_cast<long>(_Exchange), \
    static_cast<long>(_Comparand))

#else  /* defined (_M_IX86) */

#define _InterlockedIncrementSizeT(_Target) _InterlockedIncrement64(reinterpret_cast<__int64 volatile *>(_Target))
#define _InterlockedDecrementSizeT(_Target) _InterlockedDecrement64(reinterpret_cast<__int64 volatile *>(_Target))
#define _InterlockedCompareExchangeSizeT(_Target, _Exchange, _Comparand) _InterlockedCompareExchange64( \
    reinterpret_cast<__int64 volatile *>(_Target), \
    static_cast<__int64>(_Exchange), \
    static_cast<__int64>(_Comparand))

#endif  /* defined (_M_IX86) */

// Used internally to represent the smallest unit in which to allocate hidden types

typedef void * _CONCRT_BUFFER;

/// <summary>
///     The <c>Concurrency</c> namespace provides classes and functions that give you access to the Concurrency Runtime,
///     a concurrent programming framework for C++. For more information, see <see cref="Concurrency Runtime"/>.
/// </summary>
/**/
namespace Concurrency
{
/// <summary>
///     Pauses the current context for a specified amount of time.
/// </summary>
/// <param name="_Milliseconds">
///     The number of milliseconds that the current context should be paused for.  If the <paramref name="_Milliseconds"/> parameter is set to
///     the value <c>0</c>, it indicates that the current context should yield execution to other runnable contexts before continuing.
/// </param>
/// <remarks>
///     If this method is called on a Concurrency Runtime scheduler context, the scheduler will find a different context to run on the underlying
///     resource. Since the scheduler is cooperative in nature, this context may not resume exactly after the number of milliseconds specified.
///     If the scheduler is busy executing other tasks that do not cooperatively yield to the scheduler in a hurry, the wait period could be
///     indefinite.
/// </remarks>
/**/
_CRTIMP void __cdecl wait(unsigned int _Milliseconds);

/// <summary>
///     Allocates a block of memory of the size specified from the Concurrency Runtime's Caching Suballocator.
/// </summary>
/// <param name="_NumBytes">
///     The number of bytes of memory to allocate.
/// </param>
/// <returns>
///     A pointer to newly allocated memory.
/// </returns>
/// <remarks>
///     For more information on what scenarios in your application could benefit from using the Caching Suballocator,
///     see <see cref="Task Scheduler (Concurrency Runtime)"/>.
/// </remarks>
/// <seealso cref="Concurrency::Free Function"/>
/**/
_CRTIMP void * __cdecl Alloc(size_t _NumBytes);

/// <summary>
///     Frees a block of memory previously allocated by the <c>Alloc</c> method to the Concurrency Runtime's Caching Suballocator.
/// </summary>
/// <param name="_PAllocation">
///     A pointer to memory previously allocated by the <c>Alloc</c> method which is to be freed. If the parameter <paramref name="_PAllocation"/>
///     is set to the value <c>NULL</c>, this method will ignore it and return immediately.
/// </param>
/// <remarks>
///     For more information on what scenarios in your application could benefit from using the Caching Suballocator,
///     see <see cref="Task Scheduler (Concurrency Runtime)"/>.
/// </remarks>
/// <seealso cref="Concurrency::Alloc Function"/>
/**/
_CRTIMP void __cdecl Free(void * _PAllocation);

/// <summary>
///     Concurrency::details contains definitions of support routines in the public namespaces and some macros.
///     Users should not directly interact with this internal namespace.
/// </summary>
/**/
namespace details
{
    //
    // Forward declarations:
    //
    class ContextBase;
    class _TaskCollectionBase;

    //
    // A utility to hide operator delete from certain objects while still allowing the runtime to delete them internally.
    //
    template<class _T>
    void _InternalDeleteHelper(_T * _PObject)
    {
        delete _PObject;
    }

    // This class's purpose is solely to direct allocations of ConcRT classes
    // through a single point, using internal allocator.
    struct _AllocBase
    {
        // Standard operator new
        void * operator new(size_t _Size)
        {
            return Concurrency::Alloc(_Size);
        }

        // Standard operator delete
        void operator delete(void * _Ptr) throw()
        {
            Concurrency::Free(_Ptr);
        }

        // Standard operator new, no-throw version
        void * operator new(size_t _Size, const std::nothrow_t&) throw()
        {
            void * _Ptr;

            try
            {
                _Ptr = Concurrency::Alloc(_Size);
            }
            catch(...)
            {
                _Ptr = NULL;
            }

            return (_Ptr);
        }

        // Standard operator delete, no-throw version
        void operator delete(void * _Ptr, const std::nothrow_t&) throw()
        {
            operator delete(_Ptr);
        }

        // Standard operator new array
        void * operator new[](size_t _Size)
        {
            return operator new(_Size);
        }

        // Standard operator delete array
        void operator delete[](void * _Ptr) throw()
        {
            operator delete(_Ptr);
        }

        // Standard operator new array, no-throw version
        void * operator new[](size_t _Size, const std::nothrow_t& _No_throw) throw ()
        {
            return operator new(_Size, _No_throw);
        }

        // Standard operator delete array, no-throw version
        void operator delete[](void * _Ptr, const std::nothrow_t& _No_throw) throw()
        {
            operator delete(_Ptr, _No_throw);
        }

        // Standard operator new with void* placement
        void * operator new(size_t, void * _Location) throw()
        {
            return _Location;
        }

        // Standard operator delete with void* placement
        void operator delete(void *, void *) throw()
        {
        }

        // Standard operator new array with void* placement
        void * __cdecl operator new[](size_t, void * _Location) throw()
        {
            return _Location;
        }

        // Standard operator delete array with void* placement
        void __cdecl operator delete[](void *, void *) throw()
        {
        }
    };

    //
    // Wrappers for atomic access
    //
    template <size_t _Size>
    struct _Subatomic_impl { };

    template<>
    struct _Subatomic_impl<4> {
        template <typename _Ty>
        static void _StoreWithRelease(volatile _Ty& _Location, _Ty _Rhs) {
            _ReadWriteBarrier();
            _Location = _Rhs;
        }

        template <typename _Ty>
        static _Ty _LoadWithAquire(volatile _Ty& _Location) {
            _ReadWriteBarrier();
            return _Location;
        }

        template <typename _Ty>
        static _Ty _CompareAndSwap(volatile _Ty& _Location, _Ty _NewValue, _Ty _Comperand) {
            return (_Ty)_InterlockedCompareExchange((volatile long*)&_Location, (long)_NewValue, (long)_Comperand);
        }

        template <typename _Ty>
        static _Ty _FetchAndAdd(volatile _Ty& _Location, _Ty _Addend) {
            return (_Ty)_InterlockedExchangeAdd((volatile long*)&_Location, (long)_Addend);
        }

        template <typename _Ty>
        static _Ty _Increment(volatile _Ty& _Location) {
            return (_Ty)_InterlockedIncrement((volatile long*)&_Location);
        }

        template <typename _Ty>
        static _Ty _Decrement(volatile _Ty& _Location) {
            return (_Ty)_InterlockedDecrement((volatile long*)&_Location);
        }
    };

#if defined (_M_X64)
    template<>
    struct _Subatomic_impl<8> {
        template <typename _Ty>
        static void _StoreWithRelease(volatile _Ty& _Location, _Ty _Rhs) {
            _ReadWriteBarrier();
            _Location = _Rhs;
        }

        template <typename _Ty>
        static _Ty _LoadWithAquire(volatile _Ty& _Location) {
            _ReadWriteBarrier();
            return _Location;
        }

        template <typename _Ty>
        static _Ty _CompareAndSwap(volatile _Ty& _Location, _Ty _NewValue, _Ty _Comperand) {
            return (_Ty)_InterlockedCompareExchange64((volatile __int64*)&_Location, (__int64)_NewValue, (__int64)_Comperand);
        }

        template <typename _Ty>
        static _Ty _FetchAndAdd(volatile _Ty& _Location, _Ty _Addend) {
            return (_Ty)_InterlockedExchangeAdd64((volatile __int64*)&_Location, (__int64)_Addend);
        }

        template <typename _Ty>
        static _Ty _Increment(volatile _Ty& _Location) {
            return (_Ty)_InterlockedIncrement64((volatile __int64*)&_Location);
        }

        template <typename _Ty>
        static _Ty _Decrement(volatile _Ty& _Location) {
            return (_Ty)_InterlockedDecrement64((volatile __int64*)&_Location);
        }
    };
#endif  /* defined (_M_X64) */


    //
    // Wrapper for atomic access.  Only works for 4-byte or 8-byte types (e.g., int, long, long long, size_t, pointer).
    // Anything else will likely fail to compile.
    //
    template <typename _Ty>
    class _Subatomic {
    private:
        volatile _Ty _M_value;

    public:
        operator _Ty() const volatile {
            return _Subatomic_impl<sizeof(_Ty)>::_LoadWithAquire(_M_value);
        }

        _Ty operator=(_Ty _Rhs) {
            _Subatomic_impl<sizeof(_Ty)>::_StoreWithRelease(_M_value, _Rhs);
            return _Rhs;
        }

        _Ty _CompareAndSwap(_Ty _NewValue, _Ty _Comperand) {
            return _Subatomic_impl<sizeof(_Ty)>::_CompareAndSwap(_M_value, _NewValue, _Comperand);
        }

        _Ty _FetchAndAdd(_Ty _Addend) {
            return _Subatomic_impl<sizeof(_Ty)>::_FetchAndAdd(_M_value, _Addend);
        }

        _Ty operator++() {
            return _Subatomic_impl<sizeof(_Ty)>::_Increment(_M_value);
        }

        _Ty operator++(int) {
            return _Subatomic_impl<sizeof(_Ty)>::_Increment(_M_value) - 1;
        }

        _Ty operator--() {
            return _Subatomic_impl<sizeof(_Ty)>::_Decrement(_M_value);
        }

        _Ty operator--(int) {
            return _Subatomic_impl<sizeof(_Ty)>::_Decrement(_M_value) + 1;
        }

        _Ty operator+=(_Ty _Addend) {
            return _FetchAndAdd(_Addend) + _Addend;
        }
    };

    //
    // An RAII class that spin-waits on a "rented" flag.
    //
    class _SpinLock
    {
    private:
        volatile long& _M_flag;

    public:
        _CRTIMP _SpinLock(volatile long& _Flag);
        _CRTIMP ~_SpinLock();

    private:
        _SpinLock(const _SpinLock&);
        void operator=(const _SpinLock&);
    };

    //
    // A class that holds the count used for spinning and is dependent
    // on the number of hardware threads
    //
    struct _SpinCount
    {
        // Initializes the spinCount to either 0 or SPIN_COUNT, depending on
        // the number of hardware threads.
        static void __cdecl _Initialize();

        // Returns the current value of s_spinCount
        _CRTIMP static unsigned int __cdecl _Value();

        // The number of iterations used for spinning
        static unsigned int _S_spinCount;
    };

    /// <summary>
    ///     Default method for yielding during a spin wait
    /// </summary>
    /**/
    void _CRTIMP __cdecl _UnderlyingYield();

    /// <summary>
    ///     Implements busy wait with no backoff
    /// </summary>
    /**/
    template<unsigned int _YieldCount = 1>
    class _CRTIMP _SpinWait
    {
    public:

        typedef void (__cdecl *_YieldFunction)();

        /// <summary>
        ///     Construct a spin wait object
        /// </summary>
        /**/
        _SpinWait(_YieldFunction _YieldMethod = _UnderlyingYield)
            : _M_yieldFunction(_YieldMethod), _M_state(_StateInitial)
        {
            // Defer initialization of other fields to _SpinOnce().
        }

        /// <summary>
        ///     Set a dynamic spin count.
        /// </summary>
        /**/
        void _SetSpinCount(unsigned int _Count)
        {
            _ASSERTE(_M_state == _StateInitial);
            if (_Count == 0)
            {
                // Specify a count of 0 if we are on a single proc.
                _M_state = _StateSingle;
            }
            else
            {
                _M_currentSpin = _Count;
                _M_currentYield = _YieldCount;
                _M_state = _StateSpin;
            }
        }

        /// <summary>
        ///     Spins for one time quantum,until a maximum spin is reached.
        /// </summary>
        /// <returns>
        ///     false if spin count has reached steady state, true otherwise.
        /// </returns>
        /// <remarks>
        ///     If the spin count is not changing that means that it is probably not a good idea to spin again
        ///     because there is either only one processor, or maximum spin has been reached and blocking is
        ///     probably a better solution. However, if called again, SpinOnce will spin for a maximum spin count.
        /// </remarks>
        /**/
        bool _SpinOnce()
        {
            switch (_M_state)
            {
            case _StateSpin:
            {
                unsigned long _Count = _NumberOfSpins();

                for (unsigned long _I = 0; _I < _Count; _I++)
                {
                    _YieldProcessor();
                }

                if (!_ShouldSpinAgain())
                {
                    _M_state = (_M_currentYield == 0) ? _StateBlock : _StateYield;
                }

                return true;
            }

            case _StateYield:
                _ASSERTE(_M_currentYield > 0);
                if (--_M_currentYield == 0)
                {
                    _M_state = _StateBlock;
                }

                // Execute the yield
                _DoYield();
                return true;

            case _StateBlock:
                // Reset to defaults if client does not block
                _Reset();
                return false;

            case _StateSingle:
                // No need to spin on a single processor: just execute the yield
                _DoYield();
                return false;

            case _StateInitial:
                // Reset counters to their default value and Spin once.
                _Reset();
                return _SpinOnce();
            default:
                // Unreached
                return false;
            };
        }

    protected:

        /// <summary>
        ///     State of the spin wait class.
        /// </summary>
        /**/
        enum _SpinState
        {
            _StateInitial,
            _StateSpin,
            _StateYield,
            _StateBlock,
            _StateSingle
        };

        /// <summary>
        ///     Yields its time slice using the specified yieldFunciton
        /// </summary>
        /**/
        void _DoYield()
        {
            bool _ShouldYield = (_YieldCount != 0);
            if (_ShouldYield)
            {
                _ASSERTE(_M_yieldFunction != NULL);
                _M_yieldFunction();
            }
            else
            {
                _YieldProcessor();
            }
        }

        /// <summary>
        ///     Resets the counts and state to the default.
        /// </summary>
        /**/
        void _Reset()
        {
            _M_state = _StateInitial;

            // Reset to the default spin value. The value specified
            // by the client is ignored on a reset.
            _SetSpinCount(_SpinCount::_Value());

            _ASSERTE(_M_state != _StateInitial);
        }

        /// <summary>
        ///     Determines the current spin count
        /// </summary>
        /// <returns>
        ///     The number of spins to execute for this iteration
        /// </returns>
        /**/
        unsigned long _NumberOfSpins()
        {
            return 1;
        }

        /// <summary>
        ///     Determines whether maximum spin has been reached
        /// </summary>
        /// <returns>
        ///     false if spin count has reached steady state, true otherwise.
        /// </returns>
        /**/
        bool _ShouldSpinAgain()
        {
            return (--_M_currentSpin > 0);
        }

        unsigned long  _M_currentSpin;
        unsigned long  _M_currentYield;
        _SpinState     _M_state;
        _YieldFunction _M_yieldFunction;
    };

    typedef _SpinWait<>   _SpinWaitBackoffNone;
    typedef _SpinWait<0>  _SpinWaitNoYield;

    //
    // This reentrant lock uses CRITICAL_SECTION and is intended for use when kernel blocking
    // is desirable and where it is either known that the lock will be taken recursively in
    // the same thread, or when it is just not known that a non-reentrant lock can be used safely.
    //
    class _ReentrantBlockingLock
    {
    public:
        // Constructor for _ReentrantBlockingLock
        _CRTIMP _ReentrantBlockingLock();

        // Destructor for _ReentrantBlockingLock
        _CRTIMP ~_ReentrantBlockingLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire();

        // Tries to acquire the lock, does not spin.
        // Returns true if the acquisition worked, false otherwise
        _CRTIMP bool _TryAcquire();

        // Releases the lock
        _CRTIMP void _Release();


        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            explicit _Scoped_lock(_ReentrantBlockingLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            // Destroys the holder and releases the lock
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _ReentrantBlockingLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        // Critical section requires windows.h. Hide the implementation so that
        // user code need not include windows.
        _CONCRT_BUFFER _M_criticalSection[(4 * sizeof(void *) + 2 * sizeof(long) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    };

    //
    // This reentrant lock is a pure spin lock and is intended for use when kernel blocking
    // is desirable and where it is either known that the lock will be taken recursively in
    // the same thread, or when it is just not known that a non-reentrant lock can be used safely.
    //
    class _ReentrantLock
    {
    public:
        // Constructor for _ReentrantLock
        _CRTIMP _ReentrantLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire();

        // Tries to acquire the lock, does not spin
        // Returns true if the acquisition worked, false otherwise
        _CRTIMP bool _TryAcquire();

        // Releases the lock
        _CRTIMP void _Release();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            explicit _Scoped_lock(_ReentrantLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            // Destroys the holder and releases the lock
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _ReentrantLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        long _M_recursionCount;
        volatile long _M_owner;
    };

    //
    // This non-reentrant lock uses CRITICAL_SECTION and is intended for use in situations
    // where it is known that the lock will not be taken recursively, and can thus be more
    // efficiently implemented.
    //
    class _NonReentrantBlockingLock
    {
    public:
        // Constructor for _NonReentrantBlockingLock
        //
        // The constructor is exported because of _NonReentrantLock's
        // inclusion in DevUnitTests.  It is also used in RM.
        _CRTIMP _NonReentrantBlockingLock();

        // Constructor for _NonReentrantBlockingLock
        _CRTIMP ~_NonReentrantBlockingLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire();

        // Tries to acquire the lock, does not spin
        // Returns true if the lock is taken, false otherwise
        _CRTIMP bool _TryAcquire();

        // Releases the lock
        _CRTIMP void _Release();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            explicit _Scoped_lock(_NonReentrantBlockingLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            // Destroys the holder and releases the lock
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _NonReentrantBlockingLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        // Critical section requires windows.h. Hide the implementation so that
        // user code need not include windows.h
        _CONCRT_BUFFER _M_criticalSection[(4 * sizeof(void *) + 2 * sizeof(long) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    };

    //
    // A Reader-Writer Lock is intended for use in situations with many readers and rare
    // writers.
    //
    // A writer request immediately blocks future readers and then waits until all current
    // readers drain.  A reader request does not block future writers and must wait until
    // all writers are done, even those that cut in front of it.  In any race between a
    // reader and a writer, the writer always wins.
    //
    class _ReaderWriterLock
    {
    public:
        // Constructor for _ReaderWriterLock
        //
        // The constructor and destructor are exported because of _ReaderWriterLock's
        // inclusion in DevUnitTests.  We may want to revisit whether we actually want
        // to export this in the future.
        _CRTIMP _ReaderWriterLock();

        // Acquire lock for reading.  Spins until all writers finish, new writers
        // can cut in front of a waiting reader.
        _CRTIMP void _AcquireRead();

        // Release lock for reading.  The last reader changes m_state to State.kFree
        _CRTIMP void _ReleaseRead();

        // Acquire lock for writing. Spin until no readers exist, then acquire lock
        // and prevent new readers.
        _CRTIMP void _AcquireWrite();

        // Release lock for writing.
        _CRTIMP void _ReleaseWrite();

        // Try to acquire the write lock, do not spin if unable to acquire.
        // Returns true if the acquisition worked, false otherwise
        _CRTIMP bool _TryAcquireWrite();

        // Returns true if it is in write state, false otherwise
        bool _HasWriteLock() const
        {
            return (_M_state == _Write);
        }

        // Guarantees that all writers are out of the lock.  This does nothing if there are no pending writers.
        void _FlushWriteOwners();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the writer lock
            explicit _Scoped_lock(_ReaderWriterLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._AcquireWrite();
            }

            // Destroys the holder and releases the writer lock
            ~_Scoped_lock()
            {
                _M_lock._ReleaseWrite();
            }

        private:

            _ReaderWriterLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

        // An exception safe RAII wrapper for reads.
        class _Scoped_lock_read
        {
        public:
            // Constructs a holder and acquires the reader lock
            explicit _Scoped_lock_read(_ReaderWriterLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._AcquireRead();
            }

            // Destroys the holder and releases the reader lock
            ~_Scoped_lock_read()
            {
                _M_lock._ReleaseRead();
            }

        private:

            _ReaderWriterLock& _M_lock;

            _Scoped_lock_read(const _Scoped_lock_read&);                    // no copy constructor
            _Scoped_lock_read const & operator=(const _Scoped_lock_read&);  // no assignment operator
        };

    private:
        // State enum where:
        // -1    --> write mode
        // 0     --> free
        // n > 0 --> n readers have locked in read mode.
        enum _State
        {
          _Write = -1,
          _Free  = 0,
          _Read  = 1
        };

        // The current state of the lock, mapping to the State enum.  This is also
        // an indicator of the number of readers holding the lock, for any number > 0.
        volatile long _M_state;

        // A writer increments this as soon as it wants to lock and decrements this
        // after releasing the lock. To prevent writers from starving, a reader will
        // wait until this counter is zero, and only then will try to obtain the lock.
        volatile long _M_numberOfWriters;

        // Spin-Wait-Until variant
        static void __cdecl _WaitEquals(volatile const long& _Location, long _Value, long _Mask = 0xFFFFFFFF);
    };

    //
    // An exception safe RAII wrapper for  _malloca()
    //
    class _MallocaHolder
    {
    public:

        _MallocaHolder(void *pMemory) : m_pMemory(pMemory)
        {
        }

        ~_MallocaHolder()
        {
            _freea(m_pMemory);
        }

    private:

        void *m_pMemory;
    };

    // Forward declarations
    class _StructuredTaskCollection;
    class _TaskCollection;
    class _UnrealizedChore;
} // namespace details

//**************************************************************************
// Public Namespace:
//
// Anything in the Concurrency namespace is intended for direct client consumption.
//
//**************************************************************************

//
// Forward declarations:
//
class Scheduler;

/// <summary>
///     This class describes an exception that is thrown due to failure to acquire a critical resource in the Concurrency Runtime.
/// </summary>
/// <remarks>
///     This exception is typically thrown when a call to the operating system from within the Concurrency Runtime
///     fails.  The error code which would normally be returned from a call to the Win32 method <c>GetLastError</c> is
///     converted to a value of type <c>HRESULT</c> and can be retrieved via the <c>get_error_code</c> method.
/// </remarks>
/**/
class scheduler_resource_allocation_error : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>scheduler_resource_allocation_error</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /// <param name="_Hresult">
    ///     The <c>HRESULT</c> value of the error that caused the exception.
    /// </param>
    /**/
    _CRTIMP scheduler_resource_allocation_error(const char * _Message, HRESULT _Hresult) throw();

    /// <summary>
    ///     Constructs a <c>scheduler_resource_allocation_error</c> object.
    /// </summary>
    /// <param name="_Hresult">
    ///     The <c>HRESULT</c> value of the error that caused the exception.
    /// </param>
    /**/
    explicit _CRTIMP scheduler_resource_allocation_error(HRESULT _Hresult) throw();

    /// <summary>
    ///     Returns the error code that caused the exception.
    /// </summary>
    /// <returns>
    ///     The <c>HRESULT</c> value of the error that caused the exception.
    /// </returns>
    /**/
    _CRTIMP HRESULT get_error_code() const throw();

private:
    HRESULT _Hresult;
};

/// <summary>
///     This class describes an exception that is thrown whenever an unsupported operating system is used.
///     The Concurrency Runtime does not support operating systems earlier than Windows XP with Service Pack 3.
/// </summary>
/**/
class unsupported_os  : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>unsupported_os</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP unsupported_os(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>unsupported_os</c> object.
    /// </summary>
    /**/
    _CRTIMP unsupported_os() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever an operation is performed which requires a scheduler
///     to be attached to the current context and one is not.
/// </summary>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Scheduler::Attach Method"/>
/**/
class scheduler_not_attached  : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>scheduler_not_attached</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP scheduler_not_attached(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>scheduler_not_attached</c> object.
    /// </summary>
    /**/
    _CRTIMP scheduler_not_attached() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>Attach</c> method is called on a <c>Scheduler</c>
///     object which is already attached to the current context.
/// </summary>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Scheduler::Attach Method"/>
/**/
class improper_scheduler_attach : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>improper_scheduler_attach</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP improper_scheduler_attach(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>improper_scheduler_attach</c> object.
    /// </summary>
    /**/
    _CRTIMP improper_scheduler_attach() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>CurrentScheduler::Detach</c> method is called on
///     a context which has not been attached to any scheduler via the <c>Attach</c> method of a <c>Scheduler</c> object.
/// </summary>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="CurrentScheduler::Detach Method"/>
/// <seealso cref="Scheduler::Attach Method"/>
/**/
class improper_scheduler_detach : public std::exception
{
public:

    /// <summary>
    ///     Constructs an <c>improper_scheduler_detach</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP improper_scheduler_detach(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>improper_scheduler_detach</c> object.
    /// </summary>
    /**/
    _CRTIMP improper_scheduler_detach() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>Reference</c> method is called on a <c>Scheduler</c>
///     object that is shutting down, from a context that is not part of that scheduler.
/// </summary>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Scheduler::Reference Method"/>
/**/
class improper_scheduler_reference : public std::exception
{
public:

    /// <summary>
    ///     Constructs an <c>improper_scheduler_reference</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP improper_scheduler_reference(const char* _Message) throw();

    /// <summary>
    ///     Constructs an <c>improper_scheduler_reference</c> object.
    /// </summary>
    /**/
    _CRTIMP improper_scheduler_reference() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>Scheduler::SetDefaultSchedulerPolicy</c> method is
///     called when a default scheduler already exists within the process.
/// </summary>
/// <seealso cref="Scheduler::SetDefaultSchedulerPolicy Method"/>
/**/
class default_scheduler_exists : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>default_scheduler_exists</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP default_scheduler_exists(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>default_scheduler_exists</c> object.
    /// </summary>
    /**/
    _CRTIMP default_scheduler_exists() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever calls to the <c>Block</c> and <c>Unblock</c> methods of a
///     <c>Context</c> object are not properly paired.
/// </summary>
/// <remarks>
///     Calls to the <c>Block</c> and <c>Unblock</c> methods of a <c>Context</c> object must always be properly paired.
///     The Concurrency Runtime allows the operations to happen in either order. For example, a call to <c>Block</c>
///     may followed by a call to <c>Unblock</c>, or vice-versa.  This exception would be thrown if, for instance, two calls to the
///     <c>Unblock</c> method were made in a row, on a <c>Context</c> object which was not blocked.
/// </remarks>
/// <seealso cref="Context Class"/>
/// <seealso cref="Context::Unblock Method"/>
/// <seealso cref="Context::Block Method"/>
/**/
class context_unblock_unbalanced : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>context_unblock_unbalanced</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP context_unblock_unbalanced(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>context_unblock_unbalanced</c> object.
    /// </summary>
    /**/
    _CRTIMP context_unblock_unbalanced() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>Unblock</c> method of a <c>Context</c> object is called
///     from the same context.  This would indicate an attempt by a given context to unblock itself.
/// </summary>
/// <seealso cref="Context Class"/>
/// <seealso cref="Context::Unblock Method"/>
/**/
class context_self_unblock : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>context_self_unblock</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP context_self_unblock(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>context_self_unblock</c> object.
    /// </summary>
    /**/
    _CRTIMP context_self_unblock() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever there are tasks still scheduled to a <c>task_group</c> or
///     <c>structured_task_group</c> object at the time that object's destructor executes.  This exception will never be thrown
///     if the destructor is reached due to stack unwinding as the result of an exception.
/// </summary>
/// <remarks>
///     Absent exception flow, you are responsible for calling either the <c>wait</c> or <c>run_and_wait</c> method of a <c>task_group</c> or
///     <c>structured_task_group</c> object before allowing that object to destruct.  The runtime throws this exception as an
///     indication that you forgot to call the <c>wait</c> or <c>run_and_wait</c> method.
/// </remarks>
/// <seealso cref="task_group Class"/>
/// <seealso cref="task_group::wait Method"/>
/// <seealso cref="task_group::run_and_wait Method"/>
/// <seealso cref="structured_task_group Class"/>
/// <seealso cref="structured_task_group::wait Method"/>
/// <seealso cref="structured_task_group::run_and_wait Method"/>
/**/
class missing_wait : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>missing_wait</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP missing_wait(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>missing_wait</c> object.
    /// </summary>
    /**/
    _CRTIMP missing_wait() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever a messaging block is given a pointer to a target which is
///     invalid for the operation being performed.
/// </summary>
/// <remarks>
///     This exception is typically thrown for reasons such as a target attempting to consume a message which is reserved
///     for a different target or releasing a reservation that it does not hold.
/// </remarks>
/// <seealso cref="Asynchronous Message Blocks"/>
/**/
class bad_target : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>bad_target</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP bad_target(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>bad_target</c> object.
    /// </summary>
    /**/
    _CRTIMP bad_target() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever a messaging block is unable to find a requested message.
/// </summary>
/// <seealso cref="Asynchronous Message Blocks"/>
/**/
class message_not_found : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>message_not_found</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP message_not_found(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>message_not_found</c> object.
    /// </summary>
    /**/
    _CRTIMP message_not_found() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever the <c>link_target</c> method of a messaging block is
///     called and the messaging block is unable to link to the target.  This may be the result of exceeding the number of
///     links the messaging block is allowed or attempting to link a specific target twice to the same source.
/// </summary>
/// <seealso cref="Asynchronous Message Blocks"/>
/**/
class invalid_link_target : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_link_target</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_link_target(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_link_target</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_link_target() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever an invalid or unknown key is passed to a <c>SchedulerPolicy</c>
///     object constructor, or the <c>SetPolicyValue</c> method of a <c>SchedulerPolicy</c> object is passed a key that must
///     be changed via other means such as the <c>SetConcurrencyLimits</c> method.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
/// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
/**/
class invalid_scheduler_policy_key : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_key</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_scheduler_policy_key(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_key</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_scheduler_policy_key() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever a policy key of a <c>SchedulerPolicy</c> object is
///     set to an invalid value for that key.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
/// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
/**/
class invalid_scheduler_policy_value : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_value</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_scheduler_policy_value(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_value</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_scheduler_policy_value() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever an attempt is made to set the concurrency limits of a
///     <c>SchedulerPolicy</c> object such that the value of the <c>MinConcurrency</c> key is less than the value of the
///     <c>MaxConcurrency</c> key.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
/**/
class invalid_scheduler_policy_thread_specification : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_value</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_scheduler_policy_thread_specification(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_scheduler_policy_value</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_scheduler_policy_thread_specification() throw();
};

/// <summary>
///     This class describes an exception that is thrown when an invalid operation is performed that is not more accurately
///     described by another exception type thrown by the Concurrency Runtime.
/// </summary>
/// <remarks>
///     The various methods which throw this exception will generally document under what circumstances they will throw it.
/// </remarks>
/**/
class invalid_operation : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_operation</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_operation(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_operation</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_operation() throw();
};

/// <summary>
///     This class describes an exception that is thrown when the Concurrency Runtime detects that you neglected to call the
///     <c>CurrentScheduler::Detach</c> method on a context that attached to a second scheduler via the <c>Attach</c> method
///     of the <c>Scheduler</c> object.
/// </summary>
/// <remarks>
///     This exception is only thrown when you nest one scheduler inside another by calling the <c>Attach</c> method of a
///     <c>Scheduler</c> object on a context that is already owned by or attached to another scheduler.  The Concurrency Runtime
///     throws this exception opportunistically when it can detect the scenario as an aid to locating the problem.  Not every
///     instance of neglecting to call the <c>CurrentScheduler::Detach</c> method is guaranteed to throw this exception.
/// </remarks>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="CurrentScheduler::Detach Method"/>
/// <seealso cref="Scheduler::Attach Method"/>
/**/
class nested_scheduler_missing_detach : public std::exception
{
public:
    /// <summary>
    ///     Constructs a <c>nested_scheduler_missing_detach</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP nested_scheduler_missing_detach(const char * _Message) throw();

    /// <summary>
    ///     Constructs a <c>nested_scheduler_missing_detach</c> object.
    /// </summary>
    /**/
    _CRTIMP nested_scheduler_missing_detach() throw();
};

/// <summary>
///     This class describes an exception that is thrown when an operation has timed out.
/// </summary>
/**/
class operation_timed_out : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>operation_timed_out</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP operation_timed_out(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>operation_timed_out</c> object.
    /// </summary>
    /**/
    _CRTIMP operation_timed_out() throw();
};

/// <summary>
///     This class describes an exception that is thrown when a <c>task_handle</c> object is scheduled multiple times
///     via the <c>run</c> method of a <c>task_group</c> or <c>structured_task_group</c> object without an intervening
///     call to either the <c>wait</c> or <c>run_and_wait</c> methods.
/// </summary>
/// <seealso cref="task_handle Class"/>
/// <seealso cref="task_group Class"/>
/// <seealso cref="task_group::run Method"/>
/// <seealso cref="task_group::wait Method"/>
/// <seealso cref="task_group::run_and_wait Method"/>
/// <seealso cref="structured_task_group Class"/>
/// <seealso cref="structured_task_group::run Method"/>
/// <seealso cref="structured_task_group::wait Method"/>
/// <seealso cref="structured_task_group::run_and_wait Method"/>
/**/
class invalid_multiple_scheduling : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_multiple_scheduling</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_multiple_scheduling(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_multiple_scheduling</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_multiple_scheduling() throw();
};

/// <summary>
///     This class describes an exception that is thrown when the <c>Context::Oversubscribe</c> method is called with
///     the <paramref name="_BeginOversubscription"/> parameter set to <c>false</c> without a prior call to the
///     <c>Context::Oversubscribe</c> method with the <paramref name="_BeginOversubscription"/> parameter set to <c>true</c>.
/// </summary>
/// <seealso cref="Context::Oversubscribe Method"/>
/**/
class invalid_oversubscribe_operation : public std::exception
{
public:
    /// <summary>
    ///     Constructs an <c>invalid_oversubscribe_operation</c> object.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP invalid_oversubscribe_operation(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>invalid_oversubscribe_operation</c> object.
    /// </summary>
    /**/
    _CRTIMP invalid_oversubscribe_operation() throw();
};

/// <summary>
///     This class describes an exception that is thrown whenever a lock is acquired improperly.
/// </summary>
/// <remarks>
///     Typically, this exception is thrown when an attempt is made to acquire a non-reentrant lock
///     recursively on the same context.
/// </remarks>
/// <seealso cref="critical_section Class"/>
/// <seealso cref="reader_writer_lock Class"/>
/**/
class improper_lock : public std::exception
{
public:

    /// <summary>
    ///     Constructs an <c>improper_lock exception</c>.
    /// </summary>
    /// <param name="_Message">
    ///     A descriptive message of the error.
    /// </param>
    /**/
    explicit _CRTIMP improper_lock(const char * _Message) throw();

    /// <summary>
    ///     Constructs an <c>improper_lock</c> exception.
    /// </summary>
    /**/
    _CRTIMP improper_lock() throw();
};

/// <summary>
///     An elementary abstraction for a task, defined as <c>void (__cdecl * TaskProc)(void *)</c>. A <c>TaskProc</c> is called to
///     invoke the body of a task.
/// </summary>
/**/
typedef void (__cdecl * TaskProc)(void *);

/// <summary>
///     Represents an abstraction for a schedule group.  Schedule groups organize a set of related work that benefits from being
///     scheduled close together either temporally, by executing another task in the same group before moving to another group, or
///     spatially, by executing multiple items within the same group on the same NUMA node or physical socket.
/// </summary>
/// <seealso cref="CurrentScheduler Class"/>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class ScheduleGroup
{
public:

    /// <summary>
    ///     Schedules a light-weight task within the schedule group.
    /// </summary>
    /// <param name="_Proc">
    ///     A pointer to the function to execute to perform the body of the light-weight task.
    /// </param>
    /// <param name="_Data">
    ///     A void pointer to the data that will be passed as a parameter to the body of the task.
    /// </param>
    /// <remarks>
    ///     Calling the <c>ScheduleTask</c> method implicitly places a reference count on the schedule group which is removed by the runtime
    ///     at an appropriate time after the task executes.
    /// </remarks>
    /// <seealso cref="ScheduleGroup::Reference Method"/>
    /**/
    virtual void ScheduleTask(TaskProc _Proc, void * _Data) =0;

    /// <summary>
    ///     Returns an identifier for the schedule group that is unique within the scheduler to which the group belongs.
    /// </summary>
    /// <returns>
    ///     An identifier for the schedule group that is unique within the scheduler to which the group belongs.
    /// </returns>
    /**/
    virtual unsigned int Id() const =0;

    /// <summary>
    ///     Increments the schedule group's reference count.
    /// </summary>
    /// <returns>
    ///     The newly incremented reference count.
    /// </returns>
    /// <remarks>
    ///     This is typically used to manage the lifetime of the schedule group for composition.  When the reference count of a schedule
    ///     group falls to zero, the schedule group is deleted by the runtime. A schedule group created using either the
    ///     <see cref="CurrentScheduler::CreateScheduleGroup Method">CurrentScheduler::CreateScheduleGroup</see> method, or the
    ///     <see cref="Scheduler::CreateScheduleGroup Method">Scheduler::CreateScheduleGroup</see> method starts out with a reference
    ///     count of one.
    /// </remarks>
    /// <seealso cref="ScheduleGroup::Release Method"/>
    /// <seealso cref="CurrentScheduler::CreateScheduleGroup Method"/>
    /// <seealso cref="Scheduler::CreateScheduleGroup Method"/>
    /**/
    virtual unsigned int Reference() =0;

    /// <summary>
    ///     Decrements this scheduler group's reference count.
    /// </summary>
    /// <returns>
    ///     The newly decremented reference count.
    /// </returns>
    /// <remarks>
    ///     This is typically used to manage the lifetime of the schedule group for composition.  When the reference count of a schedule
    ///     group falls to zero, the schedule group is deleted by the runtime.  Once you have called the <c>Release</c> method the specific number
    ///     of times to remove the creation reference count and any additional references placed via the <c>Reference</c> method, you may not
    ///     utilize the schedule group further.  Doing so will result in undefined behavior.
    ///     <para>A schedule group is associated with a particular scheduler instance.  You must ensure that all references to the
    ///     schedule group are released before all references to the scheduler are released, since the latter could result in the scheduler
    ///     being destroyed.  Doing otherwise results in undefined behavior.</para>
    /// </remarks>
    /// <seealso cref="ScheduleGroup::Reference Method"/>
    /// <seealso cref="CurrentScheduler::CreateScheduleGroup Method"/>
    /// <seealso cref="Scheduler::CreateScheduleGroup Method"/>
    /**/
    virtual unsigned int Release() =0;

protected:

    //
    // Privatize operator delete.  Clients should utilize Release to relinquish a schedule group.
    //
    template<class _T> friend void Concurrency::details::_InternalDeleteHelper(_T * _PObject);

    /// <summary>
    ///     A <c>ScheduleGroup</c> object is destroyed internally by the runtime when all external references to it are released.
    ///     It may not be explicitly deleted.
    /// </summary>
    /// <param name="_PObject">
    ///     A pointer to the object to be deleted.
    /// </param>
    /**/
    void operator delete(void * _PObject)
    {
        ::operator delete(_PObject);
    }
};

/// <summary>
///     Special value for the policy keys <c>MinConcurrency</c> and <c>MaxConcurrency</c>.  Defaults to the number of hardware
///     threads on the machine in the absence of other constraints.
/// </summary>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
const unsigned int MaxExecutionResources = 0xFFFFFFFF;

/// <summary>
///     Special value for the policy key <c>ContextPriority</c> indicating that the thread priority of all contexts in the scheduler
///     should be the same as that of the thread which created the scheduler.
/// </summary>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
const unsigned int INHERIT_THREAD_PRIORITY = 0x0000F000;

/// <summary>
///     Policy keys describing aspects of scheduler behavior.  Each policy element is described by a key-value pair.  For more information
///     about scheduler policies and their impact on schedulers, see <see cref="Task Scheduler (Concurrency Runtime)"/>.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="CurrentScheduler Class"/>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
enum PolicyElementKey
{
    /// <summary>
    ///     The type of threads that the scheduler will utilize for underlying execution contexts.  For more information, see
    ///     <see cref="SchedulerType Enumeration"/>.
    ///     <para>Valid values  : A member of the <c>SchedulerType</c> enumeration, either <c>ThreadScheduler</c> or <c>UmsThreadDefault</c></para>
    ///     <para>Default value : <c>ThreadScheduler</c>.  This translates to Win32 threads on all operating systems.</para>
    /// </summary>
    /**/
    SchedulerKind,

    /// <summary>
    ///     The maximum concurrency level desired by the scheduler.  The resource manager will try to initially allocate this many virtual processors.
    ///     The special value <see cref="MaxExecutionResources Constant">MaxExecutionResources</see> indicates that the desired concurrency level
    ///     is same as the number of hardware threads on the machine.  If the value specified for <c>MinConcurrency</c> is greater than the number
    ///     of hardware threads on the machine and <c>MaxConcurrency</c> is specified as <c>MaxExecutionResources</c>, the value for <c>MaxConcurrency</c>
    ///     is raised to match what is set for <c>MinConcurrency</c>.
    ///     <para>Valid values  : Positive integers and the special value <c>MaxExecutionResources</c></para>
    ///     <para>Default value : <c>MaxExecutionResources</c></para>
    /// </summary>
    /**/
    MaxConcurrency,

    /// <summary>
    ///     The minimum concurrency level that must be provided to the scheduler by the resource manager.  The number of virtual processors assigned
    ///     to a scheduler will never go below the minimum.  The special value <see cref="MaxExecutionResources Constant">MaxExecutionResources</see>
    ///     indicates that the minimum concurrency level is same as the number of hardware threads on the machine.  If the value specified for
    ///     <c>MaxConcurrency</c> is less than the number of hardware threads on the machine and <c>MinConcurrency</c> is specified as
    ///     <c>MaxExecutionResources</c>, the value for <c>MinConcurrency</c> is lowered to match what is set for <c>MaxConcurrency</c>.
    ///     <para>Valid values  : Non-negative integers and the special value <c>MaxExecutionResources</c>.  Note that for scheduler policies
    ///     used for the construction of Concurrency Runtime schedulers or any policy with the <c>SchedulerKind</c> policy key set to the value
    ///     <c>UMSThreadDefault</c>, the value <c>0</c> is invalid.</para>
    ///     <para>Default value : <c>1</c></para>
    /// </summary>
    /**/
    MinConcurrency,

    /// <summary>
    ///     Tentative number of virtual processors per hardware thread.  The target oversubscription factor may be increased by the Resource Manager,
    ///     if necessary, to satisfy <c>MaxConcurrency</c> with the hardware threads on the machine.
    ///     <para>Valid values  : Positive integers</para>
    ///     <para>Default value : <c>1</c></para>
    /// </summary>
    /**/
    TargetOversubscriptionFactor,

    /// <summary>
    ///     When the <c>SchedulingProtocol</c> policy key is set to the value <c>EnhanceScheduleGroupLocality</c>, this specifies the maximum number
    ///     of runnable contexts allowed to be cached in per virtual processor local queues.  Such contexts will typically run in last-in-first-out
    ///     (LIFO) order on the virtual processor that caused them to become runnable.  Note that this policy key has no meaning when the
    ///     <c>SchedulingProtocol</c> key is set to the value <c>EnhanceForwardProgress</c>.
    ///     <para>Valid values  : Non-negative integers</para>
    ///     <para>Default value : <c>8</c></para>
    /// </summary>
    /**/
    LocalContextCacheSize,

    /// <summary>
    ///     The reserved stack size of each context in the scheduler in kilobytes.
    ///     <para>Valid values  : Positive integers</para>
    ///     <para>Default value : <c>0</c>, indicating that the process' default value for stack size be used.</para>
    /// </summary>
    /**/
    ContextStackSize,

    /// <summary>
    ///     The operating system thread priority of each context in the scheduler.  If this key is set to the value <see cref="INHERIT_THREAD_PRIORITY Constant">
    ///     INHERIT_THREAD_PRIORITY</see> the contexts in the scheduler will inherit the priority of the thread that created the scheduler.
    ///     <para>Valid values  : Any of the valid values for the Windows <c>SetThreadPriority</c> function and the special value
    ///     <c>INHERIT_THREAD_PRIORITY</c></para>
    ///     <para>Default value : <c>THREAD_PRIORITY_NORMAL</c></para>
    /// </summary>
    /**/
    ContextPriority,

    /// <summary>
    ///     Describes which scheduling algorithm will be used by the scheduler.  For more information, see <see cref="SchedulingProtocolType Enumeration"/>.
    ///     <para>Valid values  : A member of the <c>SchedulingProtocolType</c> enumeration, either <c>EnhanceScheduleGroupLocality</c>
    ///     or <c>EnhanceForwardProgress</c></para>
    ///     <para>Default value : <c>EnhanceScheduleGroupLocality</c></para>
    /// </summary>
    /**/
    SchedulingProtocol,

    /// <summary>
    ///     Determines whether the resources for the scheduler will be rebalanced according to statistical information gathered from the
    ///     scheduler or only based on the subscription level of underlying hardware threads. For more information, see
    ///     <see cref="DynamicProgressFeedbackType Enumeration"/>.
    ///     <para>Valid values  : A member of the <c>DynamicProgressFeedbackType</c> enumeration, either <c>ProgressFeedbackEnabled</c> or
    ///     <c>ProgressFeedbackDisabled</c></para>
    ///     <para>Default value : <c>ProgressFeedbackEnabled</c></para>
    /// </summary>
    /**/
    DynamicProgressFeedback,

    /// <summary>
    ///     The maximum policy element key.  Not a valid element key.
    /// </summary>
    /**/
    MaxPolicyElementKey
};

/// <summary>
///     Used by the <c>SchedulerKind</c> policy to describe the type of threads that the scheduler should utilize for underlying execution contexts.
///     For more information on available scheduler policies, see <see cref="PolicyElementKey Enumeration"/>.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
enum SchedulerType
{
    /// <summary>
    ///     Indicates an explicit request of regular Win32 threads.
    /// </summary>
    /**/
    ThreadScheduler,

    /// <summary>
    ///     Indicates a request for UMS threads if available on the underlying platform; otherwise, regular Win32 threads.  Note that if
    ///     you call the <c>GetPolicyValue</c> method of a <c>SchedulerPolicy</c> object and this value is returned, it is an indication
    ///     that the underlying platform supports UMS threads and that the policy will create a scheduler utilizing UMS threads.
    /// </summary>
    /**/
    UmsThreadDefault
};

/// <summary>
///     Used by the <c>SchedulingProtocol</c> policy to describe which scheduling algorithm will be utilized for the scheduler.  For more
///     information on available scheduler policies, see <see cref="PolicyElementKey Enumeration"/>.
/// </summary>
/// <seealso cref="SchedulerPolicy Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
enum SchedulingProtocolType
{
    /// <summary>
    ///     The scheduler prefers to continue to work on tasks within the current schedule group before moving to another schedule group.
    ///     Unblocked contexts are cached per virtual-processor and are typically scheduled in a last-in-first-out (LIFO) fashion by the
    ///     virtual processor which unblocked them.
    /// </summary>
    /**/
    EnhanceScheduleGroupLocality,

    /// <summary>
    ///     The scheduler prefers to round-robin through schedule groups after executing each task.  Unblocked contexts are typically
    ///     scheduled in a first-in-first-out (FIFO) fashion.  Virtual processors do not cache unblocked contexts.
    /// </summary>
    /**/
    EnhanceForwardProgress
};

/// <summary>
///     Used by the <c>DynamicProgressFeedback</c> policy to describe whether resources for the scheduler will be rebalanced according to
///     statistical information gathered from the scheduler or only based on virtual processors going in and out of the idle state through
///     calls to the <c>Activate</c> and <c>Deactivate</c> methods on the <c>IVirtualProcessorRoot</c> interface.  For more information
///     on available scheduler policies, see <see cref="PolicyElementKey Enumeration"/>.
/// </summary>
/// <seealso cref="PolicyElementKey Enumeration"/>
/**/
enum DynamicProgressFeedbackType
{
    /// <summary>
    ///     The scheduler does not gather progress information.  Rebalancing is done based solely on the subscription level of the underlying
    ///     hardware thread.  For more information on subscription levels, see
    ///     <see cref="IExecutionResource::CurrentSubscriptionLevel Method">IExecutionResource::CurrentSubscriptionLevel</see>.
    /// </summary>
    /**/
    ProgressFeedbackDisabled,

    /// <summary>
    ///     The scheduler gathers progress information and passes it to the resource manager.  The resource manager will utilize this statistical
    ///     information to rebalance resources on behalf of the scheduler in addition to the subscription level of the underlying
    ///     hardware thread.  For more information on subscription levels, see
    ///     <see cref="IExecutionResource::CurrentSubscriptionLevel Method">IExecutionResource::CurrentSubscriptionLevel</see>.
    /// </summary>
    /**/
    ProgressFeedbackEnabled
};

/// <summary>
///     The <c>SchedulerPolicy</c> class contains a set of key/value pairs, one for each policy element, that control the behavior of a
///     scheduler instance.
/// </summary>
/// <remarks>
///     For more information about the policies which can be controlled via the <c>SchedulerPolicy</c> class, see
///     <see cref="PolicyElementKey Enumeration"/>.
/// </remarks>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="CurrentScheduler Class"/>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class SchedulerPolicy
{
public:

    /// <summary>
    ///     Constructs a new scheduler policy and populates it with values for <see cref="PolicyElementKey Enumeration">policy keys</see>
    ///     supported by Concurrency Runtime schedulers and the Resource Manager.
    /// </summary>
    /// <remarks>
    ///     <para>The first constructor creates a new scheduler policy where all policies will be initialized to their default values.</para>
    ///     <para>The second constructor creates a new scheduler policy that uses a named-parameter style of initialization. Values after
    ///     the <paramref name="_PolicyKeyCount"/> parameter are supplied as key/value pairs.  Any policy key which is not specified in this
    ///     constructor will have its default value. This constructor could throw the exceptions <see cref="invalid_scheduler_policy_key Class">
    ///     invalid_scheduler_policy_key</see>, <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> or
    ///     <see cref="invalid_scheduler_policy_thread_specification Class"> invalid_scheduler_policy_thread_specification</see>.</para>
    ///     <para>The third constructor is a copy constructor. Often, the most convenient way to define a new scheduler policy is to copy an
    ///     existing policy and modify it via the <c>SetPolicyValue</c> or <c>SetConcurrencyLimits</c> methods.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP SchedulerPolicy();

    /// <summary>
    ///     Constructs a new scheduler policy and populates it with values for <see cref="PolicyElementKey Enumeration">policy keys</see>
    ///     supported by Concurrency Runtime schedulers and the Resource Manager.
    /// </summary>
    /// <param name="_PolicyKeyCount">
    ///     The number of key/value pairs that follow the <paramref name="_PolicyKeyCount"/> parameter.
    /// </param>
    /// <remarks>
    ///     <para>The first constructor creates a new scheduler policy where all policies will be initialized to their default values.</para>
    ///     <para>The second constructor creates a new scheduler policy that uses a named-parameter style of initialization. Values after </para>
    ///     the <paramref name="_PolicyKeyCount"/> parameter are supplied as key/value pairs.  Any policy key which is not specified in this
    ///     constructor will have its default value. This constructor could throw the exceptions <see cref="invalid_scheduler_policy_key Class">
    ///     invalid_scheduler_policy_key</see>, <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> or
    ///     <see cref="invalid_scheduler_policy_thread_specification Class"> invalid_scheduler_policy_thread_specification</see>.
    ///     <para>The third constructor is a copy constructor. Often, the most convenient way to define a new scheduler policy is to copy an
    ///     existing policy and modify it via the <c>SetPolicyValue</c> or <c>SetConcurrencyLimits</c> methods.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP SchedulerPolicy(size_t _PolicyKeyCount, ...);

    /// <summary>
    ///     Constructs a new scheduler policy and populates it with values for <see cref="PolicyElementKey Enumeration">policy keys</see>
    ///     supported by Concurrency Runtime schedulers and the Resource Manager.
    /// </summary>
    /// <param name="_SrcPolicy">
    ///     The source policy to copy.
    /// </param>
    /// <remarks>
    ///     <para>The first constructor creates a new scheduler policy where all policies will be initialized to their default values.</para>
    ///     <para>The second constructor creates a new scheduler policy that uses a named-parameter style of initialization. Values after </para>
    ///     the <paramref name="_PolicyKeyCount"/> parameter are supplied as key/value pairs.  Any policy key which is not specified in this
    ///     constructor will have its default value. This constructor could throw the exceptions <see cref="invalid_scheduler_policy_key Class">
    ///     invalid_scheduler_policy_key</see>, <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> or
    ///     <see cref="invalid_scheduler_policy_thread_specification Class"> invalid_scheduler_policy_thread_specification</see>.
    ///     <para>The third constructor is a copy constructor. Often, the most convenient way to define a new scheduler policy is to copy an
    ///     existing policy and modify it via the <c>SetPolicyValue</c> or <c>SetConcurrencyLimits</c> methods.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP SchedulerPolicy(const SchedulerPolicy& _SrcPolicy);

    /// <summary>
    ///     Assigns the scheduler policy from another scheduler policy.
    /// </summary>
    /// <param name="_RhsPolicy">
    ///     The policy to assign to this policy.
    /// </param>
    /// <returns>
    ///     A reference to the scheduler policy.
    /// </returns>
    /// <remarks>
    ///     Often, the most convenient way to define a new scheduler policy is to copy an existing policy and modify it via the
    ///     <c>SetPolicyValue</c> or <c>SetConcurrencyLimits</c> methods.
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP SchedulerPolicy& operator=(const SchedulerPolicy& _RhsPolicy);

    /// <summary>
    ///     Destroys a scheduler policy.
    /// </summary>
    /**/
    _CRTIMP ~SchedulerPolicy();

    /// <summary>
    ///     Retrieves the value of the policy key supplied as the <paramref name="_Key"/> parameter.
    /// </summary>
    /// <param name="_Key">
    ///     The policy key to retrieve a value for.
    /// </param>
    /// <returns>
    ///     If the key specified by the <paramref name="_Key"/> parameter is supported, the policy value for the key cast to an <c>unsigned int</c>.
    /// </returns>
    /// <remarks>
    ///     The method will throw <see cref="invalid_scheduler_policy_key Class">invalid_scheduler_policy_key</see> for an invalid policy key.
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP unsigned int GetPolicyValue(PolicyElementKey _Key) const;

    /// <summary>
    ///     Sets the value of the policy key supplied as the <paramref name="_Key"/> parameter and returns the old value.
    /// </summary>
    /// <param name="_Key">
    ///     The policy key to set a value for.
    /// </param>
    /// <param name="_Value">
    ///     The value to set the policy key to.
    /// </param>
    /// <returns>
    ///     If the key specified by the <paramref name="_Key"/> parameter is supported, the old policy value for the key cast to an <c>unsigned int</c>.
    /// </returns>
    /// <remarks>
    ///     The method will throw <see cref="invalid_scheduler_policy_key Class">invalid_scheduler_policy_key </see> for an invalid policy key
    ///     or any policy key whose value cannot be set by the <c>SetPolicyValue</c> method.
    ///     <para>The method will throw <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value</see> for a value that
    ///     is not supported for the key specified by the <paramref name="_Key"/> parameter.</para>
    ///     <para>Note that this method is not allowed to set the <c>MinConcurrency</c> or <c>MaxConcurrency</c> policies.  To set these values, use
    ///     the <see cref="SchedulerPolicy::SetConcurrencyLimits Method">SetConcurrencyLimits</see> method.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetConcurrencyLimits Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP unsigned int SetPolicyValue(PolicyElementKey _Key, unsigned int _Value);

    /// <summary>
    ///     Simultaneously sets the <c>MinConcurrency</c> and <c>MaxConcurrency</c> policies on the <c>SchedulerPolicy</c> object.
    /// </summary>
    /// <param name="_MinConcurrency">
    ///     The value for the <c>MinConcurrency</c> policy key.
    /// </param>
    /// <param name="_MaxConcurrency">
    ///     The value for the <c>MaxConcurrency</c> policy key.
    /// </param>
    /// <remarks>
    ///     The method will throw <see cref="invalid_scheduler_policy_thread_specification Class">invalid_scheduler_policy_thread_specification
    ///     </see> if the value specified for the <c>MinConcurrency</c> policy is greater than that specified for the <c>MaxConcurrency</c> policy.
    ///     <para>The method may also throw <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> for other
    ///     invalid values.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy::GetPolicyValue Method"/>
    /// <seealso cref="SchedulerPolicy::SetPolicyValue Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /**/
    _CRTIMP void SetConcurrencyLimits(unsigned int _MinConcurrency, unsigned int _MaxConcurrency = MaxExecutionResources);

    /// <summary>
    ///     Checks if this policy is a valid policy for a Concurrency Runtime scheduler.  If it is not, an appropriate exception will be thrown.
    /// </summary>
    /// <remarks>
    ///     The method will throw <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value </see> if a policy value supplied
    ///     in the <c>SchedulerPolicy</c> object cannot be used to create a Concurrency Runtime scheduler.  Note that such a policy is not necessarily
    ///     invalid.  The Concurrency Runtime's Resource Manager also utilizes the <c>SchedulerPolicy</c> class to describe requirements.
    /// </remarks>
    /**/
    void _ValidateConcRTPolicy() const;

private:

    struct _PolicyBag
    {
        union
        {
            unsigned int _M_pPolicyBag[MaxPolicyElementKey];
            struct
            {
                SchedulerType _M_schedulerKind;
                unsigned int _M_maxConcurrency;
                unsigned int _M_minConcurrency;
                unsigned int _M_targetOversubscriptionFactor;
                unsigned int _M_localContextCacheSize;
                unsigned int _M_contextStackSize;
                unsigned int _M_contextPriority;
                SchedulingProtocolType _M_schedulingProtocol;
                DynamicProgressFeedbackType _M_dynamicProgressFeedback;
            } _M_specificValues;
        } _M_values;
    } *_M_pPolicyBag;

    /// <summary>
    ///     Initializes the scheduler policy.
    /// </summary>
    /**/
    void _Initialize(size_t _PolicyKeyCount, va_list * _PArgs);

    /// <summary>
    ///     Make this policy a copy of the source policy.
    /// </summary>
    /**/
    void _Assign(const SchedulerPolicy& _SrcPolicy);

    /// <summary>
    ///     Returns true if the key supplied is a supported key.
    /// </summary>
    /**/
    static bool __cdecl _ValidPolicyKey(PolicyElementKey _Key);

    /// <summary>
    ///     Returns true if a policy value is in a valid range.
    /// </summary>
    /**/
    static bool __cdecl _ValidPolicyValue(PolicyElementKey _Key, unsigned int _Value);

    /// <summary>
    ///     Returns true if concurrency limit combinations are valid.
    /// </summary>
    /**/
    static bool __cdecl _AreConcurrencyLimitsValid(unsigned int _MinConcurrency, unsigned int _MaxConcurrency);
    bool _AreConcurrencyLimitsValid() const;

    /// <summary>
    ///     Test a policy's concurrency combinations.
    /// </summary>
    /**/
    bool _ArePolicyCombinationsValid() const;

    /// <summary>
    ///     Resolves some of the policy keys that are set to defaults, based on the characteristics of the underlying system.
    /// </summary>
    /**/
    void _ResolvePolicyValues();

    /// <summary>
    ///     Stringify policy keys.
    /// </summary>
    /**/
    static char * __cdecl _StringFromPolicyKey(unsigned int _Index);
};

/// <summary>
///     Represents an abstraction for the current scheduler associated with the calling context.
/// </summary>
/// <remarks>
///     If there is no scheduler (see <see cref="Scheduler Class">Scheduler</see>) associated with the calling context, many
///     methods within the <c>CurrentScheduler</c> class will result in attachment of the process' default scheduler.  This may
///     also imply that the process' default scheduler is created during such a call.
/// </remarks>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class CurrentScheduler
{
private:
    CurrentScheduler() {}

public:
    /// <summary>
    ///     Returns a unique identifier for the current scheduler.
    /// </summary>
    /// <returns>
    ///     If a scheduler is associated with the calling context, a unique identifier for that scheduler; otherwise, the value <c>-1</c>.
    /// </returns>
    /// <remarks>
    ///     This method will not result in scheduler attachment if the calling context is not already associated with a scheduler.
    /// </remarks>
    /**/
    _CRTIMP static unsigned int __cdecl Id();

    /// <summary>
    ///     Returns a copy of the policy that the current scheduler was created with.
    /// </summary>
    /// <returns>
    ///     A copy of the policy that that the current scheduler was created with.
    /// </returns>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    /// </remarks>
    /// <seealso cref="SchedulerPolicy Class"/>
    /**/
    _CRTIMP static SchedulerPolicy __cdecl GetPolicy();

    /// <summary>
    ///     Returns a pointer to the scheduler associated with the calling context, also referred to as the current scheduler.
    /// </summary>
    /// <returns>
    ///     A pointer to the scheduler associated with the calling context (the current scheduler).
    /// </returns>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context. No additional reference is placed on the <c>Scheduler</c> object
    ///     returned by this method.
    /// </remarks>
    /**/
    _CRTIMP static Scheduler * __cdecl Get();

    /// <summary>
    ///     Returns the current number of virtual processors for the scheduler associated with the calling context.
    /// </summary>
    /// <returns>
    ///     If a scheduler is associated with the calling context, the current number of virtual processors for that scheduler; otherwise,
    ///     the value <c>-1</c>.
    /// </returns>
    /// <remarks>
    ///     This method will not result in scheduler attachment if the calling context is not already associated with a scheduler.
    ///     <para>The return value from this method is an instantaneous sampling of the number of virtual processors for the scheduler associated
    ///     with the calling context.  This value may be stale the moment it is returned.</para>
    /// </remarks>
    /**/
    _CRTIMP static unsigned int __cdecl GetNumberOfVirtualProcessors();

    /// <summary>
    ///     Creates a new scheduler whose behavior is described by the <paramref name="_Policy"/> parameter and attaches it to the calling context.
    ///     The newly created scheduler will become the current scheduler for the calling context.
    /// </summary>
    /// <param name="_Policy">
    ///     The scheduler policy that describes the behavior of the newly created scheduler.
    /// </param>
    /// <remarks>
    ///     The attachment of the scheduler to the calling context implicitly places a reference count on the scheduler.
    ///     <para>After a scheduler is created with the <c>Create</c> method, you must call the <see cref="CurrentScheduler::Detach Method">
    ///     CurrentScheduler::Detach</see> method at some point in the future in order to allow the scheduler to shut down.</para>
    ///     <para>If this method is called from a context that is already attached to a different scheduler, the existing scheduler is remembered
    ///     as the previous scheduler, and the newly created scheduler becomes the current scheduler. When you call the <c>CurrentScheduler::Detach</c>
    ///     method at a later point, the previous scheduler is restored as the current scheduler.</para>
    ///     <para>This method may throw a variety of exceptions, including <see cref="scheduler_resource_allocation_error Class">
    ///     scheduler_resource_allocation_error</see> and <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value</see>.</para>
    /// </remarks>
    /// <seealso cref="SchedulerPolicy Class"/>
    /// <seealso cref="CurrentScheduler::Detach Method"/>
    /// <seealso cref="Scheduler::Reference Method"/>
    /// <seealso cref="Scheduler::Release Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static void __cdecl Create(const SchedulerPolicy& _Policy);

    /// <summary>
    ///     Detaches the current scheduler from the calling context and restores the previously attached scheduler as the current
    ///     scheduler, if one exists.  After this method returns, the calling context is then managed by the scheduler that was previously
    ///     attached to the context via either the <c>CurrentScheduler::Create</c> or <c>Scheduler::Attach</c> method.
    /// </summary>
    /// <remarks>
    ///     The <c>Detach</c> method implicitly removes a reference count from the scheduler.
    ///     <para>If there is no scheduler attached to the calling context, calling this method will result in an <see cref="improper_scheduler_detach Class">
    ///     improper_scheduler_detach</see> exception being thrown.</para>
    /// </remarks>
    /// <seealso cref="Scheduler::Attach Method"/>
    /// <seealso cref="CurrentScheduler::Create Method"/>
    /**/
    _CRTIMP static void __cdecl Detach();

    /// <summary>
    ///     Causes the Windows event handle passed in the <paramref name="_ShutdownEvent"/> parameter to be signaled when the scheduler associated with
    ///     the current context shuts down and destroys itself.  At the time the event is signaled, all work that had been scheduled to the
    ///     scheduler is complete.  Multiple shutdown events may be registered through this method.
    /// </summary>
    /// <param name="_ShutdownEvent">
    ///     A handle to a Windows event object which will be signaled by the runtime when the scheduler associated with the current context
    ///     shuts down and destroys itself.
    /// </param>
    /// <remarks>
    ///     If there is no scheduler attached to the calling context, calling this method will result in a <see cref="scheduler_not_attached Class">
    ///     scheduler_not_attached </see> exception being thrown.
    /// </remarks>
    /**/
    _CRTIMP static void __cdecl RegisterShutdownEvent(HANDLE _ShutdownEvent);

    /// <summary>
    ///     Creates a new schedule group within the scheduler associated with the calling context.
    /// </summary>
    /// <returns>
    ///     A pointer to the newly created schedule group.  This <c>ScheduleGroup</c> object has an initial reference count placed on it.
    /// </returns>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    ///     <para>You must invoke the <see cref="ScheduleGroup::Release Method">Release</see> method on a schedule group when you are
    ///     done scheduling work to it. The scheduler will destroy the schedule group when all work queued to it has completed.</para>
    ///     <para>Note that if you explicitly created this scheduler, you must release all references to schedule groups within it, before
    ///     you release your reference on the scheduler, via detaching the current context from it.</para>
    /// </remarks>
    /// <seealso cref="ScheduleGroup Class"/>
    /// <seealso cref="ScheduleGroup::Release Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static ScheduleGroup * __cdecl CreateScheduleGroup();

    /// <summary>
    ///     Schedules a light-weight task within the scheduler associated with the calling context.  The light-weight task will be placed
    ///     in a schedule group of the runtime's choosing.
    /// </summary>
    /// <param name="_Proc">
    ///     A pointer to the function to execute to perform the body of the light-weight task.
    /// </param>
    /// <param name="_Data">
    ///     A void pointer to the data that will be passed as a parameter to the body of the task.
    /// </param>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    /// </remarks>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP static void __cdecl ScheduleTask(TaskProc _Proc, void * _Data);
};

/// <summary>
///     Represents an abstraction for a Concurrency Runtime scheduler.
/// </summary>
/// <remarks>
///     The Concurrency Runtime scheduler uses execution contexts, which map to the operating system's execution contexts, such as a thread or a UMS thread,
///     to execute the work queued to it by your application.  At any time, the concurrency level of a scheduler is equal to the number of virtual processor
///     granted to it by the Resource Manager.  A virtual processor is an abstraction for a processing resource and maps to a hardware thread on the
///     underlying system. Only a single scheduler context may execute on a virtual processor at a given time.
///     <para> The Concurrency Runtime will create a default scheduler per process to execute parallel work.  In addition you may create your own scheduler
///     instances and manipulate it using this class.</para>
/// </remarks>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="PolicyElementKey Enumeration"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class Scheduler
{
protected:
    /// <summary>
    ///     An object of the <c>Scheduler</c> class can only created using factory methods, or implicitly.
    /// </summary>
    /// <remarks>
    ///     The process' default scheduler is created implicitly when you utilize many of the runtime functions which require a scheduler
    ///     to be attached to the calling context.  Methods within the <c>CurrentScheduler</c> class and features of the PPL and agents layers
    ///     typically perform implicit attachment.
    ///     <para>You can also create a scheduler explicitly through either the <c>CurrentScheduler::Create</c> method or the <c>Scheduler::Create</c>
    ///     method.</para>
    /// </remarks>
    /// <seealso cref="CurrentScheduler Class"/>
    /// <seealso cref="CurrentScheduler::Create Method"/>
    /// <seealso cref="Scheduler::Create Method"/>
    /**/
    Scheduler() {}

    /// <summary>
    ///     An object of the <c>Scheduler</c> class is implicitly destroyed when all external references to it cease to exist.
    /// </summary>
    /**/
    virtual ~Scheduler() {}

public:

    /// <summary>
    ///     Creates a new scheduler whose behavior is described by the <paramref name="_Policy"/> parameter, places an initial reference on
    ///     the scheduler, and returns a pointer to it.
    /// </summary>
    /// <param name="_Policy">
    ///     The scheduler policy that describes behavior of the newly created scheduler.
    /// </param>
    /// <returns>
    ///     A pointer to a newly created scheduler.  This <c>Scheduler</c> object has an initial reference count placed on it.
    /// </returns>
    /// <remarks>
    ///     After a scheduler is created with the <c>Create</c> method, you must call the <see cref="Release Method">Release</see> method at some point
    ///     in the future in order to remove the initial reference count and allow the scheduler to shut down.
    ///     <para>A scheduler created with this method is not attached to the calling context. It may be attached to a context via the
    ///     <see cref="Scheduler::Attach Method">Attach</see> method.</para>
    ///     <para>This method may throw a variety of exceptions, including <see cref="scheduler_resource_allocation_error Class">
    ///     scheduler_resource_allocation_error</see> and <see cref="invalid_scheduler_policy_value Class">invalid_scheduler_policy_value</see>.</para>
    /// </remarks>
    /// <seealso cref="Scheduler::Release Method"/>
    /// <seealso cref="Scheduler::Attach Method"/>
    /// <seealso cref="CurrentScheduler::Create Method"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static Scheduler * __cdecl Create(const SchedulerPolicy& _Policy);

    /// <summary>
    ///     Returns a unique identifier for the scheduler.
    /// </summary>
    /// <returns>
    ///     A unique identifier for the scheduler.
    /// </returns>
    /**/
    virtual unsigned int Id() const =0;

    /// <summary>
    ///     Returns the current number of virtual processors for the scheduler.
    /// </summary>
    /// <returns>
    ///     The current number of virtual processors for the scheduler.
    ///     <para>The return value from this method is an instantaneous sampling of the number of virtual processors for the scheduler.
    ///     This value may be stale the moment it is returned.</para>
    /// </returns>
    /**/
    virtual unsigned int GetNumberOfVirtualProcessors() const =0;

    /// <summary>
    ///     Returns a copy of the policy that the scheduler was created with.
    /// </summary>
    /// <returns>
    ///     A copy of the policy that the scheduler was created with.
    /// </returns>
    /// <seealso cref="SchedulerPolicy Class"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    virtual SchedulerPolicy GetPolicy() const =0;

    /// <summary>
    ///     Increments the scheduler's reference count.
    /// </summary>
    /// <returns>
    ///     The newly incremented reference count.
    /// </returns>
    /// <remarks>
    ///     This is typically used to manage the lifetime of the scheduler for composition.  When the reference count of a scheduler
    ///     falls to zero, the scheduler will shut down and destruct itself once all work on the scheduler has completed.
    ///     <para>The method will throw an <see cref="improper_scheduler_reference Class">improper_scheduler_reference</see> exception if the reference
    ///     count prior to calling the <c>Reference</c> method was zero and the call is made from a context that is not owned by the scheduler.</para>
    /// </remarks>
    /// <seealso cref="Scheduler::Release Method"/>
    /// <seealso cref="Scheduler::Create Method"/>
    /**/
    virtual unsigned int Reference() =0 ;

    /// <summary>
    ///     Decrements this scheduler's reference count.
    /// </summary>
    /// <returns>
    ///     The newly decremented reference count.
    /// </returns>
    /// <remarks>
    ///     This is typically used to manage the lifetime of the scheduler for composition.  When the reference count of a scheduler
    ///     falls to zero, the scheduler will shut down and destruct itself once all work on the scheduler has completed.
    /// </remarks>
    /// <seealso cref="Scheduler::Reference Method"/>
    /// <seealso cref="Scheduler::Create Method"/>
    /**/
    virtual unsigned int Release() =0;

    /// <summary>
    ///     Causes the Windows event handle passed in the <paramref name="_Event"/> parameter to be signaled when the scheduler
    ///     shuts down and destroys itself.  At the time the event is signaled, all work that had been scheduled to the
    ///     scheduler is complete.  Multiple shutdown events may be registered through this method.
    /// </summary>
    /// <param name="_Event">
    ///     A handle to a Windows event object which will be signaled by the runtime when the scheduler shuts down and destroys itself.
    /// </param>
    /**/
    virtual void RegisterShutdownEvent(HANDLE _Event) =0;

    /// <summary>
    ///     Attaches the scheduler to the calling context.  After this method returns, the calling context is managed by the scheduler and
    ///     the scheduler becomes the current scheduler.
    /// </summary>
    /// <remarks>
    ///     Attaching a scheduler implicitly places a reference on the scheduler.
    ///     <para>At some point in the future, you must call the <see cref="CurrentScheduler::Detach Method">CurrentScheduler::Detach</see>
    ///     method in order to allow the scheduler to shut down.</para>
    ///     <para>If this method is called from a context that is already attached to a different scheduler, the existing scheduler is remembered
    ///     as the previous scheduler, and the newly created scheduler becomes the current scheduler. When you call the <c>CurrentScheduler::Detach</c>
    ///     method at a later point, the previous scheduler is restored as the current scheduler.</para>
    ///     <para>This method will throw an <see cref="improper_scheduler_attach Class">improper_scheduler_attach</see> exception if this scheduler
    ///     is the current scheduler of the calling context.</para>
    /// </remarks>
    /// <seealso cref="CurrentScheduler::Detach Method"/>
    /**/
    virtual void Attach() =0;

    /// <summary>
    ///     Allows a user defined policy to be used to create the default scheduler.  This method may only be called when no default
    ///     scheduler exists within the process.  Once a default policy has been set, it remains in effect until the next valid call
    ///     to either the <c>SetDefaultSchedulerPolicy</c> or the <see cref="Scheduler::ResetDefaultSchedulerPolicy Method">ResetDefaultSchedulerPolicy
    ///     </see> method.
    /// </summary>
    /// <param name="_Policy">
    ///     The policy to be set as the default scheduler policy.
    /// </param>
    /// <remarks>
    ///     If the <c>SetDefaultSchedulerPolicy</c> method is called when a default scheduler already exists within the process, the runtime
    ///     will throw a <see cref="default_scheduler_exists Class">default_scheduler_exists</see> exception.
    /// </remarks>
    /// <seealso cref="Scheduler::ResetDefaultSchedulerPolicy Method"/>
    /// <seealso cref="SchedulerPolicy Class"/>
    /// <seealso cref="PolicyElementKey Enumeration"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static void __cdecl SetDefaultSchedulerPolicy(const SchedulerPolicy& _Policy);

    /// <summary>
    ///     Resets the default scheduler policy to the runtime's default.  The next time a default scheduler is created, it will use the
    ///     runtime's default policy settings.
    /// </summary>
    /// <remarks>
    ///     This method may be called while a default scheduler exists within the process. It will not affect the policy of the existing
    ///     default scheduler. However, if the default scheduler were to shutdown, and a new default were to be created at a later
    ///     point, the new scheduler would use the runtime's default policy settings.
    /// </remarks>
    /// <seealso cref="Scheduler::SetDefaultSchedulerPolicy Method"/>
    /// <seealso cref="SchedulerPolicy Class"/>
    /**/
    _CRTIMP static void __cdecl ResetDefaultSchedulerPolicy();

    /// <summary>
    ///     Creates a new schedule group within the scheduler.
    /// </summary>
    /// <returns>
    ///     A pointer to the newly created schedule group.  This <c>ScheduleGroup</c> object has an initial reference count placed on it.
    /// </returns>
    /// <remarks>
    ///     You must invoke the <see cref="ScheduleGroup::Release Method">Release</see> method on a schedule group when you are
    ///     done scheduling work to it. The scheduler will destroy the schedule group when all work queued to it has completed.
    ///     <para>Note that if you explicitly created this scheduler, you must release all references to schedule groups within it, before
    ///     you release your references on the scheduler.</para>
    /// </remarks>
    /// <seealso cref="ScheduleGroup Class"/>
    /// <seealso cref="ScheduleGroup::Release Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    virtual ScheduleGroup * CreateScheduleGroup() =0;

    /// <summary>
    ///     Schedules a light-weight task within the scheduler.  The light-weight task will be placed in a schedule group of the runtime's choosing.
    /// </summary>
    /// <param name="proc">
    ///     A pointer to the function to execute to perform the body of the light-weight task.
    /// </param>
    /// <param name="_Data">
    ///     A void pointer to the data that will be passed as a parameter to the body of the task.
    /// </param>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    virtual void ScheduleTask(TaskProc proc, void * _Data) =0;
};

/// <summary>
///     Represents an abstraction for an execution context.
/// </summary>
/// <remarks>
///     The Concurrency Runtime scheduler (see <see cref="Scheduler Class">Scheduler</see>) uses execution contexts to execute the work queued
///     to it by your application.  A Win32 thread and a user mode schedulable (UMS) thread are examples of execution contexts on a Windows
///     operating system. UMS threads are supported only on 64-bit operating systems with version Windows 7 and higher.
///     <para>At any time, the concurrency level of a scheduler is equal to the number of virtual processors granted to it by the Resource Manager.
///     A virtual processor is an abstraction for a processing resource and maps to a hardware thread on the underlying system. Only a single scheduler
///     context may execute on a virtual processor at a given time.</para>
///     <para> The scheduler is cooperative in nature and an executing context may yield its virtual processor to a different context at any time if
///     it wishes to enter a wait state. When its wait it satisfied, it cannot resume until an available virtual processor from the scheduler begins
///     executing it.</para>
/// </remarks>
/// <seealso cref="Scheduler Class"/>
/// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
/**/
class Context
{
public:

    /// <summary>
    ///     Returns an identifier for the context that is unique within the scheduler to which the context belongs.
    /// </summary>
    /// <returns>
    ///     An identifier for the context that is unique within the scheduler to which the context belongs.
    /// </returns>
    /**/
    virtual unsigned int GetId() const =0;

    /// <summary>
    ///     Returns an identifier for the virtual processor that the context is currently executing on.
    /// </summary>
    /// <returns>
    ///     If the context is currently executing on a virtual processor, an identifier for the virtual processor that the context
    ///     is currently executing on; otherwise, the value <c>-1</c>.
    /// </returns>
    /// <remarks>
    ///     The return value from this method is an instantaneous sampling of the virtual processor that the context is executing
    ///     on.  This value may be stale the moment it is returned and cannot be relied upon.  Typically, this method is used
    ///     for debugging or tracing purposes only.
    /// </remarks>
    /**/
    virtual unsigned int GetVirtualProcessorId() const =0;

    /// <summary>
    ///     Returns an identifier for the schedule group that the context is currently working on.
    /// </summary>
    /// <returns>
    ///     An identifier for the schedule group the context is currently working on.
    /// </returns>
    /// <remarks>
    ///     The return value from this method is an instantaneous sampling of the schedule group that the context is executing
    ///     on.  If this method is called on a context other than the current context, the value may be stale the moment it is
    ///     returned and cannot be relied upon.  Typically, this method is used for debugging or tracing purposes only.
    /// </remarks>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    virtual unsigned int GetScheduleGroupId() const =0;

    /// <summary>
    ///     Returns an identifier for the current context that is unique within the scheduler to which the current context belongs.
    /// </summary>
    /// <returns>
    ///     If the current context is attached to a scheduler, an identifier for the current context that is unique within the scheduler
    ///     to which the current context belongs; otherwise, the value <c>-1</c>.
    /// </returns>
    /**/
    _CRTIMP static unsigned int __cdecl Id();

    /// <summary>
    ///     Returns an identifier for the virtual processor that the current context is executing on.
    /// </summary>
    /// <returns>
    ///     If the current context is attached to a scheduler, an identifier for the virtual processor that the current context is
    ///     executing on; otherwise, the value <c>-1</c>.
    /// </returns>
    /// <remarks>
    ///     The return value from this method is an instantaneous sampling of the virtual processor that the current context is executing
    ///     on.  This value may be stale the moment it is returned and cannot be relied upon.  Typically, this method is used
    ///     for debugging or tracing purposes only.
    /// </remarks>
    /**/
    _CRTIMP static unsigned int __cdecl VirtualProcessorId();

    /// <summary>
    ///     Returns an identifier for the schedule group that the current context is working on.
    /// </summary>
    /// <returns>
    ///     If the current context is attached to a scheduler and working on a schedule group, an identifier for the scheduler group that the
    ///     current context is working on; otherwise, the value <c>-1</c>.
    /// </returns>
    /// <seealso cref="ScheduleGroup Class"/>
    /**/
    _CRTIMP static unsigned int __cdecl ScheduleGroupId();

    /// <summary>
    ///     Blocks the current context.
    /// </summary>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    ///     <para>If the calling context is running on a virtual processor, the virtual processor will find another runnable context to
    ///     execute or may potentially create a new one.</para>
    ///     <para>Once the <c>Block</c> method has been called or will be called, you must pair it with a call to the <see cref="Context::Unblock Method">
    ///     Unblock</see> method from another execution context in order for it to run again.  Be aware that there is a critical period between
    ///     the point where your code publishes its context for another thread to be able to call the <c>Unblock</c> method and the point
    ///     where the actual method call to <c>Block</c> is made.  During this period, it is imperative that you not call any method which
    ///     may in turn block and unblock for its own reasons (e.g.: acquiring a lock).  Calls to the <c>Block</c> and <c>Unblock</c> method
    ///     do not track the reason for the blocking and unblocking.  Only one object should have ownership of a <c>Block</c>-<c>Unblock</c>
    ///     pair.</para>
    ///     <para>This method may throw a variety of exceptions, including <see cref="scheduler_resource_allocation_error Class">
    ///     scheduler_resource_allocation_error</see>.</para>
    /// </remarks>
    /// <seealso cref="Context::Unblock Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static void __cdecl Block();

    /// <summary>
    ///     Unblocks the context and causes it to become runnable.
    /// </summary>
    /// <remarks>
    ///     It is perfectly legal for a call to the <c>Unblock</c> method to come before a corresponding call to the <see cref="Context::Block Method">
    ///     Block</see> method. As long as calls to the <c>Block</c> and <c>Unblock</c> methods are properly paired, the runtime properly handles the natural race of
    ///     either ordering.  An <c>Unblock</c> call coming before a <c>Block</c> call simply negates the effect of the <c>Block</c> call.
    ///     <para>There are several exceptions which can be thrown from this method.  If a context attempts to call the <c>Unblock</c> method on
    ///     itself, a <see cref="context_self_unblock Class">context_self_unblock</see> exception will be thrown.  If calls to <c>Block</c> and
    ///     <c>Unblock</c> are not properly paired (e.g.: two calls to <c>Unblock</c> are made for a context which is currently running), a
    ///     <see cref="context_unblock_unbalanced Class">context_unblock_unbalanced</see> exception will be thrown.</para>
    ///
    ///     <para>Be aware that there is a critical period between the point where your code publishes its context for another thread to
    ///     be able to call the <c>Unblock</c> method and the point where the actual method call to <c>Block</c> is made.  During this period,
    ///     it is imperative that you not call any method which may in turn block and unblock for its own reasons (e.g.: acquiring a lock).
    ///     Calls to the <c>Block</c> and <c>Unblock</c> method do not track the reason for the blocking and unblocking.  Only one object should have
    ///     ownership of a <c>Block</c> and <c>Unblock</c> pair.</para>
    /// </remarks>
    /// <seealso cref="Context::Block Method"/>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    virtual void Unblock() =0;

    /// <summary>
    ///     Determines whether or not the context is synchronously blocked.  A context is considered to be synchronously
    ///     blocked if it explicitly performed an action which led to blocking.
    /// </summary>
    /// <returns>
    ///     Whether the context is synchronously blocked.
    /// </returns>
    /// <remarks>
    ///     A context is considered to be synchronously blocked if it explicitly performed an action which led to blocking.  On the thread scheduler,
    ///     this would indicate a call to the <c>Context::Block</c> method or a synchronization object which was built using the runtime's
    ///     <c>Context::Block</c> method.  On the UMS scheduler, this could also indicate a call to a Windows method which explicitly blocked
    ///     using Windows synchronization primitives.  Page faults, thread suspensions, and other asynchronous events which the UMS scheduler is aware
    ///     of do not constitute synchronous blocking.
    ///     <para>The return value from this method is an instantaneous sample of whether the context is synchronously blocked.  This value may
    ///     be stale the moment it is returned and can only be used under very specific circumstances.</para>
    /// </remarks>
    /// <seealso cref="Context::Block Method"/>
    /**/
    virtual bool IsSynchronouslyBlocked() const =0;

    /// <summary>
    ///     Yields execution so that another context may execute.  If no other context is available to yield to,
    ///     the method simply returns.
    /// </summary>
    /// <remarks>
    ///     This yield variant is intended for use within spin loops.
    ///     <para>This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.</para>
    /// </remarks>
    /**/
    _CRTIMP static void __cdecl _SpinYield();

    /// <summary>
    ///     Yields execution so that another context may execute.  If no other context is available to yield to, the scheduler
    ///     may yield to another operating system thread.
    /// </summary>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    /// </remarks>
    /// <seealso cref="Context::Block Method"/>
    /// <seealso cref="Context::Unblock Method"/>
    /**/
    _CRTIMP static void __cdecl Yield();

    /// <summary>
    ///     Returns an indication of whether the task collection which is currently executing inline on the current context
    ///     is in the midst of an active cancellation (or will be shortly).
    /// </summary>
    /// <returns>
    ///     If a scheduler is attached to the calling context and a task group is executing a task inline on that context,
    ///     an indication of whether that task group is in the midst of an active cancellation (or will be shortly); otherwise,
    ///     the value <c>false</c>.
    ///     <para>This method will not result in scheduler attachment if the calling context is not already associated with a scheduler.</para>
    /// </returns>
    /**/
    _CRTIMP static bool __cdecl IsCurrentTaskCollectionCanceling();

    /// <summary>
    ///     Returns a pointer to the current context.
    /// </summary>
    /// <returns>
    ///     A pointer to the current context.
    /// </returns>
    /// <remarks>
    ///     This method will result in the process' default scheduler being created and/or attached to the calling context if there is no
    ///     scheduler currently associated with the calling context.
    /// </remarks>
    /**/
    _CRTIMP static Context * __cdecl CurrentContext();

    /// <summary>
    ///     Injects an additional virtual processor into a scheduler for the duration of a block of code when invoked on a context executing
    ///     on one of the virtual processors in that scheduler.
    /// </summary>
    /// <param name="_BeginOversubscription">
    ///     If <c>true</c>, an indication that an extra virtual processor should be added for the duration of the oversubscription.
    ///     If <c>false</c>, an indication that the oversubscription should end and the previously added virtual processor should be removed.
    /// </param>
    /// <remarks>
    ///     Note that on a scheduler which utilizes user mode schedulable (UMS) threads, this method does not inject a new virtual processor.  The
    ///     UMS scheduler can detect kernel blocking and choose to run a new context on a virtual processor whose executing context blocked.
    ///     <para>For more information on using oversubscription in your application, see <see cref="Task Scheduler (Concurrency Runtime)"/>.</para>
    /// </remarks>
    /// <seealso cref="Task Scheduler (Concurrency Runtime)"/>
    /**/
    _CRTIMP static void __cdecl Oversubscribe(bool _BeginOversubscription);

protected:

    //
    // Privatize operator delete.  The scheduler internally manages contexts.
    //
    template<class _T> friend void Concurrency::details::_InternalDeleteHelper(_T * _PObject);

    /// <summary>
    ///     A <c>Context</c> object is destroyed internally by the runtime. It may not be explicitly deleted.
    /// </summary>
    /// <param name="_PObject">
    ///     A pointer to the object to be deleted.
    /// </param>
    /**/
    void operator delete(void * _PObject)
    {
        ::operator delete(_PObject);
    }
};

/// <summary>
///     A non-reentrant mutex which is explicitly aware of the Concurrency Runtime.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Synchronization Data Structures"/>.
/// </remarks>
/// <seealso cref="reader_writer_lock Class"/>
/**/
class critical_section
{
public:

    /// <summary>
    ///     Constructs a new critical section.
    /// </summary>
    /**/
    _CRTIMP critical_section();

    /// <summary>
    ///     Destroys a critical section.
    /// </summary>
    /// <remarks>
    ///     It is expected that the lock is no longer held when the destructor runs.  Allowing the critical section to destruct with the lock
    ///     still held results in undefined behavior.
    /// </remarks>
    /**/
    _CRTIMP ~critical_section();

    /// <summary>
    ///     Acquires this critical section.
    /// </summary>
    /// <remarks>
    ///     It is often safer to utilize the <see cref="critical_section::scoped_lock Class">scoped_lock</see> construct to acquire and release
    ///     a <c>critical_section</c> object in an exception safe way.
    ///     <para>If the lock is already held by the calling context, an <see cref="improper_lock Class">improper_lock</see> exception will be
    ///     thrown.</para>
    /// </remarks>
    /// <seealso cref="critical_section::unlock Method"/>
    /// <seealso cref="critical_section::scoped_lock Class"/>
    /**/
    _CRTIMP void lock();

    /// <summary>
    ///     Tries to acquire the lock without blocking.
    /// </summary>
    /// <returns>
    ///     If the lock was acquired, the value <c>true</c>; otherwise, the value <c>false</c>.
    /// </returns>
    /// <seealso cref="critical_section::unlock Method"/>
    /**/
    _CRTIMP bool try_lock();

    /// <summary>
    ///     Unlocks the critical section.
    /// </summary>
    /// <remarks>
    ///     If the lock is not held by the calling thread, an <see cref="improper_unlock Class">improper_unlock</see> exception will be thrown.
    /// </remarks>
    /// <seealso cref="critical_section::lock Method"/>
    /// <seealso cref="critical_section::try_lock Method"/>
    /**/
    _CRTIMP void unlock();

    /// <summary>
    ///     A reference to a <c>critical_section</c> object.
    /// </summary>
    /**/
    typedef critical_section& native_handle_type;

    /// <summary>
    ///     Returns a platform specific native handle, if one exists.
    /// </summary>
    /// <returns>
    ///     A reference to the critical section.
    /// </returns>
    /// <remarks>
    ///     A <c>critical_section</c> object is not associated with a platform specific native handle for the Windows operating system.
    ///     The method simply returns a reference to the object itself.
    /// </remarks>
    /**/
    _CRTIMP native_handle_type native_handle();

    /// <summary>
    ///     Guarantees that if any context holds the lock at the time the method is called, that context has released
    ///     the lock before this method returns.
    /// </summary>
    /// <remarks>
    ///     If no context holds the lock at the instant this method is called, it returns instantly.
    /// </remarks>
    /**/
    void _Flush_current_owner();

    /// <summary>
    ///     Acquires this critical section given a specific node to lock.
    /// </summary>
    /// <param name="_PLockingNode">
    ///     The node that needs to own the lock.
    /// </param>
    /// <param name="_FHasExternalNode">
    ///     An indication if the node being locked is external to the critical_section.
    /// </param>
    /// <remarks>
    ///     If the lock is already held by the calling context, an <see cref="improper_lock Class">.improper_lock</see> exception will be thrown.
    /// </remarks>
    /**/
    void _Acquire_lock(void * _PLockingNode, bool _FHasExternalNode);

    /// <summary>
    ///     An exception safe RAII wrapper for a <c>critical_section</c> object.
    /// </summary>
    /**/
    class scoped_lock
    {
    public:

        /// <summary>
        ///     Constructs a <c>scoped_lock</c> object and acquires the <c>critical_section</c> object passed in the <paramref name="_Critical_section"/>
        ///     parameter.  If the critical section is held by another thread, this call will block.
        /// </summary>
        /// <param name="_Critical_section">
        ///     The critical section to lock.
        /// </param>
        /// <seealso cref="critical_section Class"/>
        /**/
        explicit _CRTIMP scoped_lock(critical_section& _Critical_section);

        /// <summary>
        ///     Destroys a <c>scoped_lock</c> object and releases the critical section supplied in its constructor.
        /// </summary>
        /// <seealso cref="critical_section Class"/>
        /**/
        _CRTIMP ~scoped_lock();

    private:

        critical_section& _M_critical_section;
        _CONCRT_BUFFER _M_node[(2 * sizeof(void *) + 1 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

        scoped_lock(const scoped_lock&);                    // no copy constructor
        scoped_lock const & operator=(const scoped_lock&);  // no assignment operator
    };

private:
    /// <summary>
    ///     The node allocated on the stack never really owns the lock. The reason for that is that
    ///     it would go out of scope and its insides would not be visible in unlock() where it would potentially
    ///     need to unblock the next in the queue. Instead, its state is transferred to the internal
    ///     node which is used as a scratch node.
    /// </summary>
    /// <param name="_PLockingNode">
    ///     The node that needs to own the lock.
    /// </param>
    /**/
    void _Switch_to_active(void * _PLockingNode);

    _CONCRT_BUFFER  _M_activeNode[(2 * sizeof(void *) + 1 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    void * volatile _M_pHead;
    void * volatile _M_pTail;

    /// <summary>
    ///     Hide copy constructor for a critical section
    /// </summary>
    /**/
    critical_section(const critical_section&);

    /// <summary>
    ///     Hide assignment operator for a critical section
    /// </summary>
    /**/
    critical_section& operator=(const critical_section&);
};

/// <summary>
///    A writer-preference queue-based reader-writer lock with local only spinning.  The lock grants first in - first out (FIFO) access to writers
///    and starves readers under a continuous load of writers.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Synchronization Data Structures"/>.
/// </remarks>
/// <seealso cref="critical_section Class"/>
/**/
class reader_writer_lock
{
public:

    /// <summary>
    ///     Constructs a new <c>reader_writer_lock</c> object.
    /// </summary>
    /**/
    _CRTIMP reader_writer_lock();

    /// <summary>
    ///     Destroys the <c>reader_writer_lock</c> object.
    /// </summary>
    /// <remarks>
    ///     It is expected that the lock is no longer held when the destructor runs.  Allowing the reader writer lock to destruct with the lock
    ///     still held results in undefined behavior.
    /// </remarks>
    /**/
    _CRTIMP ~reader_writer_lock();

    /// <summary>
    ///     Acquires the reader-writer lock as a writer.
    /// </summary>
    /// <remarks>
    ///     It is often safer to utilize the <see cref="reader_writer_lock::scoped_lock Class">scoped_lock</see> construct to acquire and release
    ///     a <c>reader_writer_lock</c> object as a writer in an exception safe way.
    ///     <para>Once a writer attempts to acquire the lock, any future readers will block until the writers have successfully acquired
    ///     and released the lock. This lock is biased towards writers and can starve readers under a continuous load of writers.</para>
    ///     <para>Writers are chained so that a writer exiting the lock releases the next writer in line.</para>
    ///     <para>If the lock is already held by the calling context, an <see cref="improper_lock Class">improper_lock</see> exception will be
    ///     thrown.</para>
    /// </remarks>
    /// <seealso cref="reader_writer_lock::unlock Method"/>
    /**/
    _CRTIMP void lock();

    /// <summary>
    ///     Attempts to acquire the reader-writer lock as a writer without blocking.
    /// </summary>
    /// <returns>
    ///     If the lock was acquired, the value <c>true</c>; otherwise, the value <c>false</c>.
    /// </returns>
    /// <seealso cref="reader_writer_lock::unlock Method"/>
    /**/
    _CRTIMP bool try_lock();

    /// <summary>
    ///     Acquires the reader-writer lock as a reader. If there are writers, active readers have to wait until they are done.
    ///     The reader simply registers an interest in the lock and waits for writers to release it.
    /// </summary>
    /// <remarks>
    ///     It is often safer to utilize the <see cref="reader_writer_lock::scoped_lock_read Class">scoped_lock_read</see> construct to acquire
    ///     and release a <c>reader_writer_lock</c> object as a reader in an exception safe way.
    ///     <para>If there are writers waiting on the lock, the reader will wait until all writers in line have acquired
    ///     and released the lock.  This lock is biased towards writers and can starve readers under a continuous load of writers.</para>
    /// </remarks>
    /// <seealso cref="reader_writer_lock::unlock Method"/>
    /**/
    _CRTIMP void lock_read();

    /// <summary>
    ///     Attempts to acquire the reader-writer lock as a reader without blocking.
    /// </summary>
    /// <returns>
    ///     If the lock was acquired, the value <c>true</c>; otherwise, the value <c>false</c>.
    /// </returns>
    /// <seealso cref="reader_writer_lock::unlock Method"/>
    /**/
    _CRTIMP bool try_lock_read();

    /// <summary>
    ///     Unlocks the reader-writer lock based on who locked it, reader or writer.
    /// </summary>
    /// <remarks>
    ///     If there are writers waiting on the lock, the release of the lock will always go to the next writer in FIFO
    ///     order.   This lock is biased towards writers and can starve readers under a continuous load of writers.
    /// </remarks>
    /// <seealso cref="reader_writer_lock::lock Method"/>
    /// <seealso cref="reader_writer_lock::lock_read Method"/>
    /// <seealso cref="reader_writer_lock::try_lock Method"/>
    /// <seealso cref="reader_writer_lock::try_lock_read Method"/>
    /**/
    _CRTIMP void unlock();

    /// <summary>
    ///     Acquires a write lock given a specific write node to lock.
    /// </summary>
    /// <param name="_PLockingNode">
    ///     The node that needs to own the lock.
    /// </param>
    /// <param name="_FHasExternalNode">
    ///     An indication if the node being locked is external to the <c>reader_writer_lock</c> object.
    /// </param>
    /// <remarks>
    ///     If the lock is already held by the calling context, an <see cref="improper_lock Class">.improper_lock</see> exception will be
    ///     thrown.
    /// </remarks>
    /**/
    void _Acquire_lock(void * _PLockingNode, bool _FHasExternalNode);

    /// <summary>
    ///     An exception safe RAII wrapper that can be used to acquire <c>reader_writer_lock</c> lock objects as a writer.
    /// </summary>
    /**/
    class scoped_lock
    {
    public:
        /// <summary>
        ///     Constructs a <c>scoped_lock</c> object and acquires the <c>reader_writer_lock</c> object passed in the
        ///     <paramref name="_Reader_writer_lock"/> parameter as a writer.  If the lock is held by another thread, this call will block.
        /// </summary>
        /// <param name="_Reader_writer_lock">
        ///     The <c>reader_writer_lock</c> object to acquire as a writer.
        /// </param>
        /**/
        explicit _CRTIMP scoped_lock(reader_writer_lock& _Reader_writer_lock);

        /// <summary>
        ///     Destroys a <c>reader_writer_lock</c> object and releases the lock supplied in its constructor.
        /// </summary>
        /**/
        _CRTIMP ~scoped_lock();

    private:

        reader_writer_lock& _M_reader_writer_lock;
        _CONCRT_BUFFER _M_writerNode[(2 * sizeof(void *) + 1 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

        scoped_lock(const scoped_lock&);                    // no copy constructor
        scoped_lock const & operator=(const scoped_lock&);  // no assignment operator
    };

    /// <summary>
    ///     An exception safe RAII wrapper that can be used to acquire <c>reader_writer_lock</c> lock objects as a reader.
    /// </summary>
    /**/
    class scoped_lock_read
    {
    public:
        /// <summary>
        ///     Constructs a <c>scoped_lock_read</c> object and acquires the <c>reader_writer_lock</c> object passed in the
        ///     <paramref name="_Reader_writer_lock"/> parameter as a reader.  If the lock is held by another thread as a writer or there
        ///     are pending writers, this call will block.
        /// </summary>
        /// <param name="_Reader_writer_lock">
        ///     The <c>reader_writer_lock</c> object to acquire as a reader.
        /// </param>
        /**/
        explicit _CRTIMP scoped_lock_read(reader_writer_lock& _Reader_writer_lock);

        /// <summary>
        ///     Destroys a <c>scoped_lock_read</c> object and releases the lock supplied in its constructor.
        /// </summary>
        /**/
        _CRTIMP ~scoped_lock_read();

    private:

        reader_writer_lock& _M_reader_writer_lock;

        scoped_lock_read(const scoped_lock_read&);                    // no copy constructor
        scoped_lock_read const & operator=(const scoped_lock_read&);  // no assignment operator
    };

private:

    /// <summary>
    ///     Called for the first context in the writer queue. It sets the queue head and it tries to
    ///     claim the lock if readers are not active.
    /// </summary>
    /// <param name="_PWriter">
    ///     The first writer in the queue.
    /// </param>
    /**/
    bool _Set_next_writer(void * _PWriter);

    /// <summary>
    ///     Called when writers are done with the lock, or when lock was free for claiming by
    ///     the first reader coming in. If in the meantime there are more writers interested
    ///     the list of readers is finalized and they are convoyed, while head of the list
    ///     is reset to NULL.
    /// </summary>
    /// <returns>
    ///     Pointer to the head of the reader list.
    /// </returns>
    /**/
    void * _Get_reader_convoy();

    /// <summary>
    ///     Called from unlock() when a writer is holding the lock. Writer unblocks the next writer in the list
    ///     and is being retired. If there are no more writers, but there are readers interested, then readers
    ///     are unblocked.
    /// </summary>
    /**/
    void _Unlock_writer();

    /// <summary>
    ///     Called from unlock() when a reader is holding the lock. Reader count is decremented and if this
    ///     is the last reader it checks whether there are interested writers that need to be unblocked.
    /// </summary>
    /**/
    void _Unlock_reader();

    /// <summary>
    ///     When the last writer leaves the lock, it needs to reset the tail to NULL so that the next coming
    ///     writer would know to try to grab the lock. If the CAS to NULL fails, then some other writer
    ///     managed to grab the tail before the reset, so this writer needs to wait until the link to
    ///     the next writer is complete before trying to release the next writer.
    /// </summary>
    /// <param name="_PWriter">
    ///     Last writer in the queue.
    /// </param>
    /**/
    void _Remove_last_writer(void * _PWriter);

    /// <summary>
    ///     The writer node allocated on the stack never really owns the lock. The reason for that is that
    ///     it would go out of scope and its insides would not be visible in unlock() where it would potentially
    ///     need to unblock the next writer in the queue. Instead, its state is transferred to the internal
    ///     writer node which is used as a scratch node.
    /// </summary>
    /// <param name="_PWriter">
    ///     The writer that needs to own the lock.
    /// </param>
    /**/
    void _Switch_to_active(void * _PWriter);

    _CONCRT_BUFFER _M_activeWriter[(2 * sizeof(void *) + 1 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    void *         _M_pReaderHead;
    void *         _M_pWriterHead;
    void *         _M_pWriterTail;
    volatile long  _M_lockState;

    /// <summary>
    ///     Hide copy constructor for a reader_writer_lock
    /// </summary>
    /**/
    reader_writer_lock (const reader_writer_lock& _Lock);

    /// <summary>
    ///     Hide assignment operator for a reader_writer_lock
    /// </summary>
    /**/
    reader_writer_lock& operator=(const reader_writer_lock& _Lock);
};

/// <summary>
///     Value indicating that a wait timed out.
/// </summary>
/// <seealso cref="event Class"/>
/// <seealso cref="event::wait Method"/>
/// <seealso cref="event::wait_for_multiple Method"/>
/**/
const size_t COOPERATIVE_WAIT_TIMEOUT = SIZE_MAX;

/// <summary>
///     Value indicating that a wait should never time out.
/// </summary>
/// <seealso cref="event Class"/>
/// <seealso cref="event::wait Method"/>
/// <seealso cref="event::wait_for_multiple Method"/>
/**/
const unsigned int COOPERATIVE_TIMEOUT_INFINITE = (unsigned int)-1;

/// <summary>
///     A manual reset event which is explicitly aware of the Concurrency Runtime.
/// </summary>
/// <remarks>
///     For more information, see <see cref="Synchronization Data Structures"/>.
/// </remarks>
/**/
class event
{
public:

    /// <summary>
    ///     Constructs a new event.
    /// </summary>
    /**/
    _CRTIMP event();

    /// <summary>
    ///     Destroys an event.
    /// </summary>
    /// <remarks>
    ///     It is expected that there are no threads waiting on the event when the destructor runs.  Allowing the event to destruct with threads
    ///     still waiting upon it results in undefined behavior.
    /// </remarks>
    /**/
    _CRTIMP ~event();

    /// <summary>
    ///     Waits for the event to become signaled.
    /// </summary>
    /// <param name="_Timeout">
    ///     Indicates the number of milliseconds before the wait times out.  The value <c>COOPERATIVE_TIMEOUT_INFINITE</c> signifies that
    ///     there is no timeout.
    /// </param>
    /// <returns>
    ///     If the wait was satisfied, the value <c>0</c> is returned; otherwise, the value <c>COOPERATIVE_WAIT_TIMEOUT</c> to indicate that
    ///     the wait timed out without the event becoming signaled.
    /// </returns>
    /// <seealso cref="event::set Method"/>
    /// <seealso cref="COOPERATIVE_TIMEOUT_INFINITE Variable">COOPERATIVE_TIMEOUT_INFINITE</seealso>
    /// <seealso cref="COOPERATIVE_WAIT_TIMEOUT Variable">COOPERATIVE_WAIT_TIMEOUT</seealso>
    /**/
    _CRTIMP size_t wait(unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

    /// <summary>
    ///     Signals the event.
    /// </summary>
    /// <remarks>
    ///     Signaling the event may cause an arbitrary number of contexts which are waiting on the event to become runnable.
    /// </remarks>
    /// <seealso cref="event::wait Method"/>
    /// <seealso cref="event::reset Method"/>
    /**/
    _CRTIMP void set();

    /// <summary>
    ///     Resets the event to a non-signaled state.
    /// </summary>
    /// <seealso cref="event::set Method"/>
    /// <seealso cref="event::wait Method"/>
    /**/
    _CRTIMP void reset();

    /// <summary>
    ///     Waits for multiple events to become signaled.
    /// </summary>
    /// <param name="_PPEvents">
    ///     An array of events to wait on.  The number of events within the array is indicated by the <paramref name="_Count"/> parameter.
    /// </param>
    /// <param name="_Count">
    ///     The count of events within the array supplied in the <paramref name="_PPEvents"/> parameter.
    /// </param>
    /// <param name="_FWaitAll">
    ///     If set to the value <c>true</c>, the parameter specifies that all events within the array supplied in the <paramref name="_PPEvents"/>
    ///     parameter must become signaled in order to satisfy the wait.  If set to the value <c>false</c>, it specifies that any event within the
    ///     array supplied in the <paramref name="_PPEvents"/>  parameter becoming signaled will satisfy the wait.
    /// </param>
    /// <param name="_Timeout">
    ///     Indicates the number of milliseconds before the wait times out.  The value <c>COOPERATIVE_TIMEOUT_INFINITE</c> signifies that
    ///     there is no timeout.
    /// </param>
    /// <returns>
    ///     If the wait was satisfied, the index within the array supplied in the <paramref name="_PPEvents"/> parameter which satisfied
    ///     the wait condition; otherwise, the value <c>COOPERATIVE_WAIT_TIMEOUT</c> to indicate that the wait timed out without the condition
    ///     being satisfied.
    /// </returns>
    /// <remarks>
    ///     If the parameter <paramref name="_FWaitAll"/> is set to the value <c>true</c> to indicate that all events must become signaled to satisfy
    ///     the wait, the index returned by the function carries no special significance other than the fact that it is not the value
    ///     <c>COOPERATIVE_WAIT_TIMEOUT</c>.
    /// </remarks>
    /// <seealso cref="event::wait Method"/>
    /// <seealso cref="COOPERATIVE_TIMEOUT_INFINITE Variable">COOPERATIVE_TIMEOUT_INFINITE</seealso>
    /// <seealso cref="COOPERATIVE_WAIT_TIMEOUT Variable">COOPERATIVE_WAIT_TIMEOUT</seealso>
    /**/
    _CRTIMP static size_t __cdecl wait_for_multiple(event ** _PPEvents, size_t _Count, bool _FWaitAll, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

private:

    // Prevent bad usage of copy-constructor and copy-assignment
    event(const event& _Event);
    event& operator=(const event& _Event);

    void * volatile _M_pWaitChain;
    void * _M_pResetChain;
    Concurrency::critical_section _M_lock;
};

namespace details
{
    // This is a non-reentrant lock wrapper around the ConcRT critical-section
    // and used by agents/messaging
    class _NonReentrantPPLLock
    {
    public:

        // Constructor for _NonReentrantPPLLock
        _CRTIMP _NonReentrantPPLLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire(void * _Lock_node);

        // Releases the lock
        _CRTIMP void _Release();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            _CRTIMP explicit _Scoped_lock(_NonReentrantPPLLock& _Lock);

            // Destroys the holder and releases the lock
            _CRTIMP ~_Scoped_lock();

        private:
            _NonReentrantPPLLock& _M_lock;
            _CONCRT_BUFFER  _M_lockNode[(3 * sizeof(void *) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        // critical_section
        Concurrency::critical_section _M_criticalSection;
    };

    // This is a reentrant lock implemented using the ConcRT critical section
    class _ReentrantPPLLock
    {
    public:
        // Constructor for _ReentrantPPLLock
        _CRTIMP _ReentrantPPLLock();

        // Acquire the lock, spin if necessary
        _CRTIMP void _Acquire(void * _Lock_node);

        // Releases the lock
        _CRTIMP void _Release();

        // An exception safe RAII wrapper.
        class _Scoped_lock
        {
        public:
            // Constructs a holder and acquires the specified lock
            _CRTIMP explicit _Scoped_lock(_ReentrantPPLLock& _Lock);

            // Destroys the holder and releases the lock
            _CRTIMP ~_Scoped_lock();

        private:
            _ReentrantPPLLock& _M_lock;
            _CONCRT_BUFFER  _M_lockNode[(3 * sizeof(void *) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

            _Scoped_lock(const _Scoped_lock&);                    // no copy constructor
            _Scoped_lock const & operator=(const _Scoped_lock&);  // no assignment operator
        };

    private:
        // critical_section
        Concurrency::critical_section _M_criticalSection;

        // The number of times this lock has been taken recursively
        long _M_recursionCount;

        // The current owner of the lock
        volatile long _M_owner;
    };

    struct _Chore
    {
    protected:
        // Constructors.
        explicit _Chore(TaskProc _PFunction) : m_pFunction(_PFunction)
        {
        }

        _Chore()
        {
        }

        virtual ~_Chore()
        {
        }

    public:

        // The function which invokes the work of the chore.
        TaskProc m_pFunction;
    };

    // _UnrealizedChore represents an unrealized chore -- a unit of work that scheduled in a work
    // stealing capacity.  Some higher level construct (language or library) will map atop this to provide
    // an usable abstraction to clients.
    class _UnrealizedChore : public _Chore, public _AllocBase
    {
    public:
        // Constructor for an unrealized chore.
        _UnrealizedChore() :
            _M_pTaskCollection(NULL)
        {
        }

        // Method that executes the unrealized chore.
        void _Invoke()
        {
            _M_pChoreFunction(this);
        }

        // Sets the attachment state of the chore at the time of stealing.
        void _SetDetached(bool _FDetached);

        // Returns the owning collection of the chore.
        Concurrency::details::_TaskCollectionBase* _OwningCollection() const
        {
            return _M_pTaskCollection;
        }

        // Set flag that indicates whether the scheduler owns the lifetime of the object and is responsible for freeing it.
        // The flag is ignored by _StructuredTaskCollection
        void _SetRuntimeOwnsLifetime(bool fValue)
        {
            _M_fRuntimeOwnsLifetime = fValue;
        }

        // Returns the flag that indicates whether the scheduler owns the lifetime of the object and is responsible for freeing it.
        // The flag is ignored by _StructuredTaskCollection
        bool _GetRuntimeOwnsLifetime() const
        {
            return _M_fRuntimeOwnsLifetime;
        }

        // Allocator to be used when runtime owns lifetime.
        template <typename _ChoreType, typename _Function>
        static _ChoreType * _InternalAlloc(const _Function& _Func)
        {
            _ChoreType * _Chore = new _ChoreType(_Func);
            _Chore->_M_fRuntimeOwnsLifetime = true;
            return _Chore;
        }

    protected:
        // Invocation bridge between the _UnrealizedChore and PPL.
        template <typename _ChoreType>
        static void __cdecl _InvokeBridge(_ChoreType * _PChore)
        {
            (*_PChore)();
        }

        // Place associated task collection in a safe state.
        _CRTIMP void _CheckTaskCollection();

    private:

        friend class _StructuredTaskCollection;
        friend class _TaskCollection;
        typedef void (__cdecl * CHOREFUNC)(_UnrealizedChore * _PChore);

        // The collection of work to which this particular chore belongs.
        Concurrency::details::_TaskCollectionBase * _M_pTaskCollection;

        // Internal invocation inside the scheduler.
        CHOREFUNC _M_pChoreFunction;

        // Indicates whether the scheduler owns the lifetime of the object and is responsible for freeing it.
        // This flag is ignored by _StructuredTaskCollection
        bool _M_fRuntimeOwnsLifetime;

        // An indication of whether the chore (if stolen) was detached.
        bool _M_fDetached;

        // The internal wrapper around invocation of stolen structured chores.
        __declspec(noinline)
        static void __cdecl _StructuredChoreWrapper(_UnrealizedChore * _PChore);

        // The internal wrapper around invocation of stolen unstructured chores.
        __declspec(noinline)
        static void __cdecl _UnstructuredChoreWrapper(_UnrealizedChore * _PChore);

        // To free memory allocated with _InternalAlloc.
        static void _InternalFree(_UnrealizedChore * _PChore);
    };

    // Represents possible results of waiting on a task collection.
    enum _TaskCollectionStatus
    {
        _NotComplete,
        _Completed,
        _Canceled
    };

    // _TaskCollectionBase represents an abstract set of work and provides shared waiting semantics for stolen work.
    class _TaskCollectionBase
    {
    public:
        // Constructs a new task collection.
        _TaskCollectionBase() :
            _M_completedStolenChores(_CollectionNotInitialized),
            _M_unpoppedChores(0),
            _M_pException(NULL),
            _M_inliningDepth(_S_notInlined)
        {
        }

        // Returns the owning context of the task collection.
        void * _OwningContext() const
        {
            return _M_pOwningContext;
        }

        // Returns the inlining depth.
        int _InliningDepth() const
        {
            return _M_inliningDepth;
        }

        // Returns whether this is a structured collection or not.
        bool _IsStructured()
        {
            return (_M_inlineFlags & _S_structured) != 0;
        }

    protected:

        friend class Concurrency::details::_UnrealizedChore;

        enum _TaskCollectionBaseState
        {
            _CollectionNotInitialized = LONG_MIN,
            _CollectionInitializationInProgress = LONG_MIN+1,
            _CollectionInitialized = 0
        };

        // Returns the exception portion of _M_pException.
        std::exception_ptr * _Exception() const
        {
            return (std::exception_ptr *) ((size_t)_M_pException & ~_S_cancelBitsMask);
        }

        // Indicates whether or not this task collection has an abnormal exit.
        bool _IsAbnormalExit() const
        {
            return _M_pException != NULL;
        }

        // Returns the cancel flags.
        size_t _CancelState() const
        {
            return (size_t) _M_pException & _S_cancelBitsMask;
        }

        // Returns whether or not the collection is marked for cancellation.
        bool _IsMarkedForCancellation() const
        {
            return (_CancelState() & _S_cancelBitsMask) != 0;
        }

        // Returns whether an inline cancellation was performed.
        bool _PerformedInlineCancel() const
        {
            _ASSERTE(_CancelState() != _S_cancelStarted);
            return _CancelState() == _S_cancelShotdownOwner;
        }

        // Returns the parent collection safely.
        _TaskCollectionBase *_SafeGetParent()
        {
            return ((_M_inliningDepth != _S_notInlined) ? _M_pParent : NULL);
        }

        // Called in order to execute a supposed interruption point.
        void _Interrupt(bool _FLocalCondition, int _LocalFlags = 0);

        // Called in order to determine whether this task collection will interrupt for a pending cancellation at or above it.
        bool _WillInterruptForPendingCancel();

        // Called when an exception is raised on a chore on a given task collection, this makes a determination of what to do with the exception
        // and squirrels it away for potential transport back to the thread performing a join on a chore collection.
        void _RaisedException();

        // Potentially rethrows the exception which was set with _RaisedException.  The caller has responsibility to ensure that _RaisedException
        //  was called prior to calling this and that _M_pException has progressed beyond the _S_nonNull state.
        void _RethrowException();

        // Marks the collection for cancellation and returns whether the collection was thus marked.
        bool _MarkCancellation();

        // Finishes the cancellation state (changing from _S_cancelStarted to one of the other states).  Note that only the
        // thread which successfully marked cancellation may call this.
        void _FinishCancelState(size_t _NewCancelState);

        // Called when a cancellation is raised on a chore on a given task collection.  This makes a determination of what to do with the exception
        // and squirrels it away for potential transport back to the thread performing a join on a chore collection.  Note that every other exception
        // has precedence over a cancellation.
        void _RaisedCancel();

        // Tracks the parent collection.  (e.g.: A task collection B created during execution of a chore C on task collection A is
        // considered a child of A).
        _TaskCollectionBase * _M_pParent;

        // Tracks the inlining depth of this collection for cancellation purposes and packs a series of definition bits.
        int _M_inliningDepth : 28;
        int _M_inlineFlags : 4;

        // The context which owns the task collection.  This is the context where the collection is created.
        void * _M_pOwningContext;

        // The number of unpopped chores associated with the task collection (set by the derived
        // class during chore association.
        long _M_unpoppedChores;

        // The number of stolen chores executed so far.
        volatile long _M_completedStolenChores;

        // The stored exception which has been marshaled from the thread a stolen chore ran upon to the thread that is waiting on the
        // task collection.
        //
        // The lower two bits of _M_pException are utilized for the cancellation state machine.  The upper 30 are the exception pointer.  This implies
        // that the excepiton pointer must be 4-byte aligned.  Because of intermediate states, the exception pointer cannot be between 0x8 and 0xF.  The heap should
        // not be allocating such...
        //
        std::exception_ptr * _M_pException;

        // Cancellation states
        static const size_t _S_cancelBitsMask = 0x3;
        static const size_t _S_cancelNone = 0x0;
        static const size_t _S_cancelStarted = 0x1;
        static const size_t _S_cancelDeferredShootdownOwner = 0x2;
        static const size_t _S_cancelShotdownOwner = 0x3;

        // Intermediate exceptions.
        static const size_t _S_nonNull = 0x8;
        static const size_t _S_cancelException = 0xC;

        // initialization state for inlining depth.
        static const int _S_notInlined = -1;

        // Inline flags.
        static const int _S_structured = 0x00000001;
        static const int _S_localCancel = 0x00000002;
        static const int _S_reserved = 0x0000000C;

    private:

        // Prevent bad usage of copy-constructor and copy-assignment
        _TaskCollectionBase(const _TaskCollectionBase& _Collection);
        _TaskCollectionBase& operator=(const _TaskCollectionBase& _Collection);
    };

    /// <summary>
    ///     Structured task collections represent groups of work which follow a strictly LIFO ordered paradigm
    ///     queueing and waiting respectively.  They can only be waited upon once (via object destructor)
    ///     and can only be used from a single thread of execution.
    /// </summary>
    /**/
    class _StructuredTaskCollection : public _TaskCollectionBase
    {
    public:

        /// <summary>
        ///     Construct a new structured task collection.
        /// </summary>
        /**/
        _StructuredTaskCollection()
        {
            _M_pOwningContext = NULL;
            _M_inlineFlags = _S_structured;
        }

        /// <summary>
        ///     Destruct a task collection and wait on all associated work to finish. Clients must call '_StructuredTaskCollection::Wait'
        ///     or '_StructuredTaskCollection::Cancel' prior to destructing the object.  If there are chores remaining in the queues, an
        ///     exception (missing_wait) is thrown. If the destructor is running due to exception unwinding, it will abort any scheduled work.
        ///     If another exception occurs because work is aborted, the process will terminate (C++ semantics).
        /// </summary>
        /**/
        ~_StructuredTaskCollection()
        {
            if (!_TaskCleanup())
            {
                throw missing_wait();
            }
        }

        /// <summary>
        ///     Schedules a chore that may potentially run in parallel.  The chore is pushed onto the associated workstealing queue, and
        ///     will be executed in a LIFO order.Note that the specified chore may only be scheduled upon a single task collection at a given time.
        ///     Any attempt to schedule the same chore multiple times on one or more task collection will result in an invalid_multiple_scheduling
        ///     exception.  Once the chore is guaranteed to have been executed (via calling the Wait method), it can be rescheduled to an
        ///     arbitrary task collection.
        /// </summary>
        /// <param name="_PChore">
        ///     The new unrealized chore to schedule
        /// </param>
        /**/
        _CRTIMP void _Schedule(_UnrealizedChore * _PChore);

        /// <summary>
        ///     Cancels work on the task collection.
        /// </summary>
        /**/
        _CRTIMP void _Cancel();

        /// <summary>
        ///     Informs the caller whether or not the task collection is currently in the midst of cancellation.  Note that this
        ///     does not necessarily indicate that Cancel was called on the collection (although such certainly qualifies this function
        ///     to return true).  It may be the case that the task collection is executing inline and a task collection further up in the work
        ///     tree was canceled.  In cases such as these where we can determine ahead of time that cancellation will flow through
        ///     this collection, true will be returned as 